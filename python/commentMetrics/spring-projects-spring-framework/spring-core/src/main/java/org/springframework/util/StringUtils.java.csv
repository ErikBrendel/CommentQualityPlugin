# id;timestamp;commentText;codeText;commentWords;codeWords
StringUtils -> public static boolean containsWhitespace(@Nullable CharSequence str);1495868221;Check whether the given {@code CharSequence} contains any whitespace characters._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(@Nullable CharSequence str) {_		if (!hasLength(str)) {_			return false__		}__		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,any,whitespace,characters,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,nullable,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(@Nullable CharSequence str);1496243689;Check whether the given {@code CharSequence} contains any whitespace characters._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(@Nullable CharSequence str) {_		if (!hasLength(str)) {_			return false__		}__		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,any,whitespace,characters,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,nullable,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(@Nullable CharSequence str);1496259743;Check whether the given {@code CharSequence} contains any whitespace characters._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(@Nullable CharSequence str) {_		if (!hasLength(str)) {_			return false__		}__		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,any,whitespace,characters,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,nullable,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(@Nullable CharSequence str);1496837955;Check whether the given {@code CharSequence} contains any whitespace characters._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(@Nullable CharSequence str) {_		if (!hasLength(str)) {_			return false__		}__		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,any,whitespace,characters,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,nullable,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(@Nullable CharSequence str);1499270197;Check whether the given {@code CharSequence} contains any whitespace characters._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(@Nullable CharSequence str) {_		if (!hasLength(str)) {_			return false__		}__		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,any,whitespace,characters,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,nullable,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(@Nullable CharSequence str);1508667152;Check whether the given {@code CharSequence} contains any whitespace characters._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(@Nullable CharSequence str) {_		if (!hasLength(str)) {_			return false__		}__		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,any,whitespace,characters,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,nullable,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(@Nullable CharSequence str);1508675477;Check whether the given {@code CharSequence} contains any whitespace characters._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(@Nullable CharSequence str) {_		if (!hasLength(str)) {_			return false__		}__		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,any,whitespace,characters,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,nullable,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(@Nullable CharSequence str);1508843807;Check whether the given {@code CharSequence} contains any whitespace characters._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(@Nullable CharSequence str) {_		if (!hasLength(str)) {_			return false__		}__		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,any,whitespace,characters,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,nullable,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(@Nullable CharSequence str);1516903831;Check whether the given {@code CharSequence} contains any whitespace characters._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(@Nullable CharSequence str) {_		if (!hasLength(str)) {_			return false__		}__		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,any,whitespace,characters,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,nullable,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(@Nullable CharSequence str);1519295386;Check whether the given {@code CharSequence} contains any whitespace characters._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(@Nullable CharSequence str) {_		if (!hasLength(str)) {_			return false__		}__		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,any,whitespace,characters,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,nullable,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(@Nullable CharSequence str);1519308837;Check whether the given {@code CharSequence} contains any whitespace characters._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(@Nullable CharSequence str) {_		if (!hasLength(str)) {_			return false__		}__		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,any,whitespace,characters,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,nullable,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(@Nullable CharSequence str);1519588127;Check whether the given {@code CharSequence} contains any whitespace characters._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(@Nullable CharSequence str) {_		if (!hasLength(str)) {_			return false__		}__		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,any,whitespace,characters,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,nullable,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(@Nullable CharSequence str);1522332352;Check whether the given {@code CharSequence} contains any whitespace characters._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(@Nullable CharSequence str) {_		if (!hasLength(str)) {_			return false__		}__		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,any,whitespace,characters,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,nullable,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(@Nullable CharSequence str);1525166194;Check whether the given {@code CharSequence} contains any whitespace characters._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(@Nullable CharSequence str) {_		if (!hasLength(str)) {_			return false__		}__		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,any,whitespace,characters,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,nullable,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(@Nullable CharSequence str);1530188116;Check whether the given {@code CharSequence} contains any whitespace characters._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(@Nullable CharSequence str) {_		if (!hasLength(str)) {_			return false__		}__		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,any,whitespace,characters,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,nullable,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(@Nullable CharSequence str);1531843079;Check whether the given {@code CharSequence} contains any whitespace characters._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(@Nullable CharSequence str) {_		if (!hasLength(str)) {_			return false__		}__		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,any,whitespace,characters,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,nullable,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(@Nullable CharSequence str);1531905026;Check whether the given {@code CharSequence} contains any whitespace characters._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(@Nullable CharSequence str) {_		if (!hasLength(str)) {_			return false__		}__		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,any,whitespace,characters,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,nullable,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(@Nullable CharSequence str);1533557519;Check whether the given {@code CharSequence} contains any whitespace characters._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(@Nullable CharSequence str) {_		if (!hasLength(str)) {_			return false__		}__		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,any,whitespace,characters,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,nullable,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(@Nullable CharSequence str);1533602820;Check whether the given {@code CharSequence} contains any whitespace characters._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(@Nullable CharSequence str) {_		if (!hasLength(str)) {_			return false__		}__		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,any,whitespace,characters,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,nullable,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(@Nullable CharSequence str);1535316501;Check whether the given {@code CharSequence} contains any whitespace characters._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(@Nullable CharSequence str) {_		if (!hasLength(str)) {_			return false__		}__		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,any,whitespace,characters,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,nullable,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(@Nullable CharSequence str);1550237113;Check whether the given {@code CharSequence} contains any whitespace characters._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(@Nullable CharSequence str) {_		if (!hasLength(str)) {_			return false__		}__		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,any,whitespace,characters,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,nullable,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(@Nullable CharSequence str);1550238935;Check whether the given {@code CharSequence} contains any whitespace characters._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(@Nullable CharSequence str) {_		if (!hasLength(str)) {_			return false__		}__		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,any,whitespace,characters,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,nullable,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static String trimAllWhitespace(String str);1328020251;Trim <i>all</i> whitespace from the given String:_leading, trailing, and inbetween characters._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		int index = 0__		while (sb.length() > index) {_			if (Character.isWhitespace(sb.charAt(index))) {_				sb.deleteCharAt(index)__			}_			else {_				index++__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,string,leading,trailing,and,inbetween,characters,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,int,index,0,while,sb,length,index,if,character,is,whitespace,sb,char,at,index,sb,delete,char,at,index,else,index,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1337236962;Trim <i>all</i> whitespace from the given String:_leading, trailing, and inbetween characters._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		int index = 0__		while (sb.length() > index) {_			if (Character.isWhitespace(sb.charAt(index))) {_				sb.deleteCharAt(index)__			}_			else {_				index++__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,string,leading,trailing,and,inbetween,characters,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,int,index,0,while,sb,length,index,if,character,is,whitespace,sb,char,at,index,sb,delete,char,at,index,else,index,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1356735495;Trim <i>all</i> whitespace from the given String:_leading, trailing, and inbetween characters._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		int index = 0__		while (sb.length() > index) {_			if (Character.isWhitespace(sb.charAt(index))) {_				sb.deleteCharAt(index)__			}_			else {_				index++__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,string,leading,trailing,and,inbetween,characters,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,int,index,0,while,sb,length,index,if,character,is,whitespace,sb,char,at,index,sb,delete,char,at,index,else,index,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1367955086;Trim <i>all</i> whitespace from the given String:_leading, trailing, and inbetween characters._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		int index = 0__		while (sb.length() > index) {_			if (Character.isWhitespace(sb.charAt(index))) {_				sb.deleteCharAt(index)__			}_			else {_				index++__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,string,leading,trailing,and,inbetween,characters,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,int,index,0,while,sb,length,index,if,character,is,whitespace,sb,char,at,index,sb,delete,char,at,index,else,index,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1380921248;Trim <i>all</i> whitespace from the given String:_leading, trailing, and inbetween characters._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		int index = 0__		while (sb.length() > index) {_			if (Character.isWhitespace(sb.charAt(index))) {_				sb.deleteCharAt(index)__			}_			else {_				index++__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,string,leading,trailing,and,inbetween,characters,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,int,index,0,while,sb,length,index,if,character,is,whitespace,sb,char,at,index,sb,delete,char,at,index,else,index,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1382750743;Trim <i>all</i> whitespace from the given String:_leading, trailing, and inbetween characters._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		int index = 0__		while (sb.length() > index) {_			if (Character.isWhitespace(sb.charAt(index))) {_				sb.deleteCharAt(index)__			}_			else {_				index++__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,string,leading,trailing,and,inbetween,characters,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,int,index,0,while,sb,length,index,if,character,is,whitespace,sb,char,at,index,sb,delete,char,at,index,else,index,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1385423968;Trim <i>all</i> whitespace from the given String:_leading, trailing, and in between characters._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		int index = 0__		while (sb.length() > index) {_			if (Character.isWhitespace(sb.charAt(index))) {_				sb.deleteCharAt(index)__			}_			else {_				index++__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,string,leading,trailing,and,in,between,characters,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,int,index,0,while,sb,length,index,if,character,is,whitespace,sb,char,at,index,sb,delete,char,at,index,else,index,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1400189212;Trim <i>all</i> whitespace from the given String:_leading, trailing, and in between characters._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		int index = 0__		while (sb.length() > index) {_			if (Character.isWhitespace(sb.charAt(index))) {_				sb.deleteCharAt(index)__			}_			else {_				index++__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,string,leading,trailing,and,in,between,characters,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,int,index,0,while,sb,length,index,if,character,is,whitespace,sb,char,at,index,sb,delete,char,at,index,else,index,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1400531359;Trim <i>all</i> whitespace from the given String:_leading, trailing, and in between characters._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		int index = 0__		while (sb.length() > index) {_			if (Character.isWhitespace(sb.charAt(index))) {_				sb.deleteCharAt(index)__			}_			else {_				index++__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,string,leading,trailing,and,in,between,characters,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,int,index,0,while,sb,length,index,if,character,is,whitespace,sb,char,at,index,sb,delete,char,at,index,else,index,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1402676350;Trim <i>all</i> whitespace from the given String:_leading, trailing, and in between characters._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,string,leading,trailing,and,in,between,characters,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1426267150;Trim <i>all</i> whitespace from the given String:_leading, trailing, and in between characters._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,string,leading,trailing,and,in,between,characters,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1429034538;Trim <i>all</i> whitespace from the given String:_leading, trailing, and in between characters._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,string,leading,trailing,and,in,between,characters,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1429034756;Trim <i>all</i> whitespace from the given {@code String}:_leading, trailing, and in between characters._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,code,string,leading,trailing,and,in,between,characters,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1431006895;Trim <i>all</i> whitespace from the given {@code String}:_leading, trailing, and in between characters._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,code,string,leading,trailing,and,in,between,characters,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1431007368;Trim <i>all</i> whitespace from the given {@code String}:_leading, trailing, and in between characters._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,code,string,leading,trailing,and,in,between,characters,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1449489126;Trim <i>all</i> whitespace from the given {@code String}:_leading, trailing, and in between characters._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,code,string,leading,trailing,and,in,between,characters,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1467730834;Trim <i>all</i> whitespace from the given {@code String}:_leading, trailing, and in between characters._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,code,string,leading,trailing,and,in,between,characters,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1472128018;Trim <i>all</i> whitespace from the given {@code String}:_leading, trailing, and in between characters._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,code,string,leading,trailing,and,in,between,characters,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1472202842;Trim <i>all</i> whitespace from the given {@code String}:_leading, trailing, and in between characters._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,code,string,leading,trailing,and,in,between,characters,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1473942665;Trim <i>all</i> whitespace from the given {@code String}:_leading, trailing, and in between characters._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,code,string,leading,trailing,and,in,between,characters,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1484248946;Trim <i>all</i> whitespace from the given {@code String}:_leading, trailing, and in between characters._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,code,string,leading,trailing,and,in,between,characters,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1484260238;Trim <i>all</i> whitespace from the given {@code String}:_leading, trailing, and in between characters._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,code,string,leading,trailing,and,in,between,characters,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1484694546;Trim <i>all</i> whitespace from the given {@code String}:_leading, trailing, and in between characters._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,code,string,leading,trailing,and,in,between,characters,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1487760984;Trim <i>all</i> whitespace from the given {@code String}:_leading, trailing, and in between characters._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,code,string,leading,trailing,and,in,between,characters,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1487778834;Trim <i>all</i> whitespace from the given {@code String}:_leading, trailing, and in between characters._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,code,string,leading,trailing,and,in,between,characters,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1491898314;Trim <i>all</i> whitespace from the given {@code String}:_leading, trailing, and in between characters._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,code,string,leading,trailing,and,in,between,characters,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1491903650;Trim <i>all</i> whitespace from the given {@code String}:_leading, trailing, and in between characters._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,code,string,leading,trailing,and,in,between,characters,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1495868221;Trim <i>all</i> whitespace from the given {@code String}:_leading, trailing, and in between characters._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,code,string,leading,trailing,and,in,between,characters,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1496243689;Trim <i>all</i> whitespace from the given {@code String}:_leading, trailing, and in between characters._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,code,string,leading,trailing,and,in,between,characters,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1496259743;Trim <i>all</i> whitespace from the given {@code String}:_leading, trailing, and in between characters._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,code,string,leading,trailing,and,in,between,characters,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1496837955;Trim <i>all</i> whitespace from the given {@code String}:_leading, trailing, and in between characters._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,code,string,leading,trailing,and,in,between,characters,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1499270197;Trim <i>all</i> whitespace from the given {@code String}:_leading, trailing, and in between characters._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,code,string,leading,trailing,and,in,between,characters,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1508667152;Trim <i>all</i> whitespace from the given {@code String}:_leading, trailing, and in between characters._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,code,string,leading,trailing,and,in,between,characters,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1508675477;Trim <i>all</i> whitespace from the given {@code String}:_leading, trailing, and in between characters._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,code,string,leading,trailing,and,in,between,characters,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1508843807;Trim <i>all</i> whitespace from the given {@code String}:_leading, trailing, and in between characters._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,code,string,leading,trailing,and,in,between,characters,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1516903831;Trim <i>all</i> whitespace from the given {@code String}:_leading, trailing, and in between characters._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,code,string,leading,trailing,and,in,between,characters,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1519295386;Trim <i>all</i> whitespace from the given {@code String}:_leading, trailing, and in between characters._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,code,string,leading,trailing,and,in,between,characters,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1519308837;Trim <i>all</i> whitespace from the given {@code String}:_leading, trailing, and in between characters._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,code,string,leading,trailing,and,in,between,characters,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1519588127;Trim <i>all</i> whitespace from the given {@code String}:_leading, trailing, and in between characters._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,code,string,leading,trailing,and,in,between,characters,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1522332352;Trim <i>all</i> whitespace from the given {@code String}:_leading, trailing, and in between characters._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,code,string,leading,trailing,and,in,between,characters,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1525166194;Trim <i>all</i> whitespace from the given {@code String}:_leading, trailing, and in between characters._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,code,string,leading,trailing,and,in,between,characters,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1530188116;Trim <i>all</i> whitespace from the given {@code String}:_leading, trailing, and in between characters._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,code,string,leading,trailing,and,in,between,characters,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1531843079;Trim <i>all</i> whitespace from the given {@code String}:_leading, trailing, and in between characters._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,code,string,leading,trailing,and,in,between,characters,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1531905026;Trim <i>all</i> whitespace from the given {@code String}:_leading, trailing, and in between characters._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,code,string,leading,trailing,and,in,between,characters,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1533557519;Trim <i>all</i> whitespace from the given {@code String}:_leading, trailing, and in between characters._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,code,string,leading,trailing,and,in,between,characters,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1533602820;Trim <i>all</i> whitespace from the given {@code String}:_leading, trailing, and in between characters._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,code,string,leading,trailing,and,in,between,characters,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1535316501;Trim <i>all</i> whitespace from the given {@code String}:_leading, trailing, and in between characters._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,code,string,leading,trailing,and,in,between,characters,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1550237113;Trim <i>all</i> whitespace from the given {@code String}:_leading, trailing, and in between characters._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,code,string,leading,trailing,and,in,between,characters,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static String trimAllWhitespace(String str);1550238935;Trim <i>all</i> whitespace from the given {@code String}:_leading, trailing, and in between characters._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimAllWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		int len = str.length()__		StringBuilder sb = new StringBuilder(str.length())__		for (int i = 0_ i < len_ i++) {_			char c = str.charAt(i)__			if (!Character.isWhitespace(c)) {_				sb.append(c)__			}_		}_		return sb.toString()__	};trim,i,all,i,whitespace,from,the,given,code,string,leading,trailing,and,in,between,characters,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,all,whitespace,string,str,if,has,length,str,return,str,int,len,str,length,string,builder,sb,new,string,builder,str,length,for,int,i,0,i,len,i,char,c,str,char,at,i,if,character,is,whitespace,c,sb,append,c,return,sb,to,string
StringUtils -> public static boolean isEmpty(Object str);1356735495;Check whether the given String is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(Object str);1367955086;Check whether the given String is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(Object str);1380921248;Check whether the given String is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(Object str);1382750743;Check whether the given String is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(Object str);1385423968;Check whether the given String is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(Object str);1400189212;Check whether the given String is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(Object str);1400531359;Check whether the given String is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(Object str);1402676350;Check whether the given String is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(Object str);1426267150;Check whether the given String is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(Object str);1429034538;Check whether the given String is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1_@see #isNotEmpty(CharSequence)_@see #isNotEmpty(String);public static boolean isEmpty(Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1,see,is,not,empty,char,sequence,see,is,not,empty,string;public,static,boolean,is,empty,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(Object str);1429034756;Check whether the given {@code String} is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1_@see #isNotEmpty(CharSequence)_@see #isNotEmpty(String);public static boolean isEmpty(Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,code,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1,see,is,not,empty,char,sequence,see,is,not,empty,string;public,static,boolean,is,empty,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(Object str);1431006895;Check whether the given {@code String} is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,code,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(Object str);1431007368;Check whether the given {@code String} is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,code,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(Object str);1449489126;Check whether the given {@code String} is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,code,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(Object str);1467730834;Check whether the given {@code String} is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,code,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(Object str);1472128018;Check whether the given {@code String} is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,code,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(Object str);1472202842;Check whether the given {@code String} is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,code,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(Object str);1473942665;Check whether the given {@code String} is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,code,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(Object str);1484248946;Check whether the given {@code String} is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,code,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(Object str);1484260238;Check whether the given {@code String} is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,code,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(Object str);1484694546;Check whether the given {@code String} is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,code,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(Object str);1487760984;Check whether the given {@code String} is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,code,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(Object str);1487778834;Check whether the given {@code String} is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,code,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(Object str);1491898314;Check whether the given {@code String} is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,code,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(Object str);1491903650;Check whether the given {@code String} is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,code,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,object,str,return,str,null,equals,str
StringUtils -> public static String quote(String str);1328020251;Quote the given String with single quotes._@param str the input String (e.g. "myString")_@return the quoted String (e.g. "'myString'"),_or <code>null<code> if the input was <code>null</code>;public static String quote(String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,string,with,single,quotes,param,str,the,input,string,e,g,my,string,return,the,quoted,string,e,g,my,string,or,code,null,code,if,the,input,was,code,null,code;public,static,string,quote,string,str,return,str,null,str,null
StringUtils -> public static String quote(String str);1337236962;Quote the given String with single quotes._@param str the input String (e.g. "myString")_@return the quoted String (e.g. "'myString'"),_or <code>null<code> if the input was <code>null</code>;public static String quote(String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,string,with,single,quotes,param,str,the,input,string,e,g,my,string,return,the,quoted,string,e,g,my,string,or,code,null,code,if,the,input,was,code,null,code;public,static,string,quote,string,str,return,str,null,str,null
StringUtils -> public static String quote(String str);1356735495;Quote the given String with single quotes._@param str the input String (e.g. "myString")_@return the quoted String (e.g. "'myString'"),_or {@code null} if the input was {@code null};public static String quote(String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,string,with,single,quotes,param,str,the,input,string,e,g,my,string,return,the,quoted,string,e,g,my,string,or,code,null,if,the,input,was,code,null;public,static,string,quote,string,str,return,str,null,str,null
StringUtils -> public static String quote(String str);1367955086;Quote the given String with single quotes._@param str the input String (e.g. "myString")_@return the quoted String (e.g. "'myString'"),_or {@code null} if the input was {@code null};public static String quote(String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,string,with,single,quotes,param,str,the,input,string,e,g,my,string,return,the,quoted,string,e,g,my,string,or,code,null,if,the,input,was,code,null;public,static,string,quote,string,str,return,str,null,str,null
StringUtils -> public static String quote(String str);1380921248;Quote the given String with single quotes._@param str the input String (e.g. "myString")_@return the quoted String (e.g. "'myString'"),_or {@code null} if the input was {@code null};public static String quote(String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,string,with,single,quotes,param,str,the,input,string,e,g,my,string,return,the,quoted,string,e,g,my,string,or,code,null,if,the,input,was,code,null;public,static,string,quote,string,str,return,str,null,str,null
StringUtils -> public static String quote(String str);1382750743;Quote the given String with single quotes._@param str the input String (e.g. "myString")_@return the quoted String (e.g. "'myString'"),_or {@code null} if the input was {@code null};public static String quote(String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,string,with,single,quotes,param,str,the,input,string,e,g,my,string,return,the,quoted,string,e,g,my,string,or,code,null,if,the,input,was,code,null;public,static,string,quote,string,str,return,str,null,str,null
StringUtils -> public static String quote(String str);1385423968;Quote the given String with single quotes._@param str the input String (e.g. "myString")_@return the quoted String (e.g. "'myString'"),_or {@code null} if the input was {@code null};public static String quote(String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,string,with,single,quotes,param,str,the,input,string,e,g,my,string,return,the,quoted,string,e,g,my,string,or,code,null,if,the,input,was,code,null;public,static,string,quote,string,str,return,str,null,str,null
StringUtils -> public static String quote(String str);1400189212;Quote the given String with single quotes._@param str the input String (e.g. "myString")_@return the quoted String (e.g. "'myString'"),_or {@code null} if the input was {@code null};public static String quote(String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,string,with,single,quotes,param,str,the,input,string,e,g,my,string,return,the,quoted,string,e,g,my,string,or,code,null,if,the,input,was,code,null;public,static,string,quote,string,str,return,str,null,str,null
StringUtils -> public static String quote(String str);1400531359;Quote the given String with single quotes._@param str the input String (e.g. "myString")_@return the quoted String (e.g. "'myString'"),_or {@code null} if the input was {@code null};public static String quote(String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,string,with,single,quotes,param,str,the,input,string,e,g,my,string,return,the,quoted,string,e,g,my,string,or,code,null,if,the,input,was,code,null;public,static,string,quote,string,str,return,str,null,str,null
StringUtils -> public static String quote(String str);1402676350;Quote the given String with single quotes._@param str the input String (e.g. "myString")_@return the quoted String (e.g. "'myString'"),_or {@code null} if the input was {@code null};public static String quote(String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,string,with,single,quotes,param,str,the,input,string,e,g,my,string,return,the,quoted,string,e,g,my,string,or,code,null,if,the,input,was,code,null;public,static,string,quote,string,str,return,str,null,str,null
StringUtils -> public static String quote(String str);1426267150;Quote the given String with single quotes._@param str the input String (e.g. "myString")_@return the quoted String (e.g. "'myString'"),_or {@code null} if the input was {@code null};public static String quote(String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,string,with,single,quotes,param,str,the,input,string,e,g,my,string,return,the,quoted,string,e,g,my,string,or,code,null,if,the,input,was,code,null;public,static,string,quote,string,str,return,str,null,str,null
StringUtils -> public static String quote(String str);1429034538;Quote the given String with single quotes._@param str the input String (e.g. "myString")_@return the quoted String (e.g. "'myString'"),_or {@code null} if the input was {@code null};public static String quote(String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,string,with,single,quotes,param,str,the,input,string,e,g,my,string,return,the,quoted,string,e,g,my,string,or,code,null,if,the,input,was,code,null;public,static,string,quote,string,str,return,str,null,str,null
StringUtils -> public static String quote(String str);1429034756;Quote the given {@code String} with single quotes._@param str the input {@code String} (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or {@code null} if the input was {@code null};public static String quote(String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,code,string,with,single,quotes,param,str,the,input,code,string,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,code,null,if,the,input,was,code,null;public,static,string,quote,string,str,return,str,null,str,null
StringUtils -> public static String quote(String str);1431006895;Quote the given {@code String} with single quotes._@param str the input {@code String} (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or {@code null} if the input was {@code null};public static String quote(String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,code,string,with,single,quotes,param,str,the,input,code,string,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,code,null,if,the,input,was,code,null;public,static,string,quote,string,str,return,str,null,str,null
StringUtils -> public static String quote(String str);1431007368;Quote the given {@code String} with single quotes._@param str the input {@code String} (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or {@code null} if the input was {@code null};public static String quote(String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,code,string,with,single,quotes,param,str,the,input,code,string,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,code,null,if,the,input,was,code,null;public,static,string,quote,string,str,return,str,null,str,null
StringUtils -> public static String quote(String str);1449489126;Quote the given {@code String} with single quotes._@param str the input {@code String} (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or {@code null} if the input was {@code null};public static String quote(String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,code,string,with,single,quotes,param,str,the,input,code,string,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,code,null,if,the,input,was,code,null;public,static,string,quote,string,str,return,str,null,str,null
StringUtils -> public static String quote(String str);1467730834;Quote the given {@code String} with single quotes._@param str the input {@code String} (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or {@code null} if the input was {@code null};public static String quote(String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,code,string,with,single,quotes,param,str,the,input,code,string,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,code,null,if,the,input,was,code,null;public,static,string,quote,string,str,return,str,null,str,null
StringUtils -> public static String quote(String str);1472128018;Quote the given {@code String} with single quotes._@param str the input {@code String} (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or {@code null} if the input was {@code null};public static String quote(String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,code,string,with,single,quotes,param,str,the,input,code,string,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,code,null,if,the,input,was,code,null;public,static,string,quote,string,str,return,str,null,str,null
StringUtils -> public static String quote(String str);1472202842;Quote the given {@code String} with single quotes._@param str the input {@code String} (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or {@code null} if the input was {@code null};public static String quote(String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,code,string,with,single,quotes,param,str,the,input,code,string,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,code,null,if,the,input,was,code,null;public,static,string,quote,string,str,return,str,null,str,null
StringUtils -> public static String quote(String str);1473942665;Quote the given {@code String} with single quotes._@param str the input {@code String} (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or {@code null} if the input was {@code null};public static String quote(String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,code,string,with,single,quotes,param,str,the,input,code,string,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,code,null,if,the,input,was,code,null;public,static,string,quote,string,str,return,str,null,str,null
StringUtils -> public static String quote(String str);1484248946;Quote the given {@code String} with single quotes._@param str the input {@code String} (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or {@code null} if the input was {@code null};public static String quote(String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,code,string,with,single,quotes,param,str,the,input,code,string,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,code,null,if,the,input,was,code,null;public,static,string,quote,string,str,return,str,null,str,null
StringUtils -> public static String quote(String str);1484260238;Quote the given {@code String} with single quotes._@param str the input {@code String} (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or {@code null} if the input was {@code null};public static String quote(String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,code,string,with,single,quotes,param,str,the,input,code,string,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,code,null,if,the,input,was,code,null;public,static,string,quote,string,str,return,str,null,str,null
StringUtils -> public static String quote(String str);1484694546;Quote the given {@code String} with single quotes._@param str the input {@code String} (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or {@code null} if the input was {@code null};public static String quote(String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,code,string,with,single,quotes,param,str,the,input,code,string,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,code,null,if,the,input,was,code,null;public,static,string,quote,string,str,return,str,null,str,null
StringUtils -> public static String quote(String str);1487760984;Quote the given {@code String} with single quotes._@param str the input {@code String} (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or {@code null} if the input was {@code null};public static String quote(String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,code,string,with,single,quotes,param,str,the,input,code,string,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,code,null,if,the,input,was,code,null;public,static,string,quote,string,str,return,str,null,str,null
StringUtils -> public static String quote(String str);1487778834;Quote the given {@code String} with single quotes._@param str the input {@code String} (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or {@code null} if the input was {@code null};public static String quote(String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,code,string,with,single,quotes,param,str,the,input,code,string,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,code,null,if,the,input,was,code,null;public,static,string,quote,string,str,return,str,null,str,null
StringUtils -> public static String quote(String str);1491898314;Quote the given {@code String} with single quotes._@param str the input {@code String} (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or {@code null} if the input was {@code null};public static String quote(String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,code,string,with,single,quotes,param,str,the,input,code,string,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,code,null,if,the,input,was,code,null;public,static,string,quote,string,str,return,str,null,str,null
StringUtils -> public static String quote(String str);1491903650;Quote the given {@code String} with single quotes._@param str the input {@code String} (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or {@code null} if the input was {@code null};public static String quote(String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,code,string,with,single,quotes,param,str,the,input,code,string,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,code,null,if,the,input,was,code,null;public,static,string,quote,string,str,return,str,null,str,null
StringUtils -> public static Set<String> commaDelimitedListToSet(String str);1328020251;Convenience method to convert a CSV string list to a set._Note that this will suppress duplicates._@param str the input String_@return a Set of String entries in the list;public static Set<String> commaDelimitedListToSet(String str) {_		Set<String> set = new TreeSet<String>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convenience,method,to,convert,a,csv,string,list,to,a,set,note,that,this,will,suppress,duplicates,param,str,the,input,string,return,a,set,of,string,entries,in,the,list;public,static,set,string,comma,delimited,list,to,set,string,str,set,string,set,new,tree,set,string,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(String str);1337236962;Convenience method to convert a CSV string list to a set._Note that this will suppress duplicates._@param str the input String_@return a Set of String entries in the list;public static Set<String> commaDelimitedListToSet(String str) {_		Set<String> set = new TreeSet<String>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convenience,method,to,convert,a,csv,string,list,to,a,set,note,that,this,will,suppress,duplicates,param,str,the,input,string,return,a,set,of,string,entries,in,the,list;public,static,set,string,comma,delimited,list,to,set,string,str,set,string,set,new,tree,set,string,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(String str);1356735495;Convenience method to convert a CSV string list to a set._Note that this will suppress duplicates._@param str the input String_@return a Set of String entries in the list;public static Set<String> commaDelimitedListToSet(String str) {_		Set<String> set = new TreeSet<String>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convenience,method,to,convert,a,csv,string,list,to,a,set,note,that,this,will,suppress,duplicates,param,str,the,input,string,return,a,set,of,string,entries,in,the,list;public,static,set,string,comma,delimited,list,to,set,string,str,set,string,set,new,tree,set,string,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(String str);1367955086;Convenience method to convert a CSV string list to a set._Note that this will suppress duplicates._@param str the input String_@return a Set of String entries in the list;public static Set<String> commaDelimitedListToSet(String str) {_		Set<String> set = new TreeSet<String>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convenience,method,to,convert,a,csv,string,list,to,a,set,note,that,this,will,suppress,duplicates,param,str,the,input,string,return,a,set,of,string,entries,in,the,list;public,static,set,string,comma,delimited,list,to,set,string,str,set,string,set,new,tree,set,string,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(String str);1380921248;Convenience method to convert a CSV string list to a set._Note that this will suppress duplicates._@param str the input String_@return a Set of String entries in the list;public static Set<String> commaDelimitedListToSet(String str) {_		Set<String> set = new TreeSet<String>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convenience,method,to,convert,a,csv,string,list,to,a,set,note,that,this,will,suppress,duplicates,param,str,the,input,string,return,a,set,of,string,entries,in,the,list;public,static,set,string,comma,delimited,list,to,set,string,str,set,string,set,new,tree,set,string,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(String str);1382750743;Convenience method to convert a CSV string list to a set._Note that this will suppress duplicates._@param str the input String_@return a Set of String entries in the list;public static Set<String> commaDelimitedListToSet(String str) {_		Set<String> set = new TreeSet<String>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convenience,method,to,convert,a,csv,string,list,to,a,set,note,that,this,will,suppress,duplicates,param,str,the,input,string,return,a,set,of,string,entries,in,the,list;public,static,set,string,comma,delimited,list,to,set,string,str,set,string,set,new,tree,set,string,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(String str);1385423968;Convenience method to convert a CSV string list to a set._Note that this will suppress duplicates._@param str the input String_@return a Set of String entries in the list;public static Set<String> commaDelimitedListToSet(String str) {_		Set<String> set = new TreeSet<String>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convenience,method,to,convert,a,csv,string,list,to,a,set,note,that,this,will,suppress,duplicates,param,str,the,input,string,return,a,set,of,string,entries,in,the,list;public,static,set,string,comma,delimited,list,to,set,string,str,set,string,set,new,tree,set,string,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(String str);1400189212;Convenience method to convert a CSV string list to a set._Note that this will suppress duplicates._@param str the input String_@return a Set of String entries in the list;public static Set<String> commaDelimitedListToSet(String str) {_		Set<String> set = new TreeSet<String>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convenience,method,to,convert,a,csv,string,list,to,a,set,note,that,this,will,suppress,duplicates,param,str,the,input,string,return,a,set,of,string,entries,in,the,list;public,static,set,string,comma,delimited,list,to,set,string,str,set,string,set,new,tree,set,string,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(String str);1400531359;Convenience method to convert a CSV string list to a set._Note that this will suppress duplicates._@param str the input String_@return a Set of String entries in the list;public static Set<String> commaDelimitedListToSet(String str) {_		Set<String> set = new TreeSet<String>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convenience,method,to,convert,a,csv,string,list,to,a,set,note,that,this,will,suppress,duplicates,param,str,the,input,string,return,a,set,of,string,entries,in,the,list;public,static,set,string,comma,delimited,list,to,set,string,str,set,string,set,new,tree,set,string,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(String str);1402676350;Convenience method to convert a CSV string list to a set._Note that this will suppress duplicates._@param str the input String_@return a Set of String entries in the list;public static Set<String> commaDelimitedListToSet(String str) {_		Set<String> set = new TreeSet<String>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convenience,method,to,convert,a,csv,string,list,to,a,set,note,that,this,will,suppress,duplicates,param,str,the,input,string,return,a,set,of,string,entries,in,the,list;public,static,set,string,comma,delimited,list,to,set,string,str,set,string,set,new,tree,set,string,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(String str);1426267150;Convenience method to convert a CSV string list to a set._Note that this will suppress duplicates._@param str the input String_@return a Set of String entries in the list;public static Set<String> commaDelimitedListToSet(String str) {_		Set<String> set = new TreeSet<String>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convenience,method,to,convert,a,csv,string,list,to,a,set,note,that,this,will,suppress,duplicates,param,str,the,input,string,return,a,set,of,string,entries,in,the,list;public,static,set,string,comma,delimited,list,to,set,string,str,set,string,set,new,tree,set,string,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(String str);1429034538;Convenience method to convert a CSV string list to a set._Note that this will suppress duplicates._@param str the input String_@return a Set of String entries in the list;public static Set<String> commaDelimitedListToSet(String str) {_		Set<String> set = new TreeSet<String>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convenience,method,to,convert,a,csv,string,list,to,a,set,note,that,this,will,suppress,duplicates,param,str,the,input,string,return,a,set,of,string,entries,in,the,list;public,static,set,string,comma,delimited,list,to,set,string,str,set,string,set,new,tree,set,string,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(String str);1429034756;Convert a comma delimited list (e.g., a row from a CSV file) into a set._<p>Note that this will suppress duplicates, and the elements in the_returned set will be sorted, since a {@link TreeSet} is used internally._@param str the input {@code String}_@return a set of {@code String} entries in the list;public static Set<String> commaDelimitedListToSet(String str) {_		Set<String> set = new TreeSet<String>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,a,set,p,note,that,this,will,suppress,duplicates,and,the,elements,in,the,returned,set,will,be,sorted,since,a,link,tree,set,is,used,internally,param,str,the,input,code,string,return,a,set,of,code,string,entries,in,the,list;public,static,set,string,comma,delimited,list,to,set,string,str,set,string,set,new,tree,set,string,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(String str);1431006895;Convert a comma delimited list (e.g., a row from a CSV file) into a set._<p>Note that this will suppress duplicates, and the elements in the_returned set will be sorted, since a {@link TreeSet} is used internally._@param str the input {@code String}_@return a set of {@code String} entries in the list;public static Set<String> commaDelimitedListToSet(String str) {_		Set<String> set = new TreeSet<String>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,a,set,p,note,that,this,will,suppress,duplicates,and,the,elements,in,the,returned,set,will,be,sorted,since,a,link,tree,set,is,used,internally,param,str,the,input,code,string,return,a,set,of,code,string,entries,in,the,list;public,static,set,string,comma,delimited,list,to,set,string,str,set,string,set,new,tree,set,string,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(String str);1431007368;Convert a comma delimited list (e.g., a row from a CSV file) into a set._<p>Note that this will suppress duplicates, and as of 4.2, the elements in_the returned set will preserve the original order in a {@link LinkedHashSet}._@param str the input {@code String}_@return a set of {@code String} entries in the list_@see #removeDuplicateStrings(String[]);public static Set<String> commaDelimitedListToSet(String str) {_		Set<String> set = new LinkedHashSet<String>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,a,set,p,note,that,this,will,suppress,duplicates,and,as,of,4,2,the,elements,in,the,returned,set,will,preserve,the,original,order,in,a,link,linked,hash,set,param,str,the,input,code,string,return,a,set,of,code,string,entries,in,the,list,see,remove,duplicate,strings,string;public,static,set,string,comma,delimited,list,to,set,string,str,set,string,set,new,linked,hash,set,string,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(String str);1449489126;Convert a comma delimited list (e.g., a row from a CSV file) into a set._<p>Note that this will suppress duplicates, and as of 4.2, the elements in_the returned set will preserve the original order in a {@link LinkedHashSet}._@param str the input {@code String}_@return a set of {@code String} entries in the list_@see #removeDuplicateStrings(String[]);public static Set<String> commaDelimitedListToSet(String str) {_		Set<String> set = new LinkedHashSet<String>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,a,set,p,note,that,this,will,suppress,duplicates,and,as,of,4,2,the,elements,in,the,returned,set,will,preserve,the,original,order,in,a,link,linked,hash,set,param,str,the,input,code,string,return,a,set,of,code,string,entries,in,the,list,see,remove,duplicate,strings,string;public,static,set,string,comma,delimited,list,to,set,string,str,set,string,set,new,linked,hash,set,string,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(String str);1467730834;Convert a comma delimited list (e.g., a row from a CSV file) into a set._<p>Note that this will suppress duplicates, and as of 4.2, the elements in_the returned set will preserve the original order in a {@link LinkedHashSet}._@param str the input {@code String}_@return a set of {@code String} entries in the list_@see #removeDuplicateStrings(String[]);public static Set<String> commaDelimitedListToSet(String str) {_		Set<String> set = new LinkedHashSet<>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,a,set,p,note,that,this,will,suppress,duplicates,and,as,of,4,2,the,elements,in,the,returned,set,will,preserve,the,original,order,in,a,link,linked,hash,set,param,str,the,input,code,string,return,a,set,of,code,string,entries,in,the,list,see,remove,duplicate,strings,string;public,static,set,string,comma,delimited,list,to,set,string,str,set,string,set,new,linked,hash,set,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(String str);1472128018;Convert a comma delimited list (e.g., a row from a CSV file) into a set._<p>Note that this will suppress duplicates, and as of 4.2, the elements in_the returned set will preserve the original order in a {@link LinkedHashSet}._@param str the input {@code String}_@return a set of {@code String} entries in the list_@see #removeDuplicateStrings(String[]);public static Set<String> commaDelimitedListToSet(String str) {_		Set<String> set = new LinkedHashSet<>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,a,set,p,note,that,this,will,suppress,duplicates,and,as,of,4,2,the,elements,in,the,returned,set,will,preserve,the,original,order,in,a,link,linked,hash,set,param,str,the,input,code,string,return,a,set,of,code,string,entries,in,the,list,see,remove,duplicate,strings,string;public,static,set,string,comma,delimited,list,to,set,string,str,set,string,set,new,linked,hash,set,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(String str);1472202842;Convert a comma delimited list (e.g., a row from a CSV file) into a set._<p>Note that this will suppress duplicates, and as of 4.2, the elements in_the returned set will preserve the original order in a {@link LinkedHashSet}._@param str the input {@code String}_@return a set of {@code String} entries in the list_@see #removeDuplicateStrings(String[]);public static Set<String> commaDelimitedListToSet(String str) {_		Set<String> set = new LinkedHashSet<>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,a,set,p,note,that,this,will,suppress,duplicates,and,as,of,4,2,the,elements,in,the,returned,set,will,preserve,the,original,order,in,a,link,linked,hash,set,param,str,the,input,code,string,return,a,set,of,code,string,entries,in,the,list,see,remove,duplicate,strings,string;public,static,set,string,comma,delimited,list,to,set,string,str,set,string,set,new,linked,hash,set,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(String str);1473942665;Convert a comma delimited list (e.g., a row from a CSV file) into a set._<p>Note that this will suppress duplicates, and as of 4.2, the elements in_the returned set will preserve the original order in a {@link LinkedHashSet}._@param str the input {@code String}_@return a set of {@code String} entries in the list_@see #removeDuplicateStrings(String[]);public static Set<String> commaDelimitedListToSet(String str) {_		Set<String> set = new LinkedHashSet<>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,a,set,p,note,that,this,will,suppress,duplicates,and,as,of,4,2,the,elements,in,the,returned,set,will,preserve,the,original,order,in,a,link,linked,hash,set,param,str,the,input,code,string,return,a,set,of,code,string,entries,in,the,list,see,remove,duplicate,strings,string;public,static,set,string,comma,delimited,list,to,set,string,str,set,string,set,new,linked,hash,set,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(String str);1484248946;Convert a comma delimited list (e.g., a row from a CSV file) into a set._<p>Note that this will suppress duplicates, and as of 4.2, the elements in_the returned set will preserve the original order in a {@link LinkedHashSet}._@param str the input {@code String}_@return a set of {@code String} entries in the list_@see #removeDuplicateStrings(String[]);public static Set<String> commaDelimitedListToSet(String str) {_		Set<String> set = new LinkedHashSet<>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,a,set,p,note,that,this,will,suppress,duplicates,and,as,of,4,2,the,elements,in,the,returned,set,will,preserve,the,original,order,in,a,link,linked,hash,set,param,str,the,input,code,string,return,a,set,of,code,string,entries,in,the,list,see,remove,duplicate,strings,string;public,static,set,string,comma,delimited,list,to,set,string,str,set,string,set,new,linked,hash,set,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(String str);1484260238;Convert a comma delimited list (e.g., a row from a CSV file) into a set._<p>Note that this will suppress duplicates, and as of 4.2, the elements in_the returned set will preserve the original order in a {@link LinkedHashSet}._@param str the input {@code String}_@return a set of {@code String} entries in the list_@see #removeDuplicateStrings(String[]);public static Set<String> commaDelimitedListToSet(String str) {_		Set<String> set = new LinkedHashSet<>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,a,set,p,note,that,this,will,suppress,duplicates,and,as,of,4,2,the,elements,in,the,returned,set,will,preserve,the,original,order,in,a,link,linked,hash,set,param,str,the,input,code,string,return,a,set,of,code,string,entries,in,the,list,see,remove,duplicate,strings,string;public,static,set,string,comma,delimited,list,to,set,string,str,set,string,set,new,linked,hash,set,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(String str);1484694546;Convert a comma delimited list (e.g., a row from a CSV file) into a set._<p>Note that this will suppress duplicates, and as of 4.2, the elements in_the returned set will preserve the original order in a {@link LinkedHashSet}._@param str the input {@code String}_@return a set of {@code String} entries in the list_@see #removeDuplicateStrings(String[]);public static Set<String> commaDelimitedListToSet(String str) {_		Set<String> set = new LinkedHashSet<>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,a,set,p,note,that,this,will,suppress,duplicates,and,as,of,4,2,the,elements,in,the,returned,set,will,preserve,the,original,order,in,a,link,linked,hash,set,param,str,the,input,code,string,return,a,set,of,code,string,entries,in,the,list,see,remove,duplicate,strings,string;public,static,set,string,comma,delimited,list,to,set,string,str,set,string,set,new,linked,hash,set,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(String str);1487760984;Convert a comma delimited list (e.g., a row from a CSV file) into a set._<p>Note that this will suppress duplicates, and as of 4.2, the elements in_the returned set will preserve the original order in a {@link LinkedHashSet}._@param str the input {@code String}_@return a set of {@code String} entries in the list_@see #removeDuplicateStrings(String[]);public static Set<String> commaDelimitedListToSet(String str) {_		Set<String> set = new LinkedHashSet<>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,a,set,p,note,that,this,will,suppress,duplicates,and,as,of,4,2,the,elements,in,the,returned,set,will,preserve,the,original,order,in,a,link,linked,hash,set,param,str,the,input,code,string,return,a,set,of,code,string,entries,in,the,list,see,remove,duplicate,strings,string;public,static,set,string,comma,delimited,list,to,set,string,str,set,string,set,new,linked,hash,set,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(String str);1487778834;Convert a comma delimited list (e.g., a row from a CSV file) into a set._<p>Note that this will suppress duplicates, and as of 4.2, the elements in_the returned set will preserve the original order in a {@link LinkedHashSet}._@param str the input {@code String}_@return a set of {@code String} entries in the list_@see #removeDuplicateStrings(String[]);public static Set<String> commaDelimitedListToSet(String str) {_		Set<String> set = new LinkedHashSet<>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,a,set,p,note,that,this,will,suppress,duplicates,and,as,of,4,2,the,elements,in,the,returned,set,will,preserve,the,original,order,in,a,link,linked,hash,set,param,str,the,input,code,string,return,a,set,of,code,string,entries,in,the,list,see,remove,duplicate,strings,string;public,static,set,string,comma,delimited,list,to,set,string,str,set,string,set,new,linked,hash,set,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(String str);1491898314;Convert a comma delimited list (e.g., a row from a CSV file) into a set._<p>Note that this will suppress duplicates, and as of 4.2, the elements in_the returned set will preserve the original order in a {@link LinkedHashSet}._@param str the input {@code String}_@return a set of {@code String} entries in the list_@see #removeDuplicateStrings(String[]);public static Set<String> commaDelimitedListToSet(String str) {_		Set<String> set = new LinkedHashSet<>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,a,set,p,note,that,this,will,suppress,duplicates,and,as,of,4,2,the,elements,in,the,returned,set,will,preserve,the,original,order,in,a,link,linked,hash,set,param,str,the,input,code,string,return,a,set,of,code,string,entries,in,the,list,see,remove,duplicate,strings,string;public,static,set,string,comma,delimited,list,to,set,string,str,set,string,set,new,linked,hash,set,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(String str);1491903650;Convert a comma delimited list (e.g., a row from a CSV file) into a set._<p>Note that this will suppress duplicates, and as of 4.2, the elements in_the returned set will preserve the original order in a {@link LinkedHashSet}._@param str the input {@code String}_@return a set of {@code String} entries in the list_@see #removeDuplicateStrings(String[]);public static Set<String> commaDelimitedListToSet(String str) {_		Set<String> set = new LinkedHashSet<>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,a,set,p,note,that,this,will,suppress,duplicates,and,as,of,4,2,the,elements,in,the,returned,set,will,preserve,the,original,order,in,a,link,linked,hash,set,param,str,the,input,code,string,return,a,set,of,code,string,entries,in,the,list,see,remove,duplicate,strings,string;public,static,set,string,comma,delimited,list,to,set,string,str,set,string,set,new,linked,hash,set,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(String str);1495868221;Convert a comma delimited list (e.g., a row from a CSV file) into a set._<p>Note that this will suppress duplicates, and as of 4.2, the elements in_the returned set will preserve the original order in a {@link LinkedHashSet}._@param str the input {@code String}_@return a set of {@code String} entries in the list_@see #removeDuplicateStrings(String[]);public static Set<String> commaDelimitedListToSet(String str) {_		Set<String> set = new LinkedHashSet<>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,a,set,p,note,that,this,will,suppress,duplicates,and,as,of,4,2,the,elements,in,the,returned,set,will,preserve,the,original,order,in,a,link,linked,hash,set,param,str,the,input,code,string,return,a,set,of,code,string,entries,in,the,list,see,remove,duplicate,strings,string;public,static,set,string,comma,delimited,list,to,set,string,str,set,string,set,new,linked,hash,set,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(String str);1496243689;Convert a comma delimited list (e.g., a row from a CSV file) into a set._<p>Note that this will suppress duplicates, and as of 4.2, the elements in_the returned set will preserve the original order in a {@link LinkedHashSet}._@param str the input {@code String}_@return a set of {@code String} entries in the list_@see #removeDuplicateStrings(String[]);public static Set<String> commaDelimitedListToSet(String str) {_		Set<String> set = new LinkedHashSet<>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,a,set,p,note,that,this,will,suppress,duplicates,and,as,of,4,2,the,elements,in,the,returned,set,will,preserve,the,original,order,in,a,link,linked,hash,set,param,str,the,input,code,string,return,a,set,of,code,string,entries,in,the,list,see,remove,duplicate,strings,string;public,static,set,string,comma,delimited,list,to,set,string,str,set,string,set,new,linked,hash,set,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(String str);1496259743;Convert a comma delimited list (e.g., a row from a CSV file) into a set._<p>Note that this will suppress duplicates, and as of 4.2, the elements in_the returned set will preserve the original order in a {@link LinkedHashSet}._@param str the input {@code String}_@return a set of {@code String} entries in the list_@see #removeDuplicateStrings(String[]);public static Set<String> commaDelimitedListToSet(String str) {_		Set<String> set = new LinkedHashSet<>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,a,set,p,note,that,this,will,suppress,duplicates,and,as,of,4,2,the,elements,in,the,returned,set,will,preserve,the,original,order,in,a,link,linked,hash,set,param,str,the,input,code,string,return,a,set,of,code,string,entries,in,the,list,see,remove,duplicate,strings,string;public,static,set,string,comma,delimited,list,to,set,string,str,set,string,set,new,linked,hash,set,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static String trimTrailingWhitespace(String str);1328020251;Trim trailing whitespace from the given String._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,string,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1337236962;Trim trailing whitespace from the given String._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,string,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1356735495;Trim trailing whitespace from the given String._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,string,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1367955086;Trim trailing whitespace from the given String._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,string,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1380921248;Trim trailing whitespace from the given String._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,string,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1382750743;Trim trailing whitespace from the given String._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,string,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1385423968;Trim trailing whitespace from the given String._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,string,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1400189212;Trim trailing whitespace from the given String._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,string,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1400531359;Trim trailing whitespace from the given String._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,string,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1402676350;Trim trailing whitespace from the given String._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,string,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1426267150;Trim trailing whitespace from the given String._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,string,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1429034538;Trim trailing whitespace from the given String._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,string,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1429034756;Trim trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1431006895;Trim trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1431007368;Trim trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1449489126;Trim trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1467730834;Trim trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1472128018;Trim trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1472202842;Trim trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1473942665;Trim trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1484248946;Trim trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1484260238;Trim trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1484694546;Trim trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1487760984;Trim trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1487778834;Trim trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1491898314;Trim trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1491903650;Trim trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1495868221;Trim trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1496243689;Trim trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1496259743;Trim trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1496837955;Trim trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1499270197;Trim trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1508667152;Trim trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1508675477;Trim trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1508843807;Trim trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1516903831;Trim trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1519295386;Trim trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1519308837;Trim trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1519588127;Trim trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1522332352;Trim trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1525166194;Trim trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1530188116;Trim trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1531843079;Trim trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1531905026;Trim trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1533557519;Trim trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1533602820;Trim trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1535316501;Trim trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1550237113;Trim trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingWhitespace(String str);1550238935;Trim trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimTrailingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,trailing,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String cleanPath(String path);1328020251;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (path == null) {_			return null__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(":")__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			pathToUse = pathToUse.substring(prefixIndex + 1)__		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<String>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,path,null,return,null,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,string,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1337236962;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (path == null) {_			return null__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(":")__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			pathToUse = pathToUse.substring(prefixIndex + 1)__		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<String>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,path,null,return,null,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,string,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1356735495;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (path == null) {_			return null__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(":")__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			pathToUse = pathToUse.substring(prefixIndex + 1)__		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<String>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,path,null,return,null,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,string,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1367955086;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (path == null) {_			return null__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(":")__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			pathToUse = pathToUse.substring(prefixIndex + 1)__		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<String>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,path,null,return,null,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,string,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1380921248;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (path == null) {_			return null__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(":")__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			pathToUse = pathToUse.substring(prefixIndex + 1)__		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<String>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,path,null,return,null,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,string,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1382750743;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (path == null) {_			return null__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(":")__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			pathToUse = pathToUse.substring(prefixIndex + 1)__		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<String>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,path,null,return,null,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,string,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1385423968;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (path == null) {_			return null__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(":")__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			pathToUse = pathToUse.substring(prefixIndex + 1)__		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<String>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,path,null,return,null,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,string,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1400189212;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (path == null) {_			return null__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(":")__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains("/")) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<String>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,path,null,return,null,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,string,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1400531359;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (path == null) {_			return null__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(":")__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains("/")) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<String>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,path,null,return,null,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,string,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1402676350;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (path == null) {_			return null__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(":")__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains("/")) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<String>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,path,null,return,null,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,string,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1426267150;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (path == null) {_			return null__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(":")__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains("/")) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<String>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,path,null,return,null,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,string,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1429034538;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (path == null) {_			return null__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(":")__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains("/")) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<String>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,path,null,return,null,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,string,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1429034756;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (path == null) {_			return null__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(":")__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains("/")) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<String>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,path,null,return,null,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,string,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1431006895;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (path == null) {_			return null__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(":")__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains("/")) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<String>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,path,null,return,null,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,string,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1431007368;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (path == null) {_			return null__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(":")__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains("/")) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<String>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,path,null,return,null,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,string,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1449489126;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (path == null) {_			return null__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(":")__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains("/")) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<String>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,path,null,return,null,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,string,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1467730834;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (path == null) {_			return null__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(":")__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains("/")) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,path,null,return,null,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1472128018;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (path == null) {_			return null__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(":")__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains("/")) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,path,null,return,null,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1472202842;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (path == null) {_			return null__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(":")__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains("/")) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,path,null,return,null,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1473942665;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (path == null) {_			return null__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(":")__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains("/")) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,path,null,return,null,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1484248946;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (path == null) {_			return null__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(":")__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains("/")) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,path,null,return,null,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1484260238;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (path == null) {_			return null__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(":")__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains("/")) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,path,null,return,null,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1484694546;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (path == null) {_			return null__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(":")__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains("/")) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,path,null,return,null,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1487760984;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (path == null) {_			return null__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(":")__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains("/")) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,path,null,return,null,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1487778834;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (path == null) {_			return null__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(":")__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains("/")) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,path,null,return,null,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1491898314;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (path == null) {_			return null__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(":")__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains("/")) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,path,null,return,null,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1491903650;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (path == null) {_			return null__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(":")__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains("/")) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,path,null,return,null,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1495868221;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (path == null) {_			return null__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(":")__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains("/")) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,path,null,return,null,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1496243689;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (path == null) {_			return null__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(":")__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains("/")) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,path,null,return,null,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1496259743;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (path == null) {_			return null__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(":")__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains("/")) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,path,null,return,null,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1496837955;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (!hasLength(path)) {_			return path__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(":")__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains("/")) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,has,length,path,return,path,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1499270197;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (!hasLength(path)) {_			return path__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(":")__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains("/")) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,has,length,path,return,path,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1508667152;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (!hasLength(path)) {_			return path__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(":")__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains("/")) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,has,length,path,return,path,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1508675477;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (!hasLength(path)) {_			return path__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(":")__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains("/")) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,has,length,path,return,path,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1508843807;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (!hasLength(path)) {_			return path__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(":")__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains("/")) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,has,length,path,return,path,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1516903831;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (!hasLength(path)) {_			return path__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(":")__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains("/")) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,has,length,path,return,path,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1519295386;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (!hasLength(path)) {_			return path__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(":")__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains("/")) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,has,length,path,return,path,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1519308837;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (!hasLength(path)) {_			return path__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(":")__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains("/")) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,has,length,path,return,path,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1519588127;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (!hasLength(path)) {_			return path__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(':')__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains("/")) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,has,length,path,return,path,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1522332352;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (!hasLength(path)) {_			return path__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(':')__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains("/")) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,has,length,path,return,path,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1525166194;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (!hasLength(path)) {_			return path__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(':')__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains("/")) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		List<String> pathElements = new LinkedList<>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,has,length,path,return,path,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,list,string,path,elements,new,linked,list,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1530188116;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (!hasLength(path)) {_			return path__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(':')__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains(FOLDER_SEPARATOR)) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		LinkedList<String> pathElements = new LinkedList<>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}_		_		if (pathElements.size() == 1 && "".equals(pathElements.getLast()) && !prefix.endsWith(FOLDER_SEPARATOR)) {_			pathElements.add(0, CURRENT_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,has,length,path,return,path,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,linked,list,string,path,elements,new,linked,list,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,if,path,elements,size,1,equals,path,elements,get,last,prefix,ends,with,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1531843079;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (!hasLength(path)) {_			return path__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(':')__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains(FOLDER_SEPARATOR)) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		LinkedList<String> pathElements = new LinkedList<>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}_		_		if (pathElements.size() == 1 && "".equals(pathElements.getLast()) && !prefix.endsWith(FOLDER_SEPARATOR)) {_			pathElements.add(0, CURRENT_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,has,length,path,return,path,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,linked,list,string,path,elements,new,linked,list,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,if,path,elements,size,1,equals,path,elements,get,last,prefix,ends,with,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1531905026;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (!hasLength(path)) {_			return path__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(':')__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains(FOLDER_SEPARATOR)) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		LinkedList<String> pathElements = new LinkedList<>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}_		_		if (pathElements.size() == 1 && "".equals(pathElements.getLast()) && !prefix.endsWith(FOLDER_SEPARATOR)) {_			pathElements.add(0, CURRENT_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,has,length,path,return,path,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,linked,list,string,path,elements,new,linked,list,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,if,path,elements,size,1,equals,path,elements,get,last,prefix,ends,with,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1533557519;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (!hasLength(path)) {_			return path__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(':')__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains(FOLDER_SEPARATOR)) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		LinkedList<String> pathElements = new LinkedList<>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}_		_		if (pathElements.size() == 1 && "".equals(pathElements.getLast()) && !prefix.endsWith(FOLDER_SEPARATOR)) {_			pathElements.add(0, CURRENT_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,has,length,path,return,path,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,linked,list,string,path,elements,new,linked,list,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,if,path,elements,size,1,equals,path,elements,get,last,prefix,ends,with,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1533602820;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (!hasLength(path)) {_			return path__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(':')__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains(FOLDER_SEPARATOR)) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		LinkedList<String> pathElements = new LinkedList<>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}_		_		if (pathElements.size() == 1 && "".equals(pathElements.getLast()) && !prefix.endsWith(FOLDER_SEPARATOR)) {_			pathElements.add(0, CURRENT_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,has,length,path,return,path,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,linked,list,string,path,elements,new,linked,list,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,if,path,elements,size,1,equals,path,elements,get,last,prefix,ends,with,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1535316501;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (!hasLength(path)) {_			return path__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(':')__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains(FOLDER_SEPARATOR)) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		LinkedList<String> pathElements = new LinkedList<>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}_		_		if (pathElements.size() == 1 && "".equals(pathElements.getLast()) && !prefix.endsWith(FOLDER_SEPARATOR)) {_			pathElements.add(0, CURRENT_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,has,length,path,return,path,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,linked,list,string,path,elements,new,linked,list,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,if,path,elements,size,1,equals,path,elements,get,last,prefix,ends,with,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1550237113;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (!hasLength(path)) {_			return path__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(':')__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains(FOLDER_SEPARATOR)) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		LinkedList<String> pathElements = new LinkedList<>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}_		_		if (pathElements.size() == 1 && "".equals(pathElements.getLast()) && !prefix.endsWith(FOLDER_SEPARATOR)) {_			pathElements.add(0, CURRENT_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,has,length,path,return,path,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,linked,list,string,path,elements,new,linked,list,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,if,path,elements,size,1,equals,path,elements,get,last,prefix,ends,with,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String cleanPath(String path);1550238935;Normalize the path by suppressing sequences like "path/.." and_inner simple dots._<p>The result is convenient for path comparison. For other uses,_notice that Windows separators ("\") are replaced by simple slashes._@param path the original path_@return the normalized path;public static String cleanPath(String path) {_		if (!hasLength(path)) {_			return path__		}_		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR)___		_		_		_		_		int prefixIndex = pathToUse.indexOf(':')__		String prefix = ""__		if (prefixIndex != -1) {_			prefix = pathToUse.substring(0, prefixIndex + 1)__			if (prefix.contains(FOLDER_SEPARATOR)) {_				prefix = ""__			}_			else {_				pathToUse = pathToUse.substring(prefixIndex + 1)__			}_		}_		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {_			prefix = prefix + FOLDER_SEPARATOR__			pathToUse = pathToUse.substring(1)__		}__		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR)__		LinkedList<String> pathElements = new LinkedList<>()__		int tops = 0___		for (int i = pathArray.length - 1_ i >= 0_ i--) {_			String element = pathArray[i]__			if (CURRENT_PATH.equals(element)) {_				_			}_			else if (TOP_PATH.equals(element)) {_				_				tops++__			}_			else {_				if (tops > 0) {_					_					tops--__				}_				else {_					_					pathElements.add(0, element)__				}_			}_		}__		_		for (int i = 0_ i < tops_ i++) {_			pathElements.add(0, TOP_PATH)__		}_		_		if (pathElements.size() == 1 && "".equals(pathElements.getLast()) && !prefix.endsWith(FOLDER_SEPARATOR)) {_			pathElements.add(0, CURRENT_PATH)__		}__		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR)__	};normalize,the,path,by,suppressing,sequences,like,path,and,inner,simple,dots,p,the,result,is,convenient,for,path,comparison,for,other,uses,notice,that,windows,separators,are,replaced,by,simple,slashes,param,path,the,original,path,return,the,normalized,path;public,static,string,clean,path,string,path,if,has,length,path,return,path,string,path,to,use,replace,path,int,prefix,index,path,to,use,index,of,string,prefix,if,prefix,index,1,prefix,path,to,use,substring,0,prefix,index,1,if,prefix,contains,prefix,else,path,to,use,path,to,use,substring,prefix,index,1,if,path,to,use,starts,with,prefix,prefix,path,to,use,path,to,use,substring,1,string,path,array,delimited,list,to,string,array,path,to,use,linked,list,string,path,elements,new,linked,list,int,tops,0,for,int,i,path,array,length,1,i,0,i,string,element,path,array,i,if,equals,element,else,if,equals,element,tops,else,if,tops,0,tops,else,path,elements,add,0,element,for,int,i,0,i,tops,i,path,elements,add,0,if,path,elements,size,1,equals,path,elements,get,last,prefix,ends,with,path,elements,add,0,return,prefix,collection,to,delimited,string,path,elements
StringUtils -> public static String applyRelativePath(String path, String relativePath);1328020251;Apply the given relative path to the given path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1337236962;Apply the given relative path to the given path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1356735495;Apply the given relative path to the given path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1367955086;Apply the given relative path to the given path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1380921248;Apply the given relative path to the given path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1382750743;Apply the given relative path to the given path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1385423968;Apply the given relative path to the given path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1400189212;Apply the given relative path to the given path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1400531359;Apply the given relative path to the given path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1402676350;Apply the given relative path to the given path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1426267150;Apply the given relative path to the given path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1429034538;Apply the given relative path to the given path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1429034756;Apply the given relative path to the given path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1431006895;Apply the given relative path to the given path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1431007368;Apply the given relative path to the given path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1449489126;Apply the given relative path to the given Java resource path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,java,resource,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1467730834;Apply the given relative path to the given Java resource path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,java,resource,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1472128018;Apply the given relative path to the given Java resource path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,java,resource,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1472202842;Apply the given relative path to the given Java resource path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,java,resource,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1473942665;Apply the given relative path to the given Java resource path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,java,resource,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1484248946;Apply the given relative path to the given Java resource path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,java,resource,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1484260238;Apply the given relative path to the given Java resource path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,java,resource,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1484694546;Apply the given relative path to the given Java resource path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,java,resource,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1487760984;Apply the given relative path to the given Java resource path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,java,resource,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1487778834;Apply the given relative path to the given Java resource path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,java,resource,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1491898314;Apply the given relative path to the given Java resource path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,java,resource,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1491903650;Apply the given relative path to the given Java resource path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,java,resource,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1495868221;Apply the given relative path to the given Java resource path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,java,resource,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1496243689;Apply the given relative path to the given Java resource path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,java,resource,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1496259743;Apply the given relative path to the given Java resource path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,java,resource,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1496837955;Apply the given relative path to the given Java resource path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,java,resource,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1499270197;Apply the given relative path to the given Java resource path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,java,resource,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1508667152;Apply the given relative path to the given Java resource path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,java,resource,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1508675477;Apply the given relative path to the given Java resource path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,java,resource,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1508843807;Apply the given relative path to the given Java resource path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,java,resource,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1516903831;Apply the given relative path to the given Java resource path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,java,resource,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1519295386;Apply the given relative path to the given Java resource path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,java,resource,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1519308837;Apply the given relative path to the given Java resource path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,java,resource,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1519588127;Apply the given relative path to the given Java resource path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,java,resource,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1522332352;Apply the given relative path to the given Java resource path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,java,resource,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1525166194;Apply the given relative path to the given Java resource path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,java,resource,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1530188116;Apply the given relative path to the given Java resource path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,java,resource,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1531843079;Apply the given relative path to the given Java resource path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,java,resource,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1531905026;Apply the given relative path to the given Java resource path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,java,resource,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1533557519;Apply the given relative path to the given Java resource path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,java,resource,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1533602820;Apply the given relative path to the given Java resource path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,java,resource,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1535316501;Apply the given relative path to the given Java resource path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,java,resource,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1550237113;Apply the given relative path to the given Java resource path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,java,resource,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String applyRelativePath(String path, String relativePath);1550238935;Apply the given relative path to the given Java resource path,_assuming standard Java folder separation (i.e. "/" separators)._@param path the path to start from (usually a full file path)_@param relativePath the relative path to apply_(relative to the full file path above)_@return the full file path that results from applying the relative path;public static String applyRelativePath(String path, String relativePath) {_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (separatorIndex != -1) {_			String newPath = path.substring(0, separatorIndex)__			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {_				newPath += FOLDER_SEPARATOR__			}_			return newPath + relativePath__		}_		else {_			return relativePath__		}_	};apply,the,given,relative,path,to,the,given,java,resource,path,assuming,standard,java,folder,separation,i,e,separators,param,path,the,path,to,start,from,usually,a,full,file,path,param,relative,path,the,relative,path,to,apply,relative,to,the,full,file,path,above,return,the,full,file,path,that,results,from,applying,the,relative,path;public,static,string,apply,relative,path,string,path,string,relative,path,int,separator,index,path,last,index,of,if,separator,index,1,string,new,path,path,substring,0,separator,index,if,relative,path,starts,with,new,path,return,new,path,relative,path,else,return,relative,path
StringUtils -> public static String delete(String inString, String pattern);1328020251;Delete all occurrences of the given substring._@param inString the original String_@param pattern the pattern to delete all occurrences of_@return the resulting String;public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1337236962;Delete all occurrences of the given substring._@param inString the original String_@param pattern the pattern to delete all occurrences of_@return the resulting String;public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1356735495;Delete all occurrences of the given substring._@param inString the original String_@param pattern the pattern to delete all occurrences of_@return the resulting String;public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1367955086;Delete all occurrences of the given substring._@param inString the original String_@param pattern the pattern to delete all occurrences of_@return the resulting String;public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1380921248;Delete all occurrences of the given substring._@param inString the original String_@param pattern the pattern to delete all occurrences of_@return the resulting String;public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1382750743;Delete all occurrences of the given substring._@param inString the original String_@param pattern the pattern to delete all occurrences of_@return the resulting String;public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1385423968;Delete all occurrences of the given substring._@param inString the original String_@param pattern the pattern to delete all occurrences of_@return the resulting String;public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1400189212;Delete all occurrences of the given substring._@param inString the original String_@param pattern the pattern to delete all occurrences of_@return the resulting String;public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1400531359;Delete all occurrences of the given substring._@param inString the original String_@param pattern the pattern to delete all occurrences of_@return the resulting String;public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1402676350;Delete all occurrences of the given substring._@param inString the original String_@param pattern the pattern to delete all occurrences of_@return the resulting String;public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1426267150;Delete all occurrences of the given substring._@param inString the original String_@param pattern the pattern to delete all occurrences of_@return the resulting String;public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1429034538;Delete all occurrences of the given substring._@param inString the original String_@param pattern the pattern to delete all occurrences of_@return the resulting String;public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1429034756;Delete all occurrences of the given substring._@param inString the original {@code String}_@param pattern the pattern to delete all occurrences of_@return the resulting {@code String};public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,code,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,code,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1431006895;Delete all occurrences of the given substring._@param inString the original {@code String}_@param pattern the pattern to delete all occurrences of_@return the resulting {@code String};public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,code,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,code,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1431007368;Delete all occurrences of the given substring._@param inString the original {@code String}_@param pattern the pattern to delete all occurrences of_@return the resulting {@code String};public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,code,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,code,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1449489126;Delete all occurrences of the given substring._@param inString the original {@code String}_@param pattern the pattern to delete all occurrences of_@return the resulting {@code String};public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,code,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,code,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1467730834;Delete all occurrences of the given substring._@param inString the original {@code String}_@param pattern the pattern to delete all occurrences of_@return the resulting {@code String};public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,code,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,code,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1472128018;Delete all occurrences of the given substring._@param inString the original {@code String}_@param pattern the pattern to delete all occurrences of_@return the resulting {@code String};public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,code,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,code,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1472202842;Delete all occurrences of the given substring._@param inString the original {@code String}_@param pattern the pattern to delete all occurrences of_@return the resulting {@code String};public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,code,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,code,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1473942665;Delete all occurrences of the given substring._@param inString the original {@code String}_@param pattern the pattern to delete all occurrences of_@return the resulting {@code String};public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,code,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,code,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1484248946;Delete all occurrences of the given substring._@param inString the original {@code String}_@param pattern the pattern to delete all occurrences of_@return the resulting {@code String};public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,code,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,code,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1484260238;Delete all occurrences of the given substring._@param inString the original {@code String}_@param pattern the pattern to delete all occurrences of_@return the resulting {@code String};public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,code,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,code,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1484694546;Delete all occurrences of the given substring._@param inString the original {@code String}_@param pattern the pattern to delete all occurrences of_@return the resulting {@code String};public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,code,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,code,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1487760984;Delete all occurrences of the given substring._@param inString the original {@code String}_@param pattern the pattern to delete all occurrences of_@return the resulting {@code String};public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,code,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,code,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1487778834;Delete all occurrences of the given substring._@param inString the original {@code String}_@param pattern the pattern to delete all occurrences of_@return the resulting {@code String};public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,code,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,code,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1491898314;Delete all occurrences of the given substring._@param inString the original {@code String}_@param pattern the pattern to delete all occurrences of_@return the resulting {@code String};public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,code,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,code,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1491903650;Delete all occurrences of the given substring._@param inString the original {@code String}_@param pattern the pattern to delete all occurrences of_@return the resulting {@code String};public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,code,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,code,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1495868221;Delete all occurrences of the given substring._@param inString the original {@code String}_@param pattern the pattern to delete all occurrences of_@return the resulting {@code String};public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,code,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,code,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1496243689;Delete all occurrences of the given substring._@param inString the original {@code String}_@param pattern the pattern to delete all occurrences of_@return the resulting {@code String};public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,code,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,code,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1496259743;Delete all occurrences of the given substring._@param inString the original {@code String}_@param pattern the pattern to delete all occurrences of_@return the resulting {@code String};public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,code,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,code,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1496837955;Delete all occurrences of the given substring._@param inString the original {@code String}_@param pattern the pattern to delete all occurrences of_@return the resulting {@code String};public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,code,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,code,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1499270197;Delete all occurrences of the given substring._@param inString the original {@code String}_@param pattern the pattern to delete all occurrences of_@return the resulting {@code String};public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,code,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,code,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1508667152;Delete all occurrences of the given substring._@param inString the original {@code String}_@param pattern the pattern to delete all occurrences of_@return the resulting {@code String};public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,code,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,code,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1508675477;Delete all occurrences of the given substring._@param inString the original {@code String}_@param pattern the pattern to delete all occurrences of_@return the resulting {@code String};public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,code,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,code,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1508843807;Delete all occurrences of the given substring._@param inString the original {@code String}_@param pattern the pattern to delete all occurrences of_@return the resulting {@code String};public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,code,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,code,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1516903831;Delete all occurrences of the given substring._@param inString the original {@code String}_@param pattern the pattern to delete all occurrences of_@return the resulting {@code String};public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,code,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,code,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1519295386;Delete all occurrences of the given substring._@param inString the original {@code String}_@param pattern the pattern to delete all occurrences of_@return the resulting {@code String};public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,code,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,code,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1519308837;Delete all occurrences of the given substring._@param inString the original {@code String}_@param pattern the pattern to delete all occurrences of_@return the resulting {@code String};public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,code,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,code,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1519588127;Delete all occurrences of the given substring._@param inString the original {@code String}_@param pattern the pattern to delete all occurrences of_@return the resulting {@code String};public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,code,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,code,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1522332352;Delete all occurrences of the given substring._@param inString the original {@code String}_@param pattern the pattern to delete all occurrences of_@return the resulting {@code String};public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,code,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,code,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1525166194;Delete all occurrences of the given substring._@param inString the original {@code String}_@param pattern the pattern to delete all occurrences of_@return the resulting {@code String};public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,code,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,code,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1530188116;Delete all occurrences of the given substring._@param inString the original {@code String}_@param pattern the pattern to delete all occurrences of_@return the resulting {@code String};public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,code,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,code,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1531843079;Delete all occurrences of the given substring._@param inString the original {@code String}_@param pattern the pattern to delete all occurrences of_@return the resulting {@code String};public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,code,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,code,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1531905026;Delete all occurrences of the given substring._@param inString the original {@code String}_@param pattern the pattern to delete all occurrences of_@return the resulting {@code String};public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,code,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,code,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1533557519;Delete all occurrences of the given substring._@param inString the original {@code String}_@param pattern the pattern to delete all occurrences of_@return the resulting {@code String};public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,code,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,code,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1533602820;Delete all occurrences of the given substring._@param inString the original {@code String}_@param pattern the pattern to delete all occurrences of_@return the resulting {@code String};public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,code,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,code,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1535316501;Delete all occurrences of the given substring._@param inString the original {@code String}_@param pattern the pattern to delete all occurrences of_@return the resulting {@code String};public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,code,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,code,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1550237113;Delete all occurrences of the given substring._@param inString the original {@code String}_@param pattern the pattern to delete all occurrences of_@return the resulting {@code String};public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,code,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,code,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static String delete(String inString, String pattern);1550238935;Delete all occurrences of the given substring._@param inString the original {@code String}_@param pattern the pattern to delete all occurrences of_@return the resulting {@code String};public static String delete(String inString, String pattern) {_		return replace(inString, pattern, "")__	};delete,all,occurrences,of,the,given,substring,param,in,string,the,original,code,string,param,pattern,the,pattern,to,delete,all,occurrences,of,return,the,resulting,code,string;public,static,string,delete,string,in,string,string,pattern,return,replace,in,string,pattern
StringUtils -> public static boolean hasText(@Nullable CharSequence str);1495868221;Check whether the given {@code CharSequence} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code CharSequence} is not {@code null}, its length is greater than_0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(@Nullable CharSequence str) {_		if (!hasLength(str)) {_			return false__		}__		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (!Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,nullable,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean hasText(@Nullable CharSequence str);1496243689;Check whether the given {@code CharSequence} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code CharSequence} is not {@code null}, its length is greater than_0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(@Nullable CharSequence str) {_		if (!hasLength(str)) {_			return false__		}__		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (!Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,nullable,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean hasText(@Nullable CharSequence str);1496259743;Check whether the given {@code CharSequence} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code CharSequence} is not {@code null}, its length is greater than_0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(@Nullable CharSequence str) {_		if (!hasLength(str)) {_			return false__		}__		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (!Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,nullable,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean hasText(@Nullable CharSequence str);1496837955;Check whether the given {@code CharSequence} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code CharSequence} is not {@code null}, its length is greater than_0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(@Nullable CharSequence str) {_		if (!hasLength(str)) {_			return false__		}__		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (!Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,nullable,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean hasText(@Nullable CharSequence str);1499270197;Check whether the given {@code CharSequence} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code CharSequence} is not {@code null}, its length is greater than_0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(@Nullable CharSequence str) {_		if (!hasLength(str)) {_			return false__		}__		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (!Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,nullable,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean hasText(@Nullable CharSequence str);1508667152;Check whether the given {@code CharSequence} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code CharSequence} is not {@code null}, its length is greater than_0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(@Nullable CharSequence str) {_		return (hasLength(str) && containsText(str))__	};check,whether,the,given,code,char,sequence,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,nullable,char,sequence,str,return,has,length,str,contains,text,str
StringUtils -> public static boolean hasText(@Nullable CharSequence str);1508675477;Check whether the given {@code CharSequence} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code CharSequence} is not {@code null}, its length is greater than_0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(@Nullable CharSequence str) {_		return (hasLength(str) && containsText(str))__	};check,whether,the,given,code,char,sequence,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,nullable,char,sequence,str,return,has,length,str,contains,text,str
StringUtils -> public static boolean hasText(@Nullable CharSequence str);1508843807;Check whether the given {@code CharSequence} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code CharSequence} is not {@code null}, its length is greater than_0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(@Nullable CharSequence str) {_		return (str != null && str.length() > 0 && containsText(str))__	};check,whether,the,given,code,char,sequence,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,nullable,char,sequence,str,return,str,null,str,length,0,contains,text,str
StringUtils -> public static boolean hasText(@Nullable CharSequence str);1516903831;Check whether the given {@code CharSequence} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code CharSequence} is not {@code null}, its length is greater than_0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(@Nullable CharSequence str) {_		return (str != null && str.length() > 0 && containsText(str))__	};check,whether,the,given,code,char,sequence,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,nullable,char,sequence,str,return,str,null,str,length,0,contains,text,str
StringUtils -> public static boolean hasText(@Nullable CharSequence str);1519295386;Check whether the given {@code CharSequence} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code CharSequence} is not {@code null}, its length is greater than_0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(@Nullable CharSequence str) {_		return (str != null && str.length() > 0 && containsText(str))__	};check,whether,the,given,code,char,sequence,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,nullable,char,sequence,str,return,str,null,str,length,0,contains,text,str
StringUtils -> public static boolean hasText(@Nullable CharSequence str);1519308837;Check whether the given {@code CharSequence} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code CharSequence} is not {@code null}, its length is greater than_0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(@Nullable CharSequence str) {_		return (str != null && str.length() > 0 && containsText(str))__	};check,whether,the,given,code,char,sequence,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,nullable,char,sequence,str,return,str,null,str,length,0,contains,text,str
StringUtils -> public static boolean hasText(@Nullable CharSequence str);1519588127;Check whether the given {@code CharSequence} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code CharSequence} is not {@code null}, its length is greater than_0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(@Nullable CharSequence str) {_		return (str != null && str.length() > 0 && containsText(str))__	};check,whether,the,given,code,char,sequence,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,nullable,char,sequence,str,return,str,null,str,length,0,contains,text,str
StringUtils -> public static boolean hasText(@Nullable CharSequence str);1522332352;Check whether the given {@code CharSequence} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code CharSequence} is not {@code null}, its length is greater than_0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(@Nullable CharSequence str) {_		return (str != null && str.length() > 0 && containsText(str))__	};check,whether,the,given,code,char,sequence,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,nullable,char,sequence,str,return,str,null,str,length,0,contains,text,str
StringUtils -> public static boolean hasText(@Nullable CharSequence str);1525166194;Check whether the given {@code CharSequence} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code CharSequence} is not {@code null}, its length is greater than_0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(@Nullable CharSequence str) {_		return (str != null && str.length() > 0 && containsText(str))__	};check,whether,the,given,code,char,sequence,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,nullable,char,sequence,str,return,str,null,str,length,0,contains,text,str
StringUtils -> public static boolean hasText(@Nullable CharSequence str);1530188116;Check whether the given {@code CharSequence} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code CharSequence} is not {@code null}, its length is greater than_0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(@Nullable CharSequence str) {_		return (str != null && str.length() > 0 && containsText(str))__	};check,whether,the,given,code,char,sequence,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,nullable,char,sequence,str,return,str,null,str,length,0,contains,text,str
StringUtils -> public static boolean hasText(@Nullable CharSequence str);1531843079;Check whether the given {@code CharSequence} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code CharSequence} is not {@code null}, its length is greater than_0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(@Nullable CharSequence str) {_		return (str != null && str.length() > 0 && containsText(str))__	};check,whether,the,given,code,char,sequence,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,nullable,char,sequence,str,return,str,null,str,length,0,contains,text,str
StringUtils -> public static boolean hasText(@Nullable CharSequence str);1531905026;Check whether the given {@code CharSequence} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code CharSequence} is not {@code null}, its length is greater than_0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(@Nullable CharSequence str) {_		return (str != null && str.length() > 0 && containsText(str))__	};check,whether,the,given,code,char,sequence,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,nullable,char,sequence,str,return,str,null,str,length,0,contains,text,str
StringUtils -> public static boolean hasText(@Nullable CharSequence str);1533557519;Check whether the given {@code CharSequence} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code CharSequence} is not {@code null}, its length is greater than_0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(@Nullable CharSequence str) {_		return (str != null && str.length() > 0 && containsText(str))__	};check,whether,the,given,code,char,sequence,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,nullable,char,sequence,str,return,str,null,str,length,0,contains,text,str
StringUtils -> public static boolean hasText(@Nullable CharSequence str);1533602820;Check whether the given {@code CharSequence} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code CharSequence} is not {@code null}, its length is greater than_0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(@Nullable CharSequence str) {_		return (str != null && str.length() > 0 && containsText(str))__	};check,whether,the,given,code,char,sequence,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,nullable,char,sequence,str,return,str,null,str,length,0,contains,text,str
StringUtils -> public static boolean hasText(@Nullable CharSequence str);1535316501;Check whether the given {@code CharSequence} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code CharSequence} is not {@code null}, its length is greater than_0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(@Nullable CharSequence str) {_		return (str != null && str.length() > 0 && containsText(str))__	};check,whether,the,given,code,char,sequence,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,nullable,char,sequence,str,return,str,null,str,length,0,contains,text,str
StringUtils -> public static boolean hasText(@Nullable CharSequence str);1550237113;Check whether the given {@code CharSequence} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code CharSequence} is not {@code null}, its length is greater than_0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(@Nullable CharSequence str) {_		return (str != null && str.length() > 0 && containsText(str))__	};check,whether,the,given,code,char,sequence,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,nullable,char,sequence,str,return,str,null,str,length,0,contains,text,str
StringUtils -> public static boolean hasText(@Nullable CharSequence str);1550238935;Check whether the given {@code CharSequence} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code CharSequence} is not {@code null}, its length is greater than_0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(@Nullable CharSequence str) {_		return (str != null && str.length() > 0 && containsText(str))__	};check,whether,the,given,code,char,sequence,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,nullable,char,sequence,str,return,str,null,str,length,0,contains,text,str
StringUtils -> public static boolean isNotEmpty(CharSequence str);1429034538;Check that the given {@code CharSequence} is not empty (i.e., neither_{@code null} nor of length 0)._<p>This method is an alias for {@link #hasLength(CharSequence)}._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(CharSequence)_@since 4.2;public static boolean isNotEmpty(CharSequence str) {_		return hasLength(str)__	};check,that,the,given,code,char,sequence,is,not,empty,i,e,neither,code,null,nor,of,length,0,p,this,method,is,an,alias,for,link,has,length,char,sequence,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,char,sequence,since,4,2;public,static,boolean,is,not,empty,char,sequence,str,return,has,length,str
StringUtils -> public static boolean isNotEmpty(CharSequence str);1429034756;Check that the given {@code CharSequence} is not empty (i.e., neither_{@code null} nor of length 0)._<p>This method is an alias for {@link #hasLength(CharSequence)}._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(CharSequence)_@since 4.2;public static boolean isNotEmpty(CharSequence str) {_		return hasLength(str)__	};check,that,the,given,code,char,sequence,is,not,empty,i,e,neither,code,null,nor,of,length,0,p,this,method,is,an,alias,for,link,has,length,char,sequence,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,char,sequence,since,4,2;public,static,boolean,is,not,empty,char,sequence,str,return,has,length,str
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1328020251;Trim all occurences of the supplied trailing character from the given String._@param str the String to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed String;public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurences,of,the,supplied,trailing,character,from,the,given,string,param,str,the,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1337236962;Trim all occurences of the supplied trailing character from the given String._@param str the String to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed String;public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurences,of,the,supplied,trailing,character,from,the,given,string,param,str,the,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1356735495;Trim all occurences of the supplied trailing character from the given String._@param str the String to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed String;public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurences,of,the,supplied,trailing,character,from,the,given,string,param,str,the,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1367955086;Trim all occurences of the supplied trailing character from the given String._@param str the String to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed String;public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurences,of,the,supplied,trailing,character,from,the,given,string,param,str,the,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1380921248;Trim all occurences of the supplied trailing character from the given String._@param str the String to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed String;public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurences,of,the,supplied,trailing,character,from,the,given,string,param,str,the,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1382750743;Trim all occurences of the supplied trailing character from the given String._@param str the String to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed String;public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurences,of,the,supplied,trailing,character,from,the,given,string,param,str,the,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1385423968;Trim all occurrences of the supplied trailing character from the given String._@param str the String to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed String;public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,string,param,str,the,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1400189212;Trim all occurrences of the supplied trailing character from the given String._@param str the String to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed String;public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,string,param,str,the,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1400531359;Trim all occurrences of the supplied trailing character from the given String._@param str the String to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed String;public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,string,param,str,the,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1402676350;Trim all occurrences of the supplied trailing character from the given String._@param str the String to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed String;public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,string,param,str,the,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1426267150;Trim all occurrences of the supplied trailing character from the given String._@param str the String to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed String;public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,string,param,str,the,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1429034538;Trim all occurrences of the supplied trailing character from the given String._@param str the String to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed String;public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,string,param,str,the,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1429034756;Trim all occurrences of the supplied trailing character from the given {@code String}._@param str the {@code String} to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed {@code String};public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,code,string,param,str,the,code,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1431006895;Trim all occurrences of the supplied trailing character from the given {@code String}._@param str the {@code String} to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed {@code String};public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,code,string,param,str,the,code,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1431007368;Trim all occurrences of the supplied trailing character from the given {@code String}._@param str the {@code String} to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed {@code String};public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,code,string,param,str,the,code,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1449489126;Trim all occurrences of the supplied trailing character from the given {@code String}._@param str the {@code String} to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed {@code String};public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,code,string,param,str,the,code,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1467730834;Trim all occurrences of the supplied trailing character from the given {@code String}._@param str the {@code String} to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed {@code String};public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,code,string,param,str,the,code,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1472128018;Trim all occurrences of the supplied trailing character from the given {@code String}._@param str the {@code String} to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed {@code String};public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,code,string,param,str,the,code,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1472202842;Trim all occurrences of the supplied trailing character from the given {@code String}._@param str the {@code String} to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed {@code String};public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,code,string,param,str,the,code,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1473942665;Trim all occurrences of the supplied trailing character from the given {@code String}._@param str the {@code String} to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed {@code String};public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,code,string,param,str,the,code,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1484248946;Trim all occurrences of the supplied trailing character from the given {@code String}._@param str the {@code String} to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed {@code String};public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,code,string,param,str,the,code,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1484260238;Trim all occurrences of the supplied trailing character from the given {@code String}._@param str the {@code String} to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed {@code String};public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,code,string,param,str,the,code,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1484694546;Trim all occurrences of the supplied trailing character from the given {@code String}._@param str the {@code String} to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed {@code String};public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,code,string,param,str,the,code,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1487760984;Trim all occurrences of the supplied trailing character from the given {@code String}._@param str the {@code String} to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed {@code String};public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,code,string,param,str,the,code,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1487778834;Trim all occurrences of the supplied trailing character from the given {@code String}._@param str the {@code String} to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed {@code String};public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,code,string,param,str,the,code,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1491898314;Trim all occurrences of the supplied trailing character from the given {@code String}._@param str the {@code String} to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed {@code String};public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,code,string,param,str,the,code,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1491903650;Trim all occurrences of the supplied trailing character from the given {@code String}._@param str the {@code String} to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed {@code String};public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,code,string,param,str,the,code,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1495868221;Trim all occurrences of the supplied trailing character from the given {@code String}._@param str the {@code String} to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed {@code String};public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,code,string,param,str,the,code,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1496243689;Trim all occurrences of the supplied trailing character from the given {@code String}._@param str the {@code String} to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed {@code String};public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,code,string,param,str,the,code,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1496259743;Trim all occurrences of the supplied trailing character from the given {@code String}._@param str the {@code String} to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed {@code String};public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,code,string,param,str,the,code,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1496837955;Trim all occurrences of the supplied trailing character from the given {@code String}._@param str the {@code String} to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed {@code String};public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,code,string,param,str,the,code,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1499270197;Trim all occurrences of the supplied trailing character from the given {@code String}._@param str the {@code String} to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed {@code String};public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,code,string,param,str,the,code,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1508667152;Trim all occurrences of the supplied trailing character from the given {@code String}._@param str the {@code String} to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed {@code String};public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,code,string,param,str,the,code,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1508675477;Trim all occurrences of the supplied trailing character from the given {@code String}._@param str the {@code String} to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed {@code String};public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,code,string,param,str,the,code,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1508843807;Trim all occurrences of the supplied trailing character from the given {@code String}._@param str the {@code String} to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed {@code String};public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,code,string,param,str,the,code,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1516903831;Trim all occurrences of the supplied trailing character from the given {@code String}._@param str the {@code String} to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed {@code String};public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,code,string,param,str,the,code,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1519295386;Trim all occurrences of the supplied trailing character from the given {@code String}._@param str the {@code String} to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed {@code String};public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,code,string,param,str,the,code,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1519308837;Trim all occurrences of the supplied trailing character from the given {@code String}._@param str the {@code String} to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed {@code String};public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,code,string,param,str,the,code,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1519588127;Trim all occurrences of the supplied trailing character from the given {@code String}._@param str the {@code String} to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed {@code String};public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,code,string,param,str,the,code,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1522332352;Trim all occurrences of the supplied trailing character from the given {@code String}._@param str the {@code String} to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed {@code String};public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,code,string,param,str,the,code,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1525166194;Trim all occurrences of the supplied trailing character from the given {@code String}._@param str the {@code String} to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed {@code String};public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,code,string,param,str,the,code,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1530188116;Trim all occurrences of the supplied trailing character from the given {@code String}._@param str the {@code String} to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed {@code String};public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,code,string,param,str,the,code,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1531843079;Trim all occurrences of the supplied trailing character from the given {@code String}._@param str the {@code String} to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed {@code String};public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,code,string,param,str,the,code,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1531905026;Trim all occurrences of the supplied trailing character from the given {@code String}._@param str the {@code String} to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed {@code String};public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,code,string,param,str,the,code,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1533557519;Trim all occurrences of the supplied trailing character from the given {@code String}._@param str the {@code String} to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed {@code String};public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,code,string,param,str,the,code,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1533602820;Trim all occurrences of the supplied trailing character from the given {@code String}._@param str the {@code String} to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed {@code String};public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,code,string,param,str,the,code,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1535316501;Trim all occurrences of the supplied trailing character from the given {@code String}._@param str the {@code String} to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed {@code String};public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,code,string,param,str,the,code,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1550237113;Trim all occurrences of the supplied trailing character from the given {@code String}._@param str the {@code String} to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed {@code String};public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,code,string,param,str,the,code,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimTrailingCharacter(String str, char trailingCharacter);1550238935;Trim all occurrences of the supplied trailing character from the given {@code String}._@param str the {@code String} to check_@param trailingCharacter the trailing character to be trimmed_@return the trimmed {@code String};public static String trimTrailingCharacter(String str, char trailingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,trailing,character,from,the,given,code,string,param,str,the,code,string,to,check,param,trailing,character,the,trailing,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,trailing,character,string,str,char,trailing,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,sb,length,1,trailing,character,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static boolean hasLength(String str);1328020251;Check that the given String is neither <code>null</code> nor of length 0._Note: Will return <code>true</code> for a String that purely consists of whitespace._@param str the String to check (may be <code>null</code>)_@return <code>true</code> if the String is not null and has length_@see #hasLength(CharSequence);public static boolean hasLength(String str) {_		return hasLength((CharSequence) str)__	};check,that,the,given,string,is,neither,code,null,code,nor,of,length,0,note,will,return,code,true,code,for,a,string,that,purely,consists,of,whitespace,param,str,the,string,to,check,may,be,code,null,code,return,code,true,code,if,the,string,is,not,null,and,has,length,see,has,length,char,sequence;public,static,boolean,has,length,string,str,return,has,length,char,sequence,str
StringUtils -> public static boolean hasLength(String str);1337236962;Check that the given String is neither <code>null</code> nor of length 0._Note: Will return <code>true</code> for a String that purely consists of whitespace._@param str the String to check (may be <code>null</code>)_@return <code>true</code> if the String is not null and has length_@see #hasLength(CharSequence);public static boolean hasLength(String str) {_		return hasLength((CharSequence) str)__	};check,that,the,given,string,is,neither,code,null,code,nor,of,length,0,note,will,return,code,true,code,for,a,string,that,purely,consists,of,whitespace,param,str,the,string,to,check,may,be,code,null,code,return,code,true,code,if,the,string,is,not,null,and,has,length,see,has,length,char,sequence;public,static,boolean,has,length,string,str,return,has,length,char,sequence,str
StringUtils -> public static boolean hasLength(String str);1356735495;Check that the given String is neither {@code null} nor of length 0._Note: Will return {@code true} for a String that purely consists of whitespace._@param str the String to check (may be {@code null})_@return {@code true} if the String is not null and has length_@see #hasLength(CharSequence);public static boolean hasLength(String str) {_		return hasLength((CharSequence) str)__	};check,that,the,given,string,is,neither,code,null,nor,of,length,0,note,will,return,code,true,for,a,string,that,purely,consists,of,whitespace,param,str,the,string,to,check,may,be,code,null,return,code,true,if,the,string,is,not,null,and,has,length,see,has,length,char,sequence;public,static,boolean,has,length,string,str,return,has,length,char,sequence,str
StringUtils -> public static boolean hasLength(String str);1367955086;Check that the given String is neither {@code null} nor of length 0._Note: Will return {@code true} for a String that purely consists of whitespace._@param str the String to check (may be {@code null})_@return {@code true} if the String is not null and has length_@see #hasLength(CharSequence);public static boolean hasLength(String str) {_		return hasLength((CharSequence) str)__	};check,that,the,given,string,is,neither,code,null,nor,of,length,0,note,will,return,code,true,for,a,string,that,purely,consists,of,whitespace,param,str,the,string,to,check,may,be,code,null,return,code,true,if,the,string,is,not,null,and,has,length,see,has,length,char,sequence;public,static,boolean,has,length,string,str,return,has,length,char,sequence,str
StringUtils -> public static boolean hasLength(String str);1380921248;Check that the given String is neither {@code null} nor of length 0._Note: Will return {@code true} for a String that purely consists of whitespace._@param str the String to check (may be {@code null})_@return {@code true} if the String is not null and has length_@see #hasLength(CharSequence);public static boolean hasLength(String str) {_		return hasLength((CharSequence) str)__	};check,that,the,given,string,is,neither,code,null,nor,of,length,0,note,will,return,code,true,for,a,string,that,purely,consists,of,whitespace,param,str,the,string,to,check,may,be,code,null,return,code,true,if,the,string,is,not,null,and,has,length,see,has,length,char,sequence;public,static,boolean,has,length,string,str,return,has,length,char,sequence,str
StringUtils -> public static boolean hasLength(String str);1382750743;Check that the given String is neither {@code null} nor of length 0._Note: Will return {@code true} for a String that purely consists of whitespace._@param str the String to check (may be {@code null})_@return {@code true} if the String is not null and has length_@see #hasLength(CharSequence);public static boolean hasLength(String str) {_		return hasLength((CharSequence) str)__	};check,that,the,given,string,is,neither,code,null,nor,of,length,0,note,will,return,code,true,for,a,string,that,purely,consists,of,whitespace,param,str,the,string,to,check,may,be,code,null,return,code,true,if,the,string,is,not,null,and,has,length,see,has,length,char,sequence;public,static,boolean,has,length,string,str,return,has,length,char,sequence,str
StringUtils -> public static boolean hasLength(String str);1385423968;Check that the given String is neither {@code null} nor of length 0._Note: Will return {@code true} for a String that purely consists of whitespace._@param str the String to check (may be {@code null})_@return {@code true} if the String is not null and has length_@see #hasLength(CharSequence);public static boolean hasLength(String str) {_		return hasLength((CharSequence) str)__	};check,that,the,given,string,is,neither,code,null,nor,of,length,0,note,will,return,code,true,for,a,string,that,purely,consists,of,whitespace,param,str,the,string,to,check,may,be,code,null,return,code,true,if,the,string,is,not,null,and,has,length,see,has,length,char,sequence;public,static,boolean,has,length,string,str,return,has,length,char,sequence,str
StringUtils -> public static boolean hasLength(String str);1400189212;Check that the given String is neither {@code null} nor of length 0._Note: Will return {@code true} for a String that purely consists of whitespace._@param str the String to check (may be {@code null})_@return {@code true} if the String is not null and has length_@see #hasLength(CharSequence);public static boolean hasLength(String str) {_		return hasLength((CharSequence) str)__	};check,that,the,given,string,is,neither,code,null,nor,of,length,0,note,will,return,code,true,for,a,string,that,purely,consists,of,whitespace,param,str,the,string,to,check,may,be,code,null,return,code,true,if,the,string,is,not,null,and,has,length,see,has,length,char,sequence;public,static,boolean,has,length,string,str,return,has,length,char,sequence,str
StringUtils -> public static boolean hasLength(String str);1400531359;Check that the given String is neither {@code null} nor of length 0._Note: Will return {@code true} for a String that purely consists of whitespace._@param str the String to check (may be {@code null})_@return {@code true} if the String is not null and has length_@see #hasLength(CharSequence);public static boolean hasLength(String str) {_		return hasLength((CharSequence) str)__	};check,that,the,given,string,is,neither,code,null,nor,of,length,0,note,will,return,code,true,for,a,string,that,purely,consists,of,whitespace,param,str,the,string,to,check,may,be,code,null,return,code,true,if,the,string,is,not,null,and,has,length,see,has,length,char,sequence;public,static,boolean,has,length,string,str,return,has,length,char,sequence,str
StringUtils -> public static boolean hasLength(String str);1402676350;Check that the given String is neither {@code null} nor of length 0._Note: Will return {@code true} for a String that purely consists of whitespace._@param str the String to check (may be {@code null})_@return {@code true} if the String is not null and has length_@see #hasLength(CharSequence);public static boolean hasLength(String str) {_		return hasLength((CharSequence) str)__	};check,that,the,given,string,is,neither,code,null,nor,of,length,0,note,will,return,code,true,for,a,string,that,purely,consists,of,whitespace,param,str,the,string,to,check,may,be,code,null,return,code,true,if,the,string,is,not,null,and,has,length,see,has,length,char,sequence;public,static,boolean,has,length,string,str,return,has,length,char,sequence,str
StringUtils -> public static boolean hasLength(String str);1426267150;Check that the given String is neither {@code null} nor of length 0._Note: Will return {@code true} for a String that purely consists of whitespace._@param str the String to check (may be {@code null})_@return {@code true} if the String is not null and has length_@see #hasLength(CharSequence);public static boolean hasLength(String str) {_		return hasLength((CharSequence) str)__	};check,that,the,given,string,is,neither,code,null,nor,of,length,0,note,will,return,code,true,for,a,string,that,purely,consists,of,whitespace,param,str,the,string,to,check,may,be,code,null,return,code,true,if,the,string,is,not,null,and,has,length,see,has,length,char,sequence;public,static,boolean,has,length,string,str,return,has,length,char,sequence,str
StringUtils -> public static boolean hasLength(String str);1429034538;Check that the given String is neither {@code null} nor of length 0._Note: Will return {@code true} for a String that purely consists of whitespace._@param str the String to check (may be {@code null})_@return {@code true} if the String is not null and has length_@see #hasLength(CharSequence);public static boolean hasLength(String str) {_		return hasLength((CharSequence) str)__	};check,that,the,given,string,is,neither,code,null,nor,of,length,0,note,will,return,code,true,for,a,string,that,purely,consists,of,whitespace,param,str,the,string,to,check,may,be,code,null,return,code,true,if,the,string,is,not,null,and,has,length,see,has,length,char,sequence;public,static,boolean,has,length,string,str,return,has,length,char,sequence,str
StringUtils -> public static boolean hasLength(String str);1429034756;Check that the given {@code String} is neither {@code null} nor of length 0._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasLength(CharSequence)_@see #hasText(String);public static boolean hasLength(String str) {_		return hasLength((CharSequence) str)__	};check,that,the,given,code,string,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,length,char,sequence,see,has,text,string;public,static,boolean,has,length,string,str,return,has,length,char,sequence,str
StringUtils -> public static boolean hasLength(String str);1431006895;Check that the given {@code String} is neither {@code null} nor of length 0._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasLength(CharSequence)_@see #hasText(String);public static boolean hasLength(String str) {_		return hasLength((CharSequence) str)__	};check,that,the,given,code,string,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,length,char,sequence,see,has,text,string;public,static,boolean,has,length,string,str,return,has,length,char,sequence,str
StringUtils -> public static boolean hasLength(String str);1431007368;Check that the given {@code String} is neither {@code null} nor of length 0._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasLength(CharSequence)_@see #hasText(String);public static boolean hasLength(String str) {_		return hasLength((CharSequence) str)__	};check,that,the,given,code,string,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,length,char,sequence,see,has,text,string;public,static,boolean,has,length,string,str,return,has,length,char,sequence,str
StringUtils -> public static boolean hasLength(String str);1449489126;Check that the given {@code String} is neither {@code null} nor of length 0._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasLength(CharSequence)_@see #hasText(String);public static boolean hasLength(String str) {_		return hasLength((CharSequence) str)__	};check,that,the,given,code,string,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,length,char,sequence,see,has,text,string;public,static,boolean,has,length,string,str,return,has,length,char,sequence,str
StringUtils -> public static boolean hasLength(String str);1467730834;Check that the given {@code String} is neither {@code null} nor of length 0._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasLength(CharSequence)_@see #hasText(String);public static boolean hasLength(String str) {_		return hasLength((CharSequence) str)__	};check,that,the,given,code,string,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,length,char,sequence,see,has,text,string;public,static,boolean,has,length,string,str,return,has,length,char,sequence,str
StringUtils -> public static boolean hasLength(String str);1472128018;Check that the given {@code String} is neither {@code null} nor of length 0._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasLength(CharSequence)_@see #hasText(String);public static boolean hasLength(String str) {_		return hasLength((CharSequence) str)__	};check,that,the,given,code,string,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,length,char,sequence,see,has,text,string;public,static,boolean,has,length,string,str,return,has,length,char,sequence,str
StringUtils -> public static boolean hasLength(String str);1472202842;Check that the given {@code String} is neither {@code null} nor of length 0._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasLength(CharSequence)_@see #hasText(String);public static boolean hasLength(String str) {_		return hasLength((CharSequence) str)__	};check,that,the,given,code,string,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,length,char,sequence,see,has,text,string;public,static,boolean,has,length,string,str,return,has,length,char,sequence,str
StringUtils -> public static boolean hasLength(String str);1473942665;Check that the given {@code String} is neither {@code null} nor of length 0._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasLength(CharSequence)_@see #hasText(String);public static boolean hasLength(String str) {_		return hasLength((CharSequence) str)__	};check,that,the,given,code,string,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,length,char,sequence,see,has,text,string;public,static,boolean,has,length,string,str,return,has,length,char,sequence,str
StringUtils -> public static boolean hasLength(String str);1484248946;Check that the given {@code String} is neither {@code null} nor of length 0._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasLength(CharSequence)_@see #hasText(String);public static boolean hasLength(String str) {_		return hasLength((CharSequence) str)__	};check,that,the,given,code,string,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,length,char,sequence,see,has,text,string;public,static,boolean,has,length,string,str,return,has,length,char,sequence,str
StringUtils -> public static boolean hasLength(String str);1484260238;Check that the given {@code String} is neither {@code null} nor of length 0._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasLength(CharSequence)_@see #hasText(String);public static boolean hasLength(String str) {_		return hasLength((CharSequence) str)__	};check,that,the,given,code,string,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,length,char,sequence,see,has,text,string;public,static,boolean,has,length,string,str,return,has,length,char,sequence,str
StringUtils -> public static boolean hasLength(String str);1484694546;Check that the given {@code String} is neither {@code null} nor of length 0._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasLength(CharSequence)_@see #hasText(String);public static boolean hasLength(String str) {_		return hasLength((CharSequence) str)__	};check,that,the,given,code,string,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,length,char,sequence,see,has,text,string;public,static,boolean,has,length,string,str,return,has,length,char,sequence,str
StringUtils -> public static boolean hasLength(String str);1487760984;Check that the given {@code String} is neither {@code null} nor of length 0._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasLength(CharSequence)_@see #hasText(String);public static boolean hasLength(String str) {_		return hasLength((CharSequence) str)__	};check,that,the,given,code,string,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,length,char,sequence,see,has,text,string;public,static,boolean,has,length,string,str,return,has,length,char,sequence,str
StringUtils -> public static boolean hasLength(String str);1487778834;Check that the given {@code String} is neither {@code null} nor of length 0._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasLength(CharSequence)_@see #hasText(String);public static boolean hasLength(String str) {_		return hasLength((CharSequence) str)__	};check,that,the,given,code,string,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,length,char,sequence,see,has,text,string;public,static,boolean,has,length,string,str,return,has,length,char,sequence,str
StringUtils -> public static boolean hasLength(String str);1491898314;Check that the given {@code String} is neither {@code null} nor of length 0._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasLength(CharSequence)_@see #hasText(String);public static boolean hasLength(String str) {_		return hasLength((CharSequence) str)__	};check,that,the,given,code,string,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,length,char,sequence,see,has,text,string;public,static,boolean,has,length,string,str,return,has,length,char,sequence,str
StringUtils -> public static boolean hasLength(String str);1491903650;Check that the given {@code String} is neither {@code null} nor of length 0._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasLength(CharSequence)_@see #hasText(String);public static boolean hasLength(String str) {_		return hasLength((CharSequence) str)__	};check,that,the,given,code,string,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,length,char,sequence,see,has,text,string;public,static,boolean,has,length,string,str,return,has,length,char,sequence,str
StringUtils -> @Nullable 	public static String[] split(String toSplit, String delimiter);1495868221;Split a {@code String} at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input {@code String};@Nullable_	public static String[] split(String toSplit, String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}__		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,code,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,code,string;nullable,public,static,string,split,string,to,split,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> @Nullable 	public static String[] split(String toSplit, String delimiter);1496243689;Split a {@code String} at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input {@code String};@Nullable_	public static String[] split(String toSplit, String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}__		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,code,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,code,string;nullable,public,static,string,split,string,to,split,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> @Nullable 	public static String[] split(String toSplit, String delimiter);1496259743;Split a {@code String} at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input {@code String};@Nullable_	public static String[] split(String toSplit, String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}__		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,code,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,code,string;nullable,public,static,string,split,string,to,split,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> public static Set<String> commaDelimitedListToSet(@Nullable String str);1496837955;Convert a comma delimited list (e.g., a row from a CSV file) into a set._<p>Note that this will suppress duplicates, and as of 4.2, the elements in_the returned set will preserve the original order in a {@link LinkedHashSet}._@param str the input {@code String}_@return a set of {@code String} entries in the list_@see #removeDuplicateStrings(String[]);public static Set<String> commaDelimitedListToSet(@Nullable String str) {_		Set<String> set = new LinkedHashSet<>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,a,set,p,note,that,this,will,suppress,duplicates,and,as,of,4,2,the,elements,in,the,returned,set,will,preserve,the,original,order,in,a,link,linked,hash,set,param,str,the,input,code,string,return,a,set,of,code,string,entries,in,the,list,see,remove,duplicate,strings,string;public,static,set,string,comma,delimited,list,to,set,nullable,string,str,set,string,set,new,linked,hash,set,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(@Nullable String str);1499270197;Convert a comma delimited list (e.g., a row from a CSV file) into a set._<p>Note that this will suppress duplicates, and as of 4.2, the elements in_the returned set will preserve the original order in a {@link LinkedHashSet}._@param str the input {@code String}_@return a set of {@code String} entries in the list_@see #removeDuplicateStrings(String[]);public static Set<String> commaDelimitedListToSet(@Nullable String str) {_		Set<String> set = new LinkedHashSet<>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,a,set,p,note,that,this,will,suppress,duplicates,and,as,of,4,2,the,elements,in,the,returned,set,will,preserve,the,original,order,in,a,link,linked,hash,set,param,str,the,input,code,string,return,a,set,of,code,string,entries,in,the,list,see,remove,duplicate,strings,string;public,static,set,string,comma,delimited,list,to,set,nullable,string,str,set,string,set,new,linked,hash,set,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(@Nullable String str);1508667152;Convert a comma delimited list (e.g., a row from a CSV file) into a set._<p>Note that this will suppress duplicates, and as of 4.2, the elements in_the returned set will preserve the original order in a {@link LinkedHashSet}._@param str the input {@code String}_@return a set of {@code String} entries in the list_@see #removeDuplicateStrings(String[]);public static Set<String> commaDelimitedListToSet(@Nullable String str) {_		Set<String> set = new LinkedHashSet<>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,a,set,p,note,that,this,will,suppress,duplicates,and,as,of,4,2,the,elements,in,the,returned,set,will,preserve,the,original,order,in,a,link,linked,hash,set,param,str,the,input,code,string,return,a,set,of,code,string,entries,in,the,list,see,remove,duplicate,strings,string;public,static,set,string,comma,delimited,list,to,set,nullable,string,str,set,string,set,new,linked,hash,set,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(@Nullable String str);1508675477;Convert a comma delimited list (e.g., a row from a CSV file) into a set._<p>Note that this will suppress duplicates, and as of 4.2, the elements in_the returned set will preserve the original order in a {@link LinkedHashSet}._@param str the input {@code String}_@return a set of {@code String} entries in the list_@see #removeDuplicateStrings(String[]);public static Set<String> commaDelimitedListToSet(@Nullable String str) {_		Set<String> set = new LinkedHashSet<>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,a,set,p,note,that,this,will,suppress,duplicates,and,as,of,4,2,the,elements,in,the,returned,set,will,preserve,the,original,order,in,a,link,linked,hash,set,param,str,the,input,code,string,return,a,set,of,code,string,entries,in,the,list,see,remove,duplicate,strings,string;public,static,set,string,comma,delimited,list,to,set,nullable,string,str,set,string,set,new,linked,hash,set,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(@Nullable String str);1508843807;Convert a comma delimited list (e.g., a row from a CSV file) into a set._<p>Note that this will suppress duplicates, and as of 4.2, the elements in_the returned set will preserve the original order in a {@link LinkedHashSet}._@param str the input {@code String}_@return a set of {@code String} entries in the list_@see #removeDuplicateStrings(String[]);public static Set<String> commaDelimitedListToSet(@Nullable String str) {_		Set<String> set = new LinkedHashSet<>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,a,set,p,note,that,this,will,suppress,duplicates,and,as,of,4,2,the,elements,in,the,returned,set,will,preserve,the,original,order,in,a,link,linked,hash,set,param,str,the,input,code,string,return,a,set,of,code,string,entries,in,the,list,see,remove,duplicate,strings,string;public,static,set,string,comma,delimited,list,to,set,nullable,string,str,set,string,set,new,linked,hash,set,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(@Nullable String str);1516903831;Convert a comma delimited list (e.g., a row from a CSV file) into a set._<p>Note that this will suppress duplicates, and as of 4.2, the elements in_the returned set will preserve the original order in a {@link LinkedHashSet}._@param str the input {@code String}_@return a set of {@code String} entries in the list_@see #removeDuplicateStrings(String[]);public static Set<String> commaDelimitedListToSet(@Nullable String str) {_		Set<String> set = new LinkedHashSet<>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,a,set,p,note,that,this,will,suppress,duplicates,and,as,of,4,2,the,elements,in,the,returned,set,will,preserve,the,original,order,in,a,link,linked,hash,set,param,str,the,input,code,string,return,a,set,of,code,string,entries,in,the,list,see,remove,duplicate,strings,string;public,static,set,string,comma,delimited,list,to,set,nullable,string,str,set,string,set,new,linked,hash,set,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(@Nullable String str);1519295386;Convert a comma delimited list (e.g., a row from a CSV file) into a set._<p>Note that this will suppress duplicates, and as of 4.2, the elements in_the returned set will preserve the original order in a {@link LinkedHashSet}._@param str the input {@code String}_@return a set of {@code String} entries in the list_@see #removeDuplicateStrings(String[]);public static Set<String> commaDelimitedListToSet(@Nullable String str) {_		Set<String> set = new LinkedHashSet<>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,a,set,p,note,that,this,will,suppress,duplicates,and,as,of,4,2,the,elements,in,the,returned,set,will,preserve,the,original,order,in,a,link,linked,hash,set,param,str,the,input,code,string,return,a,set,of,code,string,entries,in,the,list,see,remove,duplicate,strings,string;public,static,set,string,comma,delimited,list,to,set,nullable,string,str,set,string,set,new,linked,hash,set,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(@Nullable String str);1519308837;Convert a comma delimited list (e.g., a row from a CSV file) into a set._<p>Note that this will suppress duplicates, and as of 4.2, the elements in_the returned set will preserve the original order in a {@link LinkedHashSet}._@param str the input {@code String}_@return a set of {@code String} entries in the list_@see #removeDuplicateStrings(String[]);public static Set<String> commaDelimitedListToSet(@Nullable String str) {_		Set<String> set = new LinkedHashSet<>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,a,set,p,note,that,this,will,suppress,duplicates,and,as,of,4,2,the,elements,in,the,returned,set,will,preserve,the,original,order,in,a,link,linked,hash,set,param,str,the,input,code,string,return,a,set,of,code,string,entries,in,the,list,see,remove,duplicate,strings,string;public,static,set,string,comma,delimited,list,to,set,nullable,string,str,set,string,set,new,linked,hash,set,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(@Nullable String str);1519588127;Convert a comma delimited list (e.g., a row from a CSV file) into a set._<p>Note that this will suppress duplicates, and as of 4.2, the elements in_the returned set will preserve the original order in a {@link LinkedHashSet}._@param str the input {@code String}_@return a set of {@code String} entries in the list_@see #removeDuplicateStrings(String[]);public static Set<String> commaDelimitedListToSet(@Nullable String str) {_		Set<String> set = new LinkedHashSet<>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,a,set,p,note,that,this,will,suppress,duplicates,and,as,of,4,2,the,elements,in,the,returned,set,will,preserve,the,original,order,in,a,link,linked,hash,set,param,str,the,input,code,string,return,a,set,of,code,string,entries,in,the,list,see,remove,duplicate,strings,string;public,static,set,string,comma,delimited,list,to,set,nullable,string,str,set,string,set,new,linked,hash,set,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(@Nullable String str);1522332352;Convert a comma delimited list (e.g., a row from a CSV file) into a set._<p>Note that this will suppress duplicates, and as of 4.2, the elements in_the returned set will preserve the original order in a {@link LinkedHashSet}._@param str the input {@code String}_@return a set of {@code String} entries in the list_@see #removeDuplicateStrings(String[]);public static Set<String> commaDelimitedListToSet(@Nullable String str) {_		Set<String> set = new LinkedHashSet<>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,a,set,p,note,that,this,will,suppress,duplicates,and,as,of,4,2,the,elements,in,the,returned,set,will,preserve,the,original,order,in,a,link,linked,hash,set,param,str,the,input,code,string,return,a,set,of,code,string,entries,in,the,list,see,remove,duplicate,strings,string;public,static,set,string,comma,delimited,list,to,set,nullable,string,str,set,string,set,new,linked,hash,set,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(@Nullable String str);1525166194;Convert a comma delimited list (e.g., a row from a CSV file) into a set._<p>Note that this will suppress duplicates, and as of 4.2, the elements in_the returned set will preserve the original order in a {@link LinkedHashSet}._@param str the input {@code String}_@return a set of {@code String} entries in the list_@see #removeDuplicateStrings(String[]);public static Set<String> commaDelimitedListToSet(@Nullable String str) {_		Set<String> set = new LinkedHashSet<>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,a,set,p,note,that,this,will,suppress,duplicates,and,as,of,4,2,the,elements,in,the,returned,set,will,preserve,the,original,order,in,a,link,linked,hash,set,param,str,the,input,code,string,return,a,set,of,code,string,entries,in,the,list,see,remove,duplicate,strings,string;public,static,set,string,comma,delimited,list,to,set,nullable,string,str,set,string,set,new,linked,hash,set,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(@Nullable String str);1530188116;Convert a comma delimited list (e.g., a row from a CSV file) into a set._<p>Note that this will suppress duplicates, and as of 4.2, the elements in_the returned set will preserve the original order in a {@link LinkedHashSet}._@param str the input {@code String}_@return a set of {@code String} entries in the list_@see #removeDuplicateStrings(String[]);public static Set<String> commaDelimitedListToSet(@Nullable String str) {_		Set<String> set = new LinkedHashSet<>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,a,set,p,note,that,this,will,suppress,duplicates,and,as,of,4,2,the,elements,in,the,returned,set,will,preserve,the,original,order,in,a,link,linked,hash,set,param,str,the,input,code,string,return,a,set,of,code,string,entries,in,the,list,see,remove,duplicate,strings,string;public,static,set,string,comma,delimited,list,to,set,nullable,string,str,set,string,set,new,linked,hash,set,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(@Nullable String str);1531843079;Convert a comma delimited list (e.g., a row from a CSV file) into a set._<p>Note that this will suppress duplicates, and as of 4.2, the elements in_the returned set will preserve the original order in a {@link LinkedHashSet}._@param str the input {@code String}_@return a set of {@code String} entries in the list_@see #removeDuplicateStrings(String[]);public static Set<String> commaDelimitedListToSet(@Nullable String str) {_		Set<String> set = new LinkedHashSet<>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,a,set,p,note,that,this,will,suppress,duplicates,and,as,of,4,2,the,elements,in,the,returned,set,will,preserve,the,original,order,in,a,link,linked,hash,set,param,str,the,input,code,string,return,a,set,of,code,string,entries,in,the,list,see,remove,duplicate,strings,string;public,static,set,string,comma,delimited,list,to,set,nullable,string,str,set,string,set,new,linked,hash,set,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(@Nullable String str);1531905026;Convert a comma delimited list (e.g., a row from a CSV file) into a set._<p>Note that this will suppress duplicates, and as of 4.2, the elements in_the returned set will preserve the original order in a {@link LinkedHashSet}._@param str the input {@code String}_@return a set of {@code String} entries in the list_@see #removeDuplicateStrings(String[]);public static Set<String> commaDelimitedListToSet(@Nullable String str) {_		Set<String> set = new LinkedHashSet<>()__		String[] tokens = commaDelimitedListToStringArray(str)__		for (String token : tokens) {_			set.add(token)__		}_		return set__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,a,set,p,note,that,this,will,suppress,duplicates,and,as,of,4,2,the,elements,in,the,returned,set,will,preserve,the,original,order,in,a,link,linked,hash,set,param,str,the,input,code,string,return,a,set,of,code,string,entries,in,the,list,see,remove,duplicate,strings,string;public,static,set,string,comma,delimited,list,to,set,nullable,string,str,set,string,set,new,linked,hash,set,string,tokens,comma,delimited,list,to,string,array,str,for,string,token,tokens,set,add,token,return,set
StringUtils -> public static Set<String> commaDelimitedListToSet(@Nullable String str);1533557519;Convert a comma delimited list (e.g., a row from a CSV file) into a set._<p>Note that this will suppress duplicates, and as of 4.2, the elements in_the returned set will preserve the original order in a {@link LinkedHashSet}._@param str the input {@code String} (potentially {@code null} or empty)_@return a set of {@code String} entries in the list_@see #removeDuplicateStrings(String[]);public static Set<String> commaDelimitedListToSet(@Nullable String str) {_		String[] tokens = commaDelimitedListToStringArray(str)__		return new LinkedHashSet<>(Arrays.asList(tokens))__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,a,set,p,note,that,this,will,suppress,duplicates,and,as,of,4,2,the,elements,in,the,returned,set,will,preserve,the,original,order,in,a,link,linked,hash,set,param,str,the,input,code,string,potentially,code,null,or,empty,return,a,set,of,code,string,entries,in,the,list,see,remove,duplicate,strings,string;public,static,set,string,comma,delimited,list,to,set,nullable,string,str,string,tokens,comma,delimited,list,to,string,array,str,return,new,linked,hash,set,arrays,as,list,tokens
StringUtils -> public static Set<String> commaDelimitedListToSet(@Nullable String str);1533602820;Convert a comma delimited list (e.g., a row from a CSV file) into a set._<p>Note that this will suppress duplicates, and as of 4.2, the elements in_the returned set will preserve the original order in a {@link LinkedHashSet}._@param str the input {@code String} (potentially {@code null} or empty)_@return a set of {@code String} entries in the list_@see #removeDuplicateStrings(String[]);public static Set<String> commaDelimitedListToSet(@Nullable String str) {_		String[] tokens = commaDelimitedListToStringArray(str)__		return new LinkedHashSet<>(Arrays.asList(tokens))__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,a,set,p,note,that,this,will,suppress,duplicates,and,as,of,4,2,the,elements,in,the,returned,set,will,preserve,the,original,order,in,a,link,linked,hash,set,param,str,the,input,code,string,potentially,code,null,or,empty,return,a,set,of,code,string,entries,in,the,list,see,remove,duplicate,strings,string;public,static,set,string,comma,delimited,list,to,set,nullable,string,str,string,tokens,comma,delimited,list,to,string,array,str,return,new,linked,hash,set,arrays,as,list,tokens
StringUtils -> public static Set<String> commaDelimitedListToSet(@Nullable String str);1535316501;Convert a comma delimited list (e.g., a row from a CSV file) into a set._<p>Note that this will suppress duplicates, and as of 4.2, the elements in_the returned set will preserve the original order in a {@link LinkedHashSet}._@param str the input {@code String} (potentially {@code null} or empty)_@return a set of {@code String} entries in the list_@see #removeDuplicateStrings(String[]);public static Set<String> commaDelimitedListToSet(@Nullable String str) {_		String[] tokens = commaDelimitedListToStringArray(str)__		return new LinkedHashSet<>(Arrays.asList(tokens))__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,a,set,p,note,that,this,will,suppress,duplicates,and,as,of,4,2,the,elements,in,the,returned,set,will,preserve,the,original,order,in,a,link,linked,hash,set,param,str,the,input,code,string,potentially,code,null,or,empty,return,a,set,of,code,string,entries,in,the,list,see,remove,duplicate,strings,string;public,static,set,string,comma,delimited,list,to,set,nullable,string,str,string,tokens,comma,delimited,list,to,string,array,str,return,new,linked,hash,set,arrays,as,list,tokens
StringUtils -> public static Set<String> commaDelimitedListToSet(@Nullable String str);1550237113;Convert a comma delimited list (e.g., a row from a CSV file) into a set._<p>Note that this will suppress duplicates, and as of 4.2, the elements in_the returned set will preserve the original order in a {@link LinkedHashSet}._@param str the input {@code String} (potentially {@code null} or empty)_@return a set of {@code String} entries in the list_@see #removeDuplicateStrings(String[]);public static Set<String> commaDelimitedListToSet(@Nullable String str) {_		String[] tokens = commaDelimitedListToStringArray(str)__		return new LinkedHashSet<>(Arrays.asList(tokens))__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,a,set,p,note,that,this,will,suppress,duplicates,and,as,of,4,2,the,elements,in,the,returned,set,will,preserve,the,original,order,in,a,link,linked,hash,set,param,str,the,input,code,string,potentially,code,null,or,empty,return,a,set,of,code,string,entries,in,the,list,see,remove,duplicate,strings,string;public,static,set,string,comma,delimited,list,to,set,nullable,string,str,string,tokens,comma,delimited,list,to,string,array,str,return,new,linked,hash,set,arrays,as,list,tokens
StringUtils -> public static Set<String> commaDelimitedListToSet(@Nullable String str);1550238935;Convert a comma delimited list (e.g., a row from a CSV file) into a set._<p>Note that this will suppress duplicates, and as of 4.2, the elements in_the returned set will preserve the original order in a {@link LinkedHashSet}._@param str the input {@code String} (potentially {@code null} or empty)_@return a set of {@code String} entries in the list_@see #removeDuplicateStrings(String[]);public static Set<String> commaDelimitedListToSet(@Nullable String str) {_		String[] tokens = commaDelimitedListToStringArray(str)__		return new LinkedHashSet<>(Arrays.asList(tokens))__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,a,set,p,note,that,this,will,suppress,duplicates,and,as,of,4,2,the,elements,in,the,returned,set,will,preserve,the,original,order,in,a,link,linked,hash,set,param,str,the,input,code,string,potentially,code,null,or,empty,return,a,set,of,code,string,entries,in,the,list,see,remove,duplicate,strings,string;public,static,set,string,comma,delimited,list,to,set,nullable,string,str,string,tokens,comma,delimited,list,to,string,array,str,return,new,linked,hash,set,arrays,as,list,tokens
StringUtils -> public static String collectionToCommaDelimitedString(@Nullable Collection<?> coll);1533557519;Convert a {@code Collection} into a delimited {@code String} (e.g., CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert (potentially {@code null} or empty)_@return the delimited {@code String};public static String collectionToCommaDelimitedString(@Nullable Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,potentially,code,null,or,empty,return,the,delimited,code,string;public,static,string,collection,to,comma,delimited,string,nullable,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(@Nullable Collection<?> coll);1533602820;Convert a {@code Collection} into a delimited {@code String} (e.g., CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert (potentially {@code null} or empty)_@return the delimited {@code String};public static String collectionToCommaDelimitedString(@Nullable Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,potentially,code,null,or,empty,return,the,delimited,code,string;public,static,string,collection,to,comma,delimited,string,nullable,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(@Nullable Collection<?> coll);1535316501;Convert a {@code Collection} into a delimited {@code String} (e.g., CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert (potentially {@code null} or empty)_@return the delimited {@code String};public static String collectionToCommaDelimitedString(@Nullable Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,potentially,code,null,or,empty,return,the,delimited,code,string;public,static,string,collection,to,comma,delimited,string,nullable,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(@Nullable Collection<?> coll);1550237113;Convert a {@code Collection} into a delimited {@code String} (e.g., CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert (potentially {@code null} or empty)_@return the delimited {@code String};public static String collectionToCommaDelimitedString(@Nullable Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,potentially,code,null,or,empty,return,the,delimited,code,string;public,static,string,collection,to,comma,delimited,string,nullable,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(@Nullable Collection<?> coll);1550238935;Convert a {@code Collection} into a delimited {@code String} (e.g., CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert (potentially {@code null} or empty)_@return the delimited {@code String};public static String collectionToCommaDelimitedString(@Nullable Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,potentially,code,null,or,empty,return,the,delimited,code,string;public,static,string,collection,to,comma,delimited,string,nullable,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String arrayToCommaDelimitedString(@Nullable Object[] arr);1496837955;Convert a {@code String} array into a comma delimited {@code String}_(i.e., CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@return the delimited {@code String};public static String arrayToCommaDelimitedString(@Nullable Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convert,a,code,string,array,into,a,comma,delimited,code,string,i,e,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,code,string;public,static,string,array,to,comma,delimited,string,nullable,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(@Nullable Object[] arr);1499270197;Convert a {@code String} array into a comma delimited {@code String}_(i.e., CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@return the delimited {@code String};public static String arrayToCommaDelimitedString(@Nullable Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convert,a,code,string,array,into,a,comma,delimited,code,string,i,e,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,code,string;public,static,string,array,to,comma,delimited,string,nullable,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(@Nullable Object[] arr);1508667152;Convert a {@code String} array into a comma delimited {@code String}_(i.e., CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@return the delimited {@code String};public static String arrayToCommaDelimitedString(@Nullable Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convert,a,code,string,array,into,a,comma,delimited,code,string,i,e,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,code,string;public,static,string,array,to,comma,delimited,string,nullable,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(@Nullable Object[] arr);1508675477;Convert a {@code String} array into a comma delimited {@code String}_(i.e., CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@return the delimited {@code String};public static String arrayToCommaDelimitedString(@Nullable Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convert,a,code,string,array,into,a,comma,delimited,code,string,i,e,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,code,string;public,static,string,array,to,comma,delimited,string,nullable,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(@Nullable Object[] arr);1508843807;Convert a {@code String} array into a comma delimited {@code String}_(i.e., CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@return the delimited {@code String};public static String arrayToCommaDelimitedString(@Nullable Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convert,a,code,string,array,into,a,comma,delimited,code,string,i,e,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,code,string;public,static,string,array,to,comma,delimited,string,nullable,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(@Nullable Object[] arr);1516903831;Convert a {@code String} array into a comma delimited {@code String}_(i.e., CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@return the delimited {@code String};public static String arrayToCommaDelimitedString(@Nullable Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convert,a,code,string,array,into,a,comma,delimited,code,string,i,e,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,code,string;public,static,string,array,to,comma,delimited,string,nullable,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(@Nullable Object[] arr);1519295386;Convert a {@code String} array into a comma delimited {@code String}_(i.e., CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@return the delimited {@code String};public static String arrayToCommaDelimitedString(@Nullable Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convert,a,code,string,array,into,a,comma,delimited,code,string,i,e,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,code,string;public,static,string,array,to,comma,delimited,string,nullable,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(@Nullable Object[] arr);1519308837;Convert a {@code String} array into a comma delimited {@code String}_(i.e., CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@return the delimited {@code String};public static String arrayToCommaDelimitedString(@Nullable Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convert,a,code,string,array,into,a,comma,delimited,code,string,i,e,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,code,string;public,static,string,array,to,comma,delimited,string,nullable,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(@Nullable Object[] arr);1519588127;Convert a {@code String} array into a comma delimited {@code String}_(i.e., CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@return the delimited {@code String};public static String arrayToCommaDelimitedString(@Nullable Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convert,a,code,string,array,into,a,comma,delimited,code,string,i,e,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,code,string;public,static,string,array,to,comma,delimited,string,nullable,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(@Nullable Object[] arr);1522332352;Convert a {@code String} array into a comma delimited {@code String}_(i.e., CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@return the delimited {@code String};public static String arrayToCommaDelimitedString(@Nullable Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convert,a,code,string,array,into,a,comma,delimited,code,string,i,e,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,code,string;public,static,string,array,to,comma,delimited,string,nullable,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(@Nullable Object[] arr);1525166194;Convert a {@code String} array into a comma delimited {@code String}_(i.e., CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@return the delimited {@code String};public static String arrayToCommaDelimitedString(@Nullable Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convert,a,code,string,array,into,a,comma,delimited,code,string,i,e,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,code,string;public,static,string,array,to,comma,delimited,string,nullable,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(@Nullable Object[] arr);1530188116;Convert a {@code String} array into a comma delimited {@code String}_(i.e., CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@return the delimited {@code String};public static String arrayToCommaDelimitedString(@Nullable Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convert,a,code,string,array,into,a,comma,delimited,code,string,i,e,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,code,string;public,static,string,array,to,comma,delimited,string,nullable,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(@Nullable Object[] arr);1531843079;Convert a {@code String} array into a comma delimited {@code String}_(i.e., CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@return the delimited {@code String};public static String arrayToCommaDelimitedString(@Nullable Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convert,a,code,string,array,into,a,comma,delimited,code,string,i,e,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,code,string;public,static,string,array,to,comma,delimited,string,nullable,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(@Nullable Object[] arr);1531905026;Convert a {@code String} array into a comma delimited {@code String}_(i.e., CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@return the delimited {@code String};public static String arrayToCommaDelimitedString(@Nullable Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convert,a,code,string,array,into,a,comma,delimited,code,string,i,e,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,code,string;public,static,string,array,to,comma,delimited,string,nullable,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(@Nullable Object[] arr);1533557519;Convert a {@code String} array into a comma delimited {@code String}_(i.e., CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display (potentially {@code null} or empty)_@return the delimited {@code String};public static String arrayToCommaDelimitedString(@Nullable Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convert,a,code,string,array,into,a,comma,delimited,code,string,i,e,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,potentially,code,null,or,empty,return,the,delimited,code,string;public,static,string,array,to,comma,delimited,string,nullable,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(@Nullable Object[] arr);1533602820;Convert a {@code String} array into a comma delimited {@code String}_(i.e., CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display (potentially {@code null} or empty)_@return the delimited {@code String};public static String arrayToCommaDelimitedString(@Nullable Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convert,a,code,string,array,into,a,comma,delimited,code,string,i,e,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,potentially,code,null,or,empty,return,the,delimited,code,string;public,static,string,array,to,comma,delimited,string,nullable,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(@Nullable Object[] arr);1535316501;Convert a {@code String} array into a comma delimited {@code String}_(i.e., CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display (potentially {@code null} or empty)_@return the delimited {@code String};public static String arrayToCommaDelimitedString(@Nullable Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convert,a,code,string,array,into,a,comma,delimited,code,string,i,e,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,potentially,code,null,or,empty,return,the,delimited,code,string;public,static,string,array,to,comma,delimited,string,nullable,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(@Nullable Object[] arr);1550237113;Convert a {@code String} array into a comma delimited {@code String}_(i.e., CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display (potentially {@code null} or empty)_@return the delimited {@code String};public static String arrayToCommaDelimitedString(@Nullable Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convert,a,code,string,array,into,a,comma,delimited,code,string,i,e,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,potentially,code,null,or,empty,return,the,delimited,code,string;public,static,string,array,to,comma,delimited,string,nullable,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(@Nullable Object[] arr);1550238935;Convert a {@code String} array into a comma delimited {@code String}_(i.e., CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display (potentially {@code null} or empty)_@return the delimited {@code String};public static String arrayToCommaDelimitedString(@Nullable Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convert,a,code,string,array,into,a,comma,delimited,code,string,i,e,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,potentially,code,null,or,empty,return,the,delimited,code,string;public,static,string,array,to,comma,delimited,string,nullable,object,arr,return,array,to,delimited,string,arr
StringUtils -> @Nullable 	public static String[] split(@Nullable String toSplit, @Nullable String delimiter);1496837955;Split a {@code String} at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input {@code String};@Nullable_	public static String[] split(@Nullable String toSplit, @Nullable String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}__		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,code,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,code,string;nullable,public,static,string,split,nullable,string,to,split,nullable,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> @Nullable 	public static String[] split(@Nullable String toSplit, @Nullable String delimiter);1499270197;Split a {@code String} at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input {@code String};@Nullable_	public static String[] split(@Nullable String toSplit, @Nullable String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}__		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,code,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,code,string;nullable,public,static,string,split,nullable,string,to,split,nullable,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> @Nullable 	public static String[] split(@Nullable String toSplit, @Nullable String delimiter);1508667152;Split a {@code String} at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input {@code String};@Nullable_	public static String[] split(@Nullable String toSplit, @Nullable String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}__		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,code,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,code,string;nullable,public,static,string,split,nullable,string,to,split,nullable,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> @Nullable 	public static String[] split(@Nullable String toSplit, @Nullable String delimiter);1508675477;Split a {@code String} at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input {@code String};@Nullable_	public static String[] split(@Nullable String toSplit, @Nullable String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}__		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,code,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,code,string;nullable,public,static,string,split,nullable,string,to,split,nullable,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> @Nullable 	public static String[] split(@Nullable String toSplit, @Nullable String delimiter);1508843807;Split a {@code String} at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input {@code String};@Nullable_	public static String[] split(@Nullable String toSplit, @Nullable String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}__		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,code,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,code,string;nullable,public,static,string,split,nullable,string,to,split,nullable,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> @Nullable 	public static String[] split(@Nullable String toSplit, @Nullable String delimiter);1516903831;Split a {@code String} at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input {@code String};@Nullable_	public static String[] split(@Nullable String toSplit, @Nullable String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}__		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,code,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,code,string;nullable,public,static,string,split,nullable,string,to,split,nullable,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> @Nullable 	public static String[] split(@Nullable String toSplit, @Nullable String delimiter);1519295386;Split a {@code String} at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input {@code String};@Nullable_	public static String[] split(@Nullable String toSplit, @Nullable String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}__		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,code,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,code,string;nullable,public,static,string,split,nullable,string,to,split,nullable,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> @Nullable 	public static String[] split(@Nullable String toSplit, @Nullable String delimiter);1519308837;Split a {@code String} at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input {@code String};@Nullable_	public static String[] split(@Nullable String toSplit, @Nullable String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}__		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,code,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,code,string;nullable,public,static,string,split,nullable,string,to,split,nullable,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> @Nullable 	public static String[] split(@Nullable String toSplit, @Nullable String delimiter);1519588127;Split a {@code String} at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input {@code String};@Nullable_	public static String[] split(@Nullable String toSplit, @Nullable String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}__		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,code,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,code,string;nullable,public,static,string,split,nullable,string,to,split,nullable,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> @Nullable 	public static String[] split(@Nullable String toSplit, @Nullable String delimiter);1522332352;Split a {@code String} at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input {@code String};@Nullable_	public static String[] split(@Nullable String toSplit, @Nullable String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}__		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,code,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,code,string;nullable,public,static,string,split,nullable,string,to,split,nullable,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> @Nullable 	public static String[] split(@Nullable String toSplit, @Nullable String delimiter);1525166194;Split a {@code String} at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input {@code String};@Nullable_	public static String[] split(@Nullable String toSplit, @Nullable String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}__		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,code,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,code,string;nullable,public,static,string,split,nullable,string,to,split,nullable,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> @Nullable 	public static String[] split(@Nullable String toSplit, @Nullable String delimiter);1530188116;Split a {@code String} at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input {@code String};@Nullable_	public static String[] split(@Nullable String toSplit, @Nullable String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}__		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,code,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,code,string;nullable,public,static,string,split,nullable,string,to,split,nullable,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> @Nullable 	public static String[] split(@Nullable String toSplit, @Nullable String delimiter);1531843079;Split a {@code String} at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input {@code String};@Nullable_	public static String[] split(@Nullable String toSplit, @Nullable String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}__		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,code,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,code,string;nullable,public,static,string,split,nullable,string,to,split,nullable,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> @Nullable 	public static String[] split(@Nullable String toSplit, @Nullable String delimiter);1531905026;Split a {@code String} at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input {@code String};@Nullable_	public static String[] split(@Nullable String toSplit, @Nullable String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}__		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,code,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,code,string;nullable,public,static,string,split,nullable,string,to,split,nullable,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> @Nullable 	public static String[] split(@Nullable String toSplit, @Nullable String delimiter);1533557519;Split a {@code String} at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split (potentially {@code null} or empty)_@param delimiter to split the string up with (potentially {@code null} or empty)_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input {@code String};@Nullable_	public static String[] split(@Nullable String toSplit, @Nullable String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}__		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,code,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,potentially,code,null,or,empty,param,delimiter,to,split,the,string,up,with,potentially,code,null,or,empty,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,code,string;nullable,public,static,string,split,nullable,string,to,split,nullable,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> @Nullable 	public static String[] split(@Nullable String toSplit, @Nullable String delimiter);1533602820;Split a {@code String} at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split (potentially {@code null} or empty)_@param delimiter to split the string up with (potentially {@code null} or empty)_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input {@code String};@Nullable_	public static String[] split(@Nullable String toSplit, @Nullable String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}__		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,code,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,potentially,code,null,or,empty,param,delimiter,to,split,the,string,up,with,potentially,code,null,or,empty,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,code,string;nullable,public,static,string,split,nullable,string,to,split,nullable,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> @Nullable 	public static String[] split(@Nullable String toSplit, @Nullable String delimiter);1535316501;Split a {@code String} at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split (potentially {@code null} or empty)_@param delimiter to split the string up with (potentially {@code null} or empty)_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input {@code String};@Nullable_	public static String[] split(@Nullable String toSplit, @Nullable String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}__		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,code,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,potentially,code,null,or,empty,param,delimiter,to,split,the,string,up,with,potentially,code,null,or,empty,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,code,string;nullable,public,static,string,split,nullable,string,to,split,nullable,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> @Nullable 	public static String[] split(@Nullable String toSplit, @Nullable String delimiter);1550237113;Split a {@code String} at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split (potentially {@code null} or empty)_@param delimiter to split the string up with (potentially {@code null} or empty)_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input {@code String};@Nullable_	public static String[] split(@Nullable String toSplit, @Nullable String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}__		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,code,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,potentially,code,null,or,empty,param,delimiter,to,split,the,string,up,with,potentially,code,null,or,empty,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,code,string;nullable,public,static,string,split,nullable,string,to,split,nullable,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> @Nullable 	public static String[] split(@Nullable String toSplit, @Nullable String delimiter);1550238935;Split a {@code String} at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split (potentially {@code null} or empty)_@param delimiter to split the string up with (potentially {@code null} or empty)_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input {@code String};@Nullable_	public static String[] split(@Nullable String toSplit, @Nullable String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}__		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,code,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,potentially,code,null,or,empty,param,delimiter,to,split,the,string,up,with,potentially,code,null,or,empty,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,code,string;nullable,public,static,string,split,nullable,string,to,split,nullable,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> public static int countOccurrencesOf(String str, String sub);1328020251;Count the occurrences of the substring in string s._@param str string to search in. Return 0 if this is null._@param sub string to search for. Return 0 if this is null.;public static int countOccurrencesOf(String str, String sub) {_		if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {_			return 0__		}_		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,in,string,s,param,str,string,to,search,in,return,0,if,this,is,null,param,sub,string,to,search,for,return,0,if,this,is,null;public,static,int,count,occurrences,of,string,str,string,sub,if,str,null,sub,null,str,length,0,sub,length,0,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1337236962;Count the occurrences of the substring in string s._@param str string to search in. Return 0 if this is null._@param sub string to search for. Return 0 if this is null.;public static int countOccurrencesOf(String str, String sub) {_		if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {_			return 0__		}_		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,in,string,s,param,str,string,to,search,in,return,0,if,this,is,null,param,sub,string,to,search,for,return,0,if,this,is,null;public,static,int,count,occurrences,of,string,str,string,sub,if,str,null,sub,null,str,length,0,sub,length,0,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1356735495;Count the occurrences of the substring in string s._@param str string to search in. Return 0 if this is null._@param sub string to search for. Return 0 if this is null.;public static int countOccurrencesOf(String str, String sub) {_		if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {_			return 0__		}_		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,in,string,s,param,str,string,to,search,in,return,0,if,this,is,null,param,sub,string,to,search,for,return,0,if,this,is,null;public,static,int,count,occurrences,of,string,str,string,sub,if,str,null,sub,null,str,length,0,sub,length,0,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1367955086;Count the occurrences of the substring in string s._@param str string to search in. Return 0 if this is null._@param sub string to search for. Return 0 if this is null.;public static int countOccurrencesOf(String str, String sub) {_		if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {_			return 0__		}_		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,in,string,s,param,str,string,to,search,in,return,0,if,this,is,null,param,sub,string,to,search,for,return,0,if,this,is,null;public,static,int,count,occurrences,of,string,str,string,sub,if,str,null,sub,null,str,length,0,sub,length,0,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1380921248;Count the occurrences of the substring in string s._@param str string to search in. Return 0 if this is null._@param sub string to search for. Return 0 if this is null.;public static int countOccurrencesOf(String str, String sub) {_		if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {_			return 0__		}_		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,in,string,s,param,str,string,to,search,in,return,0,if,this,is,null,param,sub,string,to,search,for,return,0,if,this,is,null;public,static,int,count,occurrences,of,string,str,string,sub,if,str,null,sub,null,str,length,0,sub,length,0,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1382750743;Count the occurrences of the substring in string s._@param str string to search in. Return 0 if this is null._@param sub string to search for. Return 0 if this is null.;public static int countOccurrencesOf(String str, String sub) {_		if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {_			return 0__		}_		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,in,string,s,param,str,string,to,search,in,return,0,if,this,is,null,param,sub,string,to,search,for,return,0,if,this,is,null;public,static,int,count,occurrences,of,string,str,string,sub,if,str,null,sub,null,str,length,0,sub,length,0,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1385423968;Count the occurrences of the substring in string s._@param str string to search in. Return 0 if this is null._@param sub string to search for. Return 0 if this is null.;public static int countOccurrencesOf(String str, String sub) {_		if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {_			return 0__		}_		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,in,string,s,param,str,string,to,search,in,return,0,if,this,is,null,param,sub,string,to,search,for,return,0,if,this,is,null;public,static,int,count,occurrences,of,string,str,string,sub,if,str,null,sub,null,str,length,0,sub,length,0,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1400189212;Count the occurrences of the substring in string s._@param str string to search in. Return 0 if this is null._@param sub string to search for. Return 0 if this is null.;public static int countOccurrencesOf(String str, String sub) {_		if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {_			return 0__		}_		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,in,string,s,param,str,string,to,search,in,return,0,if,this,is,null,param,sub,string,to,search,for,return,0,if,this,is,null;public,static,int,count,occurrences,of,string,str,string,sub,if,str,null,sub,null,str,length,0,sub,length,0,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1400531359;Count the occurrences of the substring in string s._@param str string to search in. Return 0 if this is null._@param sub string to search for. Return 0 if this is null.;public static int countOccurrencesOf(String str, String sub) {_		if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {_			return 0__		}_		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,in,string,s,param,str,string,to,search,in,return,0,if,this,is,null,param,sub,string,to,search,for,return,0,if,this,is,null;public,static,int,count,occurrences,of,string,str,string,sub,if,str,null,sub,null,str,length,0,sub,length,0,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1402676350;Count the occurrences of the substring in string s._@param str string to search in. Return 0 if this is null._@param sub string to search for. Return 0 if this is null.;public static int countOccurrencesOf(String str, String sub) {_		if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {_			return 0__		}_		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,in,string,s,param,str,string,to,search,in,return,0,if,this,is,null,param,sub,string,to,search,for,return,0,if,this,is,null;public,static,int,count,occurrences,of,string,str,string,sub,if,str,null,sub,null,str,length,0,sub,length,0,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1426267150;Count the occurrences of the substring in string s._@param str string to search in. Return 0 if this is null._@param sub string to search for. Return 0 if this is null.;public static int countOccurrencesOf(String str, String sub) {_		if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {_			return 0__		}_		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,in,string,s,param,str,string,to,search,in,return,0,if,this,is,null,param,sub,string,to,search,for,return,0,if,this,is,null;public,static,int,count,occurrences,of,string,str,string,sub,if,str,null,sub,null,str,length,0,sub,length,0,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1429034538;Count the occurrences of the substring in string s._@param str string to search in. Return 0 if this is null._@param sub string to search for. Return 0 if this is null.;public static int countOccurrencesOf(String str, String sub) {_		if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {_			return 0__		}_		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,in,string,s,param,str,string,to,search,in,return,0,if,this,is,null,param,sub,string,to,search,for,return,0,if,this,is,null;public,static,int,count,occurrences,of,string,str,string,sub,if,str,null,sub,null,str,length,0,sub,length,0,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1429034756;Count the occurrences of the substring {@code sub} in string {@code str}._@param str string to search in. Return 0 if this is {@code null}._@param sub string to search for. Return 0 if this is {@code null}.;public static int countOccurrencesOf(String str, String sub) {_		if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {_			return 0__		}_		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,code,sub,in,string,code,str,param,str,string,to,search,in,return,0,if,this,is,code,null,param,sub,string,to,search,for,return,0,if,this,is,code,null;public,static,int,count,occurrences,of,string,str,string,sub,if,str,null,sub,null,str,length,0,sub,length,0,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1431006895;Count the occurrences of the substring {@code sub} in string {@code str}._@param str string to search in. Return 0 if this is {@code null}._@param sub string to search for. Return 0 if this is {@code null}.;public static int countOccurrencesOf(String str, String sub) {_		if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {_			return 0__		}_		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,code,sub,in,string,code,str,param,str,string,to,search,in,return,0,if,this,is,code,null,param,sub,string,to,search,for,return,0,if,this,is,code,null;public,static,int,count,occurrences,of,string,str,string,sub,if,str,null,sub,null,str,length,0,sub,length,0,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1431007368;Count the occurrences of the substring {@code sub} in string {@code str}._@param str string to search in. Return 0 if this is {@code null}._@param sub string to search for. Return 0 if this is {@code null}.;public static int countOccurrencesOf(String str, String sub) {_		if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {_			return 0__		}_		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,code,sub,in,string,code,str,param,str,string,to,search,in,return,0,if,this,is,code,null,param,sub,string,to,search,for,return,0,if,this,is,code,null;public,static,int,count,occurrences,of,string,str,string,sub,if,str,null,sub,null,str,length,0,sub,length,0,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1449489126;Count the occurrences of the substring {@code sub} in string {@code str}._@param str string to search in. Return 0 if this is {@code null}._@param sub string to search for. Return 0 if this is {@code null}.;public static int countOccurrencesOf(String str, String sub) {_		if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {_			return 0__		}_		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,code,sub,in,string,code,str,param,str,string,to,search,in,return,0,if,this,is,code,null,param,sub,string,to,search,for,return,0,if,this,is,code,null;public,static,int,count,occurrences,of,string,str,string,sub,if,str,null,sub,null,str,length,0,sub,length,0,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1467730834;Count the occurrences of the substring {@code sub} in string {@code str}._@param str string to search in. Return 0 if this is {@code null}._@param sub string to search for. Return 0 if this is {@code null}.;public static int countOccurrencesOf(String str, String sub) {_		if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {_			return 0__		}_		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,code,sub,in,string,code,str,param,str,string,to,search,in,return,0,if,this,is,code,null,param,sub,string,to,search,for,return,0,if,this,is,code,null;public,static,int,count,occurrences,of,string,str,string,sub,if,str,null,sub,null,str,length,0,sub,length,0,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1472128018;Count the occurrences of the substring {@code sub} in string {@code str}._@param str string to search in. Return 0 if this is {@code null}._@param sub string to search for. Return 0 if this is {@code null}.;public static int countOccurrencesOf(String str, String sub) {_		if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {_			return 0__		}_		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,code,sub,in,string,code,str,param,str,string,to,search,in,return,0,if,this,is,code,null,param,sub,string,to,search,for,return,0,if,this,is,code,null;public,static,int,count,occurrences,of,string,str,string,sub,if,str,null,sub,null,str,length,0,sub,length,0,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1472202842;Count the occurrences of the substring {@code sub} in string {@code str}._@param str string to search in. Return 0 if this is {@code null}._@param sub string to search for. Return 0 if this is {@code null}.;public static int countOccurrencesOf(String str, String sub) {_		if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {_			return 0__		}_		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,code,sub,in,string,code,str,param,str,string,to,search,in,return,0,if,this,is,code,null,param,sub,string,to,search,for,return,0,if,this,is,code,null;public,static,int,count,occurrences,of,string,str,string,sub,if,str,null,sub,null,str,length,0,sub,length,0,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1473942665;Count the occurrences of the substring {@code sub} in string {@code str}._@param str string to search in. Return 0 if this is {@code null}._@param sub string to search for. Return 0 if this is {@code null}.;public static int countOccurrencesOf(String str, String sub) {_		if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {_			return 0__		}_		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,code,sub,in,string,code,str,param,str,string,to,search,in,return,0,if,this,is,code,null,param,sub,string,to,search,for,return,0,if,this,is,code,null;public,static,int,count,occurrences,of,string,str,string,sub,if,str,null,sub,null,str,length,0,sub,length,0,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1484248946;Count the occurrences of the substring {@code sub} in string {@code str}._@param str string to search in. Return 0 if this is {@code null}._@param sub string to search for. Return 0 if this is {@code null}.;public static int countOccurrencesOf(String str, String sub) {_		if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {_			return 0__		}_		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,code,sub,in,string,code,str,param,str,string,to,search,in,return,0,if,this,is,code,null,param,sub,string,to,search,for,return,0,if,this,is,code,null;public,static,int,count,occurrences,of,string,str,string,sub,if,str,null,sub,null,str,length,0,sub,length,0,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1484260238;Count the occurrences of the substring {@code sub} in string {@code str}._@param str string to search in. Return 0 if this is {@code null}._@param sub string to search for. Return 0 if this is {@code null}.;public static int countOccurrencesOf(String str, String sub) {_		if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {_			return 0__		}_		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,code,sub,in,string,code,str,param,str,string,to,search,in,return,0,if,this,is,code,null,param,sub,string,to,search,for,return,0,if,this,is,code,null;public,static,int,count,occurrences,of,string,str,string,sub,if,str,null,sub,null,str,length,0,sub,length,0,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1484694546;Count the occurrences of the substring {@code sub} in string {@code str}._@param str string to search in. Return 0 if this is {@code null}._@param sub string to search for. Return 0 if this is {@code null}.;public static int countOccurrencesOf(String str, String sub) {_		if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {_			return 0__		}_		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,code,sub,in,string,code,str,param,str,string,to,search,in,return,0,if,this,is,code,null,param,sub,string,to,search,for,return,0,if,this,is,code,null;public,static,int,count,occurrences,of,string,str,string,sub,if,str,null,sub,null,str,length,0,sub,length,0,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1487760984;Count the occurrences of the substring {@code sub} in string {@code str}._@param str string to search in. Return 0 if this is {@code null}._@param sub string to search for. Return 0 if this is {@code null}.;public static int countOccurrencesOf(String str, String sub) {_		if (!hasLength(str) || !hasLength(sub)) {_			return 0__		}_		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,code,sub,in,string,code,str,param,str,string,to,search,in,return,0,if,this,is,code,null,param,sub,string,to,search,for,return,0,if,this,is,code,null;public,static,int,count,occurrences,of,string,str,string,sub,if,has,length,str,has,length,sub,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1487778834;Count the occurrences of the substring {@code sub} in string {@code str}._@param str string to search in. Return 0 if this is {@code null}._@param sub string to search for. Return 0 if this is {@code null}.;public static int countOccurrencesOf(String str, String sub) {_		if (!hasLength(str) || !hasLength(sub)) {_			return 0__		}_		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,code,sub,in,string,code,str,param,str,string,to,search,in,return,0,if,this,is,code,null,param,sub,string,to,search,for,return,0,if,this,is,code,null;public,static,int,count,occurrences,of,string,str,string,sub,if,has,length,str,has,length,sub,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1491898314;Count the occurrences of the substring {@code sub} in string {@code str}._@param str string to search in. Return 0 if this is {@code null}._@param sub string to search for. Return 0 if this is {@code null}.;public static int countOccurrencesOf(String str, String sub) {_		if (!hasLength(str) || !hasLength(sub)) {_			return 0__		}__		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,code,sub,in,string,code,str,param,str,string,to,search,in,return,0,if,this,is,code,null,param,sub,string,to,search,for,return,0,if,this,is,code,null;public,static,int,count,occurrences,of,string,str,string,sub,if,has,length,str,has,length,sub,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1491903650;Count the occurrences of the substring {@code sub} in string {@code str}._@param str string to search in. Return 0 if this is {@code null}._@param sub string to search for. Return 0 if this is {@code null}.;public static int countOccurrencesOf(String str, String sub) {_		if (!hasLength(str) || !hasLength(sub)) {_			return 0__		}__		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,code,sub,in,string,code,str,param,str,string,to,search,in,return,0,if,this,is,code,null,param,sub,string,to,search,for,return,0,if,this,is,code,null;public,static,int,count,occurrences,of,string,str,string,sub,if,has,length,str,has,length,sub,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1496837955;Count the occurrences of the substring {@code sub} in string {@code str}._@param str string to search in_@param sub string to search for;public static int countOccurrencesOf(String str, String sub) {_		if (!hasLength(str) || !hasLength(sub)) {_			return 0__		}__		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,code,sub,in,string,code,str,param,str,string,to,search,in,param,sub,string,to,search,for;public,static,int,count,occurrences,of,string,str,string,sub,if,has,length,str,has,length,sub,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1499270197;Count the occurrences of the substring {@code sub} in string {@code str}._@param str string to search in_@param sub string to search for;public static int countOccurrencesOf(String str, String sub) {_		if (!hasLength(str) || !hasLength(sub)) {_			return 0__		}__		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,code,sub,in,string,code,str,param,str,string,to,search,in,param,sub,string,to,search,for;public,static,int,count,occurrences,of,string,str,string,sub,if,has,length,str,has,length,sub,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1508667152;Count the occurrences of the substring {@code sub} in string {@code str}._@param str string to search in_@param sub string to search for;public static int countOccurrencesOf(String str, String sub) {_		if (!hasLength(str) || !hasLength(sub)) {_			return 0__		}__		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,code,sub,in,string,code,str,param,str,string,to,search,in,param,sub,string,to,search,for;public,static,int,count,occurrences,of,string,str,string,sub,if,has,length,str,has,length,sub,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1508675477;Count the occurrences of the substring {@code sub} in string {@code str}._@param str string to search in_@param sub string to search for;public static int countOccurrencesOf(String str, String sub) {_		if (!hasLength(str) || !hasLength(sub)) {_			return 0__		}__		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,code,sub,in,string,code,str,param,str,string,to,search,in,param,sub,string,to,search,for;public,static,int,count,occurrences,of,string,str,string,sub,if,has,length,str,has,length,sub,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1508843807;Count the occurrences of the substring {@code sub} in string {@code str}._@param str string to search in_@param sub string to search for;public static int countOccurrencesOf(String str, String sub) {_		if (!hasLength(str) || !hasLength(sub)) {_			return 0__		}__		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,code,sub,in,string,code,str,param,str,string,to,search,in,param,sub,string,to,search,for;public,static,int,count,occurrences,of,string,str,string,sub,if,has,length,str,has,length,sub,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1516903831;Count the occurrences of the substring {@code sub} in string {@code str}._@param str string to search in_@param sub string to search for;public static int countOccurrencesOf(String str, String sub) {_		if (!hasLength(str) || !hasLength(sub)) {_			return 0__		}__		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,code,sub,in,string,code,str,param,str,string,to,search,in,param,sub,string,to,search,for;public,static,int,count,occurrences,of,string,str,string,sub,if,has,length,str,has,length,sub,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1519295386;Count the occurrences of the substring {@code sub} in string {@code str}._@param str string to search in_@param sub string to search for;public static int countOccurrencesOf(String str, String sub) {_		if (!hasLength(str) || !hasLength(sub)) {_			return 0__		}__		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,code,sub,in,string,code,str,param,str,string,to,search,in,param,sub,string,to,search,for;public,static,int,count,occurrences,of,string,str,string,sub,if,has,length,str,has,length,sub,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1519308837;Count the occurrences of the substring {@code sub} in string {@code str}._@param str string to search in_@param sub string to search for;public static int countOccurrencesOf(String str, String sub) {_		if (!hasLength(str) || !hasLength(sub)) {_			return 0__		}__		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,code,sub,in,string,code,str,param,str,string,to,search,in,param,sub,string,to,search,for;public,static,int,count,occurrences,of,string,str,string,sub,if,has,length,str,has,length,sub,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1519588127;Count the occurrences of the substring {@code sub} in string {@code str}._@param str string to search in_@param sub string to search for;public static int countOccurrencesOf(String str, String sub) {_		if (!hasLength(str) || !hasLength(sub)) {_			return 0__		}__		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,code,sub,in,string,code,str,param,str,string,to,search,in,param,sub,string,to,search,for;public,static,int,count,occurrences,of,string,str,string,sub,if,has,length,str,has,length,sub,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1522332352;Count the occurrences of the substring {@code sub} in string {@code str}._@param str string to search in_@param sub string to search for;public static int countOccurrencesOf(String str, String sub) {_		if (!hasLength(str) || !hasLength(sub)) {_			return 0__		}__		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,code,sub,in,string,code,str,param,str,string,to,search,in,param,sub,string,to,search,for;public,static,int,count,occurrences,of,string,str,string,sub,if,has,length,str,has,length,sub,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1525166194;Count the occurrences of the substring {@code sub} in string {@code str}._@param str string to search in_@param sub string to search for;public static int countOccurrencesOf(String str, String sub) {_		if (!hasLength(str) || !hasLength(sub)) {_			return 0__		}__		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,code,sub,in,string,code,str,param,str,string,to,search,in,param,sub,string,to,search,for;public,static,int,count,occurrences,of,string,str,string,sub,if,has,length,str,has,length,sub,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1530188116;Count the occurrences of the substring {@code sub} in string {@code str}._@param str string to search in_@param sub string to search for;public static int countOccurrencesOf(String str, String sub) {_		if (!hasLength(str) || !hasLength(sub)) {_			return 0__		}__		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,code,sub,in,string,code,str,param,str,string,to,search,in,param,sub,string,to,search,for;public,static,int,count,occurrences,of,string,str,string,sub,if,has,length,str,has,length,sub,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1531843079;Count the occurrences of the substring {@code sub} in string {@code str}._@param str string to search in_@param sub string to search for;public static int countOccurrencesOf(String str, String sub) {_		if (!hasLength(str) || !hasLength(sub)) {_			return 0__		}__		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,code,sub,in,string,code,str,param,str,string,to,search,in,param,sub,string,to,search,for;public,static,int,count,occurrences,of,string,str,string,sub,if,has,length,str,has,length,sub,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1531905026;Count the occurrences of the substring {@code sub} in string {@code str}._@param str string to search in_@param sub string to search for;public static int countOccurrencesOf(String str, String sub) {_		if (!hasLength(str) || !hasLength(sub)) {_			return 0__		}__		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,code,sub,in,string,code,str,param,str,string,to,search,in,param,sub,string,to,search,for;public,static,int,count,occurrences,of,string,str,string,sub,if,has,length,str,has,length,sub,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1533557519;Count the occurrences of the substring {@code sub} in string {@code str}._@param str string to search in_@param sub string to search for;public static int countOccurrencesOf(String str, String sub) {_		if (!hasLength(str) || !hasLength(sub)) {_			return 0__		}__		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,code,sub,in,string,code,str,param,str,string,to,search,in,param,sub,string,to,search,for;public,static,int,count,occurrences,of,string,str,string,sub,if,has,length,str,has,length,sub,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1533602820;Count the occurrences of the substring {@code sub} in string {@code str}._@param str string to search in_@param sub string to search for;public static int countOccurrencesOf(String str, String sub) {_		if (!hasLength(str) || !hasLength(sub)) {_			return 0__		}__		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,code,sub,in,string,code,str,param,str,string,to,search,in,param,sub,string,to,search,for;public,static,int,count,occurrences,of,string,str,string,sub,if,has,length,str,has,length,sub,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1535316501;Count the occurrences of the substring {@code sub} in string {@code str}._@param str string to search in_@param sub string to search for;public static int countOccurrencesOf(String str, String sub) {_		if (!hasLength(str) || !hasLength(sub)) {_			return 0__		}__		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,code,sub,in,string,code,str,param,str,string,to,search,in,param,sub,string,to,search,for;public,static,int,count,occurrences,of,string,str,string,sub,if,has,length,str,has,length,sub,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1550237113;Count the occurrences of the substring {@code sub} in string {@code str}._@param str string to search in_@param sub string to search for;public static int countOccurrencesOf(String str, String sub) {_		if (!hasLength(str) || !hasLength(sub)) {_			return 0__		}__		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,code,sub,in,string,code,str,param,str,string,to,search,in,param,sub,string,to,search,for;public,static,int,count,occurrences,of,string,str,string,sub,if,has,length,str,has,length,sub,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(String str, String sub);1550238935;Count the occurrences of the substring {@code sub} in string {@code str}._@param str string to search in_@param sub string to search for;public static int countOccurrencesOf(String str, String sub) {_		if (!hasLength(str) || !hasLength(sub)) {_			return 0__		}__		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,code,sub,in,string,code,str,param,str,string,to,search,in,param,sub,string,to,search,for;public,static,int,count,occurrences,of,string,str,string,sub,if,has,length,str,has,length,sub,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> @Nullable 	public static String uriDecode(@Nullable String source, Charset charset);1495868221;Decode the given encoded URI component value. Based on the following rules:_<ul>_<li>Alphanumeric characters {@code "a"} through {@code "z"}, {@code "A"} through {@code "Z"},_and {@code "0"} through {@code "9"} stay the same.</li>_<li>Special characters {@code "-"}, {@code "_"}, {@code "."}, and {@code "*"} stay the same.</li>_<li>A sequence "{@code %<i>xy</i>}" is interpreted as a hexadecimal representation of the character.</li>_</ul>_@param source the encoded String (may be {@code null})_@param charset the character set_@return the decoded value_@throws IllegalArgumentException when the given source contains invalid encoded sequences_@since 5.0_@see java.net.URLDecoder#decode(String, String);@Nullable_	public static String uriDecode(@Nullable String source, Charset charset) {_		if (source == null) {_			return null__		}_		int length = source.length()__		if (length == 0) {_			return source__		}_		Assert.notNull(charset, "Charset must not be null")___		ByteArrayOutputStream bos = new ByteArrayOutputStream(length)__		boolean changed = false__		for (int i = 0_ i < length_ i++) {_			int ch = source.charAt(i)__			if (ch == '%') {_				if (i + 2 < length) {_					char hex1 = source.charAt(i + 1)__					char hex2 = source.charAt(i + 2)__					int u = Character.digit(hex1, 16)__					int l = Character.digit(hex2, 16)__					if (u == -1 || l == -1) {_						throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__					}_					bos.write((char) ((u << 4) + l))__					i += 2__					changed = true__				}_				else {_					throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__				}_			}_			else {_				bos.write(ch)__			}_		}_		return (changed ? new String(bos.toByteArray(), charset) : source)__	};decode,the,given,encoded,uri,component,value,based,on,the,following,rules,ul,li,alphanumeric,characters,code,a,through,code,z,code,a,through,code,z,and,code,0,through,code,9,stay,the,same,li,li,special,characters,code,code,code,and,code,stay,the,same,li,li,a,sequence,code,i,xy,i,is,interpreted,as,a,hexadecimal,representation,of,the,character,li,ul,param,source,the,encoded,string,may,be,code,null,param,charset,the,character,set,return,the,decoded,value,throws,illegal,argument,exception,when,the,given,source,contains,invalid,encoded,sequences,since,5,0,see,java,net,urldecoder,decode,string,string;nullable,public,static,string,uri,decode,nullable,string,source,charset,charset,if,source,null,return,null,int,length,source,length,if,length,0,return,source,assert,not,null,charset,charset,must,not,be,null,byte,array,output,stream,bos,new,byte,array,output,stream,length,boolean,changed,false,for,int,i,0,i,length,i,int,ch,source,char,at,i,if,ch,if,i,2,length,char,hex1,source,char,at,i,1,char,hex2,source,char,at,i,2,int,u,character,digit,hex1,16,int,l,character,digit,hex2,16,if,u,1,l,1,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,bos,write,char,u,4,l,i,2,changed,true,else,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,else,bos,write,ch,return,changed,new,string,bos,to,byte,array,charset,source
StringUtils -> @Nullable 	public static String uriDecode(@Nullable String source, Charset charset);1496243689;Decode the given encoded URI component value. Based on the following rules:_<ul>_<li>Alphanumeric characters {@code "a"} through {@code "z"}, {@code "A"} through {@code "Z"},_and {@code "0"} through {@code "9"} stay the same.</li>_<li>Special characters {@code "-"}, {@code "_"}, {@code "."}, and {@code "*"} stay the same.</li>_<li>A sequence "{@code %<i>xy</i>}" is interpreted as a hexadecimal representation of the character.</li>_</ul>_@param source the encoded String (may be {@code null})_@param charset the character set_@return the decoded value_@throws IllegalArgumentException when the given source contains invalid encoded sequences_@since 5.0_@see java.net.URLDecoder#decode(String, String);@Nullable_	public static String uriDecode(@Nullable String source, Charset charset) {_		if (source == null) {_			return null__		}_		int length = source.length()__		if (length == 0) {_			return source__		}_		Assert.notNull(charset, "Charset must not be null")___		ByteArrayOutputStream bos = new ByteArrayOutputStream(length)__		boolean changed = false__		for (int i = 0_ i < length_ i++) {_			int ch = source.charAt(i)__			if (ch == '%') {_				if (i + 2 < length) {_					char hex1 = source.charAt(i + 1)__					char hex2 = source.charAt(i + 2)__					int u = Character.digit(hex1, 16)__					int l = Character.digit(hex2, 16)__					if (u == -1 || l == -1) {_						throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__					}_					bos.write((char) ((u << 4) + l))__					i += 2__					changed = true__				}_				else {_					throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__				}_			}_			else {_				bos.write(ch)__			}_		}_		return (changed ? new String(bos.toByteArray(), charset) : source)__	};decode,the,given,encoded,uri,component,value,based,on,the,following,rules,ul,li,alphanumeric,characters,code,a,through,code,z,code,a,through,code,z,and,code,0,through,code,9,stay,the,same,li,li,special,characters,code,code,code,and,code,stay,the,same,li,li,a,sequence,code,i,xy,i,is,interpreted,as,a,hexadecimal,representation,of,the,character,li,ul,param,source,the,encoded,string,may,be,code,null,param,charset,the,character,set,return,the,decoded,value,throws,illegal,argument,exception,when,the,given,source,contains,invalid,encoded,sequences,since,5,0,see,java,net,urldecoder,decode,string,string;nullable,public,static,string,uri,decode,nullable,string,source,charset,charset,if,source,null,return,null,int,length,source,length,if,length,0,return,source,assert,not,null,charset,charset,must,not,be,null,byte,array,output,stream,bos,new,byte,array,output,stream,length,boolean,changed,false,for,int,i,0,i,length,i,int,ch,source,char,at,i,if,ch,if,i,2,length,char,hex1,source,char,at,i,1,char,hex2,source,char,at,i,2,int,u,character,digit,hex1,16,int,l,character,digit,hex2,16,if,u,1,l,1,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,bos,write,char,u,4,l,i,2,changed,true,else,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,else,bos,write,ch,return,changed,new,string,bos,to,byte,array,charset,source
StringUtils -> @Nullable 	public static String uriDecode(@Nullable String source, Charset charset);1496259743;Decode the given encoded URI component value. Based on the following rules:_<ul>_<li>Alphanumeric characters {@code "a"} through {@code "z"}, {@code "A"} through {@code "Z"},_and {@code "0"} through {@code "9"} stay the same.</li>_<li>Special characters {@code "-"}, {@code "_"}, {@code "."}, and {@code "*"} stay the same.</li>_<li>A sequence "{@code %<i>xy</i>}" is interpreted as a hexadecimal representation of the character.</li>_</ul>_@param source the encoded String (may be {@code null})_@param charset the character set_@return the decoded value_@throws IllegalArgumentException when the given source contains invalid encoded sequences_@since 5.0_@see java.net.URLDecoder#decode(String, String);@Nullable_	public static String uriDecode(@Nullable String source, Charset charset) {_		if (source == null) {_			return null__		}_		int length = source.length()__		if (length == 0) {_			return source__		}_		Assert.notNull(charset, "Charset must not be null")___		ByteArrayOutputStream bos = new ByteArrayOutputStream(length)__		boolean changed = false__		for (int i = 0_ i < length_ i++) {_			int ch = source.charAt(i)__			if (ch == '%') {_				if (i + 2 < length) {_					char hex1 = source.charAt(i + 1)__					char hex2 = source.charAt(i + 2)__					int u = Character.digit(hex1, 16)__					int l = Character.digit(hex2, 16)__					if (u == -1 || l == -1) {_						throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__					}_					bos.write((char) ((u << 4) + l))__					i += 2__					changed = true__				}_				else {_					throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__				}_			}_			else {_				bos.write(ch)__			}_		}_		return (changed ? new String(bos.toByteArray(), charset) : source)__	};decode,the,given,encoded,uri,component,value,based,on,the,following,rules,ul,li,alphanumeric,characters,code,a,through,code,z,code,a,through,code,z,and,code,0,through,code,9,stay,the,same,li,li,special,characters,code,code,code,and,code,stay,the,same,li,li,a,sequence,code,i,xy,i,is,interpreted,as,a,hexadecimal,representation,of,the,character,li,ul,param,source,the,encoded,string,may,be,code,null,param,charset,the,character,set,return,the,decoded,value,throws,illegal,argument,exception,when,the,given,source,contains,invalid,encoded,sequences,since,5,0,see,java,net,urldecoder,decode,string,string;nullable,public,static,string,uri,decode,nullable,string,source,charset,charset,if,source,null,return,null,int,length,source,length,if,length,0,return,source,assert,not,null,charset,charset,must,not,be,null,byte,array,output,stream,bos,new,byte,array,output,stream,length,boolean,changed,false,for,int,i,0,i,length,i,int,ch,source,char,at,i,if,ch,if,i,2,length,char,hex1,source,char,at,i,1,char,hex2,source,char,at,i,2,int,u,character,digit,hex1,16,int,l,character,digit,hex2,16,if,u,1,l,1,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,bos,write,char,u,4,l,i,2,changed,true,else,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,else,bos,write,ch,return,changed,new,string,bos,to,byte,array,charset,source
StringUtils -> @Nullable 	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2);1495868221;Concatenate the given {@code String} arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});@Nullable_	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,code,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;nullable,public,static,string,concatenate,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> @Nullable 	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2);1496243689;Concatenate the given {@code String} arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});@Nullable_	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,code,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;nullable,public,static,string,concatenate,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> @Nullable 	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2);1496259743;Concatenate the given {@code String} arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});@Nullable_	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,code,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;nullable,public,static,string,concatenate,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> @Nullable 	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2);1496837955;Concatenate the given {@code String} arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});@Nullable_	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,code,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;nullable,public,static,string,concatenate,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> @Nullable 	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2);1499270197;Concatenate the given {@code String} arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});@Nullable_	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,code,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;nullable,public,static,string,concatenate,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> @Nullable 	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2);1508667152;Concatenate the given {@code String} arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});@Nullable_	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,code,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;nullable,public,static,string,concatenate,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> @Nullable 	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2);1508675477;Concatenate the given {@code String} arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});@Nullable_	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,code,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;nullable,public,static,string,concatenate,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> @Nullable 	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2);1508843807;Concatenate the given {@code String} arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});@Nullable_	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,code,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;nullable,public,static,string,concatenate,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> @Nullable 	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2);1516903831;Concatenate the given {@code String} arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});@Nullable_	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,code,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;nullable,public,static,string,concatenate,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> @Nullable 	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2);1519295386;Concatenate the given {@code String} arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});@Nullable_	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,code,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;nullable,public,static,string,concatenate,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> @Nullable 	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2);1519308837;Concatenate the given {@code String} arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});@Nullable_	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,code,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;nullable,public,static,string,concatenate,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> @Nullable 	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2);1519588127;Concatenate the given {@code String} arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});@Nullable_	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,code,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;nullable,public,static,string,concatenate,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> @Nullable 	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2);1522332352;Concatenate the given {@code String} arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});@Nullable_	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,code,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;nullable,public,static,string,concatenate,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> @Nullable 	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2);1525166194;Concatenate the given {@code String} arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});@Nullable_	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,code,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;nullable,public,static,string,concatenate,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> @Nullable 	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2);1530188116;Concatenate the given {@code String} arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});@Nullable_	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,code,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;nullable,public,static,string,concatenate,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> @Nullable 	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2);1531843079;Concatenate the given {@code String} arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});@Nullable_	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,code,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;nullable,public,static,string,concatenate,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> @Nullable 	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2);1531905026;Concatenate the given {@code String} arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});@Nullable_	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,code,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;nullable,public,static,string,concatenate,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> @Nullable 	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2);1533557519;Concatenate the given {@code String} arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});@Nullable_	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,code,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;nullable,public,static,string,concatenate,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> @Nullable 	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2);1533602820;Concatenate the given {@code String} arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});@Nullable_	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,code,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;nullable,public,static,string,concatenate,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> @Nullable 	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2);1535316501;Concatenate the given {@code String} arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});@Nullable_	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,code,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;nullable,public,static,string,concatenate,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> @Nullable 	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2);1550237113;Concatenate the given {@code String} arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});@Nullable_	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,code,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;nullable,public,static,string,concatenate,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> @Nullable 	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2);1550238935;Concatenate the given {@code String} arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});@Nullable_	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,code,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;nullable,public,static,string,concatenate,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> public static boolean hasLength(CharSequence str);1328020251;Check that the given CharSequence is neither <code>null</code> nor of length 0._Note: Will return <code>true</code> for a CharSequence that purely consists of whitespace._<p><pre>_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the CharSequence to check (may be <code>null</code>)_@return <code>true</code> if the CharSequence is not null and has length_@see #hasText(String);public static boolean hasLength(CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,char,sequence,is,neither,code,null,code,nor,of,length,0,note,will,return,code,true,code,for,a,char,sequence,that,purely,consists,of,whitespace,p,pre,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,char,sequence,to,check,may,be,code,null,code,return,code,true,code,if,the,char,sequence,is,not,null,and,has,length,see,has,text,string;public,static,boolean,has,length,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(CharSequence str);1337236962;Check that the given CharSequence is neither <code>null</code> nor of length 0._Note: Will return <code>true</code> for a CharSequence that purely consists of whitespace._<p><pre>_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the CharSequence to check (may be <code>null</code>)_@return <code>true</code> if the CharSequence is not null and has length_@see #hasText(String);public static boolean hasLength(CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,char,sequence,is,neither,code,null,code,nor,of,length,0,note,will,return,code,true,code,for,a,char,sequence,that,purely,consists,of,whitespace,p,pre,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,char,sequence,to,check,may,be,code,null,code,return,code,true,code,if,the,char,sequence,is,not,null,and,has,length,see,has,text,string;public,static,boolean,has,length,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(CharSequence str);1356735495;Check that the given CharSequence is neither {@code null} nor of length 0._Note: Will return {@code true} for a CharSequence that purely consists of whitespace._<p><pre>_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the CharSequence to check (may be {@code null})_@return {@code true} if the CharSequence is not null and has length_@see #hasText(String);public static boolean hasLength(CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,char,sequence,is,neither,code,null,nor,of,length,0,note,will,return,code,true,for,a,char,sequence,that,purely,consists,of,whitespace,p,pre,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,char,sequence,to,check,may,be,code,null,return,code,true,if,the,char,sequence,is,not,null,and,has,length,see,has,text,string;public,static,boolean,has,length,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(CharSequence str);1367955086;Check that the given CharSequence is neither {@code null} nor of length 0._Note: Will return {@code true} for a CharSequence that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the CharSequence to check (may be {@code null})_@return {@code true} if the CharSequence is not null and has length_@see #hasText(String);public static boolean hasLength(CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,char,sequence,is,neither,code,null,nor,of,length,0,note,will,return,code,true,for,a,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,char,sequence,to,check,may,be,code,null,return,code,true,if,the,char,sequence,is,not,null,and,has,length,see,has,text,string;public,static,boolean,has,length,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(CharSequence str);1380921248;Check that the given CharSequence is neither {@code null} nor of length 0._Note: Will return {@code true} for a CharSequence that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the CharSequence to check (may be {@code null})_@return {@code true} if the CharSequence is not null and has length_@see #hasText(String);public static boolean hasLength(CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,char,sequence,is,neither,code,null,nor,of,length,0,note,will,return,code,true,for,a,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,char,sequence,to,check,may,be,code,null,return,code,true,if,the,char,sequence,is,not,null,and,has,length,see,has,text,string;public,static,boolean,has,length,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(CharSequence str);1382750743;Check that the given CharSequence is neither {@code null} nor of length 0._Note: Will return {@code true} for a CharSequence that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the CharSequence to check (may be {@code null})_@return {@code true} if the CharSequence is not null and has length_@see #hasText(String);public static boolean hasLength(CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,char,sequence,is,neither,code,null,nor,of,length,0,note,will,return,code,true,for,a,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,char,sequence,to,check,may,be,code,null,return,code,true,if,the,char,sequence,is,not,null,and,has,length,see,has,text,string;public,static,boolean,has,length,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(CharSequence str);1385423968;Check that the given CharSequence is neither {@code null} nor of length 0._Note: Will return {@code true} for a CharSequence that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the CharSequence to check (may be {@code null})_@return {@code true} if the CharSequence is not null and has length_@see #hasText(String);public static boolean hasLength(CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,char,sequence,is,neither,code,null,nor,of,length,0,note,will,return,code,true,for,a,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,char,sequence,to,check,may,be,code,null,return,code,true,if,the,char,sequence,is,not,null,and,has,length,see,has,text,string;public,static,boolean,has,length,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(CharSequence str);1400189212;Check that the given CharSequence is neither {@code null} nor of length 0._Note: Will return {@code true} for a CharSequence that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the CharSequence to check (may be {@code null})_@return {@code true} if the CharSequence is not null and has length_@see #hasText(String);public static boolean hasLength(CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,char,sequence,is,neither,code,null,nor,of,length,0,note,will,return,code,true,for,a,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,char,sequence,to,check,may,be,code,null,return,code,true,if,the,char,sequence,is,not,null,and,has,length,see,has,text,string;public,static,boolean,has,length,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(CharSequence str);1400531359;Check that the given CharSequence is neither {@code null} nor of length 0._Note: Will return {@code true} for a CharSequence that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the CharSequence to check (may be {@code null})_@return {@code true} if the CharSequence is not null and has length_@see #hasText(String);public static boolean hasLength(CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,char,sequence,is,neither,code,null,nor,of,length,0,note,will,return,code,true,for,a,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,char,sequence,to,check,may,be,code,null,return,code,true,if,the,char,sequence,is,not,null,and,has,length,see,has,text,string;public,static,boolean,has,length,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(CharSequence str);1402676350;Check that the given CharSequence is neither {@code null} nor of length 0._Note: Will return {@code true} for a CharSequence that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the CharSequence to check (may be {@code null})_@return {@code true} if the CharSequence is not null and has length_@see #hasText(String);public static boolean hasLength(CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,char,sequence,is,neither,code,null,nor,of,length,0,note,will,return,code,true,for,a,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,char,sequence,to,check,may,be,code,null,return,code,true,if,the,char,sequence,is,not,null,and,has,length,see,has,text,string;public,static,boolean,has,length,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(CharSequence str);1426267150;Check that the given CharSequence is neither {@code null} nor of length 0._Note: Will return {@code true} for a CharSequence that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the CharSequence to check (may be {@code null})_@return {@code true} if the CharSequence is not null and has length_@see #hasText(String);public static boolean hasLength(CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,char,sequence,is,neither,code,null,nor,of,length,0,note,will,return,code,true,for,a,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,char,sequence,to,check,may,be,code,null,return,code,true,if,the,char,sequence,is,not,null,and,has,length,see,has,text,string;public,static,boolean,has,length,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(CharSequence str);1429034538;Check that the given {@code CharSequence} is neither {@code null} nor_of length 0._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the CharSequence to check (may be {@code null})_@return {@code true} if the CharSequence is not null and has length_@see #hasText(String);public static boolean hasLength(CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,code,char,sequence,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,char,sequence,to,check,may,be,code,null,return,code,true,if,the,char,sequence,is,not,null,and,has,length,see,has,text,string;public,static,boolean,has,length,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(CharSequence str);1429034756;Check that the given {@code CharSequence} is neither {@code null} nor_of length 0._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(String);public static boolean hasLength(CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,code,char,sequence,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,string;public,static,boolean,has,length,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(CharSequence str);1431006895;Check that the given {@code CharSequence} is neither {@code null} nor_of length 0._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(String);public static boolean hasLength(CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,code,char,sequence,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,string;public,static,boolean,has,length,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(CharSequence str);1431007368;Check that the given {@code CharSequence} is neither {@code null} nor_of length 0._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(String);public static boolean hasLength(CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,code,char,sequence,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,string;public,static,boolean,has,length,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(CharSequence str);1449489126;Check that the given {@code CharSequence} is neither {@code null} nor_of length 0._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(String);public static boolean hasLength(CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,code,char,sequence,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,string;public,static,boolean,has,length,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(CharSequence str);1467730834;Check that the given {@code CharSequence} is neither {@code null} nor_of length 0._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(String);public static boolean hasLength(CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,code,char,sequence,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,string;public,static,boolean,has,length,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(CharSequence str);1472128018;Check that the given {@code CharSequence} is neither {@code null} nor_of length 0._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(String);public static boolean hasLength(CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,code,char,sequence,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,string;public,static,boolean,has,length,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(CharSequence str);1472202842;Check that the given {@code CharSequence} is neither {@code null} nor_of length 0._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(String);public static boolean hasLength(CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,code,char,sequence,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,string;public,static,boolean,has,length,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(CharSequence str);1473942665;Check that the given {@code CharSequence} is neither {@code null} nor_of length 0._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(String);public static boolean hasLength(CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,code,char,sequence,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,string;public,static,boolean,has,length,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(CharSequence str);1484248946;Check that the given {@code CharSequence} is neither {@code null} nor_of length 0._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(String);public static boolean hasLength(CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,code,char,sequence,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,string;public,static,boolean,has,length,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(CharSequence str);1484260238;Check that the given {@code CharSequence} is neither {@code null} nor_of length 0._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(String);public static boolean hasLength(CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,code,char,sequence,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,string;public,static,boolean,has,length,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(CharSequence str);1484694546;Check that the given {@code CharSequence} is neither {@code null} nor_of length 0._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(String);public static boolean hasLength(CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,code,char,sequence,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,string;public,static,boolean,has,length,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(CharSequence str);1487760984;Check that the given {@code CharSequence} is neither {@code null} nor_of length 0._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(String);public static boolean hasLength(CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,code,char,sequence,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,string;public,static,boolean,has,length,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(CharSequence str);1487778834;Check that the given {@code CharSequence} is neither {@code null} nor_of length 0._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(String);public static boolean hasLength(CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,code,char,sequence,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,string;public,static,boolean,has,length,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(CharSequence str);1491898314;Check that the given {@code CharSequence} is neither {@code null} nor_of length 0._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(String);public static boolean hasLength(CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,code,char,sequence,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,string;public,static,boolean,has,length,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(CharSequence str);1491903650;Check that the given {@code CharSequence} is neither {@code null} nor_of length 0._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(String);public static boolean hasLength(CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,code,char,sequence,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,string;public,static,boolean,has,length,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static String stripFilenameExtension(String path);1328020251;Strip the filename extension from the given path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path (may be <code>null</code>)_@return the path with stripped filename extension,_or <code>null</code> if none;public static String stripFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}_		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,may,be,code,null,code,return,the,path,with,stripped,filename,extension,or,code,null,code,if,none;public,static,string,strip,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1337236962;Strip the filename extension from the given path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path (may be <code>null</code>)_@return the path with stripped filename extension,_or <code>null</code> if none;public static String stripFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}_		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,may,be,code,null,code,return,the,path,with,stripped,filename,extension,or,code,null,code,if,none;public,static,string,strip,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1356735495;Strip the filename extension from the given path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path (may be {@code null})_@return the path with stripped filename extension,_or {@code null} if none;public static String stripFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}_		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,may,be,code,null,return,the,path,with,stripped,filename,extension,or,code,null,if,none;public,static,string,strip,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1367955086;Strip the filename extension from the given path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path (may be {@code null})_@return the path with stripped filename extension,_or {@code null} if none;public static String stripFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}_		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,may,be,code,null,return,the,path,with,stripped,filename,extension,or,code,null,if,none;public,static,string,strip,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1380921248;Strip the filename extension from the given path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path (may be {@code null})_@return the path with stripped filename extension,_or {@code null} if none;public static String stripFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}_		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,may,be,code,null,return,the,path,with,stripped,filename,extension,or,code,null,if,none;public,static,string,strip,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1382750743;Strip the filename extension from the given path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path (may be {@code null})_@return the path with stripped filename extension,_or {@code null} if none;public static String stripFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}_		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,may,be,code,null,return,the,path,with,stripped,filename,extension,or,code,null,if,none;public,static,string,strip,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1385423968;Strip the filename extension from the given path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path (may be {@code null})_@return the path with stripped filename extension,_or {@code null} if none;public static String stripFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}_		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,may,be,code,null,return,the,path,with,stripped,filename,extension,or,code,null,if,none;public,static,string,strip,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1400189212;Strip the filename extension from the given path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path (may be {@code null})_@return the path with stripped filename extension,_or {@code null} if none;public static String stripFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}_		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,may,be,code,null,return,the,path,with,stripped,filename,extension,or,code,null,if,none;public,static,string,strip,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1400531359;Strip the filename extension from the given path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path (may be {@code null})_@return the path with stripped filename extension,_or {@code null} if none;public static String stripFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}_		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,may,be,code,null,return,the,path,with,stripped,filename,extension,or,code,null,if,none;public,static,string,strip,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1402676350;Strip the filename extension from the given path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path (may be {@code null})_@return the path with stripped filename extension,_or {@code null} if none;public static String stripFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}_		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,may,be,code,null,return,the,path,with,stripped,filename,extension,or,code,null,if,none;public,static,string,strip,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1426267150;Strip the filename extension from the given path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path (may be {@code null})_@return the path with stripped filename extension,_or {@code null} if none;public static String stripFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}_		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,may,be,code,null,return,the,path,with,stripped,filename,extension,or,code,null,if,none;public,static,string,strip,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1429034538;Strip the filename extension from the given path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path (may be {@code null})_@return the path with stripped filename extension,_or {@code null} if none;public static String stripFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}_		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,may,be,code,null,return,the,path,with,stripped,filename,extension,or,code,null,if,none;public,static,string,strip,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1429034756;Strip the filename extension from the given path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path (may be {@code null})_@return the path with stripped filename extension,_or {@code null} if none;public static String stripFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}_		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,may,be,code,null,return,the,path,with,stripped,filename,extension,or,code,null,if,none;public,static,string,strip,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1431006895;Strip the filename extension from the given path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path (may be {@code null})_@return the path with stripped filename extension,_or {@code null} if none;public static String stripFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}_		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,may,be,code,null,return,the,path,with,stripped,filename,extension,or,code,null,if,none;public,static,string,strip,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1431007368;Strip the filename extension from the given path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path (may be {@code null})_@return the path with stripped filename extension,_or {@code null} if none;public static String stripFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}_		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,may,be,code,null,return,the,path,with,stripped,filename,extension,or,code,null,if,none;public,static,string,strip,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1449489126;Strip the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path (may be {@code null})_@return the path with stripped filename extension,_or {@code null} if none;public static String stripFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}_		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,may,be,code,null,return,the,path,with,stripped,filename,extension,or,code,null,if,none;public,static,string,strip,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1467730834;Strip the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path (may be {@code null})_@return the path with stripped filename extension,_or {@code null} if none;public static String stripFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}_		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,may,be,code,null,return,the,path,with,stripped,filename,extension,or,code,null,if,none;public,static,string,strip,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1472128018;Strip the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path (may be {@code null})_@return the path with stripped filename extension,_or {@code null} if none;public static String stripFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}_		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,may,be,code,null,return,the,path,with,stripped,filename,extension,or,code,null,if,none;public,static,string,strip,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1472202842;Strip the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path (may be {@code null})_@return the path with stripped filename extension,_or {@code null} if none;public static String stripFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}_		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,may,be,code,null,return,the,path,with,stripped,filename,extension,or,code,null,if,none;public,static,string,strip,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1473942665;Strip the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path (may be {@code null})_@return the path with stripped filename extension,_or {@code null} if none;public static String stripFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}_		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,may,be,code,null,return,the,path,with,stripped,filename,extension,or,code,null,if,none;public,static,string,strip,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1484248946;Strip the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path (may be {@code null})_@return the path with stripped filename extension,_or {@code null} if none;public static String stripFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}_		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,may,be,code,null,return,the,path,with,stripped,filename,extension,or,code,null,if,none;public,static,string,strip,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1484260238;Strip the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path (may be {@code null})_@return the path with stripped filename extension,_or {@code null} if none;public static String stripFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}_		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,may,be,code,null,return,the,path,with,stripped,filename,extension,or,code,null,if,none;public,static,string,strip,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1484694546;Strip the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path (may be {@code null})_@return the path with stripped filename extension,_or {@code null} if none;public static String stripFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}_		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,may,be,code,null,return,the,path,with,stripped,filename,extension,or,code,null,if,none;public,static,string,strip,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1487760984;Strip the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path (may be {@code null})_@return the path with stripped filename extension,_or {@code null} if none;public static String stripFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}_		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,may,be,code,null,return,the,path,with,stripped,filename,extension,or,code,null,if,none;public,static,string,strip,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1487778834;Strip the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path (may be {@code null})_@return the path with stripped filename extension,_or {@code null} if none;public static String stripFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}_		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,may,be,code,null,return,the,path,with,stripped,filename,extension,or,code,null,if,none;public,static,string,strip,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1491898314;Strip the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path (may be {@code null})_@return the path with stripped filename extension,_or {@code null} if none;public static String stripFilenameExtension(String path) {_		if (path == null) {_			return null__		}__		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}__		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,may,be,code,null,return,the,path,with,stripped,filename,extension,or,code,null,if,none;public,static,string,strip,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1491903650;Strip the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path (may be {@code null})_@return the path with stripped filename extension,_or {@code null} if none;public static String stripFilenameExtension(String path) {_		if (path == null) {_			return null__		}__		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}__		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,may,be,code,null,return,the,path,with,stripped,filename,extension,or,code,null,if,none;public,static,string,strip,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1496837955;Strip the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path_@return the path with stripped filename extension;public static String stripFilenameExtension(String path) {_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}__		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,return,the,path,with,stripped,filename,extension;public,static,string,strip,filename,extension,string,path,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1499270197;Strip the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path_@return the path with stripped filename extension;public static String stripFilenameExtension(String path) {_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}__		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,return,the,path,with,stripped,filename,extension;public,static,string,strip,filename,extension,string,path,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1508667152;Strip the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path_@return the path with stripped filename extension;public static String stripFilenameExtension(String path) {_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}__		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,return,the,path,with,stripped,filename,extension;public,static,string,strip,filename,extension,string,path,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1508675477;Strip the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path_@return the path with stripped filename extension;public static String stripFilenameExtension(String path) {_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}__		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,return,the,path,with,stripped,filename,extension;public,static,string,strip,filename,extension,string,path,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1508843807;Strip the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path_@return the path with stripped filename extension;public static String stripFilenameExtension(String path) {_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}__		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,return,the,path,with,stripped,filename,extension;public,static,string,strip,filename,extension,string,path,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1516903831;Strip the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path_@return the path with stripped filename extension;public static String stripFilenameExtension(String path) {_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}__		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,return,the,path,with,stripped,filename,extension;public,static,string,strip,filename,extension,string,path,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1519295386;Strip the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path_@return the path with stripped filename extension;public static String stripFilenameExtension(String path) {_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}__		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,return,the,path,with,stripped,filename,extension;public,static,string,strip,filename,extension,string,path,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1519308837;Strip the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path_@return the path with stripped filename extension;public static String stripFilenameExtension(String path) {_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}__		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,return,the,path,with,stripped,filename,extension;public,static,string,strip,filename,extension,string,path,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1519588127;Strip the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path_@return the path with stripped filename extension;public static String stripFilenameExtension(String path) {_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}__		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,return,the,path,with,stripped,filename,extension;public,static,string,strip,filename,extension,string,path,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1522332352;Strip the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path_@return the path with stripped filename extension;public static String stripFilenameExtension(String path) {_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}__		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,return,the,path,with,stripped,filename,extension;public,static,string,strip,filename,extension,string,path,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1525166194;Strip the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path_@return the path with stripped filename extension;public static String stripFilenameExtension(String path) {_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}__		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,return,the,path,with,stripped,filename,extension;public,static,string,strip,filename,extension,string,path,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1530188116;Strip the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path_@return the path with stripped filename extension;public static String stripFilenameExtension(String path) {_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}__		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,return,the,path,with,stripped,filename,extension;public,static,string,strip,filename,extension,string,path,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1531843079;Strip the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path_@return the path with stripped filename extension;public static String stripFilenameExtension(String path) {_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}__		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,return,the,path,with,stripped,filename,extension;public,static,string,strip,filename,extension,string,path,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1531905026;Strip the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path_@return the path with stripped filename extension;public static String stripFilenameExtension(String path) {_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}__		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,return,the,path,with,stripped,filename,extension;public,static,string,strip,filename,extension,string,path,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1533557519;Strip the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path_@return the path with stripped filename extension;public static String stripFilenameExtension(String path) {_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}__		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,return,the,path,with,stripped,filename,extension;public,static,string,strip,filename,extension,string,path,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1533602820;Strip the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path_@return the path with stripped filename extension;public static String stripFilenameExtension(String path) {_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}__		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,return,the,path,with,stripped,filename,extension;public,static,string,strip,filename,extension,string,path,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1535316501;Strip the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path_@return the path with stripped filename extension;public static String stripFilenameExtension(String path) {_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}__		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,return,the,path,with,stripped,filename,extension;public,static,string,strip,filename,extension,string,path,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1550237113;Strip the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path_@return the path with stripped filename extension;public static String stripFilenameExtension(String path) {_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}__		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,return,the,path,with,stripped,filename,extension;public,static,string,strip,filename,extension,string,path,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String stripFilenameExtension(String path);1550238935;Strip the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path_@return the path with stripped filename extension;public static String stripFilenameExtension(String path) {_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}__		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,return,the,path,with,stripped,filename,extension;public,static,string,strip,filename,extension,string,path,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static String uncapitalize(String str);1328020251;Uncapitalize a <code>String</code>, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the String to uncapitalize, may be <code>null</code>_@return the uncapitalized String, <code>null</code> if null;public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,code,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,string,to,uncapitalize,may,be,code,null,code,return,the,uncapitalized,string,code,null,code,if,null;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1337236962;Uncapitalize a <code>String</code>, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the String to uncapitalize, may be <code>null</code>_@return the uncapitalized String, <code>null</code> if null;public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,code,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,string,to,uncapitalize,may,be,code,null,code,return,the,uncapitalized,string,code,null,code,if,null;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1356735495;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the String to uncapitalize, may be {@code null}_@return the uncapitalized String, {@code null} if null;public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,string,to,uncapitalize,may,be,code,null,return,the,uncapitalized,string,code,null,if,null;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1367955086;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the String to uncapitalize, may be {@code null}_@return the uncapitalized String, {@code null} if null;public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,string,to,uncapitalize,may,be,code,null,return,the,uncapitalized,string,code,null,if,null;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1380921248;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the String to uncapitalize, may be {@code null}_@return the uncapitalized String, {@code null} if null;public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,string,to,uncapitalize,may,be,code,null,return,the,uncapitalized,string,code,null,if,null;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1382750743;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the String to uncapitalize, may be {@code null}_@return the uncapitalized String, {@code null} if null;public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,string,to,uncapitalize,may,be,code,null,return,the,uncapitalized,string,code,null,if,null;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1385423968;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the String to uncapitalize, may be {@code null}_@return the uncapitalized String, {@code null} if null;public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,string,to,uncapitalize,may,be,code,null,return,the,uncapitalized,string,code,null,if,null;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1400189212;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the String to uncapitalize, may be {@code null}_@return the uncapitalized String, {@code null} if null;public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,string,to,uncapitalize,may,be,code,null,return,the,uncapitalized,string,code,null,if,null;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1400531359;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the String to uncapitalize, may be {@code null}_@return the uncapitalized String, {@code null} if null;public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,string,to,uncapitalize,may,be,code,null,return,the,uncapitalized,string,code,null,if,null;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1402676350;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the String to uncapitalize, may be {@code null}_@return the uncapitalized String, {@code null} if null;public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,string,to,uncapitalize,may,be,code,null,return,the,uncapitalized,string,code,null,if,null;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1426267150;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the String to uncapitalize, may be {@code null}_@return the uncapitalized String, {@code null} if null;public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,string,to,uncapitalize,may,be,code,null,return,the,uncapitalized,string,code,null,if,null;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1429034538;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the String to uncapitalize, may be {@code null}_@return the uncapitalized String, {@code null} if null;public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,string,to,uncapitalize,may,be,code,null,return,the,uncapitalized,string,code,null,if,null;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1429034756;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the {@code String} to uncapitalize, may be {@code null}_@return the uncapitalized {@code String}, or {@code null} if the supplied_string is {@code null};public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,code,string,to,uncapitalize,may,be,code,null,return,the,uncapitalized,code,string,or,code,null,if,the,supplied,string,is,code,null;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1431006895;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the {@code String} to uncapitalize, may be {@code null}_@return the uncapitalized {@code String}, or {@code null} if the supplied_string is {@code null};public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,code,string,to,uncapitalize,may,be,code,null,return,the,uncapitalized,code,string,or,code,null,if,the,supplied,string,is,code,null;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1431007368;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the {@code String} to uncapitalize, may be {@code null}_@return the uncapitalized {@code String}, or {@code null} if the supplied_string is {@code null};public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,code,string,to,uncapitalize,may,be,code,null,return,the,uncapitalized,code,string,or,code,null,if,the,supplied,string,is,code,null;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1449489126;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the {@code String} to uncapitalize, may be {@code null}_@return the uncapitalized {@code String}, or {@code null} if the supplied_string is {@code null};public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,code,string,to,uncapitalize,may,be,code,null,return,the,uncapitalized,code,string,or,code,null,if,the,supplied,string,is,code,null;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1467730834;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the {@code String} to uncapitalize, may be {@code null}_@return the uncapitalized {@code String}, or {@code null} if the supplied_string is {@code null};public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,code,string,to,uncapitalize,may,be,code,null,return,the,uncapitalized,code,string,or,code,null,if,the,supplied,string,is,code,null;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1472128018;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the {@code String} to uncapitalize, may be {@code null}_@return the uncapitalized {@code String}, or {@code null} if the supplied_string is {@code null};public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,code,string,to,uncapitalize,may,be,code,null,return,the,uncapitalized,code,string,or,code,null,if,the,supplied,string,is,code,null;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1472202842;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the {@code String} to uncapitalize, may be {@code null}_@return the uncapitalized {@code String}, or {@code null} if the supplied_string is {@code null};public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,code,string,to,uncapitalize,may,be,code,null,return,the,uncapitalized,code,string,or,code,null,if,the,supplied,string,is,code,null;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1473942665;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the {@code String} to uncapitalize, may be {@code null}_@return the uncapitalized {@code String}, or {@code null} if the supplied_string is {@code null};public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,code,string,to,uncapitalize,may,be,code,null,return,the,uncapitalized,code,string,or,code,null,if,the,supplied,string,is,code,null;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1484248946;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the {@code String} to uncapitalize, may be {@code null}_@return the uncapitalized {@code String}, or {@code null} if the supplied_string is {@code null};public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,code,string,to,uncapitalize,may,be,code,null,return,the,uncapitalized,code,string,or,code,null,if,the,supplied,string,is,code,null;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1484260238;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the {@code String} to uncapitalize, may be {@code null}_@return the uncapitalized {@code String}, or {@code null} if the supplied_string is {@code null};public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,code,string,to,uncapitalize,may,be,code,null,return,the,uncapitalized,code,string,or,code,null,if,the,supplied,string,is,code,null;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1484694546;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the {@code String} to uncapitalize, may be {@code null}_@return the uncapitalized {@code String}, or {@code null} if the supplied_string is {@code null};public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,code,string,to,uncapitalize,may,be,code,null,return,the,uncapitalized,code,string,or,code,null,if,the,supplied,string,is,code,null;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1487760984;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the {@code String} to uncapitalize, may be {@code null}_@return the uncapitalized {@code String}, or {@code null} if the supplied_string is {@code null};public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,code,string,to,uncapitalize,may,be,code,null,return,the,uncapitalized,code,string,or,code,null,if,the,supplied,string,is,code,null;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1487778834;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the {@code String} to uncapitalize, may be {@code null}_@return the uncapitalized {@code String}, or {@code null} if the supplied_string is {@code null};public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,code,string,to,uncapitalize,may,be,code,null,return,the,uncapitalized,code,string,or,code,null,if,the,supplied,string,is,code,null;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1491898314;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the {@code String} to uncapitalize, may be {@code null}_@return the uncapitalized {@code String}, or {@code null} if the supplied_string is {@code null};public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,code,string,to,uncapitalize,may,be,code,null,return,the,uncapitalized,code,string,or,code,null,if,the,supplied,string,is,code,null;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1491903650;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the {@code String} to uncapitalize, may be {@code null}_@return the uncapitalized {@code String}, or {@code null} if the supplied_string is {@code null};public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,code,string,to,uncapitalize,may,be,code,null,return,the,uncapitalized,code,string,or,code,null,if,the,supplied,string,is,code,null;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1499270197;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the {@code String} to uncapitalize_@return the uncapitalized {@code String};public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,code,string,to,uncapitalize,return,the,uncapitalized,code,string;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1508667152;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the {@code String} to uncapitalize_@return the uncapitalized {@code String};public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,code,string,to,uncapitalize,return,the,uncapitalized,code,string;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1508675477;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the {@code String} to uncapitalize_@return the uncapitalized {@code String};public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,code,string,to,uncapitalize,return,the,uncapitalized,code,string;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1508843807;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the {@code String} to uncapitalize_@return the uncapitalized {@code String};public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,code,string,to,uncapitalize,return,the,uncapitalized,code,string;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1516903831;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the {@code String} to uncapitalize_@return the uncapitalized {@code String};public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,code,string,to,uncapitalize,return,the,uncapitalized,code,string;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1519295386;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the {@code String} to uncapitalize_@return the uncapitalized {@code String};public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,code,string,to,uncapitalize,return,the,uncapitalized,code,string;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1519308837;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the {@code String} to uncapitalize_@return the uncapitalized {@code String};public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,code,string,to,uncapitalize,return,the,uncapitalized,code,string;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1519588127;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the {@code String} to uncapitalize_@return the uncapitalized {@code String};public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,code,string,to,uncapitalize,return,the,uncapitalized,code,string;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1522332352;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the {@code String} to uncapitalize_@return the uncapitalized {@code String};public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,code,string,to,uncapitalize,return,the,uncapitalized,code,string;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1525166194;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the {@code String} to uncapitalize_@return the uncapitalized {@code String};public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,code,string,to,uncapitalize,return,the,uncapitalized,code,string;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1530188116;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the {@code String} to uncapitalize_@return the uncapitalized {@code String};public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,code,string,to,uncapitalize,return,the,uncapitalized,code,string;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1531843079;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the {@code String} to uncapitalize_@return the uncapitalized {@code String};public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,code,string,to,uncapitalize,return,the,uncapitalized,code,string;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1531905026;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the {@code String} to uncapitalize_@return the uncapitalized {@code String};public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,code,string,to,uncapitalize,return,the,uncapitalized,code,string;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1533557519;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the {@code String} to uncapitalize_@return the uncapitalized {@code String};public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,code,string,to,uncapitalize,return,the,uncapitalized,code,string;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1533602820;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the {@code String} to uncapitalize_@return the uncapitalized {@code String};public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,code,string,to,uncapitalize,return,the,uncapitalized,code,string;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1535316501;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the {@code String} to uncapitalize_@return the uncapitalized {@code String};public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,code,string,to,uncapitalize,return,the,uncapitalized,code,string;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1550237113;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the {@code String} to uncapitalize_@return the uncapitalized {@code String};public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,code,string,to,uncapitalize,return,the,uncapitalized,code,string;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String uncapitalize(String str);1550238935;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the {@code String} to uncapitalize_@return the uncapitalized {@code String};public static String uncapitalize(String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,code,string,to,uncapitalize,return,the,uncapitalized,code,string;public,static,string,uncapitalize,string,str,return,change,first,character,case,str,false
StringUtils -> public static String[] addStringToArray(String[] array, String str);1328020251;Append the given String to the given String array, returning a new array_consisting of the input array contents plus the given String._@param array the array to append to (can be <code>null</code>)_@param str the String to append_@return the new array (never <code>null</code>);public static String[] addStringToArray(String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}_		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,string,to,the,given,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,string,param,array,the,array,to,append,to,can,be,code,null,code,param,str,the,string,to,append,return,the,new,array,never,code,null,code;public,static,string,add,string,to,array,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(String[] array, String str);1337236962;Append the given String to the given String array, returning a new array_consisting of the input array contents plus the given String._@param array the array to append to (can be <code>null</code>)_@param str the String to append_@return the new array (never <code>null</code>);public static String[] addStringToArray(String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}_		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,string,to,the,given,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,string,param,array,the,array,to,append,to,can,be,code,null,code,param,str,the,string,to,append,return,the,new,array,never,code,null,code;public,static,string,add,string,to,array,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(String[] array, String str);1356735495;Append the given String to the given String array, returning a new array_consisting of the input array contents plus the given String._@param array the array to append to (can be {@code null})_@param str the String to append_@return the new array (never {@code null});public static String[] addStringToArray(String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}_		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,string,to,the,given,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(String[] array, String str);1367955086;Append the given String to the given String array, returning a new array_consisting of the input array contents plus the given String._@param array the array to append to (can be {@code null})_@param str the String to append_@return the new array (never {@code null});public static String[] addStringToArray(String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}_		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,string,to,the,given,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(String[] array, String str);1380921248;Append the given String to the given String array, returning a new array_consisting of the input array contents plus the given String._@param array the array to append to (can be {@code null})_@param str the String to append_@return the new array (never {@code null});public static String[] addStringToArray(String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}_		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,string,to,the,given,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(String[] array, String str);1382750743;Append the given String to the given String array, returning a new array_consisting of the input array contents plus the given String._@param array the array to append to (can be {@code null})_@param str the String to append_@return the new array (never {@code null});public static String[] addStringToArray(String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}_		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,string,to,the,given,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(String[] array, String str);1385423968;Append the given String to the given String array, returning a new array_consisting of the input array contents plus the given String._@param array the array to append to (can be {@code null})_@param str the String to append_@return the new array (never {@code null});public static String[] addStringToArray(String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}_		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,string,to,the,given,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(String[] array, String str);1400189212;Append the given String to the given String array, returning a new array_consisting of the input array contents plus the given String._@param array the array to append to (can be {@code null})_@param str the String to append_@return the new array (never {@code null});public static String[] addStringToArray(String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}_		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,string,to,the,given,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(String[] array, String str);1400531359;Append the given String to the given String array, returning a new array_consisting of the input array contents plus the given String._@param array the array to append to (can be {@code null})_@param str the String to append_@return the new array (never {@code null});public static String[] addStringToArray(String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}_		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,string,to,the,given,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(String[] array, String str);1402676350;Append the given String to the given String array, returning a new array_consisting of the input array contents plus the given String._@param array the array to append to (can be {@code null})_@param str the String to append_@return the new array (never {@code null});public static String[] addStringToArray(String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}_		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,string,to,the,given,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(String[] array, String str);1426267150;Append the given String to the given String array, returning a new array_consisting of the input array contents plus the given String._@param array the array to append to (can be {@code null})_@param str the String to append_@return the new array (never {@code null});public static String[] addStringToArray(String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}_		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,string,to,the,given,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(String[] array, String str);1429034538;Append the given String to the given String array, returning a new array_consisting of the input array contents plus the given String._@param array the array to append to (can be {@code null})_@param str the String to append_@return the new array (never {@code null});public static String[] addStringToArray(String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}_		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,string,to,the,given,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(String[] array, String str);1429034756;Append the given {@code String} to the given {@code String} array,_returning a new array consisting of the input array contents plus_the given {@code String}._@param array the array to append to (can be {@code null})_@param str the {@code String} to append_@return the new array (never {@code null});public static String[] addStringToArray(String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}_		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,code,string,to,the,given,code,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,code,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,code,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(String[] array, String str);1431006895;Append the given {@code String} to the given {@code String} array,_returning a new array consisting of the input array contents plus_the given {@code String}._@param array the array to append to (can be {@code null})_@param str the {@code String} to append_@return the new array (never {@code null});public static String[] addStringToArray(String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}_		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,code,string,to,the,given,code,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,code,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,code,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(String[] array, String str);1431007368;Append the given {@code String} to the given {@code String} array,_returning a new array consisting of the input array contents plus_the given {@code String}._@param array the array to append to (can be {@code null})_@param str the {@code String} to append_@return the new array (never {@code null});public static String[] addStringToArray(String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}_		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,code,string,to,the,given,code,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,code,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,code,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(String[] array, String str);1449489126;Append the given {@code String} to the given {@code String} array,_returning a new array consisting of the input array contents plus_the given {@code String}._@param array the array to append to (can be {@code null})_@param str the {@code String} to append_@return the new array (never {@code null});public static String[] addStringToArray(String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}_		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,code,string,to,the,given,code,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,code,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,code,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(String[] array, String str);1467730834;Append the given {@code String} to the given {@code String} array,_returning a new array consisting of the input array contents plus_the given {@code String}._@param array the array to append to (can be {@code null})_@param str the {@code String} to append_@return the new array (never {@code null});public static String[] addStringToArray(String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}_		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,code,string,to,the,given,code,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,code,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,code,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(String[] array, String str);1472128018;Append the given {@code String} to the given {@code String} array,_returning a new array consisting of the input array contents plus_the given {@code String}._@param array the array to append to (can be {@code null})_@param str the {@code String} to append_@return the new array (never {@code null});public static String[] addStringToArray(String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}_		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,code,string,to,the,given,code,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,code,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,code,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(String[] array, String str);1472202842;Append the given {@code String} to the given {@code String} array,_returning a new array consisting of the input array contents plus_the given {@code String}._@param array the array to append to (can be {@code null})_@param str the {@code String} to append_@return the new array (never {@code null});public static String[] addStringToArray(String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}_		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,code,string,to,the,given,code,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,code,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,code,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(String[] array, String str);1473942665;Append the given {@code String} to the given {@code String} array,_returning a new array consisting of the input array contents plus_the given {@code String}._@param array the array to append to (can be {@code null})_@param str the {@code String} to append_@return the new array (never {@code null});public static String[] addStringToArray(String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}_		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,code,string,to,the,given,code,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,code,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,code,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(String[] array, String str);1484248946;Append the given {@code String} to the given {@code String} array,_returning a new array consisting of the input array contents plus_the given {@code String}._@param array the array to append to (can be {@code null})_@param str the {@code String} to append_@return the new array (never {@code null});public static String[] addStringToArray(String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}_		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,code,string,to,the,given,code,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,code,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,code,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(String[] array, String str);1484260238;Append the given {@code String} to the given {@code String} array,_returning a new array consisting of the input array contents plus_the given {@code String}._@param array the array to append to (can be {@code null})_@param str the {@code String} to append_@return the new array (never {@code null});public static String[] addStringToArray(String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}_		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,code,string,to,the,given,code,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,code,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,code,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(String[] array, String str);1484694546;Append the given {@code String} to the given {@code String} array,_returning a new array consisting of the input array contents plus_the given {@code String}._@param array the array to append to (can be {@code null})_@param str the {@code String} to append_@return the new array (never {@code null});public static String[] addStringToArray(String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}_		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,code,string,to,the,given,code,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,code,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,code,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(String[] array, String str);1487760984;Append the given {@code String} to the given {@code String} array,_returning a new array consisting of the input array contents plus_the given {@code String}._@param array the array to append to (can be {@code null})_@param str the {@code String} to append_@return the new array (never {@code null});public static String[] addStringToArray(String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}_		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,code,string,to,the,given,code,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,code,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,code,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(String[] array, String str);1487778834;Append the given {@code String} to the given {@code String} array,_returning a new array consisting of the input array contents plus_the given {@code String}._@param array the array to append to (can be {@code null})_@param str the {@code String} to append_@return the new array (never {@code null});public static String[] addStringToArray(String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}_		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,code,string,to,the,given,code,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,code,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,code,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(String[] array, String str);1491898314;Append the given {@code String} to the given {@code String} array,_returning a new array consisting of the input array contents plus_the given {@code String}._@param array the array to append to (can be {@code null})_@param str the {@code String} to append_@return the new array (never {@code null});public static String[] addStringToArray(String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}__		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,code,string,to,the,given,code,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,code,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,code,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(String[] array, String str);1491903650;Append the given {@code String} to the given {@code String} array,_returning a new array consisting of the input array contents plus_the given {@code String}._@param array the array to append to (can be {@code null})_@param str the {@code String} to append_@return the new array (never {@code null});public static String[] addStringToArray(String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}__		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,code,string,to,the,given,code,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,code,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,code,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> @Nullable 	public static String getFilename(@Nullable String path);1495868221;Extract the filename from the given Java resource path,_e.g. {@code "mypath/myfile.txt" -> "myfile.txt"}._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;@Nullable_	public static String getFilename(@Nullable String path) {_		if (path == null) {_			return null__		}__		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,java,resource,path,e,g,code,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;nullable,public,static,string,get,filename,nullable,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> @Nullable 	public static String getFilename(@Nullable String path);1496243689;Extract the filename from the given Java resource path,_e.g. {@code "mypath/myfile.txt" -> "myfile.txt"}._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;@Nullable_	public static String getFilename(@Nullable String path) {_		if (path == null) {_			return null__		}__		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,java,resource,path,e,g,code,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;nullable,public,static,string,get,filename,nullable,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> @Nullable 	public static String getFilename(@Nullable String path);1496259743;Extract the filename from the given Java resource path,_e.g. {@code "mypath/myfile.txt" -> "myfile.txt"}._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;@Nullable_	public static String getFilename(@Nullable String path) {_		if (path == null) {_			return null__		}__		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,java,resource,path,e,g,code,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;nullable,public,static,string,get,filename,nullable,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> @Nullable 	public static String getFilename(@Nullable String path);1496837955;Extract the filename from the given Java resource path,_e.g. {@code "mypath/myfile.txt" -> "myfile.txt"}._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;@Nullable_	public static String getFilename(@Nullable String path) {_		if (path == null) {_			return null__		}__		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,java,resource,path,e,g,code,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;nullable,public,static,string,get,filename,nullable,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> @Nullable 	public static String getFilename(@Nullable String path);1499270197;Extract the filename from the given Java resource path,_e.g. {@code "mypath/myfile.txt" -> "myfile.txt"}._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;@Nullable_	public static String getFilename(@Nullable String path) {_		if (path == null) {_			return null__		}__		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,java,resource,path,e,g,code,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;nullable,public,static,string,get,filename,nullable,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> @Nullable 	public static String getFilename(@Nullable String path);1508667152;Extract the filename from the given Java resource path,_e.g. {@code "mypath/myfile.txt" -> "myfile.txt"}._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;@Nullable_	public static String getFilename(@Nullable String path) {_		if (path == null) {_			return null__		}__		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,java,resource,path,e,g,code,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;nullable,public,static,string,get,filename,nullable,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> @Nullable 	public static String getFilename(@Nullable String path);1508675477;Extract the filename from the given Java resource path,_e.g. {@code "mypath/myfile.txt" -> "myfile.txt"}._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;@Nullable_	public static String getFilename(@Nullable String path) {_		if (path == null) {_			return null__		}__		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,java,resource,path,e,g,code,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;nullable,public,static,string,get,filename,nullable,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> @Nullable 	public static String getFilename(@Nullable String path);1508843807;Extract the filename from the given Java resource path,_e.g. {@code "mypath/myfile.txt" -> "myfile.txt"}._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;@Nullable_	public static String getFilename(@Nullable String path) {_		if (path == null) {_			return null__		}__		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,java,resource,path,e,g,code,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;nullable,public,static,string,get,filename,nullable,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> @Nullable 	public static String getFilename(@Nullable String path);1516903831;Extract the filename from the given Java resource path,_e.g. {@code "mypath/myfile.txt" -> "myfile.txt"}._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;@Nullable_	public static String getFilename(@Nullable String path) {_		if (path == null) {_			return null__		}__		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,java,resource,path,e,g,code,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;nullable,public,static,string,get,filename,nullable,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> @Nullable 	public static String getFilename(@Nullable String path);1519295386;Extract the filename from the given Java resource path,_e.g. {@code "mypath/myfile.txt" -> "myfile.txt"}._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;@Nullable_	public static String getFilename(@Nullable String path) {_		if (path == null) {_			return null__		}__		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,java,resource,path,e,g,code,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;nullable,public,static,string,get,filename,nullable,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> @Nullable 	public static String getFilename(@Nullable String path);1519308837;Extract the filename from the given Java resource path,_e.g. {@code "mypath/myfile.txt" -> "myfile.txt"}._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;@Nullable_	public static String getFilename(@Nullable String path) {_		if (path == null) {_			return null__		}__		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,java,resource,path,e,g,code,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;nullable,public,static,string,get,filename,nullable,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> @Nullable 	public static String getFilename(@Nullable String path);1519588127;Extract the filename from the given Java resource path,_e.g. {@code "mypath/myfile.txt" -> "myfile.txt"}._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;@Nullable_	public static String getFilename(@Nullable String path) {_		if (path == null) {_			return null__		}__		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,java,resource,path,e,g,code,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;nullable,public,static,string,get,filename,nullable,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> @Nullable 	public static String getFilename(@Nullable String path);1522332352;Extract the filename from the given Java resource path,_e.g. {@code "mypath/myfile.txt" -> "myfile.txt"}._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;@Nullable_	public static String getFilename(@Nullable String path) {_		if (path == null) {_			return null__		}__		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,java,resource,path,e,g,code,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;nullable,public,static,string,get,filename,nullable,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> @Nullable 	public static String getFilename(@Nullable String path);1525166194;Extract the filename from the given Java resource path,_e.g. {@code "mypath/myfile.txt" -> "myfile.txt"}._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;@Nullable_	public static String getFilename(@Nullable String path) {_		if (path == null) {_			return null__		}__		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,java,resource,path,e,g,code,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;nullable,public,static,string,get,filename,nullable,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> @Nullable 	public static String getFilename(@Nullable String path);1530188116;Extract the filename from the given Java resource path,_e.g. {@code "mypath/myfile.txt" -> "myfile.txt"}._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;@Nullable_	public static String getFilename(@Nullable String path) {_		if (path == null) {_			return null__		}__		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,java,resource,path,e,g,code,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;nullable,public,static,string,get,filename,nullable,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> @Nullable 	public static String getFilename(@Nullable String path);1531843079;Extract the filename from the given Java resource path,_e.g. {@code "mypath/myfile.txt" -> "myfile.txt"}._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;@Nullable_	public static String getFilename(@Nullable String path) {_		if (path == null) {_			return null__		}__		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,java,resource,path,e,g,code,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;nullable,public,static,string,get,filename,nullable,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> @Nullable 	public static String getFilename(@Nullable String path);1531905026;Extract the filename from the given Java resource path,_e.g. {@code "mypath/myfile.txt" -> "myfile.txt"}._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;@Nullable_	public static String getFilename(@Nullable String path) {_		if (path == null) {_			return null__		}__		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,java,resource,path,e,g,code,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;nullable,public,static,string,get,filename,nullable,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> @Nullable 	public static String getFilename(@Nullable String path);1533557519;Extract the filename from the given Java resource path,_e.g. {@code "mypath/myfile.txt" -> "myfile.txt"}._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;@Nullable_	public static String getFilename(@Nullable String path) {_		if (path == null) {_			return null__		}__		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,java,resource,path,e,g,code,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;nullable,public,static,string,get,filename,nullable,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> @Nullable 	public static String getFilename(@Nullable String path);1533602820;Extract the filename from the given Java resource path,_e.g. {@code "mypath/myfile.txt" -> "myfile.txt"}._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;@Nullable_	public static String getFilename(@Nullable String path) {_		if (path == null) {_			return null__		}__		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,java,resource,path,e,g,code,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;nullable,public,static,string,get,filename,nullable,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> @Nullable 	public static String getFilename(@Nullable String path);1535316501;Extract the filename from the given Java resource path,_e.g. {@code "mypath/myfile.txt" -> "myfile.txt"}._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;@Nullable_	public static String getFilename(@Nullable String path) {_		if (path == null) {_			return null__		}__		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,java,resource,path,e,g,code,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;nullable,public,static,string,get,filename,nullable,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> @Nullable 	public static String getFilename(@Nullable String path);1550237113;Extract the filename from the given Java resource path,_e.g. {@code "mypath/myfile.txt" -> "myfile.txt"}._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;@Nullable_	public static String getFilename(@Nullable String path) {_		if (path == null) {_			return null__		}__		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,java,resource,path,e,g,code,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;nullable,public,static,string,get,filename,nullable,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> @Nullable 	public static String getFilename(@Nullable String path);1550238935;Extract the filename from the given Java resource path,_e.g. {@code "mypath/myfile.txt" -> "myfile.txt"}._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;@Nullable_	public static String getFilename(@Nullable String path) {_		if (path == null) {_			return null__		}__		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,java,resource,path,e,g,code,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;nullable,public,static,string,get,filename,nullable,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> public static boolean startsWithIgnoreCase(String str, String prefix);1328020251;Test if the given String starts with the specified prefix,_ignoring upper/lower case._@param str the String to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(String str, String prefix) {_		if (str == null || prefix == null) {_			return false__		}_		if (str.startsWith(prefix)) {_			return true__		}_		if (str.length() < prefix.length()) {_			return false__		}_		String lcStr = str.substring(0, prefix.length()).toLowerCase()__		String lcPrefix = prefix.toLowerCase()__		return lcStr.equals(lcPrefix)__	};test,if,the,given,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,string,str,string,prefix,if,str,null,prefix,null,return,false,if,str,starts,with,prefix,return,true,if,str,length,prefix,length,return,false,string,lc,str,str,substring,0,prefix,length,to,lower,case,string,lc,prefix,prefix,to,lower,case,return,lc,str,equals,lc,prefix
StringUtils -> public static boolean startsWithIgnoreCase(String str, String prefix);1337236962;Test if the given String starts with the specified prefix,_ignoring upper/lower case._@param str the String to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(String str, String prefix) {_		if (str == null || prefix == null) {_			return false__		}_		if (str.startsWith(prefix)) {_			return true__		}_		if (str.length() < prefix.length()) {_			return false__		}_		String lcStr = str.substring(0, prefix.length()).toLowerCase()__		String lcPrefix = prefix.toLowerCase()__		return lcStr.equals(lcPrefix)__	};test,if,the,given,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,string,str,string,prefix,if,str,null,prefix,null,return,false,if,str,starts,with,prefix,return,true,if,str,length,prefix,length,return,false,string,lc,str,str,substring,0,prefix,length,to,lower,case,string,lc,prefix,prefix,to,lower,case,return,lc,str,equals,lc,prefix
StringUtils -> public static boolean startsWithIgnoreCase(String str, String prefix);1356735495;Test if the given String starts with the specified prefix,_ignoring upper/lower case._@param str the String to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(String str, String prefix) {_		if (str == null || prefix == null) {_			return false__		}_		if (str.startsWith(prefix)) {_			return true__		}_		if (str.length() < prefix.length()) {_			return false__		}_		String lcStr = str.substring(0, prefix.length()).toLowerCase()__		String lcPrefix = prefix.toLowerCase()__		return lcStr.equals(lcPrefix)__	};test,if,the,given,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,string,str,string,prefix,if,str,null,prefix,null,return,false,if,str,starts,with,prefix,return,true,if,str,length,prefix,length,return,false,string,lc,str,str,substring,0,prefix,length,to,lower,case,string,lc,prefix,prefix,to,lower,case,return,lc,str,equals,lc,prefix
StringUtils -> public static boolean startsWithIgnoreCase(String str, String prefix);1367955086;Test if the given String starts with the specified prefix,_ignoring upper/lower case._@param str the String to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(String str, String prefix) {_		if (str == null || prefix == null) {_			return false__		}_		if (str.startsWith(prefix)) {_			return true__		}_		if (str.length() < prefix.length()) {_			return false__		}_		String lcStr = str.substring(0, prefix.length()).toLowerCase()__		String lcPrefix = prefix.toLowerCase()__		return lcStr.equals(lcPrefix)__	};test,if,the,given,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,string,str,string,prefix,if,str,null,prefix,null,return,false,if,str,starts,with,prefix,return,true,if,str,length,prefix,length,return,false,string,lc,str,str,substring,0,prefix,length,to,lower,case,string,lc,prefix,prefix,to,lower,case,return,lc,str,equals,lc,prefix
StringUtils -> public static boolean startsWithIgnoreCase(String str, String prefix);1380921248;Test if the given String starts with the specified prefix,_ignoring upper/lower case._@param str the String to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(String str, String prefix) {_		if (str == null || prefix == null) {_			return false__		}_		if (str.startsWith(prefix)) {_			return true__		}_		if (str.length() < prefix.length()) {_			return false__		}_		String lcStr = str.substring(0, prefix.length()).toLowerCase()__		String lcPrefix = prefix.toLowerCase()__		return lcStr.equals(lcPrefix)__	};test,if,the,given,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,string,str,string,prefix,if,str,null,prefix,null,return,false,if,str,starts,with,prefix,return,true,if,str,length,prefix,length,return,false,string,lc,str,str,substring,0,prefix,length,to,lower,case,string,lc,prefix,prefix,to,lower,case,return,lc,str,equals,lc,prefix
StringUtils -> public static boolean startsWithIgnoreCase(String str, String prefix);1382750743;Test if the given String starts with the specified prefix,_ignoring upper/lower case._@param str the String to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(String str, String prefix) {_		if (str == null || prefix == null) {_			return false__		}_		if (str.startsWith(prefix)) {_			return true__		}_		if (str.length() < prefix.length()) {_			return false__		}_		String lcStr = str.substring(0, prefix.length()).toLowerCase()__		String lcPrefix = prefix.toLowerCase()__		return lcStr.equals(lcPrefix)__	};test,if,the,given,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,string,str,string,prefix,if,str,null,prefix,null,return,false,if,str,starts,with,prefix,return,true,if,str,length,prefix,length,return,false,string,lc,str,str,substring,0,prefix,length,to,lower,case,string,lc,prefix,prefix,to,lower,case,return,lc,str,equals,lc,prefix
StringUtils -> public static boolean startsWithIgnoreCase(String str, String prefix);1385423968;Test if the given String starts with the specified prefix,_ignoring upper/lower case._@param str the String to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(String str, String prefix) {_		if (str == null || prefix == null) {_			return false__		}_		if (str.startsWith(prefix)) {_			return true__		}_		if (str.length() < prefix.length()) {_			return false__		}_		String lcStr = str.substring(0, prefix.length()).toLowerCase()__		String lcPrefix = prefix.toLowerCase()__		return lcStr.equals(lcPrefix)__	};test,if,the,given,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,string,str,string,prefix,if,str,null,prefix,null,return,false,if,str,starts,with,prefix,return,true,if,str,length,prefix,length,return,false,string,lc,str,str,substring,0,prefix,length,to,lower,case,string,lc,prefix,prefix,to,lower,case,return,lc,str,equals,lc,prefix
StringUtils -> public static boolean startsWithIgnoreCase(String str, String prefix);1400189212;Test if the given String starts with the specified prefix,_ignoring upper/lower case._@param str the String to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(String str, String prefix) {_		if (str == null || prefix == null) {_			return false__		}_		if (str.startsWith(prefix)) {_			return true__		}_		if (str.length() < prefix.length()) {_			return false__		}_		String lcStr = str.substring(0, prefix.length()).toLowerCase()__		String lcPrefix = prefix.toLowerCase()__		return lcStr.equals(lcPrefix)__	};test,if,the,given,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,string,str,string,prefix,if,str,null,prefix,null,return,false,if,str,starts,with,prefix,return,true,if,str,length,prefix,length,return,false,string,lc,str,str,substring,0,prefix,length,to,lower,case,string,lc,prefix,prefix,to,lower,case,return,lc,str,equals,lc,prefix
StringUtils -> public static boolean startsWithIgnoreCase(String str, String prefix);1400531359;Test if the given String starts with the specified prefix,_ignoring upper/lower case._@param str the String to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(String str, String prefix) {_		if (str == null || prefix == null) {_			return false__		}_		if (str.startsWith(prefix)) {_			return true__		}_		if (str.length() < prefix.length()) {_			return false__		}_		String lcStr = str.substring(0, prefix.length()).toLowerCase()__		String lcPrefix = prefix.toLowerCase()__		return lcStr.equals(lcPrefix)__	};test,if,the,given,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,string,str,string,prefix,if,str,null,prefix,null,return,false,if,str,starts,with,prefix,return,true,if,str,length,prefix,length,return,false,string,lc,str,str,substring,0,prefix,length,to,lower,case,string,lc,prefix,prefix,to,lower,case,return,lc,str,equals,lc,prefix
StringUtils -> public static boolean startsWithIgnoreCase(String str, String prefix);1402676350;Test if the given String starts with the specified prefix,_ignoring upper/lower case._@param str the String to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(String str, String prefix) {_		if (str == null || prefix == null) {_			return false__		}_		if (str.startsWith(prefix)) {_			return true__		}_		if (str.length() < prefix.length()) {_			return false__		}_		String lcStr = str.substring(0, prefix.length()).toLowerCase()__		String lcPrefix = prefix.toLowerCase()__		return lcStr.equals(lcPrefix)__	};test,if,the,given,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,string,str,string,prefix,if,str,null,prefix,null,return,false,if,str,starts,with,prefix,return,true,if,str,length,prefix,length,return,false,string,lc,str,str,substring,0,prefix,length,to,lower,case,string,lc,prefix,prefix,to,lower,case,return,lc,str,equals,lc,prefix
StringUtils -> public static boolean startsWithIgnoreCase(String str, String prefix);1426267150;Test if the given String starts with the specified prefix,_ignoring upper/lower case._@param str the String to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(String str, String prefix) {_		if (str == null || prefix == null) {_			return false__		}_		if (str.startsWith(prefix)) {_			return true__		}_		if (str.length() < prefix.length()) {_			return false__		}_		String lcStr = str.substring(0, prefix.length()).toLowerCase()__		String lcPrefix = prefix.toLowerCase()__		return lcStr.equals(lcPrefix)__	};test,if,the,given,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,string,str,string,prefix,if,str,null,prefix,null,return,false,if,str,starts,with,prefix,return,true,if,str,length,prefix,length,return,false,string,lc,str,str,substring,0,prefix,length,to,lower,case,string,lc,prefix,prefix,to,lower,case,return,lc,str,equals,lc,prefix
StringUtils -> public static boolean startsWithIgnoreCase(String str, String prefix);1429034538;Test if the given String starts with the specified prefix,_ignoring upper/lower case._@param str the String to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(String str, String prefix) {_		if (str == null || prefix == null) {_			return false__		}_		if (str.startsWith(prefix)) {_			return true__		}_		if (str.length() < prefix.length()) {_			return false__		}_		String lcStr = str.substring(0, prefix.length()).toLowerCase()__		String lcPrefix = prefix.toLowerCase()__		return lcStr.equals(lcPrefix)__	};test,if,the,given,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,string,str,string,prefix,if,str,null,prefix,null,return,false,if,str,starts,with,prefix,return,true,if,str,length,prefix,length,return,false,string,lc,str,str,substring,0,prefix,length,to,lower,case,string,lc,prefix,prefix,to,lower,case,return,lc,str,equals,lc,prefix
StringUtils -> public static boolean startsWithIgnoreCase(String str, String prefix);1429034756;Test if the given {@code String} starts with the specified prefix,_ignoring upper/lower case._@param str the {@code String} to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(String str, String prefix) {_		if (str == null || prefix == null) {_			return false__		}_		if (str.startsWith(prefix)) {_			return true__		}_		if (str.length() < prefix.length()) {_			return false__		}_		String lcStr = str.substring(0, prefix.length()).toLowerCase()__		String lcPrefix = prefix.toLowerCase()__		return lcStr.equals(lcPrefix)__	};test,if,the,given,code,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,string,str,string,prefix,if,str,null,prefix,null,return,false,if,str,starts,with,prefix,return,true,if,str,length,prefix,length,return,false,string,lc,str,str,substring,0,prefix,length,to,lower,case,string,lc,prefix,prefix,to,lower,case,return,lc,str,equals,lc,prefix
StringUtils -> public static boolean startsWithIgnoreCase(String str, String prefix);1431006895;Test if the given {@code String} starts with the specified prefix,_ignoring upper/lower case._@param str the {@code String} to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(String str, String prefix) {_		if (str == null || prefix == null) {_			return false__		}_		if (str.startsWith(prefix)) {_			return true__		}_		if (str.length() < prefix.length()) {_			return false__		}_		String lcStr = str.substring(0, prefix.length()).toLowerCase()__		String lcPrefix = prefix.toLowerCase()__		return lcStr.equals(lcPrefix)__	};test,if,the,given,code,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,string,str,string,prefix,if,str,null,prefix,null,return,false,if,str,starts,with,prefix,return,true,if,str,length,prefix,length,return,false,string,lc,str,str,substring,0,prefix,length,to,lower,case,string,lc,prefix,prefix,to,lower,case,return,lc,str,equals,lc,prefix
StringUtils -> public static boolean startsWithIgnoreCase(String str, String prefix);1431007368;Test if the given {@code String} starts with the specified prefix,_ignoring upper/lower case._@param str the {@code String} to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(String str, String prefix) {_		if (str == null || prefix == null) {_			return false__		}_		if (str.startsWith(prefix)) {_			return true__		}_		if (str.length() < prefix.length()) {_			return false__		}_		String lcStr = str.substring(0, prefix.length()).toLowerCase()__		String lcPrefix = prefix.toLowerCase()__		return lcStr.equals(lcPrefix)__	};test,if,the,given,code,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,string,str,string,prefix,if,str,null,prefix,null,return,false,if,str,starts,with,prefix,return,true,if,str,length,prefix,length,return,false,string,lc,str,str,substring,0,prefix,length,to,lower,case,string,lc,prefix,prefix,to,lower,case,return,lc,str,equals,lc,prefix
StringUtils -> public static boolean startsWithIgnoreCase(String str, String prefix);1449489126;Test if the given {@code String} starts with the specified prefix,_ignoring upper/lower case._@param str the {@code String} to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(String str, String prefix) {_		if (str == null || prefix == null) {_			return false__		}_		if (str.startsWith(prefix)) {_			return true__		}_		if (str.length() < prefix.length()) {_			return false__		}_		String lcStr = str.substring(0, prefix.length()).toLowerCase()__		String lcPrefix = prefix.toLowerCase()__		return lcStr.equals(lcPrefix)__	};test,if,the,given,code,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,string,str,string,prefix,if,str,null,prefix,null,return,false,if,str,starts,with,prefix,return,true,if,str,length,prefix,length,return,false,string,lc,str,str,substring,0,prefix,length,to,lower,case,string,lc,prefix,prefix,to,lower,case,return,lc,str,equals,lc,prefix
StringUtils -> public static boolean startsWithIgnoreCase(String str, String prefix);1467730834;Test if the given {@code String} starts with the specified prefix,_ignoring upper/lower case._@param str the {@code String} to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(String str, String prefix) {_		if (str == null || prefix == null) {_			return false__		}_		if (str.startsWith(prefix)) {_			return true__		}_		if (str.length() < prefix.length()) {_			return false__		}_		String lcStr = str.substring(0, prefix.length()).toLowerCase()__		String lcPrefix = prefix.toLowerCase()__		return lcStr.equals(lcPrefix)__	};test,if,the,given,code,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,string,str,string,prefix,if,str,null,prefix,null,return,false,if,str,starts,with,prefix,return,true,if,str,length,prefix,length,return,false,string,lc,str,str,substring,0,prefix,length,to,lower,case,string,lc,prefix,prefix,to,lower,case,return,lc,str,equals,lc,prefix
StringUtils -> public static boolean startsWithIgnoreCase(String str, String prefix);1472128018;Test if the given {@code String} starts with the specified prefix,_ignoring upper/lower case._@param str the {@code String} to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(String str, String prefix) {_		if (str == null || prefix == null) {_			return false__		}_		if (str.startsWith(prefix)) {_			return true__		}_		if (str.length() < prefix.length()) {_			return false__		}_		String lcStr = str.substring(0, prefix.length()).toLowerCase()__		String lcPrefix = prefix.toLowerCase()__		return lcStr.equals(lcPrefix)__	};test,if,the,given,code,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,string,str,string,prefix,if,str,null,prefix,null,return,false,if,str,starts,with,prefix,return,true,if,str,length,prefix,length,return,false,string,lc,str,str,substring,0,prefix,length,to,lower,case,string,lc,prefix,prefix,to,lower,case,return,lc,str,equals,lc,prefix
StringUtils -> public static boolean startsWithIgnoreCase(String str, String prefix);1472202842;Test if the given {@code String} starts with the specified prefix,_ignoring upper/lower case._@param str the {@code String} to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(String str, String prefix) {_		if (str == null || prefix == null) {_			return false__		}_		if (str.startsWith(prefix)) {_			return true__		}_		if (str.length() < prefix.length()) {_			return false__		}_		String lcStr = str.substring(0, prefix.length()).toLowerCase()__		String lcPrefix = prefix.toLowerCase()__		return lcStr.equals(lcPrefix)__	};test,if,the,given,code,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,string,str,string,prefix,if,str,null,prefix,null,return,false,if,str,starts,with,prefix,return,true,if,str,length,prefix,length,return,false,string,lc,str,str,substring,0,prefix,length,to,lower,case,string,lc,prefix,prefix,to,lower,case,return,lc,str,equals,lc,prefix
StringUtils -> public static boolean startsWithIgnoreCase(String str, String prefix);1473942665;Test if the given {@code String} starts with the specified prefix,_ignoring upper/lower case._@param str the {@code String} to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(String str, String prefix) {_		if (str == null || prefix == null) {_			return false__		}_		if (str.startsWith(prefix)) {_			return true__		}_		if (str.length() < prefix.length()) {_			return false__		}_		String lcStr = str.substring(0, prefix.length()).toLowerCase()__		String lcPrefix = prefix.toLowerCase()__		return lcStr.equals(lcPrefix)__	};test,if,the,given,code,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,string,str,string,prefix,if,str,null,prefix,null,return,false,if,str,starts,with,prefix,return,true,if,str,length,prefix,length,return,false,string,lc,str,str,substring,0,prefix,length,to,lower,case,string,lc,prefix,prefix,to,lower,case,return,lc,str,equals,lc,prefix
StringUtils -> public static boolean startsWithIgnoreCase(String str, String prefix);1484248946;Test if the given {@code String} starts with the specified prefix,_ignoring upper/lower case._@param str the {@code String} to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(String str, String prefix) {_		if (str == null || prefix == null) {_			return false__		}_		if (str.startsWith(prefix)) {_			return true__		}_		if (str.length() < prefix.length()) {_			return false__		}_		String lcStr = str.substring(0, prefix.length()).toLowerCase()__		String lcPrefix = prefix.toLowerCase()__		return lcStr.equals(lcPrefix)__	};test,if,the,given,code,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,string,str,string,prefix,if,str,null,prefix,null,return,false,if,str,starts,with,prefix,return,true,if,str,length,prefix,length,return,false,string,lc,str,str,substring,0,prefix,length,to,lower,case,string,lc,prefix,prefix,to,lower,case,return,lc,str,equals,lc,prefix
StringUtils -> public static boolean startsWithIgnoreCase(String str, String prefix);1484260238;Test if the given {@code String} starts with the specified prefix,_ignoring upper/lower case._@param str the {@code String} to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(String str, String prefix) {_		if (str == null || prefix == null) {_			return false__		}_		if (str.startsWith(prefix)) {_			return true__		}_		if (str.length() < prefix.length()) {_			return false__		}_		String lcStr = str.substring(0, prefix.length()).toLowerCase()__		String lcPrefix = prefix.toLowerCase()__		return lcStr.equals(lcPrefix)__	};test,if,the,given,code,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,string,str,string,prefix,if,str,null,prefix,null,return,false,if,str,starts,with,prefix,return,true,if,str,length,prefix,length,return,false,string,lc,str,str,substring,0,prefix,length,to,lower,case,string,lc,prefix,prefix,to,lower,case,return,lc,str,equals,lc,prefix
StringUtils -> public static boolean startsWithIgnoreCase(String str, String prefix);1484694546;Test if the given {@code String} starts with the specified prefix,_ignoring upper/lower case._@param str the {@code String} to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(String str, String prefix) {_		if (str == null || prefix == null) {_			return false__		}_		if (str.startsWith(prefix)) {_			return true__		}_		if (str.length() < prefix.length()) {_			return false__		}_		String lcStr = str.substring(0, prefix.length()).toLowerCase()__		String lcPrefix = prefix.toLowerCase()__		return lcStr.equals(lcPrefix)__	};test,if,the,given,code,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,string,str,string,prefix,if,str,null,prefix,null,return,false,if,str,starts,with,prefix,return,true,if,str,length,prefix,length,return,false,string,lc,str,str,substring,0,prefix,length,to,lower,case,string,lc,prefix,prefix,to,lower,case,return,lc,str,equals,lc,prefix
StringUtils -> public static boolean startsWithIgnoreCase(String str, String prefix);1487760984;Test if the given {@code String} starts with the specified prefix,_ignoring upper/lower case._@param str the {@code String} to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(String str, String prefix) {_		if (str == null || prefix == null) {_			return false__		}_		if (str.startsWith(prefix)) {_			return true__		}_		if (str.length() < prefix.length()) {_			return false__		}_		String lcStr = str.substring(0, prefix.length()).toLowerCase()__		String lcPrefix = prefix.toLowerCase()__		return lcStr.equals(lcPrefix)__	};test,if,the,given,code,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,string,str,string,prefix,if,str,null,prefix,null,return,false,if,str,starts,with,prefix,return,true,if,str,length,prefix,length,return,false,string,lc,str,str,substring,0,prefix,length,to,lower,case,string,lc,prefix,prefix,to,lower,case,return,lc,str,equals,lc,prefix
StringUtils -> public static boolean startsWithIgnoreCase(String str, String prefix);1487778834;Test if the given {@code String} starts with the specified prefix,_ignoring upper/lower case._@param str the {@code String} to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(String str, String prefix) {_		if (str == null || prefix == null) {_			return false__		}_		if (str.startsWith(prefix)) {_			return true__		}_		if (str.length() < prefix.length()) {_			return false__		}_		String lcStr = str.substring(0, prefix.length()).toLowerCase()__		String lcPrefix = prefix.toLowerCase()__		return lcStr.equals(lcPrefix)__	};test,if,the,given,code,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,string,str,string,prefix,if,str,null,prefix,null,return,false,if,str,starts,with,prefix,return,true,if,str,length,prefix,length,return,false,string,lc,str,str,substring,0,prefix,length,to,lower,case,string,lc,prefix,prefix,to,lower,case,return,lc,str,equals,lc,prefix
StringUtils -> public static boolean startsWithIgnoreCase(String str, String prefix);1491898314;Test if the given {@code String} starts with the specified prefix,_ignoring upper/lower case._@param str the {@code String} to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(String str, String prefix) {_		if (str == null || prefix == null) {_			return false__		}_		if (str.startsWith(prefix)) {_			return true__		}_		if (str.length() < prefix.length()) {_			return false__		}__		String lcStr = str.substring(0, prefix.length()).toLowerCase()__		String lcPrefix = prefix.toLowerCase()__		return lcStr.equals(lcPrefix)__	};test,if,the,given,code,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,string,str,string,prefix,if,str,null,prefix,null,return,false,if,str,starts,with,prefix,return,true,if,str,length,prefix,length,return,false,string,lc,str,str,substring,0,prefix,length,to,lower,case,string,lc,prefix,prefix,to,lower,case,return,lc,str,equals,lc,prefix
StringUtils -> public static boolean startsWithIgnoreCase(String str, String prefix);1491903650;Test if the given {@code String} starts with the specified prefix,_ignoring upper/lower case._@param str the {@code String} to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(String str, String prefix) {_		if (str == null || prefix == null) {_			return false__		}_		if (str.startsWith(prefix)) {_			return true__		}_		if (str.length() < prefix.length()) {_			return false__		}__		String lcStr = str.substring(0, prefix.length()).toLowerCase()__		String lcPrefix = prefix.toLowerCase()__		return lcStr.equals(lcPrefix)__	};test,if,the,given,code,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,string,str,string,prefix,if,str,null,prefix,null,return,false,if,str,starts,with,prefix,return,true,if,str,length,prefix,length,return,false,string,lc,str,str,substring,0,prefix,length,to,lower,case,string,lc,prefix,prefix,to,lower,case,return,lc,str,equals,lc,prefix
StringUtils -> public static boolean startsWithIgnoreCase(String str, String prefix);1495868221;Test if the given {@code String} starts with the specified prefix,_ignoring upper/lower case._@param str the {@code String} to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(String str, String prefix) {_		if (str == null || prefix == null) {_			return false__		}_		if (str.startsWith(prefix)) {_			return true__		}_		if (str.length() < prefix.length()) {_			return false__		}__		String lcStr = str.substring(0, prefix.length()).toLowerCase()__		String lcPrefix = prefix.toLowerCase()__		return lcStr.equals(lcPrefix)__	};test,if,the,given,code,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,string,str,string,prefix,if,str,null,prefix,null,return,false,if,str,starts,with,prefix,return,true,if,str,length,prefix,length,return,false,string,lc,str,str,substring,0,prefix,length,to,lower,case,string,lc,prefix,prefix,to,lower,case,return,lc,str,equals,lc,prefix
StringUtils -> public static boolean startsWithIgnoreCase(String str, String prefix);1496243689;Test if the given {@code String} starts with the specified prefix,_ignoring upper/lower case._@param str the {@code String} to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(String str, String prefix) {_		if (str == null || prefix == null) {_			return false__		}_		if (str.startsWith(prefix)) {_			return true__		}_		if (str.length() < prefix.length()) {_			return false__		}__		String lcStr = str.substring(0, prefix.length()).toLowerCase()__		String lcPrefix = prefix.toLowerCase()__		return lcStr.equals(lcPrefix)__	};test,if,the,given,code,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,string,str,string,prefix,if,str,null,prefix,null,return,false,if,str,starts,with,prefix,return,true,if,str,length,prefix,length,return,false,string,lc,str,str,substring,0,prefix,length,to,lower,case,string,lc,prefix,prefix,to,lower,case,return,lc,str,equals,lc,prefix
StringUtils -> public static boolean startsWithIgnoreCase(String str, String prefix);1496259743;Test if the given {@code String} starts with the specified prefix,_ignoring upper/lower case._@param str the {@code String} to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(String str, String prefix) {_		if (str == null || prefix == null) {_			return false__		}_		if (str.startsWith(prefix)) {_			return true__		}_		if (str.length() < prefix.length()) {_			return false__		}__		String lcStr = str.substring(0, prefix.length()).toLowerCase()__		String lcPrefix = prefix.toLowerCase()__		return lcStr.equals(lcPrefix)__	};test,if,the,given,code,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,string,str,string,prefix,if,str,null,prefix,null,return,false,if,str,starts,with,prefix,return,true,if,str,length,prefix,length,return,false,string,lc,str,str,substring,0,prefix,length,to,lower,case,string,lc,prefix,prefix,to,lower,case,return,lc,str,equals,lc,prefix
StringUtils -> public static boolean hasLength(@Nullable CharSequence str);1495868221;Check that the given {@code CharSequence} is neither {@code null} nor_of length 0._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(String);public static boolean hasLength(@Nullable CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,code,char,sequence,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,string;public,static,boolean,has,length,nullable,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(@Nullable CharSequence str);1496243689;Check that the given {@code CharSequence} is neither {@code null} nor_of length 0._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(String);public static boolean hasLength(@Nullable CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,code,char,sequence,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,string;public,static,boolean,has,length,nullable,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(@Nullable CharSequence str);1496259743;Check that the given {@code CharSequence} is neither {@code null} nor_of length 0._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(String);public static boolean hasLength(@Nullable CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,code,char,sequence,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,string;public,static,boolean,has,length,nullable,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(@Nullable CharSequence str);1496837955;Check that the given {@code CharSequence} is neither {@code null} nor_of length 0._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(String);public static boolean hasLength(@Nullable CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,code,char,sequence,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,string;public,static,boolean,has,length,nullable,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(@Nullable CharSequence str);1499270197;Check that the given {@code CharSequence} is neither {@code null} nor_of length 0._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(String);public static boolean hasLength(@Nullable CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,code,char,sequence,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,string;public,static,boolean,has,length,nullable,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(@Nullable CharSequence str);1508667152;Check that the given {@code CharSequence} is neither {@code null} nor_of length 0._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(String);public static boolean hasLength(@Nullable CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,code,char,sequence,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,string;public,static,boolean,has,length,nullable,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(@Nullable CharSequence str);1508675477;Check that the given {@code CharSequence} is neither {@code null} nor_of length 0._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(String);public static boolean hasLength(@Nullable CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,code,char,sequence,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,string;public,static,boolean,has,length,nullable,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(@Nullable CharSequence str);1508843807;Check that the given {@code CharSequence} is neither {@code null} nor_of length 0._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(String);public static boolean hasLength(@Nullable CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,code,char,sequence,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,string;public,static,boolean,has,length,nullable,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(@Nullable CharSequence str);1516903831;Check that the given {@code CharSequence} is neither {@code null} nor_of length 0._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(String);public static boolean hasLength(@Nullable CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,code,char,sequence,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,string;public,static,boolean,has,length,nullable,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(@Nullable CharSequence str);1519295386;Check that the given {@code CharSequence} is neither {@code null} nor_of length 0._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(String);public static boolean hasLength(@Nullable CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,code,char,sequence,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,string;public,static,boolean,has,length,nullable,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(@Nullable CharSequence str);1519308837;Check that the given {@code CharSequence} is neither {@code null} nor_of length 0._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(String);public static boolean hasLength(@Nullable CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,code,char,sequence,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,string;public,static,boolean,has,length,nullable,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(@Nullable CharSequence str);1519588127;Check that the given {@code CharSequence} is neither {@code null} nor_of length 0._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(String);public static boolean hasLength(@Nullable CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,code,char,sequence,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,string;public,static,boolean,has,length,nullable,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(@Nullable CharSequence str);1522332352;Check that the given {@code CharSequence} is neither {@code null} nor_of length 0._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(String);public static boolean hasLength(@Nullable CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,code,char,sequence,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,string;public,static,boolean,has,length,nullable,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(@Nullable CharSequence str);1525166194;Check that the given {@code CharSequence} is neither {@code null} nor_of length 0._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(String);public static boolean hasLength(@Nullable CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,code,char,sequence,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,string;public,static,boolean,has,length,nullable,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(@Nullable CharSequence str);1530188116;Check that the given {@code CharSequence} is neither {@code null} nor_of length 0._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(String);public static boolean hasLength(@Nullable CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,code,char,sequence,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,string;public,static,boolean,has,length,nullable,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(@Nullable CharSequence str);1531843079;Check that the given {@code CharSequence} is neither {@code null} nor_of length 0._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(String);public static boolean hasLength(@Nullable CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,code,char,sequence,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,string;public,static,boolean,has,length,nullable,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(@Nullable CharSequence str);1531905026;Check that the given {@code CharSequence} is neither {@code null} nor_of length 0._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(String);public static boolean hasLength(@Nullable CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,code,char,sequence,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,string;public,static,boolean,has,length,nullable,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(@Nullable CharSequence str);1533557519;Check that the given {@code CharSequence} is neither {@code null} nor_of length 0._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(String);public static boolean hasLength(@Nullable CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,code,char,sequence,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,string;public,static,boolean,has,length,nullable,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(@Nullable CharSequence str);1533602820;Check that the given {@code CharSequence} is neither {@code null} nor_of length 0._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(String);public static boolean hasLength(@Nullable CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,code,char,sequence,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,string;public,static,boolean,has,length,nullable,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(@Nullable CharSequence str);1535316501;Check that the given {@code CharSequence} is neither {@code null} nor_of length 0._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(String);public static boolean hasLength(@Nullable CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,code,char,sequence,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,string;public,static,boolean,has,length,nullable,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(@Nullable CharSequence str);1550237113;Check that the given {@code CharSequence} is neither {@code null} nor_of length 0._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(String);public static boolean hasLength(@Nullable CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,code,char,sequence,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,string;public,static,boolean,has,length,nullable,char,sequence,str,return,str,null,str,length,0
StringUtils -> public static boolean hasLength(@Nullable CharSequence str);1550238935;Check that the given {@code CharSequence} is neither {@code null} nor_of length 0._<p>Note: this method returns {@code true} for a {@code CharSequence}_that purely consists of whitespace._<p><pre class="code">_StringUtils.hasLength(null) = false_StringUtils.hasLength("") = false_StringUtils.hasLength(" ") = true_StringUtils.hasLength("Hello") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null} and has length_@see #hasText(String);public static boolean hasLength(@Nullable CharSequence str) {_		return (str != null && str.length() > 0)__	};check,that,the,given,code,char,sequence,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,char,sequence,that,purely,consists,of,whitespace,p,pre,class,code,string,utils,has,length,null,false,string,utils,has,length,false,string,utils,has,length,true,string,utils,has,length,hello,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,and,has,length,see,has,text,string;public,static,boolean,has,length,nullable,char,sequence,str,return,str,null,str,length,0
StringUtils -> @Nullable 	public static String getFilenameExtension(@Nullable String path);1495868221;Extract the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;@Nullable_	public static String getFilenameExtension(@Nullable String path) {_		if (path == null) {_			return null__		}__		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}__		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;nullable,public,static,string,get,filename,extension,nullable,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> @Nullable 	public static String getFilenameExtension(@Nullable String path);1496243689;Extract the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;@Nullable_	public static String getFilenameExtension(@Nullable String path) {_		if (path == null) {_			return null__		}__		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}__		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;nullable,public,static,string,get,filename,extension,nullable,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> @Nullable 	public static String getFilenameExtension(@Nullable String path);1496259743;Extract the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;@Nullable_	public static String getFilenameExtension(@Nullable String path) {_		if (path == null) {_			return null__		}__		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}__		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;nullable,public,static,string,get,filename,extension,nullable,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> @Nullable 	public static String getFilenameExtension(@Nullable String path);1496837955;Extract the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;@Nullable_	public static String getFilenameExtension(@Nullable String path) {_		if (path == null) {_			return null__		}__		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}__		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;nullable,public,static,string,get,filename,extension,nullable,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> @Nullable 	public static String getFilenameExtension(@Nullable String path);1499270197;Extract the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;@Nullable_	public static String getFilenameExtension(@Nullable String path) {_		if (path == null) {_			return null__		}__		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}__		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;nullable,public,static,string,get,filename,extension,nullable,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> @Nullable 	public static String getFilenameExtension(@Nullable String path);1508667152;Extract the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;@Nullable_	public static String getFilenameExtension(@Nullable String path) {_		if (path == null) {_			return null__		}__		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}__		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;nullable,public,static,string,get,filename,extension,nullable,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> @Nullable 	public static String getFilenameExtension(@Nullable String path);1508675477;Extract the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;@Nullable_	public static String getFilenameExtension(@Nullable String path) {_		if (path == null) {_			return null__		}__		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}__		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;nullable,public,static,string,get,filename,extension,nullable,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> @Nullable 	public static String getFilenameExtension(@Nullable String path);1508843807;Extract the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;@Nullable_	public static String getFilenameExtension(@Nullable String path) {_		if (path == null) {_			return null__		}__		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}__		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;nullable,public,static,string,get,filename,extension,nullable,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> @Nullable 	public static String getFilenameExtension(@Nullable String path);1516903831;Extract the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;@Nullable_	public static String getFilenameExtension(@Nullable String path) {_		if (path == null) {_			return null__		}__		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}__		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;nullable,public,static,string,get,filename,extension,nullable,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> @Nullable 	public static String getFilenameExtension(@Nullable String path);1519295386;Extract the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;@Nullable_	public static String getFilenameExtension(@Nullable String path) {_		if (path == null) {_			return null__		}__		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}__		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;nullable,public,static,string,get,filename,extension,nullable,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> @Nullable 	public static String getFilenameExtension(@Nullable String path);1519308837;Extract the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;@Nullable_	public static String getFilenameExtension(@Nullable String path) {_		if (path == null) {_			return null__		}__		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}__		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;nullable,public,static,string,get,filename,extension,nullable,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> @Nullable 	public static String getFilenameExtension(@Nullable String path);1519588127;Extract the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;@Nullable_	public static String getFilenameExtension(@Nullable String path) {_		if (path == null) {_			return null__		}__		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}__		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;nullable,public,static,string,get,filename,extension,nullable,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> @Nullable 	public static String getFilenameExtension(@Nullable String path);1522332352;Extract the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;@Nullable_	public static String getFilenameExtension(@Nullable String path) {_		if (path == null) {_			return null__		}__		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}__		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;nullable,public,static,string,get,filename,extension,nullable,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> @Nullable 	public static String getFilenameExtension(@Nullable String path);1525166194;Extract the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;@Nullable_	public static String getFilenameExtension(@Nullable String path) {_		if (path == null) {_			return null__		}__		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}__		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;nullable,public,static,string,get,filename,extension,nullable,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> @Nullable 	public static String getFilenameExtension(@Nullable String path);1530188116;Extract the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;@Nullable_	public static String getFilenameExtension(@Nullable String path) {_		if (path == null) {_			return null__		}__		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}__		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;nullable,public,static,string,get,filename,extension,nullable,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> @Nullable 	public static String getFilenameExtension(@Nullable String path);1531843079;Extract the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;@Nullable_	public static String getFilenameExtension(@Nullable String path) {_		if (path == null) {_			return null__		}__		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}__		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;nullable,public,static,string,get,filename,extension,nullable,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> @Nullable 	public static String getFilenameExtension(@Nullable String path);1531905026;Extract the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;@Nullable_	public static String getFilenameExtension(@Nullable String path) {_		if (path == null) {_			return null__		}__		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}__		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;nullable,public,static,string,get,filename,extension,nullable,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> @Nullable 	public static String getFilenameExtension(@Nullable String path);1533557519;Extract the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;@Nullable_	public static String getFilenameExtension(@Nullable String path) {_		if (path == null) {_			return null__		}__		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}__		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;nullable,public,static,string,get,filename,extension,nullable,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> @Nullable 	public static String getFilenameExtension(@Nullable String path);1533602820;Extract the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;@Nullable_	public static String getFilenameExtension(@Nullable String path) {_		if (path == null) {_			return null__		}__		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}__		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;nullable,public,static,string,get,filename,extension,nullable,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> @Nullable 	public static String getFilenameExtension(@Nullable String path);1535316501;Extract the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;@Nullable_	public static String getFilenameExtension(@Nullable String path) {_		if (path == null) {_			return null__		}__		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}__		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;nullable,public,static,string,get,filename,extension,nullable,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> @Nullable 	public static String getFilenameExtension(@Nullable String path);1550237113;Extract the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;@Nullable_	public static String getFilenameExtension(@Nullable String path) {_		if (path == null) {_			return null__		}__		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}__		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;nullable,public,static,string,get,filename,extension,nullable,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> @Nullable 	public static String getFilenameExtension(@Nullable String path);1550238935;Extract the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;@Nullable_	public static String getFilenameExtension(@Nullable String path) {_		if (path == null) {_			return null__		}__		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}__		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;nullable,public,static,string,get,filename,extension,nullable,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete);1328020251;Take a String which is a delimited list and convert it to a String array._<p>A single delimiter can consists of more than one character: It will still_be considered as single delimiter string, rather than as bunch of potential_delimiter characters - in contrast to <code>tokenizeToStringArray</code>._@param str the input String_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete. Useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a String._@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {_		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}_		List<String> result = new ArrayList<String>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,string,which,is,a,delimited,list,and,convert,it,to,a,string,array,p,a,single,delimiter,can,consists,of,more,than,one,character,it,will,still,be,considered,as,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,code,tokenize,to,string,array,code,param,str,the,input,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,string,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete);1337236962;Take a String which is a delimited list and convert it to a String array._<p>A single delimiter can consists of more than one character: It will still_be considered as single delimiter string, rather than as bunch of potential_delimiter characters - in contrast to <code>tokenizeToStringArray</code>._@param str the input String_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete. Useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a String._@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {_		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}_		List<String> result = new ArrayList<String>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,string,which,is,a,delimited,list,and,convert,it,to,a,string,array,p,a,single,delimiter,can,consists,of,more,than,one,character,it,will,still,be,considered,as,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,code,tokenize,to,string,array,code,param,str,the,input,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,string,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete);1356735495;Take a String which is a delimited list and convert it to a String array._<p>A single delimiter can consists of more than one character: It will still_be considered as single delimiter string, rather than as bunch of potential_delimiter characters - in contrast to {@code tokenizeToStringArray}._@param str the input String_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete. Useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a String._@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {_		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}_		List<String> result = new ArrayList<String>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,string,which,is,a,delimited,list,and,convert,it,to,a,string,array,p,a,single,delimiter,can,consists,of,more,than,one,character,it,will,still,be,considered,as,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,code,tokenize,to,string,array,param,str,the,input,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,string,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete);1367955086;Take a String which is a delimited list and convert it to a String array._<p>A single delimiter can consists of more than one character: It will still_be considered as single delimiter string, rather than as bunch of potential_delimiter characters - in contrast to {@code tokenizeToStringArray}._@param str the input String_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete. Useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a String._@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {_		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}_		List<String> result = new ArrayList<String>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,string,which,is,a,delimited,list,and,convert,it,to,a,string,array,p,a,single,delimiter,can,consists,of,more,than,one,character,it,will,still,be,considered,as,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,code,tokenize,to,string,array,param,str,the,input,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,string,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete);1380921248;Take a String which is a delimited list and convert it to a String array._<p>A single delimiter can consists of more than one character: It will still_be considered as single delimiter string, rather than as bunch of potential_delimiter characters - in contrast to {@code tokenizeToStringArray}._@param str the input String_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete. Useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a String._@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {_		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}_		List<String> result = new ArrayList<String>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,string,which,is,a,delimited,list,and,convert,it,to,a,string,array,p,a,single,delimiter,can,consists,of,more,than,one,character,it,will,still,be,considered,as,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,code,tokenize,to,string,array,param,str,the,input,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,string,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete);1382750743;Take a String which is a delimited list and convert it to a String array._<p>A single delimiter can consists of more than one character: It will still_be considered as single delimiter string, rather than as bunch of potential_delimiter characters - in contrast to {@code tokenizeToStringArray}._@param str the input String_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete. Useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a String._@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {_		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}_		List<String> result = new ArrayList<String>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,string,which,is,a,delimited,list,and,convert,it,to,a,string,array,p,a,single,delimiter,can,consists,of,more,than,one,character,it,will,still,be,considered,as,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,code,tokenize,to,string,array,param,str,the,input,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,string,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete);1385423968;Take a String which is a delimited list and convert it to a String array._<p>A single delimiter can consists of more than one character: It will still_be considered as single delimiter string, rather than as bunch of potential_delimiter characters - in contrast to {@code tokenizeToStringArray}._@param str the input String_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete. Useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a String._@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {_		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}_		List<String> result = new ArrayList<String>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,string,which,is,a,delimited,list,and,convert,it,to,a,string,array,p,a,single,delimiter,can,consists,of,more,than,one,character,it,will,still,be,considered,as,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,code,tokenize,to,string,array,param,str,the,input,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,string,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete);1400189212;Take a String which is a delimited list and convert it to a String array._<p>A single delimiter can consists of more than one character: It will still_be considered as single delimiter string, rather than as bunch of potential_delimiter characters - in contrast to {@code tokenizeToStringArray}._@param str the input String_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete. Useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a String._@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {_		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}_		List<String> result = new ArrayList<String>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,string,which,is,a,delimited,list,and,convert,it,to,a,string,array,p,a,single,delimiter,can,consists,of,more,than,one,character,it,will,still,be,considered,as,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,code,tokenize,to,string,array,param,str,the,input,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,string,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete);1400531359;Take a String which is a delimited list and convert it to a String array._<p>A single delimiter can consists of more than one character: It will still_be considered as single delimiter string, rather than as bunch of potential_delimiter characters - in contrast to {@code tokenizeToStringArray}._@param str the input String_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete. Useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a String._@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {_		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}_		List<String> result = new ArrayList<String>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,string,which,is,a,delimited,list,and,convert,it,to,a,string,array,p,a,single,delimiter,can,consists,of,more,than,one,character,it,will,still,be,considered,as,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,code,tokenize,to,string,array,param,str,the,input,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,string,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete);1402676350;Take a String which is a delimited list and convert it to a String array._<p>A single delimiter can consists of more than one character: It will still_be considered as single delimiter string, rather than as bunch of potential_delimiter characters - in contrast to {@code tokenizeToStringArray}._@param str the input String_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete. Useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a String._@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {_		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}_		List<String> result = new ArrayList<String>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,string,which,is,a,delimited,list,and,convert,it,to,a,string,array,p,a,single,delimiter,can,consists,of,more,than,one,character,it,will,still,be,considered,as,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,code,tokenize,to,string,array,param,str,the,input,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,string,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete);1426267150;Take a String which is a delimited list and convert it to a String array._<p>A single delimiter can consists of more than one character: It will still_be considered as single delimiter string, rather than as bunch of potential_delimiter characters - in contrast to {@code tokenizeToStringArray}._@param str the input String_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete. Useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a String._@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {_		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}_		List<String> result = new ArrayList<String>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,string,which,is,a,delimited,list,and,convert,it,to,a,string,array,p,a,single,delimiter,can,consists,of,more,than,one,character,it,will,still,be,considered,as,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,code,tokenize,to,string,array,param,str,the,input,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,string,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete);1429034538;Take a String which is a delimited list and convert it to a String array._<p>A single delimiter can consists of more than one character: It will still_be considered as single delimiter string, rather than as bunch of potential_delimiter characters - in contrast to {@code tokenizeToStringArray}._@param str the input String_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete. Useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a String._@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {_		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}_		List<String> result = new ArrayList<String>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,string,which,is,a,delimited,list,and,convert,it,to,a,string,array,p,a,single,delimiter,can,consists,of,more,than,one,character,it,will,still,be,considered,as,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,code,tokenize,to,string,array,param,str,the,input,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,string,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete);1429034756;Take a {@code String} that is a delimited list and convert it into_a {@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete_ useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a {@code String}_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {_		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}_		List<String> result = new ArrayList<String>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,code,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,string,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete);1431006895;Take a {@code String} that is a delimited list and convert it into_a {@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete_ useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a {@code String}_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {_		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}_		List<String> result = new ArrayList<String>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,code,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,string,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete);1431007368;Take a {@code String} that is a delimited list and convert it into_a {@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete_ useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a {@code String}_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {_		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}_		List<String> result = new ArrayList<String>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,code,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,string,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete);1449489126;Take a {@code String} that is a delimited list and convert it into_a {@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete_ useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a {@code String}_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {_		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}_		List<String> result = new ArrayList<String>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,code,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,string,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete);1467730834;Take a {@code String} that is a delimited list and convert it into_a {@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete_ useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a {@code String}_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {_		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}_		List<String> result = new ArrayList<>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,code,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete);1472128018;Take a {@code String} that is a delimited list and convert it into_a {@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete_ useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a {@code String}_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {_		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}_		List<String> result = new ArrayList<>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,code,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete);1472202842;Take a {@code String} that is a delimited list and convert it into_a {@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete_ useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a {@code String}_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {_		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}_		List<String> result = new ArrayList<>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,code,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete);1473942665;Take a {@code String} that is a delimited list and convert it into_a {@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete_ useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a {@code String}_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {_		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}_		List<String> result = new ArrayList<>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,code,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete);1484248946;Take a {@code String} that is a delimited list and convert it into_a {@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete_ useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a {@code String}_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {_		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}_		List<String> result = new ArrayList<>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,code,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete);1484260238;Take a {@code String} that is a delimited list and convert it into_a {@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete_ useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a {@code String}_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {_		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}_		List<String> result = new ArrayList<>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,code,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete);1484694546;Take a {@code String} that is a delimited list and convert it into_a {@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete_ useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a {@code String}_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {_		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}_		List<String> result = new ArrayList<>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,code,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete);1487760984;Take a {@code String} that is a delimited list and convert it into_a {@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete_ useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a {@code String}_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {_		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}_		List<String> result = new ArrayList<>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,code,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete);1487778834;Take a {@code String} that is a delimited list and convert it into_a {@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete_ useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a {@code String}_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {_		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}_		List<String> result = new ArrayList<>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,code,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete);1491898314;Take a {@code String} that is a delimited list and convert it into_a {@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete_ useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a {@code String}_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {_		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}__		List<String> result = new ArrayList<>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,code,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete);1491903650;Take a {@code String} that is a delimited list and convert it into_a {@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete_ useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a {@code String}_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {_		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}__		List<String> result = new ArrayList<>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,code,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete);1495868221;Take a {@code String} that is a delimited list and convert it into_a {@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete_ useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a {@code String}_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {_		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}__		List<String> result = new ArrayList<>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,code,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete);1496243689;Take a {@code String} that is a delimited list and convert it into_a {@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete_ useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a {@code String}_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {_		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}__		List<String> result = new ArrayList<>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,code,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] tokenizeToStringArray( 			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1328020251;Tokenize the given String into a String array via a StringTokenizer._<p>The given delimiters string is supposed to consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using <code>delimitedListToStringArray</code>_@param str the String to tokenize_@param delimiters the delimiter characters, assembled as String_(each of those characters is individually considered as delimiter)_@param trimTokens trim the tokens via String's <code>trim</code>_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens (<code>null</code> if the input String_was <code>null</code>)_@see java.util.StringTokenizer_@see java.lang.String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return null__		}_		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<String>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,string,into,a,string,array,via,a,string,tokenizer,p,the,given,delimiters,string,is,supposed,to,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,code,delimited,list,to,string,array,code,param,str,the,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,string,each,of,those,characters,is,individually,considered,as,delimiter,param,trim,tokens,trim,the,tokens,via,string,s,code,trim,code,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,code,null,code,if,the,input,string,was,code,null,code,see,java,util,string,tokenizer,see,java,lang,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,null,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,string,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1337236962;Tokenize the given String into a String array via a StringTokenizer._<p>The given delimiters string is supposed to consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using <code>delimitedListToStringArray</code>_@param str the String to tokenize_@param delimiters the delimiter characters, assembled as String_(each of those characters is individually considered as delimiter)_@param trimTokens trim the tokens via String's <code>trim</code>_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens (<code>null</code> if the input String_was <code>null</code>)_@see java.util.StringTokenizer_@see java.lang.String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return null__		}_		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<String>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,string,into,a,string,array,via,a,string,tokenizer,p,the,given,delimiters,string,is,supposed,to,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,code,delimited,list,to,string,array,code,param,str,the,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,string,each,of,those,characters,is,individually,considered,as,delimiter,param,trim,tokens,trim,the,tokens,via,string,s,code,trim,code,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,code,null,code,if,the,input,string,was,code,null,code,see,java,util,string,tokenizer,see,java,lang,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,null,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,string,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1356735495;Tokenize the given String into a String array via a StringTokenizer._<p>The given delimiters string is supposed to consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@code delimitedListToStringArray}_@param str the String to tokenize_@param delimiters the delimiter characters, assembled as String_(each of those characters is individually considered as delimiter)_@param trimTokens trim the tokens via String's {@code trim}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens ({@code null} if the input String_was {@code null})_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return null__		}_		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<String>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,string,into,a,string,array,via,a,string,tokenizer,p,the,given,delimiters,string,is,supposed,to,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,code,delimited,list,to,string,array,param,str,the,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,string,each,of,those,characters,is,individually,considered,as,delimiter,param,trim,tokens,trim,the,tokens,via,string,s,code,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,code,null,if,the,input,string,was,code,null,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,null,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,string,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1367955086;Tokenize the given String into a String array via a StringTokenizer._<p>The given delimiters string is supposed to consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@code delimitedListToStringArray}_@param str the String to tokenize_@param delimiters the delimiter characters, assembled as String_(each of those characters is individually considered as delimiter)_@param trimTokens trim the tokens via String's {@code trim}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens ({@code null} if the input String_was {@code null})_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return null__		}_		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<String>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,string,into,a,string,array,via,a,string,tokenizer,p,the,given,delimiters,string,is,supposed,to,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,code,delimited,list,to,string,array,param,str,the,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,string,each,of,those,characters,is,individually,considered,as,delimiter,param,trim,tokens,trim,the,tokens,via,string,s,code,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,code,null,if,the,input,string,was,code,null,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,null,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,string,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1380921248;Tokenize the given String into a String array via a StringTokenizer._<p>The given delimiters string is supposed to consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@code delimitedListToStringArray}_@param str the String to tokenize_@param delimiters the delimiter characters, assembled as String_(each of those characters is individually considered as delimiter)_@param trimTokens trim the tokens via String's {@code trim}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens ({@code null} if the input String_was {@code null})_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return null__		}_		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<String>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,string,into,a,string,array,via,a,string,tokenizer,p,the,given,delimiters,string,is,supposed,to,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,code,delimited,list,to,string,array,param,str,the,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,string,each,of,those,characters,is,individually,considered,as,delimiter,param,trim,tokens,trim,the,tokens,via,string,s,code,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,code,null,if,the,input,string,was,code,null,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,null,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,string,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1382750743;Tokenize the given String into a String array via a StringTokenizer._<p>The given delimiters string is supposed to consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@code delimitedListToStringArray}_@param str the String to tokenize_@param delimiters the delimiter characters, assembled as String_(each of those characters is individually considered as delimiter)_@param trimTokens trim the tokens via String's {@code trim}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens ({@code null} if the input String_was {@code null})_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return null__		}_		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<String>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,string,into,a,string,array,via,a,string,tokenizer,p,the,given,delimiters,string,is,supposed,to,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,code,delimited,list,to,string,array,param,str,the,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,string,each,of,those,characters,is,individually,considered,as,delimiter,param,trim,tokens,trim,the,tokens,via,string,s,code,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,code,null,if,the,input,string,was,code,null,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,null,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,string,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1385423968;Tokenize the given String into a String array via a StringTokenizer._<p>The given delimiters string is supposed to consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@code delimitedListToStringArray}_@param str the String to tokenize_@param delimiters the delimiter characters, assembled as String_(each of those characters is individually considered as delimiter)_@param trimTokens trim the tokens via String's {@code trim}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens ({@code null} if the input String_was {@code null})_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return null__		}_		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<String>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,string,into,a,string,array,via,a,string,tokenizer,p,the,given,delimiters,string,is,supposed,to,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,code,delimited,list,to,string,array,param,str,the,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,string,each,of,those,characters,is,individually,considered,as,delimiter,param,trim,tokens,trim,the,tokens,via,string,s,code,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,code,null,if,the,input,string,was,code,null,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,null,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,string,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1400189212;Tokenize the given String into a String array via a StringTokenizer._<p>The given delimiters string is supposed to consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@code delimitedListToStringArray}_@param str the String to tokenize_@param delimiters the delimiter characters, assembled as String_(each of those characters is individually considered as delimiter)_@param trimTokens trim the tokens via String's {@code trim}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens ({@code null} if the input String_was {@code null})_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return null__		}_		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<String>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,string,into,a,string,array,via,a,string,tokenizer,p,the,given,delimiters,string,is,supposed,to,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,code,delimited,list,to,string,array,param,str,the,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,string,each,of,those,characters,is,individually,considered,as,delimiter,param,trim,tokens,trim,the,tokens,via,string,s,code,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,code,null,if,the,input,string,was,code,null,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,null,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,string,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1400531359;Tokenize the given String into a String array via a StringTokenizer._<p>The given delimiters string is supposed to consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@code delimitedListToStringArray}_@param str the String to tokenize_@param delimiters the delimiter characters, assembled as String_(each of those characters is individually considered as delimiter)_@param trimTokens trim the tokens via String's {@code trim}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens ({@code null} if the input String_was {@code null})_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return null__		}_		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<String>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,string,into,a,string,array,via,a,string,tokenizer,p,the,given,delimiters,string,is,supposed,to,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,code,delimited,list,to,string,array,param,str,the,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,string,each,of,those,characters,is,individually,considered,as,delimiter,param,trim,tokens,trim,the,tokens,via,string,s,code,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,code,null,if,the,input,string,was,code,null,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,null,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,string,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1402676350;Tokenize the given String into a String array via a StringTokenizer._<p>The given delimiters string is supposed to consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@code delimitedListToStringArray}_@param str the String to tokenize_@param delimiters the delimiter characters, assembled as String_(each of those characters is individually considered as delimiter)_@param trimTokens trim the tokens via String's {@code trim}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens ({@code null} if the input String_was {@code null})_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return null__		}_		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<String>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,string,into,a,string,array,via,a,string,tokenizer,p,the,given,delimiters,string,is,supposed,to,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,code,delimited,list,to,string,array,param,str,the,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,string,each,of,those,characters,is,individually,considered,as,delimiter,param,trim,tokens,trim,the,tokens,via,string,s,code,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,code,null,if,the,input,string,was,code,null,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,null,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,string,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1426267150;Tokenize the given String into a String array via a StringTokenizer._<p>The given delimiters string is supposed to consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@code delimitedListToStringArray}_@param str the String to tokenize_@param delimiters the delimiter characters, assembled as String_(each of those characters is individually considered as delimiter)_@param trimTokens trim the tokens via String's {@code trim}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens ({@code null} if the input String_was {@code null})_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return null__		}_		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<String>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,string,into,a,string,array,via,a,string,tokenizer,p,the,given,delimiters,string,is,supposed,to,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,code,delimited,list,to,string,array,param,str,the,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,string,each,of,those,characters,is,individually,considered,as,delimiter,param,trim,tokens,trim,the,tokens,via,string,s,code,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,code,null,if,the,input,string,was,code,null,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,null,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,string,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1429034538;Tokenize the given String into a String array via a StringTokenizer._<p>The given delimiters string is supposed to consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@code delimitedListToStringArray}_@param str the String to tokenize_@param delimiters the delimiter characters, assembled as String_(each of those characters is individually considered as delimiter)_@param trimTokens trim the tokens via String's {@code trim}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens ({@code null} if the input String_was {@code null})_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return null__		}_		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<String>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,string,into,a,string,array,via,a,string,tokenizer,p,the,given,delimiters,string,is,supposed,to,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,code,delimited,list,to,string,array,param,str,the,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,string,each,of,those,characters,is,individually,considered,as,delimiter,param,trim,tokens,trim,the,tokens,via,string,s,code,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,code,null,if,the,input,string,was,code,null,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,null,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,string,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1429034756;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@param trimTokens trim the tokens via {@link String#trim()}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens ({@code null} if the input {@code String}_was {@code null})_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return null__		}_		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<String>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,param,trim,tokens,trim,the,tokens,via,link,string,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,code,null,if,the,input,code,string,was,code,null,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,null,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,string,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1431006895;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@param trimTokens trim the tokens via {@link String#trim()}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens ({@code null} if the input {@code String}_was {@code null})_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return null__		}_		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<String>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,param,trim,tokens,trim,the,tokens,via,link,string,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,code,null,if,the,input,code,string,was,code,null,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,null,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,string,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1431007368;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@param trimTokens trim the tokens via {@link String#trim()}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens ({@code null} if the input {@code String}_was {@code null})_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return null__		}_		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<String>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,param,trim,tokens,trim,the,tokens,via,link,string,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,code,null,if,the,input,code,string,was,code,null,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,null,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,string,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1449489126;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@param trimTokens trim the tokens via {@link String#trim()}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens ({@code null} if the input {@code String}_was {@code null})_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return null__		}_		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<String>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,param,trim,tokens,trim,the,tokens,via,link,string,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,code,null,if,the,input,code,string,was,code,null,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,null,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,string,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1467730834;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@param trimTokens trim the tokens via {@link String#trim()}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens ({@code null} if the input {@code String}_was {@code null})_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return null__		}_		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,param,trim,tokens,trim,the,tokens,via,link,string,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,code,null,if,the,input,code,string,was,code,null,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,null,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1472128018;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@param trimTokens trim the tokens via {@link String#trim()}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens ({@code null} if the input {@code String}_was {@code null})_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return null__		}_		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,param,trim,tokens,trim,the,tokens,via,link,string,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,code,null,if,the,input,code,string,was,code,null,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,null,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1472202842;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@param trimTokens trim the tokens via {@link String#trim()}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens ({@code null} if the input {@code String}_was {@code null})_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return null__		}_		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,param,trim,tokens,trim,the,tokens,via,link,string,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,code,null,if,the,input,code,string,was,code,null,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,null,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1473942665;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@param trimTokens trim the tokens via {@link String#trim()}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens ({@code null} if the input {@code String}_was {@code null})_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return null__		}_		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,param,trim,tokens,trim,the,tokens,via,link,string,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,code,null,if,the,input,code,string,was,code,null,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,null,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1484248946;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@param trimTokens trim the tokens via {@link String#trim()}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens ({@code null} if the input {@code String}_was {@code null})_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return null__		}_		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,param,trim,tokens,trim,the,tokens,via,link,string,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,code,null,if,the,input,code,string,was,code,null,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,null,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1484260238;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@param trimTokens trim the tokens via {@link String#trim()}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens ({@code null} if the input {@code String}_was {@code null})_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return null__		}_		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,param,trim,tokens,trim,the,tokens,via,link,string,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,code,null,if,the,input,code,string,was,code,null,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,null,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1484694546;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@param trimTokens trim the tokens via {@link String#trim()}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens ({@code null} if the input {@code String}_was {@code null})_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return null__		}_		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,param,trim,tokens,trim,the,tokens,via,link,string,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,code,null,if,the,input,code,string,was,code,null,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,null,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1487760984;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@param trimTokens trim the tokens via {@link String#trim()}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens ({@code null} if the input {@code String}_was {@code null})_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return null__		}_		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,param,trim,tokens,trim,the,tokens,via,link,string,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,code,null,if,the,input,code,string,was,code,null,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,null,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1487778834;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@param trimTokens trim the tokens via {@link String#trim()}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens ({@code null} if the input {@code String}_was {@code null})_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return null__		}_		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,param,trim,tokens,trim,the,tokens,via,link,string,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,code,null,if,the,input,code,string,was,code,null,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,null,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1491898314;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@param trimTokens trim the tokens via {@link String#trim()}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens ({@code null} if the input {@code String}_was {@code null})_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return null__		}__		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,param,trim,tokens,trim,the,tokens,via,link,string,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,code,null,if,the,input,code,string,was,code,null,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,null,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1491903650;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@param trimTokens trim the tokens via {@link String#trim()}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens ({@code null} if the input {@code String}_was {@code null})_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return null__		}__		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,param,trim,tokens,trim,the,tokens,via,link,string,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,code,null,if,the,input,code,string,was,code,null,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,null,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String getFilenameExtension(String path);1328020251;Extract the filename extension from the given path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be <code>null</code>)_@return the extracted filename extension, or <code>null</code> if none;public static String getFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}_		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,code,return,the,extracted,filename,extension,or,code,null,code,if,none;public,static,string,get,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> public static String getFilenameExtension(String path);1337236962;Extract the filename extension from the given path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be <code>null</code>)_@return the extracted filename extension, or <code>null</code> if none;public static String getFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}_		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,code,return,the,extracted,filename,extension,or,code,null,code,if,none;public,static,string,get,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> public static String getFilenameExtension(String path);1356735495;Extract the filename extension from the given path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;public static String getFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}_		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;public,static,string,get,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> public static String getFilenameExtension(String path);1367955086;Extract the filename extension from the given path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;public static String getFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}_		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;public,static,string,get,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> public static String getFilenameExtension(String path);1380921248;Extract the filename extension from the given path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;public static String getFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}_		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;public,static,string,get,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> public static String getFilenameExtension(String path);1382750743;Extract the filename extension from the given path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;public static String getFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}_		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;public,static,string,get,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> public static String getFilenameExtension(String path);1385423968;Extract the filename extension from the given path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;public static String getFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}_		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;public,static,string,get,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> public static String getFilenameExtension(String path);1400189212;Extract the filename extension from the given path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;public static String getFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}_		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;public,static,string,get,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> public static String getFilenameExtension(String path);1400531359;Extract the filename extension from the given path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;public static String getFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}_		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;public,static,string,get,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> public static String getFilenameExtension(String path);1402676350;Extract the filename extension from the given path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;public static String getFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}_		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;public,static,string,get,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> public static String getFilenameExtension(String path);1426267150;Extract the filename extension from the given path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;public static String getFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}_		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;public,static,string,get,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> public static String getFilenameExtension(String path);1429034538;Extract the filename extension from the given path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;public static String getFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}_		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;public,static,string,get,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> public static String getFilenameExtension(String path);1429034756;Extract the filename extension from the given path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;public static String getFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}_		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;public,static,string,get,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> public static String getFilenameExtension(String path);1431006895;Extract the filename extension from the given path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;public static String getFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}_		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;public,static,string,get,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> public static String getFilenameExtension(String path);1431007368;Extract the filename extension from the given path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;public static String getFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}_		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;public,static,string,get,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> public static String getFilenameExtension(String path);1449489126;Extract the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;public static String getFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}_		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;public,static,string,get,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> public static String getFilenameExtension(String path);1467730834;Extract the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;public static String getFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}_		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;public,static,string,get,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> public static String getFilenameExtension(String path);1472128018;Extract the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;public static String getFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}_		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;public,static,string,get,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> public static String getFilenameExtension(String path);1472202842;Extract the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;public static String getFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}_		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;public,static,string,get,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> public static String getFilenameExtension(String path);1473942665;Extract the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;public static String getFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}_		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;public,static,string,get,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> public static String getFilenameExtension(String path);1484248946;Extract the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;public static String getFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}_		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;public,static,string,get,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> public static String getFilenameExtension(String path);1484260238;Extract the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;public static String getFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}_		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;public,static,string,get,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> public static String getFilenameExtension(String path);1484694546;Extract the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;public static String getFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}_		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;public,static,string,get,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> public static String getFilenameExtension(String path);1487760984;Extract the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;public static String getFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}_		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;public,static,string,get,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> public static String getFilenameExtension(String path);1487778834;Extract the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;public static String getFilenameExtension(String path) {_		if (path == null) {_			return null__		}_		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}_		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}_		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;public,static,string,get,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> public static String getFilenameExtension(String path);1491898314;Extract the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;public static String getFilenameExtension(String path) {_		if (path == null) {_			return null__		}__		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}__		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;public,static,string,get,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> public static String getFilenameExtension(String path);1491903650;Extract the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "txt"._@param path the file path (may be {@code null})_@return the extracted filename extension, or {@code null} if none;public static String getFilenameExtension(String path) {_		if (path == null) {_			return null__		}__		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return null__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return null__		}__		return path.substring(extIndex + 1)__	};extract,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,extension,or,code,null,if,none;public,static,string,get,filename,extension,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,null,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,null,return,path,substring,ext,index,1
StringUtils -> public static String[] concatenateStringArrays(String[] array1, String[] array2);1328020251;Concatenate the given String arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be <code>null</code>)_@param array2 the second array (can be <code>null</code>)_@return the new array (<code>null</code> if both given arrays were <code>null</code>);public static String[] concatenateStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,code,param,array2,the,second,array,can,be,code,null,code,return,the,new,array,code,null,code,if,both,given,arrays,were,code,null,code;public,static,string,concatenate,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> public static String[] concatenateStringArrays(String[] array1, String[] array2);1337236962;Concatenate the given String arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be <code>null</code>)_@param array2 the second array (can be <code>null</code>)_@return the new array (<code>null</code> if both given arrays were <code>null</code>);public static String[] concatenateStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,code,param,array2,the,second,array,can,be,code,null,code,return,the,new,array,code,null,code,if,both,given,arrays,were,code,null,code;public,static,string,concatenate,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> public static String[] concatenateStringArrays(String[] array1, String[] array2);1356735495;Concatenate the given String arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] concatenateStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,concatenate,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> public static String[] concatenateStringArrays(String[] array1, String[] array2);1367955086;Concatenate the given String arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] concatenateStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,concatenate,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> public static String[] concatenateStringArrays(String[] array1, String[] array2);1380921248;Concatenate the given String arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] concatenateStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,concatenate,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> public static String[] concatenateStringArrays(String[] array1, String[] array2);1382750743;Concatenate the given String arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] concatenateStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,concatenate,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> public static String[] concatenateStringArrays(String[] array1, String[] array2);1385423968;Concatenate the given String arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] concatenateStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,concatenate,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> public static String[] concatenateStringArrays(String[] array1, String[] array2);1400189212;Concatenate the given String arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] concatenateStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,concatenate,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> public static String[] concatenateStringArrays(String[] array1, String[] array2);1400531359;Concatenate the given String arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] concatenateStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,concatenate,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> public static String[] concatenateStringArrays(String[] array1, String[] array2);1402676350;Concatenate the given String arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] concatenateStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,concatenate,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> public static String[] concatenateStringArrays(String[] array1, String[] array2);1426267150;Concatenate the given String arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] concatenateStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,concatenate,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> public static String[] concatenateStringArrays(String[] array1, String[] array2);1429034538;Concatenate the given String arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] concatenateStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,concatenate,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> public static String[] concatenateStringArrays(String[] array1, String[] array2);1429034756;Concatenate the given {@code String} arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] concatenateStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,code,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,concatenate,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> public static String[] concatenateStringArrays(String[] array1, String[] array2);1431006895;Concatenate the given {@code String} arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] concatenateStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,code,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,concatenate,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> public static String[] concatenateStringArrays(String[] array1, String[] array2);1431007368;Concatenate the given {@code String} arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] concatenateStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,code,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,concatenate,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> public static String[] concatenateStringArrays(String[] array1, String[] array2);1449489126;Concatenate the given {@code String} arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] concatenateStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,code,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,concatenate,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> public static String[] concatenateStringArrays(String[] array1, String[] array2);1467730834;Concatenate the given {@code String} arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] concatenateStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,code,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,concatenate,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> public static String[] concatenateStringArrays(String[] array1, String[] array2);1472128018;Concatenate the given {@code String} arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] concatenateStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,code,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,concatenate,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> public static String[] concatenateStringArrays(String[] array1, String[] array2);1472202842;Concatenate the given {@code String} arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] concatenateStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,code,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,concatenate,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> public static String[] concatenateStringArrays(String[] array1, String[] array2);1473942665;Concatenate the given {@code String} arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] concatenateStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,code,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,concatenate,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> public static String[] concatenateStringArrays(String[] array1, String[] array2);1484248946;Concatenate the given {@code String} arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] concatenateStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,code,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,concatenate,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> public static String[] concatenateStringArrays(String[] array1, String[] array2);1484260238;Concatenate the given {@code String} arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] concatenateStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,code,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,concatenate,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> public static String[] concatenateStringArrays(String[] array1, String[] array2);1484694546;Concatenate the given {@code String} arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] concatenateStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,code,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,concatenate,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> public static String[] concatenateStringArrays(String[] array1, String[] array2);1487760984;Concatenate the given {@code String} arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] concatenateStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,code,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,concatenate,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> public static String[] concatenateStringArrays(String[] array1, String[] array2);1487778834;Concatenate the given {@code String} arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] concatenateStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,code,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,concatenate,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> public static String[] concatenateStringArrays(String[] array1, String[] array2);1491898314;Concatenate the given {@code String} arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] concatenateStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,code,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,concatenate,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> public static String[] concatenateStringArrays(String[] array1, String[] array2);1491903650;Concatenate the given {@code String} arrays into one,_with overlapping array elements included twice._<p>The order of elements in the original arrays is preserved._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] concatenateStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		String[] newArr = new String[array1.length + array2.length]__		System.arraycopy(array1, 0, newArr, 0, array1.length)__		System.arraycopy(array2, 0, newArr, array1.length, array2.length)__		return newArr__	};concatenate,the,given,code,string,arrays,into,one,with,overlapping,array,elements,included,twice,p,the,order,of,elements,in,the,original,arrays,is,preserved,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,concatenate,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,string,new,arr,new,string,array1,length,array2,length,system,arraycopy,array1,0,new,arr,0,array1,length,system,arraycopy,array2,0,new,arr,array1,length,array2,length,return,new,arr
StringUtils -> @Deprecated 	public static String toLanguageTag(Locale locale);1516903831;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as {@code String}_@deprecated as of 5.0.4, in favor of {@link Locale#toLanguageTag()};@Deprecated_	public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,code,string,deprecated,as,of,5,0,4,in,favor,of,link,locale,to,language,tag;deprecated,public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> @Deprecated 	public static String toLanguageTag(Locale locale);1519295386;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as {@code String}_@deprecated as of 5.0.4, in favor of {@link Locale#toLanguageTag()};@Deprecated_	public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,code,string,deprecated,as,of,5,0,4,in,favor,of,link,locale,to,language,tag;deprecated,public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> @Deprecated 	public static String toLanguageTag(Locale locale);1519308837;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as {@code String}_@deprecated as of 5.0.4, in favor of {@link Locale#toLanguageTag()};@Deprecated_	public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,code,string,deprecated,as,of,5,0,4,in,favor,of,link,locale,to,language,tag;deprecated,public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> @Deprecated 	public static String toLanguageTag(Locale locale);1519588127;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as {@code String}_@deprecated as of 5.0.4, in favor of {@link Locale#toLanguageTag()};@Deprecated_	public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,code,string,deprecated,as,of,5,0,4,in,favor,of,link,locale,to,language,tag;deprecated,public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> @Deprecated 	public static String toLanguageTag(Locale locale);1522332352;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as {@code String}_@deprecated as of 5.0.4, in favor of {@link Locale#toLanguageTag()};@Deprecated_	public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,code,string,deprecated,as,of,5,0,4,in,favor,of,link,locale,to,language,tag;deprecated,public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> @Deprecated 	public static String toLanguageTag(Locale locale);1525166194;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as {@code String}_@deprecated as of 5.0.4, in favor of {@link Locale#toLanguageTag()};@Deprecated_	public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,code,string,deprecated,as,of,5,0,4,in,favor,of,link,locale,to,language,tag;deprecated,public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> @Deprecated 	public static String toLanguageTag(Locale locale);1530188116;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as {@code String}_@deprecated as of 5.0.4, in favor of {@link Locale#toLanguageTag()};@Deprecated_	public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,code,string,deprecated,as,of,5,0,4,in,favor,of,link,locale,to,language,tag;deprecated,public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> @Deprecated 	public static String toLanguageTag(Locale locale);1531843079;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as {@code String}_@deprecated as of 5.0.4, in favor of {@link Locale#toLanguageTag()};@Deprecated_	public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,code,string,deprecated,as,of,5,0,4,in,favor,of,link,locale,to,language,tag;deprecated,public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> @Deprecated 	public static String toLanguageTag(Locale locale);1531905026;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as {@code String}_@deprecated as of 5.0.4, in favor of {@link Locale#toLanguageTag()};@Deprecated_	public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,code,string,deprecated,as,of,5,0,4,in,favor,of,link,locale,to,language,tag;deprecated,public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> @Deprecated 	public static String toLanguageTag(Locale locale);1533557519;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as {@code String}_@deprecated as of 5.0.4, in favor of {@link Locale#toLanguageTag()};@Deprecated_	public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,code,string,deprecated,as,of,5,0,4,in,favor,of,link,locale,to,language,tag;deprecated,public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> @Deprecated 	public static String toLanguageTag(Locale locale);1533602820;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as {@code String}_@deprecated as of 5.0.4, in favor of {@link Locale#toLanguageTag()};@Deprecated_	public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,code,string,deprecated,as,of,5,0,4,in,favor,of,link,locale,to,language,tag;deprecated,public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> @Deprecated 	public static String toLanguageTag(Locale locale);1535316501;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as {@code String}_@deprecated as of 5.0.4, in favor of {@link Locale#toLanguageTag()};@Deprecated_	public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,code,string,deprecated,as,of,5,0,4,in,favor,of,link,locale,to,language,tag;deprecated,public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> @Deprecated 	public static String toLanguageTag(Locale locale);1550237113;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as {@code String}_@deprecated as of 5.0.4, in favor of {@link Locale#toLanguageTag()};@Deprecated_	public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,code,string,deprecated,as,of,5,0,4,in,favor,of,link,locale,to,language,tag;deprecated,public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> @Deprecated 	public static String toLanguageTag(Locale locale);1550238935;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as {@code String}_@deprecated as of 5.0.4, in favor of {@link Locale#toLanguageTag()};@Deprecated_	public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,code,string,deprecated,as,of,5,0,4,in,favor,of,link,locale,to,language,tag;deprecated,public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> @Nullable 	public static String quote(@Nullable String str);1495868221;Quote the given {@code String} with single quotes._@param str the input {@code String} (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or {@code null} if the input was {@code null};@Nullable_	public static String quote(@Nullable String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,code,string,with,single,quotes,param,str,the,input,code,string,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,code,null,if,the,input,was,code,null;nullable,public,static,string,quote,nullable,string,str,return,str,null,str,null
StringUtils -> @Nullable 	public static String quote(@Nullable String str);1496243689;Quote the given {@code String} with single quotes._@param str the input {@code String} (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or {@code null} if the input was {@code null};@Nullable_	public static String quote(@Nullable String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,code,string,with,single,quotes,param,str,the,input,code,string,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,code,null,if,the,input,was,code,null;nullable,public,static,string,quote,nullable,string,str,return,str,null,str,null
StringUtils -> @Nullable 	public static String quote(@Nullable String str);1496259743;Quote the given {@code String} with single quotes._@param str the input {@code String} (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or {@code null} if the input was {@code null};@Nullable_	public static String quote(@Nullable String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,code,string,with,single,quotes,param,str,the,input,code,string,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,code,null,if,the,input,was,code,null;nullable,public,static,string,quote,nullable,string,str,return,str,null,str,null
StringUtils -> @Nullable 	public static String quote(@Nullable String str);1496837955;Quote the given {@code String} with single quotes._@param str the input {@code String} (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or {@code null} if the input was {@code null};@Nullable_	public static String quote(@Nullable String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,code,string,with,single,quotes,param,str,the,input,code,string,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,code,null,if,the,input,was,code,null;nullable,public,static,string,quote,nullable,string,str,return,str,null,str,null
StringUtils -> @Nullable 	public static String quote(@Nullable String str);1499270197;Quote the given {@code String} with single quotes._@param str the input {@code String} (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or {@code null} if the input was {@code null};@Nullable_	public static String quote(@Nullable String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,code,string,with,single,quotes,param,str,the,input,code,string,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,code,null,if,the,input,was,code,null;nullable,public,static,string,quote,nullable,string,str,return,str,null,str,null
StringUtils -> @Nullable 	public static String quote(@Nullable String str);1508667152;Quote the given {@code String} with single quotes._@param str the input {@code String} (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or {@code null} if the input was {@code null};@Nullable_	public static String quote(@Nullable String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,code,string,with,single,quotes,param,str,the,input,code,string,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,code,null,if,the,input,was,code,null;nullable,public,static,string,quote,nullable,string,str,return,str,null,str,null
StringUtils -> @Nullable 	public static String quote(@Nullable String str);1508675477;Quote the given {@code String} with single quotes._@param str the input {@code String} (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or {@code null} if the input was {@code null};@Nullable_	public static String quote(@Nullable String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,code,string,with,single,quotes,param,str,the,input,code,string,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,code,null,if,the,input,was,code,null;nullable,public,static,string,quote,nullable,string,str,return,str,null,str,null
StringUtils -> @Nullable 	public static String quote(@Nullable String str);1508843807;Quote the given {@code String} with single quotes._@param str the input {@code String} (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or {@code null} if the input was {@code null};@Nullable_	public static String quote(@Nullable String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,code,string,with,single,quotes,param,str,the,input,code,string,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,code,null,if,the,input,was,code,null;nullable,public,static,string,quote,nullable,string,str,return,str,null,str,null
StringUtils -> @Nullable 	public static String quote(@Nullable String str);1516903831;Quote the given {@code String} with single quotes._@param str the input {@code String} (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or {@code null} if the input was {@code null};@Nullable_	public static String quote(@Nullable String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,code,string,with,single,quotes,param,str,the,input,code,string,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,code,null,if,the,input,was,code,null;nullable,public,static,string,quote,nullable,string,str,return,str,null,str,null
StringUtils -> @Nullable 	public static String quote(@Nullable String str);1519295386;Quote the given {@code String} with single quotes._@param str the input {@code String} (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or {@code null} if the input was {@code null};@Nullable_	public static String quote(@Nullable String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,code,string,with,single,quotes,param,str,the,input,code,string,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,code,null,if,the,input,was,code,null;nullable,public,static,string,quote,nullable,string,str,return,str,null,str,null
StringUtils -> @Nullable 	public static String quote(@Nullable String str);1519308837;Quote the given {@code String} with single quotes._@param str the input {@code String} (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or {@code null} if the input was {@code null};@Nullable_	public static String quote(@Nullable String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,code,string,with,single,quotes,param,str,the,input,code,string,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,code,null,if,the,input,was,code,null;nullable,public,static,string,quote,nullable,string,str,return,str,null,str,null
StringUtils -> @Nullable 	public static String quote(@Nullable String str);1519588127;Quote the given {@code String} with single quotes._@param str the input {@code String} (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or {@code null} if the input was {@code null};@Nullable_	public static String quote(@Nullable String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,code,string,with,single,quotes,param,str,the,input,code,string,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,code,null,if,the,input,was,code,null;nullable,public,static,string,quote,nullable,string,str,return,str,null,str,null
StringUtils -> @Nullable 	public static String quote(@Nullable String str);1522332352;Quote the given {@code String} with single quotes._@param str the input {@code String} (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or {@code null} if the input was {@code null};@Nullable_	public static String quote(@Nullable String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,code,string,with,single,quotes,param,str,the,input,code,string,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,code,null,if,the,input,was,code,null;nullable,public,static,string,quote,nullable,string,str,return,str,null,str,null
StringUtils -> @Nullable 	public static String quote(@Nullable String str);1525166194;Quote the given {@code String} with single quotes._@param str the input {@code String} (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or {@code null} if the input was {@code null};@Nullable_	public static String quote(@Nullable String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,code,string,with,single,quotes,param,str,the,input,code,string,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,code,null,if,the,input,was,code,null;nullable,public,static,string,quote,nullable,string,str,return,str,null,str,null
StringUtils -> @Nullable 	public static String quote(@Nullable String str);1530188116;Quote the given {@code String} with single quotes._@param str the input {@code String} (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or {@code null} if the input was {@code null};@Nullable_	public static String quote(@Nullable String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,code,string,with,single,quotes,param,str,the,input,code,string,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,code,null,if,the,input,was,code,null;nullable,public,static,string,quote,nullable,string,str,return,str,null,str,null
StringUtils -> @Nullable 	public static String quote(@Nullable String str);1531843079;Quote the given {@code String} with single quotes._@param str the input {@code String} (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or {@code null} if the input was {@code null};@Nullable_	public static String quote(@Nullable String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,code,string,with,single,quotes,param,str,the,input,code,string,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,code,null,if,the,input,was,code,null;nullable,public,static,string,quote,nullable,string,str,return,str,null,str,null
StringUtils -> @Nullable 	public static String quote(@Nullable String str);1531905026;Quote the given {@code String} with single quotes._@param str the input {@code String} (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or {@code null} if the input was {@code null};@Nullable_	public static String quote(@Nullable String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,code,string,with,single,quotes,param,str,the,input,code,string,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,code,null,if,the,input,was,code,null;nullable,public,static,string,quote,nullable,string,str,return,str,null,str,null
StringUtils -> @Nullable 	public static String quote(@Nullable String str);1533557519;Quote the given {@code String} with single quotes._@param str the input {@code String} (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or {@code null} if the input was {@code null};@Nullable_	public static String quote(@Nullable String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,code,string,with,single,quotes,param,str,the,input,code,string,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,code,null,if,the,input,was,code,null;nullable,public,static,string,quote,nullable,string,str,return,str,null,str,null
StringUtils -> @Nullable 	public static String quote(@Nullable String str);1533602820;Quote the given {@code String} with single quotes._@param str the input {@code String} (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or {@code null} if the input was {@code null};@Nullable_	public static String quote(@Nullable String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,code,string,with,single,quotes,param,str,the,input,code,string,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,code,null,if,the,input,was,code,null;nullable,public,static,string,quote,nullable,string,str,return,str,null,str,null
StringUtils -> @Nullable 	public static String quote(@Nullable String str);1535316501;Quote the given {@code String} with single quotes._@param str the input {@code String} (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or {@code null} if the input was {@code null};@Nullable_	public static String quote(@Nullable String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,code,string,with,single,quotes,param,str,the,input,code,string,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,code,null,if,the,input,was,code,null;nullable,public,static,string,quote,nullable,string,str,return,str,null,str,null
StringUtils -> @Nullable 	public static String quote(@Nullable String str);1550237113;Quote the given {@code String} with single quotes._@param str the input {@code String} (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or {@code null} if the input was {@code null};@Nullable_	public static String quote(@Nullable String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,code,string,with,single,quotes,param,str,the,input,code,string,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,code,null,if,the,input,was,code,null;nullable,public,static,string,quote,nullable,string,str,return,str,null,str,null
StringUtils -> @Nullable 	public static String quote(@Nullable String str);1550238935;Quote the given {@code String} with single quotes._@param str the input {@code String} (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or {@code null} if the input was {@code null};@Nullable_	public static String quote(@Nullable String str) {_		return (str != null ? "'" + str + "'" : null)__	};quote,the,given,code,string,with,single,quotes,param,str,the,input,code,string,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,code,null,if,the,input,was,code,null;nullable,public,static,string,quote,nullable,string,str,return,str,null,str,null
StringUtils -> public static String[] trimArrayElements(String[] array);1328020251;Trim the elements of the given String array,_calling <code>String.trim()</code> on each of them._@param array the original String array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,string,array,calling,code,string,trim,code,on,each,of,them,param,array,the,original,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(String[] array);1337236962;Trim the elements of the given String array,_calling <code>String.trim()</code> on each of them._@param array the original String array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,string,array,calling,code,string,trim,code,on,each,of,them,param,array,the,original,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(String[] array);1356735495;Trim the elements of the given String array,_calling {@code String.trim()} on each of them._@param array the original String array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(String[] array);1367955086;Trim the elements of the given String array,_calling {@code String.trim()} on each of them._@param array the original String array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(String[] array);1380921248;Trim the elements of the given String array,_calling {@code String.trim()} on each of them._@param array the original String array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(String[] array);1382750743;Trim the elements of the given String array,_calling {@code String.trim()} on each of them._@param array the original String array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(String[] array);1385423968;Trim the elements of the given String array,_calling {@code String.trim()} on each of them._@param array the original String array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(String[] array);1400189212;Trim the elements of the given String array,_calling {@code String.trim()} on each of them._@param array the original String array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(String[] array);1400531359;Trim the elements of the given String array,_calling {@code String.trim()} on each of them._@param array the original String array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(String[] array);1402676350;Trim the elements of the given String array,_calling {@code String.trim()} on each of them._@param array the original String array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(String[] array);1426267150;Trim the elements of the given String array,_calling {@code String.trim()} on each of them._@param array the original String array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(String[] array);1429034538;Trim the elements of the given String array,_calling {@code String.trim()} on each of them._@param array the original String array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(String[] array);1429034756;Trim the elements of the given {@code String} array,_calling {@code String.trim()} on each of them._@param array the original {@code String} array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,code,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,code,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(String[] array);1431006895;Trim the elements of the given {@code String} array,_calling {@code String.trim()} on each of them._@param array the original {@code String} array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,code,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,code,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(String[] array);1431007368;Trim the elements of the given {@code String} array,_calling {@code String.trim()} on each of them._@param array the original {@code String} array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,code,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,code,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(String[] array);1449489126;Trim the elements of the given {@code String} array,_calling {@code String.trim()} on each of them._@param array the original {@code String} array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,code,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,code,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(String[] array);1467730834;Trim the elements of the given {@code String} array,_calling {@code String.trim()} on each of them._@param array the original {@code String} array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,code,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,code,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(String[] array);1472128018;Trim the elements of the given {@code String} array,_calling {@code String.trim()} on each of them._@param array the original {@code String} array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,code,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,code,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(String[] array);1472202842;Trim the elements of the given {@code String} array,_calling {@code String.trim()} on each of them._@param array the original {@code String} array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,code,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,code,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(String[] array);1473942665;Trim the elements of the given {@code String} array,_calling {@code String.trim()} on each of them._@param array the original {@code String} array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,code,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,code,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(String[] array);1484248946;Trim the elements of the given {@code String} array,_calling {@code String.trim()} on each of them._@param array the original {@code String} array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,code,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,code,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(String[] array);1484260238;Trim the elements of the given {@code String} array,_calling {@code String.trim()} on each of them._@param array the original {@code String} array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,code,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,code,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(String[] array);1484694546;Trim the elements of the given {@code String} array,_calling {@code String.trim()} on each of them._@param array the original {@code String} array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,code,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,code,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(String[] array);1487760984;Trim the elements of the given {@code String} array,_calling {@code String.trim()} on each of them._@param array the original {@code String} array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,code,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,code,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(String[] array);1487778834;Trim the elements of the given {@code String} array,_calling {@code String.trim()} on each of them._@param array the original {@code String} array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,code,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,code,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(String[] array);1491898314;Trim the elements of the given {@code String} array,_calling {@code String.trim()} on each of them._@param array the original {@code String} array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,code,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,code,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(String[] array);1491903650;Trim the elements of the given {@code String} array,_calling {@code String.trim()} on each of them._@param array the original {@code String} array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,code,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,code,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(String[] array);1495868221;Trim the elements of the given {@code String} array,_calling {@code String.trim()} on each of them._@param array the original {@code String} array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,code,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,code,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(String[] array);1533557519;Trim the elements of the given {@code String} array,_calling {@code String.trim()} on each of them._@param array the original {@code String} array (potentially {@code null} or empty)_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}__		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,code,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,code,string,array,potentially,code,null,or,empty,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,string,array,if,object,utils,is,empty,array,return,array,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(String[] array);1533602820;Trim the elements of the given {@code String} array,_calling {@code String.trim()} on each of them._@param array the original {@code String} array (potentially empty)_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}__		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,code,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,code,string,array,potentially,empty,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,string,array,if,object,utils,is,empty,array,return,array,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(String[] array);1535316501;Trim the elements of the given {@code String} array,_calling {@code String.trim()} on each of them._@param array the original {@code String} array (potentially empty)_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}__		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,code,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,code,string,array,potentially,empty,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,string,array,if,object,utils,is,empty,array,return,array,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(String[] array);1550237113;Trim the elements of the given {@code String} array,_calling {@code String.trim()} on each of them._@param array the original {@code String} array (potentially empty)_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}__		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,code,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,code,string,array,potentially,empty,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,string,array,if,object,utils,is,empty,array,return,array,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(String[] array);1550238935;Trim the elements of the given {@code String} array,_calling {@code String.trim()} on each of them._@param array the original {@code String} array (potentially empty)_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}__		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,code,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,code,string,array,potentially,empty,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,string,array,if,object,utils,is,empty,array,return,array,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> @Nullable 	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2);1495868221;Merge the given {@code String} arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});@Nullable_	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		List<String> result = new ArrayList<>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,code,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;nullable,public,static,string,merge,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> @Nullable 	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2);1496243689;Merge the given {@code String} arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});@Nullable_	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		List<String> result = new ArrayList<>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,code,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;nullable,public,static,string,merge,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> @Nullable 	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2);1496259743;Merge the given {@code String} arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});@Nullable_	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		List<String> result = new ArrayList<>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,code,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;nullable,public,static,string,merge,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> @Nullable 	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2);1496837955;Merge the given {@code String} arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});@Nullable_	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		List<String> result = new ArrayList<>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,code,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;nullable,public,static,string,merge,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> @Nullable 	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2);1499270197;Merge the given {@code String} arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});@Nullable_	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		List<String> result = new ArrayList<>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,code,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;nullable,public,static,string,merge,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> @Nullable 	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2);1508667152;Merge the given {@code String} arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});@Nullable_	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		List<String> result = new ArrayList<>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,code,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;nullable,public,static,string,merge,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> @Nullable 	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2);1508675477;Merge the given {@code String} arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});@Nullable_	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		List<String> result = new ArrayList<>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,code,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;nullable,public,static,string,merge,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> @Nullable 	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2);1508843807;Merge the given {@code String} arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});@Nullable_	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		List<String> result = new ArrayList<>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,code,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;nullable,public,static,string,merge,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> @Nullable 	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2);1516903831;Merge the given {@code String} arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});@Nullable_	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		List<String> result = new ArrayList<>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,code,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;nullable,public,static,string,merge,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> @Nullable 	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2);1519295386;Merge the given {@code String} arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});@Nullable_	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		List<String> result = new ArrayList<>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,code,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;nullable,public,static,string,merge,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> public static String[] trimArrayElements(@Nullable String[] array);1496243689;Trim the elements of the given {@code String} array,_calling {@code String.trim()} on each of them._@param array the original {@code String} array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(@Nullable String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,code,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,code,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,nullable,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(@Nullable String[] array);1496259743;Trim the elements of the given {@code String} array,_calling {@code String.trim()} on each of them._@param array the original {@code String} array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(@Nullable String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,code,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,code,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,nullable,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(@Nullable String[] array);1496837955;Trim the elements of the given {@code String} array,_calling {@code String.trim()} on each of them._@param array the original {@code String} array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(@Nullable String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,code,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,code,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,nullable,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(@Nullable String[] array);1499270197;Trim the elements of the given {@code String} array,_calling {@code String.trim()} on each of them._@param array the original {@code String} array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(@Nullable String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,code,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,code,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,nullable,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(@Nullable String[] array);1508667152;Trim the elements of the given {@code String} array,_calling {@code String.trim()} on each of them._@param array the original {@code String} array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(@Nullable String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,code,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,code,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,nullable,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(@Nullable String[] array);1508675477;Trim the elements of the given {@code String} array,_calling {@code String.trim()} on each of them._@param array the original {@code String} array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(@Nullable String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,code,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,code,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,nullable,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(@Nullable String[] array);1508843807;Trim the elements of the given {@code String} array,_calling {@code String.trim()} on each of them._@param array the original {@code String} array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(@Nullable String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,code,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,code,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,nullable,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(@Nullable String[] array);1516903831;Trim the elements of the given {@code String} array,_calling {@code String.trim()} on each of them._@param array the original {@code String} array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(@Nullable String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,code,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,code,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,nullable,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(@Nullable String[] array);1519295386;Trim the elements of the given {@code String} array,_calling {@code String.trim()} on each of them._@param array the original {@code String} array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(@Nullable String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,code,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,code,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,nullable,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(@Nullable String[] array);1519308837;Trim the elements of the given {@code String} array,_calling {@code String.trim()} on each of them._@param array the original {@code String} array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(@Nullable String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,code,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,code,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,nullable,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(@Nullable String[] array);1519588127;Trim the elements of the given {@code String} array,_calling {@code String.trim()} on each of them._@param array the original {@code String} array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(@Nullable String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,code,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,code,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,nullable,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(@Nullable String[] array);1522332352;Trim the elements of the given {@code String} array,_calling {@code String.trim()} on each of them._@param array the original {@code String} array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(@Nullable String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,code,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,code,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,nullable,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(@Nullable String[] array);1525166194;Trim the elements of the given {@code String} array,_calling {@code String.trim()} on each of them._@param array the original {@code String} array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(@Nullable String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,code,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,code,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,nullable,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(@Nullable String[] array);1530188116;Trim the elements of the given {@code String} array,_calling {@code String.trim()} on each of them._@param array the original {@code String} array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(@Nullable String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,code,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,code,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,nullable,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(@Nullable String[] array);1531843079;Trim the elements of the given {@code String} array,_calling {@code String.trim()} on each of them._@param array the original {@code String} array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(@Nullable String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,code,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,code,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,nullable,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String[] trimArrayElements(@Nullable String[] array);1531905026;Trim the elements of the given {@code String} array,_calling {@code String.trim()} on each of them._@param array the original {@code String} array_@return the resulting array (of the same size) with trimmed elements;public static String[] trimArrayElements(@Nullable String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		String[] result = new String[array.length]__		for (int i = 0_ i < array.length_ i++) {_			String element = array[i]__			result[i] = (element != null ? element.trim() : null)__		}_		return result__	};trim,the,elements,of,the,given,code,string,array,calling,code,string,trim,on,each,of,them,param,array,the,original,code,string,array,return,the,resulting,array,of,the,same,size,with,trimmed,elements;public,static,string,trim,array,elements,nullable,string,array,if,object,utils,is,empty,array,return,new,string,0,string,result,new,string,array,length,for,int,i,0,i,array,length,i,string,element,array,i,result,i,element,null,element,trim,null,return,result
StringUtils -> public static String trimWhitespace(String str);1328020251;Trim leading and trailing whitespace from the given String._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,string,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1337236962;Trim leading and trailing whitespace from the given String._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,string,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1356735495;Trim leading and trailing whitespace from the given String._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,string,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1367955086;Trim leading and trailing whitespace from the given String._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,string,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1380921248;Trim leading and trailing whitespace from the given String._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,string,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1382750743;Trim leading and trailing whitespace from the given String._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,string,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1385423968;Trim leading and trailing whitespace from the given String._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,string,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1400189212;Trim leading and trailing whitespace from the given String._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,string,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1400531359;Trim leading and trailing whitespace from the given String._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,string,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1402676350;Trim leading and trailing whitespace from the given String._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,string,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1426267150;Trim leading and trailing whitespace from the given String._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,string,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1429034538;Trim leading and trailing whitespace from the given String._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,string,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1429034756;Trim leading and trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1431006895;Trim leading and trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1431007368;Trim leading and trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1449489126;Trim leading and trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1467730834;Trim leading and trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1472128018;Trim leading and trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1472202842;Trim leading and trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1473942665;Trim leading and trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1484248946;Trim leading and trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1484260238;Trim leading and trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1484694546;Trim leading and trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1487760984;Trim leading and trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1487778834;Trim leading and trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1491898314;Trim leading and trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1491903650;Trim leading and trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1495868221;Trim leading and trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1496243689;Trim leading and trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1496259743;Trim leading and trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1496837955;Trim leading and trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1499270197;Trim leading and trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1508667152;Trim leading and trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1508675477;Trim leading and trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1508843807;Trim leading and trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1516903831;Trim leading and trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1519295386;Trim leading and trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1519308837;Trim leading and trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1519588127;Trim leading and trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1522332352;Trim leading and trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {_			sb.deleteCharAt(sb.length() - 1)__		}_		return sb.toString()__	};trim,leading,and,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,while,sb,length,0,character,is,whitespace,sb,char,at,sb,length,1,sb,delete,char,at,sb,length,1,return,sb,to,string
StringUtils -> public static String trimWhitespace(String str);1525166194;Trim leading and trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		int beginIndex = 0__		int endIndex = str.length() - 1___		while (beginIndex <= endIndex && Character.isWhitespace(str.charAt(beginIndex))) {_			beginIndex++__		}__		while (endIndex > beginIndex && Character.isWhitespace(str.charAt(endIndex))) {_			endIndex--__		}__		return str.substring(beginIndex, endIndex + 1)__	};trim,leading,and,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,int,begin,index,0,int,end,index,str,length,1,while,begin,index,end,index,character,is,whitespace,str,char,at,begin,index,begin,index,while,end,index,begin,index,character,is,whitespace,str,char,at,end,index,end,index,return,str,substring,begin,index,end,index,1
StringUtils -> public static String trimWhitespace(String str);1530188116;Trim leading and trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		int beginIndex = 0__		int endIndex = str.length() - 1___		while (beginIndex <= endIndex && Character.isWhitespace(str.charAt(beginIndex))) {_			beginIndex++__		}__		while (endIndex > beginIndex && Character.isWhitespace(str.charAt(endIndex))) {_			endIndex--__		}__		return str.substring(beginIndex, endIndex + 1)__	};trim,leading,and,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,int,begin,index,0,int,end,index,str,length,1,while,begin,index,end,index,character,is,whitespace,str,char,at,begin,index,begin,index,while,end,index,begin,index,character,is,whitespace,str,char,at,end,index,end,index,return,str,substring,begin,index,end,index,1
StringUtils -> public static String trimWhitespace(String str);1531843079;Trim leading and trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		int beginIndex = 0__		int endIndex = str.length() - 1___		while (beginIndex <= endIndex && Character.isWhitespace(str.charAt(beginIndex))) {_			beginIndex++__		}__		while (endIndex > beginIndex && Character.isWhitespace(str.charAt(endIndex))) {_			endIndex--__		}__		return str.substring(beginIndex, endIndex + 1)__	};trim,leading,and,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,int,begin,index,0,int,end,index,str,length,1,while,begin,index,end,index,character,is,whitespace,str,char,at,begin,index,begin,index,while,end,index,begin,index,character,is,whitespace,str,char,at,end,index,end,index,return,str,substring,begin,index,end,index,1
StringUtils -> public static String trimWhitespace(String str);1531905026;Trim leading and trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		int beginIndex = 0__		int endIndex = str.length() - 1___		while (beginIndex <= endIndex && Character.isWhitespace(str.charAt(beginIndex))) {_			beginIndex++__		}__		while (endIndex > beginIndex && Character.isWhitespace(str.charAt(endIndex))) {_			endIndex--__		}__		return str.substring(beginIndex, endIndex + 1)__	};trim,leading,and,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,int,begin,index,0,int,end,index,str,length,1,while,begin,index,end,index,character,is,whitespace,str,char,at,begin,index,begin,index,while,end,index,begin,index,character,is,whitespace,str,char,at,end,index,end,index,return,str,substring,begin,index,end,index,1
StringUtils -> public static String trimWhitespace(String str);1533557519;Trim leading and trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		int beginIndex = 0__		int endIndex = str.length() - 1___		while (beginIndex <= endIndex && Character.isWhitespace(str.charAt(beginIndex))) {_			beginIndex++__		}__		while (endIndex > beginIndex && Character.isWhitespace(str.charAt(endIndex))) {_			endIndex--__		}__		return str.substring(beginIndex, endIndex + 1)__	};trim,leading,and,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,int,begin,index,0,int,end,index,str,length,1,while,begin,index,end,index,character,is,whitespace,str,char,at,begin,index,begin,index,while,end,index,begin,index,character,is,whitespace,str,char,at,end,index,end,index,return,str,substring,begin,index,end,index,1
StringUtils -> public static String trimWhitespace(String str);1533602820;Trim leading and trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		int beginIndex = 0__		int endIndex = str.length() - 1___		while (beginIndex <= endIndex && Character.isWhitespace(str.charAt(beginIndex))) {_			beginIndex++__		}__		while (endIndex > beginIndex && Character.isWhitespace(str.charAt(endIndex))) {_			endIndex--__		}__		return str.substring(beginIndex, endIndex + 1)__	};trim,leading,and,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,int,begin,index,0,int,end,index,str,length,1,while,begin,index,end,index,character,is,whitespace,str,char,at,begin,index,begin,index,while,end,index,begin,index,character,is,whitespace,str,char,at,end,index,end,index,return,str,substring,begin,index,end,index,1
StringUtils -> public static String trimWhitespace(String str);1535316501;Trim leading and trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		int beginIndex = 0__		int endIndex = str.length() - 1___		while (beginIndex <= endIndex && Character.isWhitespace(str.charAt(beginIndex))) {_			beginIndex++__		}__		while (endIndex > beginIndex && Character.isWhitespace(str.charAt(endIndex))) {_			endIndex--__		}__		return str.substring(beginIndex, endIndex + 1)__	};trim,leading,and,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,int,begin,index,0,int,end,index,str,length,1,while,begin,index,end,index,character,is,whitespace,str,char,at,begin,index,begin,index,while,end,index,begin,index,character,is,whitespace,str,char,at,end,index,end,index,return,str,substring,begin,index,end,index,1
StringUtils -> public static String trimWhitespace(String str);1550237113;Trim leading and trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		int beginIndex = 0__		int endIndex = str.length() - 1___		while (beginIndex <= endIndex && Character.isWhitespace(str.charAt(beginIndex))) {_			beginIndex++__		}__		while (endIndex > beginIndex && Character.isWhitespace(str.charAt(endIndex))) {_			endIndex--__		}__		return str.substring(beginIndex, endIndex + 1)__	};trim,leading,and,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,int,begin,index,0,int,end,index,str,length,1,while,begin,index,end,index,character,is,whitespace,str,char,at,begin,index,begin,index,while,end,index,begin,index,character,is,whitespace,str,char,at,end,index,end,index,return,str,substring,begin,index,end,index,1
StringUtils -> public static String trimWhitespace(String str);1550238935;Trim leading and trailing whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		int beginIndex = 0__		int endIndex = str.length() - 1___		while (beginIndex <= endIndex && Character.isWhitespace(str.charAt(beginIndex))) {_			beginIndex++__		}__		while (endIndex > beginIndex && Character.isWhitespace(str.charAt(endIndex))) {_			endIndex--__		}__		return str.substring(beginIndex, endIndex + 1)__	};trim,leading,and,trailing,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,whitespace,string,str,if,has,length,str,return,str,int,begin,index,0,int,end,index,str,length,1,while,begin,index,end,index,character,is,whitespace,str,char,at,begin,index,begin,index,while,end,index,begin,index,character,is,whitespace,str,char,at,end,index,end,index,return,str,substring,begin,index,end,index,1
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1495868221;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1496243689;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1496259743;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1496837955;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1499270197;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1508667152;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1508675477;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1508843807;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1516903831;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1519295386;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1519308837;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the delimiter_providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the {@code Properties}._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1519588127;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the delimiter_providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the {@code Properties}._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1522332352;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the delimiter_providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the {@code Properties}._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1525166194;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the delimiter_providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the {@code Properties}._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1530188116;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the delimiter_providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the {@code Properties}._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1531843079;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the delimiter_providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the {@code Properties}._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1531905026;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the delimiter_providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the {@code Properties}._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1533557519;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the delimiter_providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the {@code Properties}._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1533602820;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the delimiter_providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the {@code Properties}._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1535316501;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the delimiter_providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the {@code Properties}._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1550237113;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the delimiter_providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the {@code Properties}._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1550238935;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the delimiter_providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the {@code Properties}._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1328020251;Trim all occurences of the supplied leading character from the given String._@param str the String to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed String;public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurences,of,the,supplied,leading,character,from,the,given,string,param,str,the,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1337236962;Trim all occurences of the supplied leading character from the given String._@param str the String to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed String;public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurences,of,the,supplied,leading,character,from,the,given,string,param,str,the,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1356735495;Trim all occurences of the supplied leading character from the given String._@param str the String to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed String;public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurences,of,the,supplied,leading,character,from,the,given,string,param,str,the,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1367955086;Trim all occurences of the supplied leading character from the given String._@param str the String to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed String;public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurences,of,the,supplied,leading,character,from,the,given,string,param,str,the,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1380921248;Trim all occurences of the supplied leading character from the given String._@param str the String to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed String;public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurences,of,the,supplied,leading,character,from,the,given,string,param,str,the,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1382750743;Trim all occurences of the supplied leading character from the given String._@param str the String to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed String;public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurences,of,the,supplied,leading,character,from,the,given,string,param,str,the,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1385423968;Trim all occurrences of the supplied leading character from the given String._@param str the String to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed String;public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,string,param,str,the,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1400189212;Trim all occurrences of the supplied leading character from the given String._@param str the String to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed String;public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,string,param,str,the,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1400531359;Trim all occurrences of the supplied leading character from the given String._@param str the String to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed String;public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,string,param,str,the,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1402676350;Trim all occurrences of the supplied leading character from the given String._@param str the String to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed String;public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,string,param,str,the,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1426267150;Trim all occurrences of the supplied leading character from the given String._@param str the String to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed String;public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,string,param,str,the,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1429034538;Trim all occurrences of the supplied leading character from the given String._@param str the String to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed String;public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,string,param,str,the,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1429034756;Trim all occurrences of the supplied leading character from the given {@code String}._@param str the {@code String} to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed {@code String};public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,code,string,param,str,the,code,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1431006895;Trim all occurrences of the supplied leading character from the given {@code String}._@param str the {@code String} to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed {@code String};public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,code,string,param,str,the,code,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1431007368;Trim all occurrences of the supplied leading character from the given {@code String}._@param str the {@code String} to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed {@code String};public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,code,string,param,str,the,code,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1449489126;Trim all occurrences of the supplied leading character from the given {@code String}._@param str the {@code String} to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed {@code String};public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,code,string,param,str,the,code,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1467730834;Trim all occurrences of the supplied leading character from the given {@code String}._@param str the {@code String} to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed {@code String};public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,code,string,param,str,the,code,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1472128018;Trim all occurrences of the supplied leading character from the given {@code String}._@param str the {@code String} to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed {@code String};public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,code,string,param,str,the,code,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1472202842;Trim all occurrences of the supplied leading character from the given {@code String}._@param str the {@code String} to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed {@code String};public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,code,string,param,str,the,code,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1473942665;Trim all occurrences of the supplied leading character from the given {@code String}._@param str the {@code String} to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed {@code String};public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,code,string,param,str,the,code,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1484248946;Trim all occurrences of the supplied leading character from the given {@code String}._@param str the {@code String} to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed {@code String};public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,code,string,param,str,the,code,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1484260238;Trim all occurrences of the supplied leading character from the given {@code String}._@param str the {@code String} to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed {@code String};public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,code,string,param,str,the,code,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1484694546;Trim all occurrences of the supplied leading character from the given {@code String}._@param str the {@code String} to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed {@code String};public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,code,string,param,str,the,code,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1487760984;Trim all occurrences of the supplied leading character from the given {@code String}._@param str the {@code String} to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed {@code String};public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,code,string,param,str,the,code,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1487778834;Trim all occurrences of the supplied leading character from the given {@code String}._@param str the {@code String} to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed {@code String};public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,code,string,param,str,the,code,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1491898314;Trim all occurrences of the supplied leading character from the given {@code String}._@param str the {@code String} to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed {@code String};public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,code,string,param,str,the,code,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1491903650;Trim all occurrences of the supplied leading character from the given {@code String}._@param str the {@code String} to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed {@code String};public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,code,string,param,str,the,code,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1495868221;Trim all occurrences of the supplied leading character from the given {@code String}._@param str the {@code String} to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed {@code String};public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,code,string,param,str,the,code,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1496243689;Trim all occurrences of the supplied leading character from the given {@code String}._@param str the {@code String} to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed {@code String};public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,code,string,param,str,the,code,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1496259743;Trim all occurrences of the supplied leading character from the given {@code String}._@param str the {@code String} to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed {@code String};public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,code,string,param,str,the,code,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1496837955;Trim all occurrences of the supplied leading character from the given {@code String}._@param str the {@code String} to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed {@code String};public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,code,string,param,str,the,code,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1499270197;Trim all occurrences of the supplied leading character from the given {@code String}._@param str the {@code String} to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed {@code String};public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,code,string,param,str,the,code,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1508667152;Trim all occurrences of the supplied leading character from the given {@code String}._@param str the {@code String} to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed {@code String};public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,code,string,param,str,the,code,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1508675477;Trim all occurrences of the supplied leading character from the given {@code String}._@param str the {@code String} to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed {@code String};public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,code,string,param,str,the,code,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1508843807;Trim all occurrences of the supplied leading character from the given {@code String}._@param str the {@code String} to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed {@code String};public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,code,string,param,str,the,code,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1516903831;Trim all occurrences of the supplied leading character from the given {@code String}._@param str the {@code String} to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed {@code String};public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,code,string,param,str,the,code,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1519295386;Trim all occurrences of the supplied leading character from the given {@code String}._@param str the {@code String} to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed {@code String};public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,code,string,param,str,the,code,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1519308837;Trim all occurrences of the supplied leading character from the given {@code String}._@param str the {@code String} to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed {@code String};public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,code,string,param,str,the,code,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1519588127;Trim all occurrences of the supplied leading character from the given {@code String}._@param str the {@code String} to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed {@code String};public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,code,string,param,str,the,code,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1522332352;Trim all occurrences of the supplied leading character from the given {@code String}._@param str the {@code String} to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed {@code String};public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,code,string,param,str,the,code,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1525166194;Trim all occurrences of the supplied leading character from the given {@code String}._@param str the {@code String} to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed {@code String};public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,code,string,param,str,the,code,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1530188116;Trim all occurrences of the supplied leading character from the given {@code String}._@param str the {@code String} to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed {@code String};public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,code,string,param,str,the,code,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1531843079;Trim all occurrences of the supplied leading character from the given {@code String}._@param str the {@code String} to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed {@code String};public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,code,string,param,str,the,code,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1531905026;Trim all occurrences of the supplied leading character from the given {@code String}._@param str the {@code String} to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed {@code String};public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,code,string,param,str,the,code,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1533557519;Trim all occurrences of the supplied leading character from the given {@code String}._@param str the {@code String} to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed {@code String};public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,code,string,param,str,the,code,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1533602820;Trim all occurrences of the supplied leading character from the given {@code String}._@param str the {@code String} to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed {@code String};public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,code,string,param,str,the,code,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1535316501;Trim all occurrences of the supplied leading character from the given {@code String}._@param str the {@code String} to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed {@code String};public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,code,string,param,str,the,code,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1550237113;Trim all occurrences of the supplied leading character from the given {@code String}._@param str the {@code String} to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed {@code String};public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,code,string,param,str,the,code,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingCharacter(String str, char leadingCharacter);1550238935;Trim all occurrences of the supplied leading character from the given {@code String}._@param str the {@code String} to check_@param leadingCharacter the leading character to be trimmed_@return the trimmed {@code String};public static String trimLeadingCharacter(String str, char leadingCharacter) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,all,occurrences,of,the,supplied,leading,character,from,the,given,code,string,param,str,the,code,string,to,check,param,leading,character,the,leading,character,to,be,trimmed,return,the,trimmed,code,string;public,static,string,trim,leading,character,string,str,char,leading,character,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,sb,char,at,0,leading,character,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString( 			@Nullable Collection<?> coll, String delim, String prefix, String suffix);1496837955;Convert a {@link Collection} to a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@param prefix the {@code String} to start each element with_@param suffix the {@code String} to end each element with_@return the delimited {@code String};public static String collectionToDelimitedString(_			@Nullable Collection<?> coll, String delim, String prefix, String suffix) {__		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}__		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convert,a,link,collection,to,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,param,prefix,the,code,string,to,start,each,element,with,param,suffix,the,code,string,to,end,each,element,with,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,nullable,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString( 			@Nullable Collection<?> coll, String delim, String prefix, String suffix);1499270197;Convert a {@link Collection} to a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@param prefix the {@code String} to start each element with_@param suffix the {@code String} to end each element with_@return the delimited {@code String};public static String collectionToDelimitedString(_			@Nullable Collection<?> coll, String delim, String prefix, String suffix) {__		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}__		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convert,a,link,collection,to,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,param,prefix,the,code,string,to,start,each,element,with,param,suffix,the,code,string,to,end,each,element,with,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,nullable,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString( 			@Nullable Collection<?> coll, String delim, String prefix, String suffix);1508667152;Convert a {@link Collection} to a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@param prefix the {@code String} to start each element with_@param suffix the {@code String} to end each element with_@return the delimited {@code String};public static String collectionToDelimitedString(_			@Nullable Collection<?> coll, String delim, String prefix, String suffix) {__		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}__		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convert,a,link,collection,to,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,param,prefix,the,code,string,to,start,each,element,with,param,suffix,the,code,string,to,end,each,element,with,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,nullable,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString( 			@Nullable Collection<?> coll, String delim, String prefix, String suffix);1508675477;Convert a {@link Collection} to a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@param prefix the {@code String} to start each element with_@param suffix the {@code String} to end each element with_@return the delimited {@code String};public static String collectionToDelimitedString(_			@Nullable Collection<?> coll, String delim, String prefix, String suffix) {__		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}__		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convert,a,link,collection,to,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,param,prefix,the,code,string,to,start,each,element,with,param,suffix,the,code,string,to,end,each,element,with,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,nullable,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString( 			@Nullable Collection<?> coll, String delim, String prefix, String suffix);1508843807;Convert a {@link Collection} to a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@param prefix the {@code String} to start each element with_@param suffix the {@code String} to end each element with_@return the delimited {@code String};public static String collectionToDelimitedString(_			@Nullable Collection<?> coll, String delim, String prefix, String suffix) {__		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}__		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convert,a,link,collection,to,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,param,prefix,the,code,string,to,start,each,element,with,param,suffix,the,code,string,to,end,each,element,with,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,nullable,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString( 			@Nullable Collection<?> coll, String delim, String prefix, String suffix);1516903831;Convert a {@link Collection} to a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@param prefix the {@code String} to start each element with_@param suffix the {@code String} to end each element with_@return the delimited {@code String};public static String collectionToDelimitedString(_			@Nullable Collection<?> coll, String delim, String prefix, String suffix) {__		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}__		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convert,a,link,collection,to,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,param,prefix,the,code,string,to,start,each,element,with,param,suffix,the,code,string,to,end,each,element,with,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,nullable,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString( 			@Nullable Collection<?> coll, String delim, String prefix, String suffix);1519295386;Convert a {@link Collection} to a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@param prefix the {@code String} to start each element with_@param suffix the {@code String} to end each element with_@return the delimited {@code String};public static String collectionToDelimitedString(_			@Nullable Collection<?> coll, String delim, String prefix, String suffix) {__		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}__		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convert,a,link,collection,to,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,param,prefix,the,code,string,to,start,each,element,with,param,suffix,the,code,string,to,end,each,element,with,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,nullable,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString( 			@Nullable Collection<?> coll, String delim, String prefix, String suffix);1519308837;Convert a {@link Collection} to a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@param prefix the {@code String} to start each element with_@param suffix the {@code String} to end each element with_@return the delimited {@code String};public static String collectionToDelimitedString(_			@Nullable Collection<?> coll, String delim, String prefix, String suffix) {__		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}__		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convert,a,link,collection,to,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,param,prefix,the,code,string,to,start,each,element,with,param,suffix,the,code,string,to,end,each,element,with,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,nullable,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString( 			@Nullable Collection<?> coll, String delim, String prefix, String suffix);1519588127;Convert a {@link Collection} to a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@param prefix the {@code String} to start each element with_@param suffix the {@code String} to end each element with_@return the delimited {@code String};public static String collectionToDelimitedString(_			@Nullable Collection<?> coll, String delim, String prefix, String suffix) {__		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}__		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convert,a,link,collection,to,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,param,prefix,the,code,string,to,start,each,element,with,param,suffix,the,code,string,to,end,each,element,with,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,nullable,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString( 			@Nullable Collection<?> coll, String delim, String prefix, String suffix);1522332352;Convert a {@link Collection} to a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@param prefix the {@code String} to start each element with_@param suffix the {@code String} to end each element with_@return the delimited {@code String};public static String collectionToDelimitedString(_			@Nullable Collection<?> coll, String delim, String prefix, String suffix) {__		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}__		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convert,a,link,collection,to,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,param,prefix,the,code,string,to,start,each,element,with,param,suffix,the,code,string,to,end,each,element,with,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,nullable,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString( 			@Nullable Collection<?> coll, String delim, String prefix, String suffix);1525166194;Convert a {@link Collection} to a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@param prefix the {@code String} to start each element with_@param suffix the {@code String} to end each element with_@return the delimited {@code String};public static String collectionToDelimitedString(_			@Nullable Collection<?> coll, String delim, String prefix, String suffix) {__		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}__		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convert,a,link,collection,to,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,param,prefix,the,code,string,to,start,each,element,with,param,suffix,the,code,string,to,end,each,element,with,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,nullable,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString( 			@Nullable Collection<?> coll, String delim, String prefix, String suffix);1530188116;Convert a {@link Collection} to a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@param prefix the {@code String} to start each element with_@param suffix the {@code String} to end each element with_@return the delimited {@code String};public static String collectionToDelimitedString(_			@Nullable Collection<?> coll, String delim, String prefix, String suffix) {__		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}__		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convert,a,link,collection,to,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,param,prefix,the,code,string,to,start,each,element,with,param,suffix,the,code,string,to,end,each,element,with,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,nullable,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString( 			@Nullable Collection<?> coll, String delim, String prefix, String suffix);1531843079;Convert a {@link Collection} to a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@param prefix the {@code String} to start each element with_@param suffix the {@code String} to end each element with_@return the delimited {@code String};public static String collectionToDelimitedString(_			@Nullable Collection<?> coll, String delim, String prefix, String suffix) {__		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}__		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convert,a,link,collection,to,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,param,prefix,the,code,string,to,start,each,element,with,param,suffix,the,code,string,to,end,each,element,with,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,nullable,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString( 			@Nullable Collection<?> coll, String delim, String prefix, String suffix);1531905026;Convert a {@link Collection} to a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@param prefix the {@code String} to start each element with_@param suffix the {@code String} to end each element with_@return the delimited {@code String};public static String collectionToDelimitedString(_			@Nullable Collection<?> coll, String delim, String prefix, String suffix) {__		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}__		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convert,a,link,collection,to,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,param,prefix,the,code,string,to,start,each,element,with,param,suffix,the,code,string,to,end,each,element,with,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,nullable,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString( 			@Nullable Collection<?> coll, String delim, String prefix, String suffix);1533557519;Convert a {@link Collection} to a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert (potentially {@code null} or empty)_@param delim the delimiter to use (typically a ",")_@param prefix the {@code String} to start each element with_@param suffix the {@code String} to end each element with_@return the delimited {@code String};public static String collectionToDelimitedString(_			@Nullable Collection<?> coll, String delim, String prefix, String suffix) {__		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}__		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convert,a,link,collection,to,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,potentially,code,null,or,empty,param,delim,the,delimiter,to,use,typically,a,param,prefix,the,code,string,to,start,each,element,with,param,suffix,the,code,string,to,end,each,element,with,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,nullable,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString( 			@Nullable Collection<?> coll, String delim, String prefix, String suffix);1533602820;Convert a {@link Collection} to a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert (potentially {@code null} or empty)_@param delim the delimiter to use (typically a ",")_@param prefix the {@code String} to start each element with_@param suffix the {@code String} to end each element with_@return the delimited {@code String};public static String collectionToDelimitedString(_			@Nullable Collection<?> coll, String delim, String prefix, String suffix) {__		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}__		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convert,a,link,collection,to,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,potentially,code,null,or,empty,param,delim,the,delimiter,to,use,typically,a,param,prefix,the,code,string,to,start,each,element,with,param,suffix,the,code,string,to,end,each,element,with,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,nullable,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString( 			@Nullable Collection<?> coll, String delim, String prefix, String suffix);1535316501;Convert a {@link Collection} to a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert (potentially {@code null} or empty)_@param delim the delimiter to use (typically a ",")_@param prefix the {@code String} to start each element with_@param suffix the {@code String} to end each element with_@return the delimited {@code String};public static String collectionToDelimitedString(_			@Nullable Collection<?> coll, String delim, String prefix, String suffix) {__		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}__		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convert,a,link,collection,to,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,potentially,code,null,or,empty,param,delim,the,delimiter,to,use,typically,a,param,prefix,the,code,string,to,start,each,element,with,param,suffix,the,code,string,to,end,each,element,with,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,nullable,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString( 			@Nullable Collection<?> coll, String delim, String prefix, String suffix);1550237113;Convert a {@link Collection} to a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert (potentially {@code null} or empty)_@param delim the delimiter to use (typically a ",")_@param prefix the {@code String} to start each element with_@param suffix the {@code String} to end each element with_@return the delimited {@code String};public static String collectionToDelimitedString(_			@Nullable Collection<?> coll, String delim, String prefix, String suffix) {__		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}__		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convert,a,link,collection,to,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,potentially,code,null,or,empty,param,delim,the,delimiter,to,use,typically,a,param,prefix,the,code,string,to,start,each,element,with,param,suffix,the,code,string,to,end,each,element,with,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,nullable,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString( 			@Nullable Collection<?> coll, String delim, String prefix, String suffix);1550238935;Convert a {@link Collection} to a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert (potentially {@code null} or empty)_@param delim the delimiter to use (typically a ",")_@param prefix the {@code String} to start each element with_@param suffix the {@code String} to end each element with_@return the delimited {@code String};public static String collectionToDelimitedString(_			@Nullable Collection<?> coll, String delim, String prefix, String suffix) {__		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}__		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convert,a,link,collection,to,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,potentially,code,null,or,empty,param,delim,the,delimiter,to,use,typically,a,param,prefix,the,code,string,to,start,each,element,with,param,suffix,the,code,string,to,end,each,element,with,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,nullable,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> @Deprecated 	@Nullable 	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2);1519308837;Merge the given {@code String} arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null})_@deprecated as of 4.3.15, in favor of manual merging via {@link LinkedHashSet}_(with every entry included at most once, even entries within the first array);@Deprecated_	@Nullable_	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		List<String> result = new ArrayList<>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,code,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null,deprecated,as,of,4,3,15,in,favor,of,manual,merging,via,link,linked,hash,set,with,every,entry,included,at,most,once,even,entries,within,the,first,array;deprecated,nullable,public,static,string,merge,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> @Deprecated 	@Nullable 	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2);1519588127;Merge the given {@code String} arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null})_@deprecated as of 4.3.15, in favor of manual merging via {@link LinkedHashSet}_(with every entry included at most once, even entries within the first array);@Deprecated_	@Nullable_	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		List<String> result = new ArrayList<>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,code,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null,deprecated,as,of,4,3,15,in,favor,of,manual,merging,via,link,linked,hash,set,with,every,entry,included,at,most,once,even,entries,within,the,first,array;deprecated,nullable,public,static,string,merge,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> @Deprecated 	@Nullable 	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2);1522332352;Merge the given {@code String} arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null})_@deprecated as of 4.3.15, in favor of manual merging via {@link LinkedHashSet}_(with every entry included at most once, even entries within the first array);@Deprecated_	@Nullable_	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		List<String> result = new ArrayList<>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,code,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null,deprecated,as,of,4,3,15,in,favor,of,manual,merging,via,link,linked,hash,set,with,every,entry,included,at,most,once,even,entries,within,the,first,array;deprecated,nullable,public,static,string,merge,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> @Deprecated 	@Nullable 	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2);1525166194;Merge the given {@code String} arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null})_@deprecated as of 4.3.15, in favor of manual merging via {@link LinkedHashSet}_(with every entry included at most once, even entries within the first array);@Deprecated_	@Nullable_	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		List<String> result = new ArrayList<>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,code,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null,deprecated,as,of,4,3,15,in,favor,of,manual,merging,via,link,linked,hash,set,with,every,entry,included,at,most,once,even,entries,within,the,first,array;deprecated,nullable,public,static,string,merge,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> @Deprecated 	@Nullable 	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2);1530188116;Merge the given {@code String} arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null})_@deprecated as of 4.3.15, in favor of manual merging via {@link LinkedHashSet}_(with every entry included at most once, even entries within the first array);@Deprecated_	@Nullable_	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		List<String> result = new ArrayList<>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,code,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null,deprecated,as,of,4,3,15,in,favor,of,manual,merging,via,link,linked,hash,set,with,every,entry,included,at,most,once,even,entries,within,the,first,array;deprecated,nullable,public,static,string,merge,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> @Deprecated 	@Nullable 	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2);1531843079;Merge the given {@code String} arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null})_@deprecated as of 4.3.15, in favor of manual merging via {@link LinkedHashSet}_(with every entry included at most once, even entries within the first array);@Deprecated_	@Nullable_	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		List<String> result = new ArrayList<>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,code,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null,deprecated,as,of,4,3,15,in,favor,of,manual,merging,via,link,linked,hash,set,with,every,entry,included,at,most,once,even,entries,within,the,first,array;deprecated,nullable,public,static,string,merge,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> @Deprecated 	@Nullable 	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2);1531905026;Merge the given {@code String} arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null})_@deprecated as of 4.3.15, in favor of manual merging via {@link LinkedHashSet}_(with every entry included at most once, even entries within the first array);@Deprecated_	@Nullable_	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		List<String> result = new ArrayList<>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,code,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null,deprecated,as,of,4,3,15,in,favor,of,manual,merging,via,link,linked,hash,set,with,every,entry,included,at,most,once,even,entries,within,the,first,array;deprecated,nullable,public,static,string,merge,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> @Deprecated 	@Nullable 	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2);1533557519;Merge the given {@code String} arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null})_@deprecated as of 4.3.15, in favor of manual merging via {@link LinkedHashSet}_(with every entry included at most once, even entries within the first array);@Deprecated_	@Nullable_	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		List<String> result = new ArrayList<>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,code,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null,deprecated,as,of,4,3,15,in,favor,of,manual,merging,via,link,linked,hash,set,with,every,entry,included,at,most,once,even,entries,within,the,first,array;deprecated,nullable,public,static,string,merge,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> @Deprecated 	@Nullable 	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2);1533602820;Merge the given {@code String} arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null})_@deprecated as of 4.3.15, in favor of manual merging via {@link LinkedHashSet}_(with every entry included at most once, even entries within the first array);@Deprecated_	@Nullable_	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		List<String> result = new ArrayList<>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,code,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null,deprecated,as,of,4,3,15,in,favor,of,manual,merging,via,link,linked,hash,set,with,every,entry,included,at,most,once,even,entries,within,the,first,array;deprecated,nullable,public,static,string,merge,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> @Deprecated 	@Nullable 	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2);1535316501;Merge the given {@code String} arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null})_@deprecated as of 4.3.15, in favor of manual merging via {@link LinkedHashSet}_(with every entry included at most once, even entries within the first array);@Deprecated_	@Nullable_	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		List<String> result = new ArrayList<>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,code,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null,deprecated,as,of,4,3,15,in,favor,of,manual,merging,via,link,linked,hash,set,with,every,entry,included,at,most,once,even,entries,within,the,first,array;deprecated,nullable,public,static,string,merge,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> @Deprecated 	@Nullable 	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2);1550237113;Merge the given {@code String} arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null})_@deprecated as of 4.3.15, in favor of manual merging via {@link LinkedHashSet}_(with every entry included at most once, even entries within the first array);@Deprecated_	@Nullable_	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		List<String> result = new ArrayList<>(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,code,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null,deprecated,as,of,4,3,15,in,favor,of,manual,merging,via,link,linked,hash,set,with,every,entry,included,at,most,once,even,entries,within,the,first,array;deprecated,nullable,public,static,string,merge,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> @Deprecated 	@Nullable 	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2);1550238935;Merge the given {@code String} arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null})_@deprecated as of 4.3.15, in favor of manual merging via {@link LinkedHashSet}_(with every entry included at most once, even entries within the first array);@Deprecated_	@Nullable_	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		List<String> result = new ArrayList<>(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,code,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null,deprecated,as,of,4,3,15,in,favor,of,manual,merging,via,link,linked,hash,set,with,every,entry,included,at,most,once,even,entries,within,the,first,array;deprecated,nullable,public,static,string,merge,string,arrays,nullable,string,array1,nullable,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> public static boolean hasText(String str);1328020251;Check whether the given String has actual text._More specifically, returns <code>true</code> if the string not <code>null</code>,_its length is greater than 0, and it contains at least one non-whitespace character._@param str the String to check (may be <code>null</code>)_@return <code>true</code> if the String is not <code>null</code>, its length is_greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(String str) {_		return hasText((CharSequence) str)__	};check,whether,the,given,string,has,actual,text,more,specifically,returns,code,true,code,if,the,string,not,code,null,code,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,string,to,check,may,be,code,null,code,return,code,true,code,if,the,string,is,not,code,null,code,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,string,str,return,has,text,char,sequence,str
StringUtils -> public static boolean hasText(String str);1337236962;Check whether the given String has actual text._More specifically, returns <code>true</code> if the string not <code>null</code>,_its length is greater than 0, and it contains at least one non-whitespace character._@param str the String to check (may be <code>null</code>)_@return <code>true</code> if the String is not <code>null</code>, its length is_greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(String str) {_		return hasText((CharSequence) str)__	};check,whether,the,given,string,has,actual,text,more,specifically,returns,code,true,code,if,the,string,not,code,null,code,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,string,to,check,may,be,code,null,code,return,code,true,code,if,the,string,is,not,code,null,code,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,string,str,return,has,text,char,sequence,str
StringUtils -> public static boolean hasText(String str);1356735495;Check whether the given String has actual text._More specifically, returns {@code true} if the string not {@code null},_its length is greater than 0, and it contains at least one non-whitespace character._@param str the String to check (may be {@code null})_@return {@code true} if the String is not {@code null}, its length is_greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(String str) {_		return hasText((CharSequence) str)__	};check,whether,the,given,string,has,actual,text,more,specifically,returns,code,true,if,the,string,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,string,to,check,may,be,code,null,return,code,true,if,the,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,string,str,return,has,text,char,sequence,str
StringUtils -> public static boolean hasText(String str);1367955086;Check whether the given String has actual text._More specifically, returns {@code true} if the string not {@code null},_its length is greater than 0, and it contains at least one non-whitespace character._@param str the String to check (may be {@code null})_@return {@code true} if the String is not {@code null}, its length is_greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(String str) {_		return hasText((CharSequence) str)__	};check,whether,the,given,string,has,actual,text,more,specifically,returns,code,true,if,the,string,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,string,to,check,may,be,code,null,return,code,true,if,the,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,string,str,return,has,text,char,sequence,str
StringUtils -> public static boolean hasText(String str);1380921248;Check whether the given String has actual text._More specifically, returns {@code true} if the string not {@code null},_its length is greater than 0, and it contains at least one non-whitespace character._@param str the String to check (may be {@code null})_@return {@code true} if the String is not {@code null}, its length is_greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(String str) {_		return hasText((CharSequence) str)__	};check,whether,the,given,string,has,actual,text,more,specifically,returns,code,true,if,the,string,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,string,to,check,may,be,code,null,return,code,true,if,the,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,string,str,return,has,text,char,sequence,str
StringUtils -> public static boolean hasText(String str);1382750743;Check whether the given String has actual text._More specifically, returns {@code true} if the string not {@code null},_its length is greater than 0, and it contains at least one non-whitespace character._@param str the String to check (may be {@code null})_@return {@code true} if the String is not {@code null}, its length is_greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(String str) {_		return hasText((CharSequence) str)__	};check,whether,the,given,string,has,actual,text,more,specifically,returns,code,true,if,the,string,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,string,to,check,may,be,code,null,return,code,true,if,the,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,string,str,return,has,text,char,sequence,str
StringUtils -> public static boolean hasText(String str);1385423968;Check whether the given String has actual text._More specifically, returns {@code true} if the string not {@code null},_its length is greater than 0, and it contains at least one non-whitespace character._@param str the String to check (may be {@code null})_@return {@code true} if the String is not {@code null}, its length is_greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(String str) {_		return hasText((CharSequence) str)__	};check,whether,the,given,string,has,actual,text,more,specifically,returns,code,true,if,the,string,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,string,to,check,may,be,code,null,return,code,true,if,the,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,string,str,return,has,text,char,sequence,str
StringUtils -> public static boolean hasText(String str);1400189212;Check whether the given String has actual text._More specifically, returns {@code true} if the string not {@code null},_its length is greater than 0, and it contains at least one non-whitespace character._@param str the String to check (may be {@code null})_@return {@code true} if the String is not {@code null}, its length is_greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(String str) {_		return hasText((CharSequence) str)__	};check,whether,the,given,string,has,actual,text,more,specifically,returns,code,true,if,the,string,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,string,to,check,may,be,code,null,return,code,true,if,the,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,string,str,return,has,text,char,sequence,str
StringUtils -> public static boolean hasText(String str);1400531359;Check whether the given String has actual text._More specifically, returns {@code true} if the string not {@code null},_its length is greater than 0, and it contains at least one non-whitespace character._@param str the String to check (may be {@code null})_@return {@code true} if the String is not {@code null}, its length is_greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(String str) {_		return hasText((CharSequence) str)__	};check,whether,the,given,string,has,actual,text,more,specifically,returns,code,true,if,the,string,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,string,to,check,may,be,code,null,return,code,true,if,the,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,string,str,return,has,text,char,sequence,str
StringUtils -> public static boolean hasText(String str);1402676350;Check whether the given String has actual text._More specifically, returns {@code true} if the string not {@code null},_its length is greater than 0, and it contains at least one non-whitespace character._@param str the String to check (may be {@code null})_@return {@code true} if the String is not {@code null}, its length is_greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(String str) {_		return hasText((CharSequence) str)__	};check,whether,the,given,string,has,actual,text,more,specifically,returns,code,true,if,the,string,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,string,to,check,may,be,code,null,return,code,true,if,the,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,string,str,return,has,text,char,sequence,str
StringUtils -> public static boolean hasText(String str);1426267150;Check whether the given String has actual text._More specifically, returns {@code true} if the string not {@code null},_its length is greater than 0, and it contains at least one non-whitespace character._@param str the String to check (may be {@code null})_@return {@code true} if the String is not {@code null}, its length is_greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(String str) {_		return hasText((CharSequence) str)__	};check,whether,the,given,string,has,actual,text,more,specifically,returns,code,true,if,the,string,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,string,to,check,may,be,code,null,return,code,true,if,the,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,string,str,return,has,text,char,sequence,str
StringUtils -> public static boolean hasText(String str);1429034538;Check whether the given String has actual text._More specifically, returns {@code true} if the string not {@code null},_its length is greater than 0, and it contains at least one non-whitespace character._@param str the String to check (may be {@code null})_@return {@code true} if the String is not {@code null}, its length is_greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(String str) {_		return hasText((CharSequence) str)__	};check,whether,the,given,string,has,actual,text,more,specifically,returns,code,true,if,the,string,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,string,to,check,may,be,code,null,return,code,true,if,the,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,string,str,return,has,text,char,sequence,str
StringUtils -> public static boolean hasText(String str);1429034756;Check whether the given {@code String} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code String} is not {@code null}, its length is greater than 0,_and it contains at least one non-whitespace character._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null}, its_length is greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(String str) {_		return hasText((CharSequence) str)__	};check,whether,the,given,code,string,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,string,str,return,has,text,char,sequence,str
StringUtils -> public static boolean hasText(String str);1431006895;Check whether the given {@code String} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code String} is not {@code null}, its length is greater than 0,_and it contains at least one non-whitespace character._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null}, its_length is greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(String str) {_		return hasText((CharSequence) str)__	};check,whether,the,given,code,string,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,string,str,return,has,text,char,sequence,str
StringUtils -> public static boolean hasText(String str);1431007368;Check whether the given {@code String} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code String} is not {@code null}, its length is greater than 0,_and it contains at least one non-whitespace character._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null}, its_length is greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(String str) {_		return hasText((CharSequence) str)__	};check,whether,the,given,code,string,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,string,str,return,has,text,char,sequence,str
StringUtils -> public static boolean hasText(String str);1449489126;Check whether the given {@code String} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code String} is not {@code null}, its length is greater than 0,_and it contains at least one non-whitespace character._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null}, its_length is greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(String str) {_		return hasText((CharSequence) str)__	};check,whether,the,given,code,string,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,string,str,return,has,text,char,sequence,str
StringUtils -> public static boolean hasText(String str);1467730834;Check whether the given {@code String} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code String} is not {@code null}, its length is greater than 0,_and it contains at least one non-whitespace character._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null}, its_length is greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(String str) {_		return hasText((CharSequence) str)__	};check,whether,the,given,code,string,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,string,str,return,has,text,char,sequence,str
StringUtils -> public static boolean hasText(String str);1472128018;Check whether the given {@code String} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code String} is not {@code null}, its length is greater than 0,_and it contains at least one non-whitespace character._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null}, its_length is greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(String str) {_		return hasText((CharSequence) str)__	};check,whether,the,given,code,string,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,string,str,return,has,text,char,sequence,str
StringUtils -> public static boolean hasText(String str);1472202842;Check whether the given {@code String} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code String} is not {@code null}, its length is greater than 0,_and it contains at least one non-whitespace character._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null}, its_length is greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(String str) {_		return hasText((CharSequence) str)__	};check,whether,the,given,code,string,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,string,str,return,has,text,char,sequence,str
StringUtils -> public static boolean hasText(String str);1473942665;Check whether the given {@code String} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code String} is not {@code null}, its length is greater than 0,_and it contains at least one non-whitespace character._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null}, its_length is greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(String str) {_		return hasText((CharSequence) str)__	};check,whether,the,given,code,string,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,string,str,return,has,text,char,sequence,str
StringUtils -> public static boolean hasText(String str);1484248946;Check whether the given {@code String} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code String} is not {@code null}, its length is greater than 0,_and it contains at least one non-whitespace character._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null}, its_length is greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(String str) {_		return hasText((CharSequence) str)__	};check,whether,the,given,code,string,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,string,str,return,has,text,char,sequence,str
StringUtils -> public static boolean hasText(String str);1484260238;Check whether the given {@code String} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code String} is not {@code null}, its length is greater than 0,_and it contains at least one non-whitespace character._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null}, its_length is greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(String str) {_		return hasText((CharSequence) str)__	};check,whether,the,given,code,string,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,string,str,return,has,text,char,sequence,str
StringUtils -> public static boolean hasText(String str);1484694546;Check whether the given {@code String} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code String} is not {@code null}, its length is greater than 0,_and it contains at least one non-whitespace character._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null}, its_length is greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(String str) {_		return hasText((CharSequence) str)__	};check,whether,the,given,code,string,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,string,str,return,has,text,char,sequence,str
StringUtils -> public static boolean hasText(String str);1487760984;Check whether the given {@code String} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code String} is not {@code null}, its length is greater than 0,_and it contains at least one non-whitespace character._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null}, its_length is greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(String str) {_		return hasText((CharSequence) str)__	};check,whether,the,given,code,string,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,string,str,return,has,text,char,sequence,str
StringUtils -> public static boolean hasText(String str);1487778834;Check whether the given {@code String} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code String} is not {@code null}, its length is greater than 0,_and it contains at least one non-whitespace character._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null}, its_length is greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(String str) {_		return hasText((CharSequence) str)__	};check,whether,the,given,code,string,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,string,str,return,has,text,char,sequence,str
StringUtils -> public static boolean hasText(String str);1491898314;Check whether the given {@code String} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code String} is not {@code null}, its length is greater than 0,_and it contains at least one non-whitespace character._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null}, its_length is greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(String str) {_		return hasText((CharSequence) str)__	};check,whether,the,given,code,string,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,string,str,return,has,text,char,sequence,str
StringUtils -> public static boolean hasText(String str);1491903650;Check whether the given {@code String} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code String} is not {@code null}, its length is greater than 0,_and it contains at least one non-whitespace character._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null}, its_length is greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(String str) {_		return hasText((CharSequence) str)__	};check,whether,the,given,code,string,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,string,str,return,has,text,char,sequence,str
StringUtils -> public static String[] tokenizeToStringArray(@Nullable String str, String delimiters);1496837955;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>Trims tokens and omits empty tokens._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(@Nullable String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,trims,tokens,and,omits,empty,tokens,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(@Nullable String str, String delimiters);1499270197;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>Trims tokens and omits empty tokens._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(@Nullable String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,trims,tokens,and,omits,empty,tokens,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(@Nullable String str, String delimiters);1508667152;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>Trims tokens and omits empty tokens._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(@Nullable String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,trims,tokens,and,omits,empty,tokens,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(@Nullable String str, String delimiters);1508675477;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>Trims tokens and omits empty tokens._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(@Nullable String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,trims,tokens,and,omits,empty,tokens,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(@Nullable String str, String delimiters);1508843807;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>Trims tokens and omits empty tokens._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(@Nullable String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,trims,tokens,and,omits,empty,tokens,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(@Nullable String str, String delimiters);1516903831;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>Trims tokens and omits empty tokens._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(@Nullable String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,trims,tokens,and,omits,empty,tokens,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(@Nullable String str, String delimiters);1519295386;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>Trims tokens and omits empty tokens._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(@Nullable String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,trims,tokens,and,omits,empty,tokens,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(@Nullable String str, String delimiters);1519308837;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>Trims tokens and omits empty tokens._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(@Nullable String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,trims,tokens,and,omits,empty,tokens,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(@Nullable String str, String delimiters);1519588127;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>Trims tokens and omits empty tokens._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(@Nullable String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,trims,tokens,and,omits,empty,tokens,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(@Nullable String str, String delimiters);1522332352;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>Trims tokens and omits empty tokens._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(@Nullable String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,trims,tokens,and,omits,empty,tokens,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(@Nullable String str, String delimiters);1525166194;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>Trims tokens and omits empty tokens._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(@Nullable String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,trims,tokens,and,omits,empty,tokens,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(@Nullable String str, String delimiters);1530188116;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>Trims tokens and omits empty tokens._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(@Nullable String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,trims,tokens,and,omits,empty,tokens,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(@Nullable String str, String delimiters);1531843079;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>Trims tokens and omits empty tokens._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(@Nullable String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,trims,tokens,and,omits,empty,tokens,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(@Nullable String str, String delimiters);1531905026;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>Trims tokens and omits empty tokens._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(@Nullable String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,trims,tokens,and,omits,empty,tokens,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(@Nullable String str, String delimiters);1533557519;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>Trims tokens and omits empty tokens._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize (potentially {@code null} or empty)_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(@Nullable String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,trims,tokens,and,omits,empty,tokens,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,potentially,code,null,or,empty,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(@Nullable String str, String delimiters);1533602820;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>Trims tokens and omits empty tokens._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize (potentially {@code null} or empty)_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(@Nullable String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,trims,tokens,and,omits,empty,tokens,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,potentially,code,null,or,empty,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(@Nullable String str, String delimiters);1535316501;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>Trims tokens and omits empty tokens._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize (potentially {@code null} or empty)_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(@Nullable String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,trims,tokens,and,omits,empty,tokens,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,potentially,code,null,or,empty,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(@Nullable String str, String delimiters);1550237113;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>Trims tokens and omits empty tokens._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize (potentially {@code null} or empty)_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(@Nullable String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,trims,tokens,and,omits,empty,tokens,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,potentially,code,null,or,empty,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(@Nullable String str, String delimiters);1550238935;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>Trims tokens and omits empty tokens._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize (potentially {@code null} or empty)_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(@Nullable String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,trims,tokens,and,omits,empty,tokens,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,potentially,code,null,or,empty,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static boolean isEmpty(@Nullable Object str);1495868221;Check whether the given {@code String} is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(@Nullable Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,code,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,nullable,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(@Nullable Object str);1496243689;Check whether the given {@code String} is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(@Nullable Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,code,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,nullable,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(@Nullable Object str);1496259743;Check whether the given {@code String} is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(@Nullable Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,code,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,nullable,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(@Nullable Object str);1496837955;Check whether the given {@code String} is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(@Nullable Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,code,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,nullable,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(@Nullable Object str);1499270197;Check whether the given {@code String} is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(@Nullable Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,code,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,nullable,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(@Nullable Object str);1508667152;Check whether the given {@code String} is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(@Nullable Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,code,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,nullable,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(@Nullable Object str);1508675477;Check whether the given {@code String} is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(@Nullable Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,code,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,nullable,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(@Nullable Object str);1508843807;Check whether the given {@code String} is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(@Nullable Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,code,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,nullable,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(@Nullable Object str);1516903831;Check whether the given {@code String} is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(@Nullable Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,code,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,nullable,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(@Nullable Object str);1519295386;Check whether the given {@code String} is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(@Nullable Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,code,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,nullable,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(@Nullable Object str);1519308837;Check whether the given {@code String} is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(@Nullable Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,code,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,nullable,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(@Nullable Object str);1519588127;Check whether the given {@code String} is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(@Nullable Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,code,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,nullable,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(@Nullable Object str);1522332352;Check whether the given {@code String} is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(@Nullable Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,code,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,nullable,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(@Nullable Object str);1525166194;Check whether the given {@code String} is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(@Nullable Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,code,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,nullable,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(@Nullable Object str);1530188116;Check whether the given {@code String} is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(@Nullable Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,code,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,nullable,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(@Nullable Object str);1531843079;Check whether the given {@code String} is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(@Nullable Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,code,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,nullable,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(@Nullable Object str);1531905026;Check whether the given {@code String} is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(@Nullable Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,code,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,nullable,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(@Nullable Object str);1533557519;Check whether the given {@code String} is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(@Nullable Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,code,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,nullable,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(@Nullable Object str);1533602820;Check whether the given {@code String} is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(@Nullable Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,code,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,nullable,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(@Nullable Object str);1535316501;Check whether the given {@code String} is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(@Nullable Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,code,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,nullable,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(@Nullable Object str);1550237113;Check whether the given {@code String} is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(@Nullable Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,code,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,nullable,object,str,return,str,null,equals,str
StringUtils -> public static boolean isEmpty(@Nullable Object str);1550238935;Check whether the given {@code String} is empty._<p>This method accepts any Object as an argument, comparing it to_{@code null} and the empty String. As a consequence, this method_will never return {@code true} for a non-null non-String object._<p>The Object signature is useful for general attribute handling code_that commonly deals with Strings but generally has to iterate over_Objects since attributes may e.g. be primitive value objects as well._@param str the candidate String_@since 3.2.1;public static boolean isEmpty(@Nullable Object str) {_		return (str == null || "".equals(str))__	};check,whether,the,given,code,string,is,empty,p,this,method,accepts,any,object,as,an,argument,comparing,it,to,code,null,and,the,empty,string,as,a,consequence,this,method,will,never,return,code,true,for,a,non,null,non,string,object,p,the,object,signature,is,useful,for,general,attribute,handling,code,that,commonly,deals,with,strings,but,generally,has,to,iterate,over,objects,since,attributes,may,e,g,be,primitive,value,objects,as,well,param,str,the,candidate,string,since,3,2,1;public,static,boolean,is,empty,nullable,object,str,return,str,null,equals,str
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, @Nullable String charsToDelete);1496259743;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, @Nullable String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}__		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,nullable,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, @Nullable String charsToDelete);1496837955;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, @Nullable String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}__		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,nullable,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, @Nullable String charsToDelete);1499270197;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, @Nullable String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}__		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,nullable,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, @Nullable String charsToDelete);1508667152;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, @Nullable String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}__		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,nullable,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, @Nullable String charsToDelete);1508675477;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, @Nullable String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}__		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,nullable,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, @Nullable String charsToDelete);1508843807;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, @Nullable String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}__		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,nullable,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, @Nullable String charsToDelete);1516903831;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, @Nullable String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}__		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,nullable,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, @Nullable String charsToDelete);1519295386;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, @Nullable String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}__		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,nullable,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, @Nullable String charsToDelete);1519308837;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, @Nullable String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}__		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,nullable,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, @Nullable String charsToDelete);1519588127;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, @Nullable String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}__		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,nullable,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, @Nullable String charsToDelete);1522332352;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, @Nullable String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}__		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,nullable,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, @Nullable String charsToDelete);1525166194;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, @Nullable String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}__		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,nullable,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, @Nullable String charsToDelete);1530188116;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, @Nullable String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}__		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,nullable,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, @Nullable String charsToDelete);1531843079;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, @Nullable String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}__		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,nullable,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, @Nullable String charsToDelete);1531905026;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, @Nullable String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}__		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,nullable,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, @Nullable String charsToDelete);1533557519;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, @Nullable String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}__		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,nullable,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, @Nullable String charsToDelete);1533602820;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, @Nullable String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}__		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,nullable,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, @Nullable String charsToDelete);1535316501;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, @Nullable String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}__		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,nullable,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, @Nullable String charsToDelete);1550237113;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, @Nullable String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}__		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,nullable,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, @Nullable String charsToDelete);1550238935;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, @Nullable String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}__		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,nullable,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> public static String[] tokenizeToStringArray( 			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1496837955;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@param trimTokens trim the tokens via {@link String#trim()}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return new String[0]__		}__		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,param,trim,tokens,trim,the,tokens,via,link,string,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,new,string,0,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1499270197;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@param trimTokens trim the tokens via {@link String#trim()}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return new String[0]__		}__		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,param,trim,tokens,trim,the,tokens,via,link,string,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,new,string,0,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1508667152;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@param trimTokens trim the tokens via {@link String#trim()}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return new String[0]__		}__		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,param,trim,tokens,trim,the,tokens,via,link,string,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,new,string,0,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1508675477;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@param trimTokens trim the tokens via {@link String#trim()}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return new String[0]__		}__		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,param,trim,tokens,trim,the,tokens,via,link,string,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,new,string,0,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1508843807;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@param trimTokens trim the tokens via {@link String#trim()}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return new String[0]__		}__		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,param,trim,tokens,trim,the,tokens,via,link,string,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,new,string,0,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1516903831;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@param trimTokens trim the tokens via {@link String#trim()}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return new String[0]__		}__		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,param,trim,tokens,trim,the,tokens,via,link,string,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,new,string,0,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1519295386;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@param trimTokens trim the tokens via {@link String#trim()}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return new String[0]__		}__		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,param,trim,tokens,trim,the,tokens,via,link,string,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,new,string,0,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1519308837;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@param trimTokens trim the tokens via {@link String#trim()}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return new String[0]__		}__		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,param,trim,tokens,trim,the,tokens,via,link,string,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,new,string,0,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1519588127;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@param trimTokens trim the tokens via {@link String#trim()}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return new String[0]__		}__		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,param,trim,tokens,trim,the,tokens,via,link,string,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,new,string,0,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1522332352;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@param trimTokens trim the tokens via {@link String#trim()}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return new String[0]__		}__		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,param,trim,tokens,trim,the,tokens,via,link,string,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,new,string,0,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1525166194;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@param trimTokens trim the tokens via {@link String#trim()}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return new String[0]__		}__		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,param,trim,tokens,trim,the,tokens,via,link,string,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,new,string,0,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1530188116;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@param trimTokens trim the tokens via {@link String#trim()}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return new String[0]__		}__		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,param,trim,tokens,trim,the,tokens,via,link,string,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,new,string,0,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1531843079;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@param trimTokens trim the tokens via {@link String#trim()}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return new String[0]__		}__		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,param,trim,tokens,trim,the,tokens,via,link,string,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,new,string,0,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1531905026;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@param trimTokens trim the tokens via {@link String#trim()}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return new String[0]__		}__		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,param,trim,tokens,trim,the,tokens,via,link,string,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,new,string,0,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1533557519;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize (potentially {@code null} or empty)_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@param trimTokens trim the tokens via {@link String#trim()}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return new String[0]__		}__		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,potentially,code,null,or,empty,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,param,trim,tokens,trim,the,tokens,via,link,string,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,new,string,0,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1533602820;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize (potentially {@code null} or empty)_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@param trimTokens trim the tokens via {@link String#trim()}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return new String[0]__		}__		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,potentially,code,null,or,empty,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,param,trim,tokens,trim,the,tokens,via,link,string,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,new,string,0,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1535316501;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize (potentially {@code null} or empty)_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@param trimTokens trim the tokens via {@link String#trim()}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return new String[0]__		}__		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,potentially,code,null,or,empty,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,param,trim,tokens,trim,the,tokens,via,link,string,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,new,string,0,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1550237113;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize (potentially {@code null} or empty)_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@param trimTokens trim the tokens via {@link String#trim()}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return new String[0]__		}__		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,potentially,code,null,or,empty,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,param,trim,tokens,trim,the,tokens,via,link,string,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,new,string,0,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] tokenizeToStringArray( 			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1550238935;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize (potentially {@code null} or empty)_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@param trimTokens trim the tokens via {@link String#trim()}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(_			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return new String[0]__		}__		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,potentially,code,null,or,empty,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,param,trim,tokens,trim,the,tokens,via,link,string,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,new,string,0,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String arrayToCommaDelimitedString(Object[] arr);1328020251;Convenience method to return a String array as a CSV String._E.g. useful for <code>toString()</code> implementations._@param arr the array to display_@return the delimited String;public static String arrayToCommaDelimitedString(Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convenience,method,to,return,a,string,array,as,a,csv,string,e,g,useful,for,code,to,string,code,implementations,param,arr,the,array,to,display,return,the,delimited,string;public,static,string,array,to,comma,delimited,string,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(Object[] arr);1337236962;Convenience method to return a String array as a CSV String._E.g. useful for <code>toString()</code> implementations._@param arr the array to display_@return the delimited String;public static String arrayToCommaDelimitedString(Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convenience,method,to,return,a,string,array,as,a,csv,string,e,g,useful,for,code,to,string,code,implementations,param,arr,the,array,to,display,return,the,delimited,string;public,static,string,array,to,comma,delimited,string,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(Object[] arr);1356735495;Convenience method to return a String array as a CSV String._E.g. useful for {@code toString()} implementations._@param arr the array to display_@return the delimited String;public static String arrayToCommaDelimitedString(Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convenience,method,to,return,a,string,array,as,a,csv,string,e,g,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,string;public,static,string,array,to,comma,delimited,string,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(Object[] arr);1367955086;Convenience method to return a String array as a CSV String._E.g. useful for {@code toString()} implementations._@param arr the array to display_@return the delimited String;public static String arrayToCommaDelimitedString(Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convenience,method,to,return,a,string,array,as,a,csv,string,e,g,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,string;public,static,string,array,to,comma,delimited,string,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(Object[] arr);1380921248;Convenience method to return a String array as a CSV String._E.g. useful for {@code toString()} implementations._@param arr the array to display_@return the delimited String;public static String arrayToCommaDelimitedString(Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convenience,method,to,return,a,string,array,as,a,csv,string,e,g,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,string;public,static,string,array,to,comma,delimited,string,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(Object[] arr);1382750743;Convenience method to return a String array as a CSV String._E.g. useful for {@code toString()} implementations._@param arr the array to display_@return the delimited String;public static String arrayToCommaDelimitedString(Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convenience,method,to,return,a,string,array,as,a,csv,string,e,g,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,string;public,static,string,array,to,comma,delimited,string,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(Object[] arr);1385423968;Convenience method to return a String array as a CSV String._E.g. useful for {@code toString()} implementations._@param arr the array to display_@return the delimited String;public static String arrayToCommaDelimitedString(Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convenience,method,to,return,a,string,array,as,a,csv,string,e,g,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,string;public,static,string,array,to,comma,delimited,string,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(Object[] arr);1400189212;Convenience method to return a String array as a CSV String._E.g. useful for {@code toString()} implementations._@param arr the array to display_@return the delimited String;public static String arrayToCommaDelimitedString(Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convenience,method,to,return,a,string,array,as,a,csv,string,e,g,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,string;public,static,string,array,to,comma,delimited,string,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(Object[] arr);1400531359;Convenience method to return a String array as a CSV String._E.g. useful for {@code toString()} implementations._@param arr the array to display_@return the delimited String;public static String arrayToCommaDelimitedString(Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convenience,method,to,return,a,string,array,as,a,csv,string,e,g,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,string;public,static,string,array,to,comma,delimited,string,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(Object[] arr);1402676350;Convenience method to return a String array as a CSV String._E.g. useful for {@code toString()} implementations._@param arr the array to display_@return the delimited String;public static String arrayToCommaDelimitedString(Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convenience,method,to,return,a,string,array,as,a,csv,string,e,g,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,string;public,static,string,array,to,comma,delimited,string,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(Object[] arr);1426267150;Convenience method to return a String array as a CSV String._E.g. useful for {@code toString()} implementations._@param arr the array to display_@return the delimited String;public static String arrayToCommaDelimitedString(Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convenience,method,to,return,a,string,array,as,a,csv,string,e,g,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,string;public,static,string,array,to,comma,delimited,string,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(Object[] arr);1429034538;Convenience method to return a String array as a CSV String._E.g. useful for {@code toString()} implementations._@param arr the array to display_@return the delimited String;public static String arrayToCommaDelimitedString(Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convenience,method,to,return,a,string,array,as,a,csv,string,e,g,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,string;public,static,string,array,to,comma,delimited,string,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(Object[] arr);1429034756;Convert a {@code String} array into a comma delimited {@code String}_(i.e., CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@return the delimited {@code String};public static String arrayToCommaDelimitedString(Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convert,a,code,string,array,into,a,comma,delimited,code,string,i,e,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,code,string;public,static,string,array,to,comma,delimited,string,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(Object[] arr);1431006895;Convert a {@code String} array into a comma delimited {@code String}_(i.e., CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@return the delimited {@code String};public static String arrayToCommaDelimitedString(Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convert,a,code,string,array,into,a,comma,delimited,code,string,i,e,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,code,string;public,static,string,array,to,comma,delimited,string,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(Object[] arr);1431007368;Convert a {@code String} array into a comma delimited {@code String}_(i.e., CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@return the delimited {@code String};public static String arrayToCommaDelimitedString(Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convert,a,code,string,array,into,a,comma,delimited,code,string,i,e,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,code,string;public,static,string,array,to,comma,delimited,string,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(Object[] arr);1449489126;Convert a {@code String} array into a comma delimited {@code String}_(i.e., CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@return the delimited {@code String};public static String arrayToCommaDelimitedString(Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convert,a,code,string,array,into,a,comma,delimited,code,string,i,e,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,code,string;public,static,string,array,to,comma,delimited,string,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(Object[] arr);1467730834;Convert a {@code String} array into a comma delimited {@code String}_(i.e., CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@return the delimited {@code String};public static String arrayToCommaDelimitedString(Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convert,a,code,string,array,into,a,comma,delimited,code,string,i,e,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,code,string;public,static,string,array,to,comma,delimited,string,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(Object[] arr);1472128018;Convert a {@code String} array into a comma delimited {@code String}_(i.e., CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@return the delimited {@code String};public static String arrayToCommaDelimitedString(Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convert,a,code,string,array,into,a,comma,delimited,code,string,i,e,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,code,string;public,static,string,array,to,comma,delimited,string,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(Object[] arr);1472202842;Convert a {@code String} array into a comma delimited {@code String}_(i.e., CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@return the delimited {@code String};public static String arrayToCommaDelimitedString(Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convert,a,code,string,array,into,a,comma,delimited,code,string,i,e,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,code,string;public,static,string,array,to,comma,delimited,string,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(Object[] arr);1473942665;Convert a {@code String} array into a comma delimited {@code String}_(i.e., CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@return the delimited {@code String};public static String arrayToCommaDelimitedString(Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convert,a,code,string,array,into,a,comma,delimited,code,string,i,e,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,code,string;public,static,string,array,to,comma,delimited,string,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(Object[] arr);1484248946;Convert a {@code String} array into a comma delimited {@code String}_(i.e., CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@return the delimited {@code String};public static String arrayToCommaDelimitedString(Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convert,a,code,string,array,into,a,comma,delimited,code,string,i,e,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,code,string;public,static,string,array,to,comma,delimited,string,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(Object[] arr);1484260238;Convert a {@code String} array into a comma delimited {@code String}_(i.e., CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@return the delimited {@code String};public static String arrayToCommaDelimitedString(Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convert,a,code,string,array,into,a,comma,delimited,code,string,i,e,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,code,string;public,static,string,array,to,comma,delimited,string,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(Object[] arr);1484694546;Convert a {@code String} array into a comma delimited {@code String}_(i.e., CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@return the delimited {@code String};public static String arrayToCommaDelimitedString(Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convert,a,code,string,array,into,a,comma,delimited,code,string,i,e,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,code,string;public,static,string,array,to,comma,delimited,string,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(Object[] arr);1487760984;Convert a {@code String} array into a comma delimited {@code String}_(i.e., CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@return the delimited {@code String};public static String arrayToCommaDelimitedString(Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convert,a,code,string,array,into,a,comma,delimited,code,string,i,e,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,code,string;public,static,string,array,to,comma,delimited,string,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(Object[] arr);1487778834;Convert a {@code String} array into a comma delimited {@code String}_(i.e., CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@return the delimited {@code String};public static String arrayToCommaDelimitedString(Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convert,a,code,string,array,into,a,comma,delimited,code,string,i,e,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,code,string;public,static,string,array,to,comma,delimited,string,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(Object[] arr);1491898314;Convert a {@code String} array into a comma delimited {@code String}_(i.e., CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@return the delimited {@code String};public static String arrayToCommaDelimitedString(Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convert,a,code,string,array,into,a,comma,delimited,code,string,i,e,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,code,string;public,static,string,array,to,comma,delimited,string,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(Object[] arr);1491903650;Convert a {@code String} array into a comma delimited {@code String}_(i.e., CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@return the delimited {@code String};public static String arrayToCommaDelimitedString(Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convert,a,code,string,array,into,a,comma,delimited,code,string,i,e,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,code,string;public,static,string,array,to,comma,delimited,string,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(Object[] arr);1495868221;Convert a {@code String} array into a comma delimited {@code String}_(i.e., CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@return the delimited {@code String};public static String arrayToCommaDelimitedString(Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convert,a,code,string,array,into,a,comma,delimited,code,string,i,e,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,code,string;public,static,string,array,to,comma,delimited,string,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(Object[] arr);1496243689;Convert a {@code String} array into a comma delimited {@code String}_(i.e., CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@return the delimited {@code String};public static String arrayToCommaDelimitedString(Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convert,a,code,string,array,into,a,comma,delimited,code,string,i,e,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,code,string;public,static,string,array,to,comma,delimited,string,object,arr,return,array,to,delimited,string,arr
StringUtils -> public static String arrayToCommaDelimitedString(Object[] arr);1496259743;Convert a {@code String} array into a comma delimited {@code String}_(i.e., CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@return the delimited {@code String};public static String arrayToCommaDelimitedString(Object[] arr) {_		return arrayToDelimitedString(arr, ",")__	};convert,a,code,string,array,into,a,comma,delimited,code,string,i,e,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,return,the,delimited,code,string;public,static,string,array,to,comma,delimited,string,object,arr,return,array,to,delimited,string,arr
StringUtils -> @Nullable 	public static String[] toStringArray(@Nullable Collection<String> collection);1495868221;Copy the given {@code Collection} into a {@code String} array._<p>The {@code Collection} must contain {@code String} elements only._@param collection the {@code Collection} to copy_@return the {@code String} array ({@code null} if the supplied_{@code Collection} was {@code null});@Nullable_	public static String[] toStringArray(@Nullable Collection<String> collection) {_		if (collection == null) {_			return null__		}__		return collection.toArray(new String[collection.size()])__	};copy,the,given,code,collection,into,a,code,string,array,p,the,code,collection,must,contain,code,string,elements,only,param,collection,the,code,collection,to,copy,return,the,code,string,array,code,null,if,the,supplied,code,collection,was,code,null;nullable,public,static,string,to,string,array,nullable,collection,string,collection,if,collection,null,return,null,return,collection,to,array,new,string,collection,size
StringUtils -> @Nullable 	public static String[] toStringArray(@Nullable Collection<String> collection);1496243689;Copy the given {@code Collection} into a {@code String} array._<p>The {@code Collection} must contain {@code String} elements only._@param collection the {@code Collection} to copy_@return the {@code String} array ({@code null} if the supplied_{@code Collection} was {@code null});@Nullable_	public static String[] toStringArray(@Nullable Collection<String> collection) {_		if (collection == null) {_			return null__		}__		return collection.toArray(new String[collection.size()])__	};copy,the,given,code,collection,into,a,code,string,array,p,the,code,collection,must,contain,code,string,elements,only,param,collection,the,code,collection,to,copy,return,the,code,string,array,code,null,if,the,supplied,code,collection,was,code,null;nullable,public,static,string,to,string,array,nullable,collection,string,collection,if,collection,null,return,null,return,collection,to,array,new,string,collection,size
StringUtils -> @Nullable 	public static String[] toStringArray(@Nullable Collection<String> collection);1496259743;Copy the given {@code Collection} into a {@code String} array._<p>The {@code Collection} must contain {@code String} elements only._@param collection the {@code Collection} to copy_@return the {@code String} array ({@code null} if the supplied_{@code Collection} was {@code null});@Nullable_	public static String[] toStringArray(@Nullable Collection<String> collection) {_		if (collection == null) {_			return null__		}__		return collection.toArray(new String[collection.size()])__	};copy,the,given,code,collection,into,a,code,string,array,p,the,code,collection,must,contain,code,string,elements,only,param,collection,the,code,collection,to,copy,return,the,code,string,array,code,null,if,the,supplied,code,collection,was,code,null;nullable,public,static,string,to,string,array,nullable,collection,string,collection,if,collection,null,return,null,return,collection,to,array,new,string,collection,size
StringUtils -> public static String toLanguageTag(Locale locale);1328020251;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as String;public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,string;public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> public static String toLanguageTag(Locale locale);1337236962;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as String;public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,string;public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> public static String toLanguageTag(Locale locale);1356735495;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as String;public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,string;public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> public static String toLanguageTag(Locale locale);1367955086;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as String;public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,string;public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> public static String toLanguageTag(Locale locale);1380921248;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as String;public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,string;public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> public static String toLanguageTag(Locale locale);1382750743;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as String;public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,string;public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> public static String toLanguageTag(Locale locale);1385423968;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as String;public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,string;public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> public static String toLanguageTag(Locale locale);1400189212;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as String;public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,string;public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> public static String toLanguageTag(Locale locale);1400531359;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as String;public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,string;public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> public static String toLanguageTag(Locale locale);1402676350;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as String;public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,string;public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> public static String toLanguageTag(Locale locale);1426267150;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as String;public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,string;public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> public static String toLanguageTag(Locale locale);1429034538;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as String;public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,string;public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> public static String toLanguageTag(Locale locale);1429034756;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as {@code String};public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,code,string;public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> public static String toLanguageTag(Locale locale);1431006895;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as {@code String};public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,code,string;public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> public static String toLanguageTag(Locale locale);1431007368;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as {@code String};public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,code,string;public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> public static String toLanguageTag(Locale locale);1449489126;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as {@code String};public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,code,string;public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> public static String toLanguageTag(Locale locale);1467730834;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as {@code String};public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,code,string;public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> public static String toLanguageTag(Locale locale);1472128018;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as {@code String};public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,code,string;public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> public static String toLanguageTag(Locale locale);1472202842;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as {@code String};public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,code,string;public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> public static String toLanguageTag(Locale locale);1473942665;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as {@code String};public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,code,string;public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> public static String toLanguageTag(Locale locale);1484248946;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as {@code String};public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,code,string;public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> public static String toLanguageTag(Locale locale);1484260238;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as {@code String};public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,code,string;public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> public static String toLanguageTag(Locale locale);1484694546;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as {@code String};public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,code,string;public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> public static String toLanguageTag(Locale locale);1487760984;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as {@code String};public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,code,string;public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> public static String toLanguageTag(Locale locale);1487778834;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as {@code String};public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,code,string;public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> public static String toLanguageTag(Locale locale);1491898314;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as {@code String};public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,code,string;public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> public static String toLanguageTag(Locale locale);1491903650;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as {@code String};public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,code,string;public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> public static String toLanguageTag(Locale locale);1495868221;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as {@code String};public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,code,string;public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> public static String toLanguageTag(Locale locale);1496243689;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as {@code String};public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,code,string;public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> public static String toLanguageTag(Locale locale);1496259743;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as {@code String};public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,code,string;public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> public static String toLanguageTag(Locale locale);1496837955;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as {@code String};public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,code,string;public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> public static String toLanguageTag(Locale locale);1499270197;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as {@code String};public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,code,string;public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> public static String toLanguageTag(Locale locale);1508667152;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as {@code String};public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,code,string;public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> public static String toLanguageTag(Locale locale);1508675477;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as {@code String};public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,code,string;public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> public static String toLanguageTag(Locale locale);1508843807;Determine the RFC 3066 compliant language tag,_as used for the HTTP "Accept-Language" header._@param locale the Locale to transform to a language tag_@return the RFC 3066 compliant language tag as {@code String};public static String toLanguageTag(Locale locale) {_		return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "")__	};determine,the,rfc,3066,compliant,language,tag,as,used,for,the,http,accept,language,header,param,locale,the,locale,to,transform,to,a,language,tag,return,the,rfc,3066,compliant,language,tag,as,code,string;public,static,string,to,language,tag,locale,locale,return,locale,get,language,has,text,locale,get,country,locale,get,country
StringUtils -> @Nullable 	public static Locale parseLocaleString(String localeString);1496837955;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale {@code String}, following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc)__also accepts spaces as separators, as an alternative to underscores_@return a corresponding {@code Locale} instance, or {@code null} if none_@throws IllegalArgumentException in case of an invalid locale specification;@Nullable_	public static Locale parseLocaleString(String localeString) {_		String[] parts = tokenizeToStringArray(localeString, "_ ", false, false)__		String language = (parts.length > 0 ? parts[0] : "")__		String country = (parts.length > 1 ? parts[1] : "")___		validateLocalePart(language)__		validateLocalePart(country)___		String variant = ""__		if (parts.length > 2) {_			_			_			int endIndexOfCountryCode = localeString.indexOf(country, language.length()) + country.length()__			_			variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode))__			if (variant.startsWith("_")) {_				variant = trimLeadingCharacter(variant, '_')__			}_		}_		return (language.length() > 0 ? new Locale(language, country, variant) : null)__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,code,string,following,code,locale,s,code,to,string,format,en,etc,also,accepts,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance,or,code,null,if,none,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;nullable,public,static,locale,parse,locale,string,string,locale,string,string,parts,tokenize,to,string,array,locale,string,false,false,string,language,parts,length,0,parts,0,string,country,parts,length,1,parts,1,validate,locale,part,language,validate,locale,part,country,string,variant,if,parts,length,2,int,end,index,of,country,code,locale,string,index,of,country,language,length,country,length,variant,trim,leading,whitespace,locale,string,substring,end,index,of,country,code,if,variant,starts,with,variant,trim,leading,character,variant,return,language,length,0,new,locale,language,country,variant,null
StringUtils -> @Nullable 	public static Locale parseLocaleString(String localeString);1499270197;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale {@code String}, following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc)__also accepts spaces as separators, as an alternative to underscores_@return a corresponding {@code Locale} instance, or {@code null} if none_@throws IllegalArgumentException in case of an invalid locale specification;@Nullable_	public static Locale parseLocaleString(String localeString) {_		String[] parts = tokenizeToStringArray(localeString, "_ ", false, false)__		String language = (parts.length > 0 ? parts[0] : "")__		String country = (parts.length > 1 ? parts[1] : "")___		validateLocalePart(language)__		validateLocalePart(country)___		String variant = ""__		if (parts.length > 2) {_			_			_			int endIndexOfCountryCode = localeString.indexOf(country, language.length()) + country.length()__			_			variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode))__			if (variant.startsWith("_")) {_				variant = trimLeadingCharacter(variant, '_')__			}_		}_		return (language.length() > 0 ? new Locale(language, country, variant) : null)__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,code,string,following,code,locale,s,code,to,string,format,en,etc,also,accepts,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance,or,code,null,if,none,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;nullable,public,static,locale,parse,locale,string,string,locale,string,string,parts,tokenize,to,string,array,locale,string,false,false,string,language,parts,length,0,parts,0,string,country,parts,length,1,parts,1,validate,locale,part,language,validate,locale,part,country,string,variant,if,parts,length,2,int,end,index,of,country,code,locale,string,index,of,country,language,length,country,length,variant,trim,leading,whitespace,locale,string,substring,end,index,of,country,code,if,variant,starts,with,variant,trim,leading,character,variant,return,language,length,0,new,locale,language,country,variant,null
StringUtils -> @Nullable 	public static Locale parseLocaleString(String localeString);1508667152;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale {@code String}, following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc)__also accepts spaces as separators, as an alternative to underscores_@return a corresponding {@code Locale} instance, or {@code null} if none_@throws IllegalArgumentException in case of an invalid locale specification;@Nullable_	public static Locale parseLocaleString(String localeString) {_		String[] parts = tokenizeToStringArray(localeString, "_ ", false, false)__		String language = (parts.length > 0 ? parts[0] : "")__		String country = (parts.length > 1 ? parts[1] : "")___		validateLocalePart(language)__		validateLocalePart(country)___		String variant = ""__		if (parts.length > 2) {_			_			_			int endIndexOfCountryCode = localeString.indexOf(country, language.length()) + country.length()__			_			variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode))__			if (variant.startsWith("_")) {_				variant = trimLeadingCharacter(variant, '_')__			}_		}_		return (language.length() > 0 ? new Locale(language, country, variant) : null)__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,code,string,following,code,locale,s,code,to,string,format,en,etc,also,accepts,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance,or,code,null,if,none,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;nullable,public,static,locale,parse,locale,string,string,locale,string,string,parts,tokenize,to,string,array,locale,string,false,false,string,language,parts,length,0,parts,0,string,country,parts,length,1,parts,1,validate,locale,part,language,validate,locale,part,country,string,variant,if,parts,length,2,int,end,index,of,country,code,locale,string,index,of,country,language,length,country,length,variant,trim,leading,whitespace,locale,string,substring,end,index,of,country,code,if,variant,starts,with,variant,trim,leading,character,variant,return,language,length,0,new,locale,language,country,variant,null
StringUtils -> @Nullable 	public static Locale parseLocaleString(String localeString);1508675477;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale {@code String}, following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc)__also accepts spaces as separators, as an alternative to underscores_@return a corresponding {@code Locale} instance, or {@code null} if none_@throws IllegalArgumentException in case of an invalid locale specification;@Nullable_	public static Locale parseLocaleString(String localeString) {_		String[] parts = tokenizeToStringArray(localeString, "_ ", false, false)__		String language = (parts.length > 0 ? parts[0] : "")__		String country = (parts.length > 1 ? parts[1] : "")___		validateLocalePart(language)__		validateLocalePart(country)___		String variant = ""__		if (parts.length > 2) {_			_			_			int endIndexOfCountryCode = localeString.indexOf(country, language.length()) + country.length()__			_			variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode))__			if (variant.startsWith("_")) {_				variant = trimLeadingCharacter(variant, '_')__			}_		}_		return (language.length() > 0 ? new Locale(language, country, variant) : null)__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,code,string,following,code,locale,s,code,to,string,format,en,etc,also,accepts,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance,or,code,null,if,none,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;nullable,public,static,locale,parse,locale,string,string,locale,string,string,parts,tokenize,to,string,array,locale,string,false,false,string,language,parts,length,0,parts,0,string,country,parts,length,1,parts,1,validate,locale,part,language,validate,locale,part,country,string,variant,if,parts,length,2,int,end,index,of,country,code,locale,string,index,of,country,language,length,country,length,variant,trim,leading,whitespace,locale,string,substring,end,index,of,country,code,if,variant,starts,with,variant,trim,leading,character,variant,return,language,length,0,new,locale,language,country,variant,null
StringUtils -> @Nullable 	public static Locale parseLocaleString(String localeString);1508843807;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale {@code String}, following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc)__also accepts spaces as separators, as an alternative to underscores_@return a corresponding {@code Locale} instance, or {@code null} if none_@throws IllegalArgumentException in case of an invalid locale specification;@Nullable_	public static Locale parseLocaleString(String localeString) {_		String[] parts = tokenizeToStringArray(localeString, "_ ", false, false)__		String language = (parts.length > 0 ? parts[0] : "")__		String country = (parts.length > 1 ? parts[1] : "")___		validateLocalePart(language)__		validateLocalePart(country)___		String variant = ""__		if (parts.length > 2) {_			_			_			int endIndexOfCountryCode = localeString.indexOf(country, language.length()) + country.length()__			_			variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode))__			if (variant.startsWith("_")) {_				variant = trimLeadingCharacter(variant, '_')__			}_		}_		return (language.length() > 0 ? new Locale(language, country, variant) : null)__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,code,string,following,code,locale,s,code,to,string,format,en,etc,also,accepts,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance,or,code,null,if,none,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;nullable,public,static,locale,parse,locale,string,string,locale,string,string,parts,tokenize,to,string,array,locale,string,false,false,string,language,parts,length,0,parts,0,string,country,parts,length,1,parts,1,validate,locale,part,language,validate,locale,part,country,string,variant,if,parts,length,2,int,end,index,of,country,code,locale,string,index,of,country,language,length,country,length,variant,trim,leading,whitespace,locale,string,substring,end,index,of,country,code,if,variant,starts,with,variant,trim,leading,character,variant,return,language,length,0,new,locale,language,country,variant,null
StringUtils -> @Nullable 	public static Locale parseLocaleString(String localeString);1516903831;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale {@code String}: following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc), also accepting spaces as_separators (as an alternative to underscores)_<p>Note: This variant does not accept the BCP 47 language tag format._Please use {@link #parseLocale} for lenient parsing of both formats._@return a corresponding {@code Locale} instance, or {@code null} if none_@throws IllegalArgumentException in case of an invalid locale specification;@Nullable_	public static Locale parseLocaleString(String localeString) {_		return parseLocaleTokens(localeString, tokenizeLocaleSource(localeString))__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,code,string,following,code,locale,s,code,to,string,format,en,etc,also,accepting,spaces,as,separators,as,an,alternative,to,underscores,p,note,this,variant,does,not,accept,the,bcp,47,language,tag,format,please,use,link,parse,locale,for,lenient,parsing,of,both,formats,return,a,corresponding,code,locale,instance,or,code,null,if,none,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;nullable,public,static,locale,parse,locale,string,string,locale,string,return,parse,locale,tokens,locale,string,tokenize,locale,source,locale,string
StringUtils -> @Nullable 	public static Locale parseLocaleString(String localeString);1519295386;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale {@code String}: following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc), also accepting spaces as_separators (as an alternative to underscores)_<p>Note: This variant does not accept the BCP 47 language tag format._Please use {@link #parseLocale} for lenient parsing of both formats._@return a corresponding {@code Locale} instance, or {@code null} if none_@throws IllegalArgumentException in case of an invalid locale specification;@Nullable_	public static Locale parseLocaleString(String localeString) {_		return parseLocaleTokens(localeString, tokenizeLocaleSource(localeString))__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,code,string,following,code,locale,s,code,to,string,format,en,etc,also,accepting,spaces,as,separators,as,an,alternative,to,underscores,p,note,this,variant,does,not,accept,the,bcp,47,language,tag,format,please,use,link,parse,locale,for,lenient,parsing,of,both,formats,return,a,corresponding,code,locale,instance,or,code,null,if,none,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;nullable,public,static,locale,parse,locale,string,string,locale,string,return,parse,locale,tokens,locale,string,tokenize,locale,source,locale,string
StringUtils -> @Nullable 	public static Locale parseLocaleString(String localeString);1519308837;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale {@code String}: following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc), also accepting spaces as_separators (as an alternative to underscores)_<p>Note: This variant does not accept the BCP 47 language tag format._Please use {@link #parseLocale} for lenient parsing of both formats._@return a corresponding {@code Locale} instance, or {@code null} if none_@throws IllegalArgumentException in case of an invalid locale specification;@Nullable_	public static Locale parseLocaleString(String localeString) {_		return parseLocaleTokens(localeString, tokenizeLocaleSource(localeString))__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,code,string,following,code,locale,s,code,to,string,format,en,etc,also,accepting,spaces,as,separators,as,an,alternative,to,underscores,p,note,this,variant,does,not,accept,the,bcp,47,language,tag,format,please,use,link,parse,locale,for,lenient,parsing,of,both,formats,return,a,corresponding,code,locale,instance,or,code,null,if,none,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;nullable,public,static,locale,parse,locale,string,string,locale,string,return,parse,locale,tokens,locale,string,tokenize,locale,source,locale,string
StringUtils -> @Nullable 	public static Locale parseLocaleString(String localeString);1519588127;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale {@code String}: following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc), also accepting spaces as_separators (as an alternative to underscores)_<p>Note: This variant does not accept the BCP 47 language tag format._Please use {@link #parseLocale} for lenient parsing of both formats._@return a corresponding {@code Locale} instance, or {@code null} if none_@throws IllegalArgumentException in case of an invalid locale specification;@Nullable_	public static Locale parseLocaleString(String localeString) {_		return parseLocaleTokens(localeString, tokenizeLocaleSource(localeString))__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,code,string,following,code,locale,s,code,to,string,format,en,etc,also,accepting,spaces,as,separators,as,an,alternative,to,underscores,p,note,this,variant,does,not,accept,the,bcp,47,language,tag,format,please,use,link,parse,locale,for,lenient,parsing,of,both,formats,return,a,corresponding,code,locale,instance,or,code,null,if,none,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;nullable,public,static,locale,parse,locale,string,string,locale,string,return,parse,locale,tokens,locale,string,tokenize,locale,source,locale,string
StringUtils -> @Nullable 	public static Locale parseLocaleString(String localeString);1522332352;Parse the given {@code String} representation into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale {@code String}: following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc), also accepting spaces as_separators (as an alternative to underscores)_<p>Note: This variant does not accept the BCP 47 language tag format._Please use {@link #parseLocale} for lenient parsing of both formats._@return a corresponding {@code Locale} instance, or {@code null} if none_@throws IllegalArgumentException in case of an invalid locale specification;@Nullable_	public static Locale parseLocaleString(String localeString) {_		return parseLocaleTokens(localeString, tokenizeLocaleSource(localeString))__	};parse,the,given,code,string,representation,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,code,string,following,code,locale,s,code,to,string,format,en,etc,also,accepting,spaces,as,separators,as,an,alternative,to,underscores,p,note,this,variant,does,not,accept,the,bcp,47,language,tag,format,please,use,link,parse,locale,for,lenient,parsing,of,both,formats,return,a,corresponding,code,locale,instance,or,code,null,if,none,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;nullable,public,static,locale,parse,locale,string,string,locale,string,return,parse,locale,tokens,locale,string,tokenize,locale,source,locale,string
StringUtils -> @Nullable 	public static Locale parseLocaleString(String localeString);1525166194;Parse the given {@code String} representation into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale {@code String}: following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc), also accepting spaces as_separators (as an alternative to underscores)_<p>Note: This variant does not accept the BCP 47 language tag format._Please use {@link #parseLocale} for lenient parsing of both formats._@return a corresponding {@code Locale} instance, or {@code null} if none_@throws IllegalArgumentException in case of an invalid locale specification;@Nullable_	public static Locale parseLocaleString(String localeString) {_		return parseLocaleTokens(localeString, tokenizeLocaleSource(localeString))__	};parse,the,given,code,string,representation,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,code,string,following,code,locale,s,code,to,string,format,en,etc,also,accepting,spaces,as,separators,as,an,alternative,to,underscores,p,note,this,variant,does,not,accept,the,bcp,47,language,tag,format,please,use,link,parse,locale,for,lenient,parsing,of,both,formats,return,a,corresponding,code,locale,instance,or,code,null,if,none,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;nullable,public,static,locale,parse,locale,string,string,locale,string,return,parse,locale,tokens,locale,string,tokenize,locale,source,locale,string
StringUtils -> @Nullable 	public static Locale parseLocaleString(String localeString);1530188116;Parse the given {@code String} representation into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale {@code String}: following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc), also accepting spaces as_separators (as an alternative to underscores)_<p>Note: This variant does not accept the BCP 47 language tag format._Please use {@link #parseLocale} for lenient parsing of both formats._@return a corresponding {@code Locale} instance, or {@code null} if none_@throws IllegalArgumentException in case of an invalid locale specification;@Nullable_	public static Locale parseLocaleString(String localeString) {_		return parseLocaleTokens(localeString, tokenizeLocaleSource(localeString))__	};parse,the,given,code,string,representation,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,code,string,following,code,locale,s,code,to,string,format,en,etc,also,accepting,spaces,as,separators,as,an,alternative,to,underscores,p,note,this,variant,does,not,accept,the,bcp,47,language,tag,format,please,use,link,parse,locale,for,lenient,parsing,of,both,formats,return,a,corresponding,code,locale,instance,or,code,null,if,none,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;nullable,public,static,locale,parse,locale,string,string,locale,string,return,parse,locale,tokens,locale,string,tokenize,locale,source,locale,string
StringUtils -> @Nullable 	public static Locale parseLocaleString(String localeString);1531843079;Parse the given {@code String} representation into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale {@code String}: following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc), also accepting spaces as_separators (as an alternative to underscores)_<p>Note: This variant does not accept the BCP 47 language tag format._Please use {@link #parseLocale} for lenient parsing of both formats._@return a corresponding {@code Locale} instance, or {@code null} if none_@throws IllegalArgumentException in case of an invalid locale specification;@Nullable_	public static Locale parseLocaleString(String localeString) {_		return parseLocaleTokens(localeString, tokenizeLocaleSource(localeString))__	};parse,the,given,code,string,representation,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,code,string,following,code,locale,s,code,to,string,format,en,etc,also,accepting,spaces,as,separators,as,an,alternative,to,underscores,p,note,this,variant,does,not,accept,the,bcp,47,language,tag,format,please,use,link,parse,locale,for,lenient,parsing,of,both,formats,return,a,corresponding,code,locale,instance,or,code,null,if,none,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;nullable,public,static,locale,parse,locale,string,string,locale,string,return,parse,locale,tokens,locale,string,tokenize,locale,source,locale,string
StringUtils -> @Nullable 	public static Locale parseLocaleString(String localeString);1531905026;Parse the given {@code String} representation into a {@link Locale}._<p>For many parsing scenarios, this is an inverse operation of_{@link Locale#toString Locale's toString}, in a lenient sense._This method does not aim for strict {@code Locale} design compliance__it is rather specifically tailored for typical Spring parsing needs._<p><b>Note: This delegate does not accept the BCP 47 language tag format._Please use {@link #parseLocale} for lenient parsing of both formats.</b>_@param localeString the locale {@code String}: following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc), also accepting spaces as_separators (as an alternative to underscores)_@return a corresponding {@code Locale} instance, or {@code null} if none_@throws IllegalArgumentException in case of an invalid locale specification;@Nullable_	public static Locale parseLocaleString(String localeString) {_		return parseLocaleTokens(localeString, tokenizeLocaleSource(localeString))__	};parse,the,given,code,string,representation,into,a,link,locale,p,for,many,parsing,scenarios,this,is,an,inverse,operation,of,link,locale,to,string,locale,s,to,string,in,a,lenient,sense,this,method,does,not,aim,for,strict,code,locale,design,compliance,it,is,rather,specifically,tailored,for,typical,spring,parsing,needs,p,b,note,this,delegate,does,not,accept,the,bcp,47,language,tag,format,please,use,link,parse,locale,for,lenient,parsing,of,both,formats,b,param,locale,string,the,locale,code,string,following,code,locale,s,code,to,string,format,en,etc,also,accepting,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance,or,code,null,if,none,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;nullable,public,static,locale,parse,locale,string,string,locale,string,return,parse,locale,tokens,locale,string,tokenize,locale,source,locale,string
StringUtils -> @Nullable 	public static Locale parseLocaleString(String localeString);1533557519;Parse the given {@code String} representation into a {@link Locale}._<p>For many parsing scenarios, this is an inverse operation of_{@link Locale#toString Locale's toString}, in a lenient sense._This method does not aim for strict {@code Locale} design compliance__it is rather specifically tailored for typical Spring parsing needs._<p><b>Note: This delegate does not accept the BCP 47 language tag format._Please use {@link #parseLocale} for lenient parsing of both formats.</b>_@param localeString the locale {@code String}: following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc), also accepting spaces as_separators (as an alternative to underscores)_@return a corresponding {@code Locale} instance, or {@code null} if none_@throws IllegalArgumentException in case of an invalid locale specification;@Nullable_	public static Locale parseLocaleString(String localeString) {_		return parseLocaleTokens(localeString, tokenizeLocaleSource(localeString))__	};parse,the,given,code,string,representation,into,a,link,locale,p,for,many,parsing,scenarios,this,is,an,inverse,operation,of,link,locale,to,string,locale,s,to,string,in,a,lenient,sense,this,method,does,not,aim,for,strict,code,locale,design,compliance,it,is,rather,specifically,tailored,for,typical,spring,parsing,needs,p,b,note,this,delegate,does,not,accept,the,bcp,47,language,tag,format,please,use,link,parse,locale,for,lenient,parsing,of,both,formats,b,param,locale,string,the,locale,code,string,following,code,locale,s,code,to,string,format,en,etc,also,accepting,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance,or,code,null,if,none,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;nullable,public,static,locale,parse,locale,string,string,locale,string,return,parse,locale,tokens,locale,string,tokenize,locale,source,locale,string
StringUtils -> @Nullable 	public static Locale parseLocaleString(String localeString);1533602820;Parse the given {@code String} representation into a {@link Locale}._<p>For many parsing scenarios, this is an inverse operation of_{@link Locale#toString Locale's toString}, in a lenient sense._This method does not aim for strict {@code Locale} design compliance__it is rather specifically tailored for typical Spring parsing needs._<p><b>Note: This delegate does not accept the BCP 47 language tag format._Please use {@link #parseLocale} for lenient parsing of both formats.</b>_@param localeString the locale {@code String}: following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc), also accepting spaces as_separators (as an alternative to underscores)_@return a corresponding {@code Locale} instance, or {@code null} if none_@throws IllegalArgumentException in case of an invalid locale specification;@Nullable_	public static Locale parseLocaleString(String localeString) {_		return parseLocaleTokens(localeString, tokenizeLocaleSource(localeString))__	};parse,the,given,code,string,representation,into,a,link,locale,p,for,many,parsing,scenarios,this,is,an,inverse,operation,of,link,locale,to,string,locale,s,to,string,in,a,lenient,sense,this,method,does,not,aim,for,strict,code,locale,design,compliance,it,is,rather,specifically,tailored,for,typical,spring,parsing,needs,p,b,note,this,delegate,does,not,accept,the,bcp,47,language,tag,format,please,use,link,parse,locale,for,lenient,parsing,of,both,formats,b,param,locale,string,the,locale,code,string,following,code,locale,s,code,to,string,format,en,etc,also,accepting,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance,or,code,null,if,none,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;nullable,public,static,locale,parse,locale,string,string,locale,string,return,parse,locale,tokens,locale,string,tokenize,locale,source,locale,string
StringUtils -> @Nullable 	public static Locale parseLocaleString(String localeString);1535316501;Parse the given {@code String} representation into a {@link Locale}._<p>For many parsing scenarios, this is an inverse operation of_{@link Locale#toString Locale's toString}, in a lenient sense._This method does not aim for strict {@code Locale} design compliance__it is rather specifically tailored for typical Spring parsing needs._<p><b>Note: This delegate does not accept the BCP 47 language tag format._Please use {@link #parseLocale} for lenient parsing of both formats.</b>_@param localeString the locale {@code String}: following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc), also accepting spaces as_separators (as an alternative to underscores)_@return a corresponding {@code Locale} instance, or {@code null} if none_@throws IllegalArgumentException in case of an invalid locale specification;@Nullable_	public static Locale parseLocaleString(String localeString) {_		return parseLocaleTokens(localeString, tokenizeLocaleSource(localeString))__	};parse,the,given,code,string,representation,into,a,link,locale,p,for,many,parsing,scenarios,this,is,an,inverse,operation,of,link,locale,to,string,locale,s,to,string,in,a,lenient,sense,this,method,does,not,aim,for,strict,code,locale,design,compliance,it,is,rather,specifically,tailored,for,typical,spring,parsing,needs,p,b,note,this,delegate,does,not,accept,the,bcp,47,language,tag,format,please,use,link,parse,locale,for,lenient,parsing,of,both,formats,b,param,locale,string,the,locale,code,string,following,code,locale,s,code,to,string,format,en,etc,also,accepting,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance,or,code,null,if,none,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;nullable,public,static,locale,parse,locale,string,string,locale,string,return,parse,locale,tokens,locale,string,tokenize,locale,source,locale,string
StringUtils -> @Nullable 	public static Locale parseLocaleString(String localeString);1550237113;Parse the given {@code String} representation into a {@link Locale}._<p>For many parsing scenarios, this is an inverse operation of_{@link Locale#toString Locale's toString}, in a lenient sense._This method does not aim for strict {@code Locale} design compliance__it is rather specifically tailored for typical Spring parsing needs._<p><b>Note: This delegate does not accept the BCP 47 language tag format._Please use {@link #parseLocale} for lenient parsing of both formats.</b>_@param localeString the locale {@code String}: following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc), also accepting spaces as_separators (as an alternative to underscores)_@return a corresponding {@code Locale} instance, or {@code null} if none_@throws IllegalArgumentException in case of an invalid locale specification;@Nullable_	public static Locale parseLocaleString(String localeString) {_		return parseLocaleTokens(localeString, tokenizeLocaleSource(localeString))__	};parse,the,given,code,string,representation,into,a,link,locale,p,for,many,parsing,scenarios,this,is,an,inverse,operation,of,link,locale,to,string,locale,s,to,string,in,a,lenient,sense,this,method,does,not,aim,for,strict,code,locale,design,compliance,it,is,rather,specifically,tailored,for,typical,spring,parsing,needs,p,b,note,this,delegate,does,not,accept,the,bcp,47,language,tag,format,please,use,link,parse,locale,for,lenient,parsing,of,both,formats,b,param,locale,string,the,locale,code,string,following,code,locale,s,code,to,string,format,en,etc,also,accepting,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance,or,code,null,if,none,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;nullable,public,static,locale,parse,locale,string,string,locale,string,return,parse,locale,tokens,locale,string,tokenize,locale,source,locale,string
StringUtils -> @Nullable 	public static Locale parseLocaleString(String localeString);1550238935;Parse the given {@code String} representation into a {@link Locale}._<p>For many parsing scenarios, this is an inverse operation of_{@link Locale#toString Locale's toString}, in a lenient sense._This method does not aim for strict {@code Locale} design compliance__it is rather specifically tailored for typical Spring parsing needs._<p><b>Note: This delegate does not accept the BCP 47 language tag format._Please use {@link #parseLocale} for lenient parsing of both formats.</b>_@param localeString the locale {@code String}: following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc), also accepting spaces as_separators (as an alternative to underscores)_@return a corresponding {@code Locale} instance, or {@code null} if none_@throws IllegalArgumentException in case of an invalid locale specification;@Nullable_	public static Locale parseLocaleString(String localeString) {_		return parseLocaleTokens(localeString, tokenizeLocaleSource(localeString))__	};parse,the,given,code,string,representation,into,a,link,locale,p,for,many,parsing,scenarios,this,is,an,inverse,operation,of,link,locale,to,string,locale,s,to,string,in,a,lenient,sense,this,method,does,not,aim,for,strict,code,locale,design,compliance,it,is,rather,specifically,tailored,for,typical,spring,parsing,needs,p,b,note,this,delegate,does,not,accept,the,bcp,47,language,tag,format,please,use,link,parse,locale,for,lenient,parsing,of,both,formats,b,param,locale,string,the,locale,code,string,following,code,locale,s,code,to,string,format,en,etc,also,accepting,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance,or,code,null,if,none,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;nullable,public,static,locale,parse,locale,string,string,locale,string,return,parse,locale,tokens,locale,string,tokenize,locale,source,locale,string
StringUtils -> @Nullable 	public static Locale parseLocale(String localeValue);1516903831;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeValue the locale value: following either {@code Locale's}_{@code toString()} format ("en", "en_UK", etc), also accepting spaces as_separators (as an alternative to underscores), or BCP 47 (e.g. "en-UK")_as specified by {@link Locale#forLanguageTag} on Java 7+_@return a corresponding {@code Locale} instance, or {@code null} if none_@throws IllegalArgumentException in case of an invalid locale specification_@since 5.0.4_@see #parseLocaleString_@see Locale#forLanguageTag;@Nullable_	public static Locale parseLocale(String localeValue) {_		String[] tokens = tokenizeLocaleSource(localeValue)__		if (tokens.length == 1) {_			return Locale.forLanguageTag(localeValue)__		}_		return parseLocaleTokens(localeValue, tokens)__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,value,the,locale,value,following,either,code,locale,s,code,to,string,format,en,etc,also,accepting,spaces,as,separators,as,an,alternative,to,underscores,or,bcp,47,e,g,en,uk,as,specified,by,link,locale,for,language,tag,on,java,7,return,a,corresponding,code,locale,instance,or,code,null,if,none,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification,since,5,0,4,see,parse,locale,string,see,locale,for,language,tag;nullable,public,static,locale,parse,locale,string,locale,value,string,tokens,tokenize,locale,source,locale,value,if,tokens,length,1,return,locale,for,language,tag,locale,value,return,parse,locale,tokens,locale,value,tokens
StringUtils -> @Nullable 	public static Locale parseLocale(String localeValue);1519295386;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeValue the locale value: following either {@code Locale's}_{@code toString()} format ("en", "en_UK", etc), also accepting spaces as_separators (as an alternative to underscores), or BCP 47 (e.g. "en-UK")_as specified by {@link Locale#forLanguageTag} on Java 7+_@return a corresponding {@code Locale} instance, or {@code null} if none_@throws IllegalArgumentException in case of an invalid locale specification_@since 5.0.4_@see #parseLocaleString_@see Locale#forLanguageTag;@Nullable_	public static Locale parseLocale(String localeValue) {_		String[] tokens = tokenizeLocaleSource(localeValue)__		if (tokens.length == 1) {_			return Locale.forLanguageTag(localeValue)__		}_		return parseLocaleTokens(localeValue, tokens)__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,value,the,locale,value,following,either,code,locale,s,code,to,string,format,en,etc,also,accepting,spaces,as,separators,as,an,alternative,to,underscores,or,bcp,47,e,g,en,uk,as,specified,by,link,locale,for,language,tag,on,java,7,return,a,corresponding,code,locale,instance,or,code,null,if,none,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification,since,5,0,4,see,parse,locale,string,see,locale,for,language,tag;nullable,public,static,locale,parse,locale,string,locale,value,string,tokens,tokenize,locale,source,locale,value,if,tokens,length,1,return,locale,for,language,tag,locale,value,return,parse,locale,tokens,locale,value,tokens
StringUtils -> @Nullable 	public static Locale parseLocale(String localeValue);1519308837;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeValue the locale value: following either {@code Locale's}_{@code toString()} format ("en", "en_UK", etc), also accepting spaces as_separators (as an alternative to underscores), or BCP 47 (e.g. "en-UK")_as specified by {@link Locale#forLanguageTag} on Java 7+_@return a corresponding {@code Locale} instance, or {@code null} if none_@throws IllegalArgumentException in case of an invalid locale specification_@since 5.0.4_@see #parseLocaleString_@see Locale#forLanguageTag;@Nullable_	public static Locale parseLocale(String localeValue) {_		String[] tokens = tokenizeLocaleSource(localeValue)__		if (tokens.length == 1) {_			return Locale.forLanguageTag(localeValue)__		}_		return parseLocaleTokens(localeValue, tokens)__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,value,the,locale,value,following,either,code,locale,s,code,to,string,format,en,etc,also,accepting,spaces,as,separators,as,an,alternative,to,underscores,or,bcp,47,e,g,en,uk,as,specified,by,link,locale,for,language,tag,on,java,7,return,a,corresponding,code,locale,instance,or,code,null,if,none,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification,since,5,0,4,see,parse,locale,string,see,locale,for,language,tag;nullable,public,static,locale,parse,locale,string,locale,value,string,tokens,tokenize,locale,source,locale,value,if,tokens,length,1,return,locale,for,language,tag,locale,value,return,parse,locale,tokens,locale,value,tokens
StringUtils -> @Nullable 	public static Locale parseLocale(String localeValue);1519588127;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeValue the locale value: following either {@code Locale's}_{@code toString()} format ("en", "en_UK", etc), also accepting spaces as_separators (as an alternative to underscores), or BCP 47 (e.g. "en-UK")_as specified by {@link Locale#forLanguageTag} on Java 7+_@return a corresponding {@code Locale} instance, or {@code null} if none_@throws IllegalArgumentException in case of an invalid locale specification_@since 5.0.4_@see #parseLocaleString_@see Locale#forLanguageTag;@Nullable_	public static Locale parseLocale(String localeValue) {_		String[] tokens = tokenizeLocaleSource(localeValue)__		if (tokens.length == 1) {_			return Locale.forLanguageTag(localeValue)__		}_		return parseLocaleTokens(localeValue, tokens)__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,value,the,locale,value,following,either,code,locale,s,code,to,string,format,en,etc,also,accepting,spaces,as,separators,as,an,alternative,to,underscores,or,bcp,47,e,g,en,uk,as,specified,by,link,locale,for,language,tag,on,java,7,return,a,corresponding,code,locale,instance,or,code,null,if,none,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification,since,5,0,4,see,parse,locale,string,see,locale,for,language,tag;nullable,public,static,locale,parse,locale,string,locale,value,string,tokens,tokenize,locale,source,locale,value,if,tokens,length,1,return,locale,for,language,tag,locale,value,return,parse,locale,tokens,locale,value,tokens
StringUtils -> @Nullable 	public static Locale parseLocale(String localeValue);1522332352;Parse the given {@code String} value into a {@link Locale}, accepting_the {@link Locale#toString} format as well as BCP 47 language tags._@param localeValue the locale value: following either {@code Locale's}_{@code toString()} format ("en", "en_UK", etc), also accepting spaces as_separators (as an alternative to underscores), or BCP 47 (e.g. "en-UK")_as specified by {@link Locale#forLanguageTag} on Java 7+_@return a corresponding {@code Locale} instance, or {@code null} if none_@throws IllegalArgumentException in case of an invalid locale specification_@since 5.0.4_@see #parseLocaleString_@see Locale#forLanguageTag;@Nullable_	public static Locale parseLocale(String localeValue) {_		String[] tokens = tokenizeLocaleSource(localeValue)__		if (tokens.length == 1) {_			return Locale.forLanguageTag(localeValue)__		}_		return parseLocaleTokens(localeValue, tokens)__	};parse,the,given,code,string,value,into,a,link,locale,accepting,the,link,locale,to,string,format,as,well,as,bcp,47,language,tags,param,locale,value,the,locale,value,following,either,code,locale,s,code,to,string,format,en,etc,also,accepting,spaces,as,separators,as,an,alternative,to,underscores,or,bcp,47,e,g,en,uk,as,specified,by,link,locale,for,language,tag,on,java,7,return,a,corresponding,code,locale,instance,or,code,null,if,none,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification,since,5,0,4,see,parse,locale,string,see,locale,for,language,tag;nullable,public,static,locale,parse,locale,string,locale,value,string,tokens,tokenize,locale,source,locale,value,if,tokens,length,1,return,locale,for,language,tag,locale,value,return,parse,locale,tokens,locale,value,tokens
StringUtils -> @Nullable 	public static Locale parseLocale(String localeValue);1525166194;Parse the given {@code String} value into a {@link Locale}, accepting_the {@link Locale#toString} format as well as BCP 47 language tags._@param localeValue the locale value: following either {@code Locale's}_{@code toString()} format ("en", "en_UK", etc), also accepting spaces as_separators (as an alternative to underscores), or BCP 47 (e.g. "en-UK")_as specified by {@link Locale#forLanguageTag} on Java 7+_@return a corresponding {@code Locale} instance, or {@code null} if none_@throws IllegalArgumentException in case of an invalid locale specification_@since 5.0.4_@see #parseLocaleString_@see Locale#forLanguageTag;@Nullable_	public static Locale parseLocale(String localeValue) {_		String[] tokens = tokenizeLocaleSource(localeValue)__		if (tokens.length == 1) {_			return Locale.forLanguageTag(localeValue)__		}_		return parseLocaleTokens(localeValue, tokens)__	};parse,the,given,code,string,value,into,a,link,locale,accepting,the,link,locale,to,string,format,as,well,as,bcp,47,language,tags,param,locale,value,the,locale,value,following,either,code,locale,s,code,to,string,format,en,etc,also,accepting,spaces,as,separators,as,an,alternative,to,underscores,or,bcp,47,e,g,en,uk,as,specified,by,link,locale,for,language,tag,on,java,7,return,a,corresponding,code,locale,instance,or,code,null,if,none,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification,since,5,0,4,see,parse,locale,string,see,locale,for,language,tag;nullable,public,static,locale,parse,locale,string,locale,value,string,tokens,tokenize,locale,source,locale,value,if,tokens,length,1,return,locale,for,language,tag,locale,value,return,parse,locale,tokens,locale,value,tokens
StringUtils -> @Nullable 	public static Locale parseLocale(String localeValue);1530188116;Parse the given {@code String} value into a {@link Locale}, accepting_the {@link Locale#toString} format as well as BCP 47 language tags._@param localeValue the locale value: following either {@code Locale's}_{@code toString()} format ("en", "en_UK", etc), also accepting spaces as_separators (as an alternative to underscores), or BCP 47 (e.g. "en-UK")_as specified by {@link Locale#forLanguageTag} on Java 7+_@return a corresponding {@code Locale} instance, or {@code null} if none_@throws IllegalArgumentException in case of an invalid locale specification_@since 5.0.4_@see #parseLocaleString_@see Locale#forLanguageTag;@Nullable_	public static Locale parseLocale(String localeValue) {_		String[] tokens = tokenizeLocaleSource(localeValue)__		if (tokens.length == 1) {_			return Locale.forLanguageTag(localeValue)__		}_		return parseLocaleTokens(localeValue, tokens)__	};parse,the,given,code,string,value,into,a,link,locale,accepting,the,link,locale,to,string,format,as,well,as,bcp,47,language,tags,param,locale,value,the,locale,value,following,either,code,locale,s,code,to,string,format,en,etc,also,accepting,spaces,as,separators,as,an,alternative,to,underscores,or,bcp,47,e,g,en,uk,as,specified,by,link,locale,for,language,tag,on,java,7,return,a,corresponding,code,locale,instance,or,code,null,if,none,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification,since,5,0,4,see,parse,locale,string,see,locale,for,language,tag;nullable,public,static,locale,parse,locale,string,locale,value,string,tokens,tokenize,locale,source,locale,value,if,tokens,length,1,return,locale,for,language,tag,locale,value,return,parse,locale,tokens,locale,value,tokens
StringUtils -> @Nullable 	public static Locale parseLocale(String localeValue);1531843079;Parse the given {@code String} value into a {@link Locale}, accepting_the {@link Locale#toString} format as well as BCP 47 language tags._@param localeValue the locale value: following either {@code Locale's}_{@code toString()} format ("en", "en_UK", etc), also accepting spaces as_separators (as an alternative to underscores), or BCP 47 (e.g. "en-UK")_as specified by {@link Locale#forLanguageTag} on Java 7+_@return a corresponding {@code Locale} instance, or {@code null} if none_@throws IllegalArgumentException in case of an invalid locale specification_@since 5.0.4_@see #parseLocaleString_@see Locale#forLanguageTag;@Nullable_	public static Locale parseLocale(String localeValue) {_		String[] tokens = tokenizeLocaleSource(localeValue)__		if (tokens.length == 1) {_			validateLocalePart(localeValue)__			Locale resolved = Locale.forLanguageTag(localeValue)__			return (resolved.getLanguage().length() > 0 ? resolved : null)__		}_		return parseLocaleTokens(localeValue, tokens)__	};parse,the,given,code,string,value,into,a,link,locale,accepting,the,link,locale,to,string,format,as,well,as,bcp,47,language,tags,param,locale,value,the,locale,value,following,either,code,locale,s,code,to,string,format,en,etc,also,accepting,spaces,as,separators,as,an,alternative,to,underscores,or,bcp,47,e,g,en,uk,as,specified,by,link,locale,for,language,tag,on,java,7,return,a,corresponding,code,locale,instance,or,code,null,if,none,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification,since,5,0,4,see,parse,locale,string,see,locale,for,language,tag;nullable,public,static,locale,parse,locale,string,locale,value,string,tokens,tokenize,locale,source,locale,value,if,tokens,length,1,validate,locale,part,locale,value,locale,resolved,locale,for,language,tag,locale,value,return,resolved,get,language,length,0,resolved,null,return,parse,locale,tokens,locale,value,tokens
StringUtils -> @Nullable 	public static Locale parseLocale(String localeValue);1531905026;Parse the given {@code String} value into a {@link Locale}, accepting_the {@link Locale#toString} format as well as BCP 47 language tags._@param localeValue the locale value: following either {@code Locale's}_{@code toString()} format ("en", "en_UK", etc), also accepting spaces as_separators (as an alternative to underscores), or BCP 47 (e.g. "en-UK")_as specified by {@link Locale#forLanguageTag} on Java 7+_@return a corresponding {@code Locale} instance, or {@code null} if none_@throws IllegalArgumentException in case of an invalid locale specification_@since 5.0.4_@see #parseLocaleString_@see Locale#forLanguageTag;@Nullable_	public static Locale parseLocale(String localeValue) {_		String[] tokens = tokenizeLocaleSource(localeValue)__		if (tokens.length == 1) {_			validateLocalePart(localeValue)__			Locale resolved = Locale.forLanguageTag(localeValue)__			return (resolved.getLanguage().length() > 0 ? resolved : null)__		}_		return parseLocaleTokens(localeValue, tokens)__	};parse,the,given,code,string,value,into,a,link,locale,accepting,the,link,locale,to,string,format,as,well,as,bcp,47,language,tags,param,locale,value,the,locale,value,following,either,code,locale,s,code,to,string,format,en,etc,also,accepting,spaces,as,separators,as,an,alternative,to,underscores,or,bcp,47,e,g,en,uk,as,specified,by,link,locale,for,language,tag,on,java,7,return,a,corresponding,code,locale,instance,or,code,null,if,none,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification,since,5,0,4,see,parse,locale,string,see,locale,for,language,tag;nullable,public,static,locale,parse,locale,string,locale,value,string,tokens,tokenize,locale,source,locale,value,if,tokens,length,1,validate,locale,part,locale,value,locale,resolved,locale,for,language,tag,locale,value,return,resolved,get,language,length,0,resolved,null,return,parse,locale,tokens,locale,value,tokens
StringUtils -> @Nullable 	public static Locale parseLocale(String localeValue);1533557519;Parse the given {@code String} value into a {@link Locale}, accepting_the {@link Locale#toString} format as well as BCP 47 language tags._@param localeValue the locale value: following either {@code Locale's}_{@code toString()} format ("en", "en_UK", etc), also accepting spaces as_separators (as an alternative to underscores), or BCP 47 (e.g. "en-UK")_as specified by {@link Locale#forLanguageTag} on Java 7+_@return a corresponding {@code Locale} instance, or {@code null} if none_@throws IllegalArgumentException in case of an invalid locale specification_@since 5.0.4_@see #parseLocaleString_@see Locale#forLanguageTag;@Nullable_	public static Locale parseLocale(String localeValue) {_		String[] tokens = tokenizeLocaleSource(localeValue)__		if (tokens.length == 1) {_			validateLocalePart(localeValue)__			Locale resolved = Locale.forLanguageTag(localeValue)__			return (resolved.getLanguage().length() > 0 ? resolved : null)__		}_		return parseLocaleTokens(localeValue, tokens)__	};parse,the,given,code,string,value,into,a,link,locale,accepting,the,link,locale,to,string,format,as,well,as,bcp,47,language,tags,param,locale,value,the,locale,value,following,either,code,locale,s,code,to,string,format,en,etc,also,accepting,spaces,as,separators,as,an,alternative,to,underscores,or,bcp,47,e,g,en,uk,as,specified,by,link,locale,for,language,tag,on,java,7,return,a,corresponding,code,locale,instance,or,code,null,if,none,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification,since,5,0,4,see,parse,locale,string,see,locale,for,language,tag;nullable,public,static,locale,parse,locale,string,locale,value,string,tokens,tokenize,locale,source,locale,value,if,tokens,length,1,validate,locale,part,locale,value,locale,resolved,locale,for,language,tag,locale,value,return,resolved,get,language,length,0,resolved,null,return,parse,locale,tokens,locale,value,tokens
StringUtils -> @Nullable 	public static Locale parseLocale(String localeValue);1533602820;Parse the given {@code String} value into a {@link Locale}, accepting_the {@link Locale#toString} format as well as BCP 47 language tags._@param localeValue the locale value: following either {@code Locale's}_{@code toString()} format ("en", "en_UK", etc), also accepting spaces as_separators (as an alternative to underscores), or BCP 47 (e.g. "en-UK")_as specified by {@link Locale#forLanguageTag} on Java 7+_@return a corresponding {@code Locale} instance, or {@code null} if none_@throws IllegalArgumentException in case of an invalid locale specification_@since 5.0.4_@see #parseLocaleString_@see Locale#forLanguageTag;@Nullable_	public static Locale parseLocale(String localeValue) {_		String[] tokens = tokenizeLocaleSource(localeValue)__		if (tokens.length == 1) {_			validateLocalePart(localeValue)__			Locale resolved = Locale.forLanguageTag(localeValue)__			return (resolved.getLanguage().length() > 0 ? resolved : null)__		}_		return parseLocaleTokens(localeValue, tokens)__	};parse,the,given,code,string,value,into,a,link,locale,accepting,the,link,locale,to,string,format,as,well,as,bcp,47,language,tags,param,locale,value,the,locale,value,following,either,code,locale,s,code,to,string,format,en,etc,also,accepting,spaces,as,separators,as,an,alternative,to,underscores,or,bcp,47,e,g,en,uk,as,specified,by,link,locale,for,language,tag,on,java,7,return,a,corresponding,code,locale,instance,or,code,null,if,none,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification,since,5,0,4,see,parse,locale,string,see,locale,for,language,tag;nullable,public,static,locale,parse,locale,string,locale,value,string,tokens,tokenize,locale,source,locale,value,if,tokens,length,1,validate,locale,part,locale,value,locale,resolved,locale,for,language,tag,locale,value,return,resolved,get,language,length,0,resolved,null,return,parse,locale,tokens,locale,value,tokens
StringUtils -> @Nullable 	public static Locale parseLocale(String localeValue);1535316501;Parse the given {@code String} value into a {@link Locale}, accepting_the {@link Locale#toString} format as well as BCP 47 language tags._@param localeValue the locale value: following either {@code Locale's}_{@code toString()} format ("en", "en_UK", etc), also accepting spaces as_separators (as an alternative to underscores), or BCP 47 (e.g. "en-UK")_as specified by {@link Locale#forLanguageTag} on Java 7+_@return a corresponding {@code Locale} instance, or {@code null} if none_@throws IllegalArgumentException in case of an invalid locale specification_@since 5.0.4_@see #parseLocaleString_@see Locale#forLanguageTag;@Nullable_	public static Locale parseLocale(String localeValue) {_		String[] tokens = tokenizeLocaleSource(localeValue)__		if (tokens.length == 1) {_			validateLocalePart(localeValue)__			Locale resolved = Locale.forLanguageTag(localeValue)__			return (resolved.getLanguage().length() > 0 ? resolved : null)__		}_		return parseLocaleTokens(localeValue, tokens)__	};parse,the,given,code,string,value,into,a,link,locale,accepting,the,link,locale,to,string,format,as,well,as,bcp,47,language,tags,param,locale,value,the,locale,value,following,either,code,locale,s,code,to,string,format,en,etc,also,accepting,spaces,as,separators,as,an,alternative,to,underscores,or,bcp,47,e,g,en,uk,as,specified,by,link,locale,for,language,tag,on,java,7,return,a,corresponding,code,locale,instance,or,code,null,if,none,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification,since,5,0,4,see,parse,locale,string,see,locale,for,language,tag;nullable,public,static,locale,parse,locale,string,locale,value,string,tokens,tokenize,locale,source,locale,value,if,tokens,length,1,validate,locale,part,locale,value,locale,resolved,locale,for,language,tag,locale,value,return,resolved,get,language,length,0,resolved,null,return,parse,locale,tokens,locale,value,tokens
StringUtils -> @Nullable 	public static Locale parseLocale(String localeValue);1550237113;Parse the given {@code String} value into a {@link Locale}, accepting_the {@link Locale#toString} format as well as BCP 47 language tags._@param localeValue the locale value: following either {@code Locale's}_{@code toString()} format ("en", "en_UK", etc), also accepting spaces as_separators (as an alternative to underscores), or BCP 47 (e.g. "en-UK")_as specified by {@link Locale#forLanguageTag} on Java 7+_@return a corresponding {@code Locale} instance, or {@code null} if none_@throws IllegalArgumentException in case of an invalid locale specification_@since 5.0.4_@see #parseLocaleString_@see Locale#forLanguageTag;@Nullable_	public static Locale parseLocale(String localeValue) {_		String[] tokens = tokenizeLocaleSource(localeValue)__		if (tokens.length == 1) {_			validateLocalePart(localeValue)__			Locale resolved = Locale.forLanguageTag(localeValue)__			return (resolved.getLanguage().length() > 0 ? resolved : null)__		}_		return parseLocaleTokens(localeValue, tokens)__	};parse,the,given,code,string,value,into,a,link,locale,accepting,the,link,locale,to,string,format,as,well,as,bcp,47,language,tags,param,locale,value,the,locale,value,following,either,code,locale,s,code,to,string,format,en,etc,also,accepting,spaces,as,separators,as,an,alternative,to,underscores,or,bcp,47,e,g,en,uk,as,specified,by,link,locale,for,language,tag,on,java,7,return,a,corresponding,code,locale,instance,or,code,null,if,none,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification,since,5,0,4,see,parse,locale,string,see,locale,for,language,tag;nullable,public,static,locale,parse,locale,string,locale,value,string,tokens,tokenize,locale,source,locale,value,if,tokens,length,1,validate,locale,part,locale,value,locale,resolved,locale,for,language,tag,locale,value,return,resolved,get,language,length,0,resolved,null,return,parse,locale,tokens,locale,value,tokens
StringUtils -> @Nullable 	public static Locale parseLocale(String localeValue);1550238935;Parse the given {@code String} value into a {@link Locale}, accepting_the {@link Locale#toString} format as well as BCP 47 language tags._@param localeValue the locale value: following either {@code Locale's}_{@code toString()} format ("en", "en_UK", etc), also accepting spaces as_separators (as an alternative to underscores), or BCP 47 (e.g. "en-UK")_as specified by {@link Locale#forLanguageTag} on Java 7+_@return a corresponding {@code Locale} instance, or {@code null} if none_@throws IllegalArgumentException in case of an invalid locale specification_@since 5.0.4_@see #parseLocaleString_@see Locale#forLanguageTag;@Nullable_	public static Locale parseLocale(String localeValue) {_		String[] tokens = tokenizeLocaleSource(localeValue)__		if (tokens.length == 1) {_			validateLocalePart(localeValue)__			Locale resolved = Locale.forLanguageTag(localeValue)__			return (resolved.getLanguage().length() > 0 ? resolved : null)__		}_		return parseLocaleTokens(localeValue, tokens)__	};parse,the,given,code,string,value,into,a,link,locale,accepting,the,link,locale,to,string,format,as,well,as,bcp,47,language,tags,param,locale,value,the,locale,value,following,either,code,locale,s,code,to,string,format,en,etc,also,accepting,spaces,as,separators,as,an,alternative,to,underscores,or,bcp,47,e,g,en,uk,as,specified,by,link,locale,for,language,tag,on,java,7,return,a,corresponding,code,locale,instance,or,code,null,if,none,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification,since,5,0,4,see,parse,locale,string,see,locale,for,language,tag;nullable,public,static,locale,parse,locale,string,locale,value,string,tokens,tokenize,locale,source,locale,value,if,tokens,length,1,validate,locale,part,locale,value,locale,resolved,locale,for,language,tag,locale,value,return,resolved,get,language,length,0,resolved,null,return,parse,locale,tokens,locale,value,tokens
StringUtils -> public static Object quoteIfString(Object obj);1328020251;Turn the given Object into a String with single quotes_if it is a String_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted String (e.g. "'myString'"),_or the input object as-is if not a String;public static Object quoteIfString(Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,string,with,single,quotes,if,it,is,a,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,string,e,g,my,string,or,the,input,object,as,is,if,not,a,string;public,static,object,quote,if,string,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> public static Object quoteIfString(Object obj);1337236962;Turn the given Object into a String with single quotes_if it is a String_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted String (e.g. "'myString'"),_or the input object as-is if not a String;public static Object quoteIfString(Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,string,with,single,quotes,if,it,is,a,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,string,e,g,my,string,or,the,input,object,as,is,if,not,a,string;public,static,object,quote,if,string,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> public static Object quoteIfString(Object obj);1356735495;Turn the given Object into a String with single quotes_if it is a String_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted String (e.g. "'myString'"),_or the input object as-is if not a String;public static Object quoteIfString(Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,string,with,single,quotes,if,it,is,a,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,string,e,g,my,string,or,the,input,object,as,is,if,not,a,string;public,static,object,quote,if,string,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> public static Object quoteIfString(Object obj);1367955086;Turn the given Object into a String with single quotes_if it is a String_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted String (e.g. "'myString'"),_or the input object as-is if not a String;public static Object quoteIfString(Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,string,with,single,quotes,if,it,is,a,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,string,e,g,my,string,or,the,input,object,as,is,if,not,a,string;public,static,object,quote,if,string,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> public static Object quoteIfString(Object obj);1380921248;Turn the given Object into a String with single quotes_if it is a String_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted String (e.g. "'myString'"),_or the input object as-is if not a String;public static Object quoteIfString(Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,string,with,single,quotes,if,it,is,a,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,string,e,g,my,string,or,the,input,object,as,is,if,not,a,string;public,static,object,quote,if,string,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> public static Object quoteIfString(Object obj);1382750743;Turn the given Object into a String with single quotes_if it is a String_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted String (e.g. "'myString'"),_or the input object as-is if not a String;public static Object quoteIfString(Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,string,with,single,quotes,if,it,is,a,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,string,e,g,my,string,or,the,input,object,as,is,if,not,a,string;public,static,object,quote,if,string,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> public static Object quoteIfString(Object obj);1385423968;Turn the given Object into a String with single quotes_if it is a String_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted String (e.g. "'myString'"),_or the input object as-is if not a String;public static Object quoteIfString(Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,string,with,single,quotes,if,it,is,a,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,string,e,g,my,string,or,the,input,object,as,is,if,not,a,string;public,static,object,quote,if,string,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> public static Object quoteIfString(Object obj);1400189212;Turn the given Object into a String with single quotes_if it is a String_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted String (e.g. "'myString'"),_or the input object as-is if not a String;public static Object quoteIfString(Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,string,with,single,quotes,if,it,is,a,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,string,e,g,my,string,or,the,input,object,as,is,if,not,a,string;public,static,object,quote,if,string,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> public static Object quoteIfString(Object obj);1400531359;Turn the given Object into a String with single quotes_if it is a String_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted String (e.g. "'myString'"),_or the input object as-is if not a String;public static Object quoteIfString(Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,string,with,single,quotes,if,it,is,a,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,string,e,g,my,string,or,the,input,object,as,is,if,not,a,string;public,static,object,quote,if,string,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> public static Object quoteIfString(Object obj);1402676350;Turn the given Object into a String with single quotes_if it is a String_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted String (e.g. "'myString'"),_or the input object as-is if not a String;public static Object quoteIfString(Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,string,with,single,quotes,if,it,is,a,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,string,e,g,my,string,or,the,input,object,as,is,if,not,a,string;public,static,object,quote,if,string,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> public static Object quoteIfString(Object obj);1426267150;Turn the given Object into a String with single quotes_if it is a String_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted String (e.g. "'myString'"),_or the input object as-is if not a String;public static Object quoteIfString(Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,string,with,single,quotes,if,it,is,a,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,string,e,g,my,string,or,the,input,object,as,is,if,not,a,string;public,static,object,quote,if,string,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> public static Object quoteIfString(Object obj);1429034538;Turn the given Object into a String with single quotes_if it is a String_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted String (e.g. "'myString'"),_or the input object as-is if not a String;public static Object quoteIfString(Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,string,with,single,quotes,if,it,is,a,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,string,e,g,my,string,or,the,input,object,as,is,if,not,a,string;public,static,object,quote,if,string,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> public static Object quoteIfString(Object obj);1429034756;Turn the given Object into a {@code String} with single quotes_if it is a {@code String}_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or the input object as-is if not a {@code String};public static Object quoteIfString(Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,code,string,with,single,quotes,if,it,is,a,code,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,the,input,object,as,is,if,not,a,code,string;public,static,object,quote,if,string,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> public static Object quoteIfString(Object obj);1431006895;Turn the given Object into a {@code String} with single quotes_if it is a {@code String}_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or the input object as-is if not a {@code String};public static Object quoteIfString(Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,code,string,with,single,quotes,if,it,is,a,code,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,the,input,object,as,is,if,not,a,code,string;public,static,object,quote,if,string,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> public static Object quoteIfString(Object obj);1431007368;Turn the given Object into a {@code String} with single quotes_if it is a {@code String}_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or the input object as-is if not a {@code String};public static Object quoteIfString(Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,code,string,with,single,quotes,if,it,is,a,code,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,the,input,object,as,is,if,not,a,code,string;public,static,object,quote,if,string,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> public static Object quoteIfString(Object obj);1449489126;Turn the given Object into a {@code String} with single quotes_if it is a {@code String}_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or the input object as-is if not a {@code String};public static Object quoteIfString(Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,code,string,with,single,quotes,if,it,is,a,code,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,the,input,object,as,is,if,not,a,code,string;public,static,object,quote,if,string,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> public static Object quoteIfString(Object obj);1467730834;Turn the given Object into a {@code String} with single quotes_if it is a {@code String}_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or the input object as-is if not a {@code String};public static Object quoteIfString(Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,code,string,with,single,quotes,if,it,is,a,code,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,the,input,object,as,is,if,not,a,code,string;public,static,object,quote,if,string,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> public static Object quoteIfString(Object obj);1472128018;Turn the given Object into a {@code String} with single quotes_if it is a {@code String}_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or the input object as-is if not a {@code String};public static Object quoteIfString(Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,code,string,with,single,quotes,if,it,is,a,code,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,the,input,object,as,is,if,not,a,code,string;public,static,object,quote,if,string,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> public static Object quoteIfString(Object obj);1472202842;Turn the given Object into a {@code String} with single quotes_if it is a {@code String}_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or the input object as-is if not a {@code String};public static Object quoteIfString(Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,code,string,with,single,quotes,if,it,is,a,code,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,the,input,object,as,is,if,not,a,code,string;public,static,object,quote,if,string,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> public static Object quoteIfString(Object obj);1473942665;Turn the given Object into a {@code String} with single quotes_if it is a {@code String}_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or the input object as-is if not a {@code String};public static Object quoteIfString(Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,code,string,with,single,quotes,if,it,is,a,code,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,the,input,object,as,is,if,not,a,code,string;public,static,object,quote,if,string,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> public static Object quoteIfString(Object obj);1484248946;Turn the given Object into a {@code String} with single quotes_if it is a {@code String}_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or the input object as-is if not a {@code String};public static Object quoteIfString(Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,code,string,with,single,quotes,if,it,is,a,code,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,the,input,object,as,is,if,not,a,code,string;public,static,object,quote,if,string,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> public static Object quoteIfString(Object obj);1484260238;Turn the given Object into a {@code String} with single quotes_if it is a {@code String}_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or the input object as-is if not a {@code String};public static Object quoteIfString(Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,code,string,with,single,quotes,if,it,is,a,code,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,the,input,object,as,is,if,not,a,code,string;public,static,object,quote,if,string,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> public static Object quoteIfString(Object obj);1484694546;Turn the given Object into a {@code String} with single quotes_if it is a {@code String}_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or the input object as-is if not a {@code String};public static Object quoteIfString(Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,code,string,with,single,quotes,if,it,is,a,code,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,the,input,object,as,is,if,not,a,code,string;public,static,object,quote,if,string,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> public static Object quoteIfString(Object obj);1487760984;Turn the given Object into a {@code String} with single quotes_if it is a {@code String}_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or the input object as-is if not a {@code String};public static Object quoteIfString(Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,code,string,with,single,quotes,if,it,is,a,code,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,the,input,object,as,is,if,not,a,code,string;public,static,object,quote,if,string,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> public static Object quoteIfString(Object obj);1487778834;Turn the given Object into a {@code String} with single quotes_if it is a {@code String}_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or the input object as-is if not a {@code String};public static Object quoteIfString(Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,code,string,with,single,quotes,if,it,is,a,code,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,the,input,object,as,is,if,not,a,code,string;public,static,object,quote,if,string,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> public static Object quoteIfString(Object obj);1491898314;Turn the given Object into a {@code String} with single quotes_if it is a {@code String}_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or the input object as-is if not a {@code String};public static Object quoteIfString(Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,code,string,with,single,quotes,if,it,is,a,code,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,the,input,object,as,is,if,not,a,code,string;public,static,object,quote,if,string,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> public static Object quoteIfString(Object obj);1491903650;Turn the given Object into a {@code String} with single quotes_if it is a {@code String}_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or the input object as-is if not a {@code String};public static Object quoteIfString(Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,code,string,with,single,quotes,if,it,is,a,code,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,the,input,object,as,is,if,not,a,code,string;public,static,object,quote,if,string,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> public static Object quoteIfString(Object obj);1495868221;Turn the given Object into a {@code String} with single quotes_if it is a {@code String}_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or the input object as-is if not a {@code String};public static Object quoteIfString(Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,code,string,with,single,quotes,if,it,is,a,code,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,the,input,object,as,is,if,not,a,code,string;public,static,object,quote,if,string,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> public static Object quoteIfString(Object obj);1496243689;Turn the given Object into a {@code String} with single quotes_if it is a {@code String}_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or the input object as-is if not a {@code String};public static Object quoteIfString(Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,code,string,with,single,quotes,if,it,is,a,code,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,the,input,object,as,is,if,not,a,code,string;public,static,object,quote,if,string,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> public static Object quoteIfString(Object obj);1496259743;Turn the given Object into a {@code String} with single quotes_if it is a {@code String}_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or the input object as-is if not a {@code String};public static Object quoteIfString(Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,code,string,with,single,quotes,if,it,is,a,code,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,the,input,object,as,is,if,not,a,code,string;public,static,object,quote,if,string,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> public static String[] split(String toSplit, String delimiter);1328020251;Split a String at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or <code>null</code> if the delimiter wasn't found in the given input String;public static String[] split(String toSplit, String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}_		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,code,if,the,delimiter,wasn,t,found,in,the,given,input,string;public,static,string,split,string,to,split,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> public static String[] split(String toSplit, String delimiter);1337236962;Split a String at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or <code>null</code> if the delimiter wasn't found in the given input String;public static String[] split(String toSplit, String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}_		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,code,if,the,delimiter,wasn,t,found,in,the,given,input,string;public,static,string,split,string,to,split,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> public static String[] split(String toSplit, String delimiter);1356735495;Split a String at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input String;public static String[] split(String toSplit, String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}_		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,string;public,static,string,split,string,to,split,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> public static String[] split(String toSplit, String delimiter);1367955086;Split a String at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input String;public static String[] split(String toSplit, String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}_		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,string;public,static,string,split,string,to,split,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> public static String[] split(String toSplit, String delimiter);1380921248;Split a String at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input String;public static String[] split(String toSplit, String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}_		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,string;public,static,string,split,string,to,split,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> public static String[] split(String toSplit, String delimiter);1382750743;Split a String at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input String;public static String[] split(String toSplit, String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}_		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,string;public,static,string,split,string,to,split,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> public static String[] split(String toSplit, String delimiter);1385423968;Split a String at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input String;public static String[] split(String toSplit, String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}_		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,string;public,static,string,split,string,to,split,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> public static String[] split(String toSplit, String delimiter);1400189212;Split a String at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input String;public static String[] split(String toSplit, String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}_		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,string;public,static,string,split,string,to,split,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> public static String[] split(String toSplit, String delimiter);1400531359;Split a String at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input String;public static String[] split(String toSplit, String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}_		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,string;public,static,string,split,string,to,split,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> public static String[] split(String toSplit, String delimiter);1402676350;Split a String at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input String;public static String[] split(String toSplit, String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}_		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,string;public,static,string,split,string,to,split,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> public static String[] split(String toSplit, String delimiter);1426267150;Split a String at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input String;public static String[] split(String toSplit, String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}_		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,string;public,static,string,split,string,to,split,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> public static String[] split(String toSplit, String delimiter);1429034538;Split a String at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input String;public static String[] split(String toSplit, String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}_		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,string;public,static,string,split,string,to,split,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> public static String[] split(String toSplit, String delimiter);1429034756;Split a {@code String} at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input {@code String};public static String[] split(String toSplit, String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}_		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,code,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,code,string;public,static,string,split,string,to,split,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> public static String[] split(String toSplit, String delimiter);1431006895;Split a {@code String} at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input {@code String};public static String[] split(String toSplit, String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}_		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,code,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,code,string;public,static,string,split,string,to,split,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> public static String[] split(String toSplit, String delimiter);1431007368;Split a {@code String} at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input {@code String};public static String[] split(String toSplit, String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}_		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,code,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,code,string;public,static,string,split,string,to,split,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> public static String[] split(String toSplit, String delimiter);1449489126;Split a {@code String} at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input {@code String};public static String[] split(String toSplit, String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}_		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,code,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,code,string;public,static,string,split,string,to,split,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> public static String[] split(String toSplit, String delimiter);1467730834;Split a {@code String} at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input {@code String};public static String[] split(String toSplit, String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}_		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,code,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,code,string;public,static,string,split,string,to,split,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> public static String[] split(String toSplit, String delimiter);1472128018;Split a {@code String} at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input {@code String};public static String[] split(String toSplit, String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}_		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,code,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,code,string;public,static,string,split,string,to,split,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> public static String[] split(String toSplit, String delimiter);1472202842;Split a {@code String} at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input {@code String};public static String[] split(String toSplit, String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}_		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,code,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,code,string;public,static,string,split,string,to,split,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> public static String[] split(String toSplit, String delimiter);1473942665;Split a {@code String} at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input {@code String};public static String[] split(String toSplit, String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}_		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,code,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,code,string;public,static,string,split,string,to,split,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> public static String[] split(String toSplit, String delimiter);1484248946;Split a {@code String} at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input {@code String};public static String[] split(String toSplit, String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}_		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,code,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,code,string;public,static,string,split,string,to,split,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> public static String[] split(String toSplit, String delimiter);1484260238;Split a {@code String} at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input {@code String};public static String[] split(String toSplit, String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}_		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,code,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,code,string;public,static,string,split,string,to,split,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> public static String[] split(String toSplit, String delimiter);1484694546;Split a {@code String} at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input {@code String};public static String[] split(String toSplit, String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}_		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,code,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,code,string;public,static,string,split,string,to,split,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> public static String[] split(String toSplit, String delimiter);1487760984;Split a {@code String} at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input {@code String};public static String[] split(String toSplit, String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}_		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,code,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,code,string;public,static,string,split,string,to,split,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> public static String[] split(String toSplit, String delimiter);1487778834;Split a {@code String} at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input {@code String};public static String[] split(String toSplit, String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}_		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,code,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,code,string;public,static,string,split,string,to,split,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> public static String[] split(String toSplit, String delimiter);1491898314;Split a {@code String} at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input {@code String};public static String[] split(String toSplit, String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}__		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,code,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,code,string;public,static,string,split,string,to,split,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> public static String[] split(String toSplit, String delimiter);1491903650;Split a {@code String} at the first occurrence of the delimiter._Does not include the delimiter in the result._@param toSplit the string to split_@param delimiter to split the string up with_@return a two element array with index 0 being before the delimiter, and_index 1 being after the delimiter (neither element includes the delimiter)__or {@code null} if the delimiter wasn't found in the given input {@code String};public static String[] split(String toSplit, String delimiter) {_		if (!hasLength(toSplit) || !hasLength(delimiter)) {_			return null__		}_		int offset = toSplit.indexOf(delimiter)__		if (offset < 0) {_			return null__		}__		String beforeDelimiter = toSplit.substring(0, offset)__		String afterDelimiter = toSplit.substring(offset + delimiter.length())__		return new String[] {beforeDelimiter, afterDelimiter}__	};split,a,code,string,at,the,first,occurrence,of,the,delimiter,does,not,include,the,delimiter,in,the,result,param,to,split,the,string,to,split,param,delimiter,to,split,the,string,up,with,return,a,two,element,array,with,index,0,being,before,the,delimiter,and,index,1,being,after,the,delimiter,neither,element,includes,the,delimiter,or,code,null,if,the,delimiter,wasn,t,found,in,the,given,input,code,string;public,static,string,split,string,to,split,string,delimiter,if,has,length,to,split,has,length,delimiter,return,null,int,offset,to,split,index,of,delimiter,if,offset,0,return,null,string,before,delimiter,to,split,substring,0,offset,string,after,delimiter,to,split,substring,offset,delimiter,length,return,new,string,before,delimiter,after,delimiter
StringUtils -> public static boolean containsWhitespace(@Nullable String str);1495868221;Check whether the given {@code String} contains any whitespace characters._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(@Nullable String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,code,string,contains,any,whitespace,characters,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,nullable,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(@Nullable String str);1496243689;Check whether the given {@code String} contains any whitespace characters._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(@Nullable String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,code,string,contains,any,whitespace,characters,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,nullable,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(@Nullable String str);1496259743;Check whether the given {@code String} contains any whitespace characters._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(@Nullable String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,code,string,contains,any,whitespace,characters,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,nullable,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(@Nullable String str);1496837955;Check whether the given {@code String} contains any whitespace characters._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(@Nullable String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,code,string,contains,any,whitespace,characters,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,nullable,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(@Nullable String str);1499270197;Check whether the given {@code String} contains any whitespace characters._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(@Nullable String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,code,string,contains,any,whitespace,characters,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,nullable,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(@Nullable String str);1508667152;Check whether the given {@code String} contains any whitespace characters._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(@Nullable String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,code,string,contains,any,whitespace,characters,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,nullable,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(@Nullable String str);1508675477;Check whether the given {@code String} contains any whitespace characters._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(@Nullable String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,code,string,contains,any,whitespace,characters,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,nullable,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(@Nullable String str);1508843807;Check whether the given {@code String} contains any whitespace characters._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(@Nullable String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,code,string,contains,any,whitespace,characters,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,nullable,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(@Nullable String str);1516903831;Check whether the given {@code String} contains any whitespace characters._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(@Nullable String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,code,string,contains,any,whitespace,characters,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,nullable,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(@Nullable String str);1519295386;Check whether the given {@code String} contains any whitespace characters._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(@Nullable String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,code,string,contains,any,whitespace,characters,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,nullable,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(@Nullable String str);1519308837;Check whether the given {@code String} contains any whitespace characters._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(@Nullable String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,code,string,contains,any,whitespace,characters,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,nullable,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(@Nullable String str);1519588127;Check whether the given {@code String} contains any whitespace characters._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(@Nullable String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,code,string,contains,any,whitespace,characters,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,nullable,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(@Nullable String str);1522332352;Check whether the given {@code String} contains any whitespace characters._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(@Nullable String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,code,string,contains,any,whitespace,characters,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,nullable,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(@Nullable String str);1525166194;Check whether the given {@code String} contains any whitespace characters._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(@Nullable String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,code,string,contains,any,whitespace,characters,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,nullable,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(@Nullable String str);1530188116;Check whether the given {@code String} contains any whitespace characters._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(@Nullable String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,code,string,contains,any,whitespace,characters,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,nullable,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(@Nullable String str);1531843079;Check whether the given {@code String} contains any whitespace characters._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(@Nullable String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,code,string,contains,any,whitespace,characters,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,nullable,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(@Nullable String str);1531905026;Check whether the given {@code String} contains any whitespace characters._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(@Nullable String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,code,string,contains,any,whitespace,characters,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,nullable,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(@Nullable String str);1533557519;Check whether the given {@code String} contains any whitespace characters._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(@Nullable String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,code,string,contains,any,whitespace,characters,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,nullable,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(@Nullable String str);1533602820;Check whether the given {@code String} contains any whitespace characters._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(@Nullable String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,code,string,contains,any,whitespace,characters,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,nullable,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(@Nullable String str);1535316501;Check whether the given {@code String} contains any whitespace characters._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(@Nullable String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,code,string,contains,any,whitespace,characters,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,nullable,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(@Nullable String str);1550237113;Check whether the given {@code String} contains any whitespace characters._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(@Nullable String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,code,string,contains,any,whitespace,characters,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,nullable,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(@Nullable String str);1550238935;Check whether the given {@code String} contains any whitespace characters._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(@Nullable String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,code,string,contains,any,whitespace,characters,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,nullable,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> @Nullable 	public static String[] tokenizeToStringArray( 			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1495868221;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@param trimTokens trim the tokens via {@link String#trim()}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens ({@code null} if the input {@code String}_was {@code null})_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;@Nullable_	public static String[] tokenizeToStringArray(_			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return null__		}__		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,param,trim,tokens,trim,the,tokens,via,link,string,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,code,null,if,the,input,code,string,was,code,null,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;nullable,public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,null,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> @Nullable 	public static String[] tokenizeToStringArray( 			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1496243689;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@param trimTokens trim the tokens via {@link String#trim()}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens ({@code null} if the input {@code String}_was {@code null})_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;@Nullable_	public static String[] tokenizeToStringArray(_			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return null__		}__		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,param,trim,tokens,trim,the,tokens,via,link,string,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,code,null,if,the,input,code,string,was,code,null,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;nullable,public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,null,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> @Nullable 	public static String[] tokenizeToStringArray( 			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens);1496259743;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@param trimTokens trim the tokens via {@link String#trim()}_@param ignoreEmptyTokens omit empty tokens from the result array_(only applies to tokens that are empty after trimming_ StringTokenizer_will not consider subsequent delimiters as token in the first place)._@return an array of the tokens ({@code null} if the input {@code String}_was {@code null})_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;@Nullable_	public static String[] tokenizeToStringArray(_			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {__		if (str == null) {_			return null__		}__		StringTokenizer st = new StringTokenizer(str, delimiters)__		List<String> tokens = new ArrayList<>()__		while (st.hasMoreTokens()) {_			String token = st.nextToken()__			if (trimTokens) {_				token = token.trim()__			}_			if (!ignoreEmptyTokens || token.length() > 0) {_				tokens.add(token)__			}_		}_		return toStringArray(tokens)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,param,trim,tokens,trim,the,tokens,via,link,string,trim,param,ignore,empty,tokens,omit,empty,tokens,from,the,result,array,only,applies,to,tokens,that,are,empty,after,trimming,string,tokenizer,will,not,consider,subsequent,delimiters,as,token,in,the,first,place,return,an,array,of,the,tokens,code,null,if,the,input,code,string,was,code,null,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;nullable,public,static,string,tokenize,to,string,array,nullable,string,str,string,delimiters,boolean,trim,tokens,boolean,ignore,empty,tokens,if,str,null,return,null,string,tokenizer,st,new,string,tokenizer,str,delimiters,list,string,tokens,new,array,list,while,st,has,more,tokens,string,token,st,next,token,if,trim,tokens,token,token,trim,if,ignore,empty,tokens,token,length,0,tokens,add,token,return,to,string,array,tokens
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter);1328020251;Take a String which is a delimited list and convert it to a String array._<p>A single delimiter can consists of more than one character: It will still_be considered as single delimiter string, rather than as bunch of potential_delimiter characters - in contrast to <code>tokenizeToStringArray</code>._@param str the input String_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,string,which,is,a,delimited,list,and,convert,it,to,a,string,array,p,a,single,delimiter,can,consists,of,more,than,one,character,it,will,still,be,considered,as,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,code,tokenize,to,string,array,code,param,str,the,input,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter);1337236962;Take a String which is a delimited list and convert it to a String array._<p>A single delimiter can consists of more than one character: It will still_be considered as single delimiter string, rather than as bunch of potential_delimiter characters - in contrast to <code>tokenizeToStringArray</code>._@param str the input String_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,string,which,is,a,delimited,list,and,convert,it,to,a,string,array,p,a,single,delimiter,can,consists,of,more,than,one,character,it,will,still,be,considered,as,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,code,tokenize,to,string,array,code,param,str,the,input,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter);1356735495;Take a String which is a delimited list and convert it to a String array._<p>A single delimiter can consists of more than one character: It will still_be considered as single delimiter string, rather than as bunch of potential_delimiter characters - in contrast to {@code tokenizeToStringArray}._@param str the input String_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,string,which,is,a,delimited,list,and,convert,it,to,a,string,array,p,a,single,delimiter,can,consists,of,more,than,one,character,it,will,still,be,considered,as,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,code,tokenize,to,string,array,param,str,the,input,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter);1367955086;Take a String which is a delimited list and convert it to a String array._<p>A single delimiter can consists of more than one character: It will still_be considered as single delimiter string, rather than as bunch of potential_delimiter characters - in contrast to {@code tokenizeToStringArray}._@param str the input String_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,string,which,is,a,delimited,list,and,convert,it,to,a,string,array,p,a,single,delimiter,can,consists,of,more,than,one,character,it,will,still,be,considered,as,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,code,tokenize,to,string,array,param,str,the,input,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter);1380921248;Take a String which is a delimited list and convert it to a String array._<p>A single delimiter can consists of more than one character: It will still_be considered as single delimiter string, rather than as bunch of potential_delimiter characters - in contrast to {@code tokenizeToStringArray}._@param str the input String_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,string,which,is,a,delimited,list,and,convert,it,to,a,string,array,p,a,single,delimiter,can,consists,of,more,than,one,character,it,will,still,be,considered,as,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,code,tokenize,to,string,array,param,str,the,input,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter);1382750743;Take a String which is a delimited list and convert it to a String array._<p>A single delimiter can consists of more than one character: It will still_be considered as single delimiter string, rather than as bunch of potential_delimiter characters - in contrast to {@code tokenizeToStringArray}._@param str the input String_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,string,which,is,a,delimited,list,and,convert,it,to,a,string,array,p,a,single,delimiter,can,consists,of,more,than,one,character,it,will,still,be,considered,as,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,code,tokenize,to,string,array,param,str,the,input,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter);1385423968;Take a String which is a delimited list and convert it to a String array._<p>A single delimiter can consists of more than one character: It will still_be considered as single delimiter string, rather than as bunch of potential_delimiter characters - in contrast to {@code tokenizeToStringArray}._@param str the input String_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,string,which,is,a,delimited,list,and,convert,it,to,a,string,array,p,a,single,delimiter,can,consists,of,more,than,one,character,it,will,still,be,considered,as,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,code,tokenize,to,string,array,param,str,the,input,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter);1400189212;Take a String which is a delimited list and convert it to a String array._<p>A single delimiter can consists of more than one character: It will still_be considered as single delimiter string, rather than as bunch of potential_delimiter characters - in contrast to {@code tokenizeToStringArray}._@param str the input String_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,string,which,is,a,delimited,list,and,convert,it,to,a,string,array,p,a,single,delimiter,can,consists,of,more,than,one,character,it,will,still,be,considered,as,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,code,tokenize,to,string,array,param,str,the,input,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter);1400531359;Take a String which is a delimited list and convert it to a String array._<p>A single delimiter can consists of more than one character: It will still_be considered as single delimiter string, rather than as bunch of potential_delimiter characters - in contrast to {@code tokenizeToStringArray}._@param str the input String_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,string,which,is,a,delimited,list,and,convert,it,to,a,string,array,p,a,single,delimiter,can,consists,of,more,than,one,character,it,will,still,be,considered,as,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,code,tokenize,to,string,array,param,str,the,input,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter);1402676350;Take a String which is a delimited list and convert it to a String array._<p>A single delimiter can consists of more than one character: It will still_be considered as single delimiter string, rather than as bunch of potential_delimiter characters - in contrast to {@code tokenizeToStringArray}._@param str the input String_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,string,which,is,a,delimited,list,and,convert,it,to,a,string,array,p,a,single,delimiter,can,consists,of,more,than,one,character,it,will,still,be,considered,as,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,code,tokenize,to,string,array,param,str,the,input,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter);1426267150;Take a String which is a delimited list and convert it to a String array._<p>A single delimiter can consists of more than one character: It will still_be considered as single delimiter string, rather than as bunch of potential_delimiter characters - in contrast to {@code tokenizeToStringArray}._@param str the input String_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,string,which,is,a,delimited,list,and,convert,it,to,a,string,array,p,a,single,delimiter,can,consists,of,more,than,one,character,it,will,still,be,considered,as,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,code,tokenize,to,string,array,param,str,the,input,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter);1429034538;Take a String which is a delimited list and convert it to a String array._<p>A single delimiter can consists of more than one character: It will still_be considered as single delimiter string, rather than as bunch of potential_delimiter characters - in contrast to {@code tokenizeToStringArray}._@param str the input String_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,string,which,is,a,delimited,list,and,convert,it,to,a,string,array,p,a,single,delimiter,can,consists,of,more,than,one,character,it,will,still,be,considered,as,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,code,tokenize,to,string,array,param,str,the,input,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter);1429034756;Take a {@code String} that is a delimited list and convert it into a_{@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter);1431006895;Take a {@code String} that is a delimited list and convert it into a_{@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter);1431007368;Take a {@code String} that is a delimited list and convert it into a_{@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter);1449489126;Take a {@code String} that is a delimited list and convert it into a_{@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter);1467730834;Take a {@code String} that is a delimited list and convert it into a_{@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter);1472128018;Take a {@code String} that is a delimited list and convert it into a_{@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter);1472202842;Take a {@code String} that is a delimited list and convert it into a_{@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter);1473942665;Take a {@code String} that is a delimited list and convert it into a_{@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter);1484248946;Take a {@code String} that is a delimited list and convert it into a_{@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter);1484260238;Take a {@code String} that is a delimited list and convert it into a_{@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter);1484694546;Take a {@code String} that is a delimited list and convert it into a_{@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter);1487760984;Take a {@code String} that is a delimited list and convert it into a_{@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter);1487778834;Take a {@code String} that is a delimited list and convert it into a_{@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter);1491898314;Take a {@code String} that is a delimited list and convert it into a_{@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter);1491903650;Take a {@code String} that is a delimited list and convert it into a_{@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter);1495868221;Take a {@code String} that is a delimited list and convert it into a_{@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter);1496243689;Take a {@code String} that is a delimited list and convert it into a_{@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(String str, String delimiter);1496259743;Take a {@code String} that is a delimited list and convert it into a_{@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(String str, String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,string,str,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1380921248;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone String, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1382750743;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone String, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1385423968;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone String, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1400189212;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone String, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1400531359;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone String, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1402676350;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone String, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1426267150;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone String, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1429034538;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone String, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1429034756;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,code,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1431006895;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,code,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1431007368;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,code,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1449489126;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,code,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1467730834;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,code,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1472128018;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,code,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1472202842;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,code,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1473942665;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,code,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1484248946;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,code,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1484260238;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,code,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1484694546;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,code,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1487760984;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,code,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1487778834;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,code,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1491898314;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,code,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1491903650;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,code,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1495868221;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,code,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1496243689;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,code,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1496259743;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,code,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1496837955;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,code,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1499270197;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,code,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1508667152;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,code,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1508675477;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,code,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1508843807;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,code,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1516903831;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,code,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1519295386;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,code,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1519308837;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,code,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1519588127;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,code,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1522332352;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,code,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1525166194;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,code,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1530188116;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,code,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1531843079;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,code,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1531905026;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,code,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1533557519;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,code,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1533602820;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,code,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1535316501;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,code,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1550237113;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,code,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static TimeZone parseTimeZoneString(String timeZoneString);1550238935;Parse the given {@code timeZoneString} value into a {@link TimeZone}._@param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}_but throwing {@link IllegalArgumentException} in case of an invalid time zone specification_@return a corresponding {@link TimeZone} instance_@throws IllegalArgumentException in case of an invalid time zone specification;public static TimeZone parseTimeZoneString(String timeZoneString) {_		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString)__		if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {_			_			throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'")__		}_		return timeZone__	};parse,the,given,code,time,zone,string,value,into,a,link,time,zone,param,time,zone,string,the,time,zone,code,string,following,link,time,zone,get,time,zone,string,but,throwing,link,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification,return,a,corresponding,link,time,zone,instance,throws,illegal,argument,exception,in,case,of,an,invalid,time,zone,specification;public,static,time,zone,parse,time,zone,string,string,time,zone,string,time,zone,time,zone,time,zone,get,time,zone,time,zone,string,if,gmt,equals,time,zone,get,id,time,zone,string,starts,with,gmt,throw,new,illegal,argument,exception,invalid,time,zone,specification,time,zone,string,return,time,zone
StringUtils -> public static String[] toStringArray(Collection<String> collection);1328020251;Copy the given Collection into a String array._The Collection must contain String elements only._@param collection the Collection to copy_@return the String array (<code>null</code> if the passed-in_Collection was <code>null</code>);public static String[] toStringArray(Collection<String> collection) {_		if (collection == null) {_			return null__		}_		return collection.toArray(new String[collection.size()])__	};copy,the,given,collection,into,a,string,array,the,collection,must,contain,string,elements,only,param,collection,the,collection,to,copy,return,the,string,array,code,null,code,if,the,passed,in,collection,was,code,null,code;public,static,string,to,string,array,collection,string,collection,if,collection,null,return,null,return,collection,to,array,new,string,collection,size
StringUtils -> public static String[] toStringArray(Collection<String> collection);1337236962;Copy the given Collection into a String array._The Collection must contain String elements only._@param collection the Collection to copy_@return the String array (<code>null</code> if the passed-in_Collection was <code>null</code>);public static String[] toStringArray(Collection<String> collection) {_		if (collection == null) {_			return null__		}_		return collection.toArray(new String[collection.size()])__	};copy,the,given,collection,into,a,string,array,the,collection,must,contain,string,elements,only,param,collection,the,collection,to,copy,return,the,string,array,code,null,code,if,the,passed,in,collection,was,code,null,code;public,static,string,to,string,array,collection,string,collection,if,collection,null,return,null,return,collection,to,array,new,string,collection,size
StringUtils -> public static String[] toStringArray(Collection<String> collection);1356735495;Copy the given Collection into a String array._The Collection must contain String elements only._@param collection the Collection to copy_@return the String array ({@code null} if the passed-in_Collection was {@code null});public static String[] toStringArray(Collection<String> collection) {_		if (collection == null) {_			return null__		}_		return collection.toArray(new String[collection.size()])__	};copy,the,given,collection,into,a,string,array,the,collection,must,contain,string,elements,only,param,collection,the,collection,to,copy,return,the,string,array,code,null,if,the,passed,in,collection,was,code,null;public,static,string,to,string,array,collection,string,collection,if,collection,null,return,null,return,collection,to,array,new,string,collection,size
StringUtils -> public static String[] toStringArray(Collection<String> collection);1367955086;Copy the given Collection into a String array._The Collection must contain String elements only._@param collection the Collection to copy_@return the String array ({@code null} if the passed-in_Collection was {@code null});public static String[] toStringArray(Collection<String> collection) {_		if (collection == null) {_			return null__		}_		return collection.toArray(new String[collection.size()])__	};copy,the,given,collection,into,a,string,array,the,collection,must,contain,string,elements,only,param,collection,the,collection,to,copy,return,the,string,array,code,null,if,the,passed,in,collection,was,code,null;public,static,string,to,string,array,collection,string,collection,if,collection,null,return,null,return,collection,to,array,new,string,collection,size
StringUtils -> public static String[] toStringArray(Collection<String> collection);1380921248;Copy the given Collection into a String array._The Collection must contain String elements only._@param collection the Collection to copy_@return the String array ({@code null} if the passed-in_Collection was {@code null});public static String[] toStringArray(Collection<String> collection) {_		if (collection == null) {_			return null__		}_		return collection.toArray(new String[collection.size()])__	};copy,the,given,collection,into,a,string,array,the,collection,must,contain,string,elements,only,param,collection,the,collection,to,copy,return,the,string,array,code,null,if,the,passed,in,collection,was,code,null;public,static,string,to,string,array,collection,string,collection,if,collection,null,return,null,return,collection,to,array,new,string,collection,size
StringUtils -> public static String[] toStringArray(Collection<String> collection);1382750743;Copy the given Collection into a String array._The Collection must contain String elements only._@param collection the Collection to copy_@return the String array ({@code null} if the passed-in_Collection was {@code null});public static String[] toStringArray(Collection<String> collection) {_		if (collection == null) {_			return null__		}_		return collection.toArray(new String[collection.size()])__	};copy,the,given,collection,into,a,string,array,the,collection,must,contain,string,elements,only,param,collection,the,collection,to,copy,return,the,string,array,code,null,if,the,passed,in,collection,was,code,null;public,static,string,to,string,array,collection,string,collection,if,collection,null,return,null,return,collection,to,array,new,string,collection,size
StringUtils -> public static String[] toStringArray(Collection<String> collection);1385423968;Copy the given Collection into a String array._The Collection must contain String elements only._@param collection the Collection to copy_@return the String array ({@code null} if the passed-in_Collection was {@code null});public static String[] toStringArray(Collection<String> collection) {_		if (collection == null) {_			return null__		}_		return collection.toArray(new String[collection.size()])__	};copy,the,given,collection,into,a,string,array,the,collection,must,contain,string,elements,only,param,collection,the,collection,to,copy,return,the,string,array,code,null,if,the,passed,in,collection,was,code,null;public,static,string,to,string,array,collection,string,collection,if,collection,null,return,null,return,collection,to,array,new,string,collection,size
StringUtils -> public static String[] toStringArray(Collection<String> collection);1400189212;Copy the given Collection into a String array._The Collection must contain String elements only._@param collection the Collection to copy_@return the String array ({@code null} if the passed-in_Collection was {@code null});public static String[] toStringArray(Collection<String> collection) {_		if (collection == null) {_			return null__		}_		return collection.toArray(new String[collection.size()])__	};copy,the,given,collection,into,a,string,array,the,collection,must,contain,string,elements,only,param,collection,the,collection,to,copy,return,the,string,array,code,null,if,the,passed,in,collection,was,code,null;public,static,string,to,string,array,collection,string,collection,if,collection,null,return,null,return,collection,to,array,new,string,collection,size
StringUtils -> public static String[] toStringArray(Collection<String> collection);1400531359;Copy the given Collection into a String array._The Collection must contain String elements only._@param collection the Collection to copy_@return the String array ({@code null} if the passed-in_Collection was {@code null});public static String[] toStringArray(Collection<String> collection) {_		if (collection == null) {_			return null__		}_		return collection.toArray(new String[collection.size()])__	};copy,the,given,collection,into,a,string,array,the,collection,must,contain,string,elements,only,param,collection,the,collection,to,copy,return,the,string,array,code,null,if,the,passed,in,collection,was,code,null;public,static,string,to,string,array,collection,string,collection,if,collection,null,return,null,return,collection,to,array,new,string,collection,size
StringUtils -> public static String[] toStringArray(Collection<String> collection);1402676350;Copy the given Collection into a String array._The Collection must contain String elements only._@param collection the Collection to copy_@return the String array ({@code null} if the passed-in_Collection was {@code null});public static String[] toStringArray(Collection<String> collection) {_		if (collection == null) {_			return null__		}_		return collection.toArray(new String[collection.size()])__	};copy,the,given,collection,into,a,string,array,the,collection,must,contain,string,elements,only,param,collection,the,collection,to,copy,return,the,string,array,code,null,if,the,passed,in,collection,was,code,null;public,static,string,to,string,array,collection,string,collection,if,collection,null,return,null,return,collection,to,array,new,string,collection,size
StringUtils -> public static String[] toStringArray(Collection<String> collection);1426267150;Copy the given Collection into a String array._The Collection must contain String elements only._@param collection the Collection to copy_@return the String array ({@code null} if the passed-in_Collection was {@code null});public static String[] toStringArray(Collection<String> collection) {_		if (collection == null) {_			return null__		}_		return collection.toArray(new String[collection.size()])__	};copy,the,given,collection,into,a,string,array,the,collection,must,contain,string,elements,only,param,collection,the,collection,to,copy,return,the,string,array,code,null,if,the,passed,in,collection,was,code,null;public,static,string,to,string,array,collection,string,collection,if,collection,null,return,null,return,collection,to,array,new,string,collection,size
StringUtils -> public static String[] toStringArray(Collection<String> collection);1429034538;Copy the given Collection into a String array._The Collection must contain String elements only._@param collection the Collection to copy_@return the String array ({@code null} if the passed-in_Collection was {@code null});public static String[] toStringArray(Collection<String> collection) {_		if (collection == null) {_			return null__		}_		return collection.toArray(new String[collection.size()])__	};copy,the,given,collection,into,a,string,array,the,collection,must,contain,string,elements,only,param,collection,the,collection,to,copy,return,the,string,array,code,null,if,the,passed,in,collection,was,code,null;public,static,string,to,string,array,collection,string,collection,if,collection,null,return,null,return,collection,to,array,new,string,collection,size
StringUtils -> public static String[] toStringArray(Collection<String> collection);1429034756;Copy the given {@code Collection} into a {@code String} array._<p>The {@code Collection} must contain {@code String} elements only._@param collection the {@code Collection} to copy_@return the {@code String} array ({@code null} if the supplied_{@code Collection} was {@code null});public static String[] toStringArray(Collection<String> collection) {_		if (collection == null) {_			return null__		}_		return collection.toArray(new String[collection.size()])__	};copy,the,given,code,collection,into,a,code,string,array,p,the,code,collection,must,contain,code,string,elements,only,param,collection,the,code,collection,to,copy,return,the,code,string,array,code,null,if,the,supplied,code,collection,was,code,null;public,static,string,to,string,array,collection,string,collection,if,collection,null,return,null,return,collection,to,array,new,string,collection,size
StringUtils -> public static String[] toStringArray(Collection<String> collection);1431006895;Copy the given {@code Collection} into a {@code String} array._<p>The {@code Collection} must contain {@code String} elements only._@param collection the {@code Collection} to copy_@return the {@code String} array ({@code null} if the supplied_{@code Collection} was {@code null});public static String[] toStringArray(Collection<String> collection) {_		if (collection == null) {_			return null__		}_		return collection.toArray(new String[collection.size()])__	};copy,the,given,code,collection,into,a,code,string,array,p,the,code,collection,must,contain,code,string,elements,only,param,collection,the,code,collection,to,copy,return,the,code,string,array,code,null,if,the,supplied,code,collection,was,code,null;public,static,string,to,string,array,collection,string,collection,if,collection,null,return,null,return,collection,to,array,new,string,collection,size
StringUtils -> public static String[] toStringArray(Collection<String> collection);1431007368;Copy the given {@code Collection} into a {@code String} array._<p>The {@code Collection} must contain {@code String} elements only._@param collection the {@code Collection} to copy_@return the {@code String} array ({@code null} if the supplied_{@code Collection} was {@code null});public static String[] toStringArray(Collection<String> collection) {_		if (collection == null) {_			return null__		}_		return collection.toArray(new String[collection.size()])__	};copy,the,given,code,collection,into,a,code,string,array,p,the,code,collection,must,contain,code,string,elements,only,param,collection,the,code,collection,to,copy,return,the,code,string,array,code,null,if,the,supplied,code,collection,was,code,null;public,static,string,to,string,array,collection,string,collection,if,collection,null,return,null,return,collection,to,array,new,string,collection,size
StringUtils -> public static String[] toStringArray(Collection<String> collection);1449489126;Copy the given {@code Collection} into a {@code String} array._<p>The {@code Collection} must contain {@code String} elements only._@param collection the {@code Collection} to copy_@return the {@code String} array ({@code null} if the supplied_{@code Collection} was {@code null});public static String[] toStringArray(Collection<String> collection) {_		if (collection == null) {_			return null__		}_		return collection.toArray(new String[collection.size()])__	};copy,the,given,code,collection,into,a,code,string,array,p,the,code,collection,must,contain,code,string,elements,only,param,collection,the,code,collection,to,copy,return,the,code,string,array,code,null,if,the,supplied,code,collection,was,code,null;public,static,string,to,string,array,collection,string,collection,if,collection,null,return,null,return,collection,to,array,new,string,collection,size
StringUtils -> public static String[] toStringArray(Collection<String> collection);1467730834;Copy the given {@code Collection} into a {@code String} array._<p>The {@code Collection} must contain {@code String} elements only._@param collection the {@code Collection} to copy_@return the {@code String} array ({@code null} if the supplied_{@code Collection} was {@code null});public static String[] toStringArray(Collection<String> collection) {_		if (collection == null) {_			return null__		}_		return collection.toArray(new String[collection.size()])__	};copy,the,given,code,collection,into,a,code,string,array,p,the,code,collection,must,contain,code,string,elements,only,param,collection,the,code,collection,to,copy,return,the,code,string,array,code,null,if,the,supplied,code,collection,was,code,null;public,static,string,to,string,array,collection,string,collection,if,collection,null,return,null,return,collection,to,array,new,string,collection,size
StringUtils -> public static String[] toStringArray(Collection<String> collection);1472128018;Copy the given {@code Collection} into a {@code String} array._<p>The {@code Collection} must contain {@code String} elements only._@param collection the {@code Collection} to copy_@return the {@code String} array ({@code null} if the supplied_{@code Collection} was {@code null});public static String[] toStringArray(Collection<String> collection) {_		if (collection == null) {_			return null__		}_		return collection.toArray(new String[collection.size()])__	};copy,the,given,code,collection,into,a,code,string,array,p,the,code,collection,must,contain,code,string,elements,only,param,collection,the,code,collection,to,copy,return,the,code,string,array,code,null,if,the,supplied,code,collection,was,code,null;public,static,string,to,string,array,collection,string,collection,if,collection,null,return,null,return,collection,to,array,new,string,collection,size
StringUtils -> public static String[] toStringArray(Collection<String> collection);1472202842;Copy the given {@code Collection} into a {@code String} array._<p>The {@code Collection} must contain {@code String} elements only._@param collection the {@code Collection} to copy_@return the {@code String} array ({@code null} if the supplied_{@code Collection} was {@code null});public static String[] toStringArray(Collection<String> collection) {_		if (collection == null) {_			return null__		}_		return collection.toArray(new String[collection.size()])__	};copy,the,given,code,collection,into,a,code,string,array,p,the,code,collection,must,contain,code,string,elements,only,param,collection,the,code,collection,to,copy,return,the,code,string,array,code,null,if,the,supplied,code,collection,was,code,null;public,static,string,to,string,array,collection,string,collection,if,collection,null,return,null,return,collection,to,array,new,string,collection,size
StringUtils -> public static String[] toStringArray(Collection<String> collection);1473942665;Copy the given {@code Collection} into a {@code String} array._<p>The {@code Collection} must contain {@code String} elements only._@param collection the {@code Collection} to copy_@return the {@code String} array ({@code null} if the supplied_{@code Collection} was {@code null});public static String[] toStringArray(Collection<String> collection) {_		if (collection == null) {_			return null__		}_		return collection.toArray(new String[collection.size()])__	};copy,the,given,code,collection,into,a,code,string,array,p,the,code,collection,must,contain,code,string,elements,only,param,collection,the,code,collection,to,copy,return,the,code,string,array,code,null,if,the,supplied,code,collection,was,code,null;public,static,string,to,string,array,collection,string,collection,if,collection,null,return,null,return,collection,to,array,new,string,collection,size
StringUtils -> public static String[] toStringArray(Collection<String> collection);1484248946;Copy the given {@code Collection} into a {@code String} array._<p>The {@code Collection} must contain {@code String} elements only._@param collection the {@code Collection} to copy_@return the {@code String} array ({@code null} if the supplied_{@code Collection} was {@code null});public static String[] toStringArray(Collection<String> collection) {_		if (collection == null) {_			return null__		}_		return collection.toArray(new String[collection.size()])__	};copy,the,given,code,collection,into,a,code,string,array,p,the,code,collection,must,contain,code,string,elements,only,param,collection,the,code,collection,to,copy,return,the,code,string,array,code,null,if,the,supplied,code,collection,was,code,null;public,static,string,to,string,array,collection,string,collection,if,collection,null,return,null,return,collection,to,array,new,string,collection,size
StringUtils -> public static String[] toStringArray(Collection<String> collection);1484260238;Copy the given {@code Collection} into a {@code String} array._<p>The {@code Collection} must contain {@code String} elements only._@param collection the {@code Collection} to copy_@return the {@code String} array ({@code null} if the supplied_{@code Collection} was {@code null});public static String[] toStringArray(Collection<String> collection) {_		if (collection == null) {_			return null__		}_		return collection.toArray(new String[collection.size()])__	};copy,the,given,code,collection,into,a,code,string,array,p,the,code,collection,must,contain,code,string,elements,only,param,collection,the,code,collection,to,copy,return,the,code,string,array,code,null,if,the,supplied,code,collection,was,code,null;public,static,string,to,string,array,collection,string,collection,if,collection,null,return,null,return,collection,to,array,new,string,collection,size
StringUtils -> public static String[] toStringArray(Collection<String> collection);1484694546;Copy the given {@code Collection} into a {@code String} array._<p>The {@code Collection} must contain {@code String} elements only._@param collection the {@code Collection} to copy_@return the {@code String} array ({@code null} if the supplied_{@code Collection} was {@code null});public static String[] toStringArray(Collection<String> collection) {_		if (collection == null) {_			return null__		}_		return collection.toArray(new String[collection.size()])__	};copy,the,given,code,collection,into,a,code,string,array,p,the,code,collection,must,contain,code,string,elements,only,param,collection,the,code,collection,to,copy,return,the,code,string,array,code,null,if,the,supplied,code,collection,was,code,null;public,static,string,to,string,array,collection,string,collection,if,collection,null,return,null,return,collection,to,array,new,string,collection,size
StringUtils -> public static String[] toStringArray(Collection<String> collection);1487760984;Copy the given {@code Collection} into a {@code String} array._<p>The {@code Collection} must contain {@code String} elements only._@param collection the {@code Collection} to copy_@return the {@code String} array ({@code null} if the supplied_{@code Collection} was {@code null});public static String[] toStringArray(Collection<String> collection) {_		if (collection == null) {_			return null__		}_		return collection.toArray(new String[collection.size()])__	};copy,the,given,code,collection,into,a,code,string,array,p,the,code,collection,must,contain,code,string,elements,only,param,collection,the,code,collection,to,copy,return,the,code,string,array,code,null,if,the,supplied,code,collection,was,code,null;public,static,string,to,string,array,collection,string,collection,if,collection,null,return,null,return,collection,to,array,new,string,collection,size
StringUtils -> public static String[] toStringArray(Collection<String> collection);1487778834;Copy the given {@code Collection} into a {@code String} array._<p>The {@code Collection} must contain {@code String} elements only._@param collection the {@code Collection} to copy_@return the {@code String} array ({@code null} if the supplied_{@code Collection} was {@code null});public static String[] toStringArray(Collection<String> collection) {_		if (collection == null) {_			return null__		}_		return collection.toArray(new String[collection.size()])__	};copy,the,given,code,collection,into,a,code,string,array,p,the,code,collection,must,contain,code,string,elements,only,param,collection,the,code,collection,to,copy,return,the,code,string,array,code,null,if,the,supplied,code,collection,was,code,null;public,static,string,to,string,array,collection,string,collection,if,collection,null,return,null,return,collection,to,array,new,string,collection,size
StringUtils -> public static String[] toStringArray(Collection<String> collection);1491898314;Copy the given {@code Collection} into a {@code String} array._<p>The {@code Collection} must contain {@code String} elements only._@param collection the {@code Collection} to copy_@return the {@code String} array ({@code null} if the supplied_{@code Collection} was {@code null});public static String[] toStringArray(Collection<String> collection) {_		if (collection == null) {_			return null__		}__		return collection.toArray(new String[collection.size()])__	};copy,the,given,code,collection,into,a,code,string,array,p,the,code,collection,must,contain,code,string,elements,only,param,collection,the,code,collection,to,copy,return,the,code,string,array,code,null,if,the,supplied,code,collection,was,code,null;public,static,string,to,string,array,collection,string,collection,if,collection,null,return,null,return,collection,to,array,new,string,collection,size
StringUtils -> public static String[] toStringArray(Collection<String> collection);1491903650;Copy the given {@code Collection} into a {@code String} array._<p>The {@code Collection} must contain {@code String} elements only._@param collection the {@code Collection} to copy_@return the {@code String} array ({@code null} if the supplied_{@code Collection} was {@code null});public static String[] toStringArray(Collection<String> collection) {_		if (collection == null) {_			return null__		}__		return collection.toArray(new String[collection.size()])__	};copy,the,given,code,collection,into,a,code,string,array,p,the,code,collection,must,contain,code,string,elements,only,param,collection,the,code,collection,to,copy,return,the,code,string,array,code,null,if,the,supplied,code,collection,was,code,null;public,static,string,to,string,array,collection,string,collection,if,collection,null,return,null,return,collection,to,array,new,string,collection,size
StringUtils -> public static String[] toStringArray(Collection<String> collection);1496837955;Copy the given {@code Collection} into a {@code String} array._<p>The {@code Collection} must contain {@code String} elements only._@param collection the {@code Collection} to copy_@return the {@code String} array;public static String[] toStringArray(Collection<String> collection) {_		return collection.toArray(new String[collection.size()])__	};copy,the,given,code,collection,into,a,code,string,array,p,the,code,collection,must,contain,code,string,elements,only,param,collection,the,code,collection,to,copy,return,the,code,string,array;public,static,string,to,string,array,collection,string,collection,return,collection,to,array,new,string,collection,size
StringUtils -> public static String[] toStringArray(Collection<String> collection);1499270197;Copy the given {@code Collection} into a {@code String} array._<p>The {@code Collection} must contain {@code String} elements only._@param collection the {@code Collection} to copy_@return the {@code String} array;public static String[] toStringArray(Collection<String> collection) {_		return collection.toArray(new String[collection.size()])__	};copy,the,given,code,collection,into,a,code,string,array,p,the,code,collection,must,contain,code,string,elements,only,param,collection,the,code,collection,to,copy,return,the,code,string,array;public,static,string,to,string,array,collection,string,collection,return,collection,to,array,new,string,collection,size
StringUtils -> public static String[] toStringArray(Collection<String> collection);1508667152;Copy the given {@code Collection} into a {@code String} array._<p>The {@code Collection} must contain {@code String} elements only._@param collection the {@code Collection} to copy_@return the {@code String} array;public static String[] toStringArray(Collection<String> collection) {_		return collection.toArray(new String[collection.size()])__	};copy,the,given,code,collection,into,a,code,string,array,p,the,code,collection,must,contain,code,string,elements,only,param,collection,the,code,collection,to,copy,return,the,code,string,array;public,static,string,to,string,array,collection,string,collection,return,collection,to,array,new,string,collection,size
StringUtils -> public static String[] toStringArray(Collection<String> collection);1508675477;Copy the given {@code Collection} into a {@code String} array._<p>The {@code Collection} must contain {@code String} elements only._@param collection the {@code Collection} to copy_@return the {@code String} array;public static String[] toStringArray(Collection<String> collection) {_		return collection.toArray(new String[collection.size()])__	};copy,the,given,code,collection,into,a,code,string,array,p,the,code,collection,must,contain,code,string,elements,only,param,collection,the,code,collection,to,copy,return,the,code,string,array;public,static,string,to,string,array,collection,string,collection,return,collection,to,array,new,string,collection,size
StringUtils -> public static String[] toStringArray(Collection<String> collection);1508843807;Copy the given {@code Collection} into a {@code String} array._<p>The {@code Collection} must contain {@code String} elements only._@param collection the {@code Collection} to copy_@return the {@code String} array;public static String[] toStringArray(Collection<String> collection) {_		return collection.toArray(new String[collection.size()])__	};copy,the,given,code,collection,into,a,code,string,array,p,the,code,collection,must,contain,code,string,elements,only,param,collection,the,code,collection,to,copy,return,the,code,string,array;public,static,string,to,string,array,collection,string,collection,return,collection,to,array,new,string,collection,size
StringUtils -> public static String[] toStringArray(Collection<String> collection);1516903831;Copy the given {@code Collection} into a {@code String} array._<p>The {@code Collection} must contain {@code String} elements only._@param collection the {@code Collection} to copy_@return the {@code String} array;public static String[] toStringArray(Collection<String> collection) {_		return collection.toArray(new String[collection.size()])__	};copy,the,given,code,collection,into,a,code,string,array,p,the,code,collection,must,contain,code,string,elements,only,param,collection,the,code,collection,to,copy,return,the,code,string,array;public,static,string,to,string,array,collection,string,collection,return,collection,to,array,new,string,collection,size
StringUtils -> public static String[] toStringArray(Collection<String> collection);1519295386;Copy the given {@code Collection} into a {@code String} array._<p>The {@code Collection} must contain {@code String} elements only._@param collection the {@code Collection} to copy_@return the {@code String} array;public static String[] toStringArray(Collection<String> collection) {_		return collection.toArray(new String[0])__	};copy,the,given,code,collection,into,a,code,string,array,p,the,code,collection,must,contain,code,string,elements,only,param,collection,the,code,collection,to,copy,return,the,code,string,array;public,static,string,to,string,array,collection,string,collection,return,collection,to,array,new,string,0
StringUtils -> public static String[] toStringArray(Collection<String> collection);1519308837;Copy the given {@code Collection} into a {@code String} array._<p>The {@code Collection} must contain {@code String} elements only._@param collection the {@code Collection} to copy_@return the {@code String} array;public static String[] toStringArray(Collection<String> collection) {_		return collection.toArray(new String[0])__	};copy,the,given,code,collection,into,a,code,string,array,p,the,code,collection,must,contain,code,string,elements,only,param,collection,the,code,collection,to,copy,return,the,code,string,array;public,static,string,to,string,array,collection,string,collection,return,collection,to,array,new,string,0
StringUtils -> public static String[] toStringArray(Collection<String> collection);1519588127;Copy the given {@code Collection} into a {@code String} array._<p>The {@code Collection} must contain {@code String} elements only._@param collection the {@code Collection} to copy_@return the {@code String} array;public static String[] toStringArray(Collection<String> collection) {_		return collection.toArray(new String[0])__	};copy,the,given,code,collection,into,a,code,string,array,p,the,code,collection,must,contain,code,string,elements,only,param,collection,the,code,collection,to,copy,return,the,code,string,array;public,static,string,to,string,array,collection,string,collection,return,collection,to,array,new,string,0
StringUtils -> public static String[] toStringArray(Collection<String> collection);1522332352;Copy the given {@code Collection} into a {@code String} array._<p>The {@code Collection} must contain {@code String} elements only._@param collection the {@code Collection} to copy_@return the {@code String} array;public static String[] toStringArray(Collection<String> collection) {_		return collection.toArray(new String[0])__	};copy,the,given,code,collection,into,a,code,string,array,p,the,code,collection,must,contain,code,string,elements,only,param,collection,the,code,collection,to,copy,return,the,code,string,array;public,static,string,to,string,array,collection,string,collection,return,collection,to,array,new,string,0
StringUtils -> public static String[] toStringArray(Collection<String> collection);1525166194;Copy the given {@code Collection} into a {@code String} array._<p>The {@code Collection} must contain {@code String} elements only._@param collection the {@code Collection} to copy_@return the {@code String} array;public static String[] toStringArray(Collection<String> collection) {_		return collection.toArray(new String[0])__	};copy,the,given,code,collection,into,a,code,string,array,p,the,code,collection,must,contain,code,string,elements,only,param,collection,the,code,collection,to,copy,return,the,code,string,array;public,static,string,to,string,array,collection,string,collection,return,collection,to,array,new,string,0
StringUtils -> public static String[] toStringArray(Collection<String> collection);1530188116;Copy the given {@code Collection} into a {@code String} array._<p>The {@code Collection} must contain {@code String} elements only._@param collection the {@code Collection} to copy_@return the {@code String} array;public static String[] toStringArray(Collection<String> collection) {_		return collection.toArray(new String[0])__	};copy,the,given,code,collection,into,a,code,string,array,p,the,code,collection,must,contain,code,string,elements,only,param,collection,the,code,collection,to,copy,return,the,code,string,array;public,static,string,to,string,array,collection,string,collection,return,collection,to,array,new,string,0
StringUtils -> public static String[] toStringArray(Collection<String> collection);1531843079;Copy the given {@code Collection} into a {@code String} array._<p>The {@code Collection} must contain {@code String} elements only._@param collection the {@code Collection} to copy_@return the {@code String} array;public static String[] toStringArray(Collection<String> collection) {_		return collection.toArray(new String[0])__	};copy,the,given,code,collection,into,a,code,string,array,p,the,code,collection,must,contain,code,string,elements,only,param,collection,the,code,collection,to,copy,return,the,code,string,array;public,static,string,to,string,array,collection,string,collection,return,collection,to,array,new,string,0
StringUtils -> public static String[] toStringArray(Collection<String> collection);1531905026;Copy the given {@code Collection} into a {@code String} array._<p>The {@code Collection} must contain {@code String} elements only._@param collection the {@code Collection} to copy_@return the {@code String} array;public static String[] toStringArray(Collection<String> collection) {_		return collection.toArray(new String[0])__	};copy,the,given,code,collection,into,a,code,string,array,p,the,code,collection,must,contain,code,string,elements,only,param,collection,the,code,collection,to,copy,return,the,code,string,array;public,static,string,to,string,array,collection,string,collection,return,collection,to,array,new,string,0
StringUtils -> public static String[] toStringArray(Collection<String> collection);1533557519;Copy the given {@code Collection} into a {@code String} array._<p>The {@code Collection} must contain {@code String} elements only._@param collection the {@code Collection} to copy_@return the {@code String} array;public static String[] toStringArray(Collection<String> collection) {_		return collection.toArray(new String[0])__	};copy,the,given,code,collection,into,a,code,string,array,p,the,code,collection,must,contain,code,string,elements,only,param,collection,the,code,collection,to,copy,return,the,code,string,array;public,static,string,to,string,array,collection,string,collection,return,collection,to,array,new,string,0
StringUtils -> public static String[] toStringArray(Collection<String> collection);1533602820;Copy the given {@code Collection} into a {@code String} array._<p>The {@code Collection} must contain {@code String} elements only._@param collection the {@code Collection} to copy_@return the {@code String} array;public static String[] toStringArray(Collection<String> collection) {_		return collection.toArray(new String[0])__	};copy,the,given,code,collection,into,a,code,string,array,p,the,code,collection,must,contain,code,string,elements,only,param,collection,the,code,collection,to,copy,return,the,code,string,array;public,static,string,to,string,array,collection,string,collection,return,collection,to,array,new,string,0
StringUtils -> public static String[] toStringArray(Collection<String> collection);1535316501;Copy the given {@code Collection} into a {@code String} array._<p>The {@code Collection} must contain {@code String} elements only._@param collection the {@code Collection} to copy_@return the {@code String} array;public static String[] toStringArray(Collection<String> collection) {_		return collection.toArray(new String[0])__	};copy,the,given,code,collection,into,a,code,string,array,p,the,code,collection,must,contain,code,string,elements,only,param,collection,the,code,collection,to,copy,return,the,code,string,array;public,static,string,to,string,array,collection,string,collection,return,collection,to,array,new,string,0
StringUtils -> public static String[] toStringArray(Collection<String> collection);1550237113;Copy the given {@code Collection} into a {@code String} array._<p>The {@code Collection} must contain {@code String} elements only._@param collection the {@code Collection} to copy_@return the {@code String} array;public static String[] toStringArray(Collection<String> collection) {_		return collection.toArray(new String[0])__	};copy,the,given,code,collection,into,a,code,string,array,p,the,code,collection,must,contain,code,string,elements,only,param,collection,the,code,collection,to,copy,return,the,code,string,array;public,static,string,to,string,array,collection,string,collection,return,collection,to,array,new,string,0
StringUtils -> public static String[] toStringArray(Collection<String> collection);1550238935;Copy the given {@code Collection} into a {@code String} array._<p>The {@code Collection} must contain {@code String} elements only._@param collection the {@code Collection} to copy_@return the {@code String} array;public static String[] toStringArray(Collection<String> collection) {_		return collection.toArray(new String[0])__	};copy,the,given,code,collection,into,a,code,string,array,p,the,code,collection,must,contain,code,string,elements,only,param,collection,the,code,collection,to,copy,return,the,code,string,array;public,static,string,to,string,array,collection,string,collection,return,collection,to,array,new,string,0
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix);1328020251;Convenience method to return a Collection as a delimited (e.g. CSV)_String. E.g. useful for <code>toString()</code> implementations._@param coll the Collection to display_@param delim the delimiter to use (probably a ",")_@param prefix the String to start each element with_@param suffix the String to end each element with_@return the delimited String;public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {_		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}_		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convenience,method,to,return,a,collection,as,a,delimited,e,g,csv,string,e,g,useful,for,code,to,string,code,implementations,param,coll,the,collection,to,display,param,delim,the,delimiter,to,use,probably,a,param,prefix,the,string,to,start,each,element,with,param,suffix,the,string,to,end,each,element,with,return,the,delimited,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix);1337236962;Convenience method to return a Collection as a delimited (e.g. CSV)_String. E.g. useful for <code>toString()</code> implementations._@param coll the Collection to display_@param delim the delimiter to use (probably a ",")_@param prefix the String to start each element with_@param suffix the String to end each element with_@return the delimited String;public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {_		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}_		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convenience,method,to,return,a,collection,as,a,delimited,e,g,csv,string,e,g,useful,for,code,to,string,code,implementations,param,coll,the,collection,to,display,param,delim,the,delimiter,to,use,probably,a,param,prefix,the,string,to,start,each,element,with,param,suffix,the,string,to,end,each,element,with,return,the,delimited,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix);1356735495;Convenience method to return a Collection as a delimited (e.g. CSV)_String. E.g. useful for {@code toString()} implementations._@param coll the Collection to display_@param delim the delimiter to use (probably a ",")_@param prefix the String to start each element with_@param suffix the String to end each element with_@return the delimited String;public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {_		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}_		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convenience,method,to,return,a,collection,as,a,delimited,e,g,csv,string,e,g,useful,for,code,to,string,implementations,param,coll,the,collection,to,display,param,delim,the,delimiter,to,use,probably,a,param,prefix,the,string,to,start,each,element,with,param,suffix,the,string,to,end,each,element,with,return,the,delimited,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix);1367955086;Convenience method to return a Collection as a delimited (e.g. CSV)_String. E.g. useful for {@code toString()} implementations._@param coll the Collection to display_@param delim the delimiter to use (probably a ",")_@param prefix the String to start each element with_@param suffix the String to end each element with_@return the delimited String;public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {_		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}_		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convenience,method,to,return,a,collection,as,a,delimited,e,g,csv,string,e,g,useful,for,code,to,string,implementations,param,coll,the,collection,to,display,param,delim,the,delimiter,to,use,probably,a,param,prefix,the,string,to,start,each,element,with,param,suffix,the,string,to,end,each,element,with,return,the,delimited,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix);1380921248;Convenience method to return a Collection as a delimited (e.g. CSV)_String. E.g. useful for {@code toString()} implementations._@param coll the Collection to display_@param delim the delimiter to use (probably a ",")_@param prefix the String to start each element with_@param suffix the String to end each element with_@return the delimited String;public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {_		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}_		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convenience,method,to,return,a,collection,as,a,delimited,e,g,csv,string,e,g,useful,for,code,to,string,implementations,param,coll,the,collection,to,display,param,delim,the,delimiter,to,use,probably,a,param,prefix,the,string,to,start,each,element,with,param,suffix,the,string,to,end,each,element,with,return,the,delimited,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix);1382750743;Convenience method to return a Collection as a delimited (e.g. CSV)_String. E.g. useful for {@code toString()} implementations._@param coll the Collection to display_@param delim the delimiter to use (probably a ",")_@param prefix the String to start each element with_@param suffix the String to end each element with_@return the delimited String;public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {_		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}_		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convenience,method,to,return,a,collection,as,a,delimited,e,g,csv,string,e,g,useful,for,code,to,string,implementations,param,coll,the,collection,to,display,param,delim,the,delimiter,to,use,probably,a,param,prefix,the,string,to,start,each,element,with,param,suffix,the,string,to,end,each,element,with,return,the,delimited,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix);1385423968;Convenience method to return a Collection as a delimited (e.g. CSV)_String. E.g. useful for {@code toString()} implementations._@param coll the Collection to display_@param delim the delimiter to use (probably a ",")_@param prefix the String to start each element with_@param suffix the String to end each element with_@return the delimited String;public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {_		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}_		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convenience,method,to,return,a,collection,as,a,delimited,e,g,csv,string,e,g,useful,for,code,to,string,implementations,param,coll,the,collection,to,display,param,delim,the,delimiter,to,use,probably,a,param,prefix,the,string,to,start,each,element,with,param,suffix,the,string,to,end,each,element,with,return,the,delimited,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix);1400189212;Convenience method to return a Collection as a delimited (e.g. CSV)_String. E.g. useful for {@code toString()} implementations._@param coll the Collection to display_@param delim the delimiter to use (probably a ",")_@param prefix the String to start each element with_@param suffix the String to end each element with_@return the delimited String;public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {_		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}_		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convenience,method,to,return,a,collection,as,a,delimited,e,g,csv,string,e,g,useful,for,code,to,string,implementations,param,coll,the,collection,to,display,param,delim,the,delimiter,to,use,probably,a,param,prefix,the,string,to,start,each,element,with,param,suffix,the,string,to,end,each,element,with,return,the,delimited,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix);1400531359;Convenience method to return a Collection as a delimited (e.g. CSV)_String. E.g. useful for {@code toString()} implementations._@param coll the Collection to display_@param delim the delimiter to use (probably a ",")_@param prefix the String to start each element with_@param suffix the String to end each element with_@return the delimited String;public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {_		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}_		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convenience,method,to,return,a,collection,as,a,delimited,e,g,csv,string,e,g,useful,for,code,to,string,implementations,param,coll,the,collection,to,display,param,delim,the,delimiter,to,use,probably,a,param,prefix,the,string,to,start,each,element,with,param,suffix,the,string,to,end,each,element,with,return,the,delimited,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix);1402676350;Convenience method to return a Collection as a delimited (e.g. CSV)_String. E.g. useful for {@code toString()} implementations._@param coll the Collection to display_@param delim the delimiter to use (probably a ",")_@param prefix the String to start each element with_@param suffix the String to end each element with_@return the delimited String;public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {_		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}_		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convenience,method,to,return,a,collection,as,a,delimited,e,g,csv,string,e,g,useful,for,code,to,string,implementations,param,coll,the,collection,to,display,param,delim,the,delimiter,to,use,probably,a,param,prefix,the,string,to,start,each,element,with,param,suffix,the,string,to,end,each,element,with,return,the,delimited,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix);1426267150;Convenience method to return a Collection as a delimited (e.g. CSV)_String. E.g. useful for {@code toString()} implementations._@param coll the Collection to display_@param delim the delimiter to use (probably a ",")_@param prefix the String to start each element with_@param suffix the String to end each element with_@return the delimited String;public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {_		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}_		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convenience,method,to,return,a,collection,as,a,delimited,e,g,csv,string,e,g,useful,for,code,to,string,implementations,param,coll,the,collection,to,display,param,delim,the,delimiter,to,use,probably,a,param,prefix,the,string,to,start,each,element,with,param,suffix,the,string,to,end,each,element,with,return,the,delimited,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix);1429034538;Convenience method to return a Collection as a delimited (e.g. CSV)_String. E.g. useful for {@code toString()} implementations._@param coll the Collection to display_@param delim the delimiter to use (probably a ",")_@param prefix the String to start each element with_@param suffix the String to end each element with_@return the delimited String;public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {_		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}_		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convenience,method,to,return,a,collection,as,a,delimited,e,g,csv,string,e,g,useful,for,code,to,string,implementations,param,coll,the,collection,to,display,param,delim,the,delimiter,to,use,probably,a,param,prefix,the,string,to,start,each,element,with,param,suffix,the,string,to,end,each,element,with,return,the,delimited,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix);1429034756;Convert a {@link Collection} to a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@param prefix the {@code String} to start each element with_@param suffix the {@code String} to end each element with_@return the delimited {@code String};public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {_		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}_		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convert,a,link,collection,to,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,param,prefix,the,code,string,to,start,each,element,with,param,suffix,the,code,string,to,end,each,element,with,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix);1431006895;Convert a {@link Collection} to a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@param prefix the {@code String} to start each element with_@param suffix the {@code String} to end each element with_@return the delimited {@code String};public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {_		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}_		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convert,a,link,collection,to,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,param,prefix,the,code,string,to,start,each,element,with,param,suffix,the,code,string,to,end,each,element,with,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix);1431007368;Convert a {@link Collection} to a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@param prefix the {@code String} to start each element with_@param suffix the {@code String} to end each element with_@return the delimited {@code String};public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {_		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}_		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convert,a,link,collection,to,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,param,prefix,the,code,string,to,start,each,element,with,param,suffix,the,code,string,to,end,each,element,with,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix);1449489126;Convert a {@link Collection} to a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@param prefix the {@code String} to start each element with_@param suffix the {@code String} to end each element with_@return the delimited {@code String};public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {_		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}_		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convert,a,link,collection,to,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,param,prefix,the,code,string,to,start,each,element,with,param,suffix,the,code,string,to,end,each,element,with,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix);1467730834;Convert a {@link Collection} to a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@param prefix the {@code String} to start each element with_@param suffix the {@code String} to end each element with_@return the delimited {@code String};public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {_		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}_		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convert,a,link,collection,to,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,param,prefix,the,code,string,to,start,each,element,with,param,suffix,the,code,string,to,end,each,element,with,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix);1472128018;Convert a {@link Collection} to a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@param prefix the {@code String} to start each element with_@param suffix the {@code String} to end each element with_@return the delimited {@code String};public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {_		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}_		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convert,a,link,collection,to,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,param,prefix,the,code,string,to,start,each,element,with,param,suffix,the,code,string,to,end,each,element,with,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix);1472202842;Convert a {@link Collection} to a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@param prefix the {@code String} to start each element with_@param suffix the {@code String} to end each element with_@return the delimited {@code String};public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {_		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}_		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convert,a,link,collection,to,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,param,prefix,the,code,string,to,start,each,element,with,param,suffix,the,code,string,to,end,each,element,with,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix);1473942665;Convert a {@link Collection} to a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@param prefix the {@code String} to start each element with_@param suffix the {@code String} to end each element with_@return the delimited {@code String};public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {_		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}_		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convert,a,link,collection,to,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,param,prefix,the,code,string,to,start,each,element,with,param,suffix,the,code,string,to,end,each,element,with,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix);1484248946;Convert a {@link Collection} to a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@param prefix the {@code String} to start each element with_@param suffix the {@code String} to end each element with_@return the delimited {@code String};public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {_		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}_		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convert,a,link,collection,to,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,param,prefix,the,code,string,to,start,each,element,with,param,suffix,the,code,string,to,end,each,element,with,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix);1484260238;Convert a {@link Collection} to a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@param prefix the {@code String} to start each element with_@param suffix the {@code String} to end each element with_@return the delimited {@code String};public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {_		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}_		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convert,a,link,collection,to,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,param,prefix,the,code,string,to,start,each,element,with,param,suffix,the,code,string,to,end,each,element,with,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix);1484694546;Convert a {@link Collection} to a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@param prefix the {@code String} to start each element with_@param suffix the {@code String} to end each element with_@return the delimited {@code String};public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {_		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}_		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convert,a,link,collection,to,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,param,prefix,the,code,string,to,start,each,element,with,param,suffix,the,code,string,to,end,each,element,with,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix);1487760984;Convert a {@link Collection} to a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@param prefix the {@code String} to start each element with_@param suffix the {@code String} to end each element with_@return the delimited {@code String};public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {_		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}_		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convert,a,link,collection,to,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,param,prefix,the,code,string,to,start,each,element,with,param,suffix,the,code,string,to,end,each,element,with,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix);1487778834;Convert a {@link Collection} to a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@param prefix the {@code String} to start each element with_@param suffix the {@code String} to end each element with_@return the delimited {@code String};public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {_		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}_		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convert,a,link,collection,to,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,param,prefix,the,code,string,to,start,each,element,with,param,suffix,the,code,string,to,end,each,element,with,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix);1491898314;Convert a {@link Collection} to a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@param prefix the {@code String} to start each element with_@param suffix the {@code String} to end each element with_@return the delimited {@code String};public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {_		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}__		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convert,a,link,collection,to,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,param,prefix,the,code,string,to,start,each,element,with,param,suffix,the,code,string,to,end,each,element,with,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix);1491903650;Convert a {@link Collection} to a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@param prefix the {@code String} to start each element with_@param suffix the {@code String} to end each element with_@return the delimited {@code String};public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {_		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}__		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convert,a,link,collection,to,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,param,prefix,the,code,string,to,start,each,element,with,param,suffix,the,code,string,to,end,each,element,with,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix);1495868221;Convert a {@link Collection} to a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@param prefix the {@code String} to start each element with_@param suffix the {@code String} to end each element with_@return the delimited {@code String};public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {_		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}__		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convert,a,link,collection,to,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,param,prefix,the,code,string,to,start,each,element,with,param,suffix,the,code,string,to,end,each,element,with,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix);1496243689;Convert a {@link Collection} to a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@param prefix the {@code String} to start each element with_@param suffix the {@code String} to end each element with_@return the delimited {@code String};public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {_		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}__		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convert,a,link,collection,to,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,param,prefix,the,code,string,to,start,each,element,with,param,suffix,the,code,string,to,end,each,element,with,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix);1496259743;Convert a {@link Collection} to a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@param prefix the {@code String} to start each element with_@param suffix the {@code String} to end each element with_@return the delimited {@code String};public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {_		if (CollectionUtils.isEmpty(coll)) {_			return ""__		}__		StringBuilder sb = new StringBuilder()__		Iterator<?> it = coll.iterator()__		while (it.hasNext()) {_			sb.append(prefix).append(it.next()).append(suffix)__			if (it.hasNext()) {_				sb.append(delim)__			}_		}_		return sb.toString()__	};convert,a,link,collection,to,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,param,prefix,the,code,string,to,start,each,element,with,param,suffix,the,code,string,to,end,each,element,with,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,string,prefix,string,suffix,if,collection,utils,is,empty,coll,return,string,builder,sb,new,string,builder,iterator,it,coll,iterator,while,it,has,next,sb,append,prefix,append,it,next,append,suffix,if,it,has,next,sb,append,delim,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, String charsToDelete);1328020251;Delete any character in a given String._@param inString the original String_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting String;public static String deleteAny(String inString, String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,string,param,in,string,the,original,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,string;public,static,string,delete,any,string,in,string,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, String charsToDelete);1337236962;Delete any character in a given String._@param inString the original String_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting String;public static String deleteAny(String inString, String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,string,param,in,string,the,original,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,string;public,static,string,delete,any,string,in,string,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, String charsToDelete);1356735495;Delete any character in a given String._@param inString the original String_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting String;public static String deleteAny(String inString, String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,string,param,in,string,the,original,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,string;public,static,string,delete,any,string,in,string,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, String charsToDelete);1367955086;Delete any character in a given String._@param inString the original String_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting String;public static String deleteAny(String inString, String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,string,param,in,string,the,original,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,string;public,static,string,delete,any,string,in,string,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, String charsToDelete);1380921248;Delete any character in a given String._@param inString the original String_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting String;public static String deleteAny(String inString, String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,string,param,in,string,the,original,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,string;public,static,string,delete,any,string,in,string,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, String charsToDelete);1382750743;Delete any character in a given String._@param inString the original String_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting String;public static String deleteAny(String inString, String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,string,param,in,string,the,original,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,string;public,static,string,delete,any,string,in,string,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, String charsToDelete);1385423968;Delete any character in a given String._@param inString the original String_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting String;public static String deleteAny(String inString, String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,string,param,in,string,the,original,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,string;public,static,string,delete,any,string,in,string,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, String charsToDelete);1400189212;Delete any character in a given String._@param inString the original String_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting String;public static String deleteAny(String inString, String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,string,param,in,string,the,original,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,string;public,static,string,delete,any,string,in,string,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, String charsToDelete);1400531359;Delete any character in a given String._@param inString the original String_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting String;public static String deleteAny(String inString, String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,string,param,in,string,the,original,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,string;public,static,string,delete,any,string,in,string,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, String charsToDelete);1402676350;Delete any character in a given String._@param inString the original String_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting String;public static String deleteAny(String inString, String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,string,param,in,string,the,original,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,string;public,static,string,delete,any,string,in,string,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, String charsToDelete);1426267150;Delete any character in a given String._@param inString the original String_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting String;public static String deleteAny(String inString, String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,string,param,in,string,the,original,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,string;public,static,string,delete,any,string,in,string,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, String charsToDelete);1429034538;Delete any character in a given String._@param inString the original String_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting String;public static String deleteAny(String inString, String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,string,param,in,string,the,original,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,string;public,static,string,delete,any,string,in,string,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, String charsToDelete);1429034756;Delete any character in a given {@code String}._@param inString the original {@code String}_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting {@code String};public static String deleteAny(String inString, String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,code,string,param,in,string,the,original,code,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,code,string;public,static,string,delete,any,string,in,string,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, String charsToDelete);1431006895;Delete any character in a given {@code String}._@param inString the original {@code String}_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting {@code String};public static String deleteAny(String inString, String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,code,string,param,in,string,the,original,code,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,code,string;public,static,string,delete,any,string,in,string,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, String charsToDelete);1431007368;Delete any character in a given {@code String}._@param inString the original {@code String}_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting {@code String};public static String deleteAny(String inString, String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,code,string,param,in,string,the,original,code,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,code,string;public,static,string,delete,any,string,in,string,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, String charsToDelete);1449489126;Delete any character in a given {@code String}._@param inString the original {@code String}_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting {@code String};public static String deleteAny(String inString, String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,code,string,param,in,string,the,original,code,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,code,string;public,static,string,delete,any,string,in,string,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, String charsToDelete);1467730834;Delete any character in a given {@code String}._@param inString the original {@code String}_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting {@code String};public static String deleteAny(String inString, String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,code,string,param,in,string,the,original,code,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,code,string;public,static,string,delete,any,string,in,string,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, String charsToDelete);1472128018;Delete any character in a given {@code String}._@param inString the original {@code String}_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting {@code String};public static String deleteAny(String inString, String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,code,string,param,in,string,the,original,code,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,code,string;public,static,string,delete,any,string,in,string,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, String charsToDelete);1472202842;Delete any character in a given {@code String}._@param inString the original {@code String}_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting {@code String};public static String deleteAny(String inString, String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,code,string,param,in,string,the,original,code,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,code,string;public,static,string,delete,any,string,in,string,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, String charsToDelete);1473942665;Delete any character in a given {@code String}._@param inString the original {@code String}_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting {@code String};public static String deleteAny(String inString, String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,code,string,param,in,string,the,original,code,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,code,string;public,static,string,delete,any,string,in,string,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, String charsToDelete);1484248946;Delete any character in a given {@code String}._@param inString the original {@code String}_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting {@code String};public static String deleteAny(String inString, String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,code,string,param,in,string,the,original,code,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,code,string;public,static,string,delete,any,string,in,string,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, String charsToDelete);1484260238;Delete any character in a given {@code String}._@param inString the original {@code String}_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting {@code String};public static String deleteAny(String inString, String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,code,string,param,in,string,the,original,code,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,code,string;public,static,string,delete,any,string,in,string,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, String charsToDelete);1484694546;Delete any character in a given {@code String}._@param inString the original {@code String}_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting {@code String};public static String deleteAny(String inString, String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,code,string,param,in,string,the,original,code,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,code,string;public,static,string,delete,any,string,in,string,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, String charsToDelete);1487760984;Delete any character in a given {@code String}._@param inString the original {@code String}_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting {@code String};public static String deleteAny(String inString, String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,code,string,param,in,string,the,original,code,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,code,string;public,static,string,delete,any,string,in,string,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, String charsToDelete);1487778834;Delete any character in a given {@code String}._@param inString the original {@code String}_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting {@code String};public static String deleteAny(String inString, String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,code,string,param,in,string,the,original,code,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,code,string;public,static,string,delete,any,string,in,string,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, String charsToDelete);1491898314;Delete any character in a given {@code String}._@param inString the original {@code String}_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting {@code String};public static String deleteAny(String inString, String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}__		StringBuilder sb = new StringBuilder(inString.length())__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,code,string,param,in,string,the,original,code,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,code,string;public,static,string,delete,any,string,in,string,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,in,string,length,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, String charsToDelete);1491903650;Delete any character in a given {@code String}._@param inString the original {@code String}_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting {@code String};public static String deleteAny(String inString, String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}__		StringBuilder sb = new StringBuilder(inString.length())__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,code,string,param,in,string,the,original,code,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,code,string;public,static,string,delete,any,string,in,string,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,in,string,length,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, String charsToDelete);1495868221;Delete any character in a given {@code String}._@param inString the original {@code String}_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting {@code String};public static String deleteAny(String inString, String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}__		StringBuilder sb = new StringBuilder(inString.length())__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,code,string,param,in,string,the,original,code,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,code,string;public,static,string,delete,any,string,in,string,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,in,string,length,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, String charsToDelete);1496243689;Delete any character in a given {@code String}._@param inString the original {@code String}_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting {@code String};public static String deleteAny(String inString, String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}__		StringBuilder sb = new StringBuilder(inString.length())__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,code,string,param,in,string,the,original,code,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,code,string;public,static,string,delete,any,string,in,string,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,in,string,length,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, String charsToDelete);1496259743;Delete any character in a given {@code String}._@param inString the original {@code String}_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting {@code String};public static String deleteAny(String inString, String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}__		StringBuilder sb = new StringBuilder(inString.length())__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,code,string,param,in,string,the,original,code,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,code,string;public,static,string,delete,any,string,in,string,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,in,string,length,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix);1496837955;Test if the given {@code String} starts with the specified prefix,_ignoring upper/lower case._@param str the {@code String} to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix) {_		if (str == null || prefix == null) {_			return false__		}_		if (str.startsWith(prefix)) {_			return true__		}_		if (str.length() < prefix.length()) {_			return false__		}__		String lcStr = str.substring(0, prefix.length()).toLowerCase()__		String lcPrefix = prefix.toLowerCase()__		return lcStr.equals(lcPrefix)__	};test,if,the,given,code,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,nullable,string,str,nullable,string,prefix,if,str,null,prefix,null,return,false,if,str,starts,with,prefix,return,true,if,str,length,prefix,length,return,false,string,lc,str,str,substring,0,prefix,length,to,lower,case,string,lc,prefix,prefix,to,lower,case,return,lc,str,equals,lc,prefix
StringUtils -> public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix);1499270197;Test if the given {@code String} starts with the specified prefix,_ignoring upper/lower case._@param str the {@code String} to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix) {_		if (str == null || prefix == null) {_			return false__		}_		if (str.startsWith(prefix)) {_			return true__		}_		if (str.length() < prefix.length()) {_			return false__		}__		String lcStr = str.substring(0, prefix.length()).toLowerCase()__		String lcPrefix = prefix.toLowerCase()__		return lcStr.equals(lcPrefix)__	};test,if,the,given,code,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,nullable,string,str,nullable,string,prefix,if,str,null,prefix,null,return,false,if,str,starts,with,prefix,return,true,if,str,length,prefix,length,return,false,string,lc,str,str,substring,0,prefix,length,to,lower,case,string,lc,prefix,prefix,to,lower,case,return,lc,str,equals,lc,prefix
StringUtils -> public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix);1508667152;Test if the given {@code String} starts with the specified prefix,_ignoring upper/lower case._@param str the {@code String} to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix) {_		if (str == null || prefix == null) {_			return false__		}_		if (str.startsWith(prefix)) {_			return true__		}_		if (str.length() < prefix.length()) {_			return false__		}__		String lcStr = str.substring(0, prefix.length()).toLowerCase()__		String lcPrefix = prefix.toLowerCase()__		return lcStr.equals(lcPrefix)__	};test,if,the,given,code,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,nullable,string,str,nullable,string,prefix,if,str,null,prefix,null,return,false,if,str,starts,with,prefix,return,true,if,str,length,prefix,length,return,false,string,lc,str,str,substring,0,prefix,length,to,lower,case,string,lc,prefix,prefix,to,lower,case,return,lc,str,equals,lc,prefix
StringUtils -> public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix);1508675477;Test if the given {@code String} starts with the specified prefix,_ignoring upper/lower case._@param str the {@code String} to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix) {_		return (str != null && prefix != null && str.length() >= prefix.length() &&_				str.regionMatches(true, 0, prefix, 0, prefix.length()))__	};test,if,the,given,code,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,nullable,string,str,nullable,string,prefix,return,str,null,prefix,null,str,length,prefix,length,str,region,matches,true,0,prefix,0,prefix,length
StringUtils -> public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix);1508843807;Test if the given {@code String} starts with the specified prefix,_ignoring upper/lower case._@param str the {@code String} to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix) {_		return (str != null && prefix != null && str.length() >= prefix.length() &&_				str.regionMatches(true, 0, prefix, 0, prefix.length()))__	};test,if,the,given,code,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,nullable,string,str,nullable,string,prefix,return,str,null,prefix,null,str,length,prefix,length,str,region,matches,true,0,prefix,0,prefix,length
StringUtils -> public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix);1516903831;Test if the given {@code String} starts with the specified prefix,_ignoring upper/lower case._@param str the {@code String} to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix) {_		return (str != null && prefix != null && str.length() >= prefix.length() &&_				str.regionMatches(true, 0, prefix, 0, prefix.length()))__	};test,if,the,given,code,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,nullable,string,str,nullable,string,prefix,return,str,null,prefix,null,str,length,prefix,length,str,region,matches,true,0,prefix,0,prefix,length
StringUtils -> public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix);1519295386;Test if the given {@code String} starts with the specified prefix,_ignoring upper/lower case._@param str the {@code String} to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix) {_		return (str != null && prefix != null && str.length() >= prefix.length() &&_				str.regionMatches(true, 0, prefix, 0, prefix.length()))__	};test,if,the,given,code,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,nullable,string,str,nullable,string,prefix,return,str,null,prefix,null,str,length,prefix,length,str,region,matches,true,0,prefix,0,prefix,length
StringUtils -> public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix);1519308837;Test if the given {@code String} starts with the specified prefix,_ignoring upper/lower case._@param str the {@code String} to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix) {_		return (str != null && prefix != null && str.length() >= prefix.length() &&_				str.regionMatches(true, 0, prefix, 0, prefix.length()))__	};test,if,the,given,code,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,nullable,string,str,nullable,string,prefix,return,str,null,prefix,null,str,length,prefix,length,str,region,matches,true,0,prefix,0,prefix,length
StringUtils -> public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix);1519588127;Test if the given {@code String} starts with the specified prefix,_ignoring upper/lower case._@param str the {@code String} to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix) {_		return (str != null && prefix != null && str.length() >= prefix.length() &&_				str.regionMatches(true, 0, prefix, 0, prefix.length()))__	};test,if,the,given,code,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,nullable,string,str,nullable,string,prefix,return,str,null,prefix,null,str,length,prefix,length,str,region,matches,true,0,prefix,0,prefix,length
StringUtils -> public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix);1522332352;Test if the given {@code String} starts with the specified prefix,_ignoring upper/lower case._@param str the {@code String} to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix) {_		return (str != null && prefix != null && str.length() >= prefix.length() &&_				str.regionMatches(true, 0, prefix, 0, prefix.length()))__	};test,if,the,given,code,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,nullable,string,str,nullable,string,prefix,return,str,null,prefix,null,str,length,prefix,length,str,region,matches,true,0,prefix,0,prefix,length
StringUtils -> public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix);1525166194;Test if the given {@code String} starts with the specified prefix,_ignoring upper/lower case._@param str the {@code String} to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix) {_		return (str != null && prefix != null && str.length() >= prefix.length() &&_				str.regionMatches(true, 0, prefix, 0, prefix.length()))__	};test,if,the,given,code,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,nullable,string,str,nullable,string,prefix,return,str,null,prefix,null,str,length,prefix,length,str,region,matches,true,0,prefix,0,prefix,length
StringUtils -> public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix);1530188116;Test if the given {@code String} starts with the specified prefix,_ignoring upper/lower case._@param str the {@code String} to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix) {_		return (str != null && prefix != null && str.length() >= prefix.length() &&_				str.regionMatches(true, 0, prefix, 0, prefix.length()))__	};test,if,the,given,code,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,nullable,string,str,nullable,string,prefix,return,str,null,prefix,null,str,length,prefix,length,str,region,matches,true,0,prefix,0,prefix,length
StringUtils -> public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix);1531843079;Test if the given {@code String} starts with the specified prefix,_ignoring upper/lower case._@param str the {@code String} to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix) {_		return (str != null && prefix != null && str.length() >= prefix.length() &&_				str.regionMatches(true, 0, prefix, 0, prefix.length()))__	};test,if,the,given,code,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,nullable,string,str,nullable,string,prefix,return,str,null,prefix,null,str,length,prefix,length,str,region,matches,true,0,prefix,0,prefix,length
StringUtils -> public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix);1531905026;Test if the given {@code String} starts with the specified prefix,_ignoring upper/lower case._@param str the {@code String} to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix) {_		return (str != null && prefix != null && str.length() >= prefix.length() &&_				str.regionMatches(true, 0, prefix, 0, prefix.length()))__	};test,if,the,given,code,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,nullable,string,str,nullable,string,prefix,return,str,null,prefix,null,str,length,prefix,length,str,region,matches,true,0,prefix,0,prefix,length
StringUtils -> public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix);1533557519;Test if the given {@code String} starts with the specified prefix,_ignoring upper/lower case._@param str the {@code String} to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix) {_		return (str != null && prefix != null && str.length() >= prefix.length() &&_				str.regionMatches(true, 0, prefix, 0, prefix.length()))__	};test,if,the,given,code,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,nullable,string,str,nullable,string,prefix,return,str,null,prefix,null,str,length,prefix,length,str,region,matches,true,0,prefix,0,prefix,length
StringUtils -> public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix);1533602820;Test if the given {@code String} starts with the specified prefix,_ignoring upper/lower case._@param str the {@code String} to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix) {_		return (str != null && prefix != null && str.length() >= prefix.length() &&_				str.regionMatches(true, 0, prefix, 0, prefix.length()))__	};test,if,the,given,code,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,nullable,string,str,nullable,string,prefix,return,str,null,prefix,null,str,length,prefix,length,str,region,matches,true,0,prefix,0,prefix,length
StringUtils -> public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix);1535316501;Test if the given {@code String} starts with the specified prefix,_ignoring upper/lower case._@param str the {@code String} to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix) {_		return (str != null && prefix != null && str.length() >= prefix.length() &&_				str.regionMatches(true, 0, prefix, 0, prefix.length()))__	};test,if,the,given,code,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,nullable,string,str,nullable,string,prefix,return,str,null,prefix,null,str,length,prefix,length,str,region,matches,true,0,prefix,0,prefix,length
StringUtils -> public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix);1550237113;Test if the given {@code String} starts with the specified prefix,_ignoring upper/lower case._@param str the {@code String} to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix) {_		return (str != null && prefix != null && str.length() >= prefix.length() &&_				str.regionMatches(true, 0, prefix, 0, prefix.length()))__	};test,if,the,given,code,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,nullable,string,str,nullable,string,prefix,return,str,null,prefix,null,str,length,prefix,length,str,region,matches,true,0,prefix,0,prefix,length
StringUtils -> public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix);1550238935;Test if the given {@code String} starts with the specified prefix,_ignoring upper/lower case._@param str the {@code String} to check_@param prefix the prefix to look for_@see java.lang.String#startsWith;public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix) {_		return (str != null && prefix != null && str.length() >= prefix.length() &&_				str.regionMatches(true, 0, prefix, 0, prefix.length()))__	};test,if,the,given,code,string,starts,with,the,specified,prefix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,prefix,the,prefix,to,look,for,see,java,lang,string,starts,with;public,static,boolean,starts,with,ignore,case,nullable,string,str,nullable,string,prefix,return,str,null,prefix,null,str,length,prefix,length,str,region,matches,true,0,prefix,0,prefix,length
StringUtils -> public static String[] mergeStringArrays(String[] array1, String[] array2);1328020251;Merge the given String arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be <code>null</code>)_@param array2 the second array (can be <code>null</code>)_@return the new array (<code>null</code> if both given arrays were <code>null</code>);public static String[] mergeStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		List<String> result = new ArrayList<String>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,code,param,array2,the,second,array,can,be,code,null,code,return,the,new,array,code,null,code,if,both,given,arrays,were,code,null,code;public,static,string,merge,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,string,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> public static String[] mergeStringArrays(String[] array1, String[] array2);1337236962;Merge the given String arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be <code>null</code>)_@param array2 the second array (can be <code>null</code>)_@return the new array (<code>null</code> if both given arrays were <code>null</code>);public static String[] mergeStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		List<String> result = new ArrayList<String>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,code,param,array2,the,second,array,can,be,code,null,code,return,the,new,array,code,null,code,if,both,given,arrays,were,code,null,code;public,static,string,merge,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,string,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> public static String[] mergeStringArrays(String[] array1, String[] array2);1356735495;Merge the given String arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] mergeStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		List<String> result = new ArrayList<String>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,merge,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,string,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> public static String[] mergeStringArrays(String[] array1, String[] array2);1367955086;Merge the given String arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] mergeStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		List<String> result = new ArrayList<String>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,merge,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,string,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> public static String[] mergeStringArrays(String[] array1, String[] array2);1380921248;Merge the given String arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] mergeStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		List<String> result = new ArrayList<String>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,merge,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,string,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> public static String[] mergeStringArrays(String[] array1, String[] array2);1382750743;Merge the given String arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] mergeStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		List<String> result = new ArrayList<String>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,merge,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,string,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> public static String[] mergeStringArrays(String[] array1, String[] array2);1385423968;Merge the given String arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] mergeStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		List<String> result = new ArrayList<String>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,merge,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,string,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> public static String[] mergeStringArrays(String[] array1, String[] array2);1400189212;Merge the given String arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] mergeStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		List<String> result = new ArrayList<String>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,merge,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,string,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> public static String[] mergeStringArrays(String[] array1, String[] array2);1400531359;Merge the given String arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] mergeStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		List<String> result = new ArrayList<String>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,merge,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,string,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> public static String[] mergeStringArrays(String[] array1, String[] array2);1402676350;Merge the given String arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] mergeStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		List<String> result = new ArrayList<String>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,merge,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,string,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> public static String[] mergeStringArrays(String[] array1, String[] array2);1426267150;Merge the given String arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] mergeStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		List<String> result = new ArrayList<String>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,merge,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,string,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> public static String[] mergeStringArrays(String[] array1, String[] array2);1429034538;Merge the given String arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] mergeStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		List<String> result = new ArrayList<String>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,merge,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,string,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> public static String[] mergeStringArrays(String[] array1, String[] array2);1429034756;Merge the given {@code String} arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] mergeStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		List<String> result = new ArrayList<String>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,code,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,merge,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,string,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> public static String[] mergeStringArrays(String[] array1, String[] array2);1431006895;Merge the given {@code String} arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] mergeStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		List<String> result = new ArrayList<String>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,code,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,merge,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,string,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> public static String[] mergeStringArrays(String[] array1, String[] array2);1431007368;Merge the given {@code String} arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] mergeStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		List<String> result = new ArrayList<String>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,code,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,merge,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,string,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> public static String[] mergeStringArrays(String[] array1, String[] array2);1449489126;Merge the given {@code String} arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] mergeStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		List<String> result = new ArrayList<String>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,code,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,merge,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,string,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> public static String[] mergeStringArrays(String[] array1, String[] array2);1467730834;Merge the given {@code String} arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] mergeStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		List<String> result = new ArrayList<>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,code,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,merge,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> public static String[] mergeStringArrays(String[] array1, String[] array2);1472128018;Merge the given {@code String} arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] mergeStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		List<String> result = new ArrayList<>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,code,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,merge,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> public static String[] mergeStringArrays(String[] array1, String[] array2);1472202842;Merge the given {@code String} arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] mergeStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		List<String> result = new ArrayList<>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,code,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,merge,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> public static String[] mergeStringArrays(String[] array1, String[] array2);1473942665;Merge the given {@code String} arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] mergeStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		List<String> result = new ArrayList<>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,code,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,merge,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> public static String[] mergeStringArrays(String[] array1, String[] array2);1484248946;Merge the given {@code String} arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] mergeStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		List<String> result = new ArrayList<>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,code,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,merge,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> public static String[] mergeStringArrays(String[] array1, String[] array2);1484260238;Merge the given {@code String} arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] mergeStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		List<String> result = new ArrayList<>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,code,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,merge,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> public static String[] mergeStringArrays(String[] array1, String[] array2);1484694546;Merge the given {@code String} arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] mergeStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		List<String> result = new ArrayList<>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,code,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,merge,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> public static String[] mergeStringArrays(String[] array1, String[] array2);1487760984;Merge the given {@code String} arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] mergeStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		List<String> result = new ArrayList<>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,code,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,merge,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> public static String[] mergeStringArrays(String[] array1, String[] array2);1487778834;Merge the given {@code String} arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] mergeStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}_		List<String> result = new ArrayList<>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,code,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,merge,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> public static String[] mergeStringArrays(String[] array1, String[] array2);1491898314;Merge the given {@code String} arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] mergeStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		List<String> result = new ArrayList<>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,code,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,merge,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> public static String[] mergeStringArrays(String[] array1, String[] array2);1491903650;Merge the given {@code String} arrays into one, with overlapping_array elements only included once._<p>The order of elements in the original arrays is preserved_(with the exception of overlapping elements, which are only_included on their first occurrence)._@param array1 the first array (can be {@code null})_@param array2 the second array (can be {@code null})_@return the new array ({@code null} if both given arrays were {@code null});public static String[] mergeStringArrays(String[] array1, String[] array2) {_		if (ObjectUtils.isEmpty(array1)) {_			return array2__		}_		if (ObjectUtils.isEmpty(array2)) {_			return array1__		}__		List<String> result = new ArrayList<>()__		result.addAll(Arrays.asList(array1))__		for (String str : array2) {_			if (!result.contains(str)) {_				result.add(str)__			}_		}_		return toStringArray(result)__	};merge,the,given,code,string,arrays,into,one,with,overlapping,array,elements,only,included,once,p,the,order,of,elements,in,the,original,arrays,is,preserved,with,the,exception,of,overlapping,elements,which,are,only,included,on,their,first,occurrence,param,array1,the,first,array,can,be,code,null,param,array2,the,second,array,can,be,code,null,return,the,new,array,code,null,if,both,given,arrays,were,code,null;public,static,string,merge,string,arrays,string,array1,string,array2,if,object,utils,is,empty,array1,return,array2,if,object,utils,is,empty,array2,return,array1,list,string,result,new,array,list,result,add,all,arrays,as,list,array1,for,string,str,array2,if,result,contains,str,result,add,str,return,to,string,array,result
StringUtils -> public static String[] sortStringArray(String[] array);1328020251;Turn given source String array into sorted array._@param array the source array_@return the sorted array (never <code>null</code>);public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		Arrays.sort(array)__		return array__	};turn,given,source,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null,code;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1337236962;Turn given source String array into sorted array._@param array the source array_@return the sorted array (never <code>null</code>);public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		Arrays.sort(array)__		return array__	};turn,given,source,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null,code;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1356735495;Turn given source String array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		Arrays.sort(array)__		return array__	};turn,given,source,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1367955086;Turn given source String array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		Arrays.sort(array)__		return array__	};turn,given,source,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1380921248;Turn given source String array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		Arrays.sort(array)__		return array__	};turn,given,source,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1382750743;Turn given source String array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		Arrays.sort(array)__		return array__	};turn,given,source,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1385423968;Turn given source String array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		Arrays.sort(array)__		return array__	};turn,given,source,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1400189212;Turn given source String array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		Arrays.sort(array)__		return array__	};turn,given,source,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1400531359;Turn given source String array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		Arrays.sort(array)__		return array__	};turn,given,source,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1402676350;Turn given source String array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		Arrays.sort(array)__		return array__	};turn,given,source,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1426267150;Turn given source String array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		Arrays.sort(array)__		return array__	};turn,given,source,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1429034538;Turn given source String array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		Arrays.sort(array)__		return array__	};turn,given,source,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1429034756;Turn given source {@code String} array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		Arrays.sort(array)__		return array__	};turn,given,source,code,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1431006895;Turn given source {@code String} array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		Arrays.sort(array)__		return array__	};turn,given,source,code,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1431007368;Turn given source {@code String} array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		Arrays.sort(array)__		return array__	};turn,given,source,code,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1449489126;Turn given source {@code String} array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		Arrays.sort(array)__		return array__	};turn,given,source,code,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1467730834;Turn given source {@code String} array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		Arrays.sort(array)__		return array__	};turn,given,source,code,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1472128018;Turn given source {@code String} array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		Arrays.sort(array)__		return array__	};turn,given,source,code,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1472202842;Turn given source {@code String} array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		Arrays.sort(array)__		return array__	};turn,given,source,code,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1473942665;Turn given source {@code String} array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		Arrays.sort(array)__		return array__	};turn,given,source,code,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1484248946;Turn given source {@code String} array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		Arrays.sort(array)__		return array__	};turn,given,source,code,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1484260238;Turn given source {@code String} array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		Arrays.sort(array)__		return array__	};turn,given,source,code,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1484694546;Turn given source {@code String} array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		Arrays.sort(array)__		return array__	};turn,given,source,code,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1487760984;Turn given source {@code String} array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		Arrays.sort(array)__		return array__	};turn,given,source,code,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1487778834;Turn given source {@code String} array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}_		Arrays.sort(array)__		return array__	};turn,given,source,code,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1491898314;Turn given source {@code String} array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		Arrays.sort(array)__		return array__	};turn,given,source,code,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1491903650;Turn given source {@code String} array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		Arrays.sort(array)__		return array__	};turn,given,source,code,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1495868221;Turn given source {@code String} array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		Arrays.sort(array)__		return array__	};turn,given,source,code,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1496243689;Turn given source {@code String} array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		Arrays.sort(array)__		return array__	};turn,given,source,code,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1496259743;Turn given source {@code String} array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		Arrays.sort(array)__		return array__	};turn,given,source,code,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1496837955;Turn given source {@code String} array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		Arrays.sort(array)__		return array__	};turn,given,source,code,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1499270197;Turn given source {@code String} array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		Arrays.sort(array)__		return array__	};turn,given,source,code,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1508667152;Turn given source {@code String} array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		Arrays.sort(array)__		return array__	};turn,given,source,code,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1508675477;Turn given source {@code String} array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		Arrays.sort(array)__		return array__	};turn,given,source,code,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1508843807;Turn given source {@code String} array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		Arrays.sort(array)__		return array__	};turn,given,source,code,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1516903831;Turn given source {@code String} array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		Arrays.sort(array)__		return array__	};turn,given,source,code,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1519295386;Turn given source {@code String} array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		Arrays.sort(array)__		return array__	};turn,given,source,code,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1519308837;Turn given source {@code String} array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		Arrays.sort(array)__		return array__	};turn,given,source,code,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1519588127;Turn given source {@code String} array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		Arrays.sort(array)__		return array__	};turn,given,source,code,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1522332352;Turn given source {@code String} array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		Arrays.sort(array)__		return array__	};turn,given,source,code,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1525166194;Turn given source {@code String} array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		Arrays.sort(array)__		return array__	};turn,given,source,code,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1530188116;Turn given source {@code String} array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		Arrays.sort(array)__		return array__	};turn,given,source,code,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1531843079;Turn given source {@code String} array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		Arrays.sort(array)__		return array__	};turn,given,source,code,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1531905026;Turn given source {@code String} array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		Arrays.sort(array)__		return array__	};turn,given,source,code,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1533557519;Turn given source {@code String} array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		Arrays.sort(array)__		return array__	};turn,given,source,code,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1533602820;Turn given source {@code String} array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		Arrays.sort(array)__		return array__	};turn,given,source,code,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1535316501;Turn given source {@code String} array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		Arrays.sort(array)__		return array__	};turn,given,source,code,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1550237113;Turn given source {@code String} array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		Arrays.sort(array)__		return array__	};turn,given,source,code,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] sortStringArray(String[] array);1550238935;Turn given source {@code String} array into sorted array._@param array the source array_@return the sorted array (never {@code null});public static String[] sortStringArray(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[0]__		}__		Arrays.sort(array)__		return array__	};turn,given,source,code,string,array,into,sorted,array,param,array,the,source,array,return,the,sorted,array,never,code,null;public,static,string,sort,string,array,string,array,if,object,utils,is,empty,array,return,new,string,0,arrays,sort,array,return,array
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1328020251;Remove duplicate Strings from the given array._Also sorts the array, as it uses a TreeSet._@param array the String array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}_		Set<String> set = new TreeSet<String>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,also,sorts,the,array,as,it,uses,a,tree,set,param,array,the,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,tree,set,string,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1337236962;Remove duplicate Strings from the given array._Also sorts the array, as it uses a TreeSet._@param array the String array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}_		Set<String> set = new TreeSet<String>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,also,sorts,the,array,as,it,uses,a,tree,set,param,array,the,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,tree,set,string,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1356735495;Remove duplicate Strings from the given array._Also sorts the array, as it uses a TreeSet._@param array the String array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}_		Set<String> set = new TreeSet<String>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,also,sorts,the,array,as,it,uses,a,tree,set,param,array,the,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,tree,set,string,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1367955086;Remove duplicate Strings from the given array._Also sorts the array, as it uses a TreeSet._@param array the String array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}_		Set<String> set = new TreeSet<String>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,also,sorts,the,array,as,it,uses,a,tree,set,param,array,the,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,tree,set,string,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1380921248;Remove duplicate Strings from the given array._Also sorts the array, as it uses a TreeSet._@param array the String array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}_		Set<String> set = new TreeSet<String>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,also,sorts,the,array,as,it,uses,a,tree,set,param,array,the,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,tree,set,string,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1382750743;Remove duplicate Strings from the given array._Also sorts the array, as it uses a TreeSet._@param array the String array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}_		Set<String> set = new TreeSet<String>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,also,sorts,the,array,as,it,uses,a,tree,set,param,array,the,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,tree,set,string,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1385423968;Remove duplicate Strings from the given array._Also sorts the array, as it uses a TreeSet._@param array the String array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}_		Set<String> set = new TreeSet<String>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,also,sorts,the,array,as,it,uses,a,tree,set,param,array,the,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,tree,set,string,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1400189212;Remove duplicate Strings from the given array._Also sorts the array, as it uses a TreeSet._@param array the String array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}_		Set<String> set = new TreeSet<String>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,also,sorts,the,array,as,it,uses,a,tree,set,param,array,the,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,tree,set,string,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1400531359;Remove duplicate Strings from the given array._Also sorts the array, as it uses a TreeSet._@param array the String array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}_		Set<String> set = new TreeSet<String>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,also,sorts,the,array,as,it,uses,a,tree,set,param,array,the,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,tree,set,string,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1402676350;Remove duplicate Strings from the given array._Also sorts the array, as it uses a TreeSet._@param array the String array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}_		Set<String> set = new TreeSet<String>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,also,sorts,the,array,as,it,uses,a,tree,set,param,array,the,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,tree,set,string,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1426267150;Remove duplicate Strings from the given array._Also sorts the array, as it uses a TreeSet._@param array the String array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}_		Set<String> set = new TreeSet<String>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,also,sorts,the,array,as,it,uses,a,tree,set,param,array,the,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,tree,set,string,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1429034538;Remove duplicate Strings from the given array._Also sorts the array, as it uses a TreeSet._@param array the String array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}_		Set<String> set = new TreeSet<String>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,also,sorts,the,array,as,it,uses,a,tree,set,param,array,the,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,tree,set,string,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1429034756;Remove duplicate strings from the given array._<p>Also sorts the array, as it uses a {@link TreeSet}._@param array the {@code String} array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}_		Set<String> set = new TreeSet<String>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,p,also,sorts,the,array,as,it,uses,a,link,tree,set,param,array,the,code,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,tree,set,string,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1431006895;Remove duplicate strings from the given array._<p>Also sorts the array, as it uses a {@link TreeSet}._@param array the {@code String} array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}_		Set<String> set = new TreeSet<String>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,p,also,sorts,the,array,as,it,uses,a,link,tree,set,param,array,the,code,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,tree,set,string,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1431007368;Remove duplicate strings from the given array._<p>As of 4.2, it preserves the original order, as it uses a {@link LinkedHashSet}._@param array the {@code String} array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}_		Set<String> set = new LinkedHashSet<String>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,p,as,of,4,2,it,preserves,the,original,order,as,it,uses,a,link,linked,hash,set,param,array,the,code,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,linked,hash,set,string,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1449489126;Remove duplicate strings from the given array._<p>As of 4.2, it preserves the original order, as it uses a {@link LinkedHashSet}._@param array the {@code String} array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}_		Set<String> set = new LinkedHashSet<String>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,p,as,of,4,2,it,preserves,the,original,order,as,it,uses,a,link,linked,hash,set,param,array,the,code,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,linked,hash,set,string,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1467730834;Remove duplicate strings from the given array._<p>As of 4.2, it preserves the original order, as it uses a {@link LinkedHashSet}._@param array the {@code String} array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}_		Set<String> set = new LinkedHashSet<>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,p,as,of,4,2,it,preserves,the,original,order,as,it,uses,a,link,linked,hash,set,param,array,the,code,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,linked,hash,set,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1472128018;Remove duplicate strings from the given array._<p>As of 4.2, it preserves the original order, as it uses a {@link LinkedHashSet}._@param array the {@code String} array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}_		Set<String> set = new LinkedHashSet<>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,p,as,of,4,2,it,preserves,the,original,order,as,it,uses,a,link,linked,hash,set,param,array,the,code,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,linked,hash,set,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1472202842;Remove duplicate strings from the given array._<p>As of 4.2, it preserves the original order, as it uses a {@link LinkedHashSet}._@param array the {@code String} array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}_		Set<String> set = new LinkedHashSet<>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,p,as,of,4,2,it,preserves,the,original,order,as,it,uses,a,link,linked,hash,set,param,array,the,code,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,linked,hash,set,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1473942665;Remove duplicate strings from the given array._<p>As of 4.2, it preserves the original order, as it uses a {@link LinkedHashSet}._@param array the {@code String} array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}_		Set<String> set = new LinkedHashSet<>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,p,as,of,4,2,it,preserves,the,original,order,as,it,uses,a,link,linked,hash,set,param,array,the,code,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,linked,hash,set,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1484248946;Remove duplicate strings from the given array._<p>As of 4.2, it preserves the original order, as it uses a {@link LinkedHashSet}._@param array the {@code String} array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}_		Set<String> set = new LinkedHashSet<>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,p,as,of,4,2,it,preserves,the,original,order,as,it,uses,a,link,linked,hash,set,param,array,the,code,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,linked,hash,set,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1484260238;Remove duplicate strings from the given array._<p>As of 4.2, it preserves the original order, as it uses a {@link LinkedHashSet}._@param array the {@code String} array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}_		Set<String> set = new LinkedHashSet<>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,p,as,of,4,2,it,preserves,the,original,order,as,it,uses,a,link,linked,hash,set,param,array,the,code,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,linked,hash,set,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1484694546;Remove duplicate strings from the given array._<p>As of 4.2, it preserves the original order, as it uses a {@link LinkedHashSet}._@param array the {@code String} array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}_		Set<String> set = new LinkedHashSet<>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,p,as,of,4,2,it,preserves,the,original,order,as,it,uses,a,link,linked,hash,set,param,array,the,code,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,linked,hash,set,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1487760984;Remove duplicate strings from the given array._<p>As of 4.2, it preserves the original order, as it uses a {@link LinkedHashSet}._@param array the {@code String} array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}_		Set<String> set = new LinkedHashSet<>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,p,as,of,4,2,it,preserves,the,original,order,as,it,uses,a,link,linked,hash,set,param,array,the,code,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,linked,hash,set,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1487778834;Remove duplicate strings from the given array._<p>As of 4.2, it preserves the original order, as it uses a {@link LinkedHashSet}._@param array the {@code String} array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}_		Set<String> set = new LinkedHashSet<>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,p,as,of,4,2,it,preserves,the,original,order,as,it,uses,a,link,linked,hash,set,param,array,the,code,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,linked,hash,set,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1491898314;Remove duplicate strings from the given array._<p>As of 4.2, it preserves the original order, as it uses a {@link LinkedHashSet}._@param array the {@code String} array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}__		Set<String> set = new LinkedHashSet<>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,p,as,of,4,2,it,preserves,the,original,order,as,it,uses,a,link,linked,hash,set,param,array,the,code,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,linked,hash,set,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1491903650;Remove duplicate strings from the given array._<p>As of 4.2, it preserves the original order, as it uses a {@link LinkedHashSet}._@param array the {@code String} array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}__		Set<String> set = new LinkedHashSet<>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,p,as,of,4,2,it,preserves,the,original,order,as,it,uses,a,link,linked,hash,set,param,array,the,code,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,linked,hash,set,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1495868221;Remove duplicate strings from the given array._<p>As of 4.2, it preserves the original order, as it uses a {@link LinkedHashSet}._@param array the {@code String} array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}__		Set<String> set = new LinkedHashSet<>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,p,as,of,4,2,it,preserves,the,original,order,as,it,uses,a,link,linked,hash,set,param,array,the,code,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,linked,hash,set,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1496243689;Remove duplicate strings from the given array._<p>As of 4.2, it preserves the original order, as it uses a {@link LinkedHashSet}._@param array the {@code String} array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}__		Set<String> set = new LinkedHashSet<>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,p,as,of,4,2,it,preserves,the,original,order,as,it,uses,a,link,linked,hash,set,param,array,the,code,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,linked,hash,set,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1496259743;Remove duplicate strings from the given array._<p>As of 4.2, it preserves the original order, as it uses a {@link LinkedHashSet}._@param array the {@code String} array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}__		Set<String> set = new LinkedHashSet<>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,p,as,of,4,2,it,preserves,the,original,order,as,it,uses,a,link,linked,hash,set,param,array,the,code,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,linked,hash,set,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1496837955;Remove duplicate strings from the given array._<p>As of 4.2, it preserves the original order, as it uses a {@link LinkedHashSet}._@param array the {@code String} array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}__		Set<String> set = new LinkedHashSet<>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,p,as,of,4,2,it,preserves,the,original,order,as,it,uses,a,link,linked,hash,set,param,array,the,code,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,linked,hash,set,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1499270197;Remove duplicate strings from the given array._<p>As of 4.2, it preserves the original order, as it uses a {@link LinkedHashSet}._@param array the {@code String} array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}__		Set<String> set = new LinkedHashSet<>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,p,as,of,4,2,it,preserves,the,original,order,as,it,uses,a,link,linked,hash,set,param,array,the,code,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,linked,hash,set,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1508667152;Remove duplicate strings from the given array._<p>As of 4.2, it preserves the original order, as it uses a {@link LinkedHashSet}._@param array the {@code String} array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}__		Set<String> set = new LinkedHashSet<>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,p,as,of,4,2,it,preserves,the,original,order,as,it,uses,a,link,linked,hash,set,param,array,the,code,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,linked,hash,set,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1508675477;Remove duplicate strings from the given array._<p>As of 4.2, it preserves the original order, as it uses a {@link LinkedHashSet}._@param array the {@code String} array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}__		Set<String> set = new LinkedHashSet<>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,p,as,of,4,2,it,preserves,the,original,order,as,it,uses,a,link,linked,hash,set,param,array,the,code,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,linked,hash,set,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1508843807;Remove duplicate strings from the given array._<p>As of 4.2, it preserves the original order, as it uses a {@link LinkedHashSet}._@param array the {@code String} array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}__		Set<String> set = new LinkedHashSet<>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,p,as,of,4,2,it,preserves,the,original,order,as,it,uses,a,link,linked,hash,set,param,array,the,code,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,linked,hash,set,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1516903831;Remove duplicate strings from the given array._<p>As of 4.2, it preserves the original order, as it uses a {@link LinkedHashSet}._@param array the {@code String} array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}__		Set<String> set = new LinkedHashSet<>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,p,as,of,4,2,it,preserves,the,original,order,as,it,uses,a,link,linked,hash,set,param,array,the,code,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,linked,hash,set,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1519295386;Remove duplicate strings from the given array._<p>As of 4.2, it preserves the original order, as it uses a {@link LinkedHashSet}._@param array the {@code String} array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}__		Set<String> set = new LinkedHashSet<>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,p,as,of,4,2,it,preserves,the,original,order,as,it,uses,a,link,linked,hash,set,param,array,the,code,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,linked,hash,set,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1519308837;Remove duplicate strings from the given array._<p>As of 4.2, it preserves the original order, as it uses a {@link LinkedHashSet}._@param array the {@code String} array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}__		Set<String> set = new LinkedHashSet<>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,p,as,of,4,2,it,preserves,the,original,order,as,it,uses,a,link,linked,hash,set,param,array,the,code,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,linked,hash,set,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1519588127;Remove duplicate strings from the given array._<p>As of 4.2, it preserves the original order, as it uses a {@link LinkedHashSet}._@param array the {@code String} array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}__		Set<String> set = new LinkedHashSet<>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,p,as,of,4,2,it,preserves,the,original,order,as,it,uses,a,link,linked,hash,set,param,array,the,code,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,linked,hash,set,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1522332352;Remove duplicate strings from the given array._<p>As of 4.2, it preserves the original order, as it uses a {@link LinkedHashSet}._@param array the {@code String} array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}__		Set<String> set = new LinkedHashSet<>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,p,as,of,4,2,it,preserves,the,original,order,as,it,uses,a,link,linked,hash,set,param,array,the,code,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,linked,hash,set,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1525166194;Remove duplicate strings from the given array._<p>As of 4.2, it preserves the original order, as it uses a {@link LinkedHashSet}._@param array the {@code String} array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}__		Set<String> set = new LinkedHashSet<>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,p,as,of,4,2,it,preserves,the,original,order,as,it,uses,a,link,linked,hash,set,param,array,the,code,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,linked,hash,set,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1530188116;Remove duplicate strings from the given array._<p>As of 4.2, it preserves the original order, as it uses a {@link LinkedHashSet}._@param array the {@code String} array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}__		Set<String> set = new LinkedHashSet<>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,p,as,of,4,2,it,preserves,the,original,order,as,it,uses,a,link,linked,hash,set,param,array,the,code,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,linked,hash,set,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1531843079;Remove duplicate strings from the given array._<p>As of 4.2, it preserves the original order, as it uses a {@link LinkedHashSet}._@param array the {@code String} array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}__		Set<String> set = new LinkedHashSet<>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,p,as,of,4,2,it,preserves,the,original,order,as,it,uses,a,link,linked,hash,set,param,array,the,code,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,linked,hash,set,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1531905026;Remove duplicate strings from the given array._<p>As of 4.2, it preserves the original order, as it uses a {@link LinkedHashSet}._@param array the {@code String} array_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}__		Set<String> set = new LinkedHashSet<>()__		for (String element : array) {_			set.add(element)__		}_		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,p,as,of,4,2,it,preserves,the,original,order,as,it,uses,a,link,linked,hash,set,param,array,the,code,string,array,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,linked,hash,set,for,string,element,array,set,add,element,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1533557519;Remove duplicate strings from the given array._<p>As of 4.2, it preserves the original order, as it uses a {@link LinkedHashSet}._@param array the {@code String} array (potentially empty)_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}__		Set<String> set = new LinkedHashSet<>(Arrays.asList(array))__		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,p,as,of,4,2,it,preserves,the,original,order,as,it,uses,a,link,linked,hash,set,param,array,the,code,string,array,potentially,empty,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,linked,hash,set,arrays,as,list,array,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1533602820;Remove duplicate strings from the given array._<p>As of 4.2, it preserves the original order, as it uses a {@link LinkedHashSet}._@param array the {@code String} array (potentially empty)_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}__		Set<String> set = new LinkedHashSet<>(Arrays.asList(array))__		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,p,as,of,4,2,it,preserves,the,original,order,as,it,uses,a,link,linked,hash,set,param,array,the,code,string,array,potentially,empty,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,linked,hash,set,arrays,as,list,array,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1535316501;Remove duplicate strings from the given array._<p>As of 4.2, it preserves the original order, as it uses a {@link LinkedHashSet}._@param array the {@code String} array (potentially empty)_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}__		Set<String> set = new LinkedHashSet<>(Arrays.asList(array))__		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,p,as,of,4,2,it,preserves,the,original,order,as,it,uses,a,link,linked,hash,set,param,array,the,code,string,array,potentially,empty,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,linked,hash,set,arrays,as,list,array,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1550237113;Remove duplicate strings from the given array._<p>As of 4.2, it preserves the original order, as it uses a {@link LinkedHashSet}._@param array the {@code String} array (potentially empty)_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}__		Set<String> set = new LinkedHashSet<>(Arrays.asList(array))__		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,p,as,of,4,2,it,preserves,the,original,order,as,it,uses,a,link,linked,hash,set,param,array,the,code,string,array,potentially,empty,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,linked,hash,set,arrays,as,list,array,return,to,string,array,set
StringUtils -> public static String[] removeDuplicateStrings(String[] array);1550238935;Remove duplicate strings from the given array._<p>As of 4.2, it preserves the original order, as it uses a {@link LinkedHashSet}._@param array the {@code String} array (potentially empty)_@return an array without duplicates, in natural sort order;public static String[] removeDuplicateStrings(String[] array) {_		if (ObjectUtils.isEmpty(array)) {_			return array__		}__		Set<String> set = new LinkedHashSet<>(Arrays.asList(array))__		return toStringArray(set)__	};remove,duplicate,strings,from,the,given,array,p,as,of,4,2,it,preserves,the,original,order,as,it,uses,a,link,linked,hash,set,param,array,the,code,string,array,potentially,empty,return,an,array,without,duplicates,in,natural,sort,order;public,static,string,remove,duplicate,strings,string,array,if,object,utils,is,empty,array,return,array,set,string,set,new,linked,hash,set,arrays,as,list,array,return,to,string,array,set
StringUtils -> public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix);1496837955;Test if the given {@code String} ends with the specified suffix,_ignoring upper/lower case._@param str the {@code String} to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix) {_		if (str == null || suffix == null) {_			return false__		}_		if (str.endsWith(suffix)) {_			return true__		}_		if (str.length() < suffix.length()) {_			return false__		}__		String lcStr = str.substring(str.length() - suffix.length()).toLowerCase()__		String lcSuffix = suffix.toLowerCase()__		return lcStr.equals(lcSuffix)__	};test,if,the,given,code,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,nullable,string,str,nullable,string,suffix,if,str,null,suffix,null,return,false,if,str,ends,with,suffix,return,true,if,str,length,suffix,length,return,false,string,lc,str,str,substring,str,length,suffix,length,to,lower,case,string,lc,suffix,suffix,to,lower,case,return,lc,str,equals,lc,suffix
StringUtils -> public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix);1499270197;Test if the given {@code String} ends with the specified suffix,_ignoring upper/lower case._@param str the {@code String} to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix) {_		if (str == null || suffix == null) {_			return false__		}_		if (str.endsWith(suffix)) {_			return true__		}_		if (str.length() < suffix.length()) {_			return false__		}__		String lcStr = str.substring(str.length() - suffix.length()).toLowerCase()__		String lcSuffix = suffix.toLowerCase()__		return lcStr.equals(lcSuffix)__	};test,if,the,given,code,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,nullable,string,str,nullable,string,suffix,if,str,null,suffix,null,return,false,if,str,ends,with,suffix,return,true,if,str,length,suffix,length,return,false,string,lc,str,str,substring,str,length,suffix,length,to,lower,case,string,lc,suffix,suffix,to,lower,case,return,lc,str,equals,lc,suffix
StringUtils -> public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix);1508667152;Test if the given {@code String} ends with the specified suffix,_ignoring upper/lower case._@param str the {@code String} to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix) {_		if (str == null || suffix == null) {_			return false__		}_		if (str.endsWith(suffix)) {_			return true__		}_		if (str.length() < suffix.length()) {_			return false__		}__		String lcStr = str.substring(str.length() - suffix.length()).toLowerCase()__		String lcSuffix = suffix.toLowerCase()__		return lcStr.equals(lcSuffix)__	};test,if,the,given,code,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,nullable,string,str,nullable,string,suffix,if,str,null,suffix,null,return,false,if,str,ends,with,suffix,return,true,if,str,length,suffix,length,return,false,string,lc,str,str,substring,str,length,suffix,length,to,lower,case,string,lc,suffix,suffix,to,lower,case,return,lc,str,equals,lc,suffix
StringUtils -> public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix);1508675477;Test if the given {@code String} ends with the specified suffix,_ignoring upper/lower case._@param str the {@code String} to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix) {_		return (str != null && suffix != null && str.length() >= suffix.length() &&_				str.regionMatches(true, str.length() - suffix.length(), suffix, 0, suffix.length()))__	};test,if,the,given,code,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,nullable,string,str,nullable,string,suffix,return,str,null,suffix,null,str,length,suffix,length,str,region,matches,true,str,length,suffix,length,suffix,0,suffix,length
StringUtils -> public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix);1508843807;Test if the given {@code String} ends with the specified suffix,_ignoring upper/lower case._@param str the {@code String} to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix) {_		return (str != null && suffix != null && str.length() >= suffix.length() &&_				str.regionMatches(true, str.length() - suffix.length(), suffix, 0, suffix.length()))__	};test,if,the,given,code,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,nullable,string,str,nullable,string,suffix,return,str,null,suffix,null,str,length,suffix,length,str,region,matches,true,str,length,suffix,length,suffix,0,suffix,length
StringUtils -> public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix);1516903831;Test if the given {@code String} ends with the specified suffix,_ignoring upper/lower case._@param str the {@code String} to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix) {_		return (str != null && suffix != null && str.length() >= suffix.length() &&_				str.regionMatches(true, str.length() - suffix.length(), suffix, 0, suffix.length()))__	};test,if,the,given,code,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,nullable,string,str,nullable,string,suffix,return,str,null,suffix,null,str,length,suffix,length,str,region,matches,true,str,length,suffix,length,suffix,0,suffix,length
StringUtils -> public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix);1519295386;Test if the given {@code String} ends with the specified suffix,_ignoring upper/lower case._@param str the {@code String} to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix) {_		return (str != null && suffix != null && str.length() >= suffix.length() &&_				str.regionMatches(true, str.length() - suffix.length(), suffix, 0, suffix.length()))__	};test,if,the,given,code,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,nullable,string,str,nullable,string,suffix,return,str,null,suffix,null,str,length,suffix,length,str,region,matches,true,str,length,suffix,length,suffix,0,suffix,length
StringUtils -> public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix);1519308837;Test if the given {@code String} ends with the specified suffix,_ignoring upper/lower case._@param str the {@code String} to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix) {_		return (str != null && suffix != null && str.length() >= suffix.length() &&_				str.regionMatches(true, str.length() - suffix.length(), suffix, 0, suffix.length()))__	};test,if,the,given,code,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,nullable,string,str,nullable,string,suffix,return,str,null,suffix,null,str,length,suffix,length,str,region,matches,true,str,length,suffix,length,suffix,0,suffix,length
StringUtils -> public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix);1519588127;Test if the given {@code String} ends with the specified suffix,_ignoring upper/lower case._@param str the {@code String} to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix) {_		return (str != null && suffix != null && str.length() >= suffix.length() &&_				str.regionMatches(true, str.length() - suffix.length(), suffix, 0, suffix.length()))__	};test,if,the,given,code,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,nullable,string,str,nullable,string,suffix,return,str,null,suffix,null,str,length,suffix,length,str,region,matches,true,str,length,suffix,length,suffix,0,suffix,length
StringUtils -> public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix);1522332352;Test if the given {@code String} ends with the specified suffix,_ignoring upper/lower case._@param str the {@code String} to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix) {_		return (str != null && suffix != null && str.length() >= suffix.length() &&_				str.regionMatches(true, str.length() - suffix.length(), suffix, 0, suffix.length()))__	};test,if,the,given,code,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,nullable,string,str,nullable,string,suffix,return,str,null,suffix,null,str,length,suffix,length,str,region,matches,true,str,length,suffix,length,suffix,0,suffix,length
StringUtils -> public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix);1525166194;Test if the given {@code String} ends with the specified suffix,_ignoring upper/lower case._@param str the {@code String} to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix) {_		return (str != null && suffix != null && str.length() >= suffix.length() &&_				str.regionMatches(true, str.length() - suffix.length(), suffix, 0, suffix.length()))__	};test,if,the,given,code,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,nullable,string,str,nullable,string,suffix,return,str,null,suffix,null,str,length,suffix,length,str,region,matches,true,str,length,suffix,length,suffix,0,suffix,length
StringUtils -> public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix);1530188116;Test if the given {@code String} ends with the specified suffix,_ignoring upper/lower case._@param str the {@code String} to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix) {_		return (str != null && suffix != null && str.length() >= suffix.length() &&_				str.regionMatches(true, str.length() - suffix.length(), suffix, 0, suffix.length()))__	};test,if,the,given,code,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,nullable,string,str,nullable,string,suffix,return,str,null,suffix,null,str,length,suffix,length,str,region,matches,true,str,length,suffix,length,suffix,0,suffix,length
StringUtils -> public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix);1531843079;Test if the given {@code String} ends with the specified suffix,_ignoring upper/lower case._@param str the {@code String} to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix) {_		return (str != null && suffix != null && str.length() >= suffix.length() &&_				str.regionMatches(true, str.length() - suffix.length(), suffix, 0, suffix.length()))__	};test,if,the,given,code,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,nullable,string,str,nullable,string,suffix,return,str,null,suffix,null,str,length,suffix,length,str,region,matches,true,str,length,suffix,length,suffix,0,suffix,length
StringUtils -> public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix);1531905026;Test if the given {@code String} ends with the specified suffix,_ignoring upper/lower case._@param str the {@code String} to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix) {_		return (str != null && suffix != null && str.length() >= suffix.length() &&_				str.regionMatches(true, str.length() - suffix.length(), suffix, 0, suffix.length()))__	};test,if,the,given,code,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,nullable,string,str,nullable,string,suffix,return,str,null,suffix,null,str,length,suffix,length,str,region,matches,true,str,length,suffix,length,suffix,0,suffix,length
StringUtils -> public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix);1533557519;Test if the given {@code String} ends with the specified suffix,_ignoring upper/lower case._@param str the {@code String} to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix) {_		return (str != null && suffix != null && str.length() >= suffix.length() &&_				str.regionMatches(true, str.length() - suffix.length(), suffix, 0, suffix.length()))__	};test,if,the,given,code,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,nullable,string,str,nullable,string,suffix,return,str,null,suffix,null,str,length,suffix,length,str,region,matches,true,str,length,suffix,length,suffix,0,suffix,length
StringUtils -> public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix);1533602820;Test if the given {@code String} ends with the specified suffix,_ignoring upper/lower case._@param str the {@code String} to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix) {_		return (str != null && suffix != null && str.length() >= suffix.length() &&_				str.regionMatches(true, str.length() - suffix.length(), suffix, 0, suffix.length()))__	};test,if,the,given,code,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,nullable,string,str,nullable,string,suffix,return,str,null,suffix,null,str,length,suffix,length,str,region,matches,true,str,length,suffix,length,suffix,0,suffix,length
StringUtils -> public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix);1535316501;Test if the given {@code String} ends with the specified suffix,_ignoring upper/lower case._@param str the {@code String} to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix) {_		return (str != null && suffix != null && str.length() >= suffix.length() &&_				str.regionMatches(true, str.length() - suffix.length(), suffix, 0, suffix.length()))__	};test,if,the,given,code,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,nullable,string,str,nullable,string,suffix,return,str,null,suffix,null,str,length,suffix,length,str,region,matches,true,str,length,suffix,length,suffix,0,suffix,length
StringUtils -> public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix);1550237113;Test if the given {@code String} ends with the specified suffix,_ignoring upper/lower case._@param str the {@code String} to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix) {_		return (str != null && suffix != null && str.length() >= suffix.length() &&_				str.regionMatches(true, str.length() - suffix.length(), suffix, 0, suffix.length()))__	};test,if,the,given,code,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,nullable,string,str,nullable,string,suffix,return,str,null,suffix,null,str,length,suffix,length,str,region,matches,true,str,length,suffix,length,suffix,0,suffix,length
StringUtils -> public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix);1550238935;Test if the given {@code String} ends with the specified suffix,_ignoring upper/lower case._@param str the {@code String} to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix) {_		return (str != null && suffix != null && str.length() >= suffix.length() &&_				str.regionMatches(true, str.length() - suffix.length(), suffix, 0, suffix.length()))__	};test,if,the,given,code,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,nullable,string,str,nullable,string,suffix,return,str,null,suffix,null,str,length,suffix,length,str,region,matches,true,str,length,suffix,length,suffix,0,suffix,length
StringUtils -> public static boolean containsWhitespace(CharSequence str);1328020251;Check whether the given CharSequence contains any whitespace characters._@param str the CharSequence to check (may be <code>null</code>)_@return <code>true</code> if the CharSequence is not empty and_contains at least 1 whitespace character_@see java.lang.Character#isWhitespace;public static boolean containsWhitespace(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,char,sequence,contains,any,whitespace,characters,param,str,the,char,sequence,to,check,may,be,code,null,code,return,code,true,code,if,the,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,java,lang,character,is,whitespace;public,static,boolean,contains,whitespace,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(CharSequence str);1337236962;Check whether the given CharSequence contains any whitespace characters._@param str the CharSequence to check (may be <code>null</code>)_@return <code>true</code> if the CharSequence is not empty and_contains at least 1 whitespace character_@see java.lang.Character#isWhitespace;public static boolean containsWhitespace(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,char,sequence,contains,any,whitespace,characters,param,str,the,char,sequence,to,check,may,be,code,null,code,return,code,true,code,if,the,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,java,lang,character,is,whitespace;public,static,boolean,contains,whitespace,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(CharSequence str);1356735495;Check whether the given CharSequence contains any whitespace characters._@param str the CharSequence to check (may be {@code null})_@return {@code true} if the CharSequence is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,char,sequence,contains,any,whitespace,characters,param,str,the,char,sequence,to,check,may,be,code,null,return,code,true,if,the,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(CharSequence str);1367955086;Check whether the given CharSequence contains any whitespace characters._@param str the CharSequence to check (may be {@code null})_@return {@code true} if the CharSequence is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,char,sequence,contains,any,whitespace,characters,param,str,the,char,sequence,to,check,may,be,code,null,return,code,true,if,the,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(CharSequence str);1380921248;Check whether the given CharSequence contains any whitespace characters._@param str the CharSequence to check (may be {@code null})_@return {@code true} if the CharSequence is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,char,sequence,contains,any,whitespace,characters,param,str,the,char,sequence,to,check,may,be,code,null,return,code,true,if,the,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(CharSequence str);1382750743;Check whether the given CharSequence contains any whitespace characters._@param str the CharSequence to check (may be {@code null})_@return {@code true} if the CharSequence is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,char,sequence,contains,any,whitespace,characters,param,str,the,char,sequence,to,check,may,be,code,null,return,code,true,if,the,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(CharSequence str);1385423968;Check whether the given CharSequence contains any whitespace characters._@param str the CharSequence to check (may be {@code null})_@return {@code true} if the CharSequence is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,char,sequence,contains,any,whitespace,characters,param,str,the,char,sequence,to,check,may,be,code,null,return,code,true,if,the,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(CharSequence str);1400189212;Check whether the given CharSequence contains any whitespace characters._@param str the CharSequence to check (may be {@code null})_@return {@code true} if the CharSequence is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,char,sequence,contains,any,whitespace,characters,param,str,the,char,sequence,to,check,may,be,code,null,return,code,true,if,the,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(CharSequence str);1400531359;Check whether the given CharSequence contains any whitespace characters._@param str the CharSequence to check (may be {@code null})_@return {@code true} if the CharSequence is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,char,sequence,contains,any,whitespace,characters,param,str,the,char,sequence,to,check,may,be,code,null,return,code,true,if,the,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(CharSequence str);1402676350;Check whether the given CharSequence contains any whitespace characters._@param str the CharSequence to check (may be {@code null})_@return {@code true} if the CharSequence is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,char,sequence,contains,any,whitespace,characters,param,str,the,char,sequence,to,check,may,be,code,null,return,code,true,if,the,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(CharSequence str);1426267150;Check whether the given CharSequence contains any whitespace characters._@param str the CharSequence to check (may be {@code null})_@return {@code true} if the CharSequence is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,char,sequence,contains,any,whitespace,characters,param,str,the,char,sequence,to,check,may,be,code,null,return,code,true,if,the,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(CharSequence str);1429034538;Check whether the given CharSequence contains any whitespace characters._@param str the CharSequence to check (may be {@code null})_@return {@code true} if the CharSequence is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,char,sequence,contains,any,whitespace,characters,param,str,the,char,sequence,to,check,may,be,code,null,return,code,true,if,the,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(CharSequence str);1429034756;Check whether the given {@code CharSequence} contains any whitespace characters._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,any,whitespace,characters,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(CharSequence str);1431006895;Check whether the given {@code CharSequence} contains any whitespace characters._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,any,whitespace,characters,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(CharSequence str);1431007368;Check whether the given {@code CharSequence} contains any whitespace characters._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,any,whitespace,characters,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(CharSequence str);1449489126;Check whether the given {@code CharSequence} contains any whitespace characters._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,any,whitespace,characters,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(CharSequence str);1467730834;Check whether the given {@code CharSequence} contains any whitespace characters._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,any,whitespace,characters,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(CharSequence str);1472128018;Check whether the given {@code CharSequence} contains any whitespace characters._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,any,whitespace,characters,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(CharSequence str);1472202842;Check whether the given {@code CharSequence} contains any whitespace characters._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,any,whitespace,characters,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(CharSequence str);1473942665;Check whether the given {@code CharSequence} contains any whitespace characters._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,any,whitespace,characters,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(CharSequence str);1484248946;Check whether the given {@code CharSequence} contains any whitespace characters._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,any,whitespace,characters,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(CharSequence str);1484260238;Check whether the given {@code CharSequence} contains any whitespace characters._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,any,whitespace,characters,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(CharSequence str);1484694546;Check whether the given {@code CharSequence} contains any whitespace characters._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,any,whitespace,characters,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(CharSequence str);1487760984;Check whether the given {@code CharSequence} contains any whitespace characters._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,any,whitespace,characters,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(CharSequence str);1487778834;Check whether the given {@code CharSequence} contains any whitespace characters._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,any,whitespace,characters,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(CharSequence str);1491898314;Check whether the given {@code CharSequence} contains any whitespace characters._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}__		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,any,whitespace,characters,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(CharSequence str);1491903650;Check whether the given {@code CharSequence} contains any whitespace characters._@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not empty and_contains at least 1 whitespace character_@see Character#isWhitespace;public static boolean containsWhitespace(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}__		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,any,whitespace,characters,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,empty,and,contains,at,least,1,whitespace,character,see,character,is,whitespace;public,static,boolean,contains,whitespace,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static String[] delimitedListToStringArray( 			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete);1496837955;Take a {@code String} that is a delimited list and convert it into_a {@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete_ useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a {@code String}_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(_			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete) {__		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}__		List<String> result = new ArrayList<>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,code,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,nullable,string,str,nullable,string,delimiter,nullable,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray( 			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete);1499270197;Take a {@code String} that is a delimited list and convert it into_a {@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete_ useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a {@code String}_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(_			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete) {__		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}__		List<String> result = new ArrayList<>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,code,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,nullable,string,str,nullable,string,delimiter,nullable,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray( 			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete);1508667152;Take a {@code String} that is a delimited list and convert it into_a {@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete_ useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a {@code String}_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(_			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete) {__		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}__		List<String> result = new ArrayList<>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,code,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,nullable,string,str,nullable,string,delimiter,nullable,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray( 			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete);1508675477;Take a {@code String} that is a delimited list and convert it into_a {@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete_ useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a {@code String}_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(_			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete) {__		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}__		List<String> result = new ArrayList<>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,code,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,nullable,string,str,nullable,string,delimiter,nullable,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray( 			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete);1508843807;Take a {@code String} that is a delimited list and convert it into_a {@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete_ useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a {@code String}_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(_			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete) {__		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}__		List<String> result = new ArrayList<>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,code,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,nullable,string,str,nullable,string,delimiter,nullable,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray( 			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete);1516903831;Take a {@code String} that is a delimited list and convert it into_a {@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete_ useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a {@code String}_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(_			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete) {__		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}__		List<String> result = new ArrayList<>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,code,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,nullable,string,str,nullable,string,delimiter,nullable,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray( 			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete);1519295386;Take a {@code String} that is a delimited list and convert it into_a {@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete_ useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a {@code String}_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(_			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete) {__		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}__		List<String> result = new ArrayList<>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,code,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,nullable,string,str,nullable,string,delimiter,nullable,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray( 			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete);1519308837;Take a {@code String} that is a delimited list and convert it into_a {@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete_ useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a {@code String}_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(_			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete) {__		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}__		List<String> result = new ArrayList<>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,code,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,nullable,string,str,nullable,string,delimiter,nullable,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray( 			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete);1519588127;Take a {@code String} that is a delimited list and convert it into_a {@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete_ useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a {@code String}_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(_			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete) {__		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}__		List<String> result = new ArrayList<>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,code,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,nullable,string,str,nullable,string,delimiter,nullable,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray( 			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete);1522332352;Take a {@code String} that is a delimited list and convert it into_a {@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete_ useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a {@code String}_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(_			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete) {__		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}__		List<String> result = new ArrayList<>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,code,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,nullable,string,str,nullable,string,delimiter,nullable,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray( 			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete);1525166194;Take a {@code String} that is a delimited list and convert it into_a {@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete_ useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a {@code String}_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(_			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete) {__		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}__		List<String> result = new ArrayList<>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,code,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,nullable,string,str,nullable,string,delimiter,nullable,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray( 			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete);1530188116;Take a {@code String} that is a delimited list and convert it into_a {@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete_ useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a {@code String}_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(_			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete) {__		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}__		List<String> result = new ArrayList<>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,code,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,nullable,string,str,nullable,string,delimiter,nullable,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray( 			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete);1531843079;Take a {@code String} that is a delimited list and convert it into_a {@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete_ useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a {@code String}_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(_			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete) {__		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}__		List<String> result = new ArrayList<>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,code,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,nullable,string,str,nullable,string,delimiter,nullable,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray( 			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete);1531905026;Take a {@code String} that is a delimited list and convert it into_a {@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete_ useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a {@code String}_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(_			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete) {__		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}__		List<String> result = new ArrayList<>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,code,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,nullable,string,str,nullable,string,delimiter,nullable,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray( 			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete);1533557519;Take a {@code String} that is a delimited list and convert it into_a {@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String} (potentially {@code null} or empty)_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete_ useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a {@code String}_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(_			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete) {__		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}__		List<String> result = new ArrayList<>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,potentially,code,null,or,empty,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,code,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,nullable,string,str,nullable,string,delimiter,nullable,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray( 			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete);1533602820;Take a {@code String} that is a delimited list and convert it into_a {@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String} (potentially {@code null} or empty)_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete_ useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a {@code String}_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(_			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete) {__		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}__		List<String> result = new ArrayList<>()__		if ("".equals(delimiter)) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,potentially,code,null,or,empty,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,code,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,nullable,string,str,nullable,string,delimiter,nullable,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,if,equals,delimiter,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray( 			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete);1535316501;Take a {@code String} that is a delimited list and convert it into_a {@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String} (potentially {@code null} or empty)_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete_ useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a {@code String}_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(_			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete) {__		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}__		List<String> result = new ArrayList<>()__		if (delimiter.isEmpty()) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,potentially,code,null,or,empty,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,code,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,nullable,string,str,nullable,string,delimiter,nullable,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,if,delimiter,is,empty,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray( 			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete);1550237113;Take a {@code String} that is a delimited list and convert it into_a {@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String} (potentially {@code null} or empty)_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete_ useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a {@code String}_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(_			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete) {__		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}__		List<String> result = new ArrayList<>()__		if (delimiter.isEmpty()) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,potentially,code,null,or,empty,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,code,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,nullable,string,str,nullable,string,delimiter,nullable,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,if,delimiter,is,empty,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> public static String[] delimitedListToStringArray( 			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete);1550238935;Take a {@code String} that is a delimited list and convert it into_a {@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String} (potentially {@code null} or empty)_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@param charsToDelete a set of characters to delete_ useful for deleting unwanted_line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a {@code String}_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(_			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete) {__		if (str == null) {_			return new String[0]__		}_		if (delimiter == null) {_			return new String[] {str}__		}__		List<String> result = new ArrayList<>()__		if (delimiter.isEmpty()) {_			for (int i = 0_ i < str.length()_ i++) {_				result.add(deleteAny(str.substring(i, i + 1), charsToDelete))__			}_		}_		else {_			int pos = 0__			int delPos__			while ((delPos = str.indexOf(delimiter, pos)) != -1) {_				result.add(deleteAny(str.substring(pos, delPos), charsToDelete))__				pos = delPos + delimiter.length()__			}_			if (str.length() > 0 && pos <= str.length()) {_				_				result.add(deleteAny(str.substring(pos), charsToDelete))__			}_		}_		return toStringArray(result)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,potentially,code,null,or,empty,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,param,chars,to,delete,a,set,of,characters,to,delete,useful,for,deleting,unwanted,line,breaks,e,g,r,n,f,will,delete,all,new,lines,and,line,feeds,in,a,code,string,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,nullable,string,str,nullable,string,delimiter,nullable,string,chars,to,delete,if,str,null,return,new,string,0,if,delimiter,null,return,new,string,str,list,string,result,new,array,list,if,delimiter,is,empty,for,int,i,0,i,str,length,i,result,add,delete,any,str,substring,i,i,1,chars,to,delete,else,int,pos,0,int,del,pos,while,del,pos,str,index,of,delimiter,pos,1,result,add,delete,any,str,substring,pos,del,pos,chars,to,delete,pos,del,pos,delimiter,length,if,str,length,0,pos,str,length,result,add,delete,any,str,substring,pos,chars,to,delete,return,to,string,array,result
StringUtils -> @Nullable 	public static Object quoteIfString(@Nullable Object obj);1496837955;Turn the given Object into a {@code String} with single quotes_if it is a {@code String}_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or the input object as-is if not a {@code String};@Nullable_	public static Object quoteIfString(@Nullable Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,code,string,with,single,quotes,if,it,is,a,code,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,the,input,object,as,is,if,not,a,code,string;nullable,public,static,object,quote,if,string,nullable,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> @Nullable 	public static Object quoteIfString(@Nullable Object obj);1499270197;Turn the given Object into a {@code String} with single quotes_if it is a {@code String}_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or the input object as-is if not a {@code String};@Nullable_	public static Object quoteIfString(@Nullable Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,code,string,with,single,quotes,if,it,is,a,code,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,the,input,object,as,is,if,not,a,code,string;nullable,public,static,object,quote,if,string,nullable,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> @Nullable 	public static Object quoteIfString(@Nullable Object obj);1508667152;Turn the given Object into a {@code String} with single quotes_if it is a {@code String}_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or the input object as-is if not a {@code String};@Nullable_	public static Object quoteIfString(@Nullable Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,code,string,with,single,quotes,if,it,is,a,code,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,the,input,object,as,is,if,not,a,code,string;nullable,public,static,object,quote,if,string,nullable,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> @Nullable 	public static Object quoteIfString(@Nullable Object obj);1508675477;Turn the given Object into a {@code String} with single quotes_if it is a {@code String}_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or the input object as-is if not a {@code String};@Nullable_	public static Object quoteIfString(@Nullable Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,code,string,with,single,quotes,if,it,is,a,code,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,the,input,object,as,is,if,not,a,code,string;nullable,public,static,object,quote,if,string,nullable,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> @Nullable 	public static Object quoteIfString(@Nullable Object obj);1508843807;Turn the given Object into a {@code String} with single quotes_if it is a {@code String}_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or the input object as-is if not a {@code String};@Nullable_	public static Object quoteIfString(@Nullable Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,code,string,with,single,quotes,if,it,is,a,code,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,the,input,object,as,is,if,not,a,code,string;nullable,public,static,object,quote,if,string,nullable,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> @Nullable 	public static Object quoteIfString(@Nullable Object obj);1516903831;Turn the given Object into a {@code String} with single quotes_if it is a {@code String}_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or the input object as-is if not a {@code String};@Nullable_	public static Object quoteIfString(@Nullable Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,code,string,with,single,quotes,if,it,is,a,code,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,the,input,object,as,is,if,not,a,code,string;nullable,public,static,object,quote,if,string,nullable,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> @Nullable 	public static Object quoteIfString(@Nullable Object obj);1519295386;Turn the given Object into a {@code String} with single quotes_if it is a {@code String}_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or the input object as-is if not a {@code String};@Nullable_	public static Object quoteIfString(@Nullable Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,code,string,with,single,quotes,if,it,is,a,code,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,the,input,object,as,is,if,not,a,code,string;nullable,public,static,object,quote,if,string,nullable,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> @Nullable 	public static Object quoteIfString(@Nullable Object obj);1519308837;Turn the given Object into a {@code String} with single quotes_if it is a {@code String}_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or the input object as-is if not a {@code String};@Nullable_	public static Object quoteIfString(@Nullable Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,code,string,with,single,quotes,if,it,is,a,code,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,the,input,object,as,is,if,not,a,code,string;nullable,public,static,object,quote,if,string,nullable,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> @Nullable 	public static Object quoteIfString(@Nullable Object obj);1519588127;Turn the given Object into a {@code String} with single quotes_if it is a {@code String}_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or the input object as-is if not a {@code String};@Nullable_	public static Object quoteIfString(@Nullable Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,code,string,with,single,quotes,if,it,is,a,code,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,the,input,object,as,is,if,not,a,code,string;nullable,public,static,object,quote,if,string,nullable,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> @Nullable 	public static Object quoteIfString(@Nullable Object obj);1522332352;Turn the given Object into a {@code String} with single quotes_if it is a {@code String}_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or the input object as-is if not a {@code String};@Nullable_	public static Object quoteIfString(@Nullable Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,code,string,with,single,quotes,if,it,is,a,code,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,the,input,object,as,is,if,not,a,code,string;nullable,public,static,object,quote,if,string,nullable,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> @Nullable 	public static Object quoteIfString(@Nullable Object obj);1525166194;Turn the given Object into a {@code String} with single quotes_if it is a {@code String}_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or the input object as-is if not a {@code String};@Nullable_	public static Object quoteIfString(@Nullable Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,code,string,with,single,quotes,if,it,is,a,code,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,the,input,object,as,is,if,not,a,code,string;nullable,public,static,object,quote,if,string,nullable,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> @Nullable 	public static Object quoteIfString(@Nullable Object obj);1530188116;Turn the given Object into a {@code String} with single quotes_if it is a {@code String}_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or the input object as-is if not a {@code String};@Nullable_	public static Object quoteIfString(@Nullable Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,code,string,with,single,quotes,if,it,is,a,code,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,the,input,object,as,is,if,not,a,code,string;nullable,public,static,object,quote,if,string,nullable,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> @Nullable 	public static Object quoteIfString(@Nullable Object obj);1531843079;Turn the given Object into a {@code String} with single quotes_if it is a {@code String}_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or the input object as-is if not a {@code String};@Nullable_	public static Object quoteIfString(@Nullable Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,code,string,with,single,quotes,if,it,is,a,code,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,the,input,object,as,is,if,not,a,code,string;nullable,public,static,object,quote,if,string,nullable,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> @Nullable 	public static Object quoteIfString(@Nullable Object obj);1531905026;Turn the given Object into a {@code String} with single quotes_if it is a {@code String}_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or the input object as-is if not a {@code String};@Nullable_	public static Object quoteIfString(@Nullable Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,code,string,with,single,quotes,if,it,is,a,code,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,the,input,object,as,is,if,not,a,code,string;nullable,public,static,object,quote,if,string,nullable,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> @Nullable 	public static Object quoteIfString(@Nullable Object obj);1533557519;Turn the given Object into a {@code String} with single quotes_if it is a {@code String}_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or the input object as-is if not a {@code String};@Nullable_	public static Object quoteIfString(@Nullable Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,code,string,with,single,quotes,if,it,is,a,code,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,the,input,object,as,is,if,not,a,code,string;nullable,public,static,object,quote,if,string,nullable,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> @Nullable 	public static Object quoteIfString(@Nullable Object obj);1533602820;Turn the given Object into a {@code String} with single quotes_if it is a {@code String}_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or the input object as-is if not a {@code String};@Nullable_	public static Object quoteIfString(@Nullable Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,code,string,with,single,quotes,if,it,is,a,code,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,the,input,object,as,is,if,not,a,code,string;nullable,public,static,object,quote,if,string,nullable,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> @Nullable 	public static Object quoteIfString(@Nullable Object obj);1535316501;Turn the given Object into a {@code String} with single quotes_if it is a {@code String}_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or the input object as-is if not a {@code String};@Nullable_	public static Object quoteIfString(@Nullable Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,code,string,with,single,quotes,if,it,is,a,code,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,the,input,object,as,is,if,not,a,code,string;nullable,public,static,object,quote,if,string,nullable,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> @Nullable 	public static Object quoteIfString(@Nullable Object obj);1550237113;Turn the given Object into a {@code String} with single quotes_if it is a {@code String}_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or the input object as-is if not a {@code String};@Nullable_	public static Object quoteIfString(@Nullable Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,code,string,with,single,quotes,if,it,is,a,code,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,the,input,object,as,is,if,not,a,code,string;nullable,public,static,object,quote,if,string,nullable,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> @Nullable 	public static Object quoteIfString(@Nullable Object obj);1550238935;Turn the given Object into a {@code String} with single quotes_if it is a {@code String}_ keeping the Object as-is else._@param obj the input Object (e.g. "myString")_@return the quoted {@code String} (e.g. "'myString'"),_or the input object as-is if not a {@code String};@Nullable_	public static Object quoteIfString(@Nullable Object obj) {_		return (obj instanceof String ? quote((String) obj) : obj)__	};turn,the,given,object,into,a,code,string,with,single,quotes,if,it,is,a,code,string,keeping,the,object,as,is,else,param,obj,the,input,object,e,g,my,string,return,the,quoted,code,string,e,g,my,string,or,the,input,object,as,is,if,not,a,code,string;nullable,public,static,object,quote,if,string,nullable,object,obj,return,obj,instanceof,string,quote,string,obj,obj
StringUtils -> public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, String charsToDelete);1328020251;Take an array Strings and split each element based on the given delimiter._A <code>Properties</code> instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_<code>Properties</code> instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or <code>null</code> if no removal should occur_@return a <code>Properties</code> instance representing the array contents,_or <code>null</code> if the array to process was <code>null</code> or empty;public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}_		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,code,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,code,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,code,if,no,removal,should,occur,return,a,code,properties,code,instance,representing,the,array,contents,or,code,null,code,if,the,array,to,process,was,code,null,code,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, String charsToDelete);1337236962;Take an array Strings and split each element based on the given delimiter._A <code>Properties</code> instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_<code>Properties</code> instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or <code>null</code> if no removal should occur_@return a <code>Properties</code> instance representing the array contents,_or <code>null</code> if the array to process was <code>null</code> or empty;public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}_		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,code,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,code,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,code,if,no,removal,should,occur,return,a,code,properties,code,instance,representing,the,array,contents,or,code,null,code,if,the,array,to,process,was,code,null,code,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, String charsToDelete);1356735495;Take an array Strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}_		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, String charsToDelete);1367955086;Take an array Strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}_		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, String charsToDelete);1380921248;Take an array Strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}_		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, String charsToDelete);1382750743;Take an array Strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}_		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, String charsToDelete);1385423968;Take an array Strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}_		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, String charsToDelete);1400189212;Take an array Strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}_		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, String charsToDelete);1400531359;Take an array Strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}_		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, String charsToDelete);1402676350;Take an array Strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}_		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, String charsToDelete);1426267150;Take an array Strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}_		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, String charsToDelete);1429034538;Take an array Strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}_		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, String charsToDelete);1429034756;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}_		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, String charsToDelete);1431006895;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}_		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, String charsToDelete);1431007368;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}_		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, String charsToDelete);1449489126;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}_		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, String charsToDelete);1467730834;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}_		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, String charsToDelete);1472128018;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}_		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, String charsToDelete);1472202842;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}_		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, String charsToDelete);1473942665;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}_		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, String charsToDelete);1484248946;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}_		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, String charsToDelete);1484260238;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}_		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, String charsToDelete);1484694546;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}_		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, String charsToDelete);1487760984;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}_		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, String charsToDelete);1487778834;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}_		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, String charsToDelete);1491898314;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}__		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, String charsToDelete);1491903650;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}__		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> @Nullable 	public static String[] toStringArray(@Nullable Enumeration<String> enumeration);1495868221;Copy the given Enumeration into a {@code String} array._The Enumeration must contain {@code String} elements only._@param enumeration the Enumeration to copy_@return the {@code String} array ({@code null} if the passed-in_Enumeration was {@code null});@Nullable_	public static String[] toStringArray(@Nullable Enumeration<String> enumeration) {_		if (enumeration == null) {_			return null__		}__		List<String> list = Collections.list(enumeration)__		return list.toArray(new String[list.size()])__	};copy,the,given,enumeration,into,a,code,string,array,the,enumeration,must,contain,code,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,code,string,array,code,null,if,the,passed,in,enumeration,was,code,null;nullable,public,static,string,to,string,array,nullable,enumeration,string,enumeration,if,enumeration,null,return,null,list,string,list,collections,list,enumeration,return,list,to,array,new,string,list,size
StringUtils -> @Nullable 	public static String[] toStringArray(@Nullable Enumeration<String> enumeration);1496243689;Copy the given Enumeration into a {@code String} array._The Enumeration must contain {@code String} elements only._@param enumeration the Enumeration to copy_@return the {@code String} array ({@code null} if the passed-in_Enumeration was {@code null});@Nullable_	public static String[] toStringArray(@Nullable Enumeration<String> enumeration) {_		if (enumeration == null) {_			return null__		}__		List<String> list = Collections.list(enumeration)__		return list.toArray(new String[list.size()])__	};copy,the,given,enumeration,into,a,code,string,array,the,enumeration,must,contain,code,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,code,string,array,code,null,if,the,passed,in,enumeration,was,code,null;nullable,public,static,string,to,string,array,nullable,enumeration,string,enumeration,if,enumeration,null,return,null,list,string,list,collections,list,enumeration,return,list,to,array,new,string,list,size
StringUtils -> @Nullable 	public static String[] toStringArray(@Nullable Enumeration<String> enumeration);1496259743;Copy the given Enumeration into a {@code String} array._The Enumeration must contain {@code String} elements only._@param enumeration the Enumeration to copy_@return the {@code String} array ({@code null} if the passed-in_Enumeration was {@code null});@Nullable_	public static String[] toStringArray(@Nullable Enumeration<String> enumeration) {_		if (enumeration == null) {_			return null__		}__		List<String> list = Collections.list(enumeration)__		return list.toArray(new String[list.size()])__	};copy,the,given,enumeration,into,a,code,string,array,the,enumeration,must,contain,code,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,code,string,array,code,null,if,the,passed,in,enumeration,was,code,null;nullable,public,static,string,to,string,array,nullable,enumeration,string,enumeration,if,enumeration,null,return,null,list,string,list,collections,list,enumeration,return,list,to,array,new,string,list,size
StringUtils -> public static String getFilename(String path);1328020251;Extract the filename from the given path,_e.g. "mypath/myfile.txt" -> "myfile.txt"._@param path the file path (may be <code>null</code>)_@return the extracted filename, or <code>null</code> if none;public static String getFilename(String path) {_		if (path == null) {_			return null__		}_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,path,e,g,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,code,return,the,extracted,filename,or,code,null,code,if,none;public,static,string,get,filename,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> public static String getFilename(String path);1337236962;Extract the filename from the given path,_e.g. "mypath/myfile.txt" -> "myfile.txt"._@param path the file path (may be <code>null</code>)_@return the extracted filename, or <code>null</code> if none;public static String getFilename(String path) {_		if (path == null) {_			return null__		}_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,path,e,g,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,code,return,the,extracted,filename,or,code,null,code,if,none;public,static,string,get,filename,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> public static String getFilename(String path);1356735495;Extract the filename from the given path,_e.g. "mypath/myfile.txt" -> "myfile.txt"._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;public static String getFilename(String path) {_		if (path == null) {_			return null__		}_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,path,e,g,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;public,static,string,get,filename,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> public static String getFilename(String path);1367955086;Extract the filename from the given path,_e.g. "mypath/myfile.txt" -> "myfile.txt"._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;public static String getFilename(String path) {_		if (path == null) {_			return null__		}_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,path,e,g,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;public,static,string,get,filename,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> public static String getFilename(String path);1380921248;Extract the filename from the given path,_e.g. "mypath/myfile.txt" -> "myfile.txt"._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;public static String getFilename(String path) {_		if (path == null) {_			return null__		}_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,path,e,g,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;public,static,string,get,filename,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> public static String getFilename(String path);1382750743;Extract the filename from the given path,_e.g. "mypath/myfile.txt" -> "myfile.txt"._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;public static String getFilename(String path) {_		if (path == null) {_			return null__		}_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,path,e,g,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;public,static,string,get,filename,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> public static String getFilename(String path);1385423968;Extract the filename from the given path,_e.g. "mypath/myfile.txt" -> "myfile.txt"._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;public static String getFilename(String path) {_		if (path == null) {_			return null__		}_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,path,e,g,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;public,static,string,get,filename,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> public static String getFilename(String path);1400189212;Extract the filename from the given path,_e.g. "mypath/myfile.txt" -> "myfile.txt"._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;public static String getFilename(String path) {_		if (path == null) {_			return null__		}_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,path,e,g,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;public,static,string,get,filename,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> public static String getFilename(String path);1400531359;Extract the filename from the given path,_e.g. "mypath/myfile.txt" -> "myfile.txt"._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;public static String getFilename(String path) {_		if (path == null) {_			return null__		}_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,path,e,g,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;public,static,string,get,filename,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> public static String getFilename(String path);1402676350;Extract the filename from the given path,_e.g. "mypath/myfile.txt" -> "myfile.txt"._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;public static String getFilename(String path) {_		if (path == null) {_			return null__		}_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,path,e,g,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;public,static,string,get,filename,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> public static String getFilename(String path);1426267150;Extract the filename from the given path,_e.g. "mypath/myfile.txt" -> "myfile.txt"._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;public static String getFilename(String path) {_		if (path == null) {_			return null__		}_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,path,e,g,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;public,static,string,get,filename,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> public static String getFilename(String path);1429034538;Extract the filename from the given path,_e.g. "mypath/myfile.txt" -> "myfile.txt"._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;public static String getFilename(String path) {_		if (path == null) {_			return null__		}_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,path,e,g,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;public,static,string,get,filename,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> public static String getFilename(String path);1429034756;Extract the filename from the given path,_e.g. {@code "mypath/myfile.txt" -> "myfile.txt"}._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;public static String getFilename(String path) {_		if (path == null) {_			return null__		}_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,path,e,g,code,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;public,static,string,get,filename,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> public static String getFilename(String path);1431006895;Extract the filename from the given path,_e.g. {@code "mypath/myfile.txt" -> "myfile.txt"}._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;public static String getFilename(String path) {_		if (path == null) {_			return null__		}_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,path,e,g,code,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;public,static,string,get,filename,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> public static String getFilename(String path);1431007368;Extract the filename from the given path,_e.g. {@code "mypath/myfile.txt" -> "myfile.txt"}._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;public static String getFilename(String path) {_		if (path == null) {_			return null__		}_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,path,e,g,code,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;public,static,string,get,filename,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> public static String getFilename(String path);1449489126;Extract the filename from the given Java resource path,_e.g. {@code "mypath/myfile.txt" -> "myfile.txt"}._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;public static String getFilename(String path) {_		if (path == null) {_			return null__		}_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,java,resource,path,e,g,code,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;public,static,string,get,filename,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> public static String getFilename(String path);1467730834;Extract the filename from the given Java resource path,_e.g. {@code "mypath/myfile.txt" -> "myfile.txt"}._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;public static String getFilename(String path) {_		if (path == null) {_			return null__		}_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,java,resource,path,e,g,code,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;public,static,string,get,filename,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> public static String getFilename(String path);1472128018;Extract the filename from the given Java resource path,_e.g. {@code "mypath/myfile.txt" -> "myfile.txt"}._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;public static String getFilename(String path) {_		if (path == null) {_			return null__		}_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,java,resource,path,e,g,code,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;public,static,string,get,filename,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> public static String getFilename(String path);1472202842;Extract the filename from the given Java resource path,_e.g. {@code "mypath/myfile.txt" -> "myfile.txt"}._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;public static String getFilename(String path) {_		if (path == null) {_			return null__		}_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,java,resource,path,e,g,code,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;public,static,string,get,filename,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> public static String getFilename(String path);1473942665;Extract the filename from the given Java resource path,_e.g. {@code "mypath/myfile.txt" -> "myfile.txt"}._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;public static String getFilename(String path) {_		if (path == null) {_			return null__		}_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,java,resource,path,e,g,code,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;public,static,string,get,filename,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> public static String getFilename(String path);1484248946;Extract the filename from the given Java resource path,_e.g. {@code "mypath/myfile.txt" -> "myfile.txt"}._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;public static String getFilename(String path) {_		if (path == null) {_			return null__		}_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,java,resource,path,e,g,code,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;public,static,string,get,filename,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> public static String getFilename(String path);1484260238;Extract the filename from the given Java resource path,_e.g. {@code "mypath/myfile.txt" -> "myfile.txt"}._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;public static String getFilename(String path) {_		if (path == null) {_			return null__		}_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,java,resource,path,e,g,code,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;public,static,string,get,filename,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> public static String getFilename(String path);1484694546;Extract the filename from the given Java resource path,_e.g. {@code "mypath/myfile.txt" -> "myfile.txt"}._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;public static String getFilename(String path) {_		if (path == null) {_			return null__		}_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,java,resource,path,e,g,code,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;public,static,string,get,filename,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> public static String getFilename(String path);1487760984;Extract the filename from the given Java resource path,_e.g. {@code "mypath/myfile.txt" -> "myfile.txt"}._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;public static String getFilename(String path) {_		if (path == null) {_			return null__		}_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,java,resource,path,e,g,code,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;public,static,string,get,filename,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> public static String getFilename(String path);1487778834;Extract the filename from the given Java resource path,_e.g. {@code "mypath/myfile.txt" -> "myfile.txt"}._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;public static String getFilename(String path) {_		if (path == null) {_			return null__		}_		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,java,resource,path,e,g,code,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;public,static,string,get,filename,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> public static String getFilename(String path);1491898314;Extract the filename from the given Java resource path,_e.g. {@code "mypath/myfile.txt" -> "myfile.txt"}._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;public static String getFilename(String path) {_		if (path == null) {_			return null__		}__		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,java,resource,path,e,g,code,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;public,static,string,get,filename,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> public static String getFilename(String path);1491903650;Extract the filename from the given Java resource path,_e.g. {@code "mypath/myfile.txt" -> "myfile.txt"}._@param path the file path (may be {@code null})_@return the extracted filename, or {@code null} if none;public static String getFilename(String path) {_		if (path == null) {_			return null__		}__		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path)__	};extract,the,filename,from,the,given,java,resource,path,e,g,code,mypath,myfile,txt,myfile,txt,param,path,the,file,path,may,be,code,null,return,the,extracted,filename,or,code,null,if,none;public,static,string,get,filename,string,path,if,path,null,return,null,int,separator,index,path,last,index,of,return,separator,index,1,path,substring,separator,index,1,path
StringUtils -> @Nullable 	public static String uncapitalize(@Nullable String str);1495868221;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the {@code String} to uncapitalize, may be {@code null}_@return the uncapitalized {@code String}, or {@code null} if the supplied_string is {@code null};@Nullable_	public static String uncapitalize(@Nullable String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,code,string,to,uncapitalize,may,be,code,null,return,the,uncapitalized,code,string,or,code,null,if,the,supplied,string,is,code,null;nullable,public,static,string,uncapitalize,nullable,string,str,return,change,first,character,case,str,false
StringUtils -> @Nullable 	public static String uncapitalize(@Nullable String str);1496243689;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the {@code String} to uncapitalize, may be {@code null}_@return the uncapitalized {@code String}, or {@code null} if the supplied_string is {@code null};@Nullable_	public static String uncapitalize(@Nullable String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,code,string,to,uncapitalize,may,be,code,null,return,the,uncapitalized,code,string,or,code,null,if,the,supplied,string,is,code,null;nullable,public,static,string,uncapitalize,nullable,string,str,return,change,first,character,case,str,false
StringUtils -> @Nullable 	public static String uncapitalize(@Nullable String str);1496259743;Uncapitalize a {@code String}, changing the first letter to_lower case as per {@link Character#toLowerCase(char)}._No other letters are changed._@param str the {@code String} to uncapitalize, may be {@code null}_@return the uncapitalized {@code String}, or {@code null} if the supplied_string is {@code null};@Nullable_	public static String uncapitalize(@Nullable String str) {_		return changeFirstCharacterCase(str, false)__	};uncapitalize,a,code,string,changing,the,first,letter,to,lower,case,as,per,link,character,to,lower,case,char,no,other,letters,are,changed,param,str,the,code,string,to,uncapitalize,may,be,code,null,return,the,uncapitalized,code,string,or,code,null,if,the,supplied,string,is,code,null;nullable,public,static,string,uncapitalize,nullable,string,str,return,change,first,character,case,str,false
StringUtils -> public static String unqualify(String qualifiedName, char separator);1328020251;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1337236962;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1356735495;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1367955086;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1380921248;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1382750743;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1385423968;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1400189212;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1400531359;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1402676350;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1426267150;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1429034538;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1429034756;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1431006895;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1431007368;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1449489126;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1467730834;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1472128018;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1472202842;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1473942665;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1484248946;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1484260238;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1484694546;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1487760984;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1487778834;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1491898314;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1491903650;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1495868221;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1496243689;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1496259743;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1496837955;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1499270197;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1508667152;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1508675477;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1508843807;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1516903831;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1519295386;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1519308837;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1519588127;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1522332352;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1525166194;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1530188116;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1531843079;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1531905026;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1533557519;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1533602820;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1535316501;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1550237113;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String unqualify(String qualifiedName, char separator);1550238935;Unqualify a string qualified by a separator character. For example,_"this:name:is:qualified" returns "qualified" if using a ':' separator._@param qualifiedName the qualified name_@param separator the separator;public static String unqualify(String qualifiedName, char separator) {_		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1)__	};unqualify,a,string,qualified,by,a,separator,character,for,example,this,name,is,qualified,returns,qualified,if,using,a,separator,param,qualified,name,the,qualified,name,param,separator,the,separator;public,static,string,unqualify,string,qualified,name,char,separator,return,qualified,name,substring,qualified,name,last,index,of,separator,1
StringUtils -> public static String uriDecode(String source, Charset charset);1484694546;Decode the given encoded URI component value. Based on the following rules:_<ul>_<li>Alphanumeric characters {@code "a"} through {@code "z"}, {@code "A"} through {@code "Z"},_and {@code "0"} through {@code "9"} stay the same.</li>_<li>Special characters {@code "-"}, {@code "_"}, {@code "."}, and {@code "*"} stay the same.</li>_<li>A sequence "{@code %<i>xy</i>}" is interpreted as a hexadecimal representation of the character.</li>_</ul>_@param source the encoded String (may be {@code null})_@param charset the character set_@return the decoded value_@throws IllegalArgumentException when the given source contains invalid encoded sequences_@since 5.0_@see java.net.URLDecoder#decode(String, String);public static String uriDecode(String source, Charset charset) {_		if (source == null) {_			return null__		}_		int length = source.length()__		if (length == 0) {_			return source__		}_		Assert.notNull(charset, "Charset must not be null")___		ByteArrayOutputStream bos = new ByteArrayOutputStream(length)__		boolean changed = false__		for (int i = 0_ i < length_ i++) {_			int ch = source.charAt(i)__			if (ch == '%') {_				if (i + 2 < length) {_					char hex1 = source.charAt(i + 1)__					char hex2 = source.charAt(i + 2)__					int u = Character.digit(hex1, 16)__					int l = Character.digit(hex2, 16)__					if (u == -1 || l == -1) {_						throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__					}_					bos.write((char) ((u << 4) + l))__					i += 2__					changed = true__				}_				else {_					throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__				}_			}_			else {_				bos.write(ch)__			}_		}_		return (changed ? new String(bos.toByteArray(), charset) : source)__	};decode,the,given,encoded,uri,component,value,based,on,the,following,rules,ul,li,alphanumeric,characters,code,a,through,code,z,code,a,through,code,z,and,code,0,through,code,9,stay,the,same,li,li,special,characters,code,code,code,and,code,stay,the,same,li,li,a,sequence,code,i,xy,i,is,interpreted,as,a,hexadecimal,representation,of,the,character,li,ul,param,source,the,encoded,string,may,be,code,null,param,charset,the,character,set,return,the,decoded,value,throws,illegal,argument,exception,when,the,given,source,contains,invalid,encoded,sequences,since,5,0,see,java,net,urldecoder,decode,string,string;public,static,string,uri,decode,string,source,charset,charset,if,source,null,return,null,int,length,source,length,if,length,0,return,source,assert,not,null,charset,charset,must,not,be,null,byte,array,output,stream,bos,new,byte,array,output,stream,length,boolean,changed,false,for,int,i,0,i,length,i,int,ch,source,char,at,i,if,ch,if,i,2,length,char,hex1,source,char,at,i,1,char,hex2,source,char,at,i,2,int,u,character,digit,hex1,16,int,l,character,digit,hex2,16,if,u,1,l,1,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,bos,write,char,u,4,l,i,2,changed,true,else,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,else,bos,write,ch,return,changed,new,string,bos,to,byte,array,charset,source
StringUtils -> public static String uriDecode(String source, Charset charset);1487760984;Decode the given encoded URI component value. Based on the following rules:_<ul>_<li>Alphanumeric characters {@code "a"} through {@code "z"}, {@code "A"} through {@code "Z"},_and {@code "0"} through {@code "9"} stay the same.</li>_<li>Special characters {@code "-"}, {@code "_"}, {@code "."}, and {@code "*"} stay the same.</li>_<li>A sequence "{@code %<i>xy</i>}" is interpreted as a hexadecimal representation of the character.</li>_</ul>_@param source the encoded String (may be {@code null})_@param charset the character set_@return the decoded value_@throws IllegalArgumentException when the given source contains invalid encoded sequences_@since 5.0_@see java.net.URLDecoder#decode(String, String);public static String uriDecode(String source, Charset charset) {_		if (source == null) {_			return null__		}_		int length = source.length()__		if (length == 0) {_			return source__		}_		Assert.notNull(charset, "Charset must not be null")___		ByteArrayOutputStream bos = new ByteArrayOutputStream(length)__		boolean changed = false__		for (int i = 0_ i < length_ i++) {_			int ch = source.charAt(i)__			if (ch == '%') {_				if (i + 2 < length) {_					char hex1 = source.charAt(i + 1)__					char hex2 = source.charAt(i + 2)__					int u = Character.digit(hex1, 16)__					int l = Character.digit(hex2, 16)__					if (u == -1 || l == -1) {_						throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__					}_					bos.write((char) ((u << 4) + l))__					i += 2__					changed = true__				}_				else {_					throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__				}_			}_			else {_				bos.write(ch)__			}_		}_		return (changed ? new String(bos.toByteArray(), charset) : source)__	};decode,the,given,encoded,uri,component,value,based,on,the,following,rules,ul,li,alphanumeric,characters,code,a,through,code,z,code,a,through,code,z,and,code,0,through,code,9,stay,the,same,li,li,special,characters,code,code,code,and,code,stay,the,same,li,li,a,sequence,code,i,xy,i,is,interpreted,as,a,hexadecimal,representation,of,the,character,li,ul,param,source,the,encoded,string,may,be,code,null,param,charset,the,character,set,return,the,decoded,value,throws,illegal,argument,exception,when,the,given,source,contains,invalid,encoded,sequences,since,5,0,see,java,net,urldecoder,decode,string,string;public,static,string,uri,decode,string,source,charset,charset,if,source,null,return,null,int,length,source,length,if,length,0,return,source,assert,not,null,charset,charset,must,not,be,null,byte,array,output,stream,bos,new,byte,array,output,stream,length,boolean,changed,false,for,int,i,0,i,length,i,int,ch,source,char,at,i,if,ch,if,i,2,length,char,hex1,source,char,at,i,1,char,hex2,source,char,at,i,2,int,u,character,digit,hex1,16,int,l,character,digit,hex2,16,if,u,1,l,1,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,bos,write,char,u,4,l,i,2,changed,true,else,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,else,bos,write,ch,return,changed,new,string,bos,to,byte,array,charset,source
StringUtils -> public static String uriDecode(String source, Charset charset);1487778834;Decode the given encoded URI component value. Based on the following rules:_<ul>_<li>Alphanumeric characters {@code "a"} through {@code "z"}, {@code "A"} through {@code "Z"},_and {@code "0"} through {@code "9"} stay the same.</li>_<li>Special characters {@code "-"}, {@code "_"}, {@code "."}, and {@code "*"} stay the same.</li>_<li>A sequence "{@code %<i>xy</i>}" is interpreted as a hexadecimal representation of the character.</li>_</ul>_@param source the encoded String (may be {@code null})_@param charset the character set_@return the decoded value_@throws IllegalArgumentException when the given source contains invalid encoded sequences_@since 5.0_@see java.net.URLDecoder#decode(String, String);public static String uriDecode(String source, Charset charset) {_		if (source == null) {_			return null__		}_		int length = source.length()__		if (length == 0) {_			return source__		}_		Assert.notNull(charset, "Charset must not be null")___		ByteArrayOutputStream bos = new ByteArrayOutputStream(length)__		boolean changed = false__		for (int i = 0_ i < length_ i++) {_			int ch = source.charAt(i)__			if (ch == '%') {_				if (i + 2 < length) {_					char hex1 = source.charAt(i + 1)__					char hex2 = source.charAt(i + 2)__					int u = Character.digit(hex1, 16)__					int l = Character.digit(hex2, 16)__					if (u == -1 || l == -1) {_						throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__					}_					bos.write((char) ((u << 4) + l))__					i += 2__					changed = true__				}_				else {_					throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__				}_			}_			else {_				bos.write(ch)__			}_		}_		return (changed ? new String(bos.toByteArray(), charset) : source)__	};decode,the,given,encoded,uri,component,value,based,on,the,following,rules,ul,li,alphanumeric,characters,code,a,through,code,z,code,a,through,code,z,and,code,0,through,code,9,stay,the,same,li,li,special,characters,code,code,code,and,code,stay,the,same,li,li,a,sequence,code,i,xy,i,is,interpreted,as,a,hexadecimal,representation,of,the,character,li,ul,param,source,the,encoded,string,may,be,code,null,param,charset,the,character,set,return,the,decoded,value,throws,illegal,argument,exception,when,the,given,source,contains,invalid,encoded,sequences,since,5,0,see,java,net,urldecoder,decode,string,string;public,static,string,uri,decode,string,source,charset,charset,if,source,null,return,null,int,length,source,length,if,length,0,return,source,assert,not,null,charset,charset,must,not,be,null,byte,array,output,stream,bos,new,byte,array,output,stream,length,boolean,changed,false,for,int,i,0,i,length,i,int,ch,source,char,at,i,if,ch,if,i,2,length,char,hex1,source,char,at,i,1,char,hex2,source,char,at,i,2,int,u,character,digit,hex1,16,int,l,character,digit,hex2,16,if,u,1,l,1,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,bos,write,char,u,4,l,i,2,changed,true,else,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,else,bos,write,ch,return,changed,new,string,bos,to,byte,array,charset,source
StringUtils -> public static String uriDecode(String source, Charset charset);1491898314;Decode the given encoded URI component value. Based on the following rules:_<ul>_<li>Alphanumeric characters {@code "a"} through {@code "z"}, {@code "A"} through {@code "Z"},_and {@code "0"} through {@code "9"} stay the same.</li>_<li>Special characters {@code "-"}, {@code "_"}, {@code "."}, and {@code "*"} stay the same.</li>_<li>A sequence "{@code %<i>xy</i>}" is interpreted as a hexadecimal representation of the character.</li>_</ul>_@param source the encoded String (may be {@code null})_@param charset the character set_@return the decoded value_@throws IllegalArgumentException when the given source contains invalid encoded sequences_@since 5.0_@see java.net.URLDecoder#decode(String, String);public static String uriDecode(String source, Charset charset) {_		if (source == null) {_			return null__		}_		int length = source.length()__		if (length == 0) {_			return source__		}_		Assert.notNull(charset, "Charset must not be null")___		ByteArrayOutputStream bos = new ByteArrayOutputStream(length)__		boolean changed = false__		for (int i = 0_ i < length_ i++) {_			int ch = source.charAt(i)__			if (ch == '%') {_				if (i + 2 < length) {_					char hex1 = source.charAt(i + 1)__					char hex2 = source.charAt(i + 2)__					int u = Character.digit(hex1, 16)__					int l = Character.digit(hex2, 16)__					if (u == -1 || l == -1) {_						throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__					}_					bos.write((char) ((u << 4) + l))__					i += 2__					changed = true__				}_				else {_					throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__				}_			}_			else {_				bos.write(ch)__			}_		}_		return (changed ? new String(bos.toByteArray(), charset) : source)__	};decode,the,given,encoded,uri,component,value,based,on,the,following,rules,ul,li,alphanumeric,characters,code,a,through,code,z,code,a,through,code,z,and,code,0,through,code,9,stay,the,same,li,li,special,characters,code,code,code,and,code,stay,the,same,li,li,a,sequence,code,i,xy,i,is,interpreted,as,a,hexadecimal,representation,of,the,character,li,ul,param,source,the,encoded,string,may,be,code,null,param,charset,the,character,set,return,the,decoded,value,throws,illegal,argument,exception,when,the,given,source,contains,invalid,encoded,sequences,since,5,0,see,java,net,urldecoder,decode,string,string;public,static,string,uri,decode,string,source,charset,charset,if,source,null,return,null,int,length,source,length,if,length,0,return,source,assert,not,null,charset,charset,must,not,be,null,byte,array,output,stream,bos,new,byte,array,output,stream,length,boolean,changed,false,for,int,i,0,i,length,i,int,ch,source,char,at,i,if,ch,if,i,2,length,char,hex1,source,char,at,i,1,char,hex2,source,char,at,i,2,int,u,character,digit,hex1,16,int,l,character,digit,hex2,16,if,u,1,l,1,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,bos,write,char,u,4,l,i,2,changed,true,else,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,else,bos,write,ch,return,changed,new,string,bos,to,byte,array,charset,source
StringUtils -> public static String uriDecode(String source, Charset charset);1491903650;Decode the given encoded URI component value. Based on the following rules:_<ul>_<li>Alphanumeric characters {@code "a"} through {@code "z"}, {@code "A"} through {@code "Z"},_and {@code "0"} through {@code "9"} stay the same.</li>_<li>Special characters {@code "-"}, {@code "_"}, {@code "."}, and {@code "*"} stay the same.</li>_<li>A sequence "{@code %<i>xy</i>}" is interpreted as a hexadecimal representation of the character.</li>_</ul>_@param source the encoded String (may be {@code null})_@param charset the character set_@return the decoded value_@throws IllegalArgumentException when the given source contains invalid encoded sequences_@since 5.0_@see java.net.URLDecoder#decode(String, String);public static String uriDecode(String source, Charset charset) {_		if (source == null) {_			return null__		}_		int length = source.length()__		if (length == 0) {_			return source__		}_		Assert.notNull(charset, "Charset must not be null")___		ByteArrayOutputStream bos = new ByteArrayOutputStream(length)__		boolean changed = false__		for (int i = 0_ i < length_ i++) {_			int ch = source.charAt(i)__			if (ch == '%') {_				if (i + 2 < length) {_					char hex1 = source.charAt(i + 1)__					char hex2 = source.charAt(i + 2)__					int u = Character.digit(hex1, 16)__					int l = Character.digit(hex2, 16)__					if (u == -1 || l == -1) {_						throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__					}_					bos.write((char) ((u << 4) + l))__					i += 2__					changed = true__				}_				else {_					throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__				}_			}_			else {_				bos.write(ch)__			}_		}_		return (changed ? new String(bos.toByteArray(), charset) : source)__	};decode,the,given,encoded,uri,component,value,based,on,the,following,rules,ul,li,alphanumeric,characters,code,a,through,code,z,code,a,through,code,z,and,code,0,through,code,9,stay,the,same,li,li,special,characters,code,code,code,and,code,stay,the,same,li,li,a,sequence,code,i,xy,i,is,interpreted,as,a,hexadecimal,representation,of,the,character,li,ul,param,source,the,encoded,string,may,be,code,null,param,charset,the,character,set,return,the,decoded,value,throws,illegal,argument,exception,when,the,given,source,contains,invalid,encoded,sequences,since,5,0,see,java,net,urldecoder,decode,string,string;public,static,string,uri,decode,string,source,charset,charset,if,source,null,return,null,int,length,source,length,if,length,0,return,source,assert,not,null,charset,charset,must,not,be,null,byte,array,output,stream,bos,new,byte,array,output,stream,length,boolean,changed,false,for,int,i,0,i,length,i,int,ch,source,char,at,i,if,ch,if,i,2,length,char,hex1,source,char,at,i,1,char,hex2,source,char,at,i,2,int,u,character,digit,hex1,16,int,l,character,digit,hex2,16,if,u,1,l,1,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,bos,write,char,u,4,l,i,2,changed,true,else,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,else,bos,write,ch,return,changed,new,string,bos,to,byte,array,charset,source
StringUtils -> public static String uriDecode(String source, Charset charset);1496837955;Decode the given encoded URI component value. Based on the following rules:_<ul>_<li>Alphanumeric characters {@code "a"} through {@code "z"}, {@code "A"} through {@code "Z"},_and {@code "0"} through {@code "9"} stay the same.</li>_<li>Special characters {@code "-"}, {@code "_"}, {@code "."}, and {@code "*"} stay the same.</li>_<li>A sequence "{@code %<i>xy</i>}" is interpreted as a hexadecimal representation of the character.</li>_</ul>_@param source the encoded String_@param charset the character set_@return the decoded value_@throws IllegalArgumentException when the given source contains invalid encoded sequences_@since 5.0_@see java.net.URLDecoder#decode(String, String);public static String uriDecode(String source, Charset charset) {_		int length = source.length()__		if (length == 0) {_			return source__		}_		Assert.notNull(charset, "Charset must not be null")___		ByteArrayOutputStream bos = new ByteArrayOutputStream(length)__		boolean changed = false__		for (int i = 0_ i < length_ i++) {_			int ch = source.charAt(i)__			if (ch == '%') {_				if (i + 2 < length) {_					char hex1 = source.charAt(i + 1)__					char hex2 = source.charAt(i + 2)__					int u = Character.digit(hex1, 16)__					int l = Character.digit(hex2, 16)__					if (u == -1 || l == -1) {_						throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__					}_					bos.write((char) ((u << 4) + l))__					i += 2__					changed = true__				}_				else {_					throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__				}_			}_			else {_				bos.write(ch)__			}_		}_		return (changed ? new String(bos.toByteArray(), charset) : source)__	};decode,the,given,encoded,uri,component,value,based,on,the,following,rules,ul,li,alphanumeric,characters,code,a,through,code,z,code,a,through,code,z,and,code,0,through,code,9,stay,the,same,li,li,special,characters,code,code,code,and,code,stay,the,same,li,li,a,sequence,code,i,xy,i,is,interpreted,as,a,hexadecimal,representation,of,the,character,li,ul,param,source,the,encoded,string,param,charset,the,character,set,return,the,decoded,value,throws,illegal,argument,exception,when,the,given,source,contains,invalid,encoded,sequences,since,5,0,see,java,net,urldecoder,decode,string,string;public,static,string,uri,decode,string,source,charset,charset,int,length,source,length,if,length,0,return,source,assert,not,null,charset,charset,must,not,be,null,byte,array,output,stream,bos,new,byte,array,output,stream,length,boolean,changed,false,for,int,i,0,i,length,i,int,ch,source,char,at,i,if,ch,if,i,2,length,char,hex1,source,char,at,i,1,char,hex2,source,char,at,i,2,int,u,character,digit,hex1,16,int,l,character,digit,hex2,16,if,u,1,l,1,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,bos,write,char,u,4,l,i,2,changed,true,else,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,else,bos,write,ch,return,changed,new,string,bos,to,byte,array,charset,source
StringUtils -> public static String uriDecode(String source, Charset charset);1499270197;Decode the given encoded URI component value. Based on the following rules:_<ul>_<li>Alphanumeric characters {@code "a"} through {@code "z"}, {@code "A"} through {@code "Z"},_and {@code "0"} through {@code "9"} stay the same.</li>_<li>Special characters {@code "-"}, {@code "_"}, {@code "."}, and {@code "*"} stay the same.</li>_<li>A sequence "{@code %<i>xy</i>}" is interpreted as a hexadecimal representation of the character.</li>_</ul>_@param source the encoded String_@param charset the character set_@return the decoded value_@throws IllegalArgumentException when the given source contains invalid encoded sequences_@since 5.0_@see java.net.URLDecoder#decode(String, String);public static String uriDecode(String source, Charset charset) {_		int length = source.length()__		if (length == 0) {_			return source__		}_		Assert.notNull(charset, "Charset must not be null")___		ByteArrayOutputStream bos = new ByteArrayOutputStream(length)__		boolean changed = false__		for (int i = 0_ i < length_ i++) {_			int ch = source.charAt(i)__			if (ch == '%') {_				if (i + 2 < length) {_					char hex1 = source.charAt(i + 1)__					char hex2 = source.charAt(i + 2)__					int u = Character.digit(hex1, 16)__					int l = Character.digit(hex2, 16)__					if (u == -1 || l == -1) {_						throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__					}_					bos.write((char) ((u << 4) + l))__					i += 2__					changed = true__				}_				else {_					throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__				}_			}_			else {_				bos.write(ch)__			}_		}_		return (changed ? new String(bos.toByteArray(), charset) : source)__	};decode,the,given,encoded,uri,component,value,based,on,the,following,rules,ul,li,alphanumeric,characters,code,a,through,code,z,code,a,through,code,z,and,code,0,through,code,9,stay,the,same,li,li,special,characters,code,code,code,and,code,stay,the,same,li,li,a,sequence,code,i,xy,i,is,interpreted,as,a,hexadecimal,representation,of,the,character,li,ul,param,source,the,encoded,string,param,charset,the,character,set,return,the,decoded,value,throws,illegal,argument,exception,when,the,given,source,contains,invalid,encoded,sequences,since,5,0,see,java,net,urldecoder,decode,string,string;public,static,string,uri,decode,string,source,charset,charset,int,length,source,length,if,length,0,return,source,assert,not,null,charset,charset,must,not,be,null,byte,array,output,stream,bos,new,byte,array,output,stream,length,boolean,changed,false,for,int,i,0,i,length,i,int,ch,source,char,at,i,if,ch,if,i,2,length,char,hex1,source,char,at,i,1,char,hex2,source,char,at,i,2,int,u,character,digit,hex1,16,int,l,character,digit,hex2,16,if,u,1,l,1,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,bos,write,char,u,4,l,i,2,changed,true,else,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,else,bos,write,ch,return,changed,new,string,bos,to,byte,array,charset,source
StringUtils -> public static String uriDecode(String source, Charset charset);1508667152;Decode the given encoded URI component value. Based on the following rules:_<ul>_<li>Alphanumeric characters {@code "a"} through {@code "z"}, {@code "A"} through {@code "Z"},_and {@code "0"} through {@code "9"} stay the same.</li>_<li>Special characters {@code "-"}, {@code "_"}, {@code "."}, and {@code "*"} stay the same.</li>_<li>A sequence "{@code %<i>xy</i>}" is interpreted as a hexadecimal representation of the character.</li>_</ul>_@param source the encoded String_@param charset the character set_@return the decoded value_@throws IllegalArgumentException when the given source contains invalid encoded sequences_@since 5.0_@see java.net.URLDecoder#decode(String, String);public static String uriDecode(String source, Charset charset) {_		int length = source.length()__		if (length == 0) {_			return source__		}_		Assert.notNull(charset, "Charset must not be null")___		ByteArrayOutputStream bos = new ByteArrayOutputStream(length)__		boolean changed = false__		for (int i = 0_ i < length_ i++) {_			int ch = source.charAt(i)__			if (ch == '%') {_				if (i + 2 < length) {_					char hex1 = source.charAt(i + 1)__					char hex2 = source.charAt(i + 2)__					int u = Character.digit(hex1, 16)__					int l = Character.digit(hex2, 16)__					if (u == -1 || l == -1) {_						throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__					}_					bos.write((char) ((u << 4) + l))__					i += 2__					changed = true__				}_				else {_					throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__				}_			}_			else {_				bos.write(ch)__			}_		}_		return (changed ? new String(bos.toByteArray(), charset) : source)__	};decode,the,given,encoded,uri,component,value,based,on,the,following,rules,ul,li,alphanumeric,characters,code,a,through,code,z,code,a,through,code,z,and,code,0,through,code,9,stay,the,same,li,li,special,characters,code,code,code,and,code,stay,the,same,li,li,a,sequence,code,i,xy,i,is,interpreted,as,a,hexadecimal,representation,of,the,character,li,ul,param,source,the,encoded,string,param,charset,the,character,set,return,the,decoded,value,throws,illegal,argument,exception,when,the,given,source,contains,invalid,encoded,sequences,since,5,0,see,java,net,urldecoder,decode,string,string;public,static,string,uri,decode,string,source,charset,charset,int,length,source,length,if,length,0,return,source,assert,not,null,charset,charset,must,not,be,null,byte,array,output,stream,bos,new,byte,array,output,stream,length,boolean,changed,false,for,int,i,0,i,length,i,int,ch,source,char,at,i,if,ch,if,i,2,length,char,hex1,source,char,at,i,1,char,hex2,source,char,at,i,2,int,u,character,digit,hex1,16,int,l,character,digit,hex2,16,if,u,1,l,1,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,bos,write,char,u,4,l,i,2,changed,true,else,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,else,bos,write,ch,return,changed,new,string,bos,to,byte,array,charset,source
StringUtils -> public static String uriDecode(String source, Charset charset);1508675477;Decode the given encoded URI component value. Based on the following rules:_<ul>_<li>Alphanumeric characters {@code "a"} through {@code "z"}, {@code "A"} through {@code "Z"},_and {@code "0"} through {@code "9"} stay the same.</li>_<li>Special characters {@code "-"}, {@code "_"}, {@code "."}, and {@code "*"} stay the same.</li>_<li>A sequence "{@code %<i>xy</i>}" is interpreted as a hexadecimal representation of the character.</li>_</ul>_@param source the encoded String_@param charset the character set_@return the decoded value_@throws IllegalArgumentException when the given source contains invalid encoded sequences_@since 5.0_@see java.net.URLDecoder#decode(String, String);public static String uriDecode(String source, Charset charset) {_		int length = source.length()__		if (length == 0) {_			return source__		}_		Assert.notNull(charset, "Charset must not be null")___		ByteArrayOutputStream bos = new ByteArrayOutputStream(length)__		boolean changed = false__		for (int i = 0_ i < length_ i++) {_			int ch = source.charAt(i)__			if (ch == '%') {_				if (i + 2 < length) {_					char hex1 = source.charAt(i + 1)__					char hex2 = source.charAt(i + 2)__					int u = Character.digit(hex1, 16)__					int l = Character.digit(hex2, 16)__					if (u == -1 || l == -1) {_						throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__					}_					bos.write((char) ((u << 4) + l))__					i += 2__					changed = true__				}_				else {_					throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__				}_			}_			else {_				bos.write(ch)__			}_		}_		return (changed ? new String(bos.toByteArray(), charset) : source)__	};decode,the,given,encoded,uri,component,value,based,on,the,following,rules,ul,li,alphanumeric,characters,code,a,through,code,z,code,a,through,code,z,and,code,0,through,code,9,stay,the,same,li,li,special,characters,code,code,code,and,code,stay,the,same,li,li,a,sequence,code,i,xy,i,is,interpreted,as,a,hexadecimal,representation,of,the,character,li,ul,param,source,the,encoded,string,param,charset,the,character,set,return,the,decoded,value,throws,illegal,argument,exception,when,the,given,source,contains,invalid,encoded,sequences,since,5,0,see,java,net,urldecoder,decode,string,string;public,static,string,uri,decode,string,source,charset,charset,int,length,source,length,if,length,0,return,source,assert,not,null,charset,charset,must,not,be,null,byte,array,output,stream,bos,new,byte,array,output,stream,length,boolean,changed,false,for,int,i,0,i,length,i,int,ch,source,char,at,i,if,ch,if,i,2,length,char,hex1,source,char,at,i,1,char,hex2,source,char,at,i,2,int,u,character,digit,hex1,16,int,l,character,digit,hex2,16,if,u,1,l,1,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,bos,write,char,u,4,l,i,2,changed,true,else,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,else,bos,write,ch,return,changed,new,string,bos,to,byte,array,charset,source
StringUtils -> public static String uriDecode(String source, Charset charset);1508843807;Decode the given encoded URI component value. Based on the following rules:_<ul>_<li>Alphanumeric characters {@code "a"} through {@code "z"}, {@code "A"} through {@code "Z"},_and {@code "0"} through {@code "9"} stay the same.</li>_<li>Special characters {@code "-"}, {@code "_"}, {@code "."}, and {@code "*"} stay the same.</li>_<li>A sequence "{@code %<i>xy</i>}" is interpreted as a hexadecimal representation of the character.</li>_</ul>_@param source the encoded String_@param charset the character set_@return the decoded value_@throws IllegalArgumentException when the given source contains invalid encoded sequences_@since 5.0_@see java.net.URLDecoder#decode(String, String);public static String uriDecode(String source, Charset charset) {_		int length = source.length()__		if (length == 0) {_			return source__		}_		Assert.notNull(charset, "Charset must not be null")___		ByteArrayOutputStream bos = new ByteArrayOutputStream(length)__		boolean changed = false__		for (int i = 0_ i < length_ i++) {_			int ch = source.charAt(i)__			if (ch == '%') {_				if (i + 2 < length) {_					char hex1 = source.charAt(i + 1)__					char hex2 = source.charAt(i + 2)__					int u = Character.digit(hex1, 16)__					int l = Character.digit(hex2, 16)__					if (u == -1 || l == -1) {_						throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__					}_					bos.write((char) ((u << 4) + l))__					i += 2__					changed = true__				}_				else {_					throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__				}_			}_			else {_				bos.write(ch)__			}_		}_		return (changed ? new String(bos.toByteArray(), charset) : source)__	};decode,the,given,encoded,uri,component,value,based,on,the,following,rules,ul,li,alphanumeric,characters,code,a,through,code,z,code,a,through,code,z,and,code,0,through,code,9,stay,the,same,li,li,special,characters,code,code,code,and,code,stay,the,same,li,li,a,sequence,code,i,xy,i,is,interpreted,as,a,hexadecimal,representation,of,the,character,li,ul,param,source,the,encoded,string,param,charset,the,character,set,return,the,decoded,value,throws,illegal,argument,exception,when,the,given,source,contains,invalid,encoded,sequences,since,5,0,see,java,net,urldecoder,decode,string,string;public,static,string,uri,decode,string,source,charset,charset,int,length,source,length,if,length,0,return,source,assert,not,null,charset,charset,must,not,be,null,byte,array,output,stream,bos,new,byte,array,output,stream,length,boolean,changed,false,for,int,i,0,i,length,i,int,ch,source,char,at,i,if,ch,if,i,2,length,char,hex1,source,char,at,i,1,char,hex2,source,char,at,i,2,int,u,character,digit,hex1,16,int,l,character,digit,hex2,16,if,u,1,l,1,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,bos,write,char,u,4,l,i,2,changed,true,else,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,else,bos,write,ch,return,changed,new,string,bos,to,byte,array,charset,source
StringUtils -> public static String uriDecode(String source, Charset charset);1516903831;Decode the given encoded URI component value. Based on the following rules:_<ul>_<li>Alphanumeric characters {@code "a"} through {@code "z"}, {@code "A"} through {@code "Z"},_and {@code "0"} through {@code "9"} stay the same.</li>_<li>Special characters {@code "-"}, {@code "_"}, {@code "."}, and {@code "*"} stay the same.</li>_<li>A sequence "{@code %<i>xy</i>}" is interpreted as a hexadecimal representation of the character.</li>_</ul>_@param source the encoded String_@param charset the character set_@return the decoded value_@throws IllegalArgumentException when the given source contains invalid encoded sequences_@since 5.0_@see java.net.URLDecoder#decode(String, String);public static String uriDecode(String source, Charset charset) {_		int length = source.length()__		if (length == 0) {_			return source__		}_		Assert.notNull(charset, "Charset must not be null")___		ByteArrayOutputStream bos = new ByteArrayOutputStream(length)__		boolean changed = false__		for (int i = 0_ i < length_ i++) {_			int ch = source.charAt(i)__			if (ch == '%') {_				if (i + 2 < length) {_					char hex1 = source.charAt(i + 1)__					char hex2 = source.charAt(i + 2)__					int u = Character.digit(hex1, 16)__					int l = Character.digit(hex2, 16)__					if (u == -1 || l == -1) {_						throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__					}_					bos.write((char) ((u << 4) + l))__					i += 2__					changed = true__				}_				else {_					throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__				}_			}_			else {_				bos.write(ch)__			}_		}_		return (changed ? new String(bos.toByteArray(), charset) : source)__	};decode,the,given,encoded,uri,component,value,based,on,the,following,rules,ul,li,alphanumeric,characters,code,a,through,code,z,code,a,through,code,z,and,code,0,through,code,9,stay,the,same,li,li,special,characters,code,code,code,and,code,stay,the,same,li,li,a,sequence,code,i,xy,i,is,interpreted,as,a,hexadecimal,representation,of,the,character,li,ul,param,source,the,encoded,string,param,charset,the,character,set,return,the,decoded,value,throws,illegal,argument,exception,when,the,given,source,contains,invalid,encoded,sequences,since,5,0,see,java,net,urldecoder,decode,string,string;public,static,string,uri,decode,string,source,charset,charset,int,length,source,length,if,length,0,return,source,assert,not,null,charset,charset,must,not,be,null,byte,array,output,stream,bos,new,byte,array,output,stream,length,boolean,changed,false,for,int,i,0,i,length,i,int,ch,source,char,at,i,if,ch,if,i,2,length,char,hex1,source,char,at,i,1,char,hex2,source,char,at,i,2,int,u,character,digit,hex1,16,int,l,character,digit,hex2,16,if,u,1,l,1,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,bos,write,char,u,4,l,i,2,changed,true,else,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,else,bos,write,ch,return,changed,new,string,bos,to,byte,array,charset,source
StringUtils -> public static String uriDecode(String source, Charset charset);1519295386;Decode the given encoded URI component value. Based on the following rules:_<ul>_<li>Alphanumeric characters {@code "a"} through {@code "z"}, {@code "A"} through {@code "Z"},_and {@code "0"} through {@code "9"} stay the same.</li>_<li>Special characters {@code "-"}, {@code "_"}, {@code "."}, and {@code "*"} stay the same.</li>_<li>A sequence "{@code %<i>xy</i>}" is interpreted as a hexadecimal representation of the character.</li>_</ul>_@param source the encoded String_@param charset the character set_@return the decoded value_@throws IllegalArgumentException when the given source contains invalid encoded sequences_@since 5.0_@see java.net.URLDecoder#decode(String, String);public static String uriDecode(String source, Charset charset) {_		int length = source.length()__		if (length == 0) {_			return source__		}_		Assert.notNull(charset, "Charset must not be null")___		ByteArrayOutputStream bos = new ByteArrayOutputStream(length)__		boolean changed = false__		for (int i = 0_ i < length_ i++) {_			int ch = source.charAt(i)__			if (ch == '%') {_				if (i + 2 < length) {_					char hex1 = source.charAt(i + 1)__					char hex2 = source.charAt(i + 2)__					int u = Character.digit(hex1, 16)__					int l = Character.digit(hex2, 16)__					if (u == -1 || l == -1) {_						throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__					}_					bos.write((char) ((u << 4) + l))__					i += 2__					changed = true__				}_				else {_					throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__				}_			}_			else {_				bos.write(ch)__			}_		}_		return (changed ? new String(bos.toByteArray(), charset) : source)__	};decode,the,given,encoded,uri,component,value,based,on,the,following,rules,ul,li,alphanumeric,characters,code,a,through,code,z,code,a,through,code,z,and,code,0,through,code,9,stay,the,same,li,li,special,characters,code,code,code,and,code,stay,the,same,li,li,a,sequence,code,i,xy,i,is,interpreted,as,a,hexadecimal,representation,of,the,character,li,ul,param,source,the,encoded,string,param,charset,the,character,set,return,the,decoded,value,throws,illegal,argument,exception,when,the,given,source,contains,invalid,encoded,sequences,since,5,0,see,java,net,urldecoder,decode,string,string;public,static,string,uri,decode,string,source,charset,charset,int,length,source,length,if,length,0,return,source,assert,not,null,charset,charset,must,not,be,null,byte,array,output,stream,bos,new,byte,array,output,stream,length,boolean,changed,false,for,int,i,0,i,length,i,int,ch,source,char,at,i,if,ch,if,i,2,length,char,hex1,source,char,at,i,1,char,hex2,source,char,at,i,2,int,u,character,digit,hex1,16,int,l,character,digit,hex2,16,if,u,1,l,1,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,bos,write,char,u,4,l,i,2,changed,true,else,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,else,bos,write,ch,return,changed,new,string,bos,to,byte,array,charset,source
StringUtils -> public static String uriDecode(String source, Charset charset);1519308837;Decode the given encoded URI component value. Based on the following rules:_<ul>_<li>Alphanumeric characters {@code "a"} through {@code "z"}, {@code "A"} through {@code "Z"},_and {@code "0"} through {@code "9"} stay the same.</li>_<li>Special characters {@code "-"}, {@code "_"}, {@code "."}, and {@code "*"} stay the same.</li>_<li>A sequence "{@code %<i>xy</i>}" is interpreted as a hexadecimal representation of the character.</li>_</ul>_@param source the encoded String_@param charset the character set_@return the decoded value_@throws IllegalArgumentException when the given source contains invalid encoded sequences_@since 5.0_@see java.net.URLDecoder#decode(String, String);public static String uriDecode(String source, Charset charset) {_		int length = source.length()__		if (length == 0) {_			return source__		}_		Assert.notNull(charset, "Charset must not be null")___		ByteArrayOutputStream bos = new ByteArrayOutputStream(length)__		boolean changed = false__		for (int i = 0_ i < length_ i++) {_			int ch = source.charAt(i)__			if (ch == '%') {_				if (i + 2 < length) {_					char hex1 = source.charAt(i + 1)__					char hex2 = source.charAt(i + 2)__					int u = Character.digit(hex1, 16)__					int l = Character.digit(hex2, 16)__					if (u == -1 || l == -1) {_						throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__					}_					bos.write((char) ((u << 4) + l))__					i += 2__					changed = true__				}_				else {_					throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__				}_			}_			else {_				bos.write(ch)__			}_		}_		return (changed ? new String(bos.toByteArray(), charset) : source)__	};decode,the,given,encoded,uri,component,value,based,on,the,following,rules,ul,li,alphanumeric,characters,code,a,through,code,z,code,a,through,code,z,and,code,0,through,code,9,stay,the,same,li,li,special,characters,code,code,code,and,code,stay,the,same,li,li,a,sequence,code,i,xy,i,is,interpreted,as,a,hexadecimal,representation,of,the,character,li,ul,param,source,the,encoded,string,param,charset,the,character,set,return,the,decoded,value,throws,illegal,argument,exception,when,the,given,source,contains,invalid,encoded,sequences,since,5,0,see,java,net,urldecoder,decode,string,string;public,static,string,uri,decode,string,source,charset,charset,int,length,source,length,if,length,0,return,source,assert,not,null,charset,charset,must,not,be,null,byte,array,output,stream,bos,new,byte,array,output,stream,length,boolean,changed,false,for,int,i,0,i,length,i,int,ch,source,char,at,i,if,ch,if,i,2,length,char,hex1,source,char,at,i,1,char,hex2,source,char,at,i,2,int,u,character,digit,hex1,16,int,l,character,digit,hex2,16,if,u,1,l,1,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,bos,write,char,u,4,l,i,2,changed,true,else,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,else,bos,write,ch,return,changed,new,string,bos,to,byte,array,charset,source
StringUtils -> public static String uriDecode(String source, Charset charset);1519588127;Decode the given encoded URI component value. Based on the following rules:_<ul>_<li>Alphanumeric characters {@code "a"} through {@code "z"}, {@code "A"} through {@code "Z"},_and {@code "0"} through {@code "9"} stay the same.</li>_<li>Special characters {@code "-"}, {@code "_"}, {@code "."}, and {@code "*"} stay the same.</li>_<li>A sequence "{@code %<i>xy</i>}" is interpreted as a hexadecimal representation of the character.</li>_</ul>_@param source the encoded String_@param charset the character set_@return the decoded value_@throws IllegalArgumentException when the given source contains invalid encoded sequences_@since 5.0_@see java.net.URLDecoder#decode(String, String);public static String uriDecode(String source, Charset charset) {_		int length = source.length()__		if (length == 0) {_			return source__		}_		Assert.notNull(charset, "Charset must not be null")___		ByteArrayOutputStream bos = new ByteArrayOutputStream(length)__		boolean changed = false__		for (int i = 0_ i < length_ i++) {_			int ch = source.charAt(i)__			if (ch == '%') {_				if (i + 2 < length) {_					char hex1 = source.charAt(i + 1)__					char hex2 = source.charAt(i + 2)__					int u = Character.digit(hex1, 16)__					int l = Character.digit(hex2, 16)__					if (u == -1 || l == -1) {_						throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__					}_					bos.write((char) ((u << 4) + l))__					i += 2__					changed = true__				}_				else {_					throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__				}_			}_			else {_				bos.write(ch)__			}_		}_		return (changed ? new String(bos.toByteArray(), charset) : source)__	};decode,the,given,encoded,uri,component,value,based,on,the,following,rules,ul,li,alphanumeric,characters,code,a,through,code,z,code,a,through,code,z,and,code,0,through,code,9,stay,the,same,li,li,special,characters,code,code,code,and,code,stay,the,same,li,li,a,sequence,code,i,xy,i,is,interpreted,as,a,hexadecimal,representation,of,the,character,li,ul,param,source,the,encoded,string,param,charset,the,character,set,return,the,decoded,value,throws,illegal,argument,exception,when,the,given,source,contains,invalid,encoded,sequences,since,5,0,see,java,net,urldecoder,decode,string,string;public,static,string,uri,decode,string,source,charset,charset,int,length,source,length,if,length,0,return,source,assert,not,null,charset,charset,must,not,be,null,byte,array,output,stream,bos,new,byte,array,output,stream,length,boolean,changed,false,for,int,i,0,i,length,i,int,ch,source,char,at,i,if,ch,if,i,2,length,char,hex1,source,char,at,i,1,char,hex2,source,char,at,i,2,int,u,character,digit,hex1,16,int,l,character,digit,hex2,16,if,u,1,l,1,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,bos,write,char,u,4,l,i,2,changed,true,else,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,else,bos,write,ch,return,changed,new,string,bos,to,byte,array,charset,source
StringUtils -> public static String uriDecode(String source, Charset charset);1522332352;Decode the given encoded URI component value. Based on the following rules:_<ul>_<li>Alphanumeric characters {@code "a"} through {@code "z"}, {@code "A"} through {@code "Z"},_and {@code "0"} through {@code "9"} stay the same.</li>_<li>Special characters {@code "-"}, {@code "_"}, {@code "."}, and {@code "*"} stay the same.</li>_<li>A sequence "{@code %<i>xy</i>}" is interpreted as a hexadecimal representation of the character.</li>_</ul>_@param source the encoded String_@param charset the character set_@return the decoded value_@throws IllegalArgumentException when the given source contains invalid encoded sequences_@since 5.0_@see java.net.URLDecoder#decode(String, String);public static String uriDecode(String source, Charset charset) {_		int length = source.length()__		if (length == 0) {_			return source__		}_		Assert.notNull(charset, "Charset must not be null")___		ByteArrayOutputStream bos = new ByteArrayOutputStream(length)__		boolean changed = false__		for (int i = 0_ i < length_ i++) {_			int ch = source.charAt(i)__			if (ch == '%') {_				if (i + 2 < length) {_					char hex1 = source.charAt(i + 1)__					char hex2 = source.charAt(i + 2)__					int u = Character.digit(hex1, 16)__					int l = Character.digit(hex2, 16)__					if (u == -1 || l == -1) {_						throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__					}_					bos.write((char) ((u << 4) + l))__					i += 2__					changed = true__				}_				else {_					throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__				}_			}_			else {_				bos.write(ch)__			}_		}_		return (changed ? new String(bos.toByteArray(), charset) : source)__	};decode,the,given,encoded,uri,component,value,based,on,the,following,rules,ul,li,alphanumeric,characters,code,a,through,code,z,code,a,through,code,z,and,code,0,through,code,9,stay,the,same,li,li,special,characters,code,code,code,and,code,stay,the,same,li,li,a,sequence,code,i,xy,i,is,interpreted,as,a,hexadecimal,representation,of,the,character,li,ul,param,source,the,encoded,string,param,charset,the,character,set,return,the,decoded,value,throws,illegal,argument,exception,when,the,given,source,contains,invalid,encoded,sequences,since,5,0,see,java,net,urldecoder,decode,string,string;public,static,string,uri,decode,string,source,charset,charset,int,length,source,length,if,length,0,return,source,assert,not,null,charset,charset,must,not,be,null,byte,array,output,stream,bos,new,byte,array,output,stream,length,boolean,changed,false,for,int,i,0,i,length,i,int,ch,source,char,at,i,if,ch,if,i,2,length,char,hex1,source,char,at,i,1,char,hex2,source,char,at,i,2,int,u,character,digit,hex1,16,int,l,character,digit,hex2,16,if,u,1,l,1,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,bos,write,char,u,4,l,i,2,changed,true,else,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,else,bos,write,ch,return,changed,new,string,bos,to,byte,array,charset,source
StringUtils -> public static String uriDecode(String source, Charset charset);1525166194;Decode the given encoded URI component value. Based on the following rules:_<ul>_<li>Alphanumeric characters {@code "a"} through {@code "z"}, {@code "A"} through {@code "Z"},_and {@code "0"} through {@code "9"} stay the same.</li>_<li>Special characters {@code "-"}, {@code "_"}, {@code "."}, and {@code "*"} stay the same.</li>_<li>A sequence "{@code %<i>xy</i>}" is interpreted as a hexadecimal representation of the character.</li>_</ul>_@param source the encoded String_@param charset the character set_@return the decoded value_@throws IllegalArgumentException when the given source contains invalid encoded sequences_@since 5.0_@see java.net.URLDecoder#decode(String, String);public static String uriDecode(String source, Charset charset) {_		int length = source.length()__		if (length == 0) {_			return source__		}_		Assert.notNull(charset, "Charset must not be null")___		ByteArrayOutputStream bos = new ByteArrayOutputStream(length)__		boolean changed = false__		for (int i = 0_ i < length_ i++) {_			int ch = source.charAt(i)__			if (ch == '%') {_				if (i + 2 < length) {_					char hex1 = source.charAt(i + 1)__					char hex2 = source.charAt(i + 2)__					int u = Character.digit(hex1, 16)__					int l = Character.digit(hex2, 16)__					if (u == -1 || l == -1) {_						throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__					}_					bos.write((char) ((u << 4) + l))__					i += 2__					changed = true__				}_				else {_					throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__				}_			}_			else {_				bos.write(ch)__			}_		}_		return (changed ? new String(bos.toByteArray(), charset) : source)__	};decode,the,given,encoded,uri,component,value,based,on,the,following,rules,ul,li,alphanumeric,characters,code,a,through,code,z,code,a,through,code,z,and,code,0,through,code,9,stay,the,same,li,li,special,characters,code,code,code,and,code,stay,the,same,li,li,a,sequence,code,i,xy,i,is,interpreted,as,a,hexadecimal,representation,of,the,character,li,ul,param,source,the,encoded,string,param,charset,the,character,set,return,the,decoded,value,throws,illegal,argument,exception,when,the,given,source,contains,invalid,encoded,sequences,since,5,0,see,java,net,urldecoder,decode,string,string;public,static,string,uri,decode,string,source,charset,charset,int,length,source,length,if,length,0,return,source,assert,not,null,charset,charset,must,not,be,null,byte,array,output,stream,bos,new,byte,array,output,stream,length,boolean,changed,false,for,int,i,0,i,length,i,int,ch,source,char,at,i,if,ch,if,i,2,length,char,hex1,source,char,at,i,1,char,hex2,source,char,at,i,2,int,u,character,digit,hex1,16,int,l,character,digit,hex2,16,if,u,1,l,1,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,bos,write,char,u,4,l,i,2,changed,true,else,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,else,bos,write,ch,return,changed,new,string,bos,to,byte,array,charset,source
StringUtils -> public static String uriDecode(String source, Charset charset);1530188116;Decode the given encoded URI component value. Based on the following rules:_<ul>_<li>Alphanumeric characters {@code "a"} through {@code "z"}, {@code "A"} through {@code "Z"},_and {@code "0"} through {@code "9"} stay the same.</li>_<li>Special characters {@code "-"}, {@code "_"}, {@code "."}, and {@code "*"} stay the same.</li>_<li>A sequence "{@code %<i>xy</i>}" is interpreted as a hexadecimal representation of the character.</li>_</ul>_@param source the encoded String_@param charset the character set_@return the decoded value_@throws IllegalArgumentException when the given source contains invalid encoded sequences_@since 5.0_@see java.net.URLDecoder#decode(String, String);public static String uriDecode(String source, Charset charset) {_		int length = source.length()__		if (length == 0) {_			return source__		}_		Assert.notNull(charset, "Charset must not be null")___		ByteArrayOutputStream bos = new ByteArrayOutputStream(length)__		boolean changed = false__		for (int i = 0_ i < length_ i++) {_			int ch = source.charAt(i)__			if (ch == '%') {_				if (i + 2 < length) {_					char hex1 = source.charAt(i + 1)__					char hex2 = source.charAt(i + 2)__					int u = Character.digit(hex1, 16)__					int l = Character.digit(hex2, 16)__					if (u == -1 || l == -1) {_						throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__					}_					bos.write((char) ((u << 4) + l))__					i += 2__					changed = true__				}_				else {_					throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__				}_			}_			else {_				bos.write(ch)__			}_		}_		return (changed ? new String(bos.toByteArray(), charset) : source)__	};decode,the,given,encoded,uri,component,value,based,on,the,following,rules,ul,li,alphanumeric,characters,code,a,through,code,z,code,a,through,code,z,and,code,0,through,code,9,stay,the,same,li,li,special,characters,code,code,code,and,code,stay,the,same,li,li,a,sequence,code,i,xy,i,is,interpreted,as,a,hexadecimal,representation,of,the,character,li,ul,param,source,the,encoded,string,param,charset,the,character,set,return,the,decoded,value,throws,illegal,argument,exception,when,the,given,source,contains,invalid,encoded,sequences,since,5,0,see,java,net,urldecoder,decode,string,string;public,static,string,uri,decode,string,source,charset,charset,int,length,source,length,if,length,0,return,source,assert,not,null,charset,charset,must,not,be,null,byte,array,output,stream,bos,new,byte,array,output,stream,length,boolean,changed,false,for,int,i,0,i,length,i,int,ch,source,char,at,i,if,ch,if,i,2,length,char,hex1,source,char,at,i,1,char,hex2,source,char,at,i,2,int,u,character,digit,hex1,16,int,l,character,digit,hex2,16,if,u,1,l,1,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,bos,write,char,u,4,l,i,2,changed,true,else,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,else,bos,write,ch,return,changed,new,string,bos,to,byte,array,charset,source
StringUtils -> public static String uriDecode(String source, Charset charset);1531843079;Decode the given encoded URI component value. Based on the following rules:_<ul>_<li>Alphanumeric characters {@code "a"} through {@code "z"}, {@code "A"} through {@code "Z"},_and {@code "0"} through {@code "9"} stay the same.</li>_<li>Special characters {@code "-"}, {@code "_"}, {@code "."}, and {@code "*"} stay the same.</li>_<li>A sequence "{@code %<i>xy</i>}" is interpreted as a hexadecimal representation of the character.</li>_</ul>_@param source the encoded String_@param charset the character set_@return the decoded value_@throws IllegalArgumentException when the given source contains invalid encoded sequences_@since 5.0_@see java.net.URLDecoder#decode(String, String);public static String uriDecode(String source, Charset charset) {_		int length = source.length()__		if (length == 0) {_			return source__		}_		Assert.notNull(charset, "Charset must not be null")___		ByteArrayOutputStream bos = new ByteArrayOutputStream(length)__		boolean changed = false__		for (int i = 0_ i < length_ i++) {_			int ch = source.charAt(i)__			if (ch == '%') {_				if (i + 2 < length) {_					char hex1 = source.charAt(i + 1)__					char hex2 = source.charAt(i + 2)__					int u = Character.digit(hex1, 16)__					int l = Character.digit(hex2, 16)__					if (u == -1 || l == -1) {_						throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__					}_					bos.write((char) ((u << 4) + l))__					i += 2__					changed = true__				}_				else {_					throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__				}_			}_			else {_				bos.write(ch)__			}_		}_		return (changed ? new String(bos.toByteArray(), charset) : source)__	};decode,the,given,encoded,uri,component,value,based,on,the,following,rules,ul,li,alphanumeric,characters,code,a,through,code,z,code,a,through,code,z,and,code,0,through,code,9,stay,the,same,li,li,special,characters,code,code,code,and,code,stay,the,same,li,li,a,sequence,code,i,xy,i,is,interpreted,as,a,hexadecimal,representation,of,the,character,li,ul,param,source,the,encoded,string,param,charset,the,character,set,return,the,decoded,value,throws,illegal,argument,exception,when,the,given,source,contains,invalid,encoded,sequences,since,5,0,see,java,net,urldecoder,decode,string,string;public,static,string,uri,decode,string,source,charset,charset,int,length,source,length,if,length,0,return,source,assert,not,null,charset,charset,must,not,be,null,byte,array,output,stream,bos,new,byte,array,output,stream,length,boolean,changed,false,for,int,i,0,i,length,i,int,ch,source,char,at,i,if,ch,if,i,2,length,char,hex1,source,char,at,i,1,char,hex2,source,char,at,i,2,int,u,character,digit,hex1,16,int,l,character,digit,hex2,16,if,u,1,l,1,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,bos,write,char,u,4,l,i,2,changed,true,else,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,else,bos,write,ch,return,changed,new,string,bos,to,byte,array,charset,source
StringUtils -> public static String uriDecode(String source, Charset charset);1531905026;Decode the given encoded URI component value. Based on the following rules:_<ul>_<li>Alphanumeric characters {@code "a"} through {@code "z"}, {@code "A"} through {@code "Z"},_and {@code "0"} through {@code "9"} stay the same.</li>_<li>Special characters {@code "-"}, {@code "_"}, {@code "."}, and {@code "*"} stay the same.</li>_<li>A sequence "{@code %<i>xy</i>}" is interpreted as a hexadecimal representation of the character.</li>_</ul>_@param source the encoded String_@param charset the character set_@return the decoded value_@throws IllegalArgumentException when the given source contains invalid encoded sequences_@since 5.0_@see java.net.URLDecoder#decode(String, String);public static String uriDecode(String source, Charset charset) {_		int length = source.length()__		if (length == 0) {_			return source__		}_		Assert.notNull(charset, "Charset must not be null")___		ByteArrayOutputStream bos = new ByteArrayOutputStream(length)__		boolean changed = false__		for (int i = 0_ i < length_ i++) {_			int ch = source.charAt(i)__			if (ch == '%') {_				if (i + 2 < length) {_					char hex1 = source.charAt(i + 1)__					char hex2 = source.charAt(i + 2)__					int u = Character.digit(hex1, 16)__					int l = Character.digit(hex2, 16)__					if (u == -1 || l == -1) {_						throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__					}_					bos.write((char) ((u << 4) + l))__					i += 2__					changed = true__				}_				else {_					throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__				}_			}_			else {_				bos.write(ch)__			}_		}_		return (changed ? new String(bos.toByteArray(), charset) : source)__	};decode,the,given,encoded,uri,component,value,based,on,the,following,rules,ul,li,alphanumeric,characters,code,a,through,code,z,code,a,through,code,z,and,code,0,through,code,9,stay,the,same,li,li,special,characters,code,code,code,and,code,stay,the,same,li,li,a,sequence,code,i,xy,i,is,interpreted,as,a,hexadecimal,representation,of,the,character,li,ul,param,source,the,encoded,string,param,charset,the,character,set,return,the,decoded,value,throws,illegal,argument,exception,when,the,given,source,contains,invalid,encoded,sequences,since,5,0,see,java,net,urldecoder,decode,string,string;public,static,string,uri,decode,string,source,charset,charset,int,length,source,length,if,length,0,return,source,assert,not,null,charset,charset,must,not,be,null,byte,array,output,stream,bos,new,byte,array,output,stream,length,boolean,changed,false,for,int,i,0,i,length,i,int,ch,source,char,at,i,if,ch,if,i,2,length,char,hex1,source,char,at,i,1,char,hex2,source,char,at,i,2,int,u,character,digit,hex1,16,int,l,character,digit,hex2,16,if,u,1,l,1,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,bos,write,char,u,4,l,i,2,changed,true,else,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,else,bos,write,ch,return,changed,new,string,bos,to,byte,array,charset,source
StringUtils -> public static String uriDecode(String source, Charset charset);1533557519;Decode the given encoded URI component value. Based on the following rules:_<ul>_<li>Alphanumeric characters {@code "a"} through {@code "z"}, {@code "A"} through {@code "Z"},_and {@code "0"} through {@code "9"} stay the same.</li>_<li>Special characters {@code "-"}, {@code "_"}, {@code "."}, and {@code "*"} stay the same.</li>_<li>A sequence "{@code %<i>xy</i>}" is interpreted as a hexadecimal representation of the character.</li>_</ul>_@param source the encoded String_@param charset the character set_@return the decoded value_@throws IllegalArgumentException when the given source contains invalid encoded sequences_@since 5.0_@see java.net.URLDecoder#decode(String, String);public static String uriDecode(String source, Charset charset) {_		int length = source.length()__		if (length == 0) {_			return source__		}_		Assert.notNull(charset, "Charset must not be null")___		ByteArrayOutputStream bos = new ByteArrayOutputStream(length)__		boolean changed = false__		for (int i = 0_ i < length_ i++) {_			int ch = source.charAt(i)__			if (ch == '%') {_				if (i + 2 < length) {_					char hex1 = source.charAt(i + 1)__					char hex2 = source.charAt(i + 2)__					int u = Character.digit(hex1, 16)__					int l = Character.digit(hex2, 16)__					if (u == -1 || l == -1) {_						throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__					}_					bos.write((char) ((u << 4) + l))__					i += 2__					changed = true__				}_				else {_					throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__				}_			}_			else {_				bos.write(ch)__			}_		}_		return (changed ? new String(bos.toByteArray(), charset) : source)__	};decode,the,given,encoded,uri,component,value,based,on,the,following,rules,ul,li,alphanumeric,characters,code,a,through,code,z,code,a,through,code,z,and,code,0,through,code,9,stay,the,same,li,li,special,characters,code,code,code,and,code,stay,the,same,li,li,a,sequence,code,i,xy,i,is,interpreted,as,a,hexadecimal,representation,of,the,character,li,ul,param,source,the,encoded,string,param,charset,the,character,set,return,the,decoded,value,throws,illegal,argument,exception,when,the,given,source,contains,invalid,encoded,sequences,since,5,0,see,java,net,urldecoder,decode,string,string;public,static,string,uri,decode,string,source,charset,charset,int,length,source,length,if,length,0,return,source,assert,not,null,charset,charset,must,not,be,null,byte,array,output,stream,bos,new,byte,array,output,stream,length,boolean,changed,false,for,int,i,0,i,length,i,int,ch,source,char,at,i,if,ch,if,i,2,length,char,hex1,source,char,at,i,1,char,hex2,source,char,at,i,2,int,u,character,digit,hex1,16,int,l,character,digit,hex2,16,if,u,1,l,1,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,bos,write,char,u,4,l,i,2,changed,true,else,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,else,bos,write,ch,return,changed,new,string,bos,to,byte,array,charset,source
StringUtils -> public static String uriDecode(String source, Charset charset);1533602820;Decode the given encoded URI component value. Based on the following rules:_<ul>_<li>Alphanumeric characters {@code "a"} through {@code "z"}, {@code "A"} through {@code "Z"},_and {@code "0"} through {@code "9"} stay the same.</li>_<li>Special characters {@code "-"}, {@code "_"}, {@code "."}, and {@code "*"} stay the same.</li>_<li>A sequence "{@code %<i>xy</i>}" is interpreted as a hexadecimal representation of the character.</li>_</ul>_@param source the encoded String_@param charset the character set_@return the decoded value_@throws IllegalArgumentException when the given source contains invalid encoded sequences_@since 5.0_@see java.net.URLDecoder#decode(String, String);public static String uriDecode(String source, Charset charset) {_		int length = source.length()__		if (length == 0) {_			return source__		}_		Assert.notNull(charset, "Charset must not be null")___		ByteArrayOutputStream bos = new ByteArrayOutputStream(length)__		boolean changed = false__		for (int i = 0_ i < length_ i++) {_			int ch = source.charAt(i)__			if (ch == '%') {_				if (i + 2 < length) {_					char hex1 = source.charAt(i + 1)__					char hex2 = source.charAt(i + 2)__					int u = Character.digit(hex1, 16)__					int l = Character.digit(hex2, 16)__					if (u == -1 || l == -1) {_						throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__					}_					bos.write((char) ((u << 4) + l))__					i += 2__					changed = true__				}_				else {_					throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__				}_			}_			else {_				bos.write(ch)__			}_		}_		return (changed ? new String(bos.toByteArray(), charset) : source)__	};decode,the,given,encoded,uri,component,value,based,on,the,following,rules,ul,li,alphanumeric,characters,code,a,through,code,z,code,a,through,code,z,and,code,0,through,code,9,stay,the,same,li,li,special,characters,code,code,code,and,code,stay,the,same,li,li,a,sequence,code,i,xy,i,is,interpreted,as,a,hexadecimal,representation,of,the,character,li,ul,param,source,the,encoded,string,param,charset,the,character,set,return,the,decoded,value,throws,illegal,argument,exception,when,the,given,source,contains,invalid,encoded,sequences,since,5,0,see,java,net,urldecoder,decode,string,string;public,static,string,uri,decode,string,source,charset,charset,int,length,source,length,if,length,0,return,source,assert,not,null,charset,charset,must,not,be,null,byte,array,output,stream,bos,new,byte,array,output,stream,length,boolean,changed,false,for,int,i,0,i,length,i,int,ch,source,char,at,i,if,ch,if,i,2,length,char,hex1,source,char,at,i,1,char,hex2,source,char,at,i,2,int,u,character,digit,hex1,16,int,l,character,digit,hex2,16,if,u,1,l,1,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,bos,write,char,u,4,l,i,2,changed,true,else,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,else,bos,write,ch,return,changed,new,string,bos,to,byte,array,charset,source
StringUtils -> public static String uriDecode(String source, Charset charset);1535316501;Decode the given encoded URI component value. Based on the following rules:_<ul>_<li>Alphanumeric characters {@code "a"} through {@code "z"}, {@code "A"} through {@code "Z"},_and {@code "0"} through {@code "9"} stay the same.</li>_<li>Special characters {@code "-"}, {@code "_"}, {@code "."}, and {@code "*"} stay the same.</li>_<li>A sequence "{@code %<i>xy</i>}" is interpreted as a hexadecimal representation of the character.</li>_</ul>_@param source the encoded String_@param charset the character set_@return the decoded value_@throws IllegalArgumentException when the given source contains invalid encoded sequences_@since 5.0_@see java.net.URLDecoder#decode(String, String);public static String uriDecode(String source, Charset charset) {_		int length = source.length()__		if (length == 0) {_			return source__		}_		Assert.notNull(charset, "Charset must not be null")___		ByteArrayOutputStream bos = new ByteArrayOutputStream(length)__		boolean changed = false__		for (int i = 0_ i < length_ i++) {_			int ch = source.charAt(i)__			if (ch == '%') {_				if (i + 2 < length) {_					char hex1 = source.charAt(i + 1)__					char hex2 = source.charAt(i + 2)__					int u = Character.digit(hex1, 16)__					int l = Character.digit(hex2, 16)__					if (u == -1 || l == -1) {_						throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__					}_					bos.write((char) ((u << 4) + l))__					i += 2__					changed = true__				}_				else {_					throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__				}_			}_			else {_				bos.write(ch)__			}_		}_		return (changed ? new String(bos.toByteArray(), charset) : source)__	};decode,the,given,encoded,uri,component,value,based,on,the,following,rules,ul,li,alphanumeric,characters,code,a,through,code,z,code,a,through,code,z,and,code,0,through,code,9,stay,the,same,li,li,special,characters,code,code,code,and,code,stay,the,same,li,li,a,sequence,code,i,xy,i,is,interpreted,as,a,hexadecimal,representation,of,the,character,li,ul,param,source,the,encoded,string,param,charset,the,character,set,return,the,decoded,value,throws,illegal,argument,exception,when,the,given,source,contains,invalid,encoded,sequences,since,5,0,see,java,net,urldecoder,decode,string,string;public,static,string,uri,decode,string,source,charset,charset,int,length,source,length,if,length,0,return,source,assert,not,null,charset,charset,must,not,be,null,byte,array,output,stream,bos,new,byte,array,output,stream,length,boolean,changed,false,for,int,i,0,i,length,i,int,ch,source,char,at,i,if,ch,if,i,2,length,char,hex1,source,char,at,i,1,char,hex2,source,char,at,i,2,int,u,character,digit,hex1,16,int,l,character,digit,hex2,16,if,u,1,l,1,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,bos,write,char,u,4,l,i,2,changed,true,else,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,else,bos,write,ch,return,changed,new,string,bos,to,byte,array,charset,source
StringUtils -> public static String uriDecode(String source, Charset charset);1550237113;Decode the given encoded URI component value. Based on the following rules:_<ul>_<li>Alphanumeric characters {@code "a"} through {@code "z"}, {@code "A"} through {@code "Z"},_and {@code "0"} through {@code "9"} stay the same.</li>_<li>Special characters {@code "-"}, {@code "_"}, {@code "."}, and {@code "*"} stay the same.</li>_<li>A sequence "{@code %<i>xy</i>}" is interpreted as a hexadecimal representation of the character.</li>_</ul>_@param source the encoded String_@param charset the character set_@return the decoded value_@throws IllegalArgumentException when the given source contains invalid encoded sequences_@since 5.0_@see java.net.URLDecoder#decode(String, String);public static String uriDecode(String source, Charset charset) {_		int length = source.length()__		if (length == 0) {_			return source__		}_		Assert.notNull(charset, "Charset must not be null")___		ByteArrayOutputStream bos = new ByteArrayOutputStream(length)__		boolean changed = false__		for (int i = 0_ i < length_ i++) {_			int ch = source.charAt(i)__			if (ch == '%') {_				if (i + 2 < length) {_					char hex1 = source.charAt(i + 1)__					char hex2 = source.charAt(i + 2)__					int u = Character.digit(hex1, 16)__					int l = Character.digit(hex2, 16)__					if (u == -1 || l == -1) {_						throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__					}_					bos.write((char) ((u << 4) + l))__					i += 2__					changed = true__				}_				else {_					throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__				}_			}_			else {_				bos.write(ch)__			}_		}_		return (changed ? new String(bos.toByteArray(), charset) : source)__	};decode,the,given,encoded,uri,component,value,based,on,the,following,rules,ul,li,alphanumeric,characters,code,a,through,code,z,code,a,through,code,z,and,code,0,through,code,9,stay,the,same,li,li,special,characters,code,code,code,and,code,stay,the,same,li,li,a,sequence,code,i,xy,i,is,interpreted,as,a,hexadecimal,representation,of,the,character,li,ul,param,source,the,encoded,string,param,charset,the,character,set,return,the,decoded,value,throws,illegal,argument,exception,when,the,given,source,contains,invalid,encoded,sequences,since,5,0,see,java,net,urldecoder,decode,string,string;public,static,string,uri,decode,string,source,charset,charset,int,length,source,length,if,length,0,return,source,assert,not,null,charset,charset,must,not,be,null,byte,array,output,stream,bos,new,byte,array,output,stream,length,boolean,changed,false,for,int,i,0,i,length,i,int,ch,source,char,at,i,if,ch,if,i,2,length,char,hex1,source,char,at,i,1,char,hex2,source,char,at,i,2,int,u,character,digit,hex1,16,int,l,character,digit,hex2,16,if,u,1,l,1,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,bos,write,char,u,4,l,i,2,changed,true,else,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,else,bos,write,ch,return,changed,new,string,bos,to,byte,array,charset,source
StringUtils -> public static String uriDecode(String source, Charset charset);1550238935;Decode the given encoded URI component value. Based on the following rules:_<ul>_<li>Alphanumeric characters {@code "a"} through {@code "z"}, {@code "A"} through {@code "Z"},_and {@code "0"} through {@code "9"} stay the same.</li>_<li>Special characters {@code "-"}, {@code "_"}, {@code "."}, and {@code "*"} stay the same.</li>_<li>A sequence "{@code %<i>xy</i>}" is interpreted as a hexadecimal representation of the character.</li>_</ul>_@param source the encoded String_@param charset the character set_@return the decoded value_@throws IllegalArgumentException when the given source contains invalid encoded sequences_@since 5.0_@see java.net.URLDecoder#decode(String, String);public static String uriDecode(String source, Charset charset) {_		int length = source.length()__		if (length == 0) {_			return source__		}_		Assert.notNull(charset, "Charset must not be null")___		ByteArrayOutputStream bos = new ByteArrayOutputStream(length)__		boolean changed = false__		for (int i = 0_ i < length_ i++) {_			int ch = source.charAt(i)__			if (ch == '%') {_				if (i + 2 < length) {_					char hex1 = source.charAt(i + 1)__					char hex2 = source.charAt(i + 2)__					int u = Character.digit(hex1, 16)__					int l = Character.digit(hex2, 16)__					if (u == -1 || l == -1) {_						throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__					}_					bos.write((char) ((u << 4) + l))__					i += 2__					changed = true__				}_				else {_					throw new IllegalArgumentException("Invalid encoded sequence \"" + source.substring(i) + "\"")__				}_			}_			else {_				bos.write(ch)__			}_		}_		return (changed ? new String(bos.toByteArray(), charset) : source)__	};decode,the,given,encoded,uri,component,value,based,on,the,following,rules,ul,li,alphanumeric,characters,code,a,through,code,z,code,a,through,code,z,and,code,0,through,code,9,stay,the,same,li,li,special,characters,code,code,code,and,code,stay,the,same,li,li,a,sequence,code,i,xy,i,is,interpreted,as,a,hexadecimal,representation,of,the,character,li,ul,param,source,the,encoded,string,param,charset,the,character,set,return,the,decoded,value,throws,illegal,argument,exception,when,the,given,source,contains,invalid,encoded,sequences,since,5,0,see,java,net,urldecoder,decode,string,string;public,static,string,uri,decode,string,source,charset,charset,int,length,source,length,if,length,0,return,source,assert,not,null,charset,charset,must,not,be,null,byte,array,output,stream,bos,new,byte,array,output,stream,length,boolean,changed,false,for,int,i,0,i,length,i,int,ch,source,char,at,i,if,ch,if,i,2,length,char,hex1,source,char,at,i,1,char,hex2,source,char,at,i,2,int,u,character,digit,hex1,16,int,l,character,digit,hex2,16,if,u,1,l,1,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,bos,write,char,u,4,l,i,2,changed,true,else,throw,new,illegal,argument,exception,invalid,encoded,sequence,source,substring,i,else,bos,write,ch,return,changed,new,string,bos,to,byte,array,charset,source
StringUtils -> public static String deleteAny(String inString, @Nullable String charsToDelete);1496837955;Delete any character in a given {@code String}._@param inString the original {@code String}_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting {@code String};public static String deleteAny(String inString, @Nullable String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}__		StringBuilder sb = new StringBuilder(inString.length())__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,code,string,param,in,string,the,original,code,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,code,string;public,static,string,delete,any,string,in,string,nullable,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,in,string,length,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, @Nullable String charsToDelete);1499270197;Delete any character in a given {@code String}._@param inString the original {@code String}_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting {@code String};public static String deleteAny(String inString, @Nullable String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}__		StringBuilder sb = new StringBuilder(inString.length())__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,code,string,param,in,string,the,original,code,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,code,string;public,static,string,delete,any,string,in,string,nullable,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,in,string,length,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, @Nullable String charsToDelete);1508667152;Delete any character in a given {@code String}._@param inString the original {@code String}_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting {@code String};public static String deleteAny(String inString, @Nullable String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}__		StringBuilder sb = new StringBuilder(inString.length())__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,code,string,param,in,string,the,original,code,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,code,string;public,static,string,delete,any,string,in,string,nullable,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,in,string,length,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, @Nullable String charsToDelete);1508675477;Delete any character in a given {@code String}._@param inString the original {@code String}_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting {@code String};public static String deleteAny(String inString, @Nullable String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}__		StringBuilder sb = new StringBuilder(inString.length())__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,code,string,param,in,string,the,original,code,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,code,string;public,static,string,delete,any,string,in,string,nullable,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,in,string,length,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, @Nullable String charsToDelete);1508843807;Delete any character in a given {@code String}._@param inString the original {@code String}_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting {@code String};public static String deleteAny(String inString, @Nullable String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}__		StringBuilder sb = new StringBuilder(inString.length())__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,code,string,param,in,string,the,original,code,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,code,string;public,static,string,delete,any,string,in,string,nullable,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,in,string,length,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, @Nullable String charsToDelete);1516903831;Delete any character in a given {@code String}._@param inString the original {@code String}_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting {@code String};public static String deleteAny(String inString, @Nullable String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}__		StringBuilder sb = new StringBuilder(inString.length())__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,code,string,param,in,string,the,original,code,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,code,string;public,static,string,delete,any,string,in,string,nullable,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,in,string,length,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, @Nullable String charsToDelete);1519295386;Delete any character in a given {@code String}._@param inString the original {@code String}_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting {@code String};public static String deleteAny(String inString, @Nullable String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}__		StringBuilder sb = new StringBuilder(inString.length())__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,code,string,param,in,string,the,original,code,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,code,string;public,static,string,delete,any,string,in,string,nullable,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,in,string,length,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, @Nullable String charsToDelete);1519308837;Delete any character in a given {@code String}._@param inString the original {@code String}_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting {@code String};public static String deleteAny(String inString, @Nullable String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}__		StringBuilder sb = new StringBuilder(inString.length())__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,code,string,param,in,string,the,original,code,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,code,string;public,static,string,delete,any,string,in,string,nullable,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,in,string,length,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, @Nullable String charsToDelete);1519588127;Delete any character in a given {@code String}._@param inString the original {@code String}_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting {@code String};public static String deleteAny(String inString, @Nullable String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}__		StringBuilder sb = new StringBuilder(inString.length())__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,code,string,param,in,string,the,original,code,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,code,string;public,static,string,delete,any,string,in,string,nullable,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,in,string,length,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, @Nullable String charsToDelete);1522332352;Delete any character in a given {@code String}._@param inString the original {@code String}_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting {@code String};public static String deleteAny(String inString, @Nullable String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}__		StringBuilder sb = new StringBuilder(inString.length())__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,code,string,param,in,string,the,original,code,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,code,string;public,static,string,delete,any,string,in,string,nullable,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,in,string,length,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, @Nullable String charsToDelete);1525166194;Delete any character in a given {@code String}._@param inString the original {@code String}_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting {@code String};public static String deleteAny(String inString, @Nullable String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}__		StringBuilder sb = new StringBuilder(inString.length())__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,code,string,param,in,string,the,original,code,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,code,string;public,static,string,delete,any,string,in,string,nullable,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,in,string,length,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, @Nullable String charsToDelete);1530188116;Delete any character in a given {@code String}._@param inString the original {@code String}_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting {@code String};public static String deleteAny(String inString, @Nullable String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}__		StringBuilder sb = new StringBuilder(inString.length())__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,code,string,param,in,string,the,original,code,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,code,string;public,static,string,delete,any,string,in,string,nullable,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,in,string,length,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, @Nullable String charsToDelete);1531843079;Delete any character in a given {@code String}._@param inString the original {@code String}_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting {@code String};public static String deleteAny(String inString, @Nullable String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}__		StringBuilder sb = new StringBuilder(inString.length())__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,code,string,param,in,string,the,original,code,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,code,string;public,static,string,delete,any,string,in,string,nullable,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,in,string,length,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, @Nullable String charsToDelete);1531905026;Delete any character in a given {@code String}._@param inString the original {@code String}_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting {@code String};public static String deleteAny(String inString, @Nullable String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}__		StringBuilder sb = new StringBuilder(inString.length())__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,code,string,param,in,string,the,original,code,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,code,string;public,static,string,delete,any,string,in,string,nullable,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,in,string,length,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, @Nullable String charsToDelete);1533557519;Delete any character in a given {@code String}._@param inString the original {@code String}_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting {@code String};public static String deleteAny(String inString, @Nullable String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}__		StringBuilder sb = new StringBuilder(inString.length())__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,code,string,param,in,string,the,original,code,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,code,string;public,static,string,delete,any,string,in,string,nullable,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,in,string,length,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, @Nullable String charsToDelete);1533602820;Delete any character in a given {@code String}._@param inString the original {@code String}_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting {@code String};public static String deleteAny(String inString, @Nullable String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}__		StringBuilder sb = new StringBuilder(inString.length())__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,code,string,param,in,string,the,original,code,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,code,string;public,static,string,delete,any,string,in,string,nullable,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,in,string,length,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, @Nullable String charsToDelete);1535316501;Delete any character in a given {@code String}._@param inString the original {@code String}_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting {@code String};public static String deleteAny(String inString, @Nullable String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}__		StringBuilder sb = new StringBuilder(inString.length())__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,code,string,param,in,string,the,original,code,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,code,string;public,static,string,delete,any,string,in,string,nullable,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,in,string,length,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, @Nullable String charsToDelete);1550237113;Delete any character in a given {@code String}._@param inString the original {@code String}_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting {@code String};public static String deleteAny(String inString, @Nullable String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}__		StringBuilder sb = new StringBuilder(inString.length())__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,code,string,param,in,string,the,original,code,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,code,string;public,static,string,delete,any,string,in,string,nullable,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,in,string,length,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String deleteAny(String inString, @Nullable String charsToDelete);1550238935;Delete any character in a given {@code String}._@param inString the original {@code String}_@param charsToDelete a set of characters to delete._E.g. "az\n" will delete 'a's, 'z's and new lines._@return the resulting {@code String};public static String deleteAny(String inString, @Nullable String charsToDelete) {_		if (!hasLength(inString) || !hasLength(charsToDelete)) {_			return inString__		}__		StringBuilder sb = new StringBuilder(inString.length())__		for (int i = 0_ i < inString.length()_ i++) {_			char c = inString.charAt(i)__			if (charsToDelete.indexOf(c) == -1) {_				sb.append(c)__			}_		}_		return sb.toString()__	};delete,any,character,in,a,given,code,string,param,in,string,the,original,code,string,param,chars,to,delete,a,set,of,characters,to,delete,e,g,az,n,will,delete,a,s,z,s,and,new,lines,return,the,resulting,code,string;public,static,string,delete,any,string,in,string,nullable,string,chars,to,delete,if,has,length,in,string,has,length,chars,to,delete,return,in,string,string,builder,sb,new,string,builder,in,string,length,for,int,i,0,i,in,string,length,i,char,c,in,string,char,at,i,if,chars,to,delete,index,of,c,1,sb,append,c,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1328020251;Trim leading whitespace from the given String._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,string,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1337236962;Trim leading whitespace from the given String._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,string,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1356735495;Trim leading whitespace from the given String._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,string,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1367955086;Trim leading whitespace from the given String._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,string,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1380921248;Trim leading whitespace from the given String._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,string,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1382750743;Trim leading whitespace from the given String._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,string,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1385423968;Trim leading whitespace from the given String._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,string,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1400189212;Trim leading whitespace from the given String._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,string,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1400531359;Trim leading whitespace from the given String._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,string,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1402676350;Trim leading whitespace from the given String._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,string,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1426267150;Trim leading whitespace from the given String._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,string,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1429034538;Trim leading whitespace from the given String._@param str the String to check_@return the trimmed String_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,string,param,str,the,string,to,check,return,the,trimmed,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1429034756;Trim leading whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1431006895;Trim leading whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1431007368;Trim leading whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1449489126;Trim leading whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1467730834;Trim leading whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1472128018;Trim leading whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1472202842;Trim leading whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1473942665;Trim leading whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1484248946;Trim leading whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1484260238;Trim leading whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1484694546;Trim leading whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1487760984;Trim leading whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1487778834;Trim leading whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}_		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1491898314;Trim leading whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1491903650;Trim leading whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1495868221;Trim leading whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1496243689;Trim leading whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1496259743;Trim leading whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1496837955;Trim leading whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1499270197;Trim leading whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1508667152;Trim leading whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1508675477;Trim leading whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1508843807;Trim leading whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1516903831;Trim leading whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1519295386;Trim leading whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1519308837;Trim leading whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1519588127;Trim leading whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1522332352;Trim leading whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1525166194;Trim leading whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1530188116;Trim leading whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1531843079;Trim leading whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1531905026;Trim leading whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1533557519;Trim leading whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1533602820;Trim leading whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1535316501;Trim leading whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1550237113;Trim leading whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String trimLeadingWhitespace(String str);1550238935;Trim leading whitespace from the given {@code String}._@param str the {@code String} to check_@return the trimmed {@code String}_@see java.lang.Character#isWhitespace;public static String trimLeadingWhitespace(String str) {_		if (!hasLength(str)) {_			return str__		}__		StringBuilder sb = new StringBuilder(str)__		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {_			sb.deleteCharAt(0)__		}_		return sb.toString()__	};trim,leading,whitespace,from,the,given,code,string,param,str,the,code,string,to,check,return,the,trimmed,code,string,see,java,lang,character,is,whitespace;public,static,string,trim,leading,whitespace,string,str,if,has,length,str,return,str,string,builder,sb,new,string,builder,str,while,sb,length,0,character,is,whitespace,sb,char,at,0,sb,delete,char,at,0,return,sb,to,string
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim);1328020251;Convenience method to return a Collection as a delimited (e.g. CSV)_String. E.g. useful for <code>toString()</code> implementations._@param coll the Collection to display_@param delim the delimiter to use (probably a ",")_@return the delimited String;public static String collectionToDelimitedString(Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convenience,method,to,return,a,collection,as,a,delimited,e,g,csv,string,e,g,useful,for,code,to,string,code,implementations,param,coll,the,collection,to,display,param,delim,the,delimiter,to,use,probably,a,return,the,delimited,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim);1337236962;Convenience method to return a Collection as a delimited (e.g. CSV)_String. E.g. useful for <code>toString()</code> implementations._@param coll the Collection to display_@param delim the delimiter to use (probably a ",")_@return the delimited String;public static String collectionToDelimitedString(Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convenience,method,to,return,a,collection,as,a,delimited,e,g,csv,string,e,g,useful,for,code,to,string,code,implementations,param,coll,the,collection,to,display,param,delim,the,delimiter,to,use,probably,a,return,the,delimited,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim);1356735495;Convenience method to return a Collection as a delimited (e.g. CSV)_String. E.g. useful for {@code toString()} implementations._@param coll the Collection to display_@param delim the delimiter to use (probably a ",")_@return the delimited String;public static String collectionToDelimitedString(Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convenience,method,to,return,a,collection,as,a,delimited,e,g,csv,string,e,g,useful,for,code,to,string,implementations,param,coll,the,collection,to,display,param,delim,the,delimiter,to,use,probably,a,return,the,delimited,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim);1367955086;Convenience method to return a Collection as a delimited (e.g. CSV)_String. E.g. useful for {@code toString()} implementations._@param coll the Collection to display_@param delim the delimiter to use (probably a ",")_@return the delimited String;public static String collectionToDelimitedString(Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convenience,method,to,return,a,collection,as,a,delimited,e,g,csv,string,e,g,useful,for,code,to,string,implementations,param,coll,the,collection,to,display,param,delim,the,delimiter,to,use,probably,a,return,the,delimited,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim);1380921248;Convenience method to return a Collection as a delimited (e.g. CSV)_String. E.g. useful for {@code toString()} implementations._@param coll the Collection to display_@param delim the delimiter to use (probably a ",")_@return the delimited String;public static String collectionToDelimitedString(Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convenience,method,to,return,a,collection,as,a,delimited,e,g,csv,string,e,g,useful,for,code,to,string,implementations,param,coll,the,collection,to,display,param,delim,the,delimiter,to,use,probably,a,return,the,delimited,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim);1382750743;Convenience method to return a Collection as a delimited (e.g. CSV)_String. E.g. useful for {@code toString()} implementations._@param coll the Collection to display_@param delim the delimiter to use (probably a ",")_@return the delimited String;public static String collectionToDelimitedString(Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convenience,method,to,return,a,collection,as,a,delimited,e,g,csv,string,e,g,useful,for,code,to,string,implementations,param,coll,the,collection,to,display,param,delim,the,delimiter,to,use,probably,a,return,the,delimited,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim);1385423968;Convenience method to return a Collection as a delimited (e.g. CSV)_String. E.g. useful for {@code toString()} implementations._@param coll the Collection to display_@param delim the delimiter to use (probably a ",")_@return the delimited String;public static String collectionToDelimitedString(Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convenience,method,to,return,a,collection,as,a,delimited,e,g,csv,string,e,g,useful,for,code,to,string,implementations,param,coll,the,collection,to,display,param,delim,the,delimiter,to,use,probably,a,return,the,delimited,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim);1400189212;Convenience method to return a Collection as a delimited (e.g. CSV)_String. E.g. useful for {@code toString()} implementations._@param coll the Collection to display_@param delim the delimiter to use (probably a ",")_@return the delimited String;public static String collectionToDelimitedString(Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convenience,method,to,return,a,collection,as,a,delimited,e,g,csv,string,e,g,useful,for,code,to,string,implementations,param,coll,the,collection,to,display,param,delim,the,delimiter,to,use,probably,a,return,the,delimited,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim);1400531359;Convenience method to return a Collection as a delimited (e.g. CSV)_String. E.g. useful for {@code toString()} implementations._@param coll the Collection to display_@param delim the delimiter to use (probably a ",")_@return the delimited String;public static String collectionToDelimitedString(Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convenience,method,to,return,a,collection,as,a,delimited,e,g,csv,string,e,g,useful,for,code,to,string,implementations,param,coll,the,collection,to,display,param,delim,the,delimiter,to,use,probably,a,return,the,delimited,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim);1402676350;Convenience method to return a Collection as a delimited (e.g. CSV)_String. E.g. useful for {@code toString()} implementations._@param coll the Collection to display_@param delim the delimiter to use (probably a ",")_@return the delimited String;public static String collectionToDelimitedString(Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convenience,method,to,return,a,collection,as,a,delimited,e,g,csv,string,e,g,useful,for,code,to,string,implementations,param,coll,the,collection,to,display,param,delim,the,delimiter,to,use,probably,a,return,the,delimited,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim);1426267150;Convenience method to return a Collection as a delimited (e.g. CSV)_String. E.g. useful for {@code toString()} implementations._@param coll the Collection to display_@param delim the delimiter to use (probably a ",")_@return the delimited String;public static String collectionToDelimitedString(Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convenience,method,to,return,a,collection,as,a,delimited,e,g,csv,string,e,g,useful,for,code,to,string,implementations,param,coll,the,collection,to,display,param,delim,the,delimiter,to,use,probably,a,return,the,delimited,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim);1429034538;Convenience method to return a Collection as a delimited (e.g. CSV)_String. E.g. useful for {@code toString()} implementations._@param coll the Collection to display_@param delim the delimiter to use (probably a ",")_@return the delimited String;public static String collectionToDelimitedString(Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convenience,method,to,return,a,collection,as,a,delimited,e,g,csv,string,e,g,useful,for,code,to,string,implementations,param,coll,the,collection,to,display,param,delim,the,delimiter,to,use,probably,a,return,the,delimited,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim);1429034756;Convert a {@code Collection} into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String collectionToDelimitedString(Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim);1431006895;Convert a {@code Collection} into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String collectionToDelimitedString(Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim);1431007368;Convert a {@code Collection} into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String collectionToDelimitedString(Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim);1449489126;Convert a {@code Collection} into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String collectionToDelimitedString(Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim);1467730834;Convert a {@code Collection} into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String collectionToDelimitedString(Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim);1472128018;Convert a {@code Collection} into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String collectionToDelimitedString(Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim);1472202842;Convert a {@code Collection} into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String collectionToDelimitedString(Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim);1473942665;Convert a {@code Collection} into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String collectionToDelimitedString(Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim);1484248946;Convert a {@code Collection} into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String collectionToDelimitedString(Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim);1484260238;Convert a {@code Collection} into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String collectionToDelimitedString(Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim);1484694546;Convert a {@code Collection} into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String collectionToDelimitedString(Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim);1487760984;Convert a {@code Collection} into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String collectionToDelimitedString(Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim);1487778834;Convert a {@code Collection} into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String collectionToDelimitedString(Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim);1491898314;Convert a {@code Collection} into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String collectionToDelimitedString(Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim);1491903650;Convert a {@code Collection} into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String collectionToDelimitedString(Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim);1495868221;Convert a {@code Collection} into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String collectionToDelimitedString(Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim);1496243689;Convert a {@code Collection} into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String collectionToDelimitedString(Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(Collection<?> coll, String delim);1496259743;Convert a {@code Collection} into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String collectionToDelimitedString(Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> @Nullable 	public static String stripFilenameExtension(@Nullable String path);1495868221;Strip the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path (may be {@code null})_@return the path with stripped filename extension,_or {@code null} if none;@Nullable_	public static String stripFilenameExtension(@Nullable String path) {_		if (path == null) {_			return null__		}__		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}__		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,may,be,code,null,return,the,path,with,stripped,filename,extension,or,code,null,if,none;nullable,public,static,string,strip,filename,extension,nullable,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> @Nullable 	public static String stripFilenameExtension(@Nullable String path);1496243689;Strip the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path (may be {@code null})_@return the path with stripped filename extension,_or {@code null} if none;@Nullable_	public static String stripFilenameExtension(@Nullable String path) {_		if (path == null) {_			return null__		}__		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}__		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,may,be,code,null,return,the,path,with,stripped,filename,extension,or,code,null,if,none;nullable,public,static,string,strip,filename,extension,nullable,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> @Nullable 	public static String stripFilenameExtension(@Nullable String path);1496259743;Strip the filename extension from the given Java resource path,_e.g. "mypath/myfile.txt" -> "mypath/myfile"._@param path the file path (may be {@code null})_@return the path with stripped filename extension,_or {@code null} if none;@Nullable_	public static String stripFilenameExtension(@Nullable String path) {_		if (path == null) {_			return null__		}__		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR)__		if (extIndex == -1) {_			return path__		}__		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR)__		if (folderIndex > extIndex) {_			return path__		}__		return path.substring(0, extIndex)__	};strip,the,filename,extension,from,the,given,java,resource,path,e,g,mypath,myfile,txt,mypath,myfile,param,path,the,file,path,may,be,code,null,return,the,path,with,stripped,filename,extension,or,code,null,if,none;nullable,public,static,string,strip,filename,extension,nullable,string,path,if,path,null,return,null,int,ext,index,path,last,index,of,if,ext,index,1,return,path,int,folder,index,path,last,index,of,if,folder,index,ext,index,return,path,return,path,substring,0,ext,index
StringUtils -> public static Locale parseLocaleString(String localeString);1328020251;Parse the given <code>localeString</code> value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale string, following <code>Locale's</code>_<code>toString()</code> format ("en", "en_UK", etc)__also accepts spaces as separators, as an alternative to underscores_@return a corresponding <code>Locale</code> instance;public static Locale parseLocaleString(String localeString) {_		String[] parts = tokenizeToStringArray(localeString, "_ ", false, false)__		String language = (parts.length > 0 ? parts[0] : "")__		String country = (parts.length > 1 ? parts[1] : "")__		validateLocalePart(language)__		validateLocalePart(country)__		String variant = ""__		if (parts.length >= 2) {_			_			_			int endIndexOfCountryCode = localeString.indexOf(country) + country.length()__			_			variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode))__			if (variant.startsWith("_")) {_				variant = trimLeadingCharacter(variant, '_')__			}_		}_		return (language.length() > 0 ? new Locale(language, country, variant) : null)__	};parse,the,given,code,locale,string,code,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,string,following,code,locale,s,code,code,to,string,code,format,en,etc,also,accepts,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,code,instance;public,static,locale,parse,locale,string,string,locale,string,string,parts,tokenize,to,string,array,locale,string,false,false,string,language,parts,length,0,parts,0,string,country,parts,length,1,parts,1,validate,locale,part,language,validate,locale,part,country,string,variant,if,parts,length,2,int,end,index,of,country,code,locale,string,index,of,country,country,length,variant,trim,leading,whitespace,locale,string,substring,end,index,of,country,code,if,variant,starts,with,variant,trim,leading,character,variant,return,language,length,0,new,locale,language,country,variant,null
StringUtils -> public static Locale parseLocaleString(String localeString);1337236962;Parse the given <code>localeString</code> value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale string, following <code>Locale's</code>_<code>toString()</code> format ("en", "en_UK", etc)__also accepts spaces as separators, as an alternative to underscores_@return a corresponding <code>Locale</code> instance;public static Locale parseLocaleString(String localeString) {_		String[] parts = tokenizeToStringArray(localeString, "_ ", false, false)__		String language = (parts.length > 0 ? parts[0] : "")__		String country = (parts.length > 1 ? parts[1] : "")__		validateLocalePart(language)__		validateLocalePart(country)__		String variant = ""__		if (parts.length >= 2) {_			_			_			int endIndexOfCountryCode = localeString.lastIndexOf(country) + country.length()__			_			variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode))__			if (variant.startsWith("_")) {_				variant = trimLeadingCharacter(variant, '_')__			}_		}_		return (language.length() > 0 ? new Locale(language, country, variant) : null)__	};parse,the,given,code,locale,string,code,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,string,following,code,locale,s,code,code,to,string,code,format,en,etc,also,accepts,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,code,instance;public,static,locale,parse,locale,string,string,locale,string,string,parts,tokenize,to,string,array,locale,string,false,false,string,language,parts,length,0,parts,0,string,country,parts,length,1,parts,1,validate,locale,part,language,validate,locale,part,country,string,variant,if,parts,length,2,int,end,index,of,country,code,locale,string,last,index,of,country,country,length,variant,trim,leading,whitespace,locale,string,substring,end,index,of,country,code,if,variant,starts,with,variant,trim,leading,character,variant,return,language,length,0,new,locale,language,country,variant,null
StringUtils -> public static Locale parseLocaleString(String localeString);1356735495;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale string, following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc)__also accepts spaces as separators, as an alternative to underscores_@return a corresponding {@code Locale} instance;public static Locale parseLocaleString(String localeString) {_		String[] parts = tokenizeToStringArray(localeString, "_ ", false, false)__		String language = (parts.length > 0 ? parts[0] : "")__		String country = (parts.length > 1 ? parts[1] : "")__		validateLocalePart(language)__		validateLocalePart(country)__		String variant = ""__		if (parts.length >= 2) {_			_			_			int endIndexOfCountryCode = localeString.lastIndexOf(country) + country.length()__			_			variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode))__			if (variant.startsWith("_")) {_				variant = trimLeadingCharacter(variant, '_')__			}_		}_		return (language.length() > 0 ? new Locale(language, country, variant) : null)__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,string,following,code,locale,s,code,to,string,format,en,etc,also,accepts,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance;public,static,locale,parse,locale,string,string,locale,string,string,parts,tokenize,to,string,array,locale,string,false,false,string,language,parts,length,0,parts,0,string,country,parts,length,1,parts,1,validate,locale,part,language,validate,locale,part,country,string,variant,if,parts,length,2,int,end,index,of,country,code,locale,string,last,index,of,country,country,length,variant,trim,leading,whitespace,locale,string,substring,end,index,of,country,code,if,variant,starts,with,variant,trim,leading,character,variant,return,language,length,0,new,locale,language,country,variant,null
StringUtils -> public static Locale parseLocaleString(String localeString);1367955086;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale string, following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc)__also accepts spaces as separators, as an alternative to underscores_@return a corresponding {@code Locale} instance;public static Locale parseLocaleString(String localeString) {_		String[] parts = tokenizeToStringArray(localeString, "_ ", false, false)__		String language = (parts.length > 0 ? parts[0] : "")__		String country = (parts.length > 1 ? parts[1] : "")__		validateLocalePart(language)__		validateLocalePart(country)__		String variant = ""__		if (parts.length >= 2) {_			_			_			int endIndexOfCountryCode = localeString.lastIndexOf(country) + country.length()__			_			variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode))__			if (variant.startsWith("_")) {_				variant = trimLeadingCharacter(variant, '_')__			}_		}_		return (language.length() > 0 ? new Locale(language, country, variant) : null)__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,string,following,code,locale,s,code,to,string,format,en,etc,also,accepts,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance;public,static,locale,parse,locale,string,string,locale,string,string,parts,tokenize,to,string,array,locale,string,false,false,string,language,parts,length,0,parts,0,string,country,parts,length,1,parts,1,validate,locale,part,language,validate,locale,part,country,string,variant,if,parts,length,2,int,end,index,of,country,code,locale,string,last,index,of,country,country,length,variant,trim,leading,whitespace,locale,string,substring,end,index,of,country,code,if,variant,starts,with,variant,trim,leading,character,variant,return,language,length,0,new,locale,language,country,variant,null
StringUtils -> public static Locale parseLocaleString(String localeString);1380921248;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale String, following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc)__also accepts spaces as separators, as an alternative to underscores_@return a corresponding {@code Locale} instance_@throws IllegalArgumentException in case of an invalid locale specification;public static Locale parseLocaleString(String localeString) {_		String[] parts = tokenizeToStringArray(localeString, "_ ", false, false)__		String language = (parts.length > 0 ? parts[0] : "")__		String country = (parts.length > 1 ? parts[1] : "")__		validateLocalePart(language)__		validateLocalePart(country)__		String variant = ""__		if (parts.length >= 2) {_			_			_			int endIndexOfCountryCode = localeString.lastIndexOf(country) + country.length()__			_			variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode))__			if (variant.startsWith("_")) {_				variant = trimLeadingCharacter(variant, '_')__			}_		}_		return (language.length() > 0 ? new Locale(language, country, variant) : null)__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,string,following,code,locale,s,code,to,string,format,en,etc,also,accepts,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;public,static,locale,parse,locale,string,string,locale,string,string,parts,tokenize,to,string,array,locale,string,false,false,string,language,parts,length,0,parts,0,string,country,parts,length,1,parts,1,validate,locale,part,language,validate,locale,part,country,string,variant,if,parts,length,2,int,end,index,of,country,code,locale,string,last,index,of,country,country,length,variant,trim,leading,whitespace,locale,string,substring,end,index,of,country,code,if,variant,starts,with,variant,trim,leading,character,variant,return,language,length,0,new,locale,language,country,variant,null
StringUtils -> public static Locale parseLocaleString(String localeString);1382750743;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale String, following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc)__also accepts spaces as separators, as an alternative to underscores_@return a corresponding {@code Locale} instance_@throws IllegalArgumentException in case of an invalid locale specification;public static Locale parseLocaleString(String localeString) {_		String[] parts = tokenizeToStringArray(localeString, "_ ", false, false)__		String language = (parts.length > 0 ? parts[0] : "")__		String country = (parts.length > 1 ? parts[1] : "")__		validateLocalePart(language)__		validateLocalePart(country)__		String variant = ""__		if (parts.length > 2) {_			_			_			int endIndexOfCountryCode = localeString.lastIndexOf(country) + country.length()__			_			variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode))__			if (variant.startsWith("_")) {_				variant = trimLeadingCharacter(variant, '_')__			}_		}_		return (language.length() > 0 ? new Locale(language, country, variant) : null)__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,string,following,code,locale,s,code,to,string,format,en,etc,also,accepts,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;public,static,locale,parse,locale,string,string,locale,string,string,parts,tokenize,to,string,array,locale,string,false,false,string,language,parts,length,0,parts,0,string,country,parts,length,1,parts,1,validate,locale,part,language,validate,locale,part,country,string,variant,if,parts,length,2,int,end,index,of,country,code,locale,string,last,index,of,country,country,length,variant,trim,leading,whitespace,locale,string,substring,end,index,of,country,code,if,variant,starts,with,variant,trim,leading,character,variant,return,language,length,0,new,locale,language,country,variant,null
StringUtils -> public static Locale parseLocaleString(String localeString);1385423968;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale String, following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc)__also accepts spaces as separators, as an alternative to underscores_@return a corresponding {@code Locale} instance_@throws IllegalArgumentException in case of an invalid locale specification;public static Locale parseLocaleString(String localeString) {_		String[] parts = tokenizeToStringArray(localeString, "_ ", false, false)__		String language = (parts.length > 0 ? parts[0] : "")__		String country = (parts.length > 1 ? parts[1] : "")__		validateLocalePart(language)__		validateLocalePart(country)__		String variant = ""__		if (parts.length > 2) {_			_			_			int endIndexOfCountryCode = localeString.lastIndexOf(country) + country.length()__			_			variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode))__			if (variant.startsWith("_")) {_				variant = trimLeadingCharacter(variant, '_')__			}_		}_		return (language.length() > 0 ? new Locale(language, country, variant) : null)__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,string,following,code,locale,s,code,to,string,format,en,etc,also,accepts,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;public,static,locale,parse,locale,string,string,locale,string,string,parts,tokenize,to,string,array,locale,string,false,false,string,language,parts,length,0,parts,0,string,country,parts,length,1,parts,1,validate,locale,part,language,validate,locale,part,country,string,variant,if,parts,length,2,int,end,index,of,country,code,locale,string,last,index,of,country,country,length,variant,trim,leading,whitespace,locale,string,substring,end,index,of,country,code,if,variant,starts,with,variant,trim,leading,character,variant,return,language,length,0,new,locale,language,country,variant,null
StringUtils -> public static Locale parseLocaleString(String localeString);1400189212;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale String, following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc)__also accepts spaces as separators, as an alternative to underscores_@return a corresponding {@code Locale} instance_@throws IllegalArgumentException in case of an invalid locale specification;public static Locale parseLocaleString(String localeString) {_		String[] parts = tokenizeToStringArray(localeString, "_ ", false, false)__		String language = (parts.length > 0 ? parts[0] : "")__		String country = (parts.length > 1 ? parts[1] : "")__		validateLocalePart(language)__		validateLocalePart(country)__		String variant = ""__		if (parts.length > 2) {_			_			_			int endIndexOfCountryCode = localeString.lastIndexOf(country) + country.length()__			_			variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode))__			if (variant.startsWith("_")) {_				variant = trimLeadingCharacter(variant, '_')__			}_		}_		return (language.length() > 0 ? new Locale(language, country, variant) : null)__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,string,following,code,locale,s,code,to,string,format,en,etc,also,accepts,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;public,static,locale,parse,locale,string,string,locale,string,string,parts,tokenize,to,string,array,locale,string,false,false,string,language,parts,length,0,parts,0,string,country,parts,length,1,parts,1,validate,locale,part,language,validate,locale,part,country,string,variant,if,parts,length,2,int,end,index,of,country,code,locale,string,last,index,of,country,country,length,variant,trim,leading,whitespace,locale,string,substring,end,index,of,country,code,if,variant,starts,with,variant,trim,leading,character,variant,return,language,length,0,new,locale,language,country,variant,null
StringUtils -> public static Locale parseLocaleString(String localeString);1400531359;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale String, following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc)__also accepts spaces as separators, as an alternative to underscores_@return a corresponding {@code Locale} instance_@throws IllegalArgumentException in case of an invalid locale specification;public static Locale parseLocaleString(String localeString) {_		String[] parts = tokenizeToStringArray(localeString, "_ ", false, false)__		String language = (parts.length > 0 ? parts[0] : "")__		String country = (parts.length > 1 ? parts[1] : "")__		validateLocalePart(language)__		validateLocalePart(country)__		String variant = ""__		if (parts.length > 2) {_			_			_			int endIndexOfCountryCode = localeString.indexOf(country, language.length()) + country.length()__			_			variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode))__			if (variant.startsWith("_")) {_				variant = trimLeadingCharacter(variant, '_')__			}_		}_		return (language.length() > 0 ? new Locale(language, country, variant) : null)__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,string,following,code,locale,s,code,to,string,format,en,etc,also,accepts,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;public,static,locale,parse,locale,string,string,locale,string,string,parts,tokenize,to,string,array,locale,string,false,false,string,language,parts,length,0,parts,0,string,country,parts,length,1,parts,1,validate,locale,part,language,validate,locale,part,country,string,variant,if,parts,length,2,int,end,index,of,country,code,locale,string,index,of,country,language,length,country,length,variant,trim,leading,whitespace,locale,string,substring,end,index,of,country,code,if,variant,starts,with,variant,trim,leading,character,variant,return,language,length,0,new,locale,language,country,variant,null
StringUtils -> public static Locale parseLocaleString(String localeString);1402676350;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale String, following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc)__also accepts spaces as separators, as an alternative to underscores_@return a corresponding {@code Locale} instance_@throws IllegalArgumentException in case of an invalid locale specification;public static Locale parseLocaleString(String localeString) {_		String[] parts = tokenizeToStringArray(localeString, "_ ", false, false)__		String language = (parts.length > 0 ? parts[0] : "")__		String country = (parts.length > 1 ? parts[1] : "")__		validateLocalePart(language)__		validateLocalePart(country)__		String variant = ""__		if (parts.length > 2) {_			_			_			int endIndexOfCountryCode = localeString.indexOf(country, language.length()) + country.length()__			_			variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode))__			if (variant.startsWith("_")) {_				variant = trimLeadingCharacter(variant, '_')__			}_		}_		return (language.length() > 0 ? new Locale(language, country, variant) : null)__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,string,following,code,locale,s,code,to,string,format,en,etc,also,accepts,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;public,static,locale,parse,locale,string,string,locale,string,string,parts,tokenize,to,string,array,locale,string,false,false,string,language,parts,length,0,parts,0,string,country,parts,length,1,parts,1,validate,locale,part,language,validate,locale,part,country,string,variant,if,parts,length,2,int,end,index,of,country,code,locale,string,index,of,country,language,length,country,length,variant,trim,leading,whitespace,locale,string,substring,end,index,of,country,code,if,variant,starts,with,variant,trim,leading,character,variant,return,language,length,0,new,locale,language,country,variant,null
StringUtils -> public static Locale parseLocaleString(String localeString);1426267150;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale String, following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc)__also accepts spaces as separators, as an alternative to underscores_@return a corresponding {@code Locale} instance_@throws IllegalArgumentException in case of an invalid locale specification;public static Locale parseLocaleString(String localeString) {_		String[] parts = tokenizeToStringArray(localeString, "_ ", false, false)__		String language = (parts.length > 0 ? parts[0] : "")__		String country = (parts.length > 1 ? parts[1] : "")__		validateLocalePart(language)__		validateLocalePart(country)__		String variant = ""__		if (parts.length > 2) {_			_			_			int endIndexOfCountryCode = localeString.indexOf(country, language.length()) + country.length()__			_			variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode))__			if (variant.startsWith("_")) {_				variant = trimLeadingCharacter(variant, '_')__			}_		}_		return (language.length() > 0 ? new Locale(language, country, variant) : null)__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,string,following,code,locale,s,code,to,string,format,en,etc,also,accepts,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;public,static,locale,parse,locale,string,string,locale,string,string,parts,tokenize,to,string,array,locale,string,false,false,string,language,parts,length,0,parts,0,string,country,parts,length,1,parts,1,validate,locale,part,language,validate,locale,part,country,string,variant,if,parts,length,2,int,end,index,of,country,code,locale,string,index,of,country,language,length,country,length,variant,trim,leading,whitespace,locale,string,substring,end,index,of,country,code,if,variant,starts,with,variant,trim,leading,character,variant,return,language,length,0,new,locale,language,country,variant,null
StringUtils -> public static Locale parseLocaleString(String localeString);1429034538;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale String, following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc)__also accepts spaces as separators, as an alternative to underscores_@return a corresponding {@code Locale} instance_@throws IllegalArgumentException in case of an invalid locale specification;public static Locale parseLocaleString(String localeString) {_		String[] parts = tokenizeToStringArray(localeString, "_ ", false, false)__		String language = (parts.length > 0 ? parts[0] : "")__		String country = (parts.length > 1 ? parts[1] : "")__		validateLocalePart(language)__		validateLocalePart(country)__		String variant = ""__		if (parts.length > 2) {_			_			_			int endIndexOfCountryCode = localeString.indexOf(country, language.length()) + country.length()__			_			variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode))__			if (variant.startsWith("_")) {_				variant = trimLeadingCharacter(variant, '_')__			}_		}_		return (language.length() > 0 ? new Locale(language, country, variant) : null)__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,string,following,code,locale,s,code,to,string,format,en,etc,also,accepts,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;public,static,locale,parse,locale,string,string,locale,string,string,parts,tokenize,to,string,array,locale,string,false,false,string,language,parts,length,0,parts,0,string,country,parts,length,1,parts,1,validate,locale,part,language,validate,locale,part,country,string,variant,if,parts,length,2,int,end,index,of,country,code,locale,string,index,of,country,language,length,country,length,variant,trim,leading,whitespace,locale,string,substring,end,index,of,country,code,if,variant,starts,with,variant,trim,leading,character,variant,return,language,length,0,new,locale,language,country,variant,null
StringUtils -> public static Locale parseLocaleString(String localeString);1429034756;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale {@code String}, following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc)__also accepts spaces as separators, as an alternative to underscores_@return a corresponding {@code Locale} instance_@throws IllegalArgumentException in case of an invalid locale specification;public static Locale parseLocaleString(String localeString) {_		String[] parts = tokenizeToStringArray(localeString, "_ ", false, false)__		String language = (parts.length > 0 ? parts[0] : "")__		String country = (parts.length > 1 ? parts[1] : "")__		validateLocalePart(language)__		validateLocalePart(country)__		String variant = ""__		if (parts.length > 2) {_			_			_			int endIndexOfCountryCode = localeString.indexOf(country, language.length()) + country.length()__			_			variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode))__			if (variant.startsWith("_")) {_				variant = trimLeadingCharacter(variant, '_')__			}_		}_		return (language.length() > 0 ? new Locale(language, country, variant) : null)__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,code,string,following,code,locale,s,code,to,string,format,en,etc,also,accepts,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;public,static,locale,parse,locale,string,string,locale,string,string,parts,tokenize,to,string,array,locale,string,false,false,string,language,parts,length,0,parts,0,string,country,parts,length,1,parts,1,validate,locale,part,language,validate,locale,part,country,string,variant,if,parts,length,2,int,end,index,of,country,code,locale,string,index,of,country,language,length,country,length,variant,trim,leading,whitespace,locale,string,substring,end,index,of,country,code,if,variant,starts,with,variant,trim,leading,character,variant,return,language,length,0,new,locale,language,country,variant,null
StringUtils -> public static Locale parseLocaleString(String localeString);1431006895;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale {@code String}, following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc)__also accepts spaces as separators, as an alternative to underscores_@return a corresponding {@code Locale} instance_@throws IllegalArgumentException in case of an invalid locale specification;public static Locale parseLocaleString(String localeString) {_		String[] parts = tokenizeToStringArray(localeString, "_ ", false, false)__		String language = (parts.length > 0 ? parts[0] : "")__		String country = (parts.length > 1 ? parts[1] : "")__		validateLocalePart(language)__		validateLocalePart(country)__		String variant = ""__		if (parts.length > 2) {_			_			_			int endIndexOfCountryCode = localeString.indexOf(country, language.length()) + country.length()__			_			variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode))__			if (variant.startsWith("_")) {_				variant = trimLeadingCharacter(variant, '_')__			}_		}_		return (language.length() > 0 ? new Locale(language, country, variant) : null)__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,code,string,following,code,locale,s,code,to,string,format,en,etc,also,accepts,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;public,static,locale,parse,locale,string,string,locale,string,string,parts,tokenize,to,string,array,locale,string,false,false,string,language,parts,length,0,parts,0,string,country,parts,length,1,parts,1,validate,locale,part,language,validate,locale,part,country,string,variant,if,parts,length,2,int,end,index,of,country,code,locale,string,index,of,country,language,length,country,length,variant,trim,leading,whitespace,locale,string,substring,end,index,of,country,code,if,variant,starts,with,variant,trim,leading,character,variant,return,language,length,0,new,locale,language,country,variant,null
StringUtils -> public static Locale parseLocaleString(String localeString);1431007368;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale {@code String}, following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc)__also accepts spaces as separators, as an alternative to underscores_@return a corresponding {@code Locale} instance_@throws IllegalArgumentException in case of an invalid locale specification;public static Locale parseLocaleString(String localeString) {_		String[] parts = tokenizeToStringArray(localeString, "_ ", false, false)__		String language = (parts.length > 0 ? parts[0] : "")__		String country = (parts.length > 1 ? parts[1] : "")__		validateLocalePart(language)__		validateLocalePart(country)__		String variant = ""__		if (parts.length > 2) {_			_			_			int endIndexOfCountryCode = localeString.indexOf(country, language.length()) + country.length()__			_			variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode))__			if (variant.startsWith("_")) {_				variant = trimLeadingCharacter(variant, '_')__			}_		}_		return (language.length() > 0 ? new Locale(language, country, variant) : null)__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,code,string,following,code,locale,s,code,to,string,format,en,etc,also,accepts,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;public,static,locale,parse,locale,string,string,locale,string,string,parts,tokenize,to,string,array,locale,string,false,false,string,language,parts,length,0,parts,0,string,country,parts,length,1,parts,1,validate,locale,part,language,validate,locale,part,country,string,variant,if,parts,length,2,int,end,index,of,country,code,locale,string,index,of,country,language,length,country,length,variant,trim,leading,whitespace,locale,string,substring,end,index,of,country,code,if,variant,starts,with,variant,trim,leading,character,variant,return,language,length,0,new,locale,language,country,variant,null
StringUtils -> public static Locale parseLocaleString(String localeString);1449489126;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale {@code String}, following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc)__also accepts spaces as separators, as an alternative to underscores_@return a corresponding {@code Locale} instance_@throws IllegalArgumentException in case of an invalid locale specification;public static Locale parseLocaleString(String localeString) {_		String[] parts = tokenizeToStringArray(localeString, "_ ", false, false)__		String language = (parts.length > 0 ? parts[0] : "")__		String country = (parts.length > 1 ? parts[1] : "")__		validateLocalePart(language)__		validateLocalePart(country)__		String variant = ""__		if (parts.length > 2) {_			_			_			int endIndexOfCountryCode = localeString.indexOf(country, language.length()) + country.length()__			_			variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode))__			if (variant.startsWith("_")) {_				variant = trimLeadingCharacter(variant, '_')__			}_		}_		return (language.length() > 0 ? new Locale(language, country, variant) : null)__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,code,string,following,code,locale,s,code,to,string,format,en,etc,also,accepts,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;public,static,locale,parse,locale,string,string,locale,string,string,parts,tokenize,to,string,array,locale,string,false,false,string,language,parts,length,0,parts,0,string,country,parts,length,1,parts,1,validate,locale,part,language,validate,locale,part,country,string,variant,if,parts,length,2,int,end,index,of,country,code,locale,string,index,of,country,language,length,country,length,variant,trim,leading,whitespace,locale,string,substring,end,index,of,country,code,if,variant,starts,with,variant,trim,leading,character,variant,return,language,length,0,new,locale,language,country,variant,null
StringUtils -> public static Locale parseLocaleString(String localeString);1467730834;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale {@code String}, following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc)__also accepts spaces as separators, as an alternative to underscores_@return a corresponding {@code Locale} instance_@throws IllegalArgumentException in case of an invalid locale specification;public static Locale parseLocaleString(String localeString) {_		String[] parts = tokenizeToStringArray(localeString, "_ ", false, false)__		String language = (parts.length > 0 ? parts[0] : "")__		String country = (parts.length > 1 ? parts[1] : "")__		validateLocalePart(language)__		validateLocalePart(country)__		String variant = ""__		if (parts.length > 2) {_			_			_			int endIndexOfCountryCode = localeString.indexOf(country, language.length()) + country.length()__			_			variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode))__			if (variant.startsWith("_")) {_				variant = trimLeadingCharacter(variant, '_')__			}_		}_		return (language.length() > 0 ? new Locale(language, country, variant) : null)__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,code,string,following,code,locale,s,code,to,string,format,en,etc,also,accepts,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;public,static,locale,parse,locale,string,string,locale,string,string,parts,tokenize,to,string,array,locale,string,false,false,string,language,parts,length,0,parts,0,string,country,parts,length,1,parts,1,validate,locale,part,language,validate,locale,part,country,string,variant,if,parts,length,2,int,end,index,of,country,code,locale,string,index,of,country,language,length,country,length,variant,trim,leading,whitespace,locale,string,substring,end,index,of,country,code,if,variant,starts,with,variant,trim,leading,character,variant,return,language,length,0,new,locale,language,country,variant,null
StringUtils -> public static Locale parseLocaleString(String localeString);1472128018;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale {@code String}, following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc)__also accepts spaces as separators, as an alternative to underscores_@return a corresponding {@code Locale} instance_@throws IllegalArgumentException in case of an invalid locale specification;public static Locale parseLocaleString(String localeString) {_		String[] parts = tokenizeToStringArray(localeString, "_ ", false, false)__		String language = (parts.length > 0 ? parts[0] : "")__		String country = (parts.length > 1 ? parts[1] : "")__		validateLocalePart(language)__		validateLocalePart(country)__		String variant = ""__		if (parts.length > 2) {_			_			_			int endIndexOfCountryCode = localeString.indexOf(country, language.length()) + country.length()__			_			variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode))__			if (variant.startsWith("_")) {_				variant = trimLeadingCharacter(variant, '_')__			}_		}_		return (language.length() > 0 ? new Locale(language, country, variant) : null)__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,code,string,following,code,locale,s,code,to,string,format,en,etc,also,accepts,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;public,static,locale,parse,locale,string,string,locale,string,string,parts,tokenize,to,string,array,locale,string,false,false,string,language,parts,length,0,parts,0,string,country,parts,length,1,parts,1,validate,locale,part,language,validate,locale,part,country,string,variant,if,parts,length,2,int,end,index,of,country,code,locale,string,index,of,country,language,length,country,length,variant,trim,leading,whitespace,locale,string,substring,end,index,of,country,code,if,variant,starts,with,variant,trim,leading,character,variant,return,language,length,0,new,locale,language,country,variant,null
StringUtils -> public static Locale parseLocaleString(String localeString);1472202842;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale {@code String}, following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc)__also accepts spaces as separators, as an alternative to underscores_@return a corresponding {@code Locale} instance_@throws IllegalArgumentException in case of an invalid locale specification;public static Locale parseLocaleString(String localeString) {_		String[] parts = tokenizeToStringArray(localeString, "_ ", false, false)__		String language = (parts.length > 0 ? parts[0] : "")__		String country = (parts.length > 1 ? parts[1] : "")__		validateLocalePart(language)__		validateLocalePart(country)__		String variant = ""__		if (parts.length > 2) {_			_			_			int endIndexOfCountryCode = localeString.indexOf(country, language.length()) + country.length()__			_			variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode))__			if (variant.startsWith("_")) {_				variant = trimLeadingCharacter(variant, '_')__			}_		}_		return (language.length() > 0 ? new Locale(language, country, variant) : null)__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,code,string,following,code,locale,s,code,to,string,format,en,etc,also,accepts,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;public,static,locale,parse,locale,string,string,locale,string,string,parts,tokenize,to,string,array,locale,string,false,false,string,language,parts,length,0,parts,0,string,country,parts,length,1,parts,1,validate,locale,part,language,validate,locale,part,country,string,variant,if,parts,length,2,int,end,index,of,country,code,locale,string,index,of,country,language,length,country,length,variant,trim,leading,whitespace,locale,string,substring,end,index,of,country,code,if,variant,starts,with,variant,trim,leading,character,variant,return,language,length,0,new,locale,language,country,variant,null
StringUtils -> public static Locale parseLocaleString(String localeString);1473942665;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale {@code String}, following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc)__also accepts spaces as separators, as an alternative to underscores_@return a corresponding {@code Locale} instance_@throws IllegalArgumentException in case of an invalid locale specification;public static Locale parseLocaleString(String localeString) {_		String[] parts = tokenizeToStringArray(localeString, "_ ", false, false)__		String language = (parts.length > 0 ? parts[0] : "")__		String country = (parts.length > 1 ? parts[1] : "")__		validateLocalePart(language)__		validateLocalePart(country)__		String variant = ""__		if (parts.length > 2) {_			_			_			int endIndexOfCountryCode = localeString.indexOf(country, language.length()) + country.length()__			_			variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode))__			if (variant.startsWith("_")) {_				variant = trimLeadingCharacter(variant, '_')__			}_		}_		return (language.length() > 0 ? new Locale(language, country, variant) : null)__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,code,string,following,code,locale,s,code,to,string,format,en,etc,also,accepts,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;public,static,locale,parse,locale,string,string,locale,string,string,parts,tokenize,to,string,array,locale,string,false,false,string,language,parts,length,0,parts,0,string,country,parts,length,1,parts,1,validate,locale,part,language,validate,locale,part,country,string,variant,if,parts,length,2,int,end,index,of,country,code,locale,string,index,of,country,language,length,country,length,variant,trim,leading,whitespace,locale,string,substring,end,index,of,country,code,if,variant,starts,with,variant,trim,leading,character,variant,return,language,length,0,new,locale,language,country,variant,null
StringUtils -> public static Locale parseLocaleString(String localeString);1484248946;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale {@code String}, following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc)__also accepts spaces as separators, as an alternative to underscores_@return a corresponding {@code Locale} instance_@throws IllegalArgumentException in case of an invalid locale specification;public static Locale parseLocaleString(String localeString) {_		String[] parts = tokenizeToStringArray(localeString, "_ ", false, false)__		String language = (parts.length > 0 ? parts[0] : "")__		String country = (parts.length > 1 ? parts[1] : "")__		validateLocalePart(language)__		validateLocalePart(country)__		String variant = ""__		if (parts.length > 2) {_			_			_			int endIndexOfCountryCode = localeString.indexOf(country, language.length()) + country.length()__			_			variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode))__			if (variant.startsWith("_")) {_				variant = trimLeadingCharacter(variant, '_')__			}_		}_		return (language.length() > 0 ? new Locale(language, country, variant) : null)__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,code,string,following,code,locale,s,code,to,string,format,en,etc,also,accepts,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;public,static,locale,parse,locale,string,string,locale,string,string,parts,tokenize,to,string,array,locale,string,false,false,string,language,parts,length,0,parts,0,string,country,parts,length,1,parts,1,validate,locale,part,language,validate,locale,part,country,string,variant,if,parts,length,2,int,end,index,of,country,code,locale,string,index,of,country,language,length,country,length,variant,trim,leading,whitespace,locale,string,substring,end,index,of,country,code,if,variant,starts,with,variant,trim,leading,character,variant,return,language,length,0,new,locale,language,country,variant,null
StringUtils -> public static Locale parseLocaleString(String localeString);1484260238;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale {@code String}, following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc)__also accepts spaces as separators, as an alternative to underscores_@return a corresponding {@code Locale} instance_@throws IllegalArgumentException in case of an invalid locale specification;public static Locale parseLocaleString(String localeString) {_		String[] parts = tokenizeToStringArray(localeString, "_ ", false, false)__		String language = (parts.length > 0 ? parts[0] : "")__		String country = (parts.length > 1 ? parts[1] : "")__		validateLocalePart(language)__		validateLocalePart(country)__		String variant = ""__		if (parts.length > 2) {_			_			_			int endIndexOfCountryCode = localeString.indexOf(country, language.length()) + country.length()__			_			variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode))__			if (variant.startsWith("_")) {_				variant = trimLeadingCharacter(variant, '_')__			}_		}_		return (language.length() > 0 ? new Locale(language, country, variant) : null)__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,code,string,following,code,locale,s,code,to,string,format,en,etc,also,accepts,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;public,static,locale,parse,locale,string,string,locale,string,string,parts,tokenize,to,string,array,locale,string,false,false,string,language,parts,length,0,parts,0,string,country,parts,length,1,parts,1,validate,locale,part,language,validate,locale,part,country,string,variant,if,parts,length,2,int,end,index,of,country,code,locale,string,index,of,country,language,length,country,length,variant,trim,leading,whitespace,locale,string,substring,end,index,of,country,code,if,variant,starts,with,variant,trim,leading,character,variant,return,language,length,0,new,locale,language,country,variant,null
StringUtils -> public static Locale parseLocaleString(String localeString);1484694546;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale {@code String}, following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc)__also accepts spaces as separators, as an alternative to underscores_@return a corresponding {@code Locale} instance_@throws IllegalArgumentException in case of an invalid locale specification;public static Locale parseLocaleString(String localeString) {_		String[] parts = tokenizeToStringArray(localeString, "_ ", false, false)__		String language = (parts.length > 0 ? parts[0] : "")__		String country = (parts.length > 1 ? parts[1] : "")__		validateLocalePart(language)__		validateLocalePart(country)__		String variant = ""__		if (parts.length > 2) {_			_			_			int endIndexOfCountryCode = localeString.indexOf(country, language.length()) + country.length()__			_			variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode))__			if (variant.startsWith("_")) {_				variant = trimLeadingCharacter(variant, '_')__			}_		}_		return (language.length() > 0 ? new Locale(language, country, variant) : null)__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,code,string,following,code,locale,s,code,to,string,format,en,etc,also,accepts,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;public,static,locale,parse,locale,string,string,locale,string,string,parts,tokenize,to,string,array,locale,string,false,false,string,language,parts,length,0,parts,0,string,country,parts,length,1,parts,1,validate,locale,part,language,validate,locale,part,country,string,variant,if,parts,length,2,int,end,index,of,country,code,locale,string,index,of,country,language,length,country,length,variant,trim,leading,whitespace,locale,string,substring,end,index,of,country,code,if,variant,starts,with,variant,trim,leading,character,variant,return,language,length,0,new,locale,language,country,variant,null
StringUtils -> public static Locale parseLocaleString(String localeString);1487760984;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale {@code String}, following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc)__also accepts spaces as separators, as an alternative to underscores_@return a corresponding {@code Locale} instance_@throws IllegalArgumentException in case of an invalid locale specification;public static Locale parseLocaleString(String localeString) {_		String[] parts = tokenizeToStringArray(localeString, "_ ", false, false)__		String language = (parts.length > 0 ? parts[0] : "")__		String country = (parts.length > 1 ? parts[1] : "")__		validateLocalePart(language)__		validateLocalePart(country)__		String variant = ""__		if (parts.length > 2) {_			_			_			int endIndexOfCountryCode = localeString.indexOf(country, language.length()) + country.length()__			_			variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode))__			if (variant.startsWith("_")) {_				variant = trimLeadingCharacter(variant, '_')__			}_		}_		return (language.length() > 0 ? new Locale(language, country, variant) : null)__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,code,string,following,code,locale,s,code,to,string,format,en,etc,also,accepts,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;public,static,locale,parse,locale,string,string,locale,string,string,parts,tokenize,to,string,array,locale,string,false,false,string,language,parts,length,0,parts,0,string,country,parts,length,1,parts,1,validate,locale,part,language,validate,locale,part,country,string,variant,if,parts,length,2,int,end,index,of,country,code,locale,string,index,of,country,language,length,country,length,variant,trim,leading,whitespace,locale,string,substring,end,index,of,country,code,if,variant,starts,with,variant,trim,leading,character,variant,return,language,length,0,new,locale,language,country,variant,null
StringUtils -> public static Locale parseLocaleString(String localeString);1487778834;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale {@code String}, following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc)__also accepts spaces as separators, as an alternative to underscores_@return a corresponding {@code Locale} instance_@throws IllegalArgumentException in case of an invalid locale specification;public static Locale parseLocaleString(String localeString) {_		String[] parts = tokenizeToStringArray(localeString, "_ ", false, false)__		String language = (parts.length > 0 ? parts[0] : "")__		String country = (parts.length > 1 ? parts[1] : "")__		validateLocalePart(language)__		validateLocalePart(country)__		String variant = ""__		if (parts.length > 2) {_			_			_			int endIndexOfCountryCode = localeString.indexOf(country, language.length()) + country.length()__			_			variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode))__			if (variant.startsWith("_")) {_				variant = trimLeadingCharacter(variant, '_')__			}_		}_		return (language.length() > 0 ? new Locale(language, country, variant) : null)__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,code,string,following,code,locale,s,code,to,string,format,en,etc,also,accepts,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;public,static,locale,parse,locale,string,string,locale,string,string,parts,tokenize,to,string,array,locale,string,false,false,string,language,parts,length,0,parts,0,string,country,parts,length,1,parts,1,validate,locale,part,language,validate,locale,part,country,string,variant,if,parts,length,2,int,end,index,of,country,code,locale,string,index,of,country,language,length,country,length,variant,trim,leading,whitespace,locale,string,substring,end,index,of,country,code,if,variant,starts,with,variant,trim,leading,character,variant,return,language,length,0,new,locale,language,country,variant,null
StringUtils -> public static Locale parseLocaleString(String localeString);1491898314;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale {@code String}, following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc)__also accepts spaces as separators, as an alternative to underscores_@return a corresponding {@code Locale} instance_@throws IllegalArgumentException in case of an invalid locale specification;public static Locale parseLocaleString(String localeString) {_		String[] parts = tokenizeToStringArray(localeString, "_ ", false, false)__		String language = (parts.length > 0 ? parts[0] : "")__		String country = (parts.length > 1 ? parts[1] : "")___		validateLocalePart(language)__		validateLocalePart(country)___		String variant = ""__		if (parts.length > 2) {_			_			_			int endIndexOfCountryCode = localeString.indexOf(country, language.length()) + country.length()__			_			variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode))__			if (variant.startsWith("_")) {_				variant = trimLeadingCharacter(variant, '_')__			}_		}_		return (language.length() > 0 ? new Locale(language, country, variant) : null)__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,code,string,following,code,locale,s,code,to,string,format,en,etc,also,accepts,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;public,static,locale,parse,locale,string,string,locale,string,string,parts,tokenize,to,string,array,locale,string,false,false,string,language,parts,length,0,parts,0,string,country,parts,length,1,parts,1,validate,locale,part,language,validate,locale,part,country,string,variant,if,parts,length,2,int,end,index,of,country,code,locale,string,index,of,country,language,length,country,length,variant,trim,leading,whitespace,locale,string,substring,end,index,of,country,code,if,variant,starts,with,variant,trim,leading,character,variant,return,language,length,0,new,locale,language,country,variant,null
StringUtils -> public static Locale parseLocaleString(String localeString);1491903650;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale {@code String}, following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc)__also accepts spaces as separators, as an alternative to underscores_@return a corresponding {@code Locale} instance_@throws IllegalArgumentException in case of an invalid locale specification;public static Locale parseLocaleString(String localeString) {_		String[] parts = tokenizeToStringArray(localeString, "_ ", false, false)__		String language = (parts.length > 0 ? parts[0] : "")__		String country = (parts.length > 1 ? parts[1] : "")___		validateLocalePart(language)__		validateLocalePart(country)___		String variant = ""__		if (parts.length > 2) {_			_			_			int endIndexOfCountryCode = localeString.indexOf(country, language.length()) + country.length()__			_			variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode))__			if (variant.startsWith("_")) {_				variant = trimLeadingCharacter(variant, '_')__			}_		}_		return (language.length() > 0 ? new Locale(language, country, variant) : null)__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,code,string,following,code,locale,s,code,to,string,format,en,etc,also,accepts,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;public,static,locale,parse,locale,string,string,locale,string,string,parts,tokenize,to,string,array,locale,string,false,false,string,language,parts,length,0,parts,0,string,country,parts,length,1,parts,1,validate,locale,part,language,validate,locale,part,country,string,variant,if,parts,length,2,int,end,index,of,country,code,locale,string,index,of,country,language,length,country,length,variant,trim,leading,whitespace,locale,string,substring,end,index,of,country,code,if,variant,starts,with,variant,trim,leading,character,variant,return,language,length,0,new,locale,language,country,variant,null
StringUtils -> public static Locale parseLocaleString(String localeString);1495868221;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale {@code String}, following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc)__also accepts spaces as separators, as an alternative to underscores_@return a corresponding {@code Locale} instance_@throws IllegalArgumentException in case of an invalid locale specification;public static Locale parseLocaleString(String localeString) {_		String[] parts = tokenizeToStringArray(localeString, "_ ", false, false)__		String language = (parts.length > 0 ? parts[0] : "")__		String country = (parts.length > 1 ? parts[1] : "")___		validateLocalePart(language)__		validateLocalePart(country)___		String variant = ""__		if (parts.length > 2) {_			_			_			int endIndexOfCountryCode = localeString.indexOf(country, language.length()) + country.length()__			_			variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode))__			if (variant.startsWith("_")) {_				variant = trimLeadingCharacter(variant, '_')__			}_		}_		return (language.length() > 0 ? new Locale(language, country, variant) : null)__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,code,string,following,code,locale,s,code,to,string,format,en,etc,also,accepts,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;public,static,locale,parse,locale,string,string,locale,string,string,parts,tokenize,to,string,array,locale,string,false,false,string,language,parts,length,0,parts,0,string,country,parts,length,1,parts,1,validate,locale,part,language,validate,locale,part,country,string,variant,if,parts,length,2,int,end,index,of,country,code,locale,string,index,of,country,language,length,country,length,variant,trim,leading,whitespace,locale,string,substring,end,index,of,country,code,if,variant,starts,with,variant,trim,leading,character,variant,return,language,length,0,new,locale,language,country,variant,null
StringUtils -> public static Locale parseLocaleString(String localeString);1496243689;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale {@code String}, following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc)__also accepts spaces as separators, as an alternative to underscores_@return a corresponding {@code Locale} instance_@throws IllegalArgumentException in case of an invalid locale specification;public static Locale parseLocaleString(String localeString) {_		String[] parts = tokenizeToStringArray(localeString, "_ ", false, false)__		String language = (parts.length > 0 ? parts[0] : "")__		String country = (parts.length > 1 ? parts[1] : "")___		validateLocalePart(language)__		validateLocalePart(country)___		String variant = ""__		if (parts.length > 2) {_			_			_			int endIndexOfCountryCode = localeString.indexOf(country, language.length()) + country.length()__			_			variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode))__			if (variant.startsWith("_")) {_				variant = trimLeadingCharacter(variant, '_')__			}_		}_		return (language.length() > 0 ? new Locale(language, country, variant) : null)__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,code,string,following,code,locale,s,code,to,string,format,en,etc,also,accepts,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;public,static,locale,parse,locale,string,string,locale,string,string,parts,tokenize,to,string,array,locale,string,false,false,string,language,parts,length,0,parts,0,string,country,parts,length,1,parts,1,validate,locale,part,language,validate,locale,part,country,string,variant,if,parts,length,2,int,end,index,of,country,code,locale,string,index,of,country,language,length,country,length,variant,trim,leading,whitespace,locale,string,substring,end,index,of,country,code,if,variant,starts,with,variant,trim,leading,character,variant,return,language,length,0,new,locale,language,country,variant,null
StringUtils -> public static Locale parseLocaleString(String localeString);1496259743;Parse the given {@code localeString} value into a {@link Locale}._<p>This is the inverse operation of {@link Locale#toString Locale's toString}._@param localeString the locale {@code String}, following {@code Locale's}_{@code toString()} format ("en", "en_UK", etc)__also accepts spaces as separators, as an alternative to underscores_@return a corresponding {@code Locale} instance_@throws IllegalArgumentException in case of an invalid locale specification;public static Locale parseLocaleString(String localeString) {_		String[] parts = tokenizeToStringArray(localeString, "_ ", false, false)__		String language = (parts.length > 0 ? parts[0] : "")__		String country = (parts.length > 1 ? parts[1] : "")___		validateLocalePart(language)__		validateLocalePart(country)___		String variant = ""__		if (parts.length > 2) {_			_			_			int endIndexOfCountryCode = localeString.indexOf(country, language.length()) + country.length()__			_			variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode))__			if (variant.startsWith("_")) {_				variant = trimLeadingCharacter(variant, '_')__			}_		}_		return (language.length() > 0 ? new Locale(language, country, variant) : null)__	};parse,the,given,code,locale,string,value,into,a,link,locale,p,this,is,the,inverse,operation,of,link,locale,to,string,locale,s,to,string,param,locale,string,the,locale,code,string,following,code,locale,s,code,to,string,format,en,etc,also,accepts,spaces,as,separators,as,an,alternative,to,underscores,return,a,corresponding,code,locale,instance,throws,illegal,argument,exception,in,case,of,an,invalid,locale,specification;public,static,locale,parse,locale,string,string,locale,string,string,parts,tokenize,to,string,array,locale,string,false,false,string,language,parts,length,0,parts,0,string,country,parts,length,1,parts,1,validate,locale,part,language,validate,locale,part,country,string,variant,if,parts,length,2,int,end,index,of,country,code,locale,string,index,of,country,language,length,country,length,variant,trim,leading,whitespace,locale,string,substring,end,index,of,country,code,if,variant,starts,with,variant,trim,leading,character,variant,return,language,length,0,new,locale,language,country,variant,null
StringUtils -> public static String[] addStringToArray(@Nullable String[] array, String str);1495868221;Append the given {@code String} to the given {@code String} array,_returning a new array consisting of the input array contents plus_the given {@code String}._@param array the array to append to (can be {@code null})_@param str the {@code String} to append_@return the new array (never {@code null});public static String[] addStringToArray(@Nullable String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}__		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,code,string,to,the,given,code,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,code,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,code,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,nullable,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(@Nullable String[] array, String str);1496243689;Append the given {@code String} to the given {@code String} array,_returning a new array consisting of the input array contents plus_the given {@code String}._@param array the array to append to (can be {@code null})_@param str the {@code String} to append_@return the new array (never {@code null});public static String[] addStringToArray(@Nullable String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}__		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,code,string,to,the,given,code,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,code,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,code,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,nullable,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(@Nullable String[] array, String str);1496259743;Append the given {@code String} to the given {@code String} array,_returning a new array consisting of the input array contents plus_the given {@code String}._@param array the array to append to (can be {@code null})_@param str the {@code String} to append_@return the new array (never {@code null});public static String[] addStringToArray(@Nullable String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}__		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,code,string,to,the,given,code,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,code,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,code,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,nullable,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(@Nullable String[] array, String str);1496837955;Append the given {@code String} to the given {@code String} array,_returning a new array consisting of the input array contents plus_the given {@code String}._@param array the array to append to (can be {@code null})_@param str the {@code String} to append_@return the new array (never {@code null});public static String[] addStringToArray(@Nullable String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}__		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,code,string,to,the,given,code,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,code,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,code,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,nullable,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(@Nullable String[] array, String str);1499270197;Append the given {@code String} to the given {@code String} array,_returning a new array consisting of the input array contents plus_the given {@code String}._@param array the array to append to (can be {@code null})_@param str the {@code String} to append_@return the new array (never {@code null});public static String[] addStringToArray(@Nullable String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}__		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,code,string,to,the,given,code,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,code,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,code,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,nullable,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(@Nullable String[] array, String str);1508667152;Append the given {@code String} to the given {@code String} array,_returning a new array consisting of the input array contents plus_the given {@code String}._@param array the array to append to (can be {@code null})_@param str the {@code String} to append_@return the new array (never {@code null});public static String[] addStringToArray(@Nullable String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}__		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,code,string,to,the,given,code,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,code,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,code,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,nullable,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(@Nullable String[] array, String str);1508675477;Append the given {@code String} to the given {@code String} array,_returning a new array consisting of the input array contents plus_the given {@code String}._@param array the array to append to (can be {@code null})_@param str the {@code String} to append_@return the new array (never {@code null});public static String[] addStringToArray(@Nullable String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}__		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,code,string,to,the,given,code,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,code,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,code,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,nullable,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(@Nullable String[] array, String str);1508843807;Append the given {@code String} to the given {@code String} array,_returning a new array consisting of the input array contents plus_the given {@code String}._@param array the array to append to (can be {@code null})_@param str the {@code String} to append_@return the new array (never {@code null});public static String[] addStringToArray(@Nullable String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}__		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,code,string,to,the,given,code,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,code,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,code,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,nullable,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(@Nullable String[] array, String str);1516903831;Append the given {@code String} to the given {@code String} array,_returning a new array consisting of the input array contents plus_the given {@code String}._@param array the array to append to (can be {@code null})_@param str the {@code String} to append_@return the new array (never {@code null});public static String[] addStringToArray(@Nullable String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}__		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,code,string,to,the,given,code,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,code,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,code,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,nullable,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(@Nullable String[] array, String str);1519295386;Append the given {@code String} to the given {@code String} array,_returning a new array consisting of the input array contents plus_the given {@code String}._@param array the array to append to (can be {@code null})_@param str the {@code String} to append_@return the new array (never {@code null});public static String[] addStringToArray(@Nullable String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}__		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,code,string,to,the,given,code,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,code,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,code,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,nullable,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(@Nullable String[] array, String str);1519308837;Append the given {@code String} to the given {@code String} array,_returning a new array consisting of the input array contents plus_the given {@code String}._@param array the array to append to (can be {@code null})_@param str the {@code String} to append_@return the new array (never {@code null});public static String[] addStringToArray(@Nullable String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}__		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,code,string,to,the,given,code,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,code,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,code,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,nullable,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(@Nullable String[] array, String str);1519588127;Append the given {@code String} to the given {@code String} array,_returning a new array consisting of the input array contents plus_the given {@code String}._@param array the array to append to (can be {@code null})_@param str the {@code String} to append_@return the new array (never {@code null});public static String[] addStringToArray(@Nullable String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}__		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,code,string,to,the,given,code,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,code,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,code,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,nullable,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(@Nullable String[] array, String str);1522332352;Append the given {@code String} to the given {@code String} array,_returning a new array consisting of the input array contents plus_the given {@code String}._@param array the array to append to (can be {@code null})_@param str the {@code String} to append_@return the new array (never {@code null});public static String[] addStringToArray(@Nullable String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}__		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,code,string,to,the,given,code,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,code,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,code,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,nullable,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(@Nullable String[] array, String str);1525166194;Append the given {@code String} to the given {@code String} array,_returning a new array consisting of the input array contents plus_the given {@code String}._@param array the array to append to (can be {@code null})_@param str the {@code String} to append_@return the new array (never {@code null});public static String[] addStringToArray(@Nullable String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}__		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,code,string,to,the,given,code,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,code,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,code,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,nullable,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(@Nullable String[] array, String str);1530188116;Append the given {@code String} to the given {@code String} array,_returning a new array consisting of the input array contents plus_the given {@code String}._@param array the array to append to (can be {@code null})_@param str the {@code String} to append_@return the new array (never {@code null});public static String[] addStringToArray(@Nullable String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}__		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,code,string,to,the,given,code,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,code,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,code,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,nullable,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(@Nullable String[] array, String str);1531843079;Append the given {@code String} to the given {@code String} array,_returning a new array consisting of the input array contents plus_the given {@code String}._@param array the array to append to (can be {@code null})_@param str the {@code String} to append_@return the new array (never {@code null});public static String[] addStringToArray(@Nullable String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}__		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,code,string,to,the,given,code,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,code,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,code,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,nullable,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(@Nullable String[] array, String str);1531905026;Append the given {@code String} to the given {@code String} array,_returning a new array consisting of the input array contents plus_the given {@code String}._@param array the array to append to (can be {@code null})_@param str the {@code String} to append_@return the new array (never {@code null});public static String[] addStringToArray(@Nullable String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}__		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,code,string,to,the,given,code,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,code,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,code,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,nullable,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(@Nullable String[] array, String str);1533557519;Append the given {@code String} to the given {@code String} array,_returning a new array consisting of the input array contents plus_the given {@code String}._@param array the array to append to (can be {@code null})_@param str the {@code String} to append_@return the new array (never {@code null});public static String[] addStringToArray(@Nullable String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}__		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,code,string,to,the,given,code,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,code,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,code,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,nullable,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(@Nullable String[] array, String str);1533602820;Append the given {@code String} to the given {@code String} array,_returning a new array consisting of the input array contents plus_the given {@code String}._@param array the array to append to (can be {@code null})_@param str the {@code String} to append_@return the new array (never {@code null});public static String[] addStringToArray(@Nullable String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}__		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,code,string,to,the,given,code,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,code,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,code,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,nullable,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(@Nullable String[] array, String str);1535316501;Append the given {@code String} to the given {@code String} array,_returning a new array consisting of the input array contents plus_the given {@code String}._@param array the array to append to (can be {@code null})_@param str the {@code String} to append_@return the new array (never {@code null});public static String[] addStringToArray(@Nullable String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}__		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,code,string,to,the,given,code,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,code,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,code,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,nullable,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(@Nullable String[] array, String str);1550237113;Append the given {@code String} to the given {@code String} array,_returning a new array consisting of the input array contents plus_the given {@code String}._@param array the array to append to (can be {@code null})_@param str the {@code String} to append_@return the new array (never {@code null});public static String[] addStringToArray(@Nullable String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}__		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,code,string,to,the,given,code,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,code,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,code,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,nullable,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> public static String[] addStringToArray(@Nullable String[] array, String str);1550238935;Append the given {@code String} to the given {@code String} array,_returning a new array consisting of the input array contents plus_the given {@code String}._@param array the array to append to (can be {@code null})_@param str the {@code String} to append_@return the new array (never {@code null});public static String[] addStringToArray(@Nullable String[] array, String str) {_		if (ObjectUtils.isEmpty(array)) {_			return new String[] {str}__		}__		String[] newArr = new String[array.length + 1]__		System.arraycopy(array, 0, newArr, 0, array.length)__		newArr[array.length] = str__		return newArr__	};append,the,given,code,string,to,the,given,code,string,array,returning,a,new,array,consisting,of,the,input,array,contents,plus,the,given,code,string,param,array,the,array,to,append,to,can,be,code,null,param,str,the,code,string,to,append,return,the,new,array,never,code,null;public,static,string,add,string,to,array,nullable,string,array,string,str,if,object,utils,is,empty,array,return,new,string,str,string,new,arr,new,string,array,length,1,system,arraycopy,array,0,new,arr,0,array,length,new,arr,array,length,str,return,new,arr
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, String charsToDelete);1495868221;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}__		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> @Nullable 	public static Properties splitArrayElementsIntoProperties( 			String[] array, String delimiter, String charsToDelete);1496243689;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@param charsToDelete one or more characters to remove from each element_prior to attempting the split operation (typically the quotation mark_symbol), or {@code null} if no removal should occur_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;@Nullable_	public static Properties splitArrayElementsIntoProperties(_			String[] array, String delimiter, String charsToDelete) {__		if (ObjectUtils.isEmpty(array)) {_			return null__		}__		Properties result = new Properties()__		for (String element : array) {_			if (charsToDelete != null) {_				element = deleteAny(element, charsToDelete)__			}_			String[] splittedElement = split(element, delimiter)__			if (splittedElement == null) {_				continue__			}_			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim())__		}_		return result__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,param,chars,to,delete,one,or,more,characters,to,remove,from,each,element,prior,to,attempting,the,split,operation,typically,the,quotation,mark,symbol,or,code,null,if,no,removal,should,occur,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;nullable,public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,string,chars,to,delete,if,object,utils,is,empty,array,return,null,properties,result,new,properties,for,string,element,array,if,chars,to,delete,null,element,delete,any,element,chars,to,delete,string,splitted,element,split,element,delimiter,if,splitted,element,null,continue,result,set,property,splitted,element,0,trim,splitted,element,1,trim,return,result
StringUtils -> public static boolean hasText(@Nullable String str);1495868221;Check whether the given {@code String} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code String} is not {@code null}, its length is greater than 0,_and it contains at least one non-whitespace character._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null}, its_length is greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(@Nullable String str) {_		return hasText((CharSequence) str)__	};check,whether,the,given,code,string,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,nullable,string,str,return,has,text,char,sequence,str
StringUtils -> public static boolean hasText(@Nullable String str);1496243689;Check whether the given {@code String} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code String} is not {@code null}, its length is greater than 0,_and it contains at least one non-whitespace character._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null}, its_length is greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(@Nullable String str) {_		return hasText((CharSequence) str)__	};check,whether,the,given,code,string,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,nullable,string,str,return,has,text,char,sequence,str
StringUtils -> public static boolean hasText(@Nullable String str);1496259743;Check whether the given {@code String} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code String} is not {@code null}, its length is greater than 0,_and it contains at least one non-whitespace character._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null}, its_length is greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(@Nullable String str) {_		return hasText((CharSequence) str)__	};check,whether,the,given,code,string,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,nullable,string,str,return,has,text,char,sequence,str
StringUtils -> public static boolean hasText(@Nullable String str);1496837955;Check whether the given {@code String} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code String} is not {@code null}, its length is greater than 0,_and it contains at least one non-whitespace character._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null}, its_length is greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(@Nullable String str) {_		return (str != null && !str.isEmpty() && hasText((CharSequence) str))__	};check,whether,the,given,code,string,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,nullable,string,str,return,str,null,str,is,empty,has,text,char,sequence,str
StringUtils -> public static boolean hasText(@Nullable String str);1499270197;Check whether the given {@code String} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code String} is not {@code null}, its length is greater than 0,_and it contains at least one non-whitespace character._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null}, its_length is greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(@Nullable String str) {_		return (str != null && !str.isEmpty() && hasText((CharSequence) str))__	};check,whether,the,given,code,string,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,nullable,string,str,return,str,null,str,is,empty,has,text,char,sequence,str
StringUtils -> public static boolean hasText(@Nullable String str);1508667152;Check whether the given {@code String} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code String} is not {@code null}, its length is greater than 0,_and it contains at least one non-whitespace character._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null}, its_length is greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(@Nullable String str) {_		return (hasLength(str) && containsText(str))__	};check,whether,the,given,code,string,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,nullable,string,str,return,has,length,str,contains,text,str
StringUtils -> public static boolean hasText(@Nullable String str);1508675477;Check whether the given {@code String} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code String} is not {@code null}, its length is greater than 0,_and it contains at least one non-whitespace character._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null}, its_length is greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(@Nullable String str) {_		return (hasLength(str) && containsText(str))__	};check,whether,the,given,code,string,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,nullable,string,str,return,has,length,str,contains,text,str
StringUtils -> public static boolean hasText(@Nullable String str);1508843807;Check whether the given {@code String} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code String} is not {@code null}, its length is greater than 0,_and it contains at least one non-whitespace character._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null}, its_length is greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(@Nullable String str) {_		return (str != null && !str.isEmpty() && containsText(str))__	};check,whether,the,given,code,string,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,nullable,string,str,return,str,null,str,is,empty,contains,text,str
StringUtils -> public static boolean hasText(@Nullable String str);1516903831;Check whether the given {@code String} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code String} is not {@code null}, its length is greater than 0,_and it contains at least one non-whitespace character._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null}, its_length is greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(@Nullable String str) {_		return (str != null && !str.isEmpty() && containsText(str))__	};check,whether,the,given,code,string,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,nullable,string,str,return,str,null,str,is,empty,contains,text,str
StringUtils -> public static boolean hasText(@Nullable String str);1519295386;Check whether the given {@code String} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code String} is not {@code null}, its length is greater than 0,_and it contains at least one non-whitespace character._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null}, its_length is greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(@Nullable String str) {_		return (str != null && !str.isEmpty() && containsText(str))__	};check,whether,the,given,code,string,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,nullable,string,str,return,str,null,str,is,empty,contains,text,str
StringUtils -> public static boolean hasText(@Nullable String str);1519308837;Check whether the given {@code String} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code String} is not {@code null}, its length is greater than 0,_and it contains at least one non-whitespace character._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null}, its_length is greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(@Nullable String str) {_		return (str != null && !str.isEmpty() && containsText(str))__	};check,whether,the,given,code,string,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,nullable,string,str,return,str,null,str,is,empty,contains,text,str
StringUtils -> public static boolean hasText(@Nullable String str);1519588127;Check whether the given {@code String} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code String} is not {@code null}, its length is greater than 0,_and it contains at least one non-whitespace character._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null}, its_length is greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(@Nullable String str) {_		return (str != null && !str.isEmpty() && containsText(str))__	};check,whether,the,given,code,string,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,nullable,string,str,return,str,null,str,is,empty,contains,text,str
StringUtils -> public static boolean hasText(@Nullable String str);1522332352;Check whether the given {@code String} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code String} is not {@code null}, its length is greater than 0,_and it contains at least one non-whitespace character._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null}, its_length is greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(@Nullable String str) {_		return (str != null && !str.isEmpty() && containsText(str))__	};check,whether,the,given,code,string,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,nullable,string,str,return,str,null,str,is,empty,contains,text,str
StringUtils -> public static boolean hasText(@Nullable String str);1525166194;Check whether the given {@code String} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code String} is not {@code null}, its length is greater than 0,_and it contains at least one non-whitespace character._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null}, its_length is greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(@Nullable String str) {_		return (str != null && !str.isEmpty() && containsText(str))__	};check,whether,the,given,code,string,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,nullable,string,str,return,str,null,str,is,empty,contains,text,str
StringUtils -> public static boolean hasText(@Nullable String str);1530188116;Check whether the given {@code String} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code String} is not {@code null}, its length is greater than 0,_and it contains at least one non-whitespace character._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null}, its_length is greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(@Nullable String str) {_		return (str != null && !str.isEmpty() && containsText(str))__	};check,whether,the,given,code,string,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,nullable,string,str,return,str,null,str,is,empty,contains,text,str
StringUtils -> public static boolean hasText(@Nullable String str);1531843079;Check whether the given {@code String} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code String} is not {@code null}, its length is greater than 0,_and it contains at least one non-whitespace character._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null}, its_length is greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(@Nullable String str) {_		return (str != null && !str.isEmpty() && containsText(str))__	};check,whether,the,given,code,string,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,nullable,string,str,return,str,null,str,is,empty,contains,text,str
StringUtils -> public static boolean hasText(@Nullable String str);1531905026;Check whether the given {@code String} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code String} is not {@code null}, its length is greater than 0,_and it contains at least one non-whitespace character._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null}, its_length is greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(@Nullable String str) {_		return (str != null && !str.isEmpty() && containsText(str))__	};check,whether,the,given,code,string,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,nullable,string,str,return,str,null,str,is,empty,contains,text,str
StringUtils -> public static boolean hasText(@Nullable String str);1533557519;Check whether the given {@code String} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code String} is not {@code null}, its length is greater than 0,_and it contains at least one non-whitespace character._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null}, its_length is greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(@Nullable String str) {_		return (str != null && !str.isEmpty() && containsText(str))__	};check,whether,the,given,code,string,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,nullable,string,str,return,str,null,str,is,empty,contains,text,str
StringUtils -> public static boolean hasText(@Nullable String str);1533602820;Check whether the given {@code String} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code String} is not {@code null}, its length is greater than 0,_and it contains at least one non-whitespace character._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null}, its_length is greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(@Nullable String str) {_		return (str != null && !str.isEmpty() && containsText(str))__	};check,whether,the,given,code,string,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,nullable,string,str,return,str,null,str,is,empty,contains,text,str
StringUtils -> public static boolean hasText(@Nullable String str);1535316501;Check whether the given {@code String} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code String} is not {@code null}, its length is greater than 0,_and it contains at least one non-whitespace character._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null}, its_length is greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(@Nullable String str) {_		return (str != null && !str.isEmpty() && containsText(str))__	};check,whether,the,given,code,string,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,nullable,string,str,return,str,null,str,is,empty,contains,text,str
StringUtils -> public static boolean hasText(@Nullable String str);1550237113;Check whether the given {@code String} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code String} is not {@code null}, its length is greater than 0,_and it contains at least one non-whitespace character._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null}, its_length is greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(@Nullable String str) {_		return (str != null && !str.isEmpty() && containsText(str))__	};check,whether,the,given,code,string,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,nullable,string,str,return,str,null,str,is,empty,contains,text,str
StringUtils -> public static boolean hasText(@Nullable String str);1550238935;Check whether the given {@code String} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code String} is not {@code null}, its length is greater than 0,_and it contains at least one non-whitespace character._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null}, its_length is greater than 0, and it does not contain whitespace only_@see #hasText(CharSequence);public static boolean hasText(@Nullable String str) {_		return (str != null && !str.isEmpty() && containsText(str))__	};check,whether,the,given,code,string,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,has,text,char,sequence;public,static,boolean,has,text,nullable,string,str,return,str,null,str,is,empty,contains,text,str
StringUtils -> public static boolean hasLength(@Nullable String str);1495868221;Check that the given {@code String} is neither {@code null} nor of length 0._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasLength(CharSequence)_@see #hasText(String);public static boolean hasLength(@Nullable String str) {_		return hasLength((CharSequence) str)__	};check,that,the,given,code,string,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,length,char,sequence,see,has,text,string;public,static,boolean,has,length,nullable,string,str,return,has,length,char,sequence,str
StringUtils -> public static boolean hasLength(@Nullable String str);1496243689;Check that the given {@code String} is neither {@code null} nor of length 0._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasLength(CharSequence)_@see #hasText(String);public static boolean hasLength(@Nullable String str) {_		return hasLength((CharSequence) str)__	};check,that,the,given,code,string,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,length,char,sequence,see,has,text,string;public,static,boolean,has,length,nullable,string,str,return,has,length,char,sequence,str
StringUtils -> public static boolean hasLength(@Nullable String str);1496259743;Check that the given {@code String} is neither {@code null} nor of length 0._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasLength(CharSequence)_@see #hasText(String);public static boolean hasLength(@Nullable String str) {_		return hasLength((CharSequence) str)__	};check,that,the,given,code,string,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,length,char,sequence,see,has,text,string;public,static,boolean,has,length,nullable,string,str,return,has,length,char,sequence,str
StringUtils -> public static boolean hasLength(@Nullable String str);1496837955;Check that the given {@code String} is neither {@code null} nor of length 0._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasLength(CharSequence)_@see #hasText(String);public static boolean hasLength(@Nullable String str) {_		return (str != null && !str.isEmpty())__	};check,that,the,given,code,string,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,length,char,sequence,see,has,text,string;public,static,boolean,has,length,nullable,string,str,return,str,null,str,is,empty
StringUtils -> public static boolean hasLength(@Nullable String str);1499270197;Check that the given {@code String} is neither {@code null} nor of length 0._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasLength(CharSequence)_@see #hasText(String);public static boolean hasLength(@Nullable String str) {_		return (str != null && !str.isEmpty())__	};check,that,the,given,code,string,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,length,char,sequence,see,has,text,string;public,static,boolean,has,length,nullable,string,str,return,str,null,str,is,empty
StringUtils -> public static boolean hasLength(@Nullable String str);1508667152;Check that the given {@code String} is neither {@code null} nor of length 0._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasLength(CharSequence)_@see #hasText(String);public static boolean hasLength(@Nullable String str) {_		return (str != null && !str.isEmpty())__	};check,that,the,given,code,string,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,length,char,sequence,see,has,text,string;public,static,boolean,has,length,nullable,string,str,return,str,null,str,is,empty
StringUtils -> public static boolean hasLength(@Nullable String str);1508675477;Check that the given {@code String} is neither {@code null} nor of length 0._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasLength(CharSequence)_@see #hasText(String);public static boolean hasLength(@Nullable String str) {_		return (str != null && !str.isEmpty())__	};check,that,the,given,code,string,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,length,char,sequence,see,has,text,string;public,static,boolean,has,length,nullable,string,str,return,str,null,str,is,empty
StringUtils -> public static boolean hasLength(@Nullable String str);1508843807;Check that the given {@code String} is neither {@code null} nor of length 0._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasLength(CharSequence)_@see #hasText(String);public static boolean hasLength(@Nullable String str) {_		return (str != null && !str.isEmpty())__	};check,that,the,given,code,string,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,length,char,sequence,see,has,text,string;public,static,boolean,has,length,nullable,string,str,return,str,null,str,is,empty
StringUtils -> public static boolean hasLength(@Nullable String str);1516903831;Check that the given {@code String} is neither {@code null} nor of length 0._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasLength(CharSequence)_@see #hasText(String);public static boolean hasLength(@Nullable String str) {_		return (str != null && !str.isEmpty())__	};check,that,the,given,code,string,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,length,char,sequence,see,has,text,string;public,static,boolean,has,length,nullable,string,str,return,str,null,str,is,empty
StringUtils -> public static boolean hasLength(@Nullable String str);1519295386;Check that the given {@code String} is neither {@code null} nor of length 0._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasLength(CharSequence)_@see #hasText(String);public static boolean hasLength(@Nullable String str) {_		return (str != null && !str.isEmpty())__	};check,that,the,given,code,string,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,length,char,sequence,see,has,text,string;public,static,boolean,has,length,nullable,string,str,return,str,null,str,is,empty
StringUtils -> public static boolean hasLength(@Nullable String str);1519308837;Check that the given {@code String} is neither {@code null} nor of length 0._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasLength(CharSequence)_@see #hasText(String);public static boolean hasLength(@Nullable String str) {_		return (str != null && !str.isEmpty())__	};check,that,the,given,code,string,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,length,char,sequence,see,has,text,string;public,static,boolean,has,length,nullable,string,str,return,str,null,str,is,empty
StringUtils -> public static boolean hasLength(@Nullable String str);1519588127;Check that the given {@code String} is neither {@code null} nor of length 0._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasLength(CharSequence)_@see #hasText(String);public static boolean hasLength(@Nullable String str) {_		return (str != null && !str.isEmpty())__	};check,that,the,given,code,string,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,length,char,sequence,see,has,text,string;public,static,boolean,has,length,nullable,string,str,return,str,null,str,is,empty
StringUtils -> public static boolean hasLength(@Nullable String str);1522332352;Check that the given {@code String} is neither {@code null} nor of length 0._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasLength(CharSequence)_@see #hasText(String);public static boolean hasLength(@Nullable String str) {_		return (str != null && !str.isEmpty())__	};check,that,the,given,code,string,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,length,char,sequence,see,has,text,string;public,static,boolean,has,length,nullable,string,str,return,str,null,str,is,empty
StringUtils -> public static boolean hasLength(@Nullable String str);1525166194;Check that the given {@code String} is neither {@code null} nor of length 0._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasLength(CharSequence)_@see #hasText(String);public static boolean hasLength(@Nullable String str) {_		return (str != null && !str.isEmpty())__	};check,that,the,given,code,string,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,length,char,sequence,see,has,text,string;public,static,boolean,has,length,nullable,string,str,return,str,null,str,is,empty
StringUtils -> public static boolean hasLength(@Nullable String str);1530188116;Check that the given {@code String} is neither {@code null} nor of length 0._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasLength(CharSequence)_@see #hasText(String);public static boolean hasLength(@Nullable String str) {_		return (str != null && !str.isEmpty())__	};check,that,the,given,code,string,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,length,char,sequence,see,has,text,string;public,static,boolean,has,length,nullable,string,str,return,str,null,str,is,empty
StringUtils -> public static boolean hasLength(@Nullable String str);1531843079;Check that the given {@code String} is neither {@code null} nor of length 0._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasLength(CharSequence)_@see #hasText(String);public static boolean hasLength(@Nullable String str) {_		return (str != null && !str.isEmpty())__	};check,that,the,given,code,string,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,length,char,sequence,see,has,text,string;public,static,boolean,has,length,nullable,string,str,return,str,null,str,is,empty
StringUtils -> public static boolean hasLength(@Nullable String str);1531905026;Check that the given {@code String} is neither {@code null} nor of length 0._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasLength(CharSequence)_@see #hasText(String);public static boolean hasLength(@Nullable String str) {_		return (str != null && !str.isEmpty())__	};check,that,the,given,code,string,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,length,char,sequence,see,has,text,string;public,static,boolean,has,length,nullable,string,str,return,str,null,str,is,empty
StringUtils -> public static boolean hasLength(@Nullable String str);1533557519;Check that the given {@code String} is neither {@code null} nor of length 0._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasLength(CharSequence)_@see #hasText(String);public static boolean hasLength(@Nullable String str) {_		return (str != null && !str.isEmpty())__	};check,that,the,given,code,string,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,length,char,sequence,see,has,text,string;public,static,boolean,has,length,nullable,string,str,return,str,null,str,is,empty
StringUtils -> public static boolean hasLength(@Nullable String str);1533602820;Check that the given {@code String} is neither {@code null} nor of length 0._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasLength(CharSequence)_@see #hasText(String);public static boolean hasLength(@Nullable String str) {_		return (str != null && !str.isEmpty())__	};check,that,the,given,code,string,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,length,char,sequence,see,has,text,string;public,static,boolean,has,length,nullable,string,str,return,str,null,str,is,empty
StringUtils -> public static boolean hasLength(@Nullable String str);1535316501;Check that the given {@code String} is neither {@code null} nor of length 0._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasLength(CharSequence)_@see #hasText(String);public static boolean hasLength(@Nullable String str) {_		return (str != null && !str.isEmpty())__	};check,that,the,given,code,string,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,length,char,sequence,see,has,text,string;public,static,boolean,has,length,nullable,string,str,return,str,null,str,is,empty
StringUtils -> public static boolean hasLength(@Nullable String str);1550237113;Check that the given {@code String} is neither {@code null} nor of length 0._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasLength(CharSequence)_@see #hasText(String);public static boolean hasLength(@Nullable String str) {_		return (str != null && !str.isEmpty())__	};check,that,the,given,code,string,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,length,char,sequence,see,has,text,string;public,static,boolean,has,length,nullable,string,str,return,str,null,str,is,empty
StringUtils -> public static boolean hasLength(@Nullable String str);1550238935;Check that the given {@code String} is neither {@code null} nor of length 0._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasLength(CharSequence)_@see #hasText(String);public static boolean hasLength(@Nullable String str) {_		return (str != null && !str.isEmpty())__	};check,that,the,given,code,string,is,neither,code,null,nor,of,length,0,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,length,char,sequence,see,has,text,string;public,static,boolean,has,length,nullable,string,str,return,str,null,str,is,empty
StringUtils -> @Nullable 	public static String capitalize(@Nullable String str);1495868221;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the {@code String} to capitalize, may be {@code null}_@return the capitalized {@code String}, or {@code null} if the supplied_string is {@code null};@Nullable_	public static String capitalize(@Nullable String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,code,string,to,capitalize,may,be,code,null,return,the,capitalized,code,string,or,code,null,if,the,supplied,string,is,code,null;nullable,public,static,string,capitalize,nullable,string,str,return,change,first,character,case,str,true
StringUtils -> @Nullable 	public static String capitalize(@Nullable String str);1496243689;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the {@code String} to capitalize, may be {@code null}_@return the capitalized {@code String}, or {@code null} if the supplied_string is {@code null};@Nullable_	public static String capitalize(@Nullable String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,code,string,to,capitalize,may,be,code,null,return,the,capitalized,code,string,or,code,null,if,the,supplied,string,is,code,null;nullable,public,static,string,capitalize,nullable,string,str,return,change,first,character,case,str,true
StringUtils -> @Nullable 	public static String capitalize(@Nullable String str);1496259743;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the {@code String} to capitalize, may be {@code null}_@return the capitalized {@code String}, or {@code null} if the supplied_string is {@code null};@Nullable_	public static String capitalize(@Nullable String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,code,string,to,capitalize,may,be,code,null,return,the,capitalized,code,string,or,code,null,if,the,supplied,string,is,code,null;nullable,public,static,string,capitalize,nullable,string,str,return,change,first,character,case,str,true
StringUtils -> public static String[] commaDelimitedListToStringArray(@Nullable String str);1496837955;Convert a comma delimited list (e.g., a row from a CSV file) into an_array of strings._@param str the input {@code String}_@return an array of strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(@Nullable String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,an,array,of,strings,param,str,the,input,code,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,nullable,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(@Nullable String str);1499270197;Convert a comma delimited list (e.g., a row from a CSV file) into an_array of strings._@param str the input {@code String}_@return an array of strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(@Nullable String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,an,array,of,strings,param,str,the,input,code,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,nullable,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(@Nullable String str);1508667152;Convert a comma delimited list (e.g., a row from a CSV file) into an_array of strings._@param str the input {@code String}_@return an array of strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(@Nullable String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,an,array,of,strings,param,str,the,input,code,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,nullable,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(@Nullable String str);1508675477;Convert a comma delimited list (e.g., a row from a CSV file) into an_array of strings._@param str the input {@code String}_@return an array of strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(@Nullable String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,an,array,of,strings,param,str,the,input,code,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,nullable,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(@Nullable String str);1508843807;Convert a comma delimited list (e.g., a row from a CSV file) into an_array of strings._@param str the input {@code String}_@return an array of strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(@Nullable String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,an,array,of,strings,param,str,the,input,code,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,nullable,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(@Nullable String str);1516903831;Convert a comma delimited list (e.g., a row from a CSV file) into an_array of strings._@param str the input {@code String}_@return an array of strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(@Nullable String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,an,array,of,strings,param,str,the,input,code,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,nullable,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(@Nullable String str);1519295386;Convert a comma delimited list (e.g., a row from a CSV file) into an_array of strings._@param str the input {@code String}_@return an array of strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(@Nullable String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,an,array,of,strings,param,str,the,input,code,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,nullable,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(@Nullable String str);1519308837;Convert a comma delimited list (e.g., a row from a CSV file) into an_array of strings._@param str the input {@code String}_@return an array of strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(@Nullable String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,an,array,of,strings,param,str,the,input,code,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,nullable,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(@Nullable String str);1519588127;Convert a comma delimited list (e.g., a row from a CSV file) into an_array of strings._@param str the input {@code String}_@return an array of strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(@Nullable String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,an,array,of,strings,param,str,the,input,code,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,nullable,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(@Nullable String str);1522332352;Convert a comma delimited list (e.g., a row from a CSV file) into an_array of strings._@param str the input {@code String}_@return an array of strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(@Nullable String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,an,array,of,strings,param,str,the,input,code,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,nullable,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(@Nullable String str);1525166194;Convert a comma delimited list (e.g., a row from a CSV file) into an_array of strings._@param str the input {@code String}_@return an array of strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(@Nullable String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,an,array,of,strings,param,str,the,input,code,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,nullable,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(@Nullable String str);1530188116;Convert a comma delimited list (e.g., a row from a CSV file) into an_array of strings._@param str the input {@code String}_@return an array of strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(@Nullable String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,an,array,of,strings,param,str,the,input,code,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,nullable,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(@Nullable String str);1531843079;Convert a comma delimited list (e.g., a row from a CSV file) into an_array of strings._@param str the input {@code String}_@return an array of strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(@Nullable String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,an,array,of,strings,param,str,the,input,code,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,nullable,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(@Nullable String str);1531905026;Convert a comma delimited list (e.g., a row from a CSV file) into an_array of strings._@param str the input {@code String}_@return an array of strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(@Nullable String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,an,array,of,strings,param,str,the,input,code,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,nullable,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(@Nullable String str);1533557519;Convert a comma delimited list (e.g., a row from a CSV file) into an_array of strings._@param str the input {@code String} (potentially {@code null} or empty)_@return an array of strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(@Nullable String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,an,array,of,strings,param,str,the,input,code,string,potentially,code,null,or,empty,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,nullable,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(@Nullable String str);1533602820;Convert a comma delimited list (e.g., a row from a CSV file) into an_array of strings._@param str the input {@code String} (potentially {@code null} or empty)_@return an array of strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(@Nullable String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,an,array,of,strings,param,str,the,input,code,string,potentially,code,null,or,empty,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,nullable,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(@Nullable String str);1535316501;Convert a comma delimited list (e.g., a row from a CSV file) into an_array of strings._@param str the input {@code String} (potentially {@code null} or empty)_@return an array of strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(@Nullable String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,an,array,of,strings,param,str,the,input,code,string,potentially,code,null,or,empty,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,nullable,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(@Nullable String str);1550237113;Convert a comma delimited list (e.g., a row from a CSV file) into an_array of strings._@param str the input {@code String} (potentially {@code null} or empty)_@return an array of strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(@Nullable String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,an,array,of,strings,param,str,the,input,code,string,potentially,code,null,or,empty,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,nullable,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(@Nullable String str);1550238935;Convert a comma delimited list (e.g., a row from a CSV file) into an_array of strings._@param str the input {@code String} (potentially {@code null} or empty)_@return an array of strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(@Nullable String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,an,array,of,strings,param,str,the,input,code,string,potentially,code,null,or,empty,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,nullable,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String replace(String inString, String oldPattern, String newPattern);1328020251;Replace all occurences of a substring within a string with_another string._@param inString String to examine_@param oldPattern String to replace_@param newPattern String to insert_@return a String with the replacements;public static String replace(String inString, String oldPattern, String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		int pos = 0_ _		int index = inString.indexOf(oldPattern)__		_		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}_		sb.append(inString.substring(pos))__		_		return sb.toString()__	};replace,all,occurences,of,a,substring,within,a,string,with,another,string,param,in,string,string,to,examine,param,old,pattern,string,to,replace,param,new,pattern,string,to,insert,return,a,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,string,builder,sb,new,string,builder,int,pos,0,int,index,in,string,index,of,old,pattern,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, String newPattern);1337236962;Replace all occurences of a substring within a string with_another string._@param inString String to examine_@param oldPattern String to replace_@param newPattern String to insert_@return a String with the replacements;public static String replace(String inString, String oldPattern, String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		int pos = 0_ _		int index = inString.indexOf(oldPattern)__		_		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}_		sb.append(inString.substring(pos))__		_		return sb.toString()__	};replace,all,occurences,of,a,substring,within,a,string,with,another,string,param,in,string,string,to,examine,param,old,pattern,string,to,replace,param,new,pattern,string,to,insert,return,a,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,string,builder,sb,new,string,builder,int,pos,0,int,index,in,string,index,of,old,pattern,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, String newPattern);1356735495;Replace all occurences of a substring within a string with_another string._@param inString String to examine_@param oldPattern String to replace_@param newPattern String to insert_@return a String with the replacements;public static String replace(String inString, String oldPattern, String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		int pos = 0_ _		int index = inString.indexOf(oldPattern)__		_		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}_		sb.append(inString.substring(pos))__		_		return sb.toString()__	};replace,all,occurences,of,a,substring,within,a,string,with,another,string,param,in,string,string,to,examine,param,old,pattern,string,to,replace,param,new,pattern,string,to,insert,return,a,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,string,builder,sb,new,string,builder,int,pos,0,int,index,in,string,index,of,old,pattern,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, String newPattern);1367955086;Replace all occurences of a substring within a string with_another string._@param inString String to examine_@param oldPattern String to replace_@param newPattern String to insert_@return a String with the replacements;public static String replace(String inString, String oldPattern, String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		int pos = 0_ _		int index = inString.indexOf(oldPattern)__		_		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}_		sb.append(inString.substring(pos))__		_		return sb.toString()__	};replace,all,occurences,of,a,substring,within,a,string,with,another,string,param,in,string,string,to,examine,param,old,pattern,string,to,replace,param,new,pattern,string,to,insert,return,a,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,string,builder,sb,new,string,builder,int,pos,0,int,index,in,string,index,of,old,pattern,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, String newPattern);1380921248;Replace all occurences of a substring within a string with_another string._@param inString String to examine_@param oldPattern String to replace_@param newPattern String to insert_@return a String with the replacements;public static String replace(String inString, String oldPattern, String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		int pos = 0_ _		int index = inString.indexOf(oldPattern)__		_		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}_		sb.append(inString.substring(pos))__		_		return sb.toString()__	};replace,all,occurences,of,a,substring,within,a,string,with,another,string,param,in,string,string,to,examine,param,old,pattern,string,to,replace,param,new,pattern,string,to,insert,return,a,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,string,builder,sb,new,string,builder,int,pos,0,int,index,in,string,index,of,old,pattern,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, String newPattern);1382750743;Replace all occurences of a substring within a string with_another string._@param inString String to examine_@param oldPattern String to replace_@param newPattern String to insert_@return a String with the replacements;public static String replace(String inString, String oldPattern, String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		int pos = 0_ _		int index = inString.indexOf(oldPattern)__		_		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}_		sb.append(inString.substring(pos))__		_		return sb.toString()__	};replace,all,occurences,of,a,substring,within,a,string,with,another,string,param,in,string,string,to,examine,param,old,pattern,string,to,replace,param,new,pattern,string,to,insert,return,a,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,string,builder,sb,new,string,builder,int,pos,0,int,index,in,string,index,of,old,pattern,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, String newPattern);1385423968;Replace all occurrences of a substring within a string with_another string._@param inString String to examine_@param oldPattern String to replace_@param newPattern String to insert_@return a String with the replacements;public static String replace(String inString, String oldPattern, String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		int pos = 0_ _		int index = inString.indexOf(oldPattern)__		_		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}_		sb.append(inString.substring(pos))__		_		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,string,to,examine,param,old,pattern,string,to,replace,param,new,pattern,string,to,insert,return,a,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,string,builder,sb,new,string,builder,int,pos,0,int,index,in,string,index,of,old,pattern,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, String newPattern);1400189212;Replace all occurrences of a substring within a string with_another string._@param inString String to examine_@param oldPattern String to replace_@param newPattern String to insert_@return a String with the replacements;public static String replace(String inString, String oldPattern, String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		int pos = 0_ _		int index = inString.indexOf(oldPattern)__		_		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}_		sb.append(inString.substring(pos))__		_		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,string,to,examine,param,old,pattern,string,to,replace,param,new,pattern,string,to,insert,return,a,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,string,builder,sb,new,string,builder,int,pos,0,int,index,in,string,index,of,old,pattern,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, String newPattern);1400531359;Replace all occurrences of a substring within a string with_another string._@param inString String to examine_@param oldPattern String to replace_@param newPattern String to insert_@return a String with the replacements;public static String replace(String inString, String oldPattern, String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		int pos = 0_ _		int index = inString.indexOf(oldPattern)__		_		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}_		sb.append(inString.substring(pos))__		_		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,string,to,examine,param,old,pattern,string,to,replace,param,new,pattern,string,to,insert,return,a,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,string,builder,sb,new,string,builder,int,pos,0,int,index,in,string,index,of,old,pattern,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, String newPattern);1402676350;Replace all occurrences of a substring within a string with_another string._@param inString String to examine_@param oldPattern String to replace_@param newPattern String to insert_@return a String with the replacements;public static String replace(String inString, String oldPattern, String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		int pos = 0_ _		int index = inString.indexOf(oldPattern)__		_		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}_		sb.append(inString.substring(pos))__		_		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,string,to,examine,param,old,pattern,string,to,replace,param,new,pattern,string,to,insert,return,a,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,string,builder,sb,new,string,builder,int,pos,0,int,index,in,string,index,of,old,pattern,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, String newPattern);1426267150;Replace all occurrences of a substring within a string with_another string._@param inString String to examine_@param oldPattern String to replace_@param newPattern String to insert_@return a String with the replacements;public static String replace(String inString, String oldPattern, String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		int pos = 0_ _		int index = inString.indexOf(oldPattern)__		_		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}_		sb.append(inString.substring(pos))__		_		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,string,to,examine,param,old,pattern,string,to,replace,param,new,pattern,string,to,insert,return,a,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,string,builder,sb,new,string,builder,int,pos,0,int,index,in,string,index,of,old,pattern,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, String newPattern);1429034538;Replace all occurrences of a substring within a string with_another string._@param inString String to examine_@param oldPattern String to replace_@param newPattern String to insert_@return a String with the replacements;public static String replace(String inString, String oldPattern, String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		int pos = 0_ _		int index = inString.indexOf(oldPattern)__		_		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}_		sb.append(inString.substring(pos))__		_		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,string,to,examine,param,old,pattern,string,to,replace,param,new,pattern,string,to,insert,return,a,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,string,builder,sb,new,string,builder,int,pos,0,int,index,in,string,index,of,old,pattern,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, String newPattern);1429034756;Replace all occurrences of a substring within a string with_another string._@param inString {@code String} to examine_@param oldPattern {@code String} to replace_@param newPattern {@code String} to insert_@return a {@code String} with the replacements;public static String replace(String inString, String oldPattern, String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		int pos = 0_ _		int index = inString.indexOf(oldPattern)__		_		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}_		sb.append(inString.substring(pos))__		_		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,code,string,to,examine,param,old,pattern,code,string,to,replace,param,new,pattern,code,string,to,insert,return,a,code,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,string,builder,sb,new,string,builder,int,pos,0,int,index,in,string,index,of,old,pattern,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, String newPattern);1431006895;Replace all occurrences of a substring within a string with_another string._@param inString {@code String} to examine_@param oldPattern {@code String} to replace_@param newPattern {@code String} to insert_@return a {@code String} with the replacements;public static String replace(String inString, String oldPattern, String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		int pos = 0_ _		int index = inString.indexOf(oldPattern)__		_		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}_		sb.append(inString.substring(pos))__		_		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,code,string,to,examine,param,old,pattern,code,string,to,replace,param,new,pattern,code,string,to,insert,return,a,code,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,string,builder,sb,new,string,builder,int,pos,0,int,index,in,string,index,of,old,pattern,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, String newPattern);1431007368;Replace all occurrences of a substring within a string with_another string._@param inString {@code String} to examine_@param oldPattern {@code String} to replace_@param newPattern {@code String} to insert_@return a {@code String} with the replacements;public static String replace(String inString, String oldPattern, String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		int pos = 0_ _		int index = inString.indexOf(oldPattern)__		_		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}_		sb.append(inString.substring(pos))__		_		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,code,string,to,examine,param,old,pattern,code,string,to,replace,param,new,pattern,code,string,to,insert,return,a,code,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,string,builder,sb,new,string,builder,int,pos,0,int,index,in,string,index,of,old,pattern,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, String newPattern);1449489126;Replace all occurrences of a substring within a string with_another string._@param inString {@code String} to examine_@param oldPattern {@code String} to replace_@param newPattern {@code String} to insert_@return a {@code String} with the replacements;public static String replace(String inString, String oldPattern, String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		int pos = 0_ _		int index = inString.indexOf(oldPattern)__		_		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}_		sb.append(inString.substring(pos))__		_		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,code,string,to,examine,param,old,pattern,code,string,to,replace,param,new,pattern,code,string,to,insert,return,a,code,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,string,builder,sb,new,string,builder,int,pos,0,int,index,in,string,index,of,old,pattern,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, String newPattern);1467730834;Replace all occurrences of a substring within a string with_another string._@param inString {@code String} to examine_@param oldPattern {@code String} to replace_@param newPattern {@code String} to insert_@return a {@code String} with the replacements;public static String replace(String inString, String oldPattern, String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		int pos = 0_ _		int index = inString.indexOf(oldPattern)__		_		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}_		sb.append(inString.substring(pos))__		_		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,code,string,to,examine,param,old,pattern,code,string,to,replace,param,new,pattern,code,string,to,insert,return,a,code,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,string,builder,sb,new,string,builder,int,pos,0,int,index,in,string,index,of,old,pattern,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, String newPattern);1472128018;Replace all occurrences of a substring within a string with_another string._@param inString {@code String} to examine_@param oldPattern {@code String} to replace_@param newPattern {@code String} to insert_@return a {@code String} with the replacements;public static String replace(String inString, String oldPattern, String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		int pos = 0_ _		int index = inString.indexOf(oldPattern)__		_		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}_		sb.append(inString.substring(pos))__		_		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,code,string,to,examine,param,old,pattern,code,string,to,replace,param,new,pattern,code,string,to,insert,return,a,code,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,string,builder,sb,new,string,builder,int,pos,0,int,index,in,string,index,of,old,pattern,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, String newPattern);1472202842;Replace all occurrences of a substring within a string with_another string._@param inString {@code String} to examine_@param oldPattern {@code String} to replace_@param newPattern {@code String} to insert_@return a {@code String} with the replacements;public static String replace(String inString, String oldPattern, String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		int pos = 0_ _		int index = inString.indexOf(oldPattern)__		_		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}_		sb.append(inString.substring(pos))__		_		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,code,string,to,examine,param,old,pattern,code,string,to,replace,param,new,pattern,code,string,to,insert,return,a,code,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,string,builder,sb,new,string,builder,int,pos,0,int,index,in,string,index,of,old,pattern,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, String newPattern);1473942665;Replace all occurrences of a substring within a string with_another string._@param inString {@code String} to examine_@param oldPattern {@code String} to replace_@param newPattern {@code String} to insert_@return a {@code String} with the replacements;public static String replace(String inString, String oldPattern, String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		int pos = 0_ _		int index = inString.indexOf(oldPattern)__		_		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}_		sb.append(inString.substring(pos))__		_		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,code,string,to,examine,param,old,pattern,code,string,to,replace,param,new,pattern,code,string,to,insert,return,a,code,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,string,builder,sb,new,string,builder,int,pos,0,int,index,in,string,index,of,old,pattern,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, String newPattern);1484248946;Replace all occurrences of a substring within a string with_another string._@param inString {@code String} to examine_@param oldPattern {@code String} to replace_@param newPattern {@code String} to insert_@return a {@code String} with the replacements;public static String replace(String inString, String oldPattern, String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		int pos = 0_ _		int index = inString.indexOf(oldPattern)__		_		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}_		sb.append(inString.substring(pos))__		_		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,code,string,to,examine,param,old,pattern,code,string,to,replace,param,new,pattern,code,string,to,insert,return,a,code,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,string,builder,sb,new,string,builder,int,pos,0,int,index,in,string,index,of,old,pattern,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, String newPattern);1484260238;Replace all occurrences of a substring within a string with_another string._@param inString {@code String} to examine_@param oldPattern {@code String} to replace_@param newPattern {@code String} to insert_@return a {@code String} with the replacements;public static String replace(String inString, String oldPattern, String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		int pos = 0_ _		int index = inString.indexOf(oldPattern)__		_		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}_		sb.append(inString.substring(pos))__		_		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,code,string,to,examine,param,old,pattern,code,string,to,replace,param,new,pattern,code,string,to,insert,return,a,code,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,string,builder,sb,new,string,builder,int,pos,0,int,index,in,string,index,of,old,pattern,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, String newPattern);1484694546;Replace all occurrences of a substring within a string with_another string._@param inString {@code String} to examine_@param oldPattern {@code String} to replace_@param newPattern {@code String} to insert_@return a {@code String} with the replacements;public static String replace(String inString, String oldPattern, String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		int pos = 0_ _		int index = inString.indexOf(oldPattern)__		_		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}_		sb.append(inString.substring(pos))__		_		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,code,string,to,examine,param,old,pattern,code,string,to,replace,param,new,pattern,code,string,to,insert,return,a,code,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,string,builder,sb,new,string,builder,int,pos,0,int,index,in,string,index,of,old,pattern,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, String newPattern);1487760984;Replace all occurrences of a substring within a string with_another string._@param inString {@code String} to examine_@param oldPattern {@code String} to replace_@param newPattern {@code String} to insert_@return a {@code String} with the replacements;public static String replace(String inString, String oldPattern, String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		int pos = 0_ _		int index = inString.indexOf(oldPattern)__		_		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}_		sb.append(inString.substring(pos))__		_		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,code,string,to,examine,param,old,pattern,code,string,to,replace,param,new,pattern,code,string,to,insert,return,a,code,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,string,builder,sb,new,string,builder,int,pos,0,int,index,in,string,index,of,old,pattern,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, String newPattern);1487778834;Replace all occurrences of a substring within a string with_another string._@param inString {@code String} to examine_@param oldPattern {@code String} to replace_@param newPattern {@code String} to insert_@return a {@code String} with the replacements;public static String replace(String inString, String oldPattern, String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		StringBuilder sb = new StringBuilder()__		int pos = 0_ _		int index = inString.indexOf(oldPattern)__		_		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}_		sb.append(inString.substring(pos))__		_		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,code,string,to,examine,param,old,pattern,code,string,to,replace,param,new,pattern,code,string,to,insert,return,a,code,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,string,builder,sb,new,string,builder,int,pos,0,int,index,in,string,index,of,old,pattern,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, String newPattern);1491898314;Replace all occurrences of a substring within a string with_another string._@param inString {@code String} to examine_@param oldPattern {@code String} to replace_@param newPattern {@code String} to insert_@return a {@code String} with the replacements;public static String replace(String inString, String oldPattern, String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		int index = inString.indexOf(oldPattern)__		if (index == -1) {_			_			return inString__		}__		StringBuilder sb = new StringBuilder(inString.length())__		int pos = 0_  _		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}_		_		sb.append(inString.substring(pos))__		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,code,string,to,examine,param,old,pattern,code,string,to,replace,param,new,pattern,code,string,to,insert,return,a,code,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,int,index,in,string,index,of,old,pattern,if,index,1,return,in,string,string,builder,sb,new,string,builder,in,string,length,int,pos,0,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, String newPattern);1491903650;Replace all occurrences of a substring within a string with_another string._@param inString {@code String} to examine_@param oldPattern {@code String} to replace_@param newPattern {@code String} to insert_@return a {@code String} with the replacements;public static String replace(String inString, String oldPattern, String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		int index = inString.indexOf(oldPattern)__		if (index == -1) {_			_			return inString__		}__		int capacity = inString.length()__		if (newPattern.length() > oldPattern.length()) {_			capacity += 16__		}_		StringBuilder sb = new StringBuilder(capacity)___		int pos = 0_  _		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}__		_		sb.append(inString.substring(pos))__		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,code,string,to,examine,param,old,pattern,code,string,to,replace,param,new,pattern,code,string,to,insert,return,a,code,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,int,index,in,string,index,of,old,pattern,if,index,1,return,in,string,int,capacity,in,string,length,if,new,pattern,length,old,pattern,length,capacity,16,string,builder,sb,new,string,builder,capacity,int,pos,0,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, String newPattern);1495868221;Replace all occurrences of a substring within a string with_another string._@param inString {@code String} to examine_@param oldPattern {@code String} to replace_@param newPattern {@code String} to insert_@return a {@code String} with the replacements;public static String replace(String inString, String oldPattern, String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		int index = inString.indexOf(oldPattern)__		if (index == -1) {_			_			return inString__		}__		int capacity = inString.length()__		if (newPattern.length() > oldPattern.length()) {_			capacity += 16__		}_		StringBuilder sb = new StringBuilder(capacity)___		int pos = 0_  _		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}__		_		sb.append(inString.substring(pos))__		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,code,string,to,examine,param,old,pattern,code,string,to,replace,param,new,pattern,code,string,to,insert,return,a,code,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,int,index,in,string,index,of,old,pattern,if,index,1,return,in,string,int,capacity,in,string,length,if,new,pattern,length,old,pattern,length,capacity,16,string,builder,sb,new,string,builder,capacity,int,pos,0,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, String newPattern);1496243689;Replace all occurrences of a substring within a string with_another string._@param inString {@code String} to examine_@param oldPattern {@code String} to replace_@param newPattern {@code String} to insert_@return a {@code String} with the replacements;public static String replace(String inString, String oldPattern, String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		int index = inString.indexOf(oldPattern)__		if (index == -1) {_			_			return inString__		}__		int capacity = inString.length()__		if (newPattern.length() > oldPattern.length()) {_			capacity += 16__		}_		StringBuilder sb = new StringBuilder(capacity)___		int pos = 0_  _		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}__		_		sb.append(inString.substring(pos))__		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,code,string,to,examine,param,old,pattern,code,string,to,replace,param,new,pattern,code,string,to,insert,return,a,code,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,int,index,in,string,index,of,old,pattern,if,index,1,return,in,string,int,capacity,in,string,length,if,new,pattern,length,old,pattern,length,capacity,16,string,builder,sb,new,string,builder,capacity,int,pos,0,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, String newPattern);1496259743;Replace all occurrences of a substring within a string with_another string._@param inString {@code String} to examine_@param oldPattern {@code String} to replace_@param newPattern {@code String} to insert_@return a {@code String} with the replacements;public static String replace(String inString, String oldPattern, String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		int index = inString.indexOf(oldPattern)__		if (index == -1) {_			_			return inString__		}__		int capacity = inString.length()__		if (newPattern.length() > oldPattern.length()) {_			capacity += 16__		}_		StringBuilder sb = new StringBuilder(capacity)___		int pos = 0_  _		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}__		_		sb.append(inString.substring(pos))__		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,code,string,to,examine,param,old,pattern,code,string,to,replace,param,new,pattern,code,string,to,insert,return,a,code,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,int,index,in,string,index,of,old,pattern,if,index,1,return,in,string,int,capacity,in,string,length,if,new,pattern,length,old,pattern,length,capacity,16,string,builder,sb,new,string,builder,capacity,int,pos,0,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String capitalize(String str);1328020251;Capitalize a <code>String</code>, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the String to capitalize, may be <code>null</code>_@return the capitalized String, <code>null</code> if null;public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,code,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,string,to,capitalize,may,be,code,null,code,return,the,capitalized,string,code,null,code,if,null;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1337236962;Capitalize a <code>String</code>, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the String to capitalize, may be <code>null</code>_@return the capitalized String, <code>null</code> if null;public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,code,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,string,to,capitalize,may,be,code,null,code,return,the,capitalized,string,code,null,code,if,null;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1356735495;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the String to capitalize, may be {@code null}_@return the capitalized String, {@code null} if null;public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,string,to,capitalize,may,be,code,null,return,the,capitalized,string,code,null,if,null;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1367955086;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the String to capitalize, may be {@code null}_@return the capitalized String, {@code null} if null;public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,string,to,capitalize,may,be,code,null,return,the,capitalized,string,code,null,if,null;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1380921248;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the String to capitalize, may be {@code null}_@return the capitalized String, {@code null} if null;public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,string,to,capitalize,may,be,code,null,return,the,capitalized,string,code,null,if,null;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1382750743;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the String to capitalize, may be {@code null}_@return the capitalized String, {@code null} if null;public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,string,to,capitalize,may,be,code,null,return,the,capitalized,string,code,null,if,null;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1385423968;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the String to capitalize, may be {@code null}_@return the capitalized String, {@code null} if null;public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,string,to,capitalize,may,be,code,null,return,the,capitalized,string,code,null,if,null;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1400189212;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the String to capitalize, may be {@code null}_@return the capitalized String, {@code null} if null;public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,string,to,capitalize,may,be,code,null,return,the,capitalized,string,code,null,if,null;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1400531359;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the String to capitalize, may be {@code null}_@return the capitalized String, {@code null} if null;public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,string,to,capitalize,may,be,code,null,return,the,capitalized,string,code,null,if,null;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1402676350;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the String to capitalize, may be {@code null}_@return the capitalized String, {@code null} if null;public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,string,to,capitalize,may,be,code,null,return,the,capitalized,string,code,null,if,null;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1426267150;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the String to capitalize, may be {@code null}_@return the capitalized String, {@code null} if null;public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,string,to,capitalize,may,be,code,null,return,the,capitalized,string,code,null,if,null;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1429034538;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the String to capitalize, may be {@code null}_@return the capitalized String, {@code null} if null;public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,string,to,capitalize,may,be,code,null,return,the,capitalized,string,code,null,if,null;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1429034756;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the {@code String} to capitalize, may be {@code null}_@return the capitalized {@code String}, or {@code null} if the supplied_string is {@code null};public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,code,string,to,capitalize,may,be,code,null,return,the,capitalized,code,string,or,code,null,if,the,supplied,string,is,code,null;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1431006895;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the {@code String} to capitalize, may be {@code null}_@return the capitalized {@code String}, or {@code null} if the supplied_string is {@code null};public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,code,string,to,capitalize,may,be,code,null,return,the,capitalized,code,string,or,code,null,if,the,supplied,string,is,code,null;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1431007368;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the {@code String} to capitalize, may be {@code null}_@return the capitalized {@code String}, or {@code null} if the supplied_string is {@code null};public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,code,string,to,capitalize,may,be,code,null,return,the,capitalized,code,string,or,code,null,if,the,supplied,string,is,code,null;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1449489126;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the {@code String} to capitalize, may be {@code null}_@return the capitalized {@code String}, or {@code null} if the supplied_string is {@code null};public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,code,string,to,capitalize,may,be,code,null,return,the,capitalized,code,string,or,code,null,if,the,supplied,string,is,code,null;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1467730834;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the {@code String} to capitalize, may be {@code null}_@return the capitalized {@code String}, or {@code null} if the supplied_string is {@code null};public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,code,string,to,capitalize,may,be,code,null,return,the,capitalized,code,string,or,code,null,if,the,supplied,string,is,code,null;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1472128018;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the {@code String} to capitalize, may be {@code null}_@return the capitalized {@code String}, or {@code null} if the supplied_string is {@code null};public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,code,string,to,capitalize,may,be,code,null,return,the,capitalized,code,string,or,code,null,if,the,supplied,string,is,code,null;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1472202842;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the {@code String} to capitalize, may be {@code null}_@return the capitalized {@code String}, or {@code null} if the supplied_string is {@code null};public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,code,string,to,capitalize,may,be,code,null,return,the,capitalized,code,string,or,code,null,if,the,supplied,string,is,code,null;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1473942665;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the {@code String} to capitalize, may be {@code null}_@return the capitalized {@code String}, or {@code null} if the supplied_string is {@code null};public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,code,string,to,capitalize,may,be,code,null,return,the,capitalized,code,string,or,code,null,if,the,supplied,string,is,code,null;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1484248946;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the {@code String} to capitalize, may be {@code null}_@return the capitalized {@code String}, or {@code null} if the supplied_string is {@code null};public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,code,string,to,capitalize,may,be,code,null,return,the,capitalized,code,string,or,code,null,if,the,supplied,string,is,code,null;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1484260238;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the {@code String} to capitalize, may be {@code null}_@return the capitalized {@code String}, or {@code null} if the supplied_string is {@code null};public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,code,string,to,capitalize,may,be,code,null,return,the,capitalized,code,string,or,code,null,if,the,supplied,string,is,code,null;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1484694546;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the {@code String} to capitalize, may be {@code null}_@return the capitalized {@code String}, or {@code null} if the supplied_string is {@code null};public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,code,string,to,capitalize,may,be,code,null,return,the,capitalized,code,string,or,code,null,if,the,supplied,string,is,code,null;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1487760984;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the {@code String} to capitalize, may be {@code null}_@return the capitalized {@code String}, or {@code null} if the supplied_string is {@code null};public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,code,string,to,capitalize,may,be,code,null,return,the,capitalized,code,string,or,code,null,if,the,supplied,string,is,code,null;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1487778834;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the {@code String} to capitalize, may be {@code null}_@return the capitalized {@code String}, or {@code null} if the supplied_string is {@code null};public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,code,string,to,capitalize,may,be,code,null,return,the,capitalized,code,string,or,code,null,if,the,supplied,string,is,code,null;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1491898314;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the {@code String} to capitalize, may be {@code null}_@return the capitalized {@code String}, or {@code null} if the supplied_string is {@code null};public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,code,string,to,capitalize,may,be,code,null,return,the,capitalized,code,string,or,code,null,if,the,supplied,string,is,code,null;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1491903650;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the {@code String} to capitalize, may be {@code null}_@return the capitalized {@code String}, or {@code null} if the supplied_string is {@code null};public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,code,string,to,capitalize,may,be,code,null,return,the,capitalized,code,string,or,code,null,if,the,supplied,string,is,code,null;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1496837955;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the {@code String} to capitalize_@return the capitalized {@code String};public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,code,string,to,capitalize,return,the,capitalized,code,string;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1499270197;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the {@code String} to capitalize_@return the capitalized {@code String};public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,code,string,to,capitalize,return,the,capitalized,code,string;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1508667152;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the {@code String} to capitalize_@return the capitalized {@code String};public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,code,string,to,capitalize,return,the,capitalized,code,string;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1508675477;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the {@code String} to capitalize_@return the capitalized {@code String};public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,code,string,to,capitalize,return,the,capitalized,code,string;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1508843807;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the {@code String} to capitalize_@return the capitalized {@code String};public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,code,string,to,capitalize,return,the,capitalized,code,string;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1516903831;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the {@code String} to capitalize_@return the capitalized {@code String};public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,code,string,to,capitalize,return,the,capitalized,code,string;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1519295386;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the {@code String} to capitalize_@return the capitalized {@code String};public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,code,string,to,capitalize,return,the,capitalized,code,string;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1519308837;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the {@code String} to capitalize_@return the capitalized {@code String};public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,code,string,to,capitalize,return,the,capitalized,code,string;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1519588127;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the {@code String} to capitalize_@return the capitalized {@code String};public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,code,string,to,capitalize,return,the,capitalized,code,string;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1522332352;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the {@code String} to capitalize_@return the capitalized {@code String};public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,code,string,to,capitalize,return,the,capitalized,code,string;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1525166194;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the {@code String} to capitalize_@return the capitalized {@code String};public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,code,string,to,capitalize,return,the,capitalized,code,string;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1530188116;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the {@code String} to capitalize_@return the capitalized {@code String};public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,code,string,to,capitalize,return,the,capitalized,code,string;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1531843079;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the {@code String} to capitalize_@return the capitalized {@code String};public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,code,string,to,capitalize,return,the,capitalized,code,string;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1531905026;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the {@code String} to capitalize_@return the capitalized {@code String};public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,code,string,to,capitalize,return,the,capitalized,code,string;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1533557519;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the {@code String} to capitalize_@return the capitalized {@code String};public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,code,string,to,capitalize,return,the,capitalized,code,string;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1533602820;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the {@code String} to capitalize_@return the capitalized {@code String};public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,code,string,to,capitalize,return,the,capitalized,code,string;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1535316501;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the {@code String} to capitalize_@return the capitalized {@code String};public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,code,string,to,capitalize,return,the,capitalized,code,string;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1550237113;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the {@code String} to capitalize_@return the capitalized {@code String};public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,code,string,to,capitalize,return,the,capitalized,code,string;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String capitalize(String str);1550238935;Capitalize a {@code String}, changing the first letter to_upper case as per {@link Character#toUpperCase(char)}._No other letters are changed._@param str the {@code String} to capitalize_@return the capitalized {@code String};public static String capitalize(String str) {_		return changeFirstCharacterCase(str, true)__	};capitalize,a,code,string,changing,the,first,letter,to,upper,case,as,per,link,character,to,upper,case,char,no,other,letters,are,changed,param,str,the,code,string,to,capitalize,return,the,capitalized,code,string;public,static,string,capitalize,string,str,return,change,first,character,case,str,true
StringUtils -> public static String arrayToDelimitedString(@Nullable Object[] arr, String delim);1496837955;Convert a {@code String} array into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String arrayToDelimitedString(@Nullable Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}__		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convert,a,code,string,array,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,array,to,delimited,string,nullable,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(@Nullable Object[] arr, String delim);1499270197;Convert a {@code String} array into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String arrayToDelimitedString(@Nullable Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}__		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convert,a,code,string,array,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,array,to,delimited,string,nullable,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(@Nullable Object[] arr, String delim);1508667152;Convert a {@code String} array into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String arrayToDelimitedString(@Nullable Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}__		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convert,a,code,string,array,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,array,to,delimited,string,nullable,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(@Nullable Object[] arr, String delim);1508675477;Convert a {@code String} array into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String arrayToDelimitedString(@Nullable Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}__		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convert,a,code,string,array,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,array,to,delimited,string,nullable,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(@Nullable Object[] arr, String delim);1508843807;Convert a {@code String} array into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String arrayToDelimitedString(@Nullable Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}__		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convert,a,code,string,array,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,array,to,delimited,string,nullable,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(@Nullable Object[] arr, String delim);1516903831;Convert a {@code String} array into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String arrayToDelimitedString(@Nullable Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}__		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convert,a,code,string,array,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,array,to,delimited,string,nullable,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(@Nullable Object[] arr, String delim);1519295386;Convert a {@code String} array into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String arrayToDelimitedString(@Nullable Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}__		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convert,a,code,string,array,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,array,to,delimited,string,nullable,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(@Nullable Object[] arr, String delim);1519308837;Convert a {@code String} array into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String arrayToDelimitedString(@Nullable Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}__		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convert,a,code,string,array,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,array,to,delimited,string,nullable,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(@Nullable Object[] arr, String delim);1519588127;Convert a {@code String} array into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String arrayToDelimitedString(@Nullable Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}__		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convert,a,code,string,array,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,array,to,delimited,string,nullable,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(@Nullable Object[] arr, String delim);1522332352;Convert a {@code String} array into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String arrayToDelimitedString(@Nullable Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}__		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convert,a,code,string,array,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,array,to,delimited,string,nullable,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(@Nullable Object[] arr, String delim);1525166194;Convert a {@code String} array into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String arrayToDelimitedString(@Nullable Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}__		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convert,a,code,string,array,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,array,to,delimited,string,nullable,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(@Nullable Object[] arr, String delim);1530188116;Convert a {@code String} array into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String arrayToDelimitedString(@Nullable Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}__		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convert,a,code,string,array,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,array,to,delimited,string,nullable,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(@Nullable Object[] arr, String delim);1531843079;Convert a {@code String} array into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String arrayToDelimitedString(@Nullable Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}__		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convert,a,code,string,array,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,array,to,delimited,string,nullable,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(@Nullable Object[] arr, String delim);1531905026;Convert a {@code String} array into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String arrayToDelimitedString(@Nullable Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}__		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convert,a,code,string,array,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,array,to,delimited,string,nullable,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(@Nullable Object[] arr, String delim);1533557519;Convert a {@code String} array into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display (potentially {@code null} or empty)_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String arrayToDelimitedString(@Nullable Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}__		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convert,a,code,string,array,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,potentially,code,null,or,empty,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,array,to,delimited,string,nullable,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(@Nullable Object[] arr, String delim);1533602820;Convert a {@code String} array into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display (potentially {@code null} or empty)_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String arrayToDelimitedString(@Nullable Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}__		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convert,a,code,string,array,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,potentially,code,null,or,empty,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,array,to,delimited,string,nullable,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(@Nullable Object[] arr, String delim);1535316501;Convert a {@code String} array into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display (potentially {@code null} or empty)_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String arrayToDelimitedString(@Nullable Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}__		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convert,a,code,string,array,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,potentially,code,null,or,empty,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,array,to,delimited,string,nullable,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(@Nullable Object[] arr, String delim);1550237113;Convert a {@code String} array into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display (potentially {@code null} or empty)_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String arrayToDelimitedString(@Nullable Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}__		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convert,a,code,string,array,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,potentially,code,null,or,empty,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,array,to,delimited,string,nullable,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(@Nullable Object[] arr, String delim);1550238935;Convert a {@code String} array into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display (potentially {@code null} or empty)_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String arrayToDelimitedString(@Nullable Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}__		StringJoiner sj = new StringJoiner(delim)__		for (Object o : arr) {_			sj.add(String.valueOf(o))__		}_		return sj.toString()__	};convert,a,code,string,array,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,potentially,code,null,or,empty,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,array,to,delimited,string,nullable,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,joiner,sj,new,string,joiner,delim,for,object,o,arr,sj,add,string,value,of,o,return,sj,to,string
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1328020251;Convenience method to return a Collection as a CSV String._E.g. useful for <code>toString()</code> implementations._@param coll the Collection to display_@return the delimited String;public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convenience,method,to,return,a,collection,as,a,csv,string,e,g,useful,for,code,to,string,code,implementations,param,coll,the,collection,to,display,return,the,delimited,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1337236962;Convenience method to return a Collection as a CSV String._E.g. useful for <code>toString()</code> implementations._@param coll the Collection to display_@return the delimited String;public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convenience,method,to,return,a,collection,as,a,csv,string,e,g,useful,for,code,to,string,code,implementations,param,coll,the,collection,to,display,return,the,delimited,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1356735495;Convenience method to return a Collection as a CSV String._E.g. useful for {@code toString()} implementations._@param coll the Collection to display_@return the delimited String;public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convenience,method,to,return,a,collection,as,a,csv,string,e,g,useful,for,code,to,string,implementations,param,coll,the,collection,to,display,return,the,delimited,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1367955086;Convenience method to return a Collection as a CSV String._E.g. useful for {@code toString()} implementations._@param coll the Collection to display_@return the delimited String;public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convenience,method,to,return,a,collection,as,a,csv,string,e,g,useful,for,code,to,string,implementations,param,coll,the,collection,to,display,return,the,delimited,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1380921248;Convenience method to return a Collection as a CSV String._E.g. useful for {@code toString()} implementations._@param coll the Collection to display_@return the delimited String;public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convenience,method,to,return,a,collection,as,a,csv,string,e,g,useful,for,code,to,string,implementations,param,coll,the,collection,to,display,return,the,delimited,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1382750743;Convenience method to return a Collection as a CSV String._E.g. useful for {@code toString()} implementations._@param coll the Collection to display_@return the delimited String;public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convenience,method,to,return,a,collection,as,a,csv,string,e,g,useful,for,code,to,string,implementations,param,coll,the,collection,to,display,return,the,delimited,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1385423968;Convenience method to return a Collection as a CSV String._E.g. useful for {@code toString()} implementations._@param coll the Collection to display_@return the delimited String;public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convenience,method,to,return,a,collection,as,a,csv,string,e,g,useful,for,code,to,string,implementations,param,coll,the,collection,to,display,return,the,delimited,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1400189212;Convenience method to return a Collection as a CSV String._E.g. useful for {@code toString()} implementations._@param coll the Collection to display_@return the delimited String;public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convenience,method,to,return,a,collection,as,a,csv,string,e,g,useful,for,code,to,string,implementations,param,coll,the,collection,to,display,return,the,delimited,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1400531359;Convenience method to return a Collection as a CSV String._E.g. useful for {@code toString()} implementations._@param coll the Collection to display_@return the delimited String;public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convenience,method,to,return,a,collection,as,a,csv,string,e,g,useful,for,code,to,string,implementations,param,coll,the,collection,to,display,return,the,delimited,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1402676350;Convenience method to return a Collection as a CSV String._E.g. useful for {@code toString()} implementations._@param coll the Collection to display_@return the delimited String;public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convenience,method,to,return,a,collection,as,a,csv,string,e,g,useful,for,code,to,string,implementations,param,coll,the,collection,to,display,return,the,delimited,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1426267150;Convenience method to return a Collection as a CSV String._E.g. useful for {@code toString()} implementations._@param coll the Collection to display_@return the delimited String;public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convenience,method,to,return,a,collection,as,a,csv,string,e,g,useful,for,code,to,string,implementations,param,coll,the,collection,to,display,return,the,delimited,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1429034538;Convenience method to return a Collection as a CSV String._E.g. useful for {@code toString()} implementations._@param coll the Collection to display_@return the delimited String;public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convenience,method,to,return,a,collection,as,a,csv,string,e,g,useful,for,code,to,string,implementations,param,coll,the,collection,to,display,return,the,delimited,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1429034756;Convert a {@code Collection} into a delimited {@code String} (e.g., CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@return the delimited {@code String};public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,return,the,delimited,code,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1431006895;Convert a {@code Collection} into a delimited {@code String} (e.g., CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@return the delimited {@code String};public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,return,the,delimited,code,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1431007368;Convert a {@code Collection} into a delimited {@code String} (e.g., CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@return the delimited {@code String};public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,return,the,delimited,code,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1449489126;Convert a {@code Collection} into a delimited {@code String} (e.g., CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@return the delimited {@code String};public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,return,the,delimited,code,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1467730834;Convert a {@code Collection} into a delimited {@code String} (e.g., CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@return the delimited {@code String};public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,return,the,delimited,code,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1472128018;Convert a {@code Collection} into a delimited {@code String} (e.g., CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@return the delimited {@code String};public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,return,the,delimited,code,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1472202842;Convert a {@code Collection} into a delimited {@code String} (e.g., CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@return the delimited {@code String};public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,return,the,delimited,code,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1473942665;Convert a {@code Collection} into a delimited {@code String} (e.g., CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@return the delimited {@code String};public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,return,the,delimited,code,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1484248946;Convert a {@code Collection} into a delimited {@code String} (e.g., CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@return the delimited {@code String};public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,return,the,delimited,code,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1484260238;Convert a {@code Collection} into a delimited {@code String} (e.g., CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@return the delimited {@code String};public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,return,the,delimited,code,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1484694546;Convert a {@code Collection} into a delimited {@code String} (e.g., CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@return the delimited {@code String};public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,return,the,delimited,code,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1487760984;Convert a {@code Collection} into a delimited {@code String} (e.g., CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@return the delimited {@code String};public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,return,the,delimited,code,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1487778834;Convert a {@code Collection} into a delimited {@code String} (e.g., CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@return the delimited {@code String};public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,return,the,delimited,code,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1491898314;Convert a {@code Collection} into a delimited {@code String} (e.g., CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@return the delimited {@code String};public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,return,the,delimited,code,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1491903650;Convert a {@code Collection} into a delimited {@code String} (e.g., CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@return the delimited {@code String};public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,return,the,delimited,code,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1495868221;Convert a {@code Collection} into a delimited {@code String} (e.g., CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@return the delimited {@code String};public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,return,the,delimited,code,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1496243689;Convert a {@code Collection} into a delimited {@code String} (e.g., CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@return the delimited {@code String};public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,return,the,delimited,code,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1496259743;Convert a {@code Collection} into a delimited {@code String} (e.g., CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@return the delimited {@code String};public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,return,the,delimited,code,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1496837955;Convert a {@code Collection} into a delimited {@code String} (e.g., CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@return the delimited {@code String};public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,return,the,delimited,code,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1499270197;Convert a {@code Collection} into a delimited {@code String} (e.g., CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@return the delimited {@code String};public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,return,the,delimited,code,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1508667152;Convert a {@code Collection} into a delimited {@code String} (e.g., CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@return the delimited {@code String};public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,return,the,delimited,code,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1508675477;Convert a {@code Collection} into a delimited {@code String} (e.g., CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@return the delimited {@code String};public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,return,the,delimited,code,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1508843807;Convert a {@code Collection} into a delimited {@code String} (e.g., CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@return the delimited {@code String};public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,return,the,delimited,code,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1516903831;Convert a {@code Collection} into a delimited {@code String} (e.g., CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@return the delimited {@code String};public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,return,the,delimited,code,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1519295386;Convert a {@code Collection} into a delimited {@code String} (e.g., CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@return the delimited {@code String};public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,return,the,delimited,code,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1519308837;Convert a {@code Collection} into a delimited {@code String} (e.g., CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@return the delimited {@code String};public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,return,the,delimited,code,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1519588127;Convert a {@code Collection} into a delimited {@code String} (e.g., CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@return the delimited {@code String};public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,return,the,delimited,code,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1522332352;Convert a {@code Collection} into a delimited {@code String} (e.g., CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@return the delimited {@code String};public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,return,the,delimited,code,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1525166194;Convert a {@code Collection} into a delimited {@code String} (e.g., CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@return the delimited {@code String};public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,return,the,delimited,code,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1530188116;Convert a {@code Collection} into a delimited {@code String} (e.g., CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@return the delimited {@code String};public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,return,the,delimited,code,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1531843079;Convert a {@code Collection} into a delimited {@code String} (e.g., CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@return the delimited {@code String};public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,return,the,delimited,code,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static String collectionToCommaDelimitedString(Collection<?> coll);1531905026;Convert a {@code Collection} into a delimited {@code String} (e.g., CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@return the delimited {@code String};public static String collectionToCommaDelimitedString(Collection<?> coll) {_		return collectionToDelimitedString(coll, ",")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,return,the,delimited,code,string;public,static,string,collection,to,comma,delimited,string,collection,coll,return,collection,to,delimited,string,coll
StringUtils -> public static int countOccurrencesOf(@Nullable String str, @Nullable String sub);1495868221;Count the occurrences of the substring {@code sub} in string {@code str}._@param str string to search in. Return 0 if this is {@code null}._@param sub string to search for. Return 0 if this is {@code null}.;public static int countOccurrencesOf(@Nullable String str, @Nullable String sub) {_		if (!hasLength(str) || !hasLength(sub)) {_			return 0__		}__		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,code,sub,in,string,code,str,param,str,string,to,search,in,return,0,if,this,is,code,null,param,sub,string,to,search,for,return,0,if,this,is,code,null;public,static,int,count,occurrences,of,nullable,string,str,nullable,string,sub,if,has,length,str,has,length,sub,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(@Nullable String str, @Nullable String sub);1496243689;Count the occurrences of the substring {@code sub} in string {@code str}._@param str string to search in. Return 0 if this is {@code null}._@param sub string to search for. Return 0 if this is {@code null}.;public static int countOccurrencesOf(@Nullable String str, @Nullable String sub) {_		if (!hasLength(str) || !hasLength(sub)) {_			return 0__		}__		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,code,sub,in,string,code,str,param,str,string,to,search,in,return,0,if,this,is,code,null,param,sub,string,to,search,for,return,0,if,this,is,code,null;public,static,int,count,occurrences,of,nullable,string,str,nullable,string,sub,if,has,length,str,has,length,sub,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static int countOccurrencesOf(@Nullable String str, @Nullable String sub);1496259743;Count the occurrences of the substring {@code sub} in string {@code str}._@param str string to search in. Return 0 if this is {@code null}._@param sub string to search for. Return 0 if this is {@code null}.;public static int countOccurrencesOf(@Nullable String str, @Nullable String sub) {_		if (!hasLength(str) || !hasLength(sub)) {_			return 0__		}__		int count = 0__		int pos = 0__		int idx__		while ((idx = str.indexOf(sub, pos)) != -1) {_			++count__			pos = idx + sub.length()__		}_		return count__	};count,the,occurrences,of,the,substring,code,sub,in,string,code,str,param,str,string,to,search,in,return,0,if,this,is,code,null,param,sub,string,to,search,for,return,0,if,this,is,code,null;public,static,int,count,occurrences,of,nullable,string,str,nullable,string,sub,if,has,length,str,has,length,sub,return,0,int,count,0,int,pos,0,int,idx,while,idx,str,index,of,sub,pos,1,count,pos,idx,sub,length,return,count
StringUtils -> public static boolean pathEquals(String path1, String path2);1328020251;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1337236962;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1356735495;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1367955086;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1380921248;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1382750743;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1385423968;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1400189212;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1400531359;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1402676350;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1426267150;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1429034538;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1429034756;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1431006895;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1431007368;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1449489126;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1467730834;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1472128018;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1472202842;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1473942665;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1484248946;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1484260238;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1484694546;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1487760984;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1487778834;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1491898314;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1491903650;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1495868221;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1496243689;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1496259743;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1496837955;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1499270197;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1508667152;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1508675477;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1508843807;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1516903831;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1519295386;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1519308837;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1519588127;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1522332352;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1525166194;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1530188116;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1531843079;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1531905026;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1533557519;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1533602820;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1535316501;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1550237113;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static boolean pathEquals(String path1, String path2);1550238935;Compare two paths after normalization of them._@param path1 first path for comparison_@param path2 second path for comparison_@return whether the two paths are equivalent after normalization;public static boolean pathEquals(String path1, String path2) {_		return cleanPath(path1).equals(cleanPath(path2))__	};compare,two,paths,after,normalization,of,them,param,path1,first,path,for,comparison,param,path2,second,path,for,comparison,return,whether,the,two,paths,are,equivalent,after,normalization;public,static,boolean,path,equals,string,path1,string,path2,return,clean,path,path1,equals,clean,path,path2
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1328020251;Copy the given Enumeration into a String array._The Enumeration must contain String elements only._@param enumeration the Enumeration to copy_@return the String array (<code>null</code> if the passed-in_Enumeration was <code>null</code>);public static String[] toStringArray(Enumeration<String> enumeration) {_		if (enumeration == null) {_			return null__		}_		List<String> list = Collections.list(enumeration)__		return list.toArray(new String[list.size()])__	};copy,the,given,enumeration,into,a,string,array,the,enumeration,must,contain,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,string,array,code,null,code,if,the,passed,in,enumeration,was,code,null,code;public,static,string,to,string,array,enumeration,string,enumeration,if,enumeration,null,return,null,list,string,list,collections,list,enumeration,return,list,to,array,new,string,list,size
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1337236962;Copy the given Enumeration into a String array._The Enumeration must contain String elements only._@param enumeration the Enumeration to copy_@return the String array (<code>null</code> if the passed-in_Enumeration was <code>null</code>);public static String[] toStringArray(Enumeration<String> enumeration) {_		if (enumeration == null) {_			return null__		}_		List<String> list = Collections.list(enumeration)__		return list.toArray(new String[list.size()])__	};copy,the,given,enumeration,into,a,string,array,the,enumeration,must,contain,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,string,array,code,null,code,if,the,passed,in,enumeration,was,code,null,code;public,static,string,to,string,array,enumeration,string,enumeration,if,enumeration,null,return,null,list,string,list,collections,list,enumeration,return,list,to,array,new,string,list,size
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1356735495;Copy the given Enumeration into a String array._The Enumeration must contain String elements only._@param enumeration the Enumeration to copy_@return the String array ({@code null} if the passed-in_Enumeration was {@code null});public static String[] toStringArray(Enumeration<String> enumeration) {_		if (enumeration == null) {_			return null__		}_		List<String> list = Collections.list(enumeration)__		return list.toArray(new String[list.size()])__	};copy,the,given,enumeration,into,a,string,array,the,enumeration,must,contain,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,string,array,code,null,if,the,passed,in,enumeration,was,code,null;public,static,string,to,string,array,enumeration,string,enumeration,if,enumeration,null,return,null,list,string,list,collections,list,enumeration,return,list,to,array,new,string,list,size
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1367955086;Copy the given Enumeration into a String array._The Enumeration must contain String elements only._@param enumeration the Enumeration to copy_@return the String array ({@code null} if the passed-in_Enumeration was {@code null});public static String[] toStringArray(Enumeration<String> enumeration) {_		if (enumeration == null) {_			return null__		}_		List<String> list = Collections.list(enumeration)__		return list.toArray(new String[list.size()])__	};copy,the,given,enumeration,into,a,string,array,the,enumeration,must,contain,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,string,array,code,null,if,the,passed,in,enumeration,was,code,null;public,static,string,to,string,array,enumeration,string,enumeration,if,enumeration,null,return,null,list,string,list,collections,list,enumeration,return,list,to,array,new,string,list,size
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1380921248;Copy the given Enumeration into a String array._The Enumeration must contain String elements only._@param enumeration the Enumeration to copy_@return the String array ({@code null} if the passed-in_Enumeration was {@code null});public static String[] toStringArray(Enumeration<String> enumeration) {_		if (enumeration == null) {_			return null__		}_		List<String> list = Collections.list(enumeration)__		return list.toArray(new String[list.size()])__	};copy,the,given,enumeration,into,a,string,array,the,enumeration,must,contain,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,string,array,code,null,if,the,passed,in,enumeration,was,code,null;public,static,string,to,string,array,enumeration,string,enumeration,if,enumeration,null,return,null,list,string,list,collections,list,enumeration,return,list,to,array,new,string,list,size
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1382750743;Copy the given Enumeration into a String array._The Enumeration must contain String elements only._@param enumeration the Enumeration to copy_@return the String array ({@code null} if the passed-in_Enumeration was {@code null});public static String[] toStringArray(Enumeration<String> enumeration) {_		if (enumeration == null) {_			return null__		}_		List<String> list = Collections.list(enumeration)__		return list.toArray(new String[list.size()])__	};copy,the,given,enumeration,into,a,string,array,the,enumeration,must,contain,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,string,array,code,null,if,the,passed,in,enumeration,was,code,null;public,static,string,to,string,array,enumeration,string,enumeration,if,enumeration,null,return,null,list,string,list,collections,list,enumeration,return,list,to,array,new,string,list,size
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1385423968;Copy the given Enumeration into a String array._The Enumeration must contain String elements only._@param enumeration the Enumeration to copy_@return the String array ({@code null} if the passed-in_Enumeration was {@code null});public static String[] toStringArray(Enumeration<String> enumeration) {_		if (enumeration == null) {_			return null__		}_		List<String> list = Collections.list(enumeration)__		return list.toArray(new String[list.size()])__	};copy,the,given,enumeration,into,a,string,array,the,enumeration,must,contain,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,string,array,code,null,if,the,passed,in,enumeration,was,code,null;public,static,string,to,string,array,enumeration,string,enumeration,if,enumeration,null,return,null,list,string,list,collections,list,enumeration,return,list,to,array,new,string,list,size
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1400189212;Copy the given Enumeration into a String array._The Enumeration must contain String elements only._@param enumeration the Enumeration to copy_@return the String array ({@code null} if the passed-in_Enumeration was {@code null});public static String[] toStringArray(Enumeration<String> enumeration) {_		if (enumeration == null) {_			return null__		}_		List<String> list = Collections.list(enumeration)__		return list.toArray(new String[list.size()])__	};copy,the,given,enumeration,into,a,string,array,the,enumeration,must,contain,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,string,array,code,null,if,the,passed,in,enumeration,was,code,null;public,static,string,to,string,array,enumeration,string,enumeration,if,enumeration,null,return,null,list,string,list,collections,list,enumeration,return,list,to,array,new,string,list,size
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1400531359;Copy the given Enumeration into a String array._The Enumeration must contain String elements only._@param enumeration the Enumeration to copy_@return the String array ({@code null} if the passed-in_Enumeration was {@code null});public static String[] toStringArray(Enumeration<String> enumeration) {_		if (enumeration == null) {_			return null__		}_		List<String> list = Collections.list(enumeration)__		return list.toArray(new String[list.size()])__	};copy,the,given,enumeration,into,a,string,array,the,enumeration,must,contain,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,string,array,code,null,if,the,passed,in,enumeration,was,code,null;public,static,string,to,string,array,enumeration,string,enumeration,if,enumeration,null,return,null,list,string,list,collections,list,enumeration,return,list,to,array,new,string,list,size
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1402676350;Copy the given Enumeration into a String array._The Enumeration must contain String elements only._@param enumeration the Enumeration to copy_@return the String array ({@code null} if the passed-in_Enumeration was {@code null});public static String[] toStringArray(Enumeration<String> enumeration) {_		if (enumeration == null) {_			return null__		}_		List<String> list = Collections.list(enumeration)__		return list.toArray(new String[list.size()])__	};copy,the,given,enumeration,into,a,string,array,the,enumeration,must,contain,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,string,array,code,null,if,the,passed,in,enumeration,was,code,null;public,static,string,to,string,array,enumeration,string,enumeration,if,enumeration,null,return,null,list,string,list,collections,list,enumeration,return,list,to,array,new,string,list,size
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1426267150;Copy the given Enumeration into a String array._The Enumeration must contain String elements only._@param enumeration the Enumeration to copy_@return the String array ({@code null} if the passed-in_Enumeration was {@code null});public static String[] toStringArray(Enumeration<String> enumeration) {_		if (enumeration == null) {_			return null__		}_		List<String> list = Collections.list(enumeration)__		return list.toArray(new String[list.size()])__	};copy,the,given,enumeration,into,a,string,array,the,enumeration,must,contain,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,string,array,code,null,if,the,passed,in,enumeration,was,code,null;public,static,string,to,string,array,enumeration,string,enumeration,if,enumeration,null,return,null,list,string,list,collections,list,enumeration,return,list,to,array,new,string,list,size
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1429034538;Copy the given Enumeration into a String array._The Enumeration must contain String elements only._@param enumeration the Enumeration to copy_@return the String array ({@code null} if the passed-in_Enumeration was {@code null});public static String[] toStringArray(Enumeration<String> enumeration) {_		if (enumeration == null) {_			return null__		}_		List<String> list = Collections.list(enumeration)__		return list.toArray(new String[list.size()])__	};copy,the,given,enumeration,into,a,string,array,the,enumeration,must,contain,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,string,array,code,null,if,the,passed,in,enumeration,was,code,null;public,static,string,to,string,array,enumeration,string,enumeration,if,enumeration,null,return,null,list,string,list,collections,list,enumeration,return,list,to,array,new,string,list,size
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1429034756;Copy the given Enumeration into a {@code String} array._The Enumeration must contain {@code String} elements only._@param enumeration the Enumeration to copy_@return the {@code String} array ({@code null} if the passed-in_Enumeration was {@code null});public static String[] toStringArray(Enumeration<String> enumeration) {_		if (enumeration == null) {_			return null__		}_		List<String> list = Collections.list(enumeration)__		return list.toArray(new String[list.size()])__	};copy,the,given,enumeration,into,a,code,string,array,the,enumeration,must,contain,code,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,code,string,array,code,null,if,the,passed,in,enumeration,was,code,null;public,static,string,to,string,array,enumeration,string,enumeration,if,enumeration,null,return,null,list,string,list,collections,list,enumeration,return,list,to,array,new,string,list,size
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1431006895;Copy the given Enumeration into a {@code String} array._The Enumeration must contain {@code String} elements only._@param enumeration the Enumeration to copy_@return the {@code String} array ({@code null} if the passed-in_Enumeration was {@code null});public static String[] toStringArray(Enumeration<String> enumeration) {_		if (enumeration == null) {_			return null__		}_		List<String> list = Collections.list(enumeration)__		return list.toArray(new String[list.size()])__	};copy,the,given,enumeration,into,a,code,string,array,the,enumeration,must,contain,code,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,code,string,array,code,null,if,the,passed,in,enumeration,was,code,null;public,static,string,to,string,array,enumeration,string,enumeration,if,enumeration,null,return,null,list,string,list,collections,list,enumeration,return,list,to,array,new,string,list,size
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1431007368;Copy the given Enumeration into a {@code String} array._The Enumeration must contain {@code String} elements only._@param enumeration the Enumeration to copy_@return the {@code String} array ({@code null} if the passed-in_Enumeration was {@code null});public static String[] toStringArray(Enumeration<String> enumeration) {_		if (enumeration == null) {_			return null__		}_		List<String> list = Collections.list(enumeration)__		return list.toArray(new String[list.size()])__	};copy,the,given,enumeration,into,a,code,string,array,the,enumeration,must,contain,code,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,code,string,array,code,null,if,the,passed,in,enumeration,was,code,null;public,static,string,to,string,array,enumeration,string,enumeration,if,enumeration,null,return,null,list,string,list,collections,list,enumeration,return,list,to,array,new,string,list,size
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1449489126;Copy the given Enumeration into a {@code String} array._The Enumeration must contain {@code String} elements only._@param enumeration the Enumeration to copy_@return the {@code String} array ({@code null} if the passed-in_Enumeration was {@code null});public static String[] toStringArray(Enumeration<String> enumeration) {_		if (enumeration == null) {_			return null__		}_		List<String> list = Collections.list(enumeration)__		return list.toArray(new String[list.size()])__	};copy,the,given,enumeration,into,a,code,string,array,the,enumeration,must,contain,code,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,code,string,array,code,null,if,the,passed,in,enumeration,was,code,null;public,static,string,to,string,array,enumeration,string,enumeration,if,enumeration,null,return,null,list,string,list,collections,list,enumeration,return,list,to,array,new,string,list,size
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1467730834;Copy the given Enumeration into a {@code String} array._The Enumeration must contain {@code String} elements only._@param enumeration the Enumeration to copy_@return the {@code String} array ({@code null} if the passed-in_Enumeration was {@code null});public static String[] toStringArray(Enumeration<String> enumeration) {_		if (enumeration == null) {_			return null__		}_		List<String> list = Collections.list(enumeration)__		return list.toArray(new String[list.size()])__	};copy,the,given,enumeration,into,a,code,string,array,the,enumeration,must,contain,code,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,code,string,array,code,null,if,the,passed,in,enumeration,was,code,null;public,static,string,to,string,array,enumeration,string,enumeration,if,enumeration,null,return,null,list,string,list,collections,list,enumeration,return,list,to,array,new,string,list,size
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1472128018;Copy the given Enumeration into a {@code String} array._The Enumeration must contain {@code String} elements only._@param enumeration the Enumeration to copy_@return the {@code String} array ({@code null} if the passed-in_Enumeration was {@code null});public static String[] toStringArray(Enumeration<String> enumeration) {_		if (enumeration == null) {_			return null__		}_		List<String> list = Collections.list(enumeration)__		return list.toArray(new String[list.size()])__	};copy,the,given,enumeration,into,a,code,string,array,the,enumeration,must,contain,code,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,code,string,array,code,null,if,the,passed,in,enumeration,was,code,null;public,static,string,to,string,array,enumeration,string,enumeration,if,enumeration,null,return,null,list,string,list,collections,list,enumeration,return,list,to,array,new,string,list,size
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1472202842;Copy the given Enumeration into a {@code String} array._The Enumeration must contain {@code String} elements only._@param enumeration the Enumeration to copy_@return the {@code String} array ({@code null} if the passed-in_Enumeration was {@code null});public static String[] toStringArray(Enumeration<String> enumeration) {_		if (enumeration == null) {_			return null__		}_		List<String> list = Collections.list(enumeration)__		return list.toArray(new String[list.size()])__	};copy,the,given,enumeration,into,a,code,string,array,the,enumeration,must,contain,code,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,code,string,array,code,null,if,the,passed,in,enumeration,was,code,null;public,static,string,to,string,array,enumeration,string,enumeration,if,enumeration,null,return,null,list,string,list,collections,list,enumeration,return,list,to,array,new,string,list,size
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1473942665;Copy the given Enumeration into a {@code String} array._The Enumeration must contain {@code String} elements only._@param enumeration the Enumeration to copy_@return the {@code String} array ({@code null} if the passed-in_Enumeration was {@code null});public static String[] toStringArray(Enumeration<String> enumeration) {_		if (enumeration == null) {_			return null__		}_		List<String> list = Collections.list(enumeration)__		return list.toArray(new String[list.size()])__	};copy,the,given,enumeration,into,a,code,string,array,the,enumeration,must,contain,code,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,code,string,array,code,null,if,the,passed,in,enumeration,was,code,null;public,static,string,to,string,array,enumeration,string,enumeration,if,enumeration,null,return,null,list,string,list,collections,list,enumeration,return,list,to,array,new,string,list,size
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1484248946;Copy the given Enumeration into a {@code String} array._The Enumeration must contain {@code String} elements only._@param enumeration the Enumeration to copy_@return the {@code String} array ({@code null} if the passed-in_Enumeration was {@code null});public static String[] toStringArray(Enumeration<String> enumeration) {_		if (enumeration == null) {_			return null__		}_		List<String> list = Collections.list(enumeration)__		return list.toArray(new String[list.size()])__	};copy,the,given,enumeration,into,a,code,string,array,the,enumeration,must,contain,code,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,code,string,array,code,null,if,the,passed,in,enumeration,was,code,null;public,static,string,to,string,array,enumeration,string,enumeration,if,enumeration,null,return,null,list,string,list,collections,list,enumeration,return,list,to,array,new,string,list,size
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1484260238;Copy the given Enumeration into a {@code String} array._The Enumeration must contain {@code String} elements only._@param enumeration the Enumeration to copy_@return the {@code String} array ({@code null} if the passed-in_Enumeration was {@code null});public static String[] toStringArray(Enumeration<String> enumeration) {_		if (enumeration == null) {_			return null__		}_		List<String> list = Collections.list(enumeration)__		return list.toArray(new String[list.size()])__	};copy,the,given,enumeration,into,a,code,string,array,the,enumeration,must,contain,code,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,code,string,array,code,null,if,the,passed,in,enumeration,was,code,null;public,static,string,to,string,array,enumeration,string,enumeration,if,enumeration,null,return,null,list,string,list,collections,list,enumeration,return,list,to,array,new,string,list,size
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1484694546;Copy the given Enumeration into a {@code String} array._The Enumeration must contain {@code String} elements only._@param enumeration the Enumeration to copy_@return the {@code String} array ({@code null} if the passed-in_Enumeration was {@code null});public static String[] toStringArray(Enumeration<String> enumeration) {_		if (enumeration == null) {_			return null__		}_		List<String> list = Collections.list(enumeration)__		return list.toArray(new String[list.size()])__	};copy,the,given,enumeration,into,a,code,string,array,the,enumeration,must,contain,code,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,code,string,array,code,null,if,the,passed,in,enumeration,was,code,null;public,static,string,to,string,array,enumeration,string,enumeration,if,enumeration,null,return,null,list,string,list,collections,list,enumeration,return,list,to,array,new,string,list,size
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1487760984;Copy the given Enumeration into a {@code String} array._The Enumeration must contain {@code String} elements only._@param enumeration the Enumeration to copy_@return the {@code String} array ({@code null} if the passed-in_Enumeration was {@code null});public static String[] toStringArray(Enumeration<String> enumeration) {_		if (enumeration == null) {_			return null__		}_		List<String> list = Collections.list(enumeration)__		return list.toArray(new String[list.size()])__	};copy,the,given,enumeration,into,a,code,string,array,the,enumeration,must,contain,code,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,code,string,array,code,null,if,the,passed,in,enumeration,was,code,null;public,static,string,to,string,array,enumeration,string,enumeration,if,enumeration,null,return,null,list,string,list,collections,list,enumeration,return,list,to,array,new,string,list,size
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1487778834;Copy the given Enumeration into a {@code String} array._The Enumeration must contain {@code String} elements only._@param enumeration the Enumeration to copy_@return the {@code String} array ({@code null} if the passed-in_Enumeration was {@code null});public static String[] toStringArray(Enumeration<String> enumeration) {_		if (enumeration == null) {_			return null__		}_		List<String> list = Collections.list(enumeration)__		return list.toArray(new String[list.size()])__	};copy,the,given,enumeration,into,a,code,string,array,the,enumeration,must,contain,code,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,code,string,array,code,null,if,the,passed,in,enumeration,was,code,null;public,static,string,to,string,array,enumeration,string,enumeration,if,enumeration,null,return,null,list,string,list,collections,list,enumeration,return,list,to,array,new,string,list,size
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1491898314;Copy the given Enumeration into a {@code String} array._The Enumeration must contain {@code String} elements only._@param enumeration the Enumeration to copy_@return the {@code String} array ({@code null} if the passed-in_Enumeration was {@code null});public static String[] toStringArray(Enumeration<String> enumeration) {_		if (enumeration == null) {_			return null__		}__		List<String> list = Collections.list(enumeration)__		return list.toArray(new String[list.size()])__	};copy,the,given,enumeration,into,a,code,string,array,the,enumeration,must,contain,code,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,code,string,array,code,null,if,the,passed,in,enumeration,was,code,null;public,static,string,to,string,array,enumeration,string,enumeration,if,enumeration,null,return,null,list,string,list,collections,list,enumeration,return,list,to,array,new,string,list,size
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1491903650;Copy the given Enumeration into a {@code String} array._The Enumeration must contain {@code String} elements only._@param enumeration the Enumeration to copy_@return the {@code String} array ({@code null} if the passed-in_Enumeration was {@code null});public static String[] toStringArray(Enumeration<String> enumeration) {_		if (enumeration == null) {_			return null__		}__		List<String> list = Collections.list(enumeration)__		return list.toArray(new String[list.size()])__	};copy,the,given,enumeration,into,a,code,string,array,the,enumeration,must,contain,code,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,code,string,array,code,null,if,the,passed,in,enumeration,was,code,null;public,static,string,to,string,array,enumeration,string,enumeration,if,enumeration,null,return,null,list,string,list,collections,list,enumeration,return,list,to,array,new,string,list,size
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1496837955;Copy the given Enumeration into a {@code String} array._The Enumeration must contain {@code String} elements only._@param enumeration the Enumeration to copy_@return the {@code String} array;public static String[] toStringArray(Enumeration<String> enumeration) {_		List<String> list = Collections.list(enumeration)__		return list.toArray(new String[list.size()])__	};copy,the,given,enumeration,into,a,code,string,array,the,enumeration,must,contain,code,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,code,string,array;public,static,string,to,string,array,enumeration,string,enumeration,list,string,list,collections,list,enumeration,return,list,to,array,new,string,list,size
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1499270197;Copy the given Enumeration into a {@code String} array._The Enumeration must contain {@code String} elements only._@param enumeration the Enumeration to copy_@return the {@code String} array;public static String[] toStringArray(Enumeration<String> enumeration) {_		List<String> list = Collections.list(enumeration)__		return list.toArray(new String[list.size()])__	};copy,the,given,enumeration,into,a,code,string,array,the,enumeration,must,contain,code,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,code,string,array;public,static,string,to,string,array,enumeration,string,enumeration,list,string,list,collections,list,enumeration,return,list,to,array,new,string,list,size
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1508667152;Copy the given Enumeration into a {@code String} array._The Enumeration must contain {@code String} elements only._@param enumeration the Enumeration to copy_@return the {@code String} array;public static String[] toStringArray(Enumeration<String> enumeration) {_		List<String> list = Collections.list(enumeration)__		return list.toArray(new String[list.size()])__	};copy,the,given,enumeration,into,a,code,string,array,the,enumeration,must,contain,code,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,code,string,array;public,static,string,to,string,array,enumeration,string,enumeration,list,string,list,collections,list,enumeration,return,list,to,array,new,string,list,size
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1508675477;Copy the given Enumeration into a {@code String} array._The Enumeration must contain {@code String} elements only._@param enumeration the Enumeration to copy_@return the {@code String} array;public static String[] toStringArray(Enumeration<String> enumeration) {_		List<String> list = Collections.list(enumeration)__		return list.toArray(new String[list.size()])__	};copy,the,given,enumeration,into,a,code,string,array,the,enumeration,must,contain,code,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,code,string,array;public,static,string,to,string,array,enumeration,string,enumeration,list,string,list,collections,list,enumeration,return,list,to,array,new,string,list,size
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1508843807;Copy the given Enumeration into a {@code String} array._The Enumeration must contain {@code String} elements only._@param enumeration the Enumeration to copy_@return the {@code String} array;public static String[] toStringArray(Enumeration<String> enumeration) {_		List<String> list = Collections.list(enumeration)__		return list.toArray(new String[list.size()])__	};copy,the,given,enumeration,into,a,code,string,array,the,enumeration,must,contain,code,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,code,string,array;public,static,string,to,string,array,enumeration,string,enumeration,list,string,list,collections,list,enumeration,return,list,to,array,new,string,list,size
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1516903831;Copy the given Enumeration into a {@code String} array._The Enumeration must contain {@code String} elements only._@param enumeration the Enumeration to copy_@return the {@code String} array;public static String[] toStringArray(Enumeration<String> enumeration) {_		List<String> list = Collections.list(enumeration)__		return list.toArray(new String[list.size()])__	};copy,the,given,enumeration,into,a,code,string,array,the,enumeration,must,contain,code,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,code,string,array;public,static,string,to,string,array,enumeration,string,enumeration,list,string,list,collections,list,enumeration,return,list,to,array,new,string,list,size
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1519295386;Copy the given Enumeration into a {@code String} array._The Enumeration must contain {@code String} elements only._@param enumeration the Enumeration to copy_@return the {@code String} array;public static String[] toStringArray(Enumeration<String> enumeration) {_		return toStringArray(Collections.list(enumeration))__	};copy,the,given,enumeration,into,a,code,string,array,the,enumeration,must,contain,code,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,code,string,array;public,static,string,to,string,array,enumeration,string,enumeration,return,to,string,array,collections,list,enumeration
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1519308837;Copy the given Enumeration into a {@code String} array._The Enumeration must contain {@code String} elements only._@param enumeration the Enumeration to copy_@return the {@code String} array;public static String[] toStringArray(Enumeration<String> enumeration) {_		return toStringArray(Collections.list(enumeration))__	};copy,the,given,enumeration,into,a,code,string,array,the,enumeration,must,contain,code,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,code,string,array;public,static,string,to,string,array,enumeration,string,enumeration,return,to,string,array,collections,list,enumeration
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1519588127;Copy the given Enumeration into a {@code String} array._The Enumeration must contain {@code String} elements only._@param enumeration the Enumeration to copy_@return the {@code String} array;public static String[] toStringArray(Enumeration<String> enumeration) {_		return toStringArray(Collections.list(enumeration))__	};copy,the,given,enumeration,into,a,code,string,array,the,enumeration,must,contain,code,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,code,string,array;public,static,string,to,string,array,enumeration,string,enumeration,return,to,string,array,collections,list,enumeration
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1522332352;Copy the given Enumeration into a {@code String} array._The Enumeration must contain {@code String} elements only._@param enumeration the Enumeration to copy_@return the {@code String} array;public static String[] toStringArray(Enumeration<String> enumeration) {_		return toStringArray(Collections.list(enumeration))__	};copy,the,given,enumeration,into,a,code,string,array,the,enumeration,must,contain,code,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,code,string,array;public,static,string,to,string,array,enumeration,string,enumeration,return,to,string,array,collections,list,enumeration
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1525166194;Copy the given Enumeration into a {@code String} array._The Enumeration must contain {@code String} elements only._@param enumeration the Enumeration to copy_@return the {@code String} array;public static String[] toStringArray(Enumeration<String> enumeration) {_		return toStringArray(Collections.list(enumeration))__	};copy,the,given,enumeration,into,a,code,string,array,the,enumeration,must,contain,code,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,code,string,array;public,static,string,to,string,array,enumeration,string,enumeration,return,to,string,array,collections,list,enumeration
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1530188116;Copy the given Enumeration into a {@code String} array._The Enumeration must contain {@code String} elements only._@param enumeration the Enumeration to copy_@return the {@code String} array;public static String[] toStringArray(Enumeration<String> enumeration) {_		return toStringArray(Collections.list(enumeration))__	};copy,the,given,enumeration,into,a,code,string,array,the,enumeration,must,contain,code,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,code,string,array;public,static,string,to,string,array,enumeration,string,enumeration,return,to,string,array,collections,list,enumeration
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1531843079;Copy the given Enumeration into a {@code String} array._The Enumeration must contain {@code String} elements only._@param enumeration the Enumeration to copy_@return the {@code String} array;public static String[] toStringArray(Enumeration<String> enumeration) {_		return toStringArray(Collections.list(enumeration))__	};copy,the,given,enumeration,into,a,code,string,array,the,enumeration,must,contain,code,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,code,string,array;public,static,string,to,string,array,enumeration,string,enumeration,return,to,string,array,collections,list,enumeration
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1531905026;Copy the given Enumeration into a {@code String} array._The Enumeration must contain {@code String} elements only._@param enumeration the Enumeration to copy_@return the {@code String} array;public static String[] toStringArray(Enumeration<String> enumeration) {_		return toStringArray(Collections.list(enumeration))__	};copy,the,given,enumeration,into,a,code,string,array,the,enumeration,must,contain,code,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,code,string,array;public,static,string,to,string,array,enumeration,string,enumeration,return,to,string,array,collections,list,enumeration
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1533557519;Copy the given Enumeration into a {@code String} array._The Enumeration must contain {@code String} elements only._@param enumeration the Enumeration to copy_@return the {@code String} array;public static String[] toStringArray(Enumeration<String> enumeration) {_		return toStringArray(Collections.list(enumeration))__	};copy,the,given,enumeration,into,a,code,string,array,the,enumeration,must,contain,code,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,code,string,array;public,static,string,to,string,array,enumeration,string,enumeration,return,to,string,array,collections,list,enumeration
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1533602820;Copy the given Enumeration into a {@code String} array._The Enumeration must contain {@code String} elements only._@param enumeration the Enumeration to copy_@return the {@code String} array;public static String[] toStringArray(Enumeration<String> enumeration) {_		return toStringArray(Collections.list(enumeration))__	};copy,the,given,enumeration,into,a,code,string,array,the,enumeration,must,contain,code,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,code,string,array;public,static,string,to,string,array,enumeration,string,enumeration,return,to,string,array,collections,list,enumeration
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1535316501;Copy the given Enumeration into a {@code String} array._The Enumeration must contain {@code String} elements only._@param enumeration the Enumeration to copy_@return the {@code String} array;public static String[] toStringArray(Enumeration<String> enumeration) {_		return toStringArray(Collections.list(enumeration))__	};copy,the,given,enumeration,into,a,code,string,array,the,enumeration,must,contain,code,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,code,string,array;public,static,string,to,string,array,enumeration,string,enumeration,return,to,string,array,collections,list,enumeration
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1550237113;Copy the given Enumeration into a {@code String} array._The Enumeration must contain {@code String} elements only._@param enumeration the Enumeration to copy_@return the {@code String} array;public static String[] toStringArray(Enumeration<String> enumeration) {_		return toStringArray(Collections.list(enumeration))__	};copy,the,given,enumeration,into,a,code,string,array,the,enumeration,must,contain,code,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,code,string,array;public,static,string,to,string,array,enumeration,string,enumeration,return,to,string,array,collections,list,enumeration
StringUtils -> public static String[] toStringArray(Enumeration<String> enumeration);1550238935;Copy the given Enumeration into a {@code String} array._The Enumeration must contain {@code String} elements only._@param enumeration the Enumeration to copy_@return the {@code String} array;public static String[] toStringArray(Enumeration<String> enumeration) {_		return toStringArray(Collections.list(enumeration))__	};copy,the,given,enumeration,into,a,code,string,array,the,enumeration,must,contain,code,string,elements,only,param,enumeration,the,enumeration,to,copy,return,the,code,string,array;public,static,string,to,string,array,enumeration,string,enumeration,return,to,string,array,collections,list,enumeration
StringUtils -> public static String[] tokenizeToStringArray(String str, String delimiters);1328020251;Tokenize the given String into a String array via a StringTokenizer._Trims tokens and omits empty tokens._<p>The given delimiters string is supposed to consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using <code>delimitedListToStringArray</code>_@param str the String to tokenize_@param delimiters the delimiter characters, assembled as String_(each of those characters is individually considered as delimiter)._@return an array of the tokens_@see java.util.StringTokenizer_@see java.lang.String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,string,into,a,string,array,via,a,string,tokenizer,trims,tokens,and,omits,empty,tokens,p,the,given,delimiters,string,is,supposed,to,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,code,delimited,list,to,string,array,code,param,str,the,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,string,each,of,those,characters,is,individually,considered,as,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,java,lang,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(String str, String delimiters);1337236962;Tokenize the given String into a String array via a StringTokenizer._Trims tokens and omits empty tokens._<p>The given delimiters string is supposed to consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using <code>delimitedListToStringArray</code>_@param str the String to tokenize_@param delimiters the delimiter characters, assembled as String_(each of those characters is individually considered as delimiter)._@return an array of the tokens_@see java.util.StringTokenizer_@see java.lang.String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,string,into,a,string,array,via,a,string,tokenizer,trims,tokens,and,omits,empty,tokens,p,the,given,delimiters,string,is,supposed,to,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,code,delimited,list,to,string,array,code,param,str,the,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,string,each,of,those,characters,is,individually,considered,as,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,java,lang,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(String str, String delimiters);1356735495;Tokenize the given String into a String array via a StringTokenizer._Trims tokens and omits empty tokens._<p>The given delimiters string is supposed to consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@code delimitedListToStringArray}_@param str the String to tokenize_@param delimiters the delimiter characters, assembled as String_(each of those characters is individually considered as delimiter)._@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,string,into,a,string,array,via,a,string,tokenizer,trims,tokens,and,omits,empty,tokens,p,the,given,delimiters,string,is,supposed,to,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,code,delimited,list,to,string,array,param,str,the,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,string,each,of,those,characters,is,individually,considered,as,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(String str, String delimiters);1367955086;Tokenize the given String into a String array via a StringTokenizer._Trims tokens and omits empty tokens._<p>The given delimiters string is supposed to consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@code delimitedListToStringArray}_@param str the String to tokenize_@param delimiters the delimiter characters, assembled as String_(each of those characters is individually considered as delimiter)._@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,string,into,a,string,array,via,a,string,tokenizer,trims,tokens,and,omits,empty,tokens,p,the,given,delimiters,string,is,supposed,to,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,code,delimited,list,to,string,array,param,str,the,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,string,each,of,those,characters,is,individually,considered,as,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(String str, String delimiters);1380921248;Tokenize the given String into a String array via a StringTokenizer._Trims tokens and omits empty tokens._<p>The given delimiters string is supposed to consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@code delimitedListToStringArray}_@param str the String to tokenize_@param delimiters the delimiter characters, assembled as String_(each of those characters is individually considered as delimiter)._@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,string,into,a,string,array,via,a,string,tokenizer,trims,tokens,and,omits,empty,tokens,p,the,given,delimiters,string,is,supposed,to,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,code,delimited,list,to,string,array,param,str,the,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,string,each,of,those,characters,is,individually,considered,as,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(String str, String delimiters);1382750743;Tokenize the given String into a String array via a StringTokenizer._Trims tokens and omits empty tokens._<p>The given delimiters string is supposed to consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@code delimitedListToStringArray}_@param str the String to tokenize_@param delimiters the delimiter characters, assembled as String_(each of those characters is individually considered as delimiter)._@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,string,into,a,string,array,via,a,string,tokenizer,trims,tokens,and,omits,empty,tokens,p,the,given,delimiters,string,is,supposed,to,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,code,delimited,list,to,string,array,param,str,the,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,string,each,of,those,characters,is,individually,considered,as,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(String str, String delimiters);1385423968;Tokenize the given String into a String array via a StringTokenizer._Trims tokens and omits empty tokens._<p>The given delimiters string is supposed to consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@code delimitedListToStringArray}_@param str the String to tokenize_@param delimiters the delimiter characters, assembled as String_(each of those characters is individually considered as delimiter)._@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,string,into,a,string,array,via,a,string,tokenizer,trims,tokens,and,omits,empty,tokens,p,the,given,delimiters,string,is,supposed,to,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,code,delimited,list,to,string,array,param,str,the,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,string,each,of,those,characters,is,individually,considered,as,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(String str, String delimiters);1400189212;Tokenize the given String into a String array via a StringTokenizer._Trims tokens and omits empty tokens._<p>The given delimiters string is supposed to consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@code delimitedListToStringArray}_@param str the String to tokenize_@param delimiters the delimiter characters, assembled as String_(each of those characters is individually considered as delimiter)._@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,string,into,a,string,array,via,a,string,tokenizer,trims,tokens,and,omits,empty,tokens,p,the,given,delimiters,string,is,supposed,to,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,code,delimited,list,to,string,array,param,str,the,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,string,each,of,those,characters,is,individually,considered,as,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(String str, String delimiters);1400531359;Tokenize the given String into a String array via a StringTokenizer._Trims tokens and omits empty tokens._<p>The given delimiters string is supposed to consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@code delimitedListToStringArray}_@param str the String to tokenize_@param delimiters the delimiter characters, assembled as String_(each of those characters is individually considered as delimiter)._@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,string,into,a,string,array,via,a,string,tokenizer,trims,tokens,and,omits,empty,tokens,p,the,given,delimiters,string,is,supposed,to,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,code,delimited,list,to,string,array,param,str,the,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,string,each,of,those,characters,is,individually,considered,as,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(String str, String delimiters);1402676350;Tokenize the given String into a String array via a StringTokenizer._Trims tokens and omits empty tokens._<p>The given delimiters string is supposed to consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@code delimitedListToStringArray}_@param str the String to tokenize_@param delimiters the delimiter characters, assembled as String_(each of those characters is individually considered as delimiter)._@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,string,into,a,string,array,via,a,string,tokenizer,trims,tokens,and,omits,empty,tokens,p,the,given,delimiters,string,is,supposed,to,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,code,delimited,list,to,string,array,param,str,the,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,string,each,of,those,characters,is,individually,considered,as,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(String str, String delimiters);1426267150;Tokenize the given String into a String array via a StringTokenizer._Trims tokens and omits empty tokens._<p>The given delimiters string is supposed to consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@code delimitedListToStringArray}_@param str the String to tokenize_@param delimiters the delimiter characters, assembled as String_(each of those characters is individually considered as delimiter)._@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,string,into,a,string,array,via,a,string,tokenizer,trims,tokens,and,omits,empty,tokens,p,the,given,delimiters,string,is,supposed,to,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,code,delimited,list,to,string,array,param,str,the,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,string,each,of,those,characters,is,individually,considered,as,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(String str, String delimiters);1429034538;Tokenize the given String into a String array via a StringTokenizer._Trims tokens and omits empty tokens._<p>The given delimiters string is supposed to consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@code delimitedListToStringArray}_@param str the String to tokenize_@param delimiters the delimiter characters, assembled as String_(each of those characters is individually considered as delimiter)._@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,string,into,a,string,array,via,a,string,tokenizer,trims,tokens,and,omits,empty,tokens,p,the,given,delimiters,string,is,supposed,to,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,code,delimited,list,to,string,array,param,str,the,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,string,each,of,those,characters,is,individually,considered,as,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(String str, String delimiters);1429034756;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>Trims tokens and omits empty tokens._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,trims,tokens,and,omits,empty,tokens,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(String str, String delimiters);1431006895;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>Trims tokens and omits empty tokens._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,trims,tokens,and,omits,empty,tokens,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(String str, String delimiters);1431007368;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>Trims tokens and omits empty tokens._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,trims,tokens,and,omits,empty,tokens,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(String str, String delimiters);1449489126;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>Trims tokens and omits empty tokens._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,trims,tokens,and,omits,empty,tokens,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(String str, String delimiters);1467730834;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>Trims tokens and omits empty tokens._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,trims,tokens,and,omits,empty,tokens,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(String str, String delimiters);1472128018;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>Trims tokens and omits empty tokens._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,trims,tokens,and,omits,empty,tokens,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(String str, String delimiters);1472202842;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>Trims tokens and omits empty tokens._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,trims,tokens,and,omits,empty,tokens,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(String str, String delimiters);1473942665;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>Trims tokens and omits empty tokens._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,trims,tokens,and,omits,empty,tokens,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(String str, String delimiters);1484248946;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>Trims tokens and omits empty tokens._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,trims,tokens,and,omits,empty,tokens,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(String str, String delimiters);1484260238;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>Trims tokens and omits empty tokens._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,trims,tokens,and,omits,empty,tokens,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(String str, String delimiters);1484694546;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>Trims tokens and omits empty tokens._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,trims,tokens,and,omits,empty,tokens,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(String str, String delimiters);1487760984;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>Trims tokens and omits empty tokens._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,trims,tokens,and,omits,empty,tokens,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(String str, String delimiters);1487778834;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>Trims tokens and omits empty tokens._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,trims,tokens,and,omits,empty,tokens,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(String str, String delimiters);1491898314;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>Trims tokens and omits empty tokens._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,trims,tokens,and,omits,empty,tokens,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(String str, String delimiters);1491903650;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>Trims tokens and omits empty tokens._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,trims,tokens,and,omits,empty,tokens,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(String str, String delimiters);1495868221;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>Trims tokens and omits empty tokens._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,trims,tokens,and,omits,empty,tokens,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(String str, String delimiters);1496243689;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>Trims tokens and omits empty tokens._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,trims,tokens,and,omits,empty,tokens,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static String[] tokenizeToStringArray(String str, String delimiters);1496259743;Tokenize the given {@code String} into a {@code String} array via a_{@link StringTokenizer}._<p>Trims tokens and omits empty tokens._<p>The given {@code delimiters} string can consist of any number of_delimiter characters. Each of those characters can be used to separate_tokens. A delimiter is always a single character_ for multi-character_delimiters, consider using {@link #delimitedListToStringArray}._@param str the {@code String} to tokenize_@param delimiters the delimiter characters, assembled as a {@code String}_(each of the characters is individually considered as a delimiter)_@return an array of the tokens_@see java.util.StringTokenizer_@see String#trim()_@see #delimitedListToStringArray;public static String[] tokenizeToStringArray(String str, String delimiters) {_		return tokenizeToStringArray(str, delimiters, true, true)__	};tokenize,the,given,code,string,into,a,code,string,array,via,a,link,string,tokenizer,p,trims,tokens,and,omits,empty,tokens,p,the,given,code,delimiters,string,can,consist,of,any,number,of,delimiter,characters,each,of,those,characters,can,be,used,to,separate,tokens,a,delimiter,is,always,a,single,character,for,multi,character,delimiters,consider,using,link,delimited,list,to,string,array,param,str,the,code,string,to,tokenize,param,delimiters,the,delimiter,characters,assembled,as,a,code,string,each,of,the,characters,is,individually,considered,as,a,delimiter,return,an,array,of,the,tokens,see,java,util,string,tokenizer,see,string,trim,see,delimited,list,to,string,array;public,static,string,tokenize,to,string,array,string,str,string,delimiters,return,tokenize,to,string,array,str,delimiters,true,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1328020251;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		for (int j = 0_ j < substring.length()_ j++) {_			int i = index + j__			if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,for,int,j,0,j,substring,length,j,int,i,index,j,if,i,str,length,str,char,at,i,substring,char,at,j,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1337236962;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		for (int j = 0_ j < substring.length()_ j++) {_			int i = index + j__			if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,for,int,j,0,j,substring,length,j,int,i,index,j,if,i,str,length,str,char,at,i,substring,char,at,j,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1356735495;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		for (int j = 0_ j < substring.length()_ j++) {_			int i = index + j__			if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,for,int,j,0,j,substring,length,j,int,i,index,j,if,i,str,length,str,char,at,i,substring,char,at,j,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1367955086;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		for (int j = 0_ j < substring.length()_ j++) {_			int i = index + j__			if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,for,int,j,0,j,substring,length,j,int,i,index,j,if,i,str,length,str,char,at,i,substring,char,at,j,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1380921248;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		for (int j = 0_ j < substring.length()_ j++) {_			int i = index + j__			if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,for,int,j,0,j,substring,length,j,int,i,index,j,if,i,str,length,str,char,at,i,substring,char,at,j,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1382750743;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		for (int j = 0_ j < substring.length()_ j++) {_			int i = index + j__			if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,for,int,j,0,j,substring,length,j,int,i,index,j,if,i,str,length,str,char,at,i,substring,char,at,j,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1385423968;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		for (int j = 0_ j < substring.length()_ j++) {_			int i = index + j__			if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,for,int,j,0,j,substring,length,j,int,i,index,j,if,i,str,length,str,char,at,i,substring,char,at,j,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1400189212;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		for (int j = 0_ j < substring.length()_ j++) {_			int i = index + j__			if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,for,int,j,0,j,substring,length,j,int,i,index,j,if,i,str,length,str,char,at,i,substring,char,at,j,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1400531359;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		for (int j = 0_ j < substring.length()_ j++) {_			int i = index + j__			if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,for,int,j,0,j,substring,length,j,int,i,index,j,if,i,str,length,str,char,at,i,substring,char,at,j,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1402676350;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		for (int j = 0_ j < substring.length()_ j++) {_			int i = index + j__			if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,for,int,j,0,j,substring,length,j,int,i,index,j,if,i,str,length,str,char,at,i,substring,char,at,j,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1426267150;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		for (int j = 0_ j < substring.length()_ j++) {_			int i = index + j__			if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,for,int,j,0,j,substring,length,j,int,i,index,j,if,i,str,length,str,char,at,i,substring,char,at,j,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1429034538;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		for (int j = 0_ j < substring.length()_ j++) {_			int i = index + j__			if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,for,int,j,0,j,substring,length,j,int,i,index,j,if,i,str,length,str,char,at,i,substring,char,at,j,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1429034756;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		for (int j = 0_ j < substring.length()_ j++) {_			int i = index + j__			if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,for,int,j,0,j,substring,length,j,int,i,index,j,if,i,str,length,str,char,at,i,substring,char,at,j,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1431006895;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		for (int j = 0_ j < substring.length()_ j++) {_			int i = index + j__			if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,for,int,j,0,j,substring,length,j,int,i,index,j,if,i,str,length,str,char,at,i,substring,char,at,j,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1431007368;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		for (int j = 0_ j < substring.length()_ j++) {_			int i = index + j__			if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,for,int,j,0,j,substring,length,j,int,i,index,j,if,i,str,length,str,char,at,i,substring,char,at,j,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1449489126;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		for (int j = 0_ j < substring.length()_ j++) {_			int i = index + j__			if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,for,int,j,0,j,substring,length,j,int,i,index,j,if,i,str,length,str,char,at,i,substring,char,at,j,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1467730834;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		for (int j = 0_ j < substring.length()_ j++) {_			int i = index + j__			if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,for,int,j,0,j,substring,length,j,int,i,index,j,if,i,str,length,str,char,at,i,substring,char,at,j,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1472128018;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		for (int j = 0_ j < substring.length()_ j++) {_			int i = index + j__			if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,for,int,j,0,j,substring,length,j,int,i,index,j,if,i,str,length,str,char,at,i,substring,char,at,j,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1472202842;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		for (int j = 0_ j < substring.length()_ j++) {_			int i = index + j__			if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,for,int,j,0,j,substring,length,j,int,i,index,j,if,i,str,length,str,char,at,i,substring,char,at,j,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1473942665;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		for (int j = 0_ j < substring.length()_ j++) {_			int i = index + j__			if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,for,int,j,0,j,substring,length,j,int,i,index,j,if,i,str,length,str,char,at,i,substring,char,at,j,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1484248946;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		for (int j = 0_ j < substring.length()_ j++) {_			int i = index + j__			if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,for,int,j,0,j,substring,length,j,int,i,index,j,if,i,str,length,str,char,at,i,substring,char,at,j,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1484260238;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		for (int j = 0_ j < substring.length()_ j++) {_			int i = index + j__			if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,for,int,j,0,j,substring,length,j,int,i,index,j,if,i,str,length,str,char,at,i,substring,char,at,j,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1484694546;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		for (int j = 0_ j < substring.length()_ j++) {_			int i = index + j__			if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,for,int,j,0,j,substring,length,j,int,i,index,j,if,i,str,length,str,char,at,i,substring,char,at,j,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1487760984;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		for (int j = 0_ j < substring.length()_ j++) {_			int i = index + j__			if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,for,int,j,0,j,substring,length,j,int,i,index,j,if,i,str,length,str,char,at,i,substring,char,at,j,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1487778834;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		for (int j = 0_ j < substring.length()_ j++) {_			int i = index + j__			if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,for,int,j,0,j,substring,length,j,int,i,index,j,if,i,str,length,str,char,at,i,substring,char,at,j,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1491898314;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		for (int j = 0_ j < substring.length()_ j++) {_			int i = index + j__			if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,for,int,j,0,j,substring,length,j,int,i,index,j,if,i,str,length,str,char,at,i,substring,char,at,j,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1491903650;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		for (int j = 0_ j < substring.length()_ j++) {_			int i = index + j__			if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,for,int,j,0,j,substring,length,j,int,i,index,j,if,i,str,length,str,char,at,i,substring,char,at,j,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1495868221;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		for (int j = 0_ j < substring.length()_ j++) {_			int i = index + j__			if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,for,int,j,0,j,substring,length,j,int,i,index,j,if,i,str,length,str,char,at,i,substring,char,at,j,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1496243689;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		for (int j = 0_ j < substring.length()_ j++) {_			int i = index + j__			if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,for,int,j,0,j,substring,length,j,int,i,index,j,if,i,str,length,str,char,at,i,substring,char,at,j,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1496259743;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		for (int j = 0_ j < substring.length()_ j++) {_			int i = index + j__			if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,for,int,j,0,j,substring,length,j,int,i,index,j,if,i,str,length,str,char,at,i,substring,char,at,j,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1496837955;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		for (int j = 0_ j < substring.length()_ j++) {_			int i = index + j__			if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,for,int,j,0,j,substring,length,j,int,i,index,j,if,i,str,length,str,char,at,i,substring,char,at,j,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1499270197;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		for (int j = 0_ j < substring.length()_ j++) {_			int i = index + j__			if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,for,int,j,0,j,substring,length,j,int,i,index,j,if,i,str,length,str,char,at,i,substring,char,at,j,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1508667152;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		for (int j = 0_ j < substring.length()_ j++) {_			int i = index + j__			if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,for,int,j,0,j,substring,length,j,int,i,index,j,if,i,str,length,str,char,at,i,substring,char,at,j,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1508675477;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		if (index + substring.length() > str.length()) {_			return false__		}_		for (int i = 0_ i < substring.length()_ i++) {_			if (str.charAt(index + i) != substring.charAt(i)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,if,index,substring,length,str,length,return,false,for,int,i,0,i,substring,length,i,if,str,char,at,index,i,substring,char,at,i,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1508843807;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		if (index + substring.length() > str.length()) {_			return false__		}_		for (int i = 0_ i < substring.length()_ i++) {_			if (str.charAt(index + i) != substring.charAt(i)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,if,index,substring,length,str,length,return,false,for,int,i,0,i,substring,length,i,if,str,char,at,index,i,substring,char,at,i,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1516903831;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		if (index + substring.length() > str.length()) {_			return false__		}_		for (int i = 0_ i < substring.length()_ i++) {_			if (str.charAt(index + i) != substring.charAt(i)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,if,index,substring,length,str,length,return,false,for,int,i,0,i,substring,length,i,if,str,char,at,index,i,substring,char,at,i,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1519295386;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		if (index + substring.length() > str.length()) {_			return false__		}_		for (int i = 0_ i < substring.length()_ i++) {_			if (str.charAt(index + i) != substring.charAt(i)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,if,index,substring,length,str,length,return,false,for,int,i,0,i,substring,length,i,if,str,char,at,index,i,substring,char,at,i,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1519308837;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		if (index + substring.length() > str.length()) {_			return false__		}_		for (int i = 0_ i < substring.length()_ i++) {_			if (str.charAt(index + i) != substring.charAt(i)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,if,index,substring,length,str,length,return,false,for,int,i,0,i,substring,length,i,if,str,char,at,index,i,substring,char,at,i,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1519588127;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		if (index + substring.length() > str.length()) {_			return false__		}_		for (int i = 0_ i < substring.length()_ i++) {_			if (str.charAt(index + i) != substring.charAt(i)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,if,index,substring,length,str,length,return,false,for,int,i,0,i,substring,length,i,if,str,char,at,index,i,substring,char,at,i,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1522332352;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		if (index + substring.length() > str.length()) {_			return false__		}_		for (int i = 0_ i < substring.length()_ i++) {_			if (str.charAt(index + i) != substring.charAt(i)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,if,index,substring,length,str,length,return,false,for,int,i,0,i,substring,length,i,if,str,char,at,index,i,substring,char,at,i,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1525166194;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		if (index + substring.length() > str.length()) {_			return false__		}_		for (int i = 0_ i < substring.length()_ i++) {_			if (str.charAt(index + i) != substring.charAt(i)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,if,index,substring,length,str,length,return,false,for,int,i,0,i,substring,length,i,if,str,char,at,index,i,substring,char,at,i,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1530188116;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		if (index + substring.length() > str.length()) {_			return false__		}_		for (int i = 0_ i < substring.length()_ i++) {_			if (str.charAt(index + i) != substring.charAt(i)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,if,index,substring,length,str,length,return,false,for,int,i,0,i,substring,length,i,if,str,char,at,index,i,substring,char,at,i,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1531843079;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		if (index + substring.length() > str.length()) {_			return false__		}_		for (int i = 0_ i < substring.length()_ i++) {_			if (str.charAt(index + i) != substring.charAt(i)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,if,index,substring,length,str,length,return,false,for,int,i,0,i,substring,length,i,if,str,char,at,index,i,substring,char,at,i,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1531905026;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		if (index + substring.length() > str.length()) {_			return false__		}_		for (int i = 0_ i < substring.length()_ i++) {_			if (str.charAt(index + i) != substring.charAt(i)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,if,index,substring,length,str,length,return,false,for,int,i,0,i,substring,length,i,if,str,char,at,index,i,substring,char,at,i,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1533557519;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		if (index + substring.length() > str.length()) {_			return false__		}_		for (int i = 0_ i < substring.length()_ i++) {_			if (str.charAt(index + i) != substring.charAt(i)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,if,index,substring,length,str,length,return,false,for,int,i,0,i,substring,length,i,if,str,char,at,index,i,substring,char,at,i,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1533602820;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		if (index + substring.length() > str.length()) {_			return false__		}_		for (int i = 0_ i < substring.length()_ i++) {_			if (str.charAt(index + i) != substring.charAt(i)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,if,index,substring,length,str,length,return,false,for,int,i,0,i,substring,length,i,if,str,char,at,index,i,substring,char,at,i,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1535316501;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		if (index + substring.length() > str.length()) {_			return false__		}_		for (int i = 0_ i < substring.length()_ i++) {_			if (str.charAt(index + i) != substring.charAt(i)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,if,index,substring,length,str,length,return,false,for,int,i,0,i,substring,length,i,if,str,char,at,index,i,substring,char,at,i,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1550237113;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		if (index + substring.length() > str.length()) {_			return false__		}_		for (int i = 0_ i < substring.length()_ i++) {_			if (str.charAt(index + i) != substring.charAt(i)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,if,index,substring,length,str,length,return,false,for,int,i,0,i,substring,length,i,if,str,char,at,index,i,substring,char,at,i,return,false,return,true
StringUtils -> public static boolean substringMatch(CharSequence str, int index, CharSequence substring);1550238935;Test whether the given string matches the given substring_at the given index._@param str the original string (or StringBuilder)_@param index the index in the original string to start matching against_@param substring the substring to match at the given index;public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {_		if (index + substring.length() > str.length()) {_			return false__		}_		for (int i = 0_ i < substring.length()_ i++) {_			if (str.charAt(index + i) != substring.charAt(i)) {_				return false__			}_		}_		return true__	};test,whether,the,given,string,matches,the,given,substring,at,the,given,index,param,str,the,original,string,or,string,builder,param,index,the,index,in,the,original,string,to,start,matching,against,param,substring,the,substring,to,match,at,the,given,index;public,static,boolean,substring,match,char,sequence,str,int,index,char,sequence,substring,if,index,substring,length,str,length,return,false,for,int,i,0,i,substring,length,i,if,str,char,at,index,i,substring,char,at,i,return,false,return,true
StringUtils -> public static String[] commaDelimitedListToStringArray(String str);1328020251;Convert a CSV list into an array of Strings._@param str the input String_@return an array of Strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,csv,list,into,an,array,of,strings,param,str,the,input,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(String str);1337236962;Convert a CSV list into an array of Strings._@param str the input String_@return an array of Strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,csv,list,into,an,array,of,strings,param,str,the,input,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(String str);1356735495;Convert a CSV list into an array of Strings._@param str the input String_@return an array of Strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,csv,list,into,an,array,of,strings,param,str,the,input,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(String str);1367955086;Convert a CSV list into an array of Strings._@param str the input String_@return an array of Strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,csv,list,into,an,array,of,strings,param,str,the,input,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(String str);1380921248;Convert a CSV list into an array of Strings._@param str the input String_@return an array of Strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,csv,list,into,an,array,of,strings,param,str,the,input,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(String str);1382750743;Convert a CSV list into an array of Strings._@param str the input String_@return an array of Strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,csv,list,into,an,array,of,strings,param,str,the,input,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(String str);1385423968;Convert a CSV list into an array of Strings._@param str the input String_@return an array of Strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,csv,list,into,an,array,of,strings,param,str,the,input,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(String str);1400189212;Convert a CSV list into an array of Strings._@param str the input String_@return an array of Strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,csv,list,into,an,array,of,strings,param,str,the,input,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(String str);1400531359;Convert a CSV list into an array of Strings._@param str the input String_@return an array of Strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,csv,list,into,an,array,of,strings,param,str,the,input,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(String str);1402676350;Convert a CSV list into an array of Strings._@param str the input String_@return an array of Strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,csv,list,into,an,array,of,strings,param,str,the,input,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(String str);1426267150;Convert a CSV list into an array of Strings._@param str the input String_@return an array of Strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,csv,list,into,an,array,of,strings,param,str,the,input,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(String str);1429034538;Convert a CSV list into an array of Strings._@param str the input String_@return an array of Strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,csv,list,into,an,array,of,strings,param,str,the,input,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(String str);1429034756;Convert a comma delimited list (e.g., a row from a CSV file) into an_array of strings._@param str the input {@code String}_@return an array of strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,an,array,of,strings,param,str,the,input,code,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(String str);1431006895;Convert a comma delimited list (e.g., a row from a CSV file) into an_array of strings._@param str the input {@code String}_@return an array of strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,an,array,of,strings,param,str,the,input,code,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(String str);1431007368;Convert a comma delimited list (e.g., a row from a CSV file) into an_array of strings._@param str the input {@code String}_@return an array of strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,an,array,of,strings,param,str,the,input,code,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(String str);1449489126;Convert a comma delimited list (e.g., a row from a CSV file) into an_array of strings._@param str the input {@code String}_@return an array of strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,an,array,of,strings,param,str,the,input,code,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(String str);1467730834;Convert a comma delimited list (e.g., a row from a CSV file) into an_array of strings._@param str the input {@code String}_@return an array of strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,an,array,of,strings,param,str,the,input,code,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(String str);1472128018;Convert a comma delimited list (e.g., a row from a CSV file) into an_array of strings._@param str the input {@code String}_@return an array of strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,an,array,of,strings,param,str,the,input,code,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(String str);1472202842;Convert a comma delimited list (e.g., a row from a CSV file) into an_array of strings._@param str the input {@code String}_@return an array of strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,an,array,of,strings,param,str,the,input,code,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(String str);1473942665;Convert a comma delimited list (e.g., a row from a CSV file) into an_array of strings._@param str the input {@code String}_@return an array of strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,an,array,of,strings,param,str,the,input,code,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(String str);1484248946;Convert a comma delimited list (e.g., a row from a CSV file) into an_array of strings._@param str the input {@code String}_@return an array of strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,an,array,of,strings,param,str,the,input,code,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(String str);1484260238;Convert a comma delimited list (e.g., a row from a CSV file) into an_array of strings._@param str the input {@code String}_@return an array of strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,an,array,of,strings,param,str,the,input,code,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(String str);1484694546;Convert a comma delimited list (e.g., a row from a CSV file) into an_array of strings._@param str the input {@code String}_@return an array of strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,an,array,of,strings,param,str,the,input,code,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(String str);1487760984;Convert a comma delimited list (e.g., a row from a CSV file) into an_array of strings._@param str the input {@code String}_@return an array of strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,an,array,of,strings,param,str,the,input,code,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(String str);1487778834;Convert a comma delimited list (e.g., a row from a CSV file) into an_array of strings._@param str the input {@code String}_@return an array of strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,an,array,of,strings,param,str,the,input,code,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(String str);1491898314;Convert a comma delimited list (e.g., a row from a CSV file) into an_array of strings._@param str the input {@code String}_@return an array of strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,an,array,of,strings,param,str,the,input,code,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(String str);1491903650;Convert a comma delimited list (e.g., a row from a CSV file) into an_array of strings._@param str the input {@code String}_@return an array of strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,an,array,of,strings,param,str,the,input,code,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(String str);1495868221;Convert a comma delimited list (e.g., a row from a CSV file) into an_array of strings._@param str the input {@code String}_@return an array of strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,an,array,of,strings,param,str,the,input,code,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(String str);1496243689;Convert a comma delimited list (e.g., a row from a CSV file) into an_array of strings._@param str the input {@code String}_@return an array of strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,an,array,of,strings,param,str,the,input,code,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static String[] commaDelimitedListToStringArray(String str);1496259743;Convert a comma delimited list (e.g., a row from a CSV file) into an_array of strings._@param str the input {@code String}_@return an array of strings, or the empty array in case of empty input;public static String[] commaDelimitedListToStringArray(String str) {_		return delimitedListToStringArray(str, ",")__	};convert,a,comma,delimited,list,e,g,a,row,from,a,csv,file,into,an,array,of,strings,param,str,the,input,code,string,return,an,array,of,strings,or,the,empty,array,in,case,of,empty,input;public,static,string,comma,delimited,list,to,string,array,string,str,return,delimited,list,to,string,array,str
StringUtils -> public static boolean endsWithIgnoreCase(String str, String suffix);1328020251;Test if the given String ends with the specified suffix,_ignoring upper/lower case._@param str the String to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(String str, String suffix) {_		if (str == null || suffix == null) {_			return false__		}_		if (str.endsWith(suffix)) {_			return true__		}_		if (str.length() < suffix.length()) {_			return false__		}__		String lcStr = str.substring(str.length() - suffix.length()).toLowerCase()__		String lcSuffix = suffix.toLowerCase()__		return lcStr.equals(lcSuffix)__	};test,if,the,given,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,string,str,string,suffix,if,str,null,suffix,null,return,false,if,str,ends,with,suffix,return,true,if,str,length,suffix,length,return,false,string,lc,str,str,substring,str,length,suffix,length,to,lower,case,string,lc,suffix,suffix,to,lower,case,return,lc,str,equals,lc,suffix
StringUtils -> public static boolean endsWithIgnoreCase(String str, String suffix);1337236962;Test if the given String ends with the specified suffix,_ignoring upper/lower case._@param str the String to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(String str, String suffix) {_		if (str == null || suffix == null) {_			return false__		}_		if (str.endsWith(suffix)) {_			return true__		}_		if (str.length() < suffix.length()) {_			return false__		}__		String lcStr = str.substring(str.length() - suffix.length()).toLowerCase()__		String lcSuffix = suffix.toLowerCase()__		return lcStr.equals(lcSuffix)__	};test,if,the,given,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,string,str,string,suffix,if,str,null,suffix,null,return,false,if,str,ends,with,suffix,return,true,if,str,length,suffix,length,return,false,string,lc,str,str,substring,str,length,suffix,length,to,lower,case,string,lc,suffix,suffix,to,lower,case,return,lc,str,equals,lc,suffix
StringUtils -> public static boolean endsWithIgnoreCase(String str, String suffix);1356735495;Test if the given String ends with the specified suffix,_ignoring upper/lower case._@param str the String to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(String str, String suffix) {_		if (str == null || suffix == null) {_			return false__		}_		if (str.endsWith(suffix)) {_			return true__		}_		if (str.length() < suffix.length()) {_			return false__		}__		String lcStr = str.substring(str.length() - suffix.length()).toLowerCase()__		String lcSuffix = suffix.toLowerCase()__		return lcStr.equals(lcSuffix)__	};test,if,the,given,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,string,str,string,suffix,if,str,null,suffix,null,return,false,if,str,ends,with,suffix,return,true,if,str,length,suffix,length,return,false,string,lc,str,str,substring,str,length,suffix,length,to,lower,case,string,lc,suffix,suffix,to,lower,case,return,lc,str,equals,lc,suffix
StringUtils -> public static boolean endsWithIgnoreCase(String str, String suffix);1367955086;Test if the given String ends with the specified suffix,_ignoring upper/lower case._@param str the String to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(String str, String suffix) {_		if (str == null || suffix == null) {_			return false__		}_		if (str.endsWith(suffix)) {_			return true__		}_		if (str.length() < suffix.length()) {_			return false__		}__		String lcStr = str.substring(str.length() - suffix.length()).toLowerCase()__		String lcSuffix = suffix.toLowerCase()__		return lcStr.equals(lcSuffix)__	};test,if,the,given,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,string,str,string,suffix,if,str,null,suffix,null,return,false,if,str,ends,with,suffix,return,true,if,str,length,suffix,length,return,false,string,lc,str,str,substring,str,length,suffix,length,to,lower,case,string,lc,suffix,suffix,to,lower,case,return,lc,str,equals,lc,suffix
StringUtils -> public static boolean endsWithIgnoreCase(String str, String suffix);1380921248;Test if the given String ends with the specified suffix,_ignoring upper/lower case._@param str the String to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(String str, String suffix) {_		if (str == null || suffix == null) {_			return false__		}_		if (str.endsWith(suffix)) {_			return true__		}_		if (str.length() < suffix.length()) {_			return false__		}__		String lcStr = str.substring(str.length() - suffix.length()).toLowerCase()__		String lcSuffix = suffix.toLowerCase()__		return lcStr.equals(lcSuffix)__	};test,if,the,given,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,string,str,string,suffix,if,str,null,suffix,null,return,false,if,str,ends,with,suffix,return,true,if,str,length,suffix,length,return,false,string,lc,str,str,substring,str,length,suffix,length,to,lower,case,string,lc,suffix,suffix,to,lower,case,return,lc,str,equals,lc,suffix
StringUtils -> public static boolean endsWithIgnoreCase(String str, String suffix);1382750743;Test if the given String ends with the specified suffix,_ignoring upper/lower case._@param str the String to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(String str, String suffix) {_		if (str == null || suffix == null) {_			return false__		}_		if (str.endsWith(suffix)) {_			return true__		}_		if (str.length() < suffix.length()) {_			return false__		}__		String lcStr = str.substring(str.length() - suffix.length()).toLowerCase()__		String lcSuffix = suffix.toLowerCase()__		return lcStr.equals(lcSuffix)__	};test,if,the,given,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,string,str,string,suffix,if,str,null,suffix,null,return,false,if,str,ends,with,suffix,return,true,if,str,length,suffix,length,return,false,string,lc,str,str,substring,str,length,suffix,length,to,lower,case,string,lc,suffix,suffix,to,lower,case,return,lc,str,equals,lc,suffix
StringUtils -> public static boolean endsWithIgnoreCase(String str, String suffix);1385423968;Test if the given String ends with the specified suffix,_ignoring upper/lower case._@param str the String to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(String str, String suffix) {_		if (str == null || suffix == null) {_			return false__		}_		if (str.endsWith(suffix)) {_			return true__		}_		if (str.length() < suffix.length()) {_			return false__		}__		String lcStr = str.substring(str.length() - suffix.length()).toLowerCase()__		String lcSuffix = suffix.toLowerCase()__		return lcStr.equals(lcSuffix)__	};test,if,the,given,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,string,str,string,suffix,if,str,null,suffix,null,return,false,if,str,ends,with,suffix,return,true,if,str,length,suffix,length,return,false,string,lc,str,str,substring,str,length,suffix,length,to,lower,case,string,lc,suffix,suffix,to,lower,case,return,lc,str,equals,lc,suffix
StringUtils -> public static boolean endsWithIgnoreCase(String str, String suffix);1400189212;Test if the given String ends with the specified suffix,_ignoring upper/lower case._@param str the String to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(String str, String suffix) {_		if (str == null || suffix == null) {_			return false__		}_		if (str.endsWith(suffix)) {_			return true__		}_		if (str.length() < suffix.length()) {_			return false__		}__		String lcStr = str.substring(str.length() - suffix.length()).toLowerCase()__		String lcSuffix = suffix.toLowerCase()__		return lcStr.equals(lcSuffix)__	};test,if,the,given,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,string,str,string,suffix,if,str,null,suffix,null,return,false,if,str,ends,with,suffix,return,true,if,str,length,suffix,length,return,false,string,lc,str,str,substring,str,length,suffix,length,to,lower,case,string,lc,suffix,suffix,to,lower,case,return,lc,str,equals,lc,suffix
StringUtils -> public static boolean endsWithIgnoreCase(String str, String suffix);1400531359;Test if the given String ends with the specified suffix,_ignoring upper/lower case._@param str the String to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(String str, String suffix) {_		if (str == null || suffix == null) {_			return false__		}_		if (str.endsWith(suffix)) {_			return true__		}_		if (str.length() < suffix.length()) {_			return false__		}__		String lcStr = str.substring(str.length() - suffix.length()).toLowerCase()__		String lcSuffix = suffix.toLowerCase()__		return lcStr.equals(lcSuffix)__	};test,if,the,given,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,string,str,string,suffix,if,str,null,suffix,null,return,false,if,str,ends,with,suffix,return,true,if,str,length,suffix,length,return,false,string,lc,str,str,substring,str,length,suffix,length,to,lower,case,string,lc,suffix,suffix,to,lower,case,return,lc,str,equals,lc,suffix
StringUtils -> public static boolean endsWithIgnoreCase(String str, String suffix);1402676350;Test if the given String ends with the specified suffix,_ignoring upper/lower case._@param str the String to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(String str, String suffix) {_		if (str == null || suffix == null) {_			return false__		}_		if (str.endsWith(suffix)) {_			return true__		}_		if (str.length() < suffix.length()) {_			return false__		}__		String lcStr = str.substring(str.length() - suffix.length()).toLowerCase()__		String lcSuffix = suffix.toLowerCase()__		return lcStr.equals(lcSuffix)__	};test,if,the,given,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,string,str,string,suffix,if,str,null,suffix,null,return,false,if,str,ends,with,suffix,return,true,if,str,length,suffix,length,return,false,string,lc,str,str,substring,str,length,suffix,length,to,lower,case,string,lc,suffix,suffix,to,lower,case,return,lc,str,equals,lc,suffix
StringUtils -> public static boolean endsWithIgnoreCase(String str, String suffix);1426267150;Test if the given String ends with the specified suffix,_ignoring upper/lower case._@param str the String to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(String str, String suffix) {_		if (str == null || suffix == null) {_			return false__		}_		if (str.endsWith(suffix)) {_			return true__		}_		if (str.length() < suffix.length()) {_			return false__		}__		String lcStr = str.substring(str.length() - suffix.length()).toLowerCase()__		String lcSuffix = suffix.toLowerCase()__		return lcStr.equals(lcSuffix)__	};test,if,the,given,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,string,str,string,suffix,if,str,null,suffix,null,return,false,if,str,ends,with,suffix,return,true,if,str,length,suffix,length,return,false,string,lc,str,str,substring,str,length,suffix,length,to,lower,case,string,lc,suffix,suffix,to,lower,case,return,lc,str,equals,lc,suffix
StringUtils -> public static boolean endsWithIgnoreCase(String str, String suffix);1429034538;Test if the given String ends with the specified suffix,_ignoring upper/lower case._@param str the String to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(String str, String suffix) {_		if (str == null || suffix == null) {_			return false__		}_		if (str.endsWith(suffix)) {_			return true__		}_		if (str.length() < suffix.length()) {_			return false__		}__		String lcStr = str.substring(str.length() - suffix.length()).toLowerCase()__		String lcSuffix = suffix.toLowerCase()__		return lcStr.equals(lcSuffix)__	};test,if,the,given,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,string,str,string,suffix,if,str,null,suffix,null,return,false,if,str,ends,with,suffix,return,true,if,str,length,suffix,length,return,false,string,lc,str,str,substring,str,length,suffix,length,to,lower,case,string,lc,suffix,suffix,to,lower,case,return,lc,str,equals,lc,suffix
StringUtils -> public static boolean endsWithIgnoreCase(String str, String suffix);1429034756;Test if the given {@code String} ends with the specified suffix,_ignoring upper/lower case._@param str the {@code String} to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(String str, String suffix) {_		if (str == null || suffix == null) {_			return false__		}_		if (str.endsWith(suffix)) {_			return true__		}_		if (str.length() < suffix.length()) {_			return false__		}__		String lcStr = str.substring(str.length() - suffix.length()).toLowerCase()__		String lcSuffix = suffix.toLowerCase()__		return lcStr.equals(lcSuffix)__	};test,if,the,given,code,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,string,str,string,suffix,if,str,null,suffix,null,return,false,if,str,ends,with,suffix,return,true,if,str,length,suffix,length,return,false,string,lc,str,str,substring,str,length,suffix,length,to,lower,case,string,lc,suffix,suffix,to,lower,case,return,lc,str,equals,lc,suffix
StringUtils -> public static boolean endsWithIgnoreCase(String str, String suffix);1431006895;Test if the given {@code String} ends with the specified suffix,_ignoring upper/lower case._@param str the {@code String} to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(String str, String suffix) {_		if (str == null || suffix == null) {_			return false__		}_		if (str.endsWith(suffix)) {_			return true__		}_		if (str.length() < suffix.length()) {_			return false__		}__		String lcStr = str.substring(str.length() - suffix.length()).toLowerCase()__		String lcSuffix = suffix.toLowerCase()__		return lcStr.equals(lcSuffix)__	};test,if,the,given,code,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,string,str,string,suffix,if,str,null,suffix,null,return,false,if,str,ends,with,suffix,return,true,if,str,length,suffix,length,return,false,string,lc,str,str,substring,str,length,suffix,length,to,lower,case,string,lc,suffix,suffix,to,lower,case,return,lc,str,equals,lc,suffix
StringUtils -> public static boolean endsWithIgnoreCase(String str, String suffix);1431007368;Test if the given {@code String} ends with the specified suffix,_ignoring upper/lower case._@param str the {@code String} to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(String str, String suffix) {_		if (str == null || suffix == null) {_			return false__		}_		if (str.endsWith(suffix)) {_			return true__		}_		if (str.length() < suffix.length()) {_			return false__		}__		String lcStr = str.substring(str.length() - suffix.length()).toLowerCase()__		String lcSuffix = suffix.toLowerCase()__		return lcStr.equals(lcSuffix)__	};test,if,the,given,code,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,string,str,string,suffix,if,str,null,suffix,null,return,false,if,str,ends,with,suffix,return,true,if,str,length,suffix,length,return,false,string,lc,str,str,substring,str,length,suffix,length,to,lower,case,string,lc,suffix,suffix,to,lower,case,return,lc,str,equals,lc,suffix
StringUtils -> public static boolean endsWithIgnoreCase(String str, String suffix);1449489126;Test if the given {@code String} ends with the specified suffix,_ignoring upper/lower case._@param str the {@code String} to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(String str, String suffix) {_		if (str == null || suffix == null) {_			return false__		}_		if (str.endsWith(suffix)) {_			return true__		}_		if (str.length() < suffix.length()) {_			return false__		}__		String lcStr = str.substring(str.length() - suffix.length()).toLowerCase()__		String lcSuffix = suffix.toLowerCase()__		return lcStr.equals(lcSuffix)__	};test,if,the,given,code,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,string,str,string,suffix,if,str,null,suffix,null,return,false,if,str,ends,with,suffix,return,true,if,str,length,suffix,length,return,false,string,lc,str,str,substring,str,length,suffix,length,to,lower,case,string,lc,suffix,suffix,to,lower,case,return,lc,str,equals,lc,suffix
StringUtils -> public static boolean endsWithIgnoreCase(String str, String suffix);1467730834;Test if the given {@code String} ends with the specified suffix,_ignoring upper/lower case._@param str the {@code String} to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(String str, String suffix) {_		if (str == null || suffix == null) {_			return false__		}_		if (str.endsWith(suffix)) {_			return true__		}_		if (str.length() < suffix.length()) {_			return false__		}__		String lcStr = str.substring(str.length() - suffix.length()).toLowerCase()__		String lcSuffix = suffix.toLowerCase()__		return lcStr.equals(lcSuffix)__	};test,if,the,given,code,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,string,str,string,suffix,if,str,null,suffix,null,return,false,if,str,ends,with,suffix,return,true,if,str,length,suffix,length,return,false,string,lc,str,str,substring,str,length,suffix,length,to,lower,case,string,lc,suffix,suffix,to,lower,case,return,lc,str,equals,lc,suffix
StringUtils -> public static boolean endsWithIgnoreCase(String str, String suffix);1472128018;Test if the given {@code String} ends with the specified suffix,_ignoring upper/lower case._@param str the {@code String} to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(String str, String suffix) {_		if (str == null || suffix == null) {_			return false__		}_		if (str.endsWith(suffix)) {_			return true__		}_		if (str.length() < suffix.length()) {_			return false__		}__		String lcStr = str.substring(str.length() - suffix.length()).toLowerCase()__		String lcSuffix = suffix.toLowerCase()__		return lcStr.equals(lcSuffix)__	};test,if,the,given,code,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,string,str,string,suffix,if,str,null,suffix,null,return,false,if,str,ends,with,suffix,return,true,if,str,length,suffix,length,return,false,string,lc,str,str,substring,str,length,suffix,length,to,lower,case,string,lc,suffix,suffix,to,lower,case,return,lc,str,equals,lc,suffix
StringUtils -> public static boolean endsWithIgnoreCase(String str, String suffix);1472202842;Test if the given {@code String} ends with the specified suffix,_ignoring upper/lower case._@param str the {@code String} to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(String str, String suffix) {_		if (str == null || suffix == null) {_			return false__		}_		if (str.endsWith(suffix)) {_			return true__		}_		if (str.length() < suffix.length()) {_			return false__		}__		String lcStr = str.substring(str.length() - suffix.length()).toLowerCase()__		String lcSuffix = suffix.toLowerCase()__		return lcStr.equals(lcSuffix)__	};test,if,the,given,code,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,string,str,string,suffix,if,str,null,suffix,null,return,false,if,str,ends,with,suffix,return,true,if,str,length,suffix,length,return,false,string,lc,str,str,substring,str,length,suffix,length,to,lower,case,string,lc,suffix,suffix,to,lower,case,return,lc,str,equals,lc,suffix
StringUtils -> public static boolean endsWithIgnoreCase(String str, String suffix);1473942665;Test if the given {@code String} ends with the specified suffix,_ignoring upper/lower case._@param str the {@code String} to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(String str, String suffix) {_		if (str == null || suffix == null) {_			return false__		}_		if (str.endsWith(suffix)) {_			return true__		}_		if (str.length() < suffix.length()) {_			return false__		}__		String lcStr = str.substring(str.length() - suffix.length()).toLowerCase()__		String lcSuffix = suffix.toLowerCase()__		return lcStr.equals(lcSuffix)__	};test,if,the,given,code,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,string,str,string,suffix,if,str,null,suffix,null,return,false,if,str,ends,with,suffix,return,true,if,str,length,suffix,length,return,false,string,lc,str,str,substring,str,length,suffix,length,to,lower,case,string,lc,suffix,suffix,to,lower,case,return,lc,str,equals,lc,suffix
StringUtils -> public static boolean endsWithIgnoreCase(String str, String suffix);1484248946;Test if the given {@code String} ends with the specified suffix,_ignoring upper/lower case._@param str the {@code String} to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(String str, String suffix) {_		if (str == null || suffix == null) {_			return false__		}_		if (str.endsWith(suffix)) {_			return true__		}_		if (str.length() < suffix.length()) {_			return false__		}__		String lcStr = str.substring(str.length() - suffix.length()).toLowerCase()__		String lcSuffix = suffix.toLowerCase()__		return lcStr.equals(lcSuffix)__	};test,if,the,given,code,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,string,str,string,suffix,if,str,null,suffix,null,return,false,if,str,ends,with,suffix,return,true,if,str,length,suffix,length,return,false,string,lc,str,str,substring,str,length,suffix,length,to,lower,case,string,lc,suffix,suffix,to,lower,case,return,lc,str,equals,lc,suffix
StringUtils -> public static boolean endsWithIgnoreCase(String str, String suffix);1484260238;Test if the given {@code String} ends with the specified suffix,_ignoring upper/lower case._@param str the {@code String} to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(String str, String suffix) {_		if (str == null || suffix == null) {_			return false__		}_		if (str.endsWith(suffix)) {_			return true__		}_		if (str.length() < suffix.length()) {_			return false__		}__		String lcStr = str.substring(str.length() - suffix.length()).toLowerCase()__		String lcSuffix = suffix.toLowerCase()__		return lcStr.equals(lcSuffix)__	};test,if,the,given,code,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,string,str,string,suffix,if,str,null,suffix,null,return,false,if,str,ends,with,suffix,return,true,if,str,length,suffix,length,return,false,string,lc,str,str,substring,str,length,suffix,length,to,lower,case,string,lc,suffix,suffix,to,lower,case,return,lc,str,equals,lc,suffix
StringUtils -> public static boolean endsWithIgnoreCase(String str, String suffix);1484694546;Test if the given {@code String} ends with the specified suffix,_ignoring upper/lower case._@param str the {@code String} to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(String str, String suffix) {_		if (str == null || suffix == null) {_			return false__		}_		if (str.endsWith(suffix)) {_			return true__		}_		if (str.length() < suffix.length()) {_			return false__		}__		String lcStr = str.substring(str.length() - suffix.length()).toLowerCase()__		String lcSuffix = suffix.toLowerCase()__		return lcStr.equals(lcSuffix)__	};test,if,the,given,code,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,string,str,string,suffix,if,str,null,suffix,null,return,false,if,str,ends,with,suffix,return,true,if,str,length,suffix,length,return,false,string,lc,str,str,substring,str,length,suffix,length,to,lower,case,string,lc,suffix,suffix,to,lower,case,return,lc,str,equals,lc,suffix
StringUtils -> public static boolean endsWithIgnoreCase(String str, String suffix);1487760984;Test if the given {@code String} ends with the specified suffix,_ignoring upper/lower case._@param str the {@code String} to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(String str, String suffix) {_		if (str == null || suffix == null) {_			return false__		}_		if (str.endsWith(suffix)) {_			return true__		}_		if (str.length() < suffix.length()) {_			return false__		}__		String lcStr = str.substring(str.length() - suffix.length()).toLowerCase()__		String lcSuffix = suffix.toLowerCase()__		return lcStr.equals(lcSuffix)__	};test,if,the,given,code,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,string,str,string,suffix,if,str,null,suffix,null,return,false,if,str,ends,with,suffix,return,true,if,str,length,suffix,length,return,false,string,lc,str,str,substring,str,length,suffix,length,to,lower,case,string,lc,suffix,suffix,to,lower,case,return,lc,str,equals,lc,suffix
StringUtils -> public static boolean endsWithIgnoreCase(String str, String suffix);1487778834;Test if the given {@code String} ends with the specified suffix,_ignoring upper/lower case._@param str the {@code String} to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(String str, String suffix) {_		if (str == null || suffix == null) {_			return false__		}_		if (str.endsWith(suffix)) {_			return true__		}_		if (str.length() < suffix.length()) {_			return false__		}__		String lcStr = str.substring(str.length() - suffix.length()).toLowerCase()__		String lcSuffix = suffix.toLowerCase()__		return lcStr.equals(lcSuffix)__	};test,if,the,given,code,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,string,str,string,suffix,if,str,null,suffix,null,return,false,if,str,ends,with,suffix,return,true,if,str,length,suffix,length,return,false,string,lc,str,str,substring,str,length,suffix,length,to,lower,case,string,lc,suffix,suffix,to,lower,case,return,lc,str,equals,lc,suffix
StringUtils -> public static boolean endsWithIgnoreCase(String str, String suffix);1491898314;Test if the given {@code String} ends with the specified suffix,_ignoring upper/lower case._@param str the {@code String} to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(String str, String suffix) {_		if (str == null || suffix == null) {_			return false__		}_		if (str.endsWith(suffix)) {_			return true__		}_		if (str.length() < suffix.length()) {_			return false__		}__		String lcStr = str.substring(str.length() - suffix.length()).toLowerCase()__		String lcSuffix = suffix.toLowerCase()__		return lcStr.equals(lcSuffix)__	};test,if,the,given,code,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,string,str,string,suffix,if,str,null,suffix,null,return,false,if,str,ends,with,suffix,return,true,if,str,length,suffix,length,return,false,string,lc,str,str,substring,str,length,suffix,length,to,lower,case,string,lc,suffix,suffix,to,lower,case,return,lc,str,equals,lc,suffix
StringUtils -> public static boolean endsWithIgnoreCase(String str, String suffix);1491903650;Test if the given {@code String} ends with the specified suffix,_ignoring upper/lower case._@param str the {@code String} to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(String str, String suffix) {_		if (str == null || suffix == null) {_			return false__		}_		if (str.endsWith(suffix)) {_			return true__		}_		if (str.length() < suffix.length()) {_			return false__		}__		String lcStr = str.substring(str.length() - suffix.length()).toLowerCase()__		String lcSuffix = suffix.toLowerCase()__		return lcStr.equals(lcSuffix)__	};test,if,the,given,code,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,string,str,string,suffix,if,str,null,suffix,null,return,false,if,str,ends,with,suffix,return,true,if,str,length,suffix,length,return,false,string,lc,str,str,substring,str,length,suffix,length,to,lower,case,string,lc,suffix,suffix,to,lower,case,return,lc,str,equals,lc,suffix
StringUtils -> public static boolean endsWithIgnoreCase(String str, String suffix);1495868221;Test if the given {@code String} ends with the specified suffix,_ignoring upper/lower case._@param str the {@code String} to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(String str, String suffix) {_		if (str == null || suffix == null) {_			return false__		}_		if (str.endsWith(suffix)) {_			return true__		}_		if (str.length() < suffix.length()) {_			return false__		}__		String lcStr = str.substring(str.length() - suffix.length()).toLowerCase()__		String lcSuffix = suffix.toLowerCase()__		return lcStr.equals(lcSuffix)__	};test,if,the,given,code,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,string,str,string,suffix,if,str,null,suffix,null,return,false,if,str,ends,with,suffix,return,true,if,str,length,suffix,length,return,false,string,lc,str,str,substring,str,length,suffix,length,to,lower,case,string,lc,suffix,suffix,to,lower,case,return,lc,str,equals,lc,suffix
StringUtils -> public static boolean endsWithIgnoreCase(String str, String suffix);1496243689;Test if the given {@code String} ends with the specified suffix,_ignoring upper/lower case._@param str the {@code String} to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(String str, String suffix) {_		if (str == null || suffix == null) {_			return false__		}_		if (str.endsWith(suffix)) {_			return true__		}_		if (str.length() < suffix.length()) {_			return false__		}__		String lcStr = str.substring(str.length() - suffix.length()).toLowerCase()__		String lcSuffix = suffix.toLowerCase()__		return lcStr.equals(lcSuffix)__	};test,if,the,given,code,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,string,str,string,suffix,if,str,null,suffix,null,return,false,if,str,ends,with,suffix,return,true,if,str,length,suffix,length,return,false,string,lc,str,str,substring,str,length,suffix,length,to,lower,case,string,lc,suffix,suffix,to,lower,case,return,lc,str,equals,lc,suffix
StringUtils -> public static boolean endsWithIgnoreCase(String str, String suffix);1496259743;Test if the given {@code String} ends with the specified suffix,_ignoring upper/lower case._@param str the {@code String} to check_@param suffix the suffix to look for_@see java.lang.String#endsWith;public static boolean endsWithIgnoreCase(String str, String suffix) {_		if (str == null || suffix == null) {_			return false__		}_		if (str.endsWith(suffix)) {_			return true__		}_		if (str.length() < suffix.length()) {_			return false__		}__		String lcStr = str.substring(str.length() - suffix.length()).toLowerCase()__		String lcSuffix = suffix.toLowerCase()__		return lcStr.equals(lcSuffix)__	};test,if,the,given,code,string,ends,with,the,specified,suffix,ignoring,upper,lower,case,param,str,the,code,string,to,check,param,suffix,the,suffix,to,look,for,see,java,lang,string,ends,with;public,static,boolean,ends,with,ignore,case,string,str,string,suffix,if,str,null,suffix,null,return,false,if,str,ends,with,suffix,return,true,if,str,length,suffix,length,return,false,string,lc,str,str,substring,str,length,suffix,length,to,lower,case,string,lc,suffix,suffix,to,lower,case,return,lc,str,equals,lc,suffix
StringUtils -> public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1328020251;Take an array Strings and split each element based on the given delimiter._A <code>Properties</code> instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_<code>Properties</code> instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a <code>Properties</code> instance representing the array contents,_or <code>null</code> if the array to process was null or empty;public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,code,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,code,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,code,instance,representing,the,array,contents,or,code,null,code,if,the,array,to,process,was,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1337236962;Take an array Strings and split each element based on the given delimiter._A <code>Properties</code> instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_<code>Properties</code> instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a <code>Properties</code> instance representing the array contents,_or <code>null</code> if the array to process was null or empty;public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,code,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,code,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,code,instance,representing,the,array,contents,or,code,null,code,if,the,array,to,process,was,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1356735495;Take an array Strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was null or empty;public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1367955086;Take an array Strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was null or empty;public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1380921248;Take an array Strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was null or empty;public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1382750743;Take an array Strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was null or empty;public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1385423968;Take an array Strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was null or empty;public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1400189212;Take an array Strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was null or empty;public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1400531359;Take an array Strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was null or empty;public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1402676350;Take an array Strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was null or empty;public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1426267150;Take an array Strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was null or empty;public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1429034538;Take an array Strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was null or empty;public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1429034756;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1431006895;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1431007368;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1449489126;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1467730834;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1472128018;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1472202842;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1473942665;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1484248946;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1484260238;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1484694546;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1487760984;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1487778834;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1491898314;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter);1491903650;Take an array of strings and split each element based on the given delimiter._A {@code Properties} instance is then generated, with the left of the_delimiter providing the key, and the right of the delimiter providing the value._<p>Will trim both the key and value before adding them to the_{@code Properties} instance._@param array the array to process_@param delimiter to split each element using (typically the equals symbol)_@return a {@code Properties} instance representing the array contents,_or {@code null} if the array to process was {@code null} or empty;public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {_		return splitArrayElementsIntoProperties(array, delimiter, null)__	};take,an,array,of,strings,and,split,each,element,based,on,the,given,delimiter,a,code,properties,instance,is,then,generated,with,the,left,of,the,delimiter,providing,the,key,and,the,right,of,the,delimiter,providing,the,value,p,will,trim,both,the,key,and,value,before,adding,them,to,the,code,properties,instance,param,array,the,array,to,process,param,delimiter,to,split,each,element,using,typically,the,equals,symbol,return,a,code,properties,instance,representing,the,array,contents,or,code,null,if,the,array,to,process,was,code,null,or,empty;public,static,properties,split,array,elements,into,properties,string,array,string,delimiter,return,split,array,elements,into,properties,array,delimiter,null
StringUtils -> public static boolean isNotEmpty(String str);1429034538;Check that the given {@code String} is not empty (i.e., neither_{@code null} nor of length 0)._<p>This method is an alias for {@link #hasLength(String)}._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasText(String)_@since 4.2;public static boolean isNotEmpty(String str) {_		return hasLength(str)__	};check,that,the,given,code,string,is,not,empty,i,e,neither,code,null,nor,of,length,0,p,this,method,is,an,alias,for,link,has,length,string,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,text,string,since,4,2;public,static,boolean,is,not,empty,string,str,return,has,length,str
StringUtils -> public static boolean isNotEmpty(String str);1429034756;Check that the given {@code String} is not empty (i.e., neither_{@code null} nor of length 0)._<p>This method is an alias for {@link #hasLength(String)}._<p>Note: this method returns {@code true} for a {@code String} that_purely consists of whitespace._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not {@code null} and has length_@see #hasText(String)_@since 4.2;public static boolean isNotEmpty(String str) {_		return hasLength(str)__	};check,that,the,given,code,string,is,not,empty,i,e,neither,code,null,nor,of,length,0,p,this,method,is,an,alias,for,link,has,length,string,p,note,this,method,returns,code,true,for,a,code,string,that,purely,consists,of,whitespace,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,code,null,and,has,length,see,has,text,string,since,4,2;public,static,boolean,is,not,empty,string,str,return,has,length,str
StringUtils -> public static String arrayToDelimitedString(Object[] arr, String delim);1328020251;Convenience method to return a String array as a delimited (e.g. CSV)_String. E.g. useful for <code>toString()</code> implementations._@param arr the array to display_@param delim the delimiter to use (probably a ",")_@return the delimited String;public static String arrayToDelimitedString(Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convenience,method,to,return,a,string,array,as,a,delimited,e,g,csv,string,e,g,useful,for,code,to,string,code,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,probably,a,return,the,delimited,string;public,static,string,array,to,delimited,string,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(Object[] arr, String delim);1337236962;Convenience method to return a String array as a delimited (e.g. CSV)_String. E.g. useful for <code>toString()</code> implementations._@param arr the array to display_@param delim the delimiter to use (probably a ",")_@return the delimited String;public static String arrayToDelimitedString(Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convenience,method,to,return,a,string,array,as,a,delimited,e,g,csv,string,e,g,useful,for,code,to,string,code,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,probably,a,return,the,delimited,string;public,static,string,array,to,delimited,string,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(Object[] arr, String delim);1356735495;Convenience method to return a String array as a delimited (e.g. CSV)_String. E.g. useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (probably a ",")_@return the delimited String;public static String arrayToDelimitedString(Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convenience,method,to,return,a,string,array,as,a,delimited,e,g,csv,string,e,g,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,probably,a,return,the,delimited,string;public,static,string,array,to,delimited,string,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(Object[] arr, String delim);1367955086;Convenience method to return a String array as a delimited (e.g. CSV)_String. E.g. useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (probably a ",")_@return the delimited String;public static String arrayToDelimitedString(Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convenience,method,to,return,a,string,array,as,a,delimited,e,g,csv,string,e,g,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,probably,a,return,the,delimited,string;public,static,string,array,to,delimited,string,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(Object[] arr, String delim);1380921248;Convenience method to return a String array as a delimited (e.g. CSV)_String. E.g. useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (probably a ",")_@return the delimited String;public static String arrayToDelimitedString(Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convenience,method,to,return,a,string,array,as,a,delimited,e,g,csv,string,e,g,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,probably,a,return,the,delimited,string;public,static,string,array,to,delimited,string,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(Object[] arr, String delim);1382750743;Convenience method to return a String array as a delimited (e.g. CSV)_String. E.g. useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (probably a ",")_@return the delimited String;public static String arrayToDelimitedString(Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convenience,method,to,return,a,string,array,as,a,delimited,e,g,csv,string,e,g,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,probably,a,return,the,delimited,string;public,static,string,array,to,delimited,string,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(Object[] arr, String delim);1385423968;Convenience method to return a String array as a delimited (e.g. CSV)_String. E.g. useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (probably a ",")_@return the delimited String;public static String arrayToDelimitedString(Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convenience,method,to,return,a,string,array,as,a,delimited,e,g,csv,string,e,g,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,probably,a,return,the,delimited,string;public,static,string,array,to,delimited,string,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(Object[] arr, String delim);1400189212;Convenience method to return a String array as a delimited (e.g. CSV)_String. E.g. useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (probably a ",")_@return the delimited String;public static String arrayToDelimitedString(Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convenience,method,to,return,a,string,array,as,a,delimited,e,g,csv,string,e,g,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,probably,a,return,the,delimited,string;public,static,string,array,to,delimited,string,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(Object[] arr, String delim);1400531359;Convenience method to return a String array as a delimited (e.g. CSV)_String. E.g. useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (probably a ",")_@return the delimited String;public static String arrayToDelimitedString(Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convenience,method,to,return,a,string,array,as,a,delimited,e,g,csv,string,e,g,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,probably,a,return,the,delimited,string;public,static,string,array,to,delimited,string,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(Object[] arr, String delim);1402676350;Convenience method to return a String array as a delimited (e.g. CSV)_String. E.g. useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (probably a ",")_@return the delimited String;public static String arrayToDelimitedString(Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convenience,method,to,return,a,string,array,as,a,delimited,e,g,csv,string,e,g,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,probably,a,return,the,delimited,string;public,static,string,array,to,delimited,string,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(Object[] arr, String delim);1426267150;Convenience method to return a String array as a delimited (e.g. CSV)_String. E.g. useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (probably a ",")_@return the delimited String;public static String arrayToDelimitedString(Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convenience,method,to,return,a,string,array,as,a,delimited,e,g,csv,string,e,g,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,probably,a,return,the,delimited,string;public,static,string,array,to,delimited,string,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(Object[] arr, String delim);1429034538;Convenience method to return a String array as a delimited (e.g. CSV)_String. E.g. useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (probably a ",")_@return the delimited String;public static String arrayToDelimitedString(Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convenience,method,to,return,a,string,array,as,a,delimited,e,g,csv,string,e,g,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,probably,a,return,the,delimited,string;public,static,string,array,to,delimited,string,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(Object[] arr, String delim);1429034756;Convert a {@code String} array into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String arrayToDelimitedString(Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convert,a,code,string,array,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,array,to,delimited,string,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(Object[] arr, String delim);1431006895;Convert a {@code String} array into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String arrayToDelimitedString(Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convert,a,code,string,array,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,array,to,delimited,string,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(Object[] arr, String delim);1431007368;Convert a {@code String} array into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String arrayToDelimitedString(Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convert,a,code,string,array,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,array,to,delimited,string,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(Object[] arr, String delim);1449489126;Convert a {@code String} array into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String arrayToDelimitedString(Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convert,a,code,string,array,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,array,to,delimited,string,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(Object[] arr, String delim);1467730834;Convert a {@code String} array into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String arrayToDelimitedString(Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convert,a,code,string,array,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,array,to,delimited,string,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(Object[] arr, String delim);1472128018;Convert a {@code String} array into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String arrayToDelimitedString(Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convert,a,code,string,array,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,array,to,delimited,string,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(Object[] arr, String delim);1472202842;Convert a {@code String} array into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String arrayToDelimitedString(Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convert,a,code,string,array,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,array,to,delimited,string,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(Object[] arr, String delim);1473942665;Convert a {@code String} array into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String arrayToDelimitedString(Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convert,a,code,string,array,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,array,to,delimited,string,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(Object[] arr, String delim);1484248946;Convert a {@code String} array into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String arrayToDelimitedString(Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convert,a,code,string,array,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,array,to,delimited,string,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(Object[] arr, String delim);1484260238;Convert a {@code String} array into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String arrayToDelimitedString(Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convert,a,code,string,array,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,array,to,delimited,string,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(Object[] arr, String delim);1484694546;Convert a {@code String} array into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String arrayToDelimitedString(Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convert,a,code,string,array,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,array,to,delimited,string,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(Object[] arr, String delim);1487760984;Convert a {@code String} array into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String arrayToDelimitedString(Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convert,a,code,string,array,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,array,to,delimited,string,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(Object[] arr, String delim);1487778834;Convert a {@code String} array into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String arrayToDelimitedString(Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}_		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convert,a,code,string,array,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,array,to,delimited,string,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(Object[] arr, String delim);1491898314;Convert a {@code String} array into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String arrayToDelimitedString(Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}__		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convert,a,code,string,array,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,array,to,delimited,string,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(Object[] arr, String delim);1491903650;Convert a {@code String} array into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String arrayToDelimitedString(Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}__		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convert,a,code,string,array,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,array,to,delimited,string,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(Object[] arr, String delim);1495868221;Convert a {@code String} array into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String arrayToDelimitedString(Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}__		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convert,a,code,string,array,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,array,to,delimited,string,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(Object[] arr, String delim);1496243689;Convert a {@code String} array into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String arrayToDelimitedString(Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}__		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convert,a,code,string,array,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,array,to,delimited,string,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String arrayToDelimitedString(Object[] arr, String delim);1496259743;Convert a {@code String} array into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param arr the array to display_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String arrayToDelimitedString(Object[] arr, String delim) {_		if (ObjectUtils.isEmpty(arr)) {_			return ""__		}_		if (arr.length == 1) {_			return ObjectUtils.nullSafeToString(arr[0])__		}__		StringBuilder sb = new StringBuilder()__		for (int i = 0_ i < arr.length_ i++) {_			if (i > 0) {_				sb.append(delim)__			}_			sb.append(arr[i])__		}_		return sb.toString()__	};convert,a,code,string,array,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,arr,the,array,to,display,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,array,to,delimited,string,object,arr,string,delim,if,object,utils,is,empty,arr,return,if,arr,length,1,return,object,utils,null,safe,to,string,arr,0,string,builder,sb,new,string,builder,for,int,i,0,i,arr,length,i,if,i,0,sb,append,delim,sb,append,arr,i,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, @Nullable String newPattern);1496837955;Replace all occurrences of a substring within a string with another string._@param inString {@code String} to examine_@param oldPattern {@code String} to replace_@param newPattern {@code String} to insert_@return a {@code String} with the replacements;public static String replace(String inString, String oldPattern, @Nullable String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		int index = inString.indexOf(oldPattern)__		if (index == -1) {_			_			return inString__		}__		int capacity = inString.length()__		if (newPattern.length() > oldPattern.length()) {_			capacity += 16__		}_		StringBuilder sb = new StringBuilder(capacity)___		int pos = 0_  _		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}__		_		sb.append(inString.substring(pos))__		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,code,string,to,examine,param,old,pattern,code,string,to,replace,param,new,pattern,code,string,to,insert,return,a,code,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,nullable,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,int,index,in,string,index,of,old,pattern,if,index,1,return,in,string,int,capacity,in,string,length,if,new,pattern,length,old,pattern,length,capacity,16,string,builder,sb,new,string,builder,capacity,int,pos,0,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, @Nullable String newPattern);1499270197;Replace all occurrences of a substring within a string with another string._@param inString {@code String} to examine_@param oldPattern {@code String} to replace_@param newPattern {@code String} to insert_@return a {@code String} with the replacements;public static String replace(String inString, String oldPattern, @Nullable String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		int index = inString.indexOf(oldPattern)__		if (index == -1) {_			_			return inString__		}__		int capacity = inString.length()__		if (newPattern.length() > oldPattern.length()) {_			capacity += 16__		}_		StringBuilder sb = new StringBuilder(capacity)___		int pos = 0_  _		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}__		_		sb.append(inString.substring(pos))__		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,code,string,to,examine,param,old,pattern,code,string,to,replace,param,new,pattern,code,string,to,insert,return,a,code,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,nullable,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,int,index,in,string,index,of,old,pattern,if,index,1,return,in,string,int,capacity,in,string,length,if,new,pattern,length,old,pattern,length,capacity,16,string,builder,sb,new,string,builder,capacity,int,pos,0,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, @Nullable String newPattern);1508667152;Replace all occurrences of a substring within a string with another string._@param inString {@code String} to examine_@param oldPattern {@code String} to replace_@param newPattern {@code String} to insert_@return a {@code String} with the replacements;public static String replace(String inString, String oldPattern, @Nullable String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		int index = inString.indexOf(oldPattern)__		if (index == -1) {_			_			return inString__		}__		int capacity = inString.length()__		if (newPattern.length() > oldPattern.length()) {_			capacity += 16__		}_		StringBuilder sb = new StringBuilder(capacity)___		int pos = 0_  _		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}__		_		sb.append(inString.substring(pos))__		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,code,string,to,examine,param,old,pattern,code,string,to,replace,param,new,pattern,code,string,to,insert,return,a,code,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,nullable,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,int,index,in,string,index,of,old,pattern,if,index,1,return,in,string,int,capacity,in,string,length,if,new,pattern,length,old,pattern,length,capacity,16,string,builder,sb,new,string,builder,capacity,int,pos,0,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, @Nullable String newPattern);1508675477;Replace all occurrences of a substring within a string with another string._@param inString {@code String} to examine_@param oldPattern {@code String} to replace_@param newPattern {@code String} to insert_@return a {@code String} with the replacements;public static String replace(String inString, String oldPattern, @Nullable String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		int index = inString.indexOf(oldPattern)__		if (index == -1) {_			_			return inString__		}__		int capacity = inString.length()__		if (newPattern.length() > oldPattern.length()) {_			capacity += 16__		}_		StringBuilder sb = new StringBuilder(capacity)___		int pos = 0_  _		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}__		_		sb.append(inString.substring(pos))__		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,code,string,to,examine,param,old,pattern,code,string,to,replace,param,new,pattern,code,string,to,insert,return,a,code,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,nullable,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,int,index,in,string,index,of,old,pattern,if,index,1,return,in,string,int,capacity,in,string,length,if,new,pattern,length,old,pattern,length,capacity,16,string,builder,sb,new,string,builder,capacity,int,pos,0,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, @Nullable String newPattern);1508843807;Replace all occurrences of a substring within a string with another string._@param inString {@code String} to examine_@param oldPattern {@code String} to replace_@param newPattern {@code String} to insert_@return a {@code String} with the replacements;public static String replace(String inString, String oldPattern, @Nullable String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		int index = inString.indexOf(oldPattern)__		if (index == -1) {_			_			return inString__		}__		int capacity = inString.length()__		if (newPattern.length() > oldPattern.length()) {_			capacity += 16__		}_		StringBuilder sb = new StringBuilder(capacity)___		int pos = 0_  _		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}__		_		sb.append(inString.substring(pos))__		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,code,string,to,examine,param,old,pattern,code,string,to,replace,param,new,pattern,code,string,to,insert,return,a,code,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,nullable,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,int,index,in,string,index,of,old,pattern,if,index,1,return,in,string,int,capacity,in,string,length,if,new,pattern,length,old,pattern,length,capacity,16,string,builder,sb,new,string,builder,capacity,int,pos,0,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, @Nullable String newPattern);1516903831;Replace all occurrences of a substring within a string with another string._@param inString {@code String} to examine_@param oldPattern {@code String} to replace_@param newPattern {@code String} to insert_@return a {@code String} with the replacements;public static String replace(String inString, String oldPattern, @Nullable String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		int index = inString.indexOf(oldPattern)__		if (index == -1) {_			_			return inString__		}__		int capacity = inString.length()__		if (newPattern.length() > oldPattern.length()) {_			capacity += 16__		}_		StringBuilder sb = new StringBuilder(capacity)___		int pos = 0_  _		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}__		_		sb.append(inString.substring(pos))__		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,code,string,to,examine,param,old,pattern,code,string,to,replace,param,new,pattern,code,string,to,insert,return,a,code,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,nullable,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,int,index,in,string,index,of,old,pattern,if,index,1,return,in,string,int,capacity,in,string,length,if,new,pattern,length,old,pattern,length,capacity,16,string,builder,sb,new,string,builder,capacity,int,pos,0,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, @Nullable String newPattern);1519295386;Replace all occurrences of a substring within a string with another string._@param inString {@code String} to examine_@param oldPattern {@code String} to replace_@param newPattern {@code String} to insert_@return a {@code String} with the replacements;public static String replace(String inString, String oldPattern, @Nullable String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		int index = inString.indexOf(oldPattern)__		if (index == -1) {_			_			return inString__		}__		int capacity = inString.length()__		if (newPattern.length() > oldPattern.length()) {_			capacity += 16__		}_		StringBuilder sb = new StringBuilder(capacity)___		int pos = 0_  _		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}__		_		sb.append(inString.substring(pos))__		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,code,string,to,examine,param,old,pattern,code,string,to,replace,param,new,pattern,code,string,to,insert,return,a,code,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,nullable,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,int,index,in,string,index,of,old,pattern,if,index,1,return,in,string,int,capacity,in,string,length,if,new,pattern,length,old,pattern,length,capacity,16,string,builder,sb,new,string,builder,capacity,int,pos,0,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, @Nullable String newPattern);1519308837;Replace all occurrences of a substring within a string with another string._@param inString {@code String} to examine_@param oldPattern {@code String} to replace_@param newPattern {@code String} to insert_@return a {@code String} with the replacements;public static String replace(String inString, String oldPattern, @Nullable String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		int index = inString.indexOf(oldPattern)__		if (index == -1) {_			_			return inString__		}__		int capacity = inString.length()__		if (newPattern.length() > oldPattern.length()) {_			capacity += 16__		}_		StringBuilder sb = new StringBuilder(capacity)___		int pos = 0_  _		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}__		_		sb.append(inString.substring(pos))__		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,code,string,to,examine,param,old,pattern,code,string,to,replace,param,new,pattern,code,string,to,insert,return,a,code,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,nullable,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,int,index,in,string,index,of,old,pattern,if,index,1,return,in,string,int,capacity,in,string,length,if,new,pattern,length,old,pattern,length,capacity,16,string,builder,sb,new,string,builder,capacity,int,pos,0,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, @Nullable String newPattern);1519588127;Replace all occurrences of a substring within a string with another string._@param inString {@code String} to examine_@param oldPattern {@code String} to replace_@param newPattern {@code String} to insert_@return a {@code String} with the replacements;public static String replace(String inString, String oldPattern, @Nullable String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		int index = inString.indexOf(oldPattern)__		if (index == -1) {_			_			return inString__		}__		int capacity = inString.length()__		if (newPattern.length() > oldPattern.length()) {_			capacity += 16__		}_		StringBuilder sb = new StringBuilder(capacity)___		int pos = 0_  _		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}__		_		sb.append(inString.substring(pos))__		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,code,string,to,examine,param,old,pattern,code,string,to,replace,param,new,pattern,code,string,to,insert,return,a,code,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,nullable,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,int,index,in,string,index,of,old,pattern,if,index,1,return,in,string,int,capacity,in,string,length,if,new,pattern,length,old,pattern,length,capacity,16,string,builder,sb,new,string,builder,capacity,int,pos,0,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, @Nullable String newPattern);1522332352;Replace all occurrences of a substring within a string with another string._@param inString {@code String} to examine_@param oldPattern {@code String} to replace_@param newPattern {@code String} to insert_@return a {@code String} with the replacements;public static String replace(String inString, String oldPattern, @Nullable String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		int index = inString.indexOf(oldPattern)__		if (index == -1) {_			_			return inString__		}__		int capacity = inString.length()__		if (newPattern.length() > oldPattern.length()) {_			capacity += 16__		}_		StringBuilder sb = new StringBuilder(capacity)___		int pos = 0_  _		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}__		_		sb.append(inString.substring(pos))__		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,code,string,to,examine,param,old,pattern,code,string,to,replace,param,new,pattern,code,string,to,insert,return,a,code,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,nullable,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,int,index,in,string,index,of,old,pattern,if,index,1,return,in,string,int,capacity,in,string,length,if,new,pattern,length,old,pattern,length,capacity,16,string,builder,sb,new,string,builder,capacity,int,pos,0,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, @Nullable String newPattern);1525166194;Replace all occurrences of a substring within a string with another string._@param inString {@code String} to examine_@param oldPattern {@code String} to replace_@param newPattern {@code String} to insert_@return a {@code String} with the replacements;public static String replace(String inString, String oldPattern, @Nullable String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		int index = inString.indexOf(oldPattern)__		if (index == -1) {_			_			return inString__		}__		int capacity = inString.length()__		if (newPattern.length() > oldPattern.length()) {_			capacity += 16__		}_		StringBuilder sb = new StringBuilder(capacity)___		int pos = 0_  _		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}__		_		sb.append(inString.substring(pos))__		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,code,string,to,examine,param,old,pattern,code,string,to,replace,param,new,pattern,code,string,to,insert,return,a,code,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,nullable,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,int,index,in,string,index,of,old,pattern,if,index,1,return,in,string,int,capacity,in,string,length,if,new,pattern,length,old,pattern,length,capacity,16,string,builder,sb,new,string,builder,capacity,int,pos,0,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, @Nullable String newPattern);1530188116;Replace all occurrences of a substring within a string with another string._@param inString {@code String} to examine_@param oldPattern {@code String} to replace_@param newPattern {@code String} to insert_@return a {@code String} with the replacements;public static String replace(String inString, String oldPattern, @Nullable String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		int index = inString.indexOf(oldPattern)__		if (index == -1) {_			_			return inString__		}__		int capacity = inString.length()__		if (newPattern.length() > oldPattern.length()) {_			capacity += 16__		}_		StringBuilder sb = new StringBuilder(capacity)___		int pos = 0_  _		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}__		_		sb.append(inString.substring(pos))__		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,code,string,to,examine,param,old,pattern,code,string,to,replace,param,new,pattern,code,string,to,insert,return,a,code,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,nullable,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,int,index,in,string,index,of,old,pattern,if,index,1,return,in,string,int,capacity,in,string,length,if,new,pattern,length,old,pattern,length,capacity,16,string,builder,sb,new,string,builder,capacity,int,pos,0,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, @Nullable String newPattern);1531843079;Replace all occurrences of a substring within a string with another string._@param inString {@code String} to examine_@param oldPattern {@code String} to replace_@param newPattern {@code String} to insert_@return a {@code String} with the replacements;public static String replace(String inString, String oldPattern, @Nullable String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		int index = inString.indexOf(oldPattern)__		if (index == -1) {_			_			return inString__		}__		int capacity = inString.length()__		if (newPattern.length() > oldPattern.length()) {_			capacity += 16__		}_		StringBuilder sb = new StringBuilder(capacity)___		int pos = 0_  _		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}__		_		sb.append(inString.substring(pos))__		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,code,string,to,examine,param,old,pattern,code,string,to,replace,param,new,pattern,code,string,to,insert,return,a,code,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,nullable,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,int,index,in,string,index,of,old,pattern,if,index,1,return,in,string,int,capacity,in,string,length,if,new,pattern,length,old,pattern,length,capacity,16,string,builder,sb,new,string,builder,capacity,int,pos,0,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, @Nullable String newPattern);1531905026;Replace all occurrences of a substring within a string with another string._@param inString {@code String} to examine_@param oldPattern {@code String} to replace_@param newPattern {@code String} to insert_@return a {@code String} with the replacements;public static String replace(String inString, String oldPattern, @Nullable String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		int index = inString.indexOf(oldPattern)__		if (index == -1) {_			_			return inString__		}__		int capacity = inString.length()__		if (newPattern.length() > oldPattern.length()) {_			capacity += 16__		}_		StringBuilder sb = new StringBuilder(capacity)___		int pos = 0_  _		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}__		_		sb.append(inString.substring(pos))__		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,code,string,to,examine,param,old,pattern,code,string,to,replace,param,new,pattern,code,string,to,insert,return,a,code,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,nullable,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,int,index,in,string,index,of,old,pattern,if,index,1,return,in,string,int,capacity,in,string,length,if,new,pattern,length,old,pattern,length,capacity,16,string,builder,sb,new,string,builder,capacity,int,pos,0,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, @Nullable String newPattern);1533557519;Replace all occurrences of a substring within a string with another string._@param inString {@code String} to examine_@param oldPattern {@code String} to replace_@param newPattern {@code String} to insert_@return a {@code String} with the replacements;public static String replace(String inString, String oldPattern, @Nullable String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		int index = inString.indexOf(oldPattern)__		if (index == -1) {_			_			return inString__		}__		int capacity = inString.length()__		if (newPattern.length() > oldPattern.length()) {_			capacity += 16__		}_		StringBuilder sb = new StringBuilder(capacity)___		int pos = 0_  _		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}__		_		sb.append(inString.substring(pos))__		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,code,string,to,examine,param,old,pattern,code,string,to,replace,param,new,pattern,code,string,to,insert,return,a,code,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,nullable,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,int,index,in,string,index,of,old,pattern,if,index,1,return,in,string,int,capacity,in,string,length,if,new,pattern,length,old,pattern,length,capacity,16,string,builder,sb,new,string,builder,capacity,int,pos,0,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, @Nullable String newPattern);1533602820;Replace all occurrences of a substring within a string with another string._@param inString {@code String} to examine_@param oldPattern {@code String} to replace_@param newPattern {@code String} to insert_@return a {@code String} with the replacements;public static String replace(String inString, String oldPattern, @Nullable String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		int index = inString.indexOf(oldPattern)__		if (index == -1) {_			_			return inString__		}__		int capacity = inString.length()__		if (newPattern.length() > oldPattern.length()) {_			capacity += 16__		}_		StringBuilder sb = new StringBuilder(capacity)___		int pos = 0_  _		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}__		_		sb.append(inString.substring(pos))__		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,code,string,to,examine,param,old,pattern,code,string,to,replace,param,new,pattern,code,string,to,insert,return,a,code,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,nullable,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,int,index,in,string,index,of,old,pattern,if,index,1,return,in,string,int,capacity,in,string,length,if,new,pattern,length,old,pattern,length,capacity,16,string,builder,sb,new,string,builder,capacity,int,pos,0,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, @Nullable String newPattern);1535316501;Replace all occurrences of a substring within a string with another string._@param inString {@code String} to examine_@param oldPattern {@code String} to replace_@param newPattern {@code String} to insert_@return a {@code String} with the replacements;public static String replace(String inString, String oldPattern, @Nullable String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		int index = inString.indexOf(oldPattern)__		if (index == -1) {_			_			return inString__		}__		int capacity = inString.length()__		if (newPattern.length() > oldPattern.length()) {_			capacity += 16__		}_		StringBuilder sb = new StringBuilder(capacity)___		int pos = 0_  _		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}__		_		sb.append(inString.substring(pos))__		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,code,string,to,examine,param,old,pattern,code,string,to,replace,param,new,pattern,code,string,to,insert,return,a,code,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,nullable,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,int,index,in,string,index,of,old,pattern,if,index,1,return,in,string,int,capacity,in,string,length,if,new,pattern,length,old,pattern,length,capacity,16,string,builder,sb,new,string,builder,capacity,int,pos,0,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, @Nullable String newPattern);1550237113;Replace all occurrences of a substring within a string with another string._@param inString {@code String} to examine_@param oldPattern {@code String} to replace_@param newPattern {@code String} to insert_@return a {@code String} with the replacements;public static String replace(String inString, String oldPattern, @Nullable String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		int index = inString.indexOf(oldPattern)__		if (index == -1) {_			_			return inString__		}__		int capacity = inString.length()__		if (newPattern.length() > oldPattern.length()) {_			capacity += 16__		}_		StringBuilder sb = new StringBuilder(capacity)___		int pos = 0_  _		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}__		_		sb.append(inString.substring(pos))__		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,code,string,to,examine,param,old,pattern,code,string,to,replace,param,new,pattern,code,string,to,insert,return,a,code,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,nullable,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,int,index,in,string,index,of,old,pattern,if,index,1,return,in,string,int,capacity,in,string,length,if,new,pattern,length,old,pattern,length,capacity,16,string,builder,sb,new,string,builder,capacity,int,pos,0,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static String replace(String inString, String oldPattern, @Nullable String newPattern);1550238935;Replace all occurrences of a substring within a string with another string._@param inString {@code String} to examine_@param oldPattern {@code String} to replace_@param newPattern {@code String} to insert_@return a {@code String} with the replacements;public static String replace(String inString, String oldPattern, @Nullable String newPattern) {_		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {_			return inString__		}_		int index = inString.indexOf(oldPattern)__		if (index == -1) {_			_			return inString__		}__		int capacity = inString.length()__		if (newPattern.length() > oldPattern.length()) {_			capacity += 16__		}_		StringBuilder sb = new StringBuilder(capacity)___		int pos = 0_  _		int patLen = oldPattern.length()__		while (index >= 0) {_			sb.append(inString.substring(pos, index))__			sb.append(newPattern)__			pos = index + patLen__			index = inString.indexOf(oldPattern, pos)__		}__		_		sb.append(inString.substring(pos))__		return sb.toString()__	};replace,all,occurrences,of,a,substring,within,a,string,with,another,string,param,in,string,code,string,to,examine,param,old,pattern,code,string,to,replace,param,new,pattern,code,string,to,insert,return,a,code,string,with,the,replacements;public,static,string,replace,string,in,string,string,old,pattern,nullable,string,new,pattern,if,has,length,in,string,has,length,old,pattern,new,pattern,null,return,in,string,int,index,in,string,index,of,old,pattern,if,index,1,return,in,string,int,capacity,in,string,length,if,new,pattern,length,old,pattern,length,capacity,16,string,builder,sb,new,string,builder,capacity,int,pos,0,int,pat,len,old,pattern,length,while,index,0,sb,append,in,string,substring,pos,index,sb,append,new,pattern,pos,index,pat,len,index,in,string,index,of,old,pattern,pos,sb,append,in,string,substring,pos,return,sb,to,string
StringUtils -> public static boolean hasText(CharSequence str);1328020251;Check whether the given CharSequence has actual text._More specifically, returns <code>true</code> if the string not <code>null</code>,_its length is greater than 0, and it contains at least one non-whitespace character._<p><pre>_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the CharSequence to check (may be <code>null</code>)_@return <code>true</code> if the CharSequence is not <code>null</code>,_its length is greater than 0, and it does not contain whitespace only_@see java.lang.Character#isWhitespace;public static boolean hasText(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (!Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,char,sequence,has,actual,text,more,specifically,returns,code,true,code,if,the,string,not,code,null,code,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,char,sequence,to,check,may,be,code,null,code,return,code,true,code,if,the,char,sequence,is,not,code,null,code,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,java,lang,character,is,whitespace;public,static,boolean,has,text,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean hasText(CharSequence str);1337236962;Check whether the given CharSequence has actual text._More specifically, returns <code>true</code> if the string not <code>null</code>,_its length is greater than 0, and it contains at least one non-whitespace character._<p><pre>_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the CharSequence to check (may be <code>null</code>)_@return <code>true</code> if the CharSequence is not <code>null</code>,_its length is greater than 0, and it does not contain whitespace only_@see java.lang.Character#isWhitespace;public static boolean hasText(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (!Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,char,sequence,has,actual,text,more,specifically,returns,code,true,code,if,the,string,not,code,null,code,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,char,sequence,to,check,may,be,code,null,code,return,code,true,code,if,the,char,sequence,is,not,code,null,code,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,java,lang,character,is,whitespace;public,static,boolean,has,text,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean hasText(CharSequence str);1356735495;Check whether the given CharSequence has actual text._More specifically, returns {@code true} if the string not {@code null},_its length is greater than 0, and it contains at least one non-whitespace character._<p><pre>_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the CharSequence to check (may be {@code null})_@return {@code true} if the CharSequence is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (!Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,char,sequence,has,actual,text,more,specifically,returns,code,true,if,the,string,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,char,sequence,to,check,may,be,code,null,return,code,true,if,the,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean hasText(CharSequence str);1367955086;Check whether the given CharSequence has actual text._More specifically, returns {@code true} if the string not {@code null},_its length is greater than 0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the CharSequence to check (may be {@code null})_@return {@code true} if the CharSequence is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (!Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,char,sequence,has,actual,text,more,specifically,returns,code,true,if,the,string,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,char,sequence,to,check,may,be,code,null,return,code,true,if,the,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean hasText(CharSequence str);1380921248;Check whether the given CharSequence has actual text._More specifically, returns {@code true} if the string not {@code null},_its length is greater than 0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the CharSequence to check (may be {@code null})_@return {@code true} if the CharSequence is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (!Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,char,sequence,has,actual,text,more,specifically,returns,code,true,if,the,string,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,char,sequence,to,check,may,be,code,null,return,code,true,if,the,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean hasText(CharSequence str);1382750743;Check whether the given CharSequence has actual text._More specifically, returns {@code true} if the string not {@code null},_its length is greater than 0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the CharSequence to check (may be {@code null})_@return {@code true} if the CharSequence is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (!Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,char,sequence,has,actual,text,more,specifically,returns,code,true,if,the,string,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,char,sequence,to,check,may,be,code,null,return,code,true,if,the,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean hasText(CharSequence str);1385423968;Check whether the given CharSequence has actual text._More specifically, returns {@code true} if the string not {@code null},_its length is greater than 0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the CharSequence to check (may be {@code null})_@return {@code true} if the CharSequence is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (!Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,char,sequence,has,actual,text,more,specifically,returns,code,true,if,the,string,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,char,sequence,to,check,may,be,code,null,return,code,true,if,the,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean hasText(CharSequence str);1400189212;Check whether the given CharSequence has actual text._More specifically, returns {@code true} if the string not {@code null},_its length is greater than 0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the CharSequence to check (may be {@code null})_@return {@code true} if the CharSequence is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (!Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,char,sequence,has,actual,text,more,specifically,returns,code,true,if,the,string,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,char,sequence,to,check,may,be,code,null,return,code,true,if,the,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean hasText(CharSequence str);1400531359;Check whether the given CharSequence has actual text._More specifically, returns {@code true} if the string not {@code null},_its length is greater than 0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the CharSequence to check (may be {@code null})_@return {@code true} if the CharSequence is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (!Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,char,sequence,has,actual,text,more,specifically,returns,code,true,if,the,string,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,char,sequence,to,check,may,be,code,null,return,code,true,if,the,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean hasText(CharSequence str);1402676350;Check whether the given CharSequence has actual text._More specifically, returns {@code true} if the string not {@code null},_its length is greater than 0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the CharSequence to check (may be {@code null})_@return {@code true} if the CharSequence is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (!Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,char,sequence,has,actual,text,more,specifically,returns,code,true,if,the,string,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,char,sequence,to,check,may,be,code,null,return,code,true,if,the,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean hasText(CharSequence str);1426267150;Check whether the given CharSequence has actual text._More specifically, returns {@code true} if the string not {@code null},_its length is greater than 0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the CharSequence to check (may be {@code null})_@return {@code true} if the CharSequence is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (!Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,char,sequence,has,actual,text,more,specifically,returns,code,true,if,the,string,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,char,sequence,to,check,may,be,code,null,return,code,true,if,the,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean hasText(CharSequence str);1429034538;Check whether the given CharSequence has actual text._More specifically, returns {@code true} if the string not {@code null},_its length is greater than 0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the CharSequence to check (may be {@code null})_@return {@code true} if the CharSequence is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (!Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,char,sequence,has,actual,text,more,specifically,returns,code,true,if,the,string,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,char,sequence,to,check,may,be,code,null,return,code,true,if,the,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean hasText(CharSequence str);1429034756;Check whether the given {@code CharSequence} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code CharSequence} is not {@code null}, its length is greater than_0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (!Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean hasText(CharSequence str);1431006895;Check whether the given {@code CharSequence} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code CharSequence} is not {@code null}, its length is greater than_0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (!Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean hasText(CharSequence str);1431007368;Check whether the given {@code CharSequence} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code CharSequence} is not {@code null}, its length is greater than_0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (!Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean hasText(CharSequence str);1449489126;Check whether the given {@code CharSequence} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code CharSequence} is not {@code null}, its length is greater than_0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (!Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean hasText(CharSequence str);1467730834;Check whether the given {@code CharSequence} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code CharSequence} is not {@code null}, its length is greater than_0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (!Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean hasText(CharSequence str);1472128018;Check whether the given {@code CharSequence} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code CharSequence} is not {@code null}, its length is greater than_0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (!Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean hasText(CharSequence str);1472202842;Check whether the given {@code CharSequence} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code CharSequence} is not {@code null}, its length is greater than_0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (!Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean hasText(CharSequence str);1473942665;Check whether the given {@code CharSequence} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code CharSequence} is not {@code null}, its length is greater than_0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (!Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean hasText(CharSequence str);1484248946;Check whether the given {@code CharSequence} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code CharSequence} is not {@code null}, its length is greater than_0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (!Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean hasText(CharSequence str);1484260238;Check whether the given {@code CharSequence} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code CharSequence} is not {@code null}, its length is greater than_0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (!Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean hasText(CharSequence str);1484694546;Check whether the given {@code CharSequence} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code CharSequence} is not {@code null}, its length is greater than_0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (!Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean hasText(CharSequence str);1487760984;Check whether the given {@code CharSequence} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code CharSequence} is not {@code null}, its length is greater than_0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (!Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean hasText(CharSequence str);1487778834;Check whether the given {@code CharSequence} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code CharSequence} is not {@code null}, its length is greater than_0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}_		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (!Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean hasText(CharSequence str);1491898314;Check whether the given {@code CharSequence} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code CharSequence} is not {@code null}, its length is greater than_0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}__		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (!Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean hasText(CharSequence str);1491903650;Check whether the given {@code CharSequence} contains actual <em>text</em>._<p>More specifically, this method returns {@code true} if the_{@code CharSequence} is not {@code null}, its length is greater than_0, and it contains at least one non-whitespace character._<p><pre class="code">_StringUtils.hasText(null) = false_StringUtils.hasText("") = false_StringUtils.hasText(" ") = false_StringUtils.hasText("12345") = true_StringUtils.hasText(" 12345 ") = true_</pre>_@param str the {@code CharSequence} to check (may be {@code null})_@return {@code true} if the {@code CharSequence} is not {@code null},_its length is greater than 0, and it does not contain whitespace only_@see Character#isWhitespace;public static boolean hasText(CharSequence str) {_		if (!hasLength(str)) {_			return false__		}__		int strLen = str.length()__		for (int i = 0_ i < strLen_ i++) {_			if (!Character.isWhitespace(str.charAt(i))) {_				return true__			}_		}_		return false__	};check,whether,the,given,code,char,sequence,contains,actual,em,text,em,p,more,specifically,this,method,returns,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,contains,at,least,one,non,whitespace,character,p,pre,class,code,string,utils,has,text,null,false,string,utils,has,text,false,string,utils,has,text,false,string,utils,has,text,12345,true,string,utils,has,text,12345,true,pre,param,str,the,code,char,sequence,to,check,may,be,code,null,return,code,true,if,the,code,char,sequence,is,not,code,null,its,length,is,greater,than,0,and,it,does,not,contain,whitespace,only,see,character,is,whitespace;public,static,boolean,has,text,char,sequence,str,if,has,length,str,return,false,int,str,len,str,length,for,int,i,0,i,str,len,i,if,character,is,whitespace,str,char,at,i,return,true,return,false
StringUtils -> public static boolean containsWhitespace(String str);1328020251;Check whether the given String contains any whitespace characters._@param str the String to check (may be <code>null</code>)_@return <code>true</code> if the String is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,string,contains,any,whitespace,characters,param,str,the,string,to,check,may,be,code,null,code,return,code,true,code,if,the,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(String str);1337236962;Check whether the given String contains any whitespace characters._@param str the String to check (may be <code>null</code>)_@return <code>true</code> if the String is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,string,contains,any,whitespace,characters,param,str,the,string,to,check,may,be,code,null,code,return,code,true,code,if,the,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(String str);1356735495;Check whether the given String contains any whitespace characters._@param str the String to check (may be {@code null})_@return {@code true} if the String is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,string,contains,any,whitespace,characters,param,str,the,string,to,check,may,be,code,null,return,code,true,if,the,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(String str);1367955086;Check whether the given String contains any whitespace characters._@param str the String to check (may be {@code null})_@return {@code true} if the String is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,string,contains,any,whitespace,characters,param,str,the,string,to,check,may,be,code,null,return,code,true,if,the,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(String str);1380921248;Check whether the given String contains any whitespace characters._@param str the String to check (may be {@code null})_@return {@code true} if the String is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,string,contains,any,whitespace,characters,param,str,the,string,to,check,may,be,code,null,return,code,true,if,the,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(String str);1382750743;Check whether the given String contains any whitespace characters._@param str the String to check (may be {@code null})_@return {@code true} if the String is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,string,contains,any,whitespace,characters,param,str,the,string,to,check,may,be,code,null,return,code,true,if,the,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(String str);1385423968;Check whether the given String contains any whitespace characters._@param str the String to check (may be {@code null})_@return {@code true} if the String is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,string,contains,any,whitespace,characters,param,str,the,string,to,check,may,be,code,null,return,code,true,if,the,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(String str);1400189212;Check whether the given String contains any whitespace characters._@param str the String to check (may be {@code null})_@return {@code true} if the String is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,string,contains,any,whitespace,characters,param,str,the,string,to,check,may,be,code,null,return,code,true,if,the,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(String str);1400531359;Check whether the given String contains any whitespace characters._@param str the String to check (may be {@code null})_@return {@code true} if the String is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,string,contains,any,whitespace,characters,param,str,the,string,to,check,may,be,code,null,return,code,true,if,the,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(String str);1402676350;Check whether the given String contains any whitespace characters._@param str the String to check (may be {@code null})_@return {@code true} if the String is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,string,contains,any,whitespace,characters,param,str,the,string,to,check,may,be,code,null,return,code,true,if,the,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(String str);1426267150;Check whether the given String contains any whitespace characters._@param str the String to check (may be {@code null})_@return {@code true} if the String is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,string,contains,any,whitespace,characters,param,str,the,string,to,check,may,be,code,null,return,code,true,if,the,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(String str);1429034538;Check whether the given String contains any whitespace characters._@param str the String to check (may be {@code null})_@return {@code true} if the String is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,string,contains,any,whitespace,characters,param,str,the,string,to,check,may,be,code,null,return,code,true,if,the,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(String str);1429034756;Check whether the given {@code String} contains any whitespace characters._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,code,string,contains,any,whitespace,characters,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(String str);1431006895;Check whether the given {@code String} contains any whitespace characters._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,code,string,contains,any,whitespace,characters,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(String str);1431007368;Check whether the given {@code String} contains any whitespace characters._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,code,string,contains,any,whitespace,characters,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(String str);1449489126;Check whether the given {@code String} contains any whitespace characters._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,code,string,contains,any,whitespace,characters,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(String str);1467730834;Check whether the given {@code String} contains any whitespace characters._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,code,string,contains,any,whitespace,characters,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(String str);1472128018;Check whether the given {@code String} contains any whitespace characters._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,code,string,contains,any,whitespace,characters,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(String str);1472202842;Check whether the given {@code String} contains any whitespace characters._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,code,string,contains,any,whitespace,characters,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(String str);1473942665;Check whether the given {@code String} contains any whitespace characters._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,code,string,contains,any,whitespace,characters,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(String str);1484248946;Check whether the given {@code String} contains any whitespace characters._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,code,string,contains,any,whitespace,characters,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(String str);1484260238;Check whether the given {@code String} contains any whitespace characters._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,code,string,contains,any,whitespace,characters,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(String str);1484694546;Check whether the given {@code String} contains any whitespace characters._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,code,string,contains,any,whitespace,characters,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(String str);1487760984;Check whether the given {@code String} contains any whitespace characters._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,code,string,contains,any,whitespace,characters,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(String str);1487778834;Check whether the given {@code String} contains any whitespace characters._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,code,string,contains,any,whitespace,characters,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(String str);1491898314;Check whether the given {@code String} contains any whitespace characters._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,code,string,contains,any,whitespace,characters,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static boolean containsWhitespace(String str);1491903650;Check whether the given {@code String} contains any whitespace characters._@param str the {@code String} to check (may be {@code null})_@return {@code true} if the {@code String} is not empty and_contains at least 1 whitespace character_@see #containsWhitespace(CharSequence);public static boolean containsWhitespace(String str) {_		return containsWhitespace((CharSequence) str)__	};check,whether,the,given,code,string,contains,any,whitespace,characters,param,str,the,code,string,to,check,may,be,code,null,return,code,true,if,the,code,string,is,not,empty,and,contains,at,least,1,whitespace,character,see,contains,whitespace,char,sequence;public,static,boolean,contains,whitespace,string,str,return,contains,whitespace,char,sequence,str
StringUtils -> public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter);1496837955;Take a {@code String} that is a delimited list and convert it into a_{@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,nullable,string,str,nullable,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter);1499270197;Take a {@code String} that is a delimited list and convert it into a_{@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,nullable,string,str,nullable,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter);1508667152;Take a {@code String} that is a delimited list and convert it into a_{@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,nullable,string,str,nullable,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter);1508675477;Take a {@code String} that is a delimited list and convert it into a_{@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,nullable,string,str,nullable,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter);1508843807;Take a {@code String} that is a delimited list and convert it into a_{@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,nullable,string,str,nullable,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter);1516903831;Take a {@code String} that is a delimited list and convert it into a_{@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,nullable,string,str,nullable,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter);1519295386;Take a {@code String} that is a delimited list and convert it into a_{@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,nullable,string,str,nullable,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter);1519308837;Take a {@code String} that is a delimited list and convert it into a_{@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,nullable,string,str,nullable,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter);1519588127;Take a {@code String} that is a delimited list and convert it into a_{@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,nullable,string,str,nullable,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter);1522332352;Take a {@code String} that is a delimited list and convert it into a_{@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,nullable,string,str,nullable,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter);1525166194;Take a {@code String} that is a delimited list and convert it into a_{@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,nullable,string,str,nullable,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter);1530188116;Take a {@code String} that is a delimited list and convert it into a_{@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,nullable,string,str,nullable,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter);1531843079;Take a {@code String} that is a delimited list and convert it into a_{@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,nullable,string,str,nullable,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter);1531905026;Take a {@code String} that is a delimited list and convert it into a_{@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String}_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,nullable,string,str,nullable,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter);1533557519;Take a {@code String} that is a delimited list and convert it into a_{@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String} (potentially {@code null} or empty)_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,potentially,code,null,or,empty,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,nullable,string,str,nullable,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter);1533602820;Take a {@code String} that is a delimited list and convert it into a_{@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String} (potentially {@code null} or empty)_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,potentially,code,null,or,empty,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,nullable,string,str,nullable,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter);1535316501;Take a {@code String} that is a delimited list and convert it into a_{@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String} (potentially {@code null} or empty)_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,potentially,code,null,or,empty,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,nullable,string,str,nullable,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter);1550237113;Take a {@code String} that is a delimited list and convert it into a_{@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String} (potentially {@code null} or empty)_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,potentially,code,null,or,empty,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,nullable,string,str,nullable,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter);1550238935;Take a {@code String} that is a delimited list and convert it into a_{@code String} array._<p>A single {@code delimiter} may consist of more than one character,_but it will still be considered as a single delimiter string, rather_than as bunch of potential delimiter characters, in contrast to_{@link #tokenizeToStringArray}._@param str the input {@code String} (potentially {@code null} or empty)_@param delimiter the delimiter between elements (this is a single delimiter,_rather than a bunch individual delimiter characters)_@return an array of the tokens in the list_@see #tokenizeToStringArray;public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter) {_		return delimitedListToStringArray(str, delimiter, null)__	};take,a,code,string,that,is,a,delimited,list,and,convert,it,into,a,code,string,array,p,a,single,code,delimiter,may,consist,of,more,than,one,character,but,it,will,still,be,considered,as,a,single,delimiter,string,rather,than,as,bunch,of,potential,delimiter,characters,in,contrast,to,link,tokenize,to,string,array,param,str,the,input,code,string,potentially,code,null,or,empty,param,delimiter,the,delimiter,between,elements,this,is,a,single,delimiter,rather,than,a,bunch,individual,delimiter,characters,return,an,array,of,the,tokens,in,the,list,see,tokenize,to,string,array;public,static,string,delimited,list,to,string,array,nullable,string,str,nullable,string,delimiter,return,delimited,list,to,string,array,str,delimiter,null
StringUtils -> public static String unqualify(String qualifiedName);1328020251;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1337236962;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1356735495;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1367955086;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1380921248;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1382750743;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1385423968;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1400189212;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1400531359;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1402676350;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1426267150;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1429034538;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1429034756;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1431006895;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1431007368;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1449489126;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1467730834;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1472128018;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1472202842;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1473942665;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1484248946;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1484260238;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1484694546;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1487760984;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1487778834;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1491898314;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1491903650;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1495868221;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1496243689;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1496259743;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1496837955;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1499270197;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1508667152;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1508675477;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1508843807;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1516903831;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1519295386;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1519308837;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1519588127;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1522332352;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1525166194;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1530188116;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1531843079;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1531905026;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1533557519;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1533602820;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1535316501;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1550237113;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String unqualify(String qualifiedName);1550238935;Unqualify a string qualified by a '.' dot character. For example,_"this.name.is.qualified", returns "qualified"._@param qualifiedName the qualified name;public static String unqualify(String qualifiedName) {_		return unqualify(qualifiedName, '.')__	};unqualify,a,string,qualified,by,a,dot,character,for,example,this,name,is,qualified,returns,qualified,param,qualified,name,the,qualified,name;public,static,string,unqualify,string,qualified,name,return,unqualify,qualified,name
StringUtils -> public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim);1496837955;Convert a {@code Collection} into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,nullable,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim);1499270197;Convert a {@code Collection} into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,nullable,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim);1508667152;Convert a {@code Collection} into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,nullable,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim);1508675477;Convert a {@code Collection} into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,nullable,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim);1508843807;Convert a {@code Collection} into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,nullable,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim);1516903831;Convert a {@code Collection} into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,nullable,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim);1519295386;Convert a {@code Collection} into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,nullable,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim);1519308837;Convert a {@code Collection} into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,nullable,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim);1519588127;Convert a {@code Collection} into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,nullable,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim);1522332352;Convert a {@code Collection} into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,nullable,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim);1525166194;Convert a {@code Collection} into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,nullable,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim);1530188116;Convert a {@code Collection} into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,nullable,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim);1531843079;Convert a {@code Collection} into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,nullable,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim);1531905026;Convert a {@code Collection} into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,nullable,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim);1533557519;Convert a {@code Collection} into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert (potentially {@code null} or empty)_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,potentially,code,null,or,empty,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,nullable,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim);1533602820;Convert a {@code Collection} into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert (potentially {@code null} or empty)_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,potentially,code,null,or,empty,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,nullable,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim);1535316501;Convert a {@code Collection} into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert (potentially {@code null} or empty)_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,potentially,code,null,or,empty,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,nullable,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim);1550237113;Convert a {@code Collection} into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert (potentially {@code null} or empty)_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,potentially,code,null,or,empty,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,nullable,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
StringUtils -> public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim);1550238935;Convert a {@code Collection} into a delimited {@code String} (e.g. CSV)._<p>Useful for {@code toString()} implementations._@param coll the {@code Collection} to convert (potentially {@code null} or empty)_@param delim the delimiter to use (typically a ",")_@return the delimited {@code String};public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim) {_		return collectionToDelimitedString(coll, delim, "", "")__	};convert,a,code,collection,into,a,delimited,code,string,e,g,csv,p,useful,for,code,to,string,implementations,param,coll,the,code,collection,to,convert,potentially,code,null,or,empty,param,delim,the,delimiter,to,use,typically,a,return,the,delimited,code,string;public,static,string,collection,to,delimited,string,nullable,collection,coll,string,delim,return,collection,to,delimited,string,coll,delim
