commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Specify an external factory to use for creating new Threads,  * instead of relying on the local properties of this executor.  * <p>You may specify an inner ThreadFactory bean or also a ThreadFactory reference  * obtained from JNDI (on a Java EE 6 server) or some other lookup mechanism.  * @see #setThreadNamePrefix  * @see #setThreadPriority  */ ;/**  * Specify an external factory to use for creating new Threads,  * instead of relying on the local properties of this executor.  * <p>You may specify an inner ThreadFactory bean or also a ThreadFactory reference  * obtained from JNDI (on a Java EE 6 server) or some other lookup mechanism.  * @see #setThreadNamePrefix  * @see #setThreadPriority  */ public void setThreadFactory(@Nullable ThreadFactory threadFactory) {     this.threadFactory = threadFactory. }
true;public,final;0;4;/**  * Return the external factory to use for creating new Threads, if any.  */ ;/**  * Return the external factory to use for creating new Threads, if any.  */ @Nullable public final ThreadFactory getThreadFactory() {     return this.threadFactory. }
true;public,final;1;3;/**  * Specify a custom {@link TaskDecorator} to be applied to any {@link Runnable}  * about to be executed.  * <p>Note that such a decorator is not necessarily being applied to the  * user-supplied {@code Runnable}/{@code Callable} but rather to the actual  * execution callback (which may be a wrapper around the user-supplied task).  * <p>The primary use case is to set some execution context around the task's  * invocation, or to provide some monitoring/statistics for task execution.  * @since 4.3  */ ;/**  * Specify a custom {@link TaskDecorator} to be applied to any {@link Runnable}  * about to be executed.  * <p>Note that such a decorator is not necessarily being applied to the  * user-supplied {@code Runnable}/{@code Callable} but rather to the actual  * execution callback (which may be a wrapper around the user-supplied task).  * <p>The primary use case is to set some execution context around the task's  * invocation, or to provide some monitoring/statistics for task execution.  * @since 4.3  */ public final void setTaskDecorator(TaskDecorator taskDecorator) {     this.taskDecorator = taskDecorator. }
true;public;1;3;/**  * Set the maximum number of parallel accesses allowed.  * -1 indicates no concurrency limit at all.  * <p>In principle, this limit can be changed at runtime,  * although it is generally designed as a config time setting.  * NOTE: Do not switch between -1 and any concrete limit at runtime,  * as this will lead to inconsistent concurrency counts: A limit  * of -1 effectively turns off concurrency counting completely.  * @see #UNBOUNDED_CONCURRENCY  */ ;/**  * Set the maximum number of parallel accesses allowed.  * -1 indicates no concurrency limit at all.  * <p>In principle, this limit can be changed at runtime,  * although it is generally designed as a config time setting.  * NOTE: Do not switch between -1 and any concrete limit at runtime,  * as this will lead to inconsistent concurrency counts: A limit  * of -1 effectively turns off concurrency counting completely.  * @see #UNBOUNDED_CONCURRENCY  */ public void setConcurrencyLimit(int concurrencyLimit) {     this.concurrencyThrottle.setConcurrencyLimit(concurrencyLimit). }
true;public,final;0;3;/**  * Return the maximum number of parallel accesses allowed.  */ ;/**  * Return the maximum number of parallel accesses allowed.  */ public final int getConcurrencyLimit() {     return this.concurrencyThrottle.getConcurrencyLimit(). }
true;public,final;0;3;/**  * Return whether this throttle is currently active.  * @return {@code true} if the concurrency limit for this instance is active  * @see #getConcurrencyLimit()  * @see #setConcurrencyLimit  */ ;/**  * Return whether this throttle is currently active.  * @return {@code true} if the concurrency limit for this instance is active  * @see #getConcurrencyLimit()  * @see #setConcurrencyLimit  */ public final boolean isThrottleActive() {     return this.concurrencyThrottle.isThrottleActive(). }
true;public;1;4;/**  * Executes the given task, within a concurrency throttle  * if configured (through the superclass's settings).  * @see #doExecute(Runnable)  */ ;/**  * Executes the given task, within a concurrency throttle  * if configured (through the superclass's settings).  * @see #doExecute(Runnable)  */ @Override public void execute(Runnable task) {     execute(task, TIMEOUT_INDEFINITE). }
true;public;2;12;/**  * Executes the given task, within a concurrency throttle  * if configured (through the superclass's settings).  * <p>Executes urgent tasks (with 'immediate' timeout) directly,  * bypassing the concurrency throttle (if active). All other  * tasks are subject to throttling.  * @see #TIMEOUT_IMMEDIATE  * @see #doExecute(Runnable)  */ ;/**  * Executes the given task, within a concurrency throttle  * if configured (through the superclass's settings).  * <p>Executes urgent tasks (with 'immediate' timeout) directly,  * bypassing the concurrency throttle (if active). All other  * tasks are subject to throttling.  * @see #TIMEOUT_IMMEDIATE  * @see #doExecute(Runnable)  */ @Override public void execute(Runnable task, long startTimeout) {     Assert.notNull(task, "Runnable must not be null").     Runnable taskToUse = (this.taskDecorator != null ? this.taskDecorator.decorate(task) : task).     if (isThrottleActive() && startTimeout > TIMEOUT_IMMEDIATE) {         this.concurrencyThrottle.beforeAccess().         doExecute(new ConcurrencyThrottlingRunnable(taskToUse)).     } else {         doExecute(taskToUse).     } }
false;public;1;6;;@Override public Future<?> submit(Runnable task) {     FutureTask<Object> future = new FutureTask<>(task, null).     execute(future, TIMEOUT_INDEFINITE).     return future. }
false;public;1;6;;@Override public <T> Future<T> submit(Callable<T> task) {     FutureTask<T> future = new FutureTask<>(task).     execute(future, TIMEOUT_INDEFINITE).     return future. }
false;public;1;6;;@Override public ListenableFuture<?> submitListenable(Runnable task) {     ListenableFutureTask<Object> future = new ListenableFutureTask<>(task, null).     execute(future, TIMEOUT_INDEFINITE).     return future. }
false;public;1;6;;@Override public <T> ListenableFuture<T> submitListenable(Callable<T> task) {     ListenableFutureTask<T> future = new ListenableFutureTask<>(task).     execute(future, TIMEOUT_INDEFINITE).     return future. }
true;protected;1;4;/**  * Template method for the actual execution of a task.  * <p>The default implementation creates a new Thread and starts it.  * @param task the Runnable to execute  * @see #setThreadFactory  * @see #createThread  * @see java.lang.Thread#start()  */ ;/**  * Template method for the actual execution of a task.  * <p>The default implementation creates a new Thread and starts it.  * @param task the Runnable to execute  * @see #setThreadFactory  * @see #createThread  * @see java.lang.Thread#start()  */ protected void doExecute(Runnable task) {     Thread thread = (this.threadFactory != null ? this.threadFactory.newThread(task) : createThread(task)).     thread.start(). }
false;protected;0;4;;@Override protected void beforeAccess() {     super.beforeAccess(). }
false;protected;0;4;;@Override protected void afterAccess() {     super.afterAccess(). }
false;public;0;9;;@Override public void run() {     try {         this.target.run().     } finally {         concurrencyThrottle.afterAccess().     } }
