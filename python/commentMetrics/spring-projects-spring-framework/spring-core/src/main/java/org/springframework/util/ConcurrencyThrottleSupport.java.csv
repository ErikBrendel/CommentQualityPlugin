commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the maximum number of concurrent access attempts allowed.  * -1 indicates unbounded concurrency.  * <p>In principle, this limit can be changed at runtime,  * although it is generally designed as a config time setting.  * <p>NOTE: Do not switch between -1 and any concrete limit at runtime,  * as this will lead to inconsistent concurrency counts: A limit  * of -1 effectively turns off concurrency counting completely.  */ ;/**  * Set the maximum number of concurrent access attempts allowed.  * -1 indicates unbounded concurrency.  * <p>In principle, this limit can be changed at runtime,  * although it is generally designed as a config time setting.  * <p>NOTE: Do not switch between -1 and any concrete limit at runtime,  * as this will lead to inconsistent concurrency counts: A limit  * of -1 effectively turns off concurrency counting completely.  */ public void setConcurrencyLimit(int concurrencyLimit) {     this.concurrencyLimit = concurrencyLimit. }
true;public;0;3;/**  * Return the maximum number of concurrent access attempts allowed.  */ ;/**  * Return the maximum number of concurrent access attempts allowed.  */ public int getConcurrencyLimit() {     return this.concurrencyLimit. }
true;public;0;3;/**  * Return whether this throttle is currently active.  * @return {@code true} if the concurrency limit for this instance is active  * @see #getConcurrencyLimit()  */ ;/**  * Return whether this throttle is currently active.  * @return {@code true} if the concurrency limit for this instance is active  * @see #getConcurrencyLimit()  */ public boolean isThrottleActive() {     return (this.concurrencyLimit >= 0). }
true;protected;0;34;/**  * To be invoked before the main execution logic of concrete subclasses.  * <p>This implementation applies the concurrency throttle.  * @see #afterAccess()  */ ;/**  * To be invoked before the main execution logic of concrete subclasses.  * <p>This implementation applies the concurrency throttle.  * @see #afterAccess()  */ protected void beforeAccess() {     if (this.concurrencyLimit == NO_CONCURRENCY) {         throw new IllegalStateException("Currently no invocations allowed - concurrency limit set to NO_CONCURRENCY").     }     if (this.concurrencyLimit > 0) {         boolean debug = logger.isDebugEnabled().         synchronized (this.monitor) {             boolean interrupted = false.             while (this.concurrencyCount >= this.concurrencyLimit) {                 if (interrupted) {                     throw new IllegalStateException("Thread was interrupted while waiting for invocation access, " + "but concurrency limit still does not allow for entering").                 }                 if (debug) {                     logger.debug("Concurrency count " + this.concurrencyCount + " has reached limit " + this.concurrencyLimit + " - blocking").                 }                 try {                     this.monitor.wait().                 } catch (InterruptedException ex) {                     // Re-interrupt current thread, to allow other threads to react.                     Thread.currentThread().interrupt().                     interrupted = true.                 }             }             if (debug) {                 logger.debug("Entering throttle at concurrency count " + this.concurrencyCount).             }             this.concurrencyCount++.         }     } }
true;protected;0;11;/**  * To be invoked after the main execution logic of concrete subclasses.  * @see #beforeAccess()  */ ;/**  * To be invoked after the main execution logic of concrete subclasses.  * @see #beforeAccess()  */ protected void afterAccess() {     if (this.concurrencyLimit >= 0) {         synchronized (this.monitor) {             this.concurrencyCount--.             if (logger.isDebugEnabled()) {                 logger.debug("Returning from throttle at concurrency count " + this.concurrencyCount).             }             this.monitor.notify().         }     } }
false;private;1;8;;// --------------------------------------------------------------------- // Serialization support // --------------------------------------------------------------------- private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {     // Rely on default serialization, just initialize state after deserialization.     ois.defaultReadObject().     // Initialize transient fields.     this.logger = LogFactory.getLog(getClass()).     this.monitor = new Object(). }
