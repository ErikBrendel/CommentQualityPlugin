commented;modifiers;parameterAmount;loc;comment;code
false;public;2;5;;@Override public boolean canDecode(ResolvableType elementType, @Nullable MimeType mimeType) {     return (Resource.class.isAssignableFrom(elementType.toClass()) && super.canDecode(elementType, mimeType)). }
false;public;4;6;;@Override public Flux<Resource> decode(Publisher<DataBuffer> inputStream, ResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {     return Flux.from(decodeToMono(inputStream, elementType, mimeType, hints)). }
false;protected;4;23;;@Override protected Resource decodeDataBuffer(DataBuffer dataBuffer, ResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {     byte[] bytes = new byte[dataBuffer.readableByteCount()].     dataBuffer.read(bytes).     DataBufferUtils.release(dataBuffer).     if (logger.isDebugEnabled()) {         logger.debug(Hints.getLogPrefix(hints) + "Read " + bytes.length + " bytes").     }     Class<?> clazz = elementType.toClass().     if (clazz == InputStreamResource.class) {         return new InputStreamResource(new ByteArrayInputStream(bytes)).     } else if (Resource.class.isAssignableFrom(clazz)) {         return new ByteArrayResource(bytes).     } else {         throw new IllegalStateException("Unsupported resource class: " + clazz).     } }
