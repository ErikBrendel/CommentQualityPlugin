# id;timestamp;commentText;codeText;commentWords;codeWords
MimeTypeUtils -> public static void sortBySpecificity(List<MimeType> mimeTypes);1375896097;Sorts the given list of {@code MimeType} objects by specificity._<p>_Given two mime types:_<ol>_<li>if either mime type has a {@linkplain #isWildcardType() wildcard type}, then_the mime type without the wildcard is ordered before the other.</li>_<li>if the two mime types have different {@linkplain #getType() types}, then_they are considered equal and remain their current order.</li>_<li>if either mime type has a {@linkplain #isWildcardSubtype() wildcard subtype}_, then the mime type without the wildcard is sorted before the other.</li>_<li>if the two mime types have different {@linkplain #getSubtype() subtypes},_then they are considered equal and remain their current order.</li>_<li>if the two mime types have a different amount of_{@linkplain #getParameter(String) parameters}, then the mime type with the most_parameters is ordered before the other.</li>_</ol>_<p>_For example: <blockquote>audio/basic &lt_ audio/* &lt_ *&#047_*</blockquote>_<blockquote>audio/basic_level=1 &lt_ audio/basic</blockquote>_<blockquote>audio/basic == text/html</blockquote> <blockquote>audio/basic ==_audio/wave</blockquote>__@param mimeTypes the list of mime types to be sorted_@see <a href="http://tools.ietf.org/html/rfc2616#section-14.1">HTTP 1.1, section_14.1</a>;public static void sortBySpecificity(List<MimeType> mimeTypes) {_		Assert.notNull(mimeTypes, "'mimeTypes' must not be null")__		if (mimeTypes.size() > 1) {_			Collections.sort(mimeTypes, SPECIFICITY_COMPARATOR)__		}_	};sorts,the,given,list,of,code,mime,type,objects,by,specificity,p,given,two,mime,types,ol,li,if,either,mime,type,has,a,linkplain,is,wildcard,type,wildcard,type,then,the,mime,type,without,the,wildcard,is,ordered,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,get,type,types,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,either,mime,type,has,a,linkplain,is,wildcard,subtype,wildcard,subtype,then,the,mime,type,without,the,wildcard,is,sorted,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,get,subtype,subtypes,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,the,two,mime,types,have,a,different,amount,of,linkplain,get,parameter,string,parameters,then,the,mime,type,with,the,most,parameters,is,ordered,before,the,other,li,ol,p,for,example,blockquote,audio,basic,lt,audio,lt,047,blockquote,blockquote,audio,basic,level,1,lt,audio,basic,blockquote,blockquote,audio,basic,text,html,blockquote,blockquote,audio,basic,audio,wave,blockquote,param,mime,types,the,list,of,mime,types,to,be,sorted,see,a,href,http,tools,ietf,org,html,rfc2616,section,14,1,http,1,1,section,14,1,a;public,static,void,sort,by,specificity,list,mime,type,mime,types,assert,not,null,mime,types,mime,types,must,not,be,null,if,mime,types,size,1,collections,sort,mime,types
MimeTypeUtils -> public static void sortBySpecificity(List<MimeType> mimeTypes);1385501137;Sorts the given list of {@code MimeType} objects by specificity._<p>_Given two mime types:_<ol>_<li>if either mime type has a {@linkplain MimeType#isWildcardType() wildcard type},_then the mime type without the wildcard is ordered before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getType() types},_then they are considered equal and remain their current order.</li>_<li>if either mime type has a {@linkplain MimeType#isWildcardSubtype() wildcard subtype}_, then the mime type without the wildcard is sorted before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getSubtype() subtypes},_then they are considered equal and remain their current order.</li>_<li>if the two mime types have a different amount of_{@linkplain MimeType#getParameter(String) parameters}, then the mime type with the most_parameters is ordered before the other.</li>_</ol>_<p>_For example: <blockquote>audio/basic &lt_ audio/* &lt_ *&#047_*</blockquote>_<blockquote>audio/basic_level=1 &lt_ audio/basic</blockquote>_<blockquote>audio/basic == text/html</blockquote> <blockquote>audio/basic ==_audio/wave</blockquote>__@param mimeTypes the list of mime types to be sorted_@see <a href="http://tools.ietf.org/html/rfc2616#section-14.1">HTTP 1.1, section_14.1</a>;public static void sortBySpecificity(List<MimeType> mimeTypes) {_		Assert.notNull(mimeTypes, "'mimeTypes' must not be null")__		if (mimeTypes.size() > 1) {_			Collections.sort(mimeTypes, SPECIFICITY_COMPARATOR)__		}_	};sorts,the,given,list,of,code,mime,type,objects,by,specificity,p,given,two,mime,types,ol,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,type,wildcard,type,then,the,mime,type,without,the,wildcard,is,ordered,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,type,types,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,subtype,wildcard,subtype,then,the,mime,type,without,the,wildcard,is,sorted,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,subtype,subtypes,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,the,two,mime,types,have,a,different,amount,of,linkplain,mime,type,get,parameter,string,parameters,then,the,mime,type,with,the,most,parameters,is,ordered,before,the,other,li,ol,p,for,example,blockquote,audio,basic,lt,audio,lt,047,blockquote,blockquote,audio,basic,level,1,lt,audio,basic,blockquote,blockquote,audio,basic,text,html,blockquote,blockquote,audio,basic,audio,wave,blockquote,param,mime,types,the,list,of,mime,types,to,be,sorted,see,a,href,http,tools,ietf,org,html,rfc2616,section,14,1,http,1,1,section,14,1,a;public,static,void,sort,by,specificity,list,mime,type,mime,types,assert,not,null,mime,types,mime,types,must,not,be,null,if,mime,types,size,1,collections,sort,mime,types
MimeTypeUtils -> public static void sortBySpecificity(List<MimeType> mimeTypes);1385507478;Sorts the given list of {@code MimeType} objects by specificity._<p>Given two mime types:_<ol>_<li>if either mime type has a {@linkplain MimeType#isWildcardType() wildcard type},_then the mime type without the wildcard is ordered before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getType() types},_then they are considered equal and remain their current order.</li>_<li>if either mime type has a {@linkplain MimeType#isWildcardSubtype() wildcard subtype}_, then the mime type without the wildcard is sorted before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getSubtype() subtypes},_then they are considered equal and remain their current order.</li>_<li>if the two mime types have a different amount of_{@linkplain MimeType#getParameter(String) parameters}, then the mime type with the most_parameters is ordered before the other.</li>_</ol>_<p>For example: <blockquote>audio/basic &lt_ audio/* &lt_ *&#047_*</blockquote>_<blockquote>audio/basic_level=1 &lt_ audio/basic</blockquote>_<blockquote>audio/basic == text/html</blockquote> <blockquote>audio/basic ==_audio/wave</blockquote>_@param mimeTypes the list of mime types to be sorted_@see <a href="http://tools.ietf.org/html/rfc2616#section-14.1">HTTP 1.1, section_14.1</a>;public static void sortBySpecificity(List<MimeType> mimeTypes) {_		Assert.notNull(mimeTypes, "'mimeTypes' must not be null")__		if (mimeTypes.size() > 1) {_			Collections.sort(mimeTypes, SPECIFICITY_COMPARATOR)__		}_	};sorts,the,given,list,of,code,mime,type,objects,by,specificity,p,given,two,mime,types,ol,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,type,wildcard,type,then,the,mime,type,without,the,wildcard,is,ordered,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,type,types,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,subtype,wildcard,subtype,then,the,mime,type,without,the,wildcard,is,sorted,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,subtype,subtypes,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,the,two,mime,types,have,a,different,amount,of,linkplain,mime,type,get,parameter,string,parameters,then,the,mime,type,with,the,most,parameters,is,ordered,before,the,other,li,ol,p,for,example,blockquote,audio,basic,lt,audio,lt,047,blockquote,blockquote,audio,basic,level,1,lt,audio,basic,blockquote,blockquote,audio,basic,text,html,blockquote,blockquote,audio,basic,audio,wave,blockquote,param,mime,types,the,list,of,mime,types,to,be,sorted,see,a,href,http,tools,ietf,org,html,rfc2616,section,14,1,http,1,1,section,14,1,a;public,static,void,sort,by,specificity,list,mime,type,mime,types,assert,not,null,mime,types,mime,types,must,not,be,null,if,mime,types,size,1,collections,sort,mime,types
MimeTypeUtils -> public static void sortBySpecificity(List<MimeType> mimeTypes);1407415845;Sorts the given list of {@code MimeType} objects by specificity._<p>Given two mime types:_<ol>_<li>if either mime type has a {@linkplain MimeType#isWildcardType() wildcard type},_then the mime type without the wildcard is ordered before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getType() types},_then they are considered equal and remain their current order.</li>_<li>if either mime type has a {@linkplain MimeType#isWildcardSubtype() wildcard subtype}_, then the mime type without the wildcard is sorted before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getSubtype() subtypes},_then they are considered equal and remain their current order.</li>_<li>if the two mime types have a different amount of_{@linkplain MimeType#getParameter(String) parameters}, then the mime type with the most_parameters is ordered before the other.</li>_</ol>_<p>For example: <blockquote>audio/basic &lt_ audio/* &lt_ *&#047_*</blockquote>_<blockquote>audio/basic_level=1 &lt_ audio/basic</blockquote>_<blockquote>audio/basic == text/html</blockquote> <blockquote>audio/basic ==_audio/wave</blockquote>_@param mimeTypes the list of mime types to be sorted_@see <a href="http://tools.ietf.org/html/rfc7231#section-5.3.2">HTTP 1.1: Semantics_and Content, section 5.3.2</a>;public static void sortBySpecificity(List<MimeType> mimeTypes) {_		Assert.notNull(mimeTypes, "'mimeTypes' must not be null")__		if (mimeTypes.size() > 1) {_			Collections.sort(mimeTypes, SPECIFICITY_COMPARATOR)__		}_	};sorts,the,given,list,of,code,mime,type,objects,by,specificity,p,given,two,mime,types,ol,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,type,wildcard,type,then,the,mime,type,without,the,wildcard,is,ordered,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,type,types,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,subtype,wildcard,subtype,then,the,mime,type,without,the,wildcard,is,sorted,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,subtype,subtypes,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,the,two,mime,types,have,a,different,amount,of,linkplain,mime,type,get,parameter,string,parameters,then,the,mime,type,with,the,most,parameters,is,ordered,before,the,other,li,ol,p,for,example,blockquote,audio,basic,lt,audio,lt,047,blockquote,blockquote,audio,basic,level,1,lt,audio,basic,blockquote,blockquote,audio,basic,text,html,blockquote,blockquote,audio,basic,audio,wave,blockquote,param,mime,types,the,list,of,mime,types,to,be,sorted,see,a,href,http,tools,ietf,org,html,rfc7231,section,5,3,2,http,1,1,semantics,and,content,section,5,3,2,a;public,static,void,sort,by,specificity,list,mime,type,mime,types,assert,not,null,mime,types,mime,types,must,not,be,null,if,mime,types,size,1,collections,sort,mime,types
MimeTypeUtils -> public static void sortBySpecificity(List<MimeType> mimeTypes);1413848647;Sorts the given list of {@code MimeType} objects by specificity._<p>Given two mime types:_<ol>_<li>if either mime type has a {@linkplain MimeType#isWildcardType() wildcard type},_then the mime type without the wildcard is ordered before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getType() types},_then they are considered equal and remain their current order.</li>_<li>if either mime type has a {@linkplain MimeType#isWildcardSubtype() wildcard subtype}_, then the mime type without the wildcard is sorted before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getSubtype() subtypes},_then they are considered equal and remain their current order.</li>_<li>if the two mime types have a different amount of_{@linkplain MimeType#getParameter(String) parameters}, then the mime type with the most_parameters is ordered before the other.</li>_</ol>_<p>For example: <blockquote>audio/basic &lt_ audio/* &lt_ *&#047_*</blockquote>_<blockquote>audio/basic_level=1 &lt_ audio/basic</blockquote>_<blockquote>audio/basic == text/html</blockquote> <blockquote>audio/basic ==_audio/wave</blockquote>_@param mimeTypes the list of mime types to be sorted_@see <a href="http://tools.ietf.org/html/rfc7231#section-5.3.2">HTTP 1.1: Semantics_and Content, section 5.3.2</a>;public static void sortBySpecificity(List<MimeType> mimeTypes) {_		Assert.notNull(mimeTypes, "'mimeTypes' must not be null")__		if (mimeTypes.size() > 1) {_			Collections.sort(mimeTypes, SPECIFICITY_COMPARATOR)__		}_	};sorts,the,given,list,of,code,mime,type,objects,by,specificity,p,given,two,mime,types,ol,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,type,wildcard,type,then,the,mime,type,without,the,wildcard,is,ordered,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,type,types,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,subtype,wildcard,subtype,then,the,mime,type,without,the,wildcard,is,sorted,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,subtype,subtypes,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,the,two,mime,types,have,a,different,amount,of,linkplain,mime,type,get,parameter,string,parameters,then,the,mime,type,with,the,most,parameters,is,ordered,before,the,other,li,ol,p,for,example,blockquote,audio,basic,lt,audio,lt,047,blockquote,blockquote,audio,basic,level,1,lt,audio,basic,blockquote,blockquote,audio,basic,text,html,blockquote,blockquote,audio,basic,audio,wave,blockquote,param,mime,types,the,list,of,mime,types,to,be,sorted,see,a,href,http,tools,ietf,org,html,rfc7231,section,5,3,2,http,1,1,semantics,and,content,section,5,3,2,a;public,static,void,sort,by,specificity,list,mime,type,mime,types,assert,not,null,mime,types,mime,types,must,not,be,null,if,mime,types,size,1,collections,sort,mime,types
MimeTypeUtils -> public static void sortBySpecificity(List<MimeType> mimeTypes);1426880143;Sorts the given list of {@code MimeType} objects by specificity._<p>Given two mime types:_<ol>_<li>if either mime type has a {@linkplain MimeType#isWildcardType() wildcard type},_then the mime type without the wildcard is ordered before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getType() types},_then they are considered equal and remain their current order.</li>_<li>if either mime type has a {@linkplain MimeType#isWildcardSubtype() wildcard subtype}_, then the mime type without the wildcard is sorted before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getSubtype() subtypes},_then they are considered equal and remain their current order.</li>_<li>if the two mime types have a different amount of_{@linkplain MimeType#getParameter(String) parameters}, then the mime type with the most_parameters is ordered before the other.</li>_</ol>_<p>For example: <blockquote>audio/basic &lt_ audio/* &lt_ *&#047_*</blockquote>_<blockquote>audio/basic_level=1 &lt_ audio/basic</blockquote>_<blockquote>audio/basic == text/html</blockquote> <blockquote>audio/basic ==_audio/wave</blockquote>_@param mimeTypes the list of mime types to be sorted_@see <a href="http://tools.ietf.org/html/rfc7231#section-5.3.2">HTTP 1.1: Semantics_and Content, section 5.3.2</a>;public static void sortBySpecificity(List<MimeType> mimeTypes) {_		Assert.notNull(mimeTypes, "'mimeTypes' must not be null")__		if (mimeTypes.size() > 1) {_			Collections.sort(mimeTypes, SPECIFICITY_COMPARATOR)__		}_	};sorts,the,given,list,of,code,mime,type,objects,by,specificity,p,given,two,mime,types,ol,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,type,wildcard,type,then,the,mime,type,without,the,wildcard,is,ordered,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,type,types,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,subtype,wildcard,subtype,then,the,mime,type,without,the,wildcard,is,sorted,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,subtype,subtypes,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,the,two,mime,types,have,a,different,amount,of,linkplain,mime,type,get,parameter,string,parameters,then,the,mime,type,with,the,most,parameters,is,ordered,before,the,other,li,ol,p,for,example,blockquote,audio,basic,lt,audio,lt,047,blockquote,blockquote,audio,basic,level,1,lt,audio,basic,blockquote,blockquote,audio,basic,text,html,blockquote,blockquote,audio,basic,audio,wave,blockquote,param,mime,types,the,list,of,mime,types,to,be,sorted,see,a,href,http,tools,ietf,org,html,rfc7231,section,5,3,2,http,1,1,semantics,and,content,section,5,3,2,a;public,static,void,sort,by,specificity,list,mime,type,mime,types,assert,not,null,mime,types,mime,types,must,not,be,null,if,mime,types,size,1,collections,sort,mime,types
MimeTypeUtils -> public static void sortBySpecificity(List<MimeType> mimeTypes);1460988078;Sorts the given list of {@code MimeType} objects by specificity._<p>Given two mime types:_<ol>_<li>if either mime type has a {@linkplain MimeType#isWildcardType() wildcard type},_then the mime type without the wildcard is ordered before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getType() types},_then they are considered equal and remain their current order.</li>_<li>if either mime type has a {@linkplain MimeType#isWildcardSubtype() wildcard subtype}_, then the mime type without the wildcard is sorted before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getSubtype() subtypes},_then they are considered equal and remain their current order.</li>_<li>if the two mime types have a different amount of_{@linkplain MimeType#getParameter(String) parameters}, then the mime type with the most_parameters is ordered before the other.</li>_</ol>_<p>For example: <blockquote>audio/basic &lt_ audio/* &lt_ *&#047_*</blockquote>_<blockquote>audio/basic_level=1 &lt_ audio/basic</blockquote>_<blockquote>audio/basic == text/html</blockquote> <blockquote>audio/basic ==_audio/wave</blockquote>_@param mimeTypes the list of mime types to be sorted_@see <a href="http://tools.ietf.org/html/rfc7231#section-5.3.2">HTTP 1.1: Semantics_and Content, section 5.3.2</a>;public static void sortBySpecificity(List<MimeType> mimeTypes) {_		Assert.notNull(mimeTypes, "'mimeTypes' must not be null")__		if (mimeTypes.size() > 1) {_			Collections.sort(mimeTypes, SPECIFICITY_COMPARATOR)__		}_	};sorts,the,given,list,of,code,mime,type,objects,by,specificity,p,given,two,mime,types,ol,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,type,wildcard,type,then,the,mime,type,without,the,wildcard,is,ordered,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,type,types,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,subtype,wildcard,subtype,then,the,mime,type,without,the,wildcard,is,sorted,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,subtype,subtypes,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,the,two,mime,types,have,a,different,amount,of,linkplain,mime,type,get,parameter,string,parameters,then,the,mime,type,with,the,most,parameters,is,ordered,before,the,other,li,ol,p,for,example,blockquote,audio,basic,lt,audio,lt,047,blockquote,blockquote,audio,basic,level,1,lt,audio,basic,blockquote,blockquote,audio,basic,text,html,blockquote,blockquote,audio,basic,audio,wave,blockquote,param,mime,types,the,list,of,mime,types,to,be,sorted,see,a,href,http,tools,ietf,org,html,rfc7231,section,5,3,2,http,1,1,semantics,and,content,section,5,3,2,a;public,static,void,sort,by,specificity,list,mime,type,mime,types,assert,not,null,mime,types,mime,types,must,not,be,null,if,mime,types,size,1,collections,sort,mime,types
MimeTypeUtils -> public static void sortBySpecificity(List<MimeType> mimeTypes);1467730834;Sorts the given list of {@code MimeType} objects by specificity._<p>Given two mime types:_<ol>_<li>if either mime type has a {@linkplain MimeType#isWildcardType() wildcard type},_then the mime type without the wildcard is ordered before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getType() types},_then they are considered equal and remain their current order.</li>_<li>if either mime type has a {@linkplain MimeType#isWildcardSubtype() wildcard subtype}_, then the mime type without the wildcard is sorted before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getSubtype() subtypes},_then they are considered equal and remain their current order.</li>_<li>if the two mime types have a different amount of_{@linkplain MimeType#getParameter(String) parameters}, then the mime type with the most_parameters is ordered before the other.</li>_</ol>_<p>For example: <blockquote>audio/basic &lt_ audio/* &lt_ *&#047_*</blockquote>_<blockquote>audio/basic_level=1 &lt_ audio/basic</blockquote>_<blockquote>audio/basic == text/html</blockquote> <blockquote>audio/basic ==_audio/wave</blockquote>_@param mimeTypes the list of mime types to be sorted_@see <a href="http://tools.ietf.org/html/rfc7231#section-5.3.2">HTTP 1.1: Semantics_and Content, section 5.3.2</a>;public static void sortBySpecificity(List<MimeType> mimeTypes) {_		Assert.notNull(mimeTypes, "'mimeTypes' must not be null")__		if (mimeTypes.size() > 1) {_			Collections.sort(mimeTypes, SPECIFICITY_COMPARATOR)__		}_	};sorts,the,given,list,of,code,mime,type,objects,by,specificity,p,given,two,mime,types,ol,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,type,wildcard,type,then,the,mime,type,without,the,wildcard,is,ordered,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,type,types,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,subtype,wildcard,subtype,then,the,mime,type,without,the,wildcard,is,sorted,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,subtype,subtypes,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,the,two,mime,types,have,a,different,amount,of,linkplain,mime,type,get,parameter,string,parameters,then,the,mime,type,with,the,most,parameters,is,ordered,before,the,other,li,ol,p,for,example,blockquote,audio,basic,lt,audio,lt,047,blockquote,blockquote,audio,basic,level,1,lt,audio,basic,blockquote,blockquote,audio,basic,text,html,blockquote,blockquote,audio,basic,audio,wave,blockquote,param,mime,types,the,list,of,mime,types,to,be,sorted,see,a,href,http,tools,ietf,org,html,rfc7231,section,5,3,2,http,1,1,semantics,and,content,section,5,3,2,a;public,static,void,sort,by,specificity,list,mime,type,mime,types,assert,not,null,mime,types,mime,types,must,not,be,null,if,mime,types,size,1,collections,sort,mime,types
MimeTypeUtils -> public static void sortBySpecificity(List<MimeType> mimeTypes);1468513830;Sorts the given list of {@code MimeType} objects by specificity._<p>Given two mime types:_<ol>_<li>if either mime type has a {@linkplain MimeType#isWildcardType() wildcard type},_then the mime type without the wildcard is ordered before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getType() types},_then they are considered equal and remain their current order.</li>_<li>if either mime type has a {@linkplain MimeType#isWildcardSubtype() wildcard subtype}_, then the mime type without the wildcard is sorted before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getSubtype() subtypes},_then they are considered equal and remain their current order.</li>_<li>if the two mime types have a different amount of_{@linkplain MimeType#getParameter(String) parameters}, then the mime type with the most_parameters is ordered before the other.</li>_</ol>_<p>For example: <blockquote>audio/basic &lt_ audio/* &lt_ *&#047_*</blockquote>_<blockquote>audio/basic_level=1 &lt_ audio/basic</blockquote>_<blockquote>audio/basic == text/html</blockquote> <blockquote>audio/basic ==_audio/wave</blockquote>_@param mimeTypes the list of mime types to be sorted_@see <a href="http://tools.ietf.org/html/rfc7231#section-5.3.2">HTTP 1.1: Semantics_and Content, section 5.3.2</a>;public static void sortBySpecificity(List<MimeType> mimeTypes) {_		Assert.notNull(mimeTypes, "'mimeTypes' must not be null")__		if (mimeTypes.size() > 1) {_			Collections.sort(mimeTypes, SPECIFICITY_COMPARATOR)__		}_	};sorts,the,given,list,of,code,mime,type,objects,by,specificity,p,given,two,mime,types,ol,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,type,wildcard,type,then,the,mime,type,without,the,wildcard,is,ordered,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,type,types,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,subtype,wildcard,subtype,then,the,mime,type,without,the,wildcard,is,sorted,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,subtype,subtypes,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,the,two,mime,types,have,a,different,amount,of,linkplain,mime,type,get,parameter,string,parameters,then,the,mime,type,with,the,most,parameters,is,ordered,before,the,other,li,ol,p,for,example,blockquote,audio,basic,lt,audio,lt,047,blockquote,blockquote,audio,basic,level,1,lt,audio,basic,blockquote,blockquote,audio,basic,text,html,blockquote,blockquote,audio,basic,audio,wave,blockquote,param,mime,types,the,list,of,mime,types,to,be,sorted,see,a,href,http,tools,ietf,org,html,rfc7231,section,5,3,2,http,1,1,semantics,and,content,section,5,3,2,a;public,static,void,sort,by,specificity,list,mime,type,mime,types,assert,not,null,mime,types,mime,types,must,not,be,null,if,mime,types,size,1,collections,sort,mime,types
MimeTypeUtils -> public static void sortBySpecificity(List<MimeType> mimeTypes);1468532417;Sorts the given list of {@code MimeType} objects by specificity._<p>Given two mime types:_<ol>_<li>if either mime type has a {@linkplain MimeType#isWildcardType() wildcard type},_then the mime type without the wildcard is ordered before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getType() types},_then they are considered equal and remain their current order.</li>_<li>if either mime type has a {@linkplain MimeType#isWildcardSubtype() wildcard subtype}_, then the mime type without the wildcard is sorted before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getSubtype() subtypes},_then they are considered equal and remain their current order.</li>_<li>if the two mime types have a different amount of_{@linkplain MimeType#getParameter(String) parameters}, then the mime type with the most_parameters is ordered before the other.</li>_</ol>_<p>For example: <blockquote>audio/basic &lt_ audio/* &lt_ *&#047_*</blockquote>_<blockquote>audio/basic_level=1 &lt_ audio/basic</blockquote>_<blockquote>audio/basic == text/html</blockquote> <blockquote>audio/basic ==_audio/wave</blockquote>_@param mimeTypes the list of mime types to be sorted_@see <a href="http://tools.ietf.org/html/rfc7231#section-5.3.2">HTTP 1.1: Semantics_and Content, section 5.3.2</a>;public static void sortBySpecificity(List<MimeType> mimeTypes) {_		Assert.notNull(mimeTypes, "'mimeTypes' must not be null")__		if (mimeTypes.size() > 1) {_			Collections.sort(mimeTypes, SPECIFICITY_COMPARATOR)__		}_	};sorts,the,given,list,of,code,mime,type,objects,by,specificity,p,given,two,mime,types,ol,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,type,wildcard,type,then,the,mime,type,without,the,wildcard,is,ordered,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,type,types,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,subtype,wildcard,subtype,then,the,mime,type,without,the,wildcard,is,sorted,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,subtype,subtypes,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,the,two,mime,types,have,a,different,amount,of,linkplain,mime,type,get,parameter,string,parameters,then,the,mime,type,with,the,most,parameters,is,ordered,before,the,other,li,ol,p,for,example,blockquote,audio,basic,lt,audio,lt,047,blockquote,blockquote,audio,basic,level,1,lt,audio,basic,blockquote,blockquote,audio,basic,text,html,blockquote,blockquote,audio,basic,audio,wave,blockquote,param,mime,types,the,list,of,mime,types,to,be,sorted,see,a,href,http,tools,ietf,org,html,rfc7231,section,5,3,2,http,1,1,semantics,and,content,section,5,3,2,a;public,static,void,sort,by,specificity,list,mime,type,mime,types,assert,not,null,mime,types,mime,types,must,not,be,null,if,mime,types,size,1,collections,sort,mime,types
MimeTypeUtils -> public static void sortBySpecificity(List<MimeType> mimeTypes);1468947211;Sorts the given list of {@code MimeType} objects by specificity._<p>Given two mime types:_<ol>_<li>if either mime type has a {@linkplain MimeType#isWildcardType() wildcard type},_then the mime type without the wildcard is ordered before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getType() types},_then they are considered equal and remain their current order.</li>_<li>if either mime type has a {@linkplain MimeType#isWildcardSubtype() wildcard subtype}_, then the mime type without the wildcard is sorted before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getSubtype() subtypes},_then they are considered equal and remain their current order.</li>_<li>if the two mime types have a different amount of_{@linkplain MimeType#getParameter(String) parameters}, then the mime type with the most_parameters is ordered before the other.</li>_</ol>_<p>For example: <blockquote>audio/basic &lt_ audio/* &lt_ *&#047_*</blockquote>_<blockquote>audio/basic_level=1 &lt_ audio/basic</blockquote>_<blockquote>audio/basic == text/html</blockquote> <blockquote>audio/basic ==_audio/wave</blockquote>_@param mimeTypes the list of mime types to be sorted_@see <a href="http://tools.ietf.org/html/rfc7231#section-5.3.2">HTTP 1.1: Semantics_and Content, section 5.3.2</a>;public static void sortBySpecificity(List<MimeType> mimeTypes) {_		Assert.notNull(mimeTypes, "'mimeTypes' must not be null")__		if (mimeTypes.size() > 1) {_			Collections.sort(mimeTypes, SPECIFICITY_COMPARATOR)__		}_	};sorts,the,given,list,of,code,mime,type,objects,by,specificity,p,given,two,mime,types,ol,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,type,wildcard,type,then,the,mime,type,without,the,wildcard,is,ordered,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,type,types,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,subtype,wildcard,subtype,then,the,mime,type,without,the,wildcard,is,sorted,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,subtype,subtypes,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,the,two,mime,types,have,a,different,amount,of,linkplain,mime,type,get,parameter,string,parameters,then,the,mime,type,with,the,most,parameters,is,ordered,before,the,other,li,ol,p,for,example,blockquote,audio,basic,lt,audio,lt,047,blockquote,blockquote,audio,basic,level,1,lt,audio,basic,blockquote,blockquote,audio,basic,text,html,blockquote,blockquote,audio,basic,audio,wave,blockquote,param,mime,types,the,list,of,mime,types,to,be,sorted,see,a,href,http,tools,ietf,org,html,rfc7231,section,5,3,2,http,1,1,semantics,and,content,section,5,3,2,a;public,static,void,sort,by,specificity,list,mime,type,mime,types,assert,not,null,mime,types,mime,types,must,not,be,null,if,mime,types,size,1,collections,sort,mime,types
MimeTypeUtils -> public static void sortBySpecificity(List<MimeType> mimeTypes);1472213779;Sorts the given list of {@code MimeType} objects by specificity._<p>Given two mime types:_<ol>_<li>if either mime type has a {@linkplain MimeType#isWildcardType() wildcard type},_then the mime type without the wildcard is ordered before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getType() types},_then they are considered equal and remain their current order.</li>_<li>if either mime type has a {@linkplain MimeType#isWildcardSubtype() wildcard subtype}_, then the mime type without the wildcard is sorted before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getSubtype() subtypes},_then they are considered equal and remain their current order.</li>_<li>if the two mime types have a different amount of_{@linkplain MimeType#getParameter(String) parameters}, then the mime type with the most_parameters is ordered before the other.</li>_</ol>_<p>For example: <blockquote>audio/basic &lt_ audio/* &lt_ *&#047_*</blockquote>_<blockquote>audio/basic_level=1 &lt_ audio/basic</blockquote>_<blockquote>audio/basic == text/html</blockquote> <blockquote>audio/basic ==_audio/wave</blockquote>_@param mimeTypes the list of mime types to be sorted_@see <a href="http://tools.ietf.org/html/rfc7231#section-5.3.2">HTTP 1.1: Semantics_and Content, section 5.3.2</a>;public static void sortBySpecificity(List<MimeType> mimeTypes) {_		Assert.notNull(mimeTypes, "'mimeTypes' must not be null")__		if (mimeTypes.size() > 1) {_			Collections.sort(mimeTypes, SPECIFICITY_COMPARATOR)__		}_	};sorts,the,given,list,of,code,mime,type,objects,by,specificity,p,given,two,mime,types,ol,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,type,wildcard,type,then,the,mime,type,without,the,wildcard,is,ordered,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,type,types,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,subtype,wildcard,subtype,then,the,mime,type,without,the,wildcard,is,sorted,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,subtype,subtypes,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,the,two,mime,types,have,a,different,amount,of,linkplain,mime,type,get,parameter,string,parameters,then,the,mime,type,with,the,most,parameters,is,ordered,before,the,other,li,ol,p,for,example,blockquote,audio,basic,lt,audio,lt,047,blockquote,blockquote,audio,basic,level,1,lt,audio,basic,blockquote,blockquote,audio,basic,text,html,blockquote,blockquote,audio,basic,audio,wave,blockquote,param,mime,types,the,list,of,mime,types,to,be,sorted,see,a,href,http,tools,ietf,org,html,rfc7231,section,5,3,2,http,1,1,semantics,and,content,section,5,3,2,a;public,static,void,sort,by,specificity,list,mime,type,mime,types,assert,not,null,mime,types,mime,types,must,not,be,null,if,mime,types,size,1,collections,sort,mime,types
MimeTypeUtils -> public static void sortBySpecificity(List<MimeType> mimeTypes);1472594218;Sorts the given list of {@code MimeType} objects by specificity._<p>Given two mime types:_<ol>_<li>if either mime type has a {@linkplain MimeType#isWildcardType() wildcard type},_then the mime type without the wildcard is ordered before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getType() types},_then they are considered equal and remain their current order.</li>_<li>if either mime type has a {@linkplain MimeType#isWildcardSubtype() wildcard subtype}_, then the mime type without the wildcard is sorted before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getSubtype() subtypes},_then they are considered equal and remain their current order.</li>_<li>if the two mime types have a different amount of_{@linkplain MimeType#getParameter(String) parameters}, then the mime type with the most_parameters is ordered before the other.</li>_</ol>_<p>For example: <blockquote>audio/basic &lt_ audio/* &lt_ *&#047_*</blockquote>_<blockquote>audio/basic_level=1 &lt_ audio/basic</blockquote>_<blockquote>audio/basic == text/html</blockquote> <blockquote>audio/basic ==_audio/wave</blockquote>_@param mimeTypes the list of mime types to be sorted_@see <a href="http://tools.ietf.org/html/rfc7231#section-5.3.2">HTTP 1.1: Semantics_and Content, section 5.3.2</a>;public static void sortBySpecificity(List<MimeType> mimeTypes) {_		Assert.notNull(mimeTypes, "'mimeTypes' must not be null")__		if (mimeTypes.size() > 1) {_			Collections.sort(mimeTypes, SPECIFICITY_COMPARATOR)__		}_	};sorts,the,given,list,of,code,mime,type,objects,by,specificity,p,given,two,mime,types,ol,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,type,wildcard,type,then,the,mime,type,without,the,wildcard,is,ordered,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,type,types,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,subtype,wildcard,subtype,then,the,mime,type,without,the,wildcard,is,sorted,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,subtype,subtypes,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,the,two,mime,types,have,a,different,amount,of,linkplain,mime,type,get,parameter,string,parameters,then,the,mime,type,with,the,most,parameters,is,ordered,before,the,other,li,ol,p,for,example,blockquote,audio,basic,lt,audio,lt,047,blockquote,blockquote,audio,basic,level,1,lt,audio,basic,blockquote,blockquote,audio,basic,text,html,blockquote,blockquote,audio,basic,audio,wave,blockquote,param,mime,types,the,list,of,mime,types,to,be,sorted,see,a,href,http,tools,ietf,org,html,rfc7231,section,5,3,2,http,1,1,semantics,and,content,section,5,3,2,a;public,static,void,sort,by,specificity,list,mime,type,mime,types,assert,not,null,mime,types,mime,types,must,not,be,null,if,mime,types,size,1,collections,sort,mime,types
MimeTypeUtils -> public static void sortBySpecificity(List<MimeType> mimeTypes);1481292266;Sorts the given list of {@code MimeType} objects by specificity._<p>Given two mime types:_<ol>_<li>if either mime type has a {@linkplain MimeType#isWildcardType() wildcard type},_then the mime type without the wildcard is ordered before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getType() types},_then they are considered equal and remain their current order.</li>_<li>if either mime type has a {@linkplain MimeType#isWildcardSubtype() wildcard subtype}_, then the mime type without the wildcard is sorted before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getSubtype() subtypes},_then they are considered equal and remain their current order.</li>_<li>if the two mime types have a different amount of_{@linkplain MimeType#getParameter(String) parameters}, then the mime type with the most_parameters is ordered before the other.</li>_</ol>_<p>For example: <blockquote>audio/basic &lt_ audio/* &lt_ *&#047_*</blockquote>_<blockquote>audio/basic_level=1 &lt_ audio/basic</blockquote>_<blockquote>audio/basic == text/html</blockquote> <blockquote>audio/basic ==_audio/wave</blockquote>_@param mimeTypes the list of mime types to be sorted_@see <a href="http://tools.ietf.org/html/rfc7231#section-5.3.2">HTTP 1.1: Semantics_and Content, section 5.3.2</a>;public static void sortBySpecificity(List<MimeType> mimeTypes) {_		Assert.notNull(mimeTypes, "'mimeTypes' must not be null")__		if (mimeTypes.size() > 1) {_			Collections.sort(mimeTypes, SPECIFICITY_COMPARATOR)__		}_	};sorts,the,given,list,of,code,mime,type,objects,by,specificity,p,given,two,mime,types,ol,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,type,wildcard,type,then,the,mime,type,without,the,wildcard,is,ordered,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,type,types,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,subtype,wildcard,subtype,then,the,mime,type,without,the,wildcard,is,sorted,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,subtype,subtypes,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,the,two,mime,types,have,a,different,amount,of,linkplain,mime,type,get,parameter,string,parameters,then,the,mime,type,with,the,most,parameters,is,ordered,before,the,other,li,ol,p,for,example,blockquote,audio,basic,lt,audio,lt,047,blockquote,blockquote,audio,basic,level,1,lt,audio,basic,blockquote,blockquote,audio,basic,text,html,blockquote,blockquote,audio,basic,audio,wave,blockquote,param,mime,types,the,list,of,mime,types,to,be,sorted,see,a,href,http,tools,ietf,org,html,rfc7231,section,5,3,2,http,1,1,semantics,and,content,section,5,3,2,a;public,static,void,sort,by,specificity,list,mime,type,mime,types,assert,not,null,mime,types,mime,types,must,not,be,null,if,mime,types,size,1,collections,sort,mime,types
MimeTypeUtils -> public static void sortBySpecificity(List<MimeType> mimeTypes);1484249067;Sorts the given list of {@code MimeType} objects by specificity._<p>Given two mime types:_<ol>_<li>if either mime type has a {@linkplain MimeType#isWildcardType() wildcard type},_then the mime type without the wildcard is ordered before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getType() types},_then they are considered equal and remain their current order.</li>_<li>if either mime type has a {@linkplain MimeType#isWildcardSubtype() wildcard subtype}_, then the mime type without the wildcard is sorted before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getSubtype() subtypes},_then they are considered equal and remain their current order.</li>_<li>if the two mime types have a different amount of_{@linkplain MimeType#getParameter(String) parameters}, then the mime type with the most_parameters is ordered before the other.</li>_</ol>_<p>For example: <blockquote>audio/basic &lt_ audio/* &lt_ *&#047_*</blockquote>_<blockquote>audio/basic_level=1 &lt_ audio/basic</blockquote>_<blockquote>audio/basic == text/html</blockquote> <blockquote>audio/basic ==_audio/wave</blockquote>_@param mimeTypes the list of mime types to be sorted_@see <a href="http://tools.ietf.org/html/rfc7231#section-5.3.2">HTTP 1.1: Semantics_and Content, section 5.3.2</a>;public static void sortBySpecificity(List<MimeType> mimeTypes) {_		Assert.notNull(mimeTypes, "'mimeTypes' must not be null")__		if (mimeTypes.size() > 1) {_			Collections.sort(mimeTypes, SPECIFICITY_COMPARATOR)__		}_	};sorts,the,given,list,of,code,mime,type,objects,by,specificity,p,given,two,mime,types,ol,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,type,wildcard,type,then,the,mime,type,without,the,wildcard,is,ordered,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,type,types,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,subtype,wildcard,subtype,then,the,mime,type,without,the,wildcard,is,sorted,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,subtype,subtypes,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,the,two,mime,types,have,a,different,amount,of,linkplain,mime,type,get,parameter,string,parameters,then,the,mime,type,with,the,most,parameters,is,ordered,before,the,other,li,ol,p,for,example,blockquote,audio,basic,lt,audio,lt,047,blockquote,blockquote,audio,basic,level,1,lt,audio,basic,blockquote,blockquote,audio,basic,text,html,blockquote,blockquote,audio,basic,audio,wave,blockquote,param,mime,types,the,list,of,mime,types,to,be,sorted,see,a,href,http,tools,ietf,org,html,rfc7231,section,5,3,2,http,1,1,semantics,and,content,section,5,3,2,a;public,static,void,sort,by,specificity,list,mime,type,mime,types,assert,not,null,mime,types,mime,types,must,not,be,null,if,mime,types,size,1,collections,sort,mime,types
MimeTypeUtils -> public static void sortBySpecificity(List<MimeType> mimeTypes);1484260257;Sorts the given list of {@code MimeType} objects by specificity._<p>Given two mime types:_<ol>_<li>if either mime type has a {@linkplain MimeType#isWildcardType() wildcard type},_then the mime type without the wildcard is ordered before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getType() types},_then they are considered equal and remain their current order.</li>_<li>if either mime type has a {@linkplain MimeType#isWildcardSubtype() wildcard subtype}_, then the mime type without the wildcard is sorted before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getSubtype() subtypes},_then they are considered equal and remain their current order.</li>_<li>if the two mime types have a different amount of_{@linkplain MimeType#getParameter(String) parameters}, then the mime type with the most_parameters is ordered before the other.</li>_</ol>_<p>For example: <blockquote>audio/basic &lt_ audio/* &lt_ *&#047_*</blockquote>_<blockquote>audio/basic_level=1 &lt_ audio/basic</blockquote>_<blockquote>audio/basic == text/html</blockquote> <blockquote>audio/basic ==_audio/wave</blockquote>_@param mimeTypes the list of mime types to be sorted_@see <a href="http://tools.ietf.org/html/rfc7231#section-5.3.2">HTTP 1.1: Semantics_and Content, section 5.3.2</a>;public static void sortBySpecificity(List<MimeType> mimeTypes) {_		Assert.notNull(mimeTypes, "'mimeTypes' must not be null")__		if (mimeTypes.size() > 1) {_			Collections.sort(mimeTypes, SPECIFICITY_COMPARATOR)__		}_	};sorts,the,given,list,of,code,mime,type,objects,by,specificity,p,given,two,mime,types,ol,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,type,wildcard,type,then,the,mime,type,without,the,wildcard,is,ordered,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,type,types,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,subtype,wildcard,subtype,then,the,mime,type,without,the,wildcard,is,sorted,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,subtype,subtypes,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,the,two,mime,types,have,a,different,amount,of,linkplain,mime,type,get,parameter,string,parameters,then,the,mime,type,with,the,most,parameters,is,ordered,before,the,other,li,ol,p,for,example,blockquote,audio,basic,lt,audio,lt,047,blockquote,blockquote,audio,basic,level,1,lt,audio,basic,blockquote,blockquote,audio,basic,text,html,blockquote,blockquote,audio,basic,audio,wave,blockquote,param,mime,types,the,list,of,mime,types,to,be,sorted,see,a,href,http,tools,ietf,org,html,rfc7231,section,5,3,2,http,1,1,semantics,and,content,section,5,3,2,a;public,static,void,sort,by,specificity,list,mime,type,mime,types,assert,not,null,mime,types,mime,types,must,not,be,null,if,mime,types,size,1,collections,sort,mime,types
MimeTypeUtils -> public static void sortBySpecificity(List<MimeType> mimeTypes);1487760984;Sorts the given list of {@code MimeType} objects by specificity._<p>Given two mime types:_<ol>_<li>if either mime type has a {@linkplain MimeType#isWildcardType() wildcard type},_then the mime type without the wildcard is ordered before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getType() types},_then they are considered equal and remain their current order.</li>_<li>if either mime type has a {@linkplain MimeType#isWildcardSubtype() wildcard subtype}_, then the mime type without the wildcard is sorted before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getSubtype() subtypes},_then they are considered equal and remain their current order.</li>_<li>if the two mime types have a different amount of_{@linkplain MimeType#getParameter(String) parameters}, then the mime type with the most_parameters is ordered before the other.</li>_</ol>_<p>For example: <blockquote>audio/basic &lt_ audio/* &lt_ *&#047_*</blockquote>_<blockquote>audio/basic_level=1 &lt_ audio/basic</blockquote>_<blockquote>audio/basic == text/html</blockquote> <blockquote>audio/basic ==_audio/wave</blockquote>_@param mimeTypes the list of mime types to be sorted_@see <a href="http://tools.ietf.org/html/rfc7231#section-5.3.2">HTTP 1.1: Semantics_and Content, section 5.3.2</a>;public static void sortBySpecificity(List<MimeType> mimeTypes) {_		Assert.notNull(mimeTypes, "'mimeTypes' must not be null")__		if (mimeTypes.size() > 1) {_			Collections.sort(mimeTypes, SPECIFICITY_COMPARATOR)__		}_	};sorts,the,given,list,of,code,mime,type,objects,by,specificity,p,given,two,mime,types,ol,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,type,wildcard,type,then,the,mime,type,without,the,wildcard,is,ordered,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,type,types,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,subtype,wildcard,subtype,then,the,mime,type,without,the,wildcard,is,sorted,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,subtype,subtypes,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,the,two,mime,types,have,a,different,amount,of,linkplain,mime,type,get,parameter,string,parameters,then,the,mime,type,with,the,most,parameters,is,ordered,before,the,other,li,ol,p,for,example,blockquote,audio,basic,lt,audio,lt,047,blockquote,blockquote,audio,basic,level,1,lt,audio,basic,blockquote,blockquote,audio,basic,text,html,blockquote,blockquote,audio,basic,audio,wave,blockquote,param,mime,types,the,list,of,mime,types,to,be,sorted,see,a,href,http,tools,ietf,org,html,rfc7231,section,5,3,2,http,1,1,semantics,and,content,section,5,3,2,a;public,static,void,sort,by,specificity,list,mime,type,mime,types,assert,not,null,mime,types,mime,types,must,not,be,null,if,mime,types,size,1,collections,sort,mime,types
MimeTypeUtils -> public static void sortBySpecificity(List<MimeType> mimeTypes);1518772998;Sorts the given list of {@code MimeType} objects by specificity._<p>Given two mime types:_<ol>_<li>if either mime type has a {@linkplain MimeType#isWildcardType() wildcard type},_then the mime type without the wildcard is ordered before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getType() types},_then they are considered equal and remain their current order.</li>_<li>if either mime type has a {@linkplain MimeType#isWildcardSubtype() wildcard subtype}_, then the mime type without the wildcard is sorted before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getSubtype() subtypes},_then they are considered equal and remain their current order.</li>_<li>if the two mime types have a different amount of_{@linkplain MimeType#getParameter(String) parameters}, then the mime type with the most_parameters is ordered before the other.</li>_</ol>_<p>For example: <blockquote>audio/basic &lt_ audio/* &lt_ *&#047_*</blockquote>_<blockquote>audio/basic_level=1 &lt_ audio/basic</blockquote>_<blockquote>audio/basic == text/html</blockquote> <blockquote>audio/basic ==_audio/wave</blockquote>_@param mimeTypes the list of mime types to be sorted_@see <a href="http://tools.ietf.org/html/rfc7231#section-5.3.2">HTTP 1.1: Semantics_and Content, section 5.3.2</a>;public static void sortBySpecificity(List<MimeType> mimeTypes) {_		Assert.notNull(mimeTypes, "'mimeTypes' must not be null")__		if (mimeTypes.size() > 1) {_			mimeTypes.sort(SPECIFICITY_COMPARATOR)__		}_	};sorts,the,given,list,of,code,mime,type,objects,by,specificity,p,given,two,mime,types,ol,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,type,wildcard,type,then,the,mime,type,without,the,wildcard,is,ordered,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,type,types,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,subtype,wildcard,subtype,then,the,mime,type,without,the,wildcard,is,sorted,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,subtype,subtypes,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,the,two,mime,types,have,a,different,amount,of,linkplain,mime,type,get,parameter,string,parameters,then,the,mime,type,with,the,most,parameters,is,ordered,before,the,other,li,ol,p,for,example,blockquote,audio,basic,lt,audio,lt,047,blockquote,blockquote,audio,basic,level,1,lt,audio,basic,blockquote,blockquote,audio,basic,text,html,blockquote,blockquote,audio,basic,audio,wave,blockquote,param,mime,types,the,list,of,mime,types,to,be,sorted,see,a,href,http,tools,ietf,org,html,rfc7231,section,5,3,2,http,1,1,semantics,and,content,section,5,3,2,a;public,static,void,sort,by,specificity,list,mime,type,mime,types,assert,not,null,mime,types,mime,types,must,not,be,null,if,mime,types,size,1,mime,types,sort
MimeTypeUtils -> public static void sortBySpecificity(List<MimeType> mimeTypes);1520528267;Sorts the given list of {@code MimeType} objects by specificity._<p>Given two mime types:_<ol>_<li>if either mime type has a {@linkplain MimeType#isWildcardType() wildcard type},_then the mime type without the wildcard is ordered before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getType() types},_then they are considered equal and remain their current order.</li>_<li>if either mime type has a {@linkplain MimeType#isWildcardSubtype() wildcard subtype}_, then the mime type without the wildcard is sorted before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getSubtype() subtypes},_then they are considered equal and remain their current order.</li>_<li>if the two mime types have a different amount of_{@linkplain MimeType#getParameter(String) parameters}, then the mime type with the most_parameters is ordered before the other.</li>_</ol>_<p>For example: <blockquote>audio/basic &lt_ audio/* &lt_ *&#047_*</blockquote>_<blockquote>audio/basic_level=1 &lt_ audio/basic</blockquote>_<blockquote>audio/basic == text/html</blockquote> <blockquote>audio/basic ==_audio/wave</blockquote>_@param mimeTypes the list of mime types to be sorted_@see <a href="http://tools.ietf.org/html/rfc7231#section-5.3.2">HTTP 1.1: Semantics_and Content, section 5.3.2</a>;public static void sortBySpecificity(List<MimeType> mimeTypes) {_		Assert.notNull(mimeTypes, "'mimeTypes' must not be null")__		if (mimeTypes.size() > 1) {_			mimeTypes.sort(SPECIFICITY_COMPARATOR)__		}_	};sorts,the,given,list,of,code,mime,type,objects,by,specificity,p,given,two,mime,types,ol,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,type,wildcard,type,then,the,mime,type,without,the,wildcard,is,ordered,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,type,types,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,subtype,wildcard,subtype,then,the,mime,type,without,the,wildcard,is,sorted,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,subtype,subtypes,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,the,two,mime,types,have,a,different,amount,of,linkplain,mime,type,get,parameter,string,parameters,then,the,mime,type,with,the,most,parameters,is,ordered,before,the,other,li,ol,p,for,example,blockquote,audio,basic,lt,audio,lt,047,blockquote,blockquote,audio,basic,level,1,lt,audio,basic,blockquote,blockquote,audio,basic,text,html,blockquote,blockquote,audio,basic,audio,wave,blockquote,param,mime,types,the,list,of,mime,types,to,be,sorted,see,a,href,http,tools,ietf,org,html,rfc7231,section,5,3,2,http,1,1,semantics,and,content,section,5,3,2,a;public,static,void,sort,by,specificity,list,mime,type,mime,types,assert,not,null,mime,types,mime,types,must,not,be,null,if,mime,types,size,1,mime,types,sort
MimeTypeUtils -> public static void sortBySpecificity(List<MimeType> mimeTypes);1521671173;Sorts the given list of {@code MimeType} objects by specificity._<p>Given two mime types:_<ol>_<li>if either mime type has a {@linkplain MimeType#isWildcardType() wildcard type},_then the mime type without the wildcard is ordered before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getType() types},_then they are considered equal and remain their current order.</li>_<li>if either mime type has a {@linkplain MimeType#isWildcardSubtype() wildcard subtype}_, then the mime type without the wildcard is sorted before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getSubtype() subtypes},_then they are considered equal and remain their current order.</li>_<li>if the two mime types have a different amount of_{@linkplain MimeType#getParameter(String) parameters}, then the mime type with the most_parameters is ordered before the other.</li>_</ol>_<p>For example: <blockquote>audio/basic &lt_ audio/* &lt_ *&#047_*</blockquote>_<blockquote>audio/basic_level=1 &lt_ audio/basic</blockquote>_<blockquote>audio/basic == text/html</blockquote> <blockquote>audio/basic ==_audio/wave</blockquote>_@param mimeTypes the list of mime types to be sorted_@see <a href="http://tools.ietf.org/html/rfc7231#section-5.3.2">HTTP 1.1: Semantics_and Content, section 5.3.2</a>;public static void sortBySpecificity(List<MimeType> mimeTypes) {_		Assert.notNull(mimeTypes, "'mimeTypes' must not be null")__		if (mimeTypes.size() > 1) {_			mimeTypes.sort(SPECIFICITY_COMPARATOR)__		}_	};sorts,the,given,list,of,code,mime,type,objects,by,specificity,p,given,two,mime,types,ol,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,type,wildcard,type,then,the,mime,type,without,the,wildcard,is,ordered,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,type,types,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,subtype,wildcard,subtype,then,the,mime,type,without,the,wildcard,is,sorted,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,subtype,subtypes,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,the,two,mime,types,have,a,different,amount,of,linkplain,mime,type,get,parameter,string,parameters,then,the,mime,type,with,the,most,parameters,is,ordered,before,the,other,li,ol,p,for,example,blockquote,audio,basic,lt,audio,lt,047,blockquote,blockquote,audio,basic,level,1,lt,audio,basic,blockquote,blockquote,audio,basic,text,html,blockquote,blockquote,audio,basic,audio,wave,blockquote,param,mime,types,the,list,of,mime,types,to,be,sorted,see,a,href,http,tools,ietf,org,html,rfc7231,section,5,3,2,http,1,1,semantics,and,content,section,5,3,2,a;public,static,void,sort,by,specificity,list,mime,type,mime,types,assert,not,null,mime,types,mime,types,must,not,be,null,if,mime,types,size,1,mime,types,sort
MimeTypeUtils -> public static void sortBySpecificity(List<MimeType> mimeTypes);1521855941;Sorts the given list of {@code MimeType} objects by specificity._<p>Given two mime types:_<ol>_<li>if either mime type has a {@linkplain MimeType#isWildcardType() wildcard type},_then the mime type without the wildcard is ordered before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getType() types},_then they are considered equal and remain their current order.</li>_<li>if either mime type has a {@linkplain MimeType#isWildcardSubtype() wildcard subtype}_, then the mime type without the wildcard is sorted before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getSubtype() subtypes},_then they are considered equal and remain their current order.</li>_<li>if the two mime types have a different amount of_{@linkplain MimeType#getParameter(String) parameters}, then the mime type with the most_parameters is ordered before the other.</li>_</ol>_<p>For example: <blockquote>audio/basic &lt_ audio/* &lt_ *&#047_*</blockquote>_<blockquote>audio/basic_level=1 &lt_ audio/basic</blockquote>_<blockquote>audio/basic == text/html</blockquote> <blockquote>audio/basic ==_audio/wave</blockquote>_@param mimeTypes the list of mime types to be sorted_@see <a href="http://tools.ietf.org/html/rfc7231#section-5.3.2">HTTP 1.1: Semantics_and Content, section 5.3.2</a>;public static void sortBySpecificity(List<MimeType> mimeTypes) {_		Assert.notNull(mimeTypes, "'mimeTypes' must not be null")__		if (mimeTypes.size() > 1) {_			mimeTypes.sort(SPECIFICITY_COMPARATOR)__		}_	};sorts,the,given,list,of,code,mime,type,objects,by,specificity,p,given,two,mime,types,ol,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,type,wildcard,type,then,the,mime,type,without,the,wildcard,is,ordered,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,type,types,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,subtype,wildcard,subtype,then,the,mime,type,without,the,wildcard,is,sorted,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,subtype,subtypes,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,the,two,mime,types,have,a,different,amount,of,linkplain,mime,type,get,parameter,string,parameters,then,the,mime,type,with,the,most,parameters,is,ordered,before,the,other,li,ol,p,for,example,blockquote,audio,basic,lt,audio,lt,047,blockquote,blockquote,audio,basic,level,1,lt,audio,basic,blockquote,blockquote,audio,basic,text,html,blockquote,blockquote,audio,basic,audio,wave,blockquote,param,mime,types,the,list,of,mime,types,to,be,sorted,see,a,href,http,tools,ietf,org,html,rfc7231,section,5,3,2,http,1,1,semantics,and,content,section,5,3,2,a;public,static,void,sort,by,specificity,list,mime,type,mime,types,assert,not,null,mime,types,mime,types,must,not,be,null,if,mime,types,size,1,mime,types,sort
MimeTypeUtils -> public static void sortBySpecificity(List<MimeType> mimeTypes);1522194969;Sorts the given list of {@code MimeType} objects by specificity._<p>Given two mime types:_<ol>_<li>if either mime type has a {@linkplain MimeType#isWildcardType() wildcard type},_then the mime type without the wildcard is ordered before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getType() types},_then they are considered equal and remain their current order.</li>_<li>if either mime type has a {@linkplain MimeType#isWildcardSubtype() wildcard subtype}_, then the mime type without the wildcard is sorted before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getSubtype() subtypes},_then they are considered equal and remain their current order.</li>_<li>if the two mime types have a different amount of_{@linkplain MimeType#getParameter(String) parameters}, then the mime type with the most_parameters is ordered before the other.</li>_</ol>_<p>For example: <blockquote>audio/basic &lt_ audio/* &lt_ *&#047_*</blockquote>_<blockquote>audio/basic_level=1 &lt_ audio/basic</blockquote>_<blockquote>audio/basic == text/html</blockquote> <blockquote>audio/basic ==_audio/wave</blockquote>_@param mimeTypes the list of mime types to be sorted_@see <a href="http://tools.ietf.org/html/rfc7231#section-5.3.2">HTTP 1.1: Semantics_and Content, section 5.3.2</a>;public static void sortBySpecificity(List<MimeType> mimeTypes) {_		Assert.notNull(mimeTypes, "'mimeTypes' must not be null")__		if (mimeTypes.size() > 1) {_			mimeTypes.sort(SPECIFICITY_COMPARATOR)__		}_	};sorts,the,given,list,of,code,mime,type,objects,by,specificity,p,given,two,mime,types,ol,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,type,wildcard,type,then,the,mime,type,without,the,wildcard,is,ordered,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,type,types,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,subtype,wildcard,subtype,then,the,mime,type,without,the,wildcard,is,sorted,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,subtype,subtypes,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,the,two,mime,types,have,a,different,amount,of,linkplain,mime,type,get,parameter,string,parameters,then,the,mime,type,with,the,most,parameters,is,ordered,before,the,other,li,ol,p,for,example,blockquote,audio,basic,lt,audio,lt,047,blockquote,blockquote,audio,basic,level,1,lt,audio,basic,blockquote,blockquote,audio,basic,text,html,blockquote,blockquote,audio,basic,audio,wave,blockquote,param,mime,types,the,list,of,mime,types,to,be,sorted,see,a,href,http,tools,ietf,org,html,rfc7231,section,5,3,2,http,1,1,semantics,and,content,section,5,3,2,a;public,static,void,sort,by,specificity,list,mime,type,mime,types,assert,not,null,mime,types,mime,types,must,not,be,null,if,mime,types,size,1,mime,types,sort
MimeTypeUtils -> public static void sortBySpecificity(List<MimeType> mimeTypes);1529943163;Sorts the given list of {@code MimeType} objects by specificity._<p>Given two mime types:_<ol>_<li>if either mime type has a {@linkplain MimeType#isWildcardType() wildcard type},_then the mime type without the wildcard is ordered before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getType() types},_then they are considered equal and remain their current order.</li>_<li>if either mime type has a {@linkplain MimeType#isWildcardSubtype() wildcard subtype}_, then the mime type without the wildcard is sorted before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getSubtype() subtypes},_then they are considered equal and remain their current order.</li>_<li>if the two mime types have a different amount of_{@linkplain MimeType#getParameter(String) parameters}, then the mime type with the most_parameters is ordered before the other.</li>_</ol>_<p>For example: <blockquote>audio/basic &lt_ audio/* &lt_ *&#047_*</blockquote>_<blockquote>audio/basic_level=1 &lt_ audio/basic</blockquote>_<blockquote>audio/basic == text/html</blockquote> <blockquote>audio/basic ==_audio/wave</blockquote>_@param mimeTypes the list of mime types to be sorted_@see <a href="http://tools.ietf.org/html/rfc7231#section-5.3.2">HTTP 1.1: Semantics_and Content, section 5.3.2</a>;public static void sortBySpecificity(List<MimeType> mimeTypes) {_		Assert.notNull(mimeTypes, "'mimeTypes' must not be null")__		if (mimeTypes.size() > 1) {_			mimeTypes.sort(SPECIFICITY_COMPARATOR)__		}_	};sorts,the,given,list,of,code,mime,type,objects,by,specificity,p,given,two,mime,types,ol,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,type,wildcard,type,then,the,mime,type,without,the,wildcard,is,ordered,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,type,types,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,subtype,wildcard,subtype,then,the,mime,type,without,the,wildcard,is,sorted,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,subtype,subtypes,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,the,two,mime,types,have,a,different,amount,of,linkplain,mime,type,get,parameter,string,parameters,then,the,mime,type,with,the,most,parameters,is,ordered,before,the,other,li,ol,p,for,example,blockquote,audio,basic,lt,audio,lt,047,blockquote,blockquote,audio,basic,level,1,lt,audio,basic,blockquote,blockquote,audio,basic,text,html,blockquote,blockquote,audio,basic,audio,wave,blockquote,param,mime,types,the,list,of,mime,types,to,be,sorted,see,a,href,http,tools,ietf,org,html,rfc7231,section,5,3,2,http,1,1,semantics,and,content,section,5,3,2,a;public,static,void,sort,by,specificity,list,mime,type,mime,types,assert,not,null,mime,types,mime,types,must,not,be,null,if,mime,types,size,1,mime,types,sort
MimeTypeUtils -> public static void sortBySpecificity(List<MimeType> mimeTypes);1542168307;Sorts the given list of {@code MimeType} objects by specificity._<p>Given two mime types:_<ol>_<li>if either mime type has a {@linkplain MimeType#isWildcardType() wildcard type},_then the mime type without the wildcard is ordered before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getType() types},_then they are considered equal and remain their current order.</li>_<li>if either mime type has a {@linkplain MimeType#isWildcardSubtype() wildcard subtype}_, then the mime type without the wildcard is sorted before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getSubtype() subtypes},_then they are considered equal and remain their current order.</li>_<li>if the two mime types have a different amount of_{@linkplain MimeType#getParameter(String) parameters}, then the mime type with the most_parameters is ordered before the other.</li>_</ol>_<p>For example: <blockquote>audio/basic &lt_ audio/* &lt_ *&#047_*</blockquote>_<blockquote>audio/basic_level=1 &lt_ audio/basic</blockquote>_<blockquote>audio/basic == text/html</blockquote> <blockquote>audio/basic ==_audio/wave</blockquote>_@param mimeTypes the list of mime types to be sorted_@see <a href="http://tools.ietf.org/html/rfc7231#section-5.3.2">HTTP 1.1: Semantics_and Content, section 5.3.2</a>;public static void sortBySpecificity(List<MimeType> mimeTypes) {_		Assert.notNull(mimeTypes, "'mimeTypes' must not be null")__		if (mimeTypes.size() > 1) {_			mimeTypes.sort(SPECIFICITY_COMPARATOR)__		}_	};sorts,the,given,list,of,code,mime,type,objects,by,specificity,p,given,two,mime,types,ol,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,type,wildcard,type,then,the,mime,type,without,the,wildcard,is,ordered,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,type,types,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,subtype,wildcard,subtype,then,the,mime,type,without,the,wildcard,is,sorted,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,subtype,subtypes,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,the,two,mime,types,have,a,different,amount,of,linkplain,mime,type,get,parameter,string,parameters,then,the,mime,type,with,the,most,parameters,is,ordered,before,the,other,li,ol,p,for,example,blockquote,audio,basic,lt,audio,lt,047,blockquote,blockquote,audio,basic,level,1,lt,audio,basic,blockquote,blockquote,audio,basic,text,html,blockquote,blockquote,audio,basic,audio,wave,blockquote,param,mime,types,the,list,of,mime,types,to,be,sorted,see,a,href,http,tools,ietf,org,html,rfc7231,section,5,3,2,http,1,1,semantics,and,content,section,5,3,2,a;public,static,void,sort,by,specificity,list,mime,type,mime,types,assert,not,null,mime,types,mime,types,must,not,be,null,if,mime,types,size,1,mime,types,sort
MimeTypeUtils -> public static void sortBySpecificity(List<MimeType> mimeTypes);1549373623;Sorts the given list of {@code MimeType} objects by specificity._<p>Given two mime types:_<ol>_<li>if either mime type has a {@linkplain MimeType#isWildcardType() wildcard type},_then the mime type without the wildcard is ordered before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getType() types},_then they are considered equal and remain their current order.</li>_<li>if either mime type has a {@linkplain MimeType#isWildcardSubtype() wildcard subtype}_, then the mime type without the wildcard is sorted before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getSubtype() subtypes},_then they are considered equal and remain their current order.</li>_<li>if the two mime types have a different amount of_{@linkplain MimeType#getParameter(String) parameters}, then the mime type with the most_parameters is ordered before the other.</li>_</ol>_<p>For example: <blockquote>audio/basic &lt_ audio/* &lt_ *&#047_*</blockquote>_<blockquote>audio/basic_level=1 &lt_ audio/basic</blockquote>_<blockquote>audio/basic == text/html</blockquote> <blockquote>audio/basic ==_audio/wave</blockquote>_@param mimeTypes the list of mime types to be sorted_@see <a href="http://tools.ietf.org/html/rfc7231#section-5.3.2">HTTP 1.1: Semantics_and Content, section 5.3.2</a>;public static void sortBySpecificity(List<MimeType> mimeTypes) {_		Assert.notNull(mimeTypes, "'mimeTypes' must not be null")__		if (mimeTypes.size() > 1) {_			mimeTypes.sort(SPECIFICITY_COMPARATOR)__		}_	};sorts,the,given,list,of,code,mime,type,objects,by,specificity,p,given,two,mime,types,ol,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,type,wildcard,type,then,the,mime,type,without,the,wildcard,is,ordered,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,type,types,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,subtype,wildcard,subtype,then,the,mime,type,without,the,wildcard,is,sorted,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,subtype,subtypes,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,the,two,mime,types,have,a,different,amount,of,linkplain,mime,type,get,parameter,string,parameters,then,the,mime,type,with,the,most,parameters,is,ordered,before,the,other,li,ol,p,for,example,blockquote,audio,basic,lt,audio,lt,047,blockquote,blockquote,audio,basic,level,1,lt,audio,basic,blockquote,blockquote,audio,basic,text,html,blockquote,blockquote,audio,basic,audio,wave,blockquote,param,mime,types,the,list,of,mime,types,to,be,sorted,see,a,href,http,tools,ietf,org,html,rfc7231,section,5,3,2,http,1,1,semantics,and,content,section,5,3,2,a;public,static,void,sort,by,specificity,list,mime,type,mime,types,assert,not,null,mime,types,mime,types,must,not,be,null,if,mime,types,size,1,mime,types,sort
MimeTypeUtils -> public static void sortBySpecificity(List<MimeType> mimeTypes);1549375593;Sorts the given list of {@code MimeType} objects by specificity._<p>Given two mime types:_<ol>_<li>if either mime type has a {@linkplain MimeType#isWildcardType() wildcard type},_then the mime type without the wildcard is ordered before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getType() types},_then they are considered equal and remain their current order.</li>_<li>if either mime type has a {@linkplain MimeType#isWildcardSubtype() wildcard subtype}_, then the mime type without the wildcard is sorted before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getSubtype() subtypes},_then they are considered equal and remain their current order.</li>_<li>if the two mime types have a different amount of_{@linkplain MimeType#getParameter(String) parameters}, then the mime type with the most_parameters is ordered before the other.</li>_</ol>_<p>For example: <blockquote>audio/basic &lt_ audio/* &lt_ *&#047_*</blockquote>_<blockquote>audio/basic_level=1 &lt_ audio/basic</blockquote>_<blockquote>audio/basic == text/html</blockquote> <blockquote>audio/basic ==_audio/wave</blockquote>_@param mimeTypes the list of mime types to be sorted_@see <a href="http://tools.ietf.org/html/rfc7231#section-5.3.2">HTTP 1.1: Semantics_and Content, section 5.3.2</a>;public static void sortBySpecificity(List<MimeType> mimeTypes) {_		Assert.notNull(mimeTypes, "'mimeTypes' must not be null")__		if (mimeTypes.size() > 1) {_			mimeTypes.sort(SPECIFICITY_COMPARATOR)__		}_	};sorts,the,given,list,of,code,mime,type,objects,by,specificity,p,given,two,mime,types,ol,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,type,wildcard,type,then,the,mime,type,without,the,wildcard,is,ordered,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,type,types,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,subtype,wildcard,subtype,then,the,mime,type,without,the,wildcard,is,sorted,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,subtype,subtypes,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,the,two,mime,types,have,a,different,amount,of,linkplain,mime,type,get,parameter,string,parameters,then,the,mime,type,with,the,most,parameters,is,ordered,before,the,other,li,ol,p,for,example,blockquote,audio,basic,lt,audio,lt,047,blockquote,blockquote,audio,basic,level,1,lt,audio,basic,blockquote,blockquote,audio,basic,text,html,blockquote,blockquote,audio,basic,audio,wave,blockquote,param,mime,types,the,list,of,mime,types,to,be,sorted,see,a,href,http,tools,ietf,org,html,rfc7231,section,5,3,2,http,1,1,semantics,and,content,section,5,3,2,a;public,static,void,sort,by,specificity,list,mime,type,mime,types,assert,not,null,mime,types,mime,types,must,not,be,null,if,mime,types,size,1,mime,types,sort
MimeTypeUtils -> public static void sortBySpecificity(List<MimeType> mimeTypes);1549377521;Sorts the given list of {@code MimeType} objects by specificity._<p>Given two mime types:_<ol>_<li>if either mime type has a {@linkplain MimeType#isWildcardType() wildcard type},_then the mime type without the wildcard is ordered before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getType() types},_then they are considered equal and remain their current order.</li>_<li>if either mime type has a {@linkplain MimeType#isWildcardSubtype() wildcard subtype}_, then the mime type without the wildcard is sorted before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getSubtype() subtypes},_then they are considered equal and remain their current order.</li>_<li>if the two mime types have a different amount of_{@linkplain MimeType#getParameter(String) parameters}, then the mime type with the most_parameters is ordered before the other.</li>_</ol>_<p>For example: <blockquote>audio/basic &lt_ audio/* &lt_ *&#047_*</blockquote>_<blockquote>audio/basic_level=1 &lt_ audio/basic</blockquote>_<blockquote>audio/basic == text/html</blockquote> <blockquote>audio/basic ==_audio/wave</blockquote>_@param mimeTypes the list of mime types to be sorted_@see <a href="http://tools.ietf.org/html/rfc7231#section-5.3.2">HTTP 1.1: Semantics_and Content, section 5.3.2</a>;public static void sortBySpecificity(List<MimeType> mimeTypes) {_		Assert.notNull(mimeTypes, "'mimeTypes' must not be null")__		if (mimeTypes.size() > 1) {_			mimeTypes.sort(SPECIFICITY_COMPARATOR)__		}_	};sorts,the,given,list,of,code,mime,type,objects,by,specificity,p,given,two,mime,types,ol,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,type,wildcard,type,then,the,mime,type,without,the,wildcard,is,ordered,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,type,types,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,subtype,wildcard,subtype,then,the,mime,type,without,the,wildcard,is,sorted,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,subtype,subtypes,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,the,two,mime,types,have,a,different,amount,of,linkplain,mime,type,get,parameter,string,parameters,then,the,mime,type,with,the,most,parameters,is,ordered,before,the,other,li,ol,p,for,example,blockquote,audio,basic,lt,audio,lt,047,blockquote,blockquote,audio,basic,level,1,lt,audio,basic,blockquote,blockquote,audio,basic,text,html,blockquote,blockquote,audio,basic,audio,wave,blockquote,param,mime,types,the,list,of,mime,types,to,be,sorted,see,a,href,http,tools,ietf,org,html,rfc7231,section,5,3,2,http,1,1,semantics,and,content,section,5,3,2,a;public,static,void,sort,by,specificity,list,mime,type,mime,types,assert,not,null,mime,types,mime,types,must,not,be,null,if,mime,types,size,1,mime,types,sort
MimeTypeUtils -> public static void sortBySpecificity(List<MimeType> mimeTypes);1549878350;Sorts the given list of {@code MimeType} objects by specificity._<p>Given two mime types:_<ol>_<li>if either mime type has a {@linkplain MimeType#isWildcardType() wildcard type},_then the mime type without the wildcard is ordered before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getType() types},_then they are considered equal and remain their current order.</li>_<li>if either mime type has a {@linkplain MimeType#isWildcardSubtype() wildcard subtype}_, then the mime type without the wildcard is sorted before the other.</li>_<li>if the two mime types have different {@linkplain MimeType#getSubtype() subtypes},_then they are considered equal and remain their current order.</li>_<li>if the two mime types have a different amount of_{@linkplain MimeType#getParameter(String) parameters}, then the mime type with the most_parameters is ordered before the other.</li>_</ol>_<p>For example: <blockquote>audio/basic &lt_ audio/* &lt_ *&#047_*</blockquote>_<blockquote>audio/basic_level=1 &lt_ audio/basic</blockquote>_<blockquote>audio/basic == text/html</blockquote> <blockquote>audio/basic ==_audio/wave</blockquote>_@param mimeTypes the list of mime types to be sorted_@see <a href="http://tools.ietf.org/html/rfc7231#section-5.3.2">HTTP 1.1: Semantics_and Content, section 5.3.2</a>;public static void sortBySpecificity(List<MimeType> mimeTypes) {_		Assert.notNull(mimeTypes, "'mimeTypes' must not be null")__		if (mimeTypes.size() > 1) {_			mimeTypes.sort(SPECIFICITY_COMPARATOR)__		}_	};sorts,the,given,list,of,code,mime,type,objects,by,specificity,p,given,two,mime,types,ol,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,type,wildcard,type,then,the,mime,type,without,the,wildcard,is,ordered,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,type,types,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,either,mime,type,has,a,linkplain,mime,type,is,wildcard,subtype,wildcard,subtype,then,the,mime,type,without,the,wildcard,is,sorted,before,the,other,li,li,if,the,two,mime,types,have,different,linkplain,mime,type,get,subtype,subtypes,then,they,are,considered,equal,and,remain,their,current,order,li,li,if,the,two,mime,types,have,a,different,amount,of,linkplain,mime,type,get,parameter,string,parameters,then,the,mime,type,with,the,most,parameters,is,ordered,before,the,other,li,ol,p,for,example,blockquote,audio,basic,lt,audio,lt,047,blockquote,blockquote,audio,basic,level,1,lt,audio,basic,blockquote,blockquote,audio,basic,text,html,blockquote,blockquote,audio,basic,audio,wave,blockquote,param,mime,types,the,list,of,mime,types,to,be,sorted,see,a,href,http,tools,ietf,org,html,rfc7231,section,5,3,2,http,1,1,semantics,and,content,section,5,3,2,a;public,static,void,sort,by,specificity,list,mime,type,mime,types,assert,not,null,mime,types,mime,types,must,not,be,null,if,mime,types,size,1,mime,types,sort
MimeTypeUtils -> public static String generateMultipartBoundaryString();1426880143;Generate a random MIME boundary as String, often used in multipart mime types.;public static String generateMultipartBoundaryString() {_		return new String(generateMultipartBoundary(), US_ASCII)__	};generate,a,random,mime,boundary,as,string,often,used,in,multipart,mime,types;public,static,string,generate,multipart,boundary,string,return,new,string,generate,multipart,boundary
MimeTypeUtils -> public static String generateMultipartBoundaryString();1460988078;Generate a random MIME boundary as String, often used in multipart mime types.;public static String generateMultipartBoundaryString() {_		return new String(generateMultipartBoundary(), US_ASCII)__	};generate,a,random,mime,boundary,as,string,often,used,in,multipart,mime,types;public,static,string,generate,multipart,boundary,string,return,new,string,generate,multipart,boundary
MimeTypeUtils -> public static String generateMultipartBoundaryString();1467730834;Generate a random MIME boundary as String, often used in multipart mime types.;public static String generateMultipartBoundaryString() {_		return new String(generateMultipartBoundary(), US_ASCII)__	};generate,a,random,mime,boundary,as,string,often,used,in,multipart,mime,types;public,static,string,generate,multipart,boundary,string,return,new,string,generate,multipart,boundary
MimeTypeUtils -> public static String generateMultipartBoundaryString();1468513830;Generate a random MIME boundary as String, often used in multipart mime types.;public static String generateMultipartBoundaryString() {_		return new String(generateMultipartBoundary(), US_ASCII)__	};generate,a,random,mime,boundary,as,string,often,used,in,multipart,mime,types;public,static,string,generate,multipart,boundary,string,return,new,string,generate,multipart,boundary
MimeTypeUtils -> public static String generateMultipartBoundaryString();1468532417;Generate a random MIME boundary as String, often used in multipart mime types.;public static String generateMultipartBoundaryString() {_		return new String(generateMultipartBoundary(), US_ASCII)__	};generate,a,random,mime,boundary,as,string,often,used,in,multipart,mime,types;public,static,string,generate,multipart,boundary,string,return,new,string,generate,multipart,boundary
MimeTypeUtils -> public static String generateMultipartBoundaryString();1468947211;Generate a random MIME boundary as String, often used in multipart mime types.;public static String generateMultipartBoundaryString() {_		return new String(generateMultipartBoundary(), US_ASCII)__	};generate,a,random,mime,boundary,as,string,often,used,in,multipart,mime,types;public,static,string,generate,multipart,boundary,string,return,new,string,generate,multipart,boundary
MimeTypeUtils -> public static String generateMultipartBoundaryString();1472213779;Generate a random MIME boundary as String, often used in multipart mime types.;public static String generateMultipartBoundaryString() {_		return new String(generateMultipartBoundary(), StandardCharsets.US_ASCII)__	};generate,a,random,mime,boundary,as,string,often,used,in,multipart,mime,types;public,static,string,generate,multipart,boundary,string,return,new,string,generate,multipart,boundary,standard,charsets
MimeTypeUtils -> public static String generateMultipartBoundaryString();1472594218;Generate a random MIME boundary as String, often used in multipart mime types.;public static String generateMultipartBoundaryString() {_		return new String(generateMultipartBoundary(), StandardCharsets.US_ASCII)__	};generate,a,random,mime,boundary,as,string,often,used,in,multipart,mime,types;public,static,string,generate,multipart,boundary,string,return,new,string,generate,multipart,boundary,standard,charsets
MimeTypeUtils -> public static String generateMultipartBoundaryString();1481292266;Generate a random MIME boundary as String, often used in multipart mime types.;public static String generateMultipartBoundaryString() {_		return new String(generateMultipartBoundary(), StandardCharsets.US_ASCII)__	};generate,a,random,mime,boundary,as,string,often,used,in,multipart,mime,types;public,static,string,generate,multipart,boundary,string,return,new,string,generate,multipart,boundary,standard,charsets
MimeTypeUtils -> public static String generateMultipartBoundaryString();1484249067;Generate a random MIME boundary as String, often used in multipart mime types.;public static String generateMultipartBoundaryString() {_		return new String(generateMultipartBoundary(), StandardCharsets.US_ASCII)__	};generate,a,random,mime,boundary,as,string,often,used,in,multipart,mime,types;public,static,string,generate,multipart,boundary,string,return,new,string,generate,multipart,boundary,standard,charsets
MimeTypeUtils -> public static String generateMultipartBoundaryString();1484260257;Generate a random MIME boundary as String, often used in multipart mime types.;public static String generateMultipartBoundaryString() {_		return new String(generateMultipartBoundary(), StandardCharsets.US_ASCII)__	};generate,a,random,mime,boundary,as,string,often,used,in,multipart,mime,types;public,static,string,generate,multipart,boundary,string,return,new,string,generate,multipart,boundary,standard,charsets
MimeTypeUtils -> public static String generateMultipartBoundaryString();1487760984;Generate a random MIME boundary as String, often used in multipart mime types.;public static String generateMultipartBoundaryString() {_		return new String(generateMultipartBoundary(), StandardCharsets.US_ASCII)__	};generate,a,random,mime,boundary,as,string,often,used,in,multipart,mime,types;public,static,string,generate,multipart,boundary,string,return,new,string,generate,multipart,boundary,standard,charsets
MimeTypeUtils -> public static String generateMultipartBoundaryString();1518772998;Generate a random MIME boundary as String, often used in multipart mime types.;public static String generateMultipartBoundaryString() {_		return new String(generateMultipartBoundary(), StandardCharsets.US_ASCII)__	};generate,a,random,mime,boundary,as,string,often,used,in,multipart,mime,types;public,static,string,generate,multipart,boundary,string,return,new,string,generate,multipart,boundary,standard,charsets
MimeTypeUtils -> public static String generateMultipartBoundaryString();1520528267;Generate a random MIME boundary as String, often used in multipart mime types.;public static String generateMultipartBoundaryString() {_		return new String(generateMultipartBoundary(), StandardCharsets.US_ASCII)__	};generate,a,random,mime,boundary,as,string,often,used,in,multipart,mime,types;public,static,string,generate,multipart,boundary,string,return,new,string,generate,multipart,boundary,standard,charsets
MimeTypeUtils -> public static String generateMultipartBoundaryString();1521671173;Generate a random MIME boundary as String, often used in multipart mime types.;public static String generateMultipartBoundaryString() {_		return new String(generateMultipartBoundary(), StandardCharsets.US_ASCII)__	};generate,a,random,mime,boundary,as,string,often,used,in,multipart,mime,types;public,static,string,generate,multipart,boundary,string,return,new,string,generate,multipart,boundary,standard,charsets
MimeTypeUtils -> public static String generateMultipartBoundaryString();1521855941;Generate a random MIME boundary as String, often used in multipart mime types.;public static String generateMultipartBoundaryString() {_		return new String(generateMultipartBoundary(), StandardCharsets.US_ASCII)__	};generate,a,random,mime,boundary,as,string,often,used,in,multipart,mime,types;public,static,string,generate,multipart,boundary,string,return,new,string,generate,multipart,boundary,standard,charsets
MimeTypeUtils -> public static String generateMultipartBoundaryString();1522194969;Generate a random MIME boundary as String, often used in multipart mime types.;public static String generateMultipartBoundaryString() {_		return new String(generateMultipartBoundary(), StandardCharsets.US_ASCII)__	};generate,a,random,mime,boundary,as,string,often,used,in,multipart,mime,types;public,static,string,generate,multipart,boundary,string,return,new,string,generate,multipart,boundary,standard,charsets
MimeTypeUtils -> public static String generateMultipartBoundaryString();1529943163;Generate a random MIME boundary as String, often used in multipart mime types.;public static String generateMultipartBoundaryString() {_		return new String(generateMultipartBoundary(), StandardCharsets.US_ASCII)__	};generate,a,random,mime,boundary,as,string,often,used,in,multipart,mime,types;public,static,string,generate,multipart,boundary,string,return,new,string,generate,multipart,boundary,standard,charsets
MimeTypeUtils -> public static String generateMultipartBoundaryString();1542168307;Generate a random MIME boundary as String, often used in multipart mime types.;public static String generateMultipartBoundaryString() {_		return new String(generateMultipartBoundary(), StandardCharsets.US_ASCII)__	};generate,a,random,mime,boundary,as,string,often,used,in,multipart,mime,types;public,static,string,generate,multipart,boundary,string,return,new,string,generate,multipart,boundary,standard,charsets
MimeTypeUtils -> public static String generateMultipartBoundaryString();1549373623;Generate a random MIME boundary as String, often used in multipart mime types.;public static String generateMultipartBoundaryString() {_		return new String(generateMultipartBoundary(), StandardCharsets.US_ASCII)__	};generate,a,random,mime,boundary,as,string,often,used,in,multipart,mime,types;public,static,string,generate,multipart,boundary,string,return,new,string,generate,multipart,boundary,standard,charsets
MimeTypeUtils -> public static String generateMultipartBoundaryString();1549375593;Generate a random MIME boundary as String, often used in multipart mime types.;public static String generateMultipartBoundaryString() {_		return new String(generateMultipartBoundary(), StandardCharsets.US_ASCII)__	};generate,a,random,mime,boundary,as,string,often,used,in,multipart,mime,types;public,static,string,generate,multipart,boundary,string,return,new,string,generate,multipart,boundary,standard,charsets
MimeTypeUtils -> public static String generateMultipartBoundaryString();1549377521;Generate a random MIME boundary as String, often used in multipart mime types.;public static String generateMultipartBoundaryString() {_		return new String(generateMultipartBoundary(), StandardCharsets.US_ASCII)__	};generate,a,random,mime,boundary,as,string,often,used,in,multipart,mime,types;public,static,string,generate,multipart,boundary,string,return,new,string,generate,multipart,boundary,standard,charsets
MimeTypeUtils -> public static String generateMultipartBoundaryString();1549878350;Generate a random MIME boundary as String, often used in multipart mime types.;public static String generateMultipartBoundaryString() {_		return new String(generateMultipartBoundary(), StandardCharsets.US_ASCII)__	};generate,a,random,mime,boundary,as,string,often,used,in,multipart,mime,types;public,static,string,generate,multipart,boundary,string,return,new,string,generate,multipart,boundary,standard,charsets
MimeTypeUtils -> public static Optional<MimeType> getMimeType(String filename);1468513830;Returns the {@code MimeType} of the given file name, using the Java Activation_Framework._@param filename the filename whose mime type is to be found_@return the mime type, if any;public static Optional<MimeType> getMimeType(String filename) {_		if (filename != null) {_			String mimeType = fileTypeMap.getContentType(filename)__			if (StringUtils.hasText(mimeType)) {_				return Optional.of(parseMimeType(mimeType))__			}_		}_		return Optional.empty()__	};returns,the,code,mime,type,of,the,given,file,name,using,the,java,activation,framework,param,filename,the,filename,whose,mime,type,is,to,be,found,return,the,mime,type,if,any;public,static,optional,mime,type,get,mime,type,string,filename,if,filename,null,string,mime,type,file,type,map,get,content,type,filename,if,string,utils,has,text,mime,type,return,optional,of,parse,mime,type,mime,type,return,optional,empty
MimeTypeUtils -> public static Optional<MimeType> getMimeType(String filename);1468532417;Returns the {@code MimeType} of the given file name, using the Java Activation_Framework._@param filename the filename whose mime type is to be found_@return the mime type, if any_@since 5.0;public static Optional<MimeType> getMimeType(String filename) {_		if (filename != null) {_			String mimeType = fileTypeMap.getContentType(filename)__			if (StringUtils.hasText(mimeType)) {_				return Optional.of(parseMimeType(mimeType))__			}_		}_		return Optional.empty()__	};returns,the,code,mime,type,of,the,given,file,name,using,the,java,activation,framework,param,filename,the,filename,whose,mime,type,is,to,be,found,return,the,mime,type,if,any,since,5,0;public,static,optional,mime,type,get,mime,type,string,filename,if,filename,null,string,mime,type,file,type,map,get,content,type,filename,if,string,utils,has,text,mime,type,return,optional,of,parse,mime,type,mime,type,return,optional,empty
MimeTypeUtils -> public static MimeType parseMimeType(String mimeType);1375896097;Parse the given String into a single {@code MimeType}._@param mimeType the string to parse_@return the mime type_@throws InvalidMimeTypeException if the string cannot be parsed;public static MimeType parseMimeType(String mimeType) {_		if (!StringUtils.hasLength(mimeType)) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}_		String[] parts = StringUtils.tokenizeToStringArray(mimeType, "_")___		String fullType = parts[0].trim()__		_		if (MimeType.WILDCARD_TYPE.equals(fullType)) {_			fullType = "*/*"__		}_		int subIndex = fullType.indexOf('/')__		if (subIndex == -1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain '/'")__		}_		if (subIndex == fullType.length() - 1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain subtype after '/'")__		}_		String type = fullType.substring(0, subIndex)__		String subtype = fullType.substring(subIndex + 1, fullType.length())__		if (MimeType.WILDCARD_TYPE.equals(type) && !MimeType.WILDCARD_TYPE.equals(subtype)) {_			throw new InvalidMimeTypeException(mimeType, "wildcard type is legal only in '*/*' (all mime types)")__		}__		Map<String, String> parameters = null__		if (parts.length > 1) {_			parameters = new LinkedHashMap<String, String>(parts.length - 1)__			for (int i = 1_ i < parts.length_ i++) {_				String parameter = parts[i]__				int eqIndex = parameter.indexOf('=')__				if (eqIndex != -1) {_					String attribute = parameter.substring(0, eqIndex)__					String value = parameter.substring(eqIndex + 1, parameter.length())__					parameters.put(attribute, value)__				}_			}_		}__		try {_			return new MimeType(type, subtype, parameters)__		}_		catch (UnsupportedCharsetException ex) {_			throw new InvalidMimeTypeException(mimeType, "unsupported charset '" + ex.getCharsetName() + "'")__		}_		catch (IllegalArgumentException ex) {_			throw new InvalidMimeTypeException(mimeType, ex.getMessage())__		}_	};parse,the,given,string,into,a,single,code,mime,type,param,mime,type,the,string,to,parse,return,the,mime,type,throws,invalid,mime,type,exception,if,the,string,cannot,be,parsed;public,static,mime,type,parse,mime,type,string,mime,type,if,string,utils,has,length,mime,type,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,string,parts,string,utils,tokenize,to,string,array,mime,type,string,full,type,parts,0,trim,if,mime,type,equals,full,type,full,type,int,sub,index,full,type,index,of,if,sub,index,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,if,sub,index,full,type,length,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,subtype,after,string,type,full,type,substring,0,sub,index,string,subtype,full,type,substring,sub,index,1,full,type,length,if,mime,type,equals,type,mime,type,equals,subtype,throw,new,invalid,mime,type,exception,mime,type,wildcard,type,is,legal,only,in,all,mime,types,map,string,string,parameters,null,if,parts,length,1,parameters,new,linked,hash,map,string,string,parts,length,1,for,int,i,1,i,parts,length,i,string,parameter,parts,i,int,eq,index,parameter,index,of,if,eq,index,1,string,attribute,parameter,substring,0,eq,index,string,value,parameter,substring,eq,index,1,parameter,length,parameters,put,attribute,value,try,return,new,mime,type,type,subtype,parameters,catch,unsupported,charset,exception,ex,throw,new,invalid,mime,type,exception,mime,type,unsupported,charset,ex,get,charset,name,catch,illegal,argument,exception,ex,throw,new,invalid,mime,type,exception,mime,type,ex,get,message
MimeTypeUtils -> public static MimeType parseMimeType(String mimeType);1385501137;Parse the given String into a single {@code MimeType}._@param mimeType the string to parse_@return the mime type_@throws InvalidMimeTypeException if the string cannot be parsed;public static MimeType parseMimeType(String mimeType) {_		if (!StringUtils.hasLength(mimeType)) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}_		String[] parts = StringUtils.tokenizeToStringArray(mimeType, "_")___		String fullType = parts[0].trim()__		_		if (MimeType.WILDCARD_TYPE.equals(fullType)) {_			fullType = "*/*"__		}_		int subIndex = fullType.indexOf('/')__		if (subIndex == -1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain '/'")__		}_		if (subIndex == fullType.length() - 1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain subtype after '/'")__		}_		String type = fullType.substring(0, subIndex)__		String subtype = fullType.substring(subIndex + 1, fullType.length())__		if (MimeType.WILDCARD_TYPE.equals(type) && !MimeType.WILDCARD_TYPE.equals(subtype)) {_			throw new InvalidMimeTypeException(mimeType, "wildcard type is legal only in '*/*' (all mime types)")__		}__		Map<String, String> parameters = null__		if (parts.length > 1) {_			parameters = new LinkedHashMap<String, String>(parts.length - 1)__			for (int i = 1_ i < parts.length_ i++) {_				String parameter = parts[i]__				int eqIndex = parameter.indexOf('=')__				if (eqIndex != -1) {_					String attribute = parameter.substring(0, eqIndex)__					String value = parameter.substring(eqIndex + 1, parameter.length())__					parameters.put(attribute, value)__				}_			}_		}__		try {_			return new MimeType(type, subtype, parameters)__		}_		catch (UnsupportedCharsetException ex) {_			throw new InvalidMimeTypeException(mimeType, "unsupported charset '" + ex.getCharsetName() + "'")__		}_		catch (IllegalArgumentException ex) {_			throw new InvalidMimeTypeException(mimeType, ex.getMessage())__		}_	};parse,the,given,string,into,a,single,code,mime,type,param,mime,type,the,string,to,parse,return,the,mime,type,throws,invalid,mime,type,exception,if,the,string,cannot,be,parsed;public,static,mime,type,parse,mime,type,string,mime,type,if,string,utils,has,length,mime,type,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,string,parts,string,utils,tokenize,to,string,array,mime,type,string,full,type,parts,0,trim,if,mime,type,equals,full,type,full,type,int,sub,index,full,type,index,of,if,sub,index,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,if,sub,index,full,type,length,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,subtype,after,string,type,full,type,substring,0,sub,index,string,subtype,full,type,substring,sub,index,1,full,type,length,if,mime,type,equals,type,mime,type,equals,subtype,throw,new,invalid,mime,type,exception,mime,type,wildcard,type,is,legal,only,in,all,mime,types,map,string,string,parameters,null,if,parts,length,1,parameters,new,linked,hash,map,string,string,parts,length,1,for,int,i,1,i,parts,length,i,string,parameter,parts,i,int,eq,index,parameter,index,of,if,eq,index,1,string,attribute,parameter,substring,0,eq,index,string,value,parameter,substring,eq,index,1,parameter,length,parameters,put,attribute,value,try,return,new,mime,type,type,subtype,parameters,catch,unsupported,charset,exception,ex,throw,new,invalid,mime,type,exception,mime,type,unsupported,charset,ex,get,charset,name,catch,illegal,argument,exception,ex,throw,new,invalid,mime,type,exception,mime,type,ex,get,message
MimeTypeUtils -> public static MimeType parseMimeType(String mimeType);1385507478;Parse the given String into a single {@code MimeType}._@param mimeType the string to parse_@return the mime type_@throws InvalidMimeTypeException if the string cannot be parsed;public static MimeType parseMimeType(String mimeType) {_		if (!StringUtils.hasLength(mimeType)) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}_		String[] parts = StringUtils.tokenizeToStringArray(mimeType, "_")___		String fullType = parts[0].trim()__		_		if (MimeType.WILDCARD_TYPE.equals(fullType)) {_			fullType = "*/*"__		}_		int subIndex = fullType.indexOf('/')__		if (subIndex == -1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain '/'")__		}_		if (subIndex == fullType.length() - 1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain subtype after '/'")__		}_		String type = fullType.substring(0, subIndex)__		String subtype = fullType.substring(subIndex + 1, fullType.length())__		if (MimeType.WILDCARD_TYPE.equals(type) && !MimeType.WILDCARD_TYPE.equals(subtype)) {_			throw new InvalidMimeTypeException(mimeType, "wildcard type is legal only in '*/*' (all mime types)")__		}__		Map<String, String> parameters = null__		if (parts.length > 1) {_			parameters = new LinkedHashMap<String, String>(parts.length - 1)__			for (int i = 1_ i < parts.length_ i++) {_				String parameter = parts[i]__				int eqIndex = parameter.indexOf('=')__				if (eqIndex != -1) {_					String attribute = parameter.substring(0, eqIndex)__					String value = parameter.substring(eqIndex + 1, parameter.length())__					parameters.put(attribute, value)__				}_			}_		}__		try {_			return new MimeType(type, subtype, parameters)__		}_		catch (UnsupportedCharsetException ex) {_			throw new InvalidMimeTypeException(mimeType, "unsupported charset '" + ex.getCharsetName() + "'")__		}_		catch (IllegalArgumentException ex) {_			throw new InvalidMimeTypeException(mimeType, ex.getMessage())__		}_	};parse,the,given,string,into,a,single,code,mime,type,param,mime,type,the,string,to,parse,return,the,mime,type,throws,invalid,mime,type,exception,if,the,string,cannot,be,parsed;public,static,mime,type,parse,mime,type,string,mime,type,if,string,utils,has,length,mime,type,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,string,parts,string,utils,tokenize,to,string,array,mime,type,string,full,type,parts,0,trim,if,mime,type,equals,full,type,full,type,int,sub,index,full,type,index,of,if,sub,index,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,if,sub,index,full,type,length,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,subtype,after,string,type,full,type,substring,0,sub,index,string,subtype,full,type,substring,sub,index,1,full,type,length,if,mime,type,equals,type,mime,type,equals,subtype,throw,new,invalid,mime,type,exception,mime,type,wildcard,type,is,legal,only,in,all,mime,types,map,string,string,parameters,null,if,parts,length,1,parameters,new,linked,hash,map,string,string,parts,length,1,for,int,i,1,i,parts,length,i,string,parameter,parts,i,int,eq,index,parameter,index,of,if,eq,index,1,string,attribute,parameter,substring,0,eq,index,string,value,parameter,substring,eq,index,1,parameter,length,parameters,put,attribute,value,try,return,new,mime,type,type,subtype,parameters,catch,unsupported,charset,exception,ex,throw,new,invalid,mime,type,exception,mime,type,unsupported,charset,ex,get,charset,name,catch,illegal,argument,exception,ex,throw,new,invalid,mime,type,exception,mime,type,ex,get,message
MimeTypeUtils -> public static MimeType parseMimeType(String mimeType);1407415845;Parse the given String into a single {@code MimeType}._@param mimeType the string to parse_@return the mime type_@throws InvalidMimeTypeException if the string cannot be parsed;public static MimeType parseMimeType(String mimeType) {_		if (!StringUtils.hasLength(mimeType)) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}_		String[] parts = StringUtils.tokenizeToStringArray(mimeType, "_")___		String fullType = parts[0].trim()__		_		if (MimeType.WILDCARD_TYPE.equals(fullType)) {_			fullType = "*/*"__		}_		int subIndex = fullType.indexOf('/')__		if (subIndex == -1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain '/'")__		}_		if (subIndex == fullType.length() - 1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain subtype after '/'")__		}_		String type = fullType.substring(0, subIndex)__		String subtype = fullType.substring(subIndex + 1, fullType.length())__		if (MimeType.WILDCARD_TYPE.equals(type) && !MimeType.WILDCARD_TYPE.equals(subtype)) {_			throw new InvalidMimeTypeException(mimeType, "wildcard type is legal only in '*/*' (all mime types)")__		}__		Map<String, String> parameters = null__		if (parts.length > 1) {_			parameters = new LinkedHashMap<String, String>(parts.length - 1)__			for (int i = 1_ i < parts.length_ i++) {_				String parameter = parts[i]__				int eqIndex = parameter.indexOf('=')__				if (eqIndex != -1) {_					String attribute = parameter.substring(0, eqIndex)__					String value = parameter.substring(eqIndex + 1, parameter.length())__					parameters.put(attribute, value)__				}_			}_		}__		try {_			return new MimeType(type, subtype, parameters)__		}_		catch (UnsupportedCharsetException ex) {_			throw new InvalidMimeTypeException(mimeType, "unsupported charset '" + ex.getCharsetName() + "'")__		}_		catch (IllegalArgumentException ex) {_			throw new InvalidMimeTypeException(mimeType, ex.getMessage())__		}_	};parse,the,given,string,into,a,single,code,mime,type,param,mime,type,the,string,to,parse,return,the,mime,type,throws,invalid,mime,type,exception,if,the,string,cannot,be,parsed;public,static,mime,type,parse,mime,type,string,mime,type,if,string,utils,has,length,mime,type,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,string,parts,string,utils,tokenize,to,string,array,mime,type,string,full,type,parts,0,trim,if,mime,type,equals,full,type,full,type,int,sub,index,full,type,index,of,if,sub,index,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,if,sub,index,full,type,length,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,subtype,after,string,type,full,type,substring,0,sub,index,string,subtype,full,type,substring,sub,index,1,full,type,length,if,mime,type,equals,type,mime,type,equals,subtype,throw,new,invalid,mime,type,exception,mime,type,wildcard,type,is,legal,only,in,all,mime,types,map,string,string,parameters,null,if,parts,length,1,parameters,new,linked,hash,map,string,string,parts,length,1,for,int,i,1,i,parts,length,i,string,parameter,parts,i,int,eq,index,parameter,index,of,if,eq,index,1,string,attribute,parameter,substring,0,eq,index,string,value,parameter,substring,eq,index,1,parameter,length,parameters,put,attribute,value,try,return,new,mime,type,type,subtype,parameters,catch,unsupported,charset,exception,ex,throw,new,invalid,mime,type,exception,mime,type,unsupported,charset,ex,get,charset,name,catch,illegal,argument,exception,ex,throw,new,invalid,mime,type,exception,mime,type,ex,get,message
MimeTypeUtils -> public static MimeType parseMimeType(String mimeType);1413848647;Parse the given String into a single {@code MimeType}._@param mimeType the string to parse_@return the mime type_@throws InvalidMimeTypeException if the string cannot be parsed;public static MimeType parseMimeType(String mimeType) {_		if (!StringUtils.hasLength(mimeType)) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}_		String[] parts = StringUtils.tokenizeToStringArray(mimeType, "_")___		String fullType = parts[0].trim()__		_		if (MimeType.WILDCARD_TYPE.equals(fullType)) {_			fullType = "*/*"__		}_		int subIndex = fullType.indexOf('/')__		if (subIndex == -1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain '/'")__		}_		if (subIndex == fullType.length() - 1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain subtype after '/'")__		}_		String type = fullType.substring(0, subIndex)__		String subtype = fullType.substring(subIndex + 1, fullType.length())__		if (MimeType.WILDCARD_TYPE.equals(type) && !MimeType.WILDCARD_TYPE.equals(subtype)) {_			throw new InvalidMimeTypeException(mimeType, "wildcard type is legal only in '*/*' (all mime types)")__		}__		Map<String, String> parameters = null__		if (parts.length > 1) {_			parameters = new LinkedHashMap<String, String>(parts.length - 1)__			for (int i = 1_ i < parts.length_ i++) {_				String parameter = parts[i]__				int eqIndex = parameter.indexOf('=')__				if (eqIndex != -1) {_					String attribute = parameter.substring(0, eqIndex)__					String value = parameter.substring(eqIndex + 1, parameter.length())__					parameters.put(attribute, value)__				}_			}_		}__		try {_			return new MimeType(type, subtype, parameters)__		}_		catch (UnsupportedCharsetException ex) {_			throw new InvalidMimeTypeException(mimeType, "unsupported charset '" + ex.getCharsetName() + "'")__		}_		catch (IllegalArgumentException ex) {_			throw new InvalidMimeTypeException(mimeType, ex.getMessage())__		}_	};parse,the,given,string,into,a,single,code,mime,type,param,mime,type,the,string,to,parse,return,the,mime,type,throws,invalid,mime,type,exception,if,the,string,cannot,be,parsed;public,static,mime,type,parse,mime,type,string,mime,type,if,string,utils,has,length,mime,type,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,string,parts,string,utils,tokenize,to,string,array,mime,type,string,full,type,parts,0,trim,if,mime,type,equals,full,type,full,type,int,sub,index,full,type,index,of,if,sub,index,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,if,sub,index,full,type,length,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,subtype,after,string,type,full,type,substring,0,sub,index,string,subtype,full,type,substring,sub,index,1,full,type,length,if,mime,type,equals,type,mime,type,equals,subtype,throw,new,invalid,mime,type,exception,mime,type,wildcard,type,is,legal,only,in,all,mime,types,map,string,string,parameters,null,if,parts,length,1,parameters,new,linked,hash,map,string,string,parts,length,1,for,int,i,1,i,parts,length,i,string,parameter,parts,i,int,eq,index,parameter,index,of,if,eq,index,1,string,attribute,parameter,substring,0,eq,index,string,value,parameter,substring,eq,index,1,parameter,length,parameters,put,attribute,value,try,return,new,mime,type,type,subtype,parameters,catch,unsupported,charset,exception,ex,throw,new,invalid,mime,type,exception,mime,type,unsupported,charset,ex,get,charset,name,catch,illegal,argument,exception,ex,throw,new,invalid,mime,type,exception,mime,type,ex,get,message
MimeTypeUtils -> public static MimeType parseMimeType(String mimeType);1426880143;Parse the given String into a single {@code MimeType}._@param mimeType the string to parse_@return the mime type_@throws InvalidMimeTypeException if the string cannot be parsed;public static MimeType parseMimeType(String mimeType) {_		if (!StringUtils.hasLength(mimeType)) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}_		String[] parts = StringUtils.tokenizeToStringArray(mimeType, "_")___		String fullType = parts[0].trim()__		_		if (MimeType.WILDCARD_TYPE.equals(fullType)) {_			fullType = "*/*"__		}_		int subIndex = fullType.indexOf('/')__		if (subIndex == -1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain '/'")__		}_		if (subIndex == fullType.length() - 1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain subtype after '/'")__		}_		String type = fullType.substring(0, subIndex)__		String subtype = fullType.substring(subIndex + 1, fullType.length())__		if (MimeType.WILDCARD_TYPE.equals(type) && !MimeType.WILDCARD_TYPE.equals(subtype)) {_			throw new InvalidMimeTypeException(mimeType, "wildcard type is legal only in '*/*' (all mime types)")__		}__		Map<String, String> parameters = null__		if (parts.length > 1) {_			parameters = new LinkedHashMap<String, String>(parts.length - 1)__			for (int i = 1_ i < parts.length_ i++) {_				String parameter = parts[i]__				int eqIndex = parameter.indexOf('=')__				if (eqIndex != -1) {_					String attribute = parameter.substring(0, eqIndex)__					String value = parameter.substring(eqIndex + 1, parameter.length())__					parameters.put(attribute, value)__				}_			}_		}__		try {_			return new MimeType(type, subtype, parameters)__		}_		catch (UnsupportedCharsetException ex) {_			throw new InvalidMimeTypeException(mimeType, "unsupported charset '" + ex.getCharsetName() + "'")__		}_		catch (IllegalArgumentException ex) {_			throw new InvalidMimeTypeException(mimeType, ex.getMessage())__		}_	};parse,the,given,string,into,a,single,code,mime,type,param,mime,type,the,string,to,parse,return,the,mime,type,throws,invalid,mime,type,exception,if,the,string,cannot,be,parsed;public,static,mime,type,parse,mime,type,string,mime,type,if,string,utils,has,length,mime,type,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,string,parts,string,utils,tokenize,to,string,array,mime,type,string,full,type,parts,0,trim,if,mime,type,equals,full,type,full,type,int,sub,index,full,type,index,of,if,sub,index,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,if,sub,index,full,type,length,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,subtype,after,string,type,full,type,substring,0,sub,index,string,subtype,full,type,substring,sub,index,1,full,type,length,if,mime,type,equals,type,mime,type,equals,subtype,throw,new,invalid,mime,type,exception,mime,type,wildcard,type,is,legal,only,in,all,mime,types,map,string,string,parameters,null,if,parts,length,1,parameters,new,linked,hash,map,string,string,parts,length,1,for,int,i,1,i,parts,length,i,string,parameter,parts,i,int,eq,index,parameter,index,of,if,eq,index,1,string,attribute,parameter,substring,0,eq,index,string,value,parameter,substring,eq,index,1,parameter,length,parameters,put,attribute,value,try,return,new,mime,type,type,subtype,parameters,catch,unsupported,charset,exception,ex,throw,new,invalid,mime,type,exception,mime,type,unsupported,charset,ex,get,charset,name,catch,illegal,argument,exception,ex,throw,new,invalid,mime,type,exception,mime,type,ex,get,message
MimeTypeUtils -> public static MimeType parseMimeType(String mimeType);1460988078;Parse the given String into a single {@code MimeType}._@param mimeType the string to parse_@return the mime type_@throws InvalidMimeTypeException if the string cannot be parsed;public static MimeType parseMimeType(String mimeType) {_		if (!StringUtils.hasLength(mimeType)) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}_		String[] parts = StringUtils.tokenizeToStringArray(mimeType, "_")__		if (parts.length == 0) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}__		String fullType = parts[0].trim()__		_		if (MimeType.WILDCARD_TYPE.equals(fullType)) {_			fullType = "*/*"__		}_		int subIndex = fullType.indexOf('/')__		if (subIndex == -1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain '/'")__		}_		if (subIndex == fullType.length() - 1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain subtype after '/'")__		}_		String type = fullType.substring(0, subIndex)__		String subtype = fullType.substring(subIndex + 1, fullType.length())__		if (MimeType.WILDCARD_TYPE.equals(type) && !MimeType.WILDCARD_TYPE.equals(subtype)) {_			throw new InvalidMimeTypeException(mimeType, "wildcard type is legal only in '*/*' (all mime types)")__		}__		Map<String, String> parameters = null__		if (parts.length > 1) {_			parameters = new LinkedHashMap<String, String>(parts.length - 1)__			for (int i = 1_ i < parts.length_ i++) {_				String parameter = parts[i]__				int eqIndex = parameter.indexOf('=')__				if (eqIndex != -1) {_					String attribute = parameter.substring(0, eqIndex)__					String value = parameter.substring(eqIndex + 1, parameter.length())__					parameters.put(attribute, value)__				}_			}_		}__		try {_			return new MimeType(type, subtype, parameters)__		}_		catch (UnsupportedCharsetException ex) {_			throw new InvalidMimeTypeException(mimeType, "unsupported charset '" + ex.getCharsetName() + "'")__		}_		catch (IllegalArgumentException ex) {_			throw new InvalidMimeTypeException(mimeType, ex.getMessage())__		}_	};parse,the,given,string,into,a,single,code,mime,type,param,mime,type,the,string,to,parse,return,the,mime,type,throws,invalid,mime,type,exception,if,the,string,cannot,be,parsed;public,static,mime,type,parse,mime,type,string,mime,type,if,string,utils,has,length,mime,type,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,string,parts,string,utils,tokenize,to,string,array,mime,type,if,parts,length,0,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,string,full,type,parts,0,trim,if,mime,type,equals,full,type,full,type,int,sub,index,full,type,index,of,if,sub,index,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,if,sub,index,full,type,length,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,subtype,after,string,type,full,type,substring,0,sub,index,string,subtype,full,type,substring,sub,index,1,full,type,length,if,mime,type,equals,type,mime,type,equals,subtype,throw,new,invalid,mime,type,exception,mime,type,wildcard,type,is,legal,only,in,all,mime,types,map,string,string,parameters,null,if,parts,length,1,parameters,new,linked,hash,map,string,string,parts,length,1,for,int,i,1,i,parts,length,i,string,parameter,parts,i,int,eq,index,parameter,index,of,if,eq,index,1,string,attribute,parameter,substring,0,eq,index,string,value,parameter,substring,eq,index,1,parameter,length,parameters,put,attribute,value,try,return,new,mime,type,type,subtype,parameters,catch,unsupported,charset,exception,ex,throw,new,invalid,mime,type,exception,mime,type,unsupported,charset,ex,get,charset,name,catch,illegal,argument,exception,ex,throw,new,invalid,mime,type,exception,mime,type,ex,get,message
MimeTypeUtils -> public static MimeType parseMimeType(String mimeType);1467730834;Parse the given String into a single {@code MimeType}._@param mimeType the string to parse_@return the mime type_@throws InvalidMimeTypeException if the string cannot be parsed;public static MimeType parseMimeType(String mimeType) {_		if (!StringUtils.hasLength(mimeType)) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}_		String[] parts = StringUtils.tokenizeToStringArray(mimeType, "_")__		if (parts.length == 0) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}__		String fullType = parts[0].trim()__		_		if (MimeType.WILDCARD_TYPE.equals(fullType)) {_			fullType = "*/*"__		}_		int subIndex = fullType.indexOf('/')__		if (subIndex == -1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain '/'")__		}_		if (subIndex == fullType.length() - 1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain subtype after '/'")__		}_		String type = fullType.substring(0, subIndex)__		String subtype = fullType.substring(subIndex + 1, fullType.length())__		if (MimeType.WILDCARD_TYPE.equals(type) && !MimeType.WILDCARD_TYPE.equals(subtype)) {_			throw new InvalidMimeTypeException(mimeType, "wildcard type is legal only in '*/*' (all mime types)")__		}__		Map<String, String> parameters = null__		if (parts.length > 1) {_			parameters = new LinkedHashMap<>(parts.length - 1)__			for (int i = 1_ i < parts.length_ i++) {_				String parameter = parts[i]__				int eqIndex = parameter.indexOf('=')__				if (eqIndex != -1) {_					String attribute = parameter.substring(0, eqIndex)__					String value = parameter.substring(eqIndex + 1, parameter.length())__					parameters.put(attribute, value)__				}_			}_		}__		try {_			return new MimeType(type, subtype, parameters)__		}_		catch (UnsupportedCharsetException ex) {_			throw new InvalidMimeTypeException(mimeType, "unsupported charset '" + ex.getCharsetName() + "'")__		}_		catch (IllegalArgumentException ex) {_			throw new InvalidMimeTypeException(mimeType, ex.getMessage())__		}_	};parse,the,given,string,into,a,single,code,mime,type,param,mime,type,the,string,to,parse,return,the,mime,type,throws,invalid,mime,type,exception,if,the,string,cannot,be,parsed;public,static,mime,type,parse,mime,type,string,mime,type,if,string,utils,has,length,mime,type,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,string,parts,string,utils,tokenize,to,string,array,mime,type,if,parts,length,0,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,string,full,type,parts,0,trim,if,mime,type,equals,full,type,full,type,int,sub,index,full,type,index,of,if,sub,index,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,if,sub,index,full,type,length,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,subtype,after,string,type,full,type,substring,0,sub,index,string,subtype,full,type,substring,sub,index,1,full,type,length,if,mime,type,equals,type,mime,type,equals,subtype,throw,new,invalid,mime,type,exception,mime,type,wildcard,type,is,legal,only,in,all,mime,types,map,string,string,parameters,null,if,parts,length,1,parameters,new,linked,hash,map,parts,length,1,for,int,i,1,i,parts,length,i,string,parameter,parts,i,int,eq,index,parameter,index,of,if,eq,index,1,string,attribute,parameter,substring,0,eq,index,string,value,parameter,substring,eq,index,1,parameter,length,parameters,put,attribute,value,try,return,new,mime,type,type,subtype,parameters,catch,unsupported,charset,exception,ex,throw,new,invalid,mime,type,exception,mime,type,unsupported,charset,ex,get,charset,name,catch,illegal,argument,exception,ex,throw,new,invalid,mime,type,exception,mime,type,ex,get,message
MimeTypeUtils -> public static MimeType parseMimeType(String mimeType);1468513830;Parse the given String into a single {@code MimeType}._@param mimeType the string to parse_@return the mime type_@throws InvalidMimeTypeException if the string cannot be parsed;public static MimeType parseMimeType(String mimeType) {_		if (!StringUtils.hasLength(mimeType)) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}_		String[] parts = StringUtils.tokenizeToStringArray(mimeType, "_")__		if (parts.length == 0) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}__		String fullType = parts[0].trim()__		_		if (MimeType.WILDCARD_TYPE.equals(fullType)) {_			fullType = "*/*"__		}_		int subIndex = fullType.indexOf('/')__		if (subIndex == -1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain '/'")__		}_		if (subIndex == fullType.length() - 1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain subtype after '/'")__		}_		String type = fullType.substring(0, subIndex)__		String subtype = fullType.substring(subIndex + 1, fullType.length())__		if (MimeType.WILDCARD_TYPE.equals(type) && !MimeType.WILDCARD_TYPE.equals(subtype)) {_			throw new InvalidMimeTypeException(mimeType, "wildcard type is legal only in '*/*' (all mime types)")__		}__		Map<String, String> parameters = null__		if (parts.length > 1) {_			parameters = new LinkedHashMap<>(parts.length - 1)__			for (int i = 1_ i < parts.length_ i++) {_				String parameter = parts[i]__				int eqIndex = parameter.indexOf('=')__				if (eqIndex != -1) {_					String attribute = parameter.substring(0, eqIndex)__					String value = parameter.substring(eqIndex + 1, parameter.length())__					parameters.put(attribute, value)__				}_			}_		}__		try {_			return new MimeType(type, subtype, parameters)__		}_		catch (UnsupportedCharsetException ex) {_			throw new InvalidMimeTypeException(mimeType, "unsupported charset '" + ex.getCharsetName() + "'")__		}_		catch (IllegalArgumentException ex) {_			throw new InvalidMimeTypeException(mimeType, ex.getMessage())__		}_	};parse,the,given,string,into,a,single,code,mime,type,param,mime,type,the,string,to,parse,return,the,mime,type,throws,invalid,mime,type,exception,if,the,string,cannot,be,parsed;public,static,mime,type,parse,mime,type,string,mime,type,if,string,utils,has,length,mime,type,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,string,parts,string,utils,tokenize,to,string,array,mime,type,if,parts,length,0,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,string,full,type,parts,0,trim,if,mime,type,equals,full,type,full,type,int,sub,index,full,type,index,of,if,sub,index,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,if,sub,index,full,type,length,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,subtype,after,string,type,full,type,substring,0,sub,index,string,subtype,full,type,substring,sub,index,1,full,type,length,if,mime,type,equals,type,mime,type,equals,subtype,throw,new,invalid,mime,type,exception,mime,type,wildcard,type,is,legal,only,in,all,mime,types,map,string,string,parameters,null,if,parts,length,1,parameters,new,linked,hash,map,parts,length,1,for,int,i,1,i,parts,length,i,string,parameter,parts,i,int,eq,index,parameter,index,of,if,eq,index,1,string,attribute,parameter,substring,0,eq,index,string,value,parameter,substring,eq,index,1,parameter,length,parameters,put,attribute,value,try,return,new,mime,type,type,subtype,parameters,catch,unsupported,charset,exception,ex,throw,new,invalid,mime,type,exception,mime,type,unsupported,charset,ex,get,charset,name,catch,illegal,argument,exception,ex,throw,new,invalid,mime,type,exception,mime,type,ex,get,message
MimeTypeUtils -> public static MimeType parseMimeType(String mimeType);1468532417;Parse the given String into a single {@code MimeType}._@param mimeType the string to parse_@return the mime type_@throws InvalidMimeTypeException if the string cannot be parsed;public static MimeType parseMimeType(String mimeType) {_		if (!StringUtils.hasLength(mimeType)) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}_		String[] parts = StringUtils.tokenizeToStringArray(mimeType, "_")__		if (parts.length == 0) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}__		String fullType = parts[0].trim()__		_		if (MimeType.WILDCARD_TYPE.equals(fullType)) {_			fullType = "*/*"__		}_		int subIndex = fullType.indexOf('/')__		if (subIndex == -1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain '/'")__		}_		if (subIndex == fullType.length() - 1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain subtype after '/'")__		}_		String type = fullType.substring(0, subIndex)__		String subtype = fullType.substring(subIndex + 1, fullType.length())__		if (MimeType.WILDCARD_TYPE.equals(type) && !MimeType.WILDCARD_TYPE.equals(subtype)) {_			throw new InvalidMimeTypeException(mimeType, "wildcard type is legal only in '*/*' (all mime types)")__		}__		Map<String, String> parameters = null__		if (parts.length > 1) {_			parameters = new LinkedHashMap<>(parts.length - 1)__			for (int i = 1_ i < parts.length_ i++) {_				String parameter = parts[i]__				int eqIndex = parameter.indexOf('=')__				if (eqIndex != -1) {_					String attribute = parameter.substring(0, eqIndex)__					String value = parameter.substring(eqIndex + 1, parameter.length())__					parameters.put(attribute, value)__				}_			}_		}__		try {_			return new MimeType(type, subtype, parameters)__		}_		catch (UnsupportedCharsetException ex) {_			throw new InvalidMimeTypeException(mimeType, "unsupported charset '" + ex.getCharsetName() + "'")__		}_		catch (IllegalArgumentException ex) {_			throw new InvalidMimeTypeException(mimeType, ex.getMessage())__		}_	};parse,the,given,string,into,a,single,code,mime,type,param,mime,type,the,string,to,parse,return,the,mime,type,throws,invalid,mime,type,exception,if,the,string,cannot,be,parsed;public,static,mime,type,parse,mime,type,string,mime,type,if,string,utils,has,length,mime,type,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,string,parts,string,utils,tokenize,to,string,array,mime,type,if,parts,length,0,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,string,full,type,parts,0,trim,if,mime,type,equals,full,type,full,type,int,sub,index,full,type,index,of,if,sub,index,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,if,sub,index,full,type,length,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,subtype,after,string,type,full,type,substring,0,sub,index,string,subtype,full,type,substring,sub,index,1,full,type,length,if,mime,type,equals,type,mime,type,equals,subtype,throw,new,invalid,mime,type,exception,mime,type,wildcard,type,is,legal,only,in,all,mime,types,map,string,string,parameters,null,if,parts,length,1,parameters,new,linked,hash,map,parts,length,1,for,int,i,1,i,parts,length,i,string,parameter,parts,i,int,eq,index,parameter,index,of,if,eq,index,1,string,attribute,parameter,substring,0,eq,index,string,value,parameter,substring,eq,index,1,parameter,length,parameters,put,attribute,value,try,return,new,mime,type,type,subtype,parameters,catch,unsupported,charset,exception,ex,throw,new,invalid,mime,type,exception,mime,type,unsupported,charset,ex,get,charset,name,catch,illegal,argument,exception,ex,throw,new,invalid,mime,type,exception,mime,type,ex,get,message
MimeTypeUtils -> public static MimeType parseMimeType(String mimeType);1468947211;Parse the given String into a single {@code MimeType}._@param mimeType the string to parse_@return the mime type_@throws InvalidMimeTypeException if the string cannot be parsed;public static MimeType parseMimeType(String mimeType) {_		if (!StringUtils.hasLength(mimeType)) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}_		String[] parts = StringUtils.tokenizeToStringArray(mimeType, "_")__		if (parts.length == 0) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}__		String fullType = parts[0].trim()__		_		if (MimeType.WILDCARD_TYPE.equals(fullType)) {_			fullType = "*/*"__		}_		int subIndex = fullType.indexOf('/')__		if (subIndex == -1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain '/'")__		}_		if (subIndex == fullType.length() - 1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain subtype after '/'")__		}_		String type = fullType.substring(0, subIndex)__		String subtype = fullType.substring(subIndex + 1, fullType.length())__		if (MimeType.WILDCARD_TYPE.equals(type) && !MimeType.WILDCARD_TYPE.equals(subtype)) {_			throw new InvalidMimeTypeException(mimeType, "wildcard type is legal only in '*/*' (all mime types)")__		}__		Map<String, String> parameters = null__		if (parts.length > 1) {_			parameters = new LinkedHashMap<>(parts.length - 1)__			for (int i = 1_ i < parts.length_ i++) {_				String parameter = parts[i]__				int eqIndex = parameter.indexOf('=')__				if (eqIndex != -1) {_					String attribute = parameter.substring(0, eqIndex)__					String value = parameter.substring(eqIndex + 1, parameter.length())__					parameters.put(attribute, value)__				}_			}_		}__		try {_			return new MimeType(type, subtype, parameters)__		}_		catch (UnsupportedCharsetException ex) {_			throw new InvalidMimeTypeException(mimeType, "unsupported charset '" + ex.getCharsetName() + "'")__		}_		catch (IllegalArgumentException ex) {_			throw new InvalidMimeTypeException(mimeType, ex.getMessage())__		}_	};parse,the,given,string,into,a,single,code,mime,type,param,mime,type,the,string,to,parse,return,the,mime,type,throws,invalid,mime,type,exception,if,the,string,cannot,be,parsed;public,static,mime,type,parse,mime,type,string,mime,type,if,string,utils,has,length,mime,type,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,string,parts,string,utils,tokenize,to,string,array,mime,type,if,parts,length,0,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,string,full,type,parts,0,trim,if,mime,type,equals,full,type,full,type,int,sub,index,full,type,index,of,if,sub,index,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,if,sub,index,full,type,length,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,subtype,after,string,type,full,type,substring,0,sub,index,string,subtype,full,type,substring,sub,index,1,full,type,length,if,mime,type,equals,type,mime,type,equals,subtype,throw,new,invalid,mime,type,exception,mime,type,wildcard,type,is,legal,only,in,all,mime,types,map,string,string,parameters,null,if,parts,length,1,parameters,new,linked,hash,map,parts,length,1,for,int,i,1,i,parts,length,i,string,parameter,parts,i,int,eq,index,parameter,index,of,if,eq,index,1,string,attribute,parameter,substring,0,eq,index,string,value,parameter,substring,eq,index,1,parameter,length,parameters,put,attribute,value,try,return,new,mime,type,type,subtype,parameters,catch,unsupported,charset,exception,ex,throw,new,invalid,mime,type,exception,mime,type,unsupported,charset,ex,get,charset,name,catch,illegal,argument,exception,ex,throw,new,invalid,mime,type,exception,mime,type,ex,get,message
MimeTypeUtils -> public static MimeType parseMimeType(String mimeType);1472213779;Parse the given String into a single {@code MimeType}._@param mimeType the string to parse_@return the mime type_@throws InvalidMimeTypeException if the string cannot be parsed;public static MimeType parseMimeType(String mimeType) {_		if (!StringUtils.hasLength(mimeType)) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}_		String[] parts = StringUtils.tokenizeToStringArray(mimeType, "_")__		if (parts.length == 0) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}__		String fullType = parts[0].trim()__		_		if (MimeType.WILDCARD_TYPE.equals(fullType)) {_			fullType = "*/*"__		}_		int subIndex = fullType.indexOf('/')__		if (subIndex == -1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain '/'")__		}_		if (subIndex == fullType.length() - 1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain subtype after '/'")__		}_		String type = fullType.substring(0, subIndex)__		String subtype = fullType.substring(subIndex + 1, fullType.length())__		if (MimeType.WILDCARD_TYPE.equals(type) && !MimeType.WILDCARD_TYPE.equals(subtype)) {_			throw new InvalidMimeTypeException(mimeType, "wildcard type is legal only in '*/*' (all mime types)")__		}__		Map<String, String> parameters = null__		if (parts.length > 1) {_			parameters = new LinkedHashMap<>(parts.length - 1)__			for (int i = 1_ i < parts.length_ i++) {_				String parameter = parts[i]__				int eqIndex = parameter.indexOf('=')__				if (eqIndex != -1) {_					String attribute = parameter.substring(0, eqIndex)__					String value = parameter.substring(eqIndex + 1, parameter.length())__					parameters.put(attribute, value)__				}_			}_		}__		try {_			return new MimeType(type, subtype, parameters)__		}_		catch (UnsupportedCharsetException ex) {_			throw new InvalidMimeTypeException(mimeType, "unsupported charset '" + ex.getCharsetName() + "'")__		}_		catch (IllegalArgumentException ex) {_			throw new InvalidMimeTypeException(mimeType, ex.getMessage())__		}_	};parse,the,given,string,into,a,single,code,mime,type,param,mime,type,the,string,to,parse,return,the,mime,type,throws,invalid,mime,type,exception,if,the,string,cannot,be,parsed;public,static,mime,type,parse,mime,type,string,mime,type,if,string,utils,has,length,mime,type,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,string,parts,string,utils,tokenize,to,string,array,mime,type,if,parts,length,0,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,string,full,type,parts,0,trim,if,mime,type,equals,full,type,full,type,int,sub,index,full,type,index,of,if,sub,index,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,if,sub,index,full,type,length,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,subtype,after,string,type,full,type,substring,0,sub,index,string,subtype,full,type,substring,sub,index,1,full,type,length,if,mime,type,equals,type,mime,type,equals,subtype,throw,new,invalid,mime,type,exception,mime,type,wildcard,type,is,legal,only,in,all,mime,types,map,string,string,parameters,null,if,parts,length,1,parameters,new,linked,hash,map,parts,length,1,for,int,i,1,i,parts,length,i,string,parameter,parts,i,int,eq,index,parameter,index,of,if,eq,index,1,string,attribute,parameter,substring,0,eq,index,string,value,parameter,substring,eq,index,1,parameter,length,parameters,put,attribute,value,try,return,new,mime,type,type,subtype,parameters,catch,unsupported,charset,exception,ex,throw,new,invalid,mime,type,exception,mime,type,unsupported,charset,ex,get,charset,name,catch,illegal,argument,exception,ex,throw,new,invalid,mime,type,exception,mime,type,ex,get,message
MimeTypeUtils -> public static MimeType parseMimeType(String mimeType);1472594218;Parse the given String into a single {@code MimeType}._@param mimeType the string to parse_@return the mime type_@throws InvalidMimeTypeException if the string cannot be parsed;public static MimeType parseMimeType(String mimeType) {_		if (!StringUtils.hasLength(mimeType)) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}_		String[] parts = StringUtils.tokenizeToStringArray(mimeType, "_")__		if (parts.length == 0) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}__		String fullType = parts[0].trim()__		_		if (MimeType.WILDCARD_TYPE.equals(fullType)) {_			fullType = "*/*"__		}_		int subIndex = fullType.indexOf('/')__		if (subIndex == -1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain '/'")__		}_		if (subIndex == fullType.length() - 1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain subtype after '/'")__		}_		String type = fullType.substring(0, subIndex)__		String subtype = fullType.substring(subIndex + 1, fullType.length())__		if (MimeType.WILDCARD_TYPE.equals(type) && !MimeType.WILDCARD_TYPE.equals(subtype)) {_			throw new InvalidMimeTypeException(mimeType, "wildcard type is legal only in '*/*' (all mime types)")__		}__		Map<String, String> parameters = null__		if (parts.length > 1) {_			parameters = new LinkedHashMap<>(parts.length - 1)__			for (int i = 1_ i < parts.length_ i++) {_				String parameter = parts[i]__				int eqIndex = parameter.indexOf('=')__				if (eqIndex != -1) {_					String attribute = parameter.substring(0, eqIndex)__					String value = parameter.substring(eqIndex + 1, parameter.length())__					parameters.put(attribute, value)__				}_			}_		}__		try {_			return new MimeType(type, subtype, parameters)__		}_		catch (UnsupportedCharsetException ex) {_			throw new InvalidMimeTypeException(mimeType, "unsupported charset '" + ex.getCharsetName() + "'")__		}_		catch (IllegalArgumentException ex) {_			throw new InvalidMimeTypeException(mimeType, ex.getMessage())__		}_	};parse,the,given,string,into,a,single,code,mime,type,param,mime,type,the,string,to,parse,return,the,mime,type,throws,invalid,mime,type,exception,if,the,string,cannot,be,parsed;public,static,mime,type,parse,mime,type,string,mime,type,if,string,utils,has,length,mime,type,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,string,parts,string,utils,tokenize,to,string,array,mime,type,if,parts,length,0,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,string,full,type,parts,0,trim,if,mime,type,equals,full,type,full,type,int,sub,index,full,type,index,of,if,sub,index,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,if,sub,index,full,type,length,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,subtype,after,string,type,full,type,substring,0,sub,index,string,subtype,full,type,substring,sub,index,1,full,type,length,if,mime,type,equals,type,mime,type,equals,subtype,throw,new,invalid,mime,type,exception,mime,type,wildcard,type,is,legal,only,in,all,mime,types,map,string,string,parameters,null,if,parts,length,1,parameters,new,linked,hash,map,parts,length,1,for,int,i,1,i,parts,length,i,string,parameter,parts,i,int,eq,index,parameter,index,of,if,eq,index,1,string,attribute,parameter,substring,0,eq,index,string,value,parameter,substring,eq,index,1,parameter,length,parameters,put,attribute,value,try,return,new,mime,type,type,subtype,parameters,catch,unsupported,charset,exception,ex,throw,new,invalid,mime,type,exception,mime,type,unsupported,charset,ex,get,charset,name,catch,illegal,argument,exception,ex,throw,new,invalid,mime,type,exception,mime,type,ex,get,message
MimeTypeUtils -> public static MimeType parseMimeType(String mimeType);1481292266;Parse the given String into a single {@code MimeType}._@param mimeType the string to parse_@return the mime type_@throws InvalidMimeTypeException if the string cannot be parsed;public static MimeType parseMimeType(String mimeType) {_		if (!StringUtils.hasLength(mimeType)) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}__		int index = mimeType.indexOf('_')__		String fullType = (index >= 0 ? mimeType.substring(0, index) : mimeType).trim()__		if (fullType.length() == 0) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}__		_		if (MimeType.WILDCARD_TYPE.equals(fullType)) {_			fullType = "*/*"__		}_		int subIndex = fullType.indexOf('/')__		if (subIndex == -1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain '/'")__		}_		if (subIndex == fullType.length() - 1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain subtype after '/'")__		}_		String type = fullType.substring(0, subIndex)__		String subtype = fullType.substring(subIndex + 1, fullType.length())__		if (MimeType.WILDCARD_TYPE.equals(type) && !MimeType.WILDCARD_TYPE.equals(subtype)) {_			throw new InvalidMimeTypeException(mimeType, "wildcard type is legal only in '*/*' (all mime types)")__		}__		Map<String, String> parameters = null__		do {_			int nextIndex = index + 1__			boolean quoted = false__			while (nextIndex < mimeType.length()) {_				char ch = mimeType.charAt(nextIndex)__				if (ch == '_') {_					if (!quoted) {_						break__					}_				}_				else if (ch == '"') {_					quoted = !quoted__				}_				nextIndex++__			}_			String parameter = mimeType.substring(index + 1, nextIndex).trim()__			if (parameter.length() > 0) {_				if (parameters == null) {_					parameters = new LinkedHashMap<>(4)__				}_				int eqIndex = parameter.indexOf('=')__				if (eqIndex >= 0) {_					String attribute = parameter.substring(0, eqIndex)__					String value = parameter.substring(eqIndex + 1, parameter.length())__					parameters.put(attribute, value)__				}_			}_			index = nextIndex__		}_		while (index < mimeType.length())___		try {_			return new MimeType(type, subtype, parameters)__		}_		catch (UnsupportedCharsetException ex) {_			throw new InvalidMimeTypeException(mimeType, "unsupported charset '" + ex.getCharsetName() + "'")__		}_		catch (IllegalArgumentException ex) {_			throw new InvalidMimeTypeException(mimeType, ex.getMessage())__		}_	};parse,the,given,string,into,a,single,code,mime,type,param,mime,type,the,string,to,parse,return,the,mime,type,throws,invalid,mime,type,exception,if,the,string,cannot,be,parsed;public,static,mime,type,parse,mime,type,string,mime,type,if,string,utils,has,length,mime,type,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,int,index,mime,type,index,of,string,full,type,index,0,mime,type,substring,0,index,mime,type,trim,if,full,type,length,0,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,if,mime,type,equals,full,type,full,type,int,sub,index,full,type,index,of,if,sub,index,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,if,sub,index,full,type,length,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,subtype,after,string,type,full,type,substring,0,sub,index,string,subtype,full,type,substring,sub,index,1,full,type,length,if,mime,type,equals,type,mime,type,equals,subtype,throw,new,invalid,mime,type,exception,mime,type,wildcard,type,is,legal,only,in,all,mime,types,map,string,string,parameters,null,do,int,next,index,index,1,boolean,quoted,false,while,next,index,mime,type,length,char,ch,mime,type,char,at,next,index,if,ch,if,quoted,break,else,if,ch,quoted,quoted,next,index,string,parameter,mime,type,substring,index,1,next,index,trim,if,parameter,length,0,if,parameters,null,parameters,new,linked,hash,map,4,int,eq,index,parameter,index,of,if,eq,index,0,string,attribute,parameter,substring,0,eq,index,string,value,parameter,substring,eq,index,1,parameter,length,parameters,put,attribute,value,index,next,index,while,index,mime,type,length,try,return,new,mime,type,type,subtype,parameters,catch,unsupported,charset,exception,ex,throw,new,invalid,mime,type,exception,mime,type,unsupported,charset,ex,get,charset,name,catch,illegal,argument,exception,ex,throw,new,invalid,mime,type,exception,mime,type,ex,get,message
MimeTypeUtils -> public static MimeType parseMimeType(String mimeType);1484249067;Parse the given String into a single {@code MimeType}._@param mimeType the string to parse_@return the mime type_@throws InvalidMimeTypeException if the string cannot be parsed;public static MimeType parseMimeType(String mimeType) {_		if (!StringUtils.hasLength(mimeType)) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}__		int index = mimeType.indexOf('_')__		String fullType = (index >= 0 ? mimeType.substring(0, index) : mimeType).trim()__		if (fullType.length() == 0) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}__		_		if (MimeType.WILDCARD_TYPE.equals(fullType)) {_			fullType = "*/*"__		}_		int subIndex = fullType.indexOf('/')__		if (subIndex == -1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain '/'")__		}_		if (subIndex == fullType.length() - 1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain subtype after '/'")__		}_		String type = fullType.substring(0, subIndex)__		String subtype = fullType.substring(subIndex + 1, fullType.length())__		if (MimeType.WILDCARD_TYPE.equals(type) && !MimeType.WILDCARD_TYPE.equals(subtype)) {_			throw new InvalidMimeTypeException(mimeType, "wildcard type is legal only in '*/*' (all mime types)")__		}__		Map<String, String> parameters = null__		do {_			int nextIndex = index + 1__			boolean quoted = false__			while (nextIndex < mimeType.length()) {_				char ch = mimeType.charAt(nextIndex)__				if (ch == '_') {_					if (!quoted) {_						break__					}_				}_				else if (ch == '"') {_					quoted = !quoted__				}_				nextIndex++__			}_			String parameter = mimeType.substring(index + 1, nextIndex).trim()__			if (parameter.length() > 0) {_				if (parameters == null) {_					parameters = new LinkedHashMap<>(4)__				}_				int eqIndex = parameter.indexOf('=')__				if (eqIndex >= 0) {_					String attribute = parameter.substring(0, eqIndex)__					String value = parameter.substring(eqIndex + 1, parameter.length())__					parameters.put(attribute, value)__				}_			}_			index = nextIndex__		}_		while (index < mimeType.length())___		try {_			return new MimeType(type, subtype, parameters)__		}_		catch (UnsupportedCharsetException ex) {_			throw new InvalidMimeTypeException(mimeType, "unsupported charset '" + ex.getCharsetName() + "'")__		}_		catch (IllegalArgumentException ex) {_			throw new InvalidMimeTypeException(mimeType, ex.getMessage())__		}_	};parse,the,given,string,into,a,single,code,mime,type,param,mime,type,the,string,to,parse,return,the,mime,type,throws,invalid,mime,type,exception,if,the,string,cannot,be,parsed;public,static,mime,type,parse,mime,type,string,mime,type,if,string,utils,has,length,mime,type,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,int,index,mime,type,index,of,string,full,type,index,0,mime,type,substring,0,index,mime,type,trim,if,full,type,length,0,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,if,mime,type,equals,full,type,full,type,int,sub,index,full,type,index,of,if,sub,index,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,if,sub,index,full,type,length,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,subtype,after,string,type,full,type,substring,0,sub,index,string,subtype,full,type,substring,sub,index,1,full,type,length,if,mime,type,equals,type,mime,type,equals,subtype,throw,new,invalid,mime,type,exception,mime,type,wildcard,type,is,legal,only,in,all,mime,types,map,string,string,parameters,null,do,int,next,index,index,1,boolean,quoted,false,while,next,index,mime,type,length,char,ch,mime,type,char,at,next,index,if,ch,if,quoted,break,else,if,ch,quoted,quoted,next,index,string,parameter,mime,type,substring,index,1,next,index,trim,if,parameter,length,0,if,parameters,null,parameters,new,linked,hash,map,4,int,eq,index,parameter,index,of,if,eq,index,0,string,attribute,parameter,substring,0,eq,index,string,value,parameter,substring,eq,index,1,parameter,length,parameters,put,attribute,value,index,next,index,while,index,mime,type,length,try,return,new,mime,type,type,subtype,parameters,catch,unsupported,charset,exception,ex,throw,new,invalid,mime,type,exception,mime,type,unsupported,charset,ex,get,charset,name,catch,illegal,argument,exception,ex,throw,new,invalid,mime,type,exception,mime,type,ex,get,message
MimeTypeUtils -> public static MimeType parseMimeType(String mimeType);1484260257;Parse the given String into a single {@code MimeType}._@param mimeType the string to parse_@return the mime type_@throws InvalidMimeTypeException if the string cannot be parsed;public static MimeType parseMimeType(String mimeType) {_		if (!StringUtils.hasLength(mimeType)) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}__		int index = mimeType.indexOf('_')__		String fullType = (index >= 0 ? mimeType.substring(0, index) : mimeType).trim()__		if (fullType.length() == 0) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}__		_		if (MimeType.WILDCARD_TYPE.equals(fullType)) {_			fullType = "*/*"__		}_		int subIndex = fullType.indexOf('/')__		if (subIndex == -1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain '/'")__		}_		if (subIndex == fullType.length() - 1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain subtype after '/'")__		}_		String type = fullType.substring(0, subIndex)__		String subtype = fullType.substring(subIndex + 1, fullType.length())__		if (MimeType.WILDCARD_TYPE.equals(type) && !MimeType.WILDCARD_TYPE.equals(subtype)) {_			throw new InvalidMimeTypeException(mimeType, "wildcard type is legal only in '*/*' (all mime types)")__		}__		Map<String, String> parameters = null__		do {_			int nextIndex = index + 1__			boolean quoted = false__			while (nextIndex < mimeType.length()) {_				char ch = mimeType.charAt(nextIndex)__				if (ch == '_') {_					if (!quoted) {_						break__					}_				}_				else if (ch == '"') {_					quoted = !quoted__				}_				nextIndex++__			}_			String parameter = mimeType.substring(index + 1, nextIndex).trim()__			if (parameter.length() > 0) {_				if (parameters == null) {_					parameters = new LinkedHashMap<>(4)__				}_				int eqIndex = parameter.indexOf('=')__				if (eqIndex >= 0) {_					String attribute = parameter.substring(0, eqIndex)__					String value = parameter.substring(eqIndex + 1, parameter.length())__					parameters.put(attribute, value)__				}_			}_			index = nextIndex__		}_		while (index < mimeType.length())___		try {_			return new MimeType(type, subtype, parameters)__		}_		catch (UnsupportedCharsetException ex) {_			throw new InvalidMimeTypeException(mimeType, "unsupported charset '" + ex.getCharsetName() + "'")__		}_		catch (IllegalArgumentException ex) {_			throw new InvalidMimeTypeException(mimeType, ex.getMessage())__		}_	};parse,the,given,string,into,a,single,code,mime,type,param,mime,type,the,string,to,parse,return,the,mime,type,throws,invalid,mime,type,exception,if,the,string,cannot,be,parsed;public,static,mime,type,parse,mime,type,string,mime,type,if,string,utils,has,length,mime,type,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,int,index,mime,type,index,of,string,full,type,index,0,mime,type,substring,0,index,mime,type,trim,if,full,type,length,0,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,if,mime,type,equals,full,type,full,type,int,sub,index,full,type,index,of,if,sub,index,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,if,sub,index,full,type,length,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,subtype,after,string,type,full,type,substring,0,sub,index,string,subtype,full,type,substring,sub,index,1,full,type,length,if,mime,type,equals,type,mime,type,equals,subtype,throw,new,invalid,mime,type,exception,mime,type,wildcard,type,is,legal,only,in,all,mime,types,map,string,string,parameters,null,do,int,next,index,index,1,boolean,quoted,false,while,next,index,mime,type,length,char,ch,mime,type,char,at,next,index,if,ch,if,quoted,break,else,if,ch,quoted,quoted,next,index,string,parameter,mime,type,substring,index,1,next,index,trim,if,parameter,length,0,if,parameters,null,parameters,new,linked,hash,map,4,int,eq,index,parameter,index,of,if,eq,index,0,string,attribute,parameter,substring,0,eq,index,string,value,parameter,substring,eq,index,1,parameter,length,parameters,put,attribute,value,index,next,index,while,index,mime,type,length,try,return,new,mime,type,type,subtype,parameters,catch,unsupported,charset,exception,ex,throw,new,invalid,mime,type,exception,mime,type,unsupported,charset,ex,get,charset,name,catch,illegal,argument,exception,ex,throw,new,invalid,mime,type,exception,mime,type,ex,get,message
MimeTypeUtils -> public static MimeType parseMimeType(String mimeType);1487760984;Parse the given String into a single {@code MimeType}._@param mimeType the string to parse_@return the mime type_@throws InvalidMimeTypeException if the string cannot be parsed;public static MimeType parseMimeType(String mimeType) {_		if (!StringUtils.hasLength(mimeType)) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}__		int index = mimeType.indexOf('_')__		String fullType = (index >= 0 ? mimeType.substring(0, index) : mimeType).trim()__		if (fullType.isEmpty()) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}__		_		if (MimeType.WILDCARD_TYPE.equals(fullType)) {_			fullType = "*/*"__		}_		int subIndex = fullType.indexOf('/')__		if (subIndex == -1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain '/'")__		}_		if (subIndex == fullType.length() - 1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain subtype after '/'")__		}_		String type = fullType.substring(0, subIndex)__		String subtype = fullType.substring(subIndex + 1, fullType.length())__		if (MimeType.WILDCARD_TYPE.equals(type) && !MimeType.WILDCARD_TYPE.equals(subtype)) {_			throw new InvalidMimeTypeException(mimeType, "wildcard type is legal only in '*/*' (all mime types)")__		}__		Map<String, String> parameters = null__		do {_			int nextIndex = index + 1__			boolean quoted = false__			while (nextIndex < mimeType.length()) {_				char ch = mimeType.charAt(nextIndex)__				if (ch == '_') {_					if (!quoted) {_						break__					}_				}_				else if (ch == '"') {_					quoted = !quoted__				}_				nextIndex++__			}_			String parameter = mimeType.substring(index + 1, nextIndex).trim()__			if (parameter.length() > 0) {_				if (parameters == null) {_					parameters = new LinkedHashMap<>(4)__				}_				int eqIndex = parameter.indexOf('=')__				if (eqIndex >= 0) {_					String attribute = parameter.substring(0, eqIndex)__					String value = parameter.substring(eqIndex + 1, parameter.length())__					parameters.put(attribute, value)__				}_			}_			index = nextIndex__		}_		while (index < mimeType.length())___		try {_			return new MimeType(type, subtype, parameters)__		}_		catch (UnsupportedCharsetException ex) {_			throw new InvalidMimeTypeException(mimeType, "unsupported charset '" + ex.getCharsetName() + "'")__		}_		catch (IllegalArgumentException ex) {_			throw new InvalidMimeTypeException(mimeType, ex.getMessage())__		}_	};parse,the,given,string,into,a,single,code,mime,type,param,mime,type,the,string,to,parse,return,the,mime,type,throws,invalid,mime,type,exception,if,the,string,cannot,be,parsed;public,static,mime,type,parse,mime,type,string,mime,type,if,string,utils,has,length,mime,type,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,int,index,mime,type,index,of,string,full,type,index,0,mime,type,substring,0,index,mime,type,trim,if,full,type,is,empty,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,if,mime,type,equals,full,type,full,type,int,sub,index,full,type,index,of,if,sub,index,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,if,sub,index,full,type,length,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,subtype,after,string,type,full,type,substring,0,sub,index,string,subtype,full,type,substring,sub,index,1,full,type,length,if,mime,type,equals,type,mime,type,equals,subtype,throw,new,invalid,mime,type,exception,mime,type,wildcard,type,is,legal,only,in,all,mime,types,map,string,string,parameters,null,do,int,next,index,index,1,boolean,quoted,false,while,next,index,mime,type,length,char,ch,mime,type,char,at,next,index,if,ch,if,quoted,break,else,if,ch,quoted,quoted,next,index,string,parameter,mime,type,substring,index,1,next,index,trim,if,parameter,length,0,if,parameters,null,parameters,new,linked,hash,map,4,int,eq,index,parameter,index,of,if,eq,index,0,string,attribute,parameter,substring,0,eq,index,string,value,parameter,substring,eq,index,1,parameter,length,parameters,put,attribute,value,index,next,index,while,index,mime,type,length,try,return,new,mime,type,type,subtype,parameters,catch,unsupported,charset,exception,ex,throw,new,invalid,mime,type,exception,mime,type,unsupported,charset,ex,get,charset,name,catch,illegal,argument,exception,ex,throw,new,invalid,mime,type,exception,mime,type,ex,get,message
MimeTypeUtils -> public static MimeType parseMimeType(String mimeType);1518772998;Parse the given String into a single {@code MimeType}._@param mimeType the string to parse_@return the mime type_@throws InvalidMimeTypeException if the string cannot be parsed;public static MimeType parseMimeType(String mimeType) {_		if (!StringUtils.hasLength(mimeType)) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}__		int index = mimeType.indexOf('_')__		String fullType = (index >= 0 ? mimeType.substring(0, index) : mimeType).trim()__		if (fullType.isEmpty()) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}__		_		if (MimeType.WILDCARD_TYPE.equals(fullType)) {_			fullType = "*/*"__		}_		int subIndex = fullType.indexOf('/')__		if (subIndex == -1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain '/'")__		}_		if (subIndex == fullType.length() - 1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain subtype after '/'")__		}_		String type = fullType.substring(0, subIndex)__		String subtype = fullType.substring(subIndex + 1, fullType.length())__		if (MimeType.WILDCARD_TYPE.equals(type) && !MimeType.WILDCARD_TYPE.equals(subtype)) {_			throw new InvalidMimeTypeException(mimeType, "wildcard type is legal only in '*/*' (all mime types)")__		}__		Map<String, String> parameters = null__		do {_			int nextIndex = index + 1__			boolean quoted = false__			while (nextIndex < mimeType.length()) {_				char ch = mimeType.charAt(nextIndex)__				if (ch == '_') {_					if (!quoted) {_						break__					}_				}_				else if (ch == '"') {_					quoted = !quoted__				}_				nextIndex++__			}_			String parameter = mimeType.substring(index + 1, nextIndex).trim()__			if (parameter.length() > 0) {_				if (parameters == null) {_					parameters = new LinkedHashMap<>(4)__				}_				int eqIndex = parameter.indexOf('=')__				if (eqIndex >= 0) {_					String attribute = parameter.substring(0, eqIndex)__					String value = parameter.substring(eqIndex + 1, parameter.length())__					parameters.put(attribute, value)__				}_			}_			index = nextIndex__		}_		while (index < mimeType.length())___		try {_			return new MimeType(type, subtype, parameters)__		}_		catch (UnsupportedCharsetException ex) {_			throw new InvalidMimeTypeException(mimeType, "unsupported charset '" + ex.getCharsetName() + "'")__		}_		catch (IllegalArgumentException ex) {_			throw new InvalidMimeTypeException(mimeType, ex.getMessage())__		}_	};parse,the,given,string,into,a,single,code,mime,type,param,mime,type,the,string,to,parse,return,the,mime,type,throws,invalid,mime,type,exception,if,the,string,cannot,be,parsed;public,static,mime,type,parse,mime,type,string,mime,type,if,string,utils,has,length,mime,type,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,int,index,mime,type,index,of,string,full,type,index,0,mime,type,substring,0,index,mime,type,trim,if,full,type,is,empty,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,if,mime,type,equals,full,type,full,type,int,sub,index,full,type,index,of,if,sub,index,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,if,sub,index,full,type,length,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,subtype,after,string,type,full,type,substring,0,sub,index,string,subtype,full,type,substring,sub,index,1,full,type,length,if,mime,type,equals,type,mime,type,equals,subtype,throw,new,invalid,mime,type,exception,mime,type,wildcard,type,is,legal,only,in,all,mime,types,map,string,string,parameters,null,do,int,next,index,index,1,boolean,quoted,false,while,next,index,mime,type,length,char,ch,mime,type,char,at,next,index,if,ch,if,quoted,break,else,if,ch,quoted,quoted,next,index,string,parameter,mime,type,substring,index,1,next,index,trim,if,parameter,length,0,if,parameters,null,parameters,new,linked,hash,map,4,int,eq,index,parameter,index,of,if,eq,index,0,string,attribute,parameter,substring,0,eq,index,string,value,parameter,substring,eq,index,1,parameter,length,parameters,put,attribute,value,index,next,index,while,index,mime,type,length,try,return,new,mime,type,type,subtype,parameters,catch,unsupported,charset,exception,ex,throw,new,invalid,mime,type,exception,mime,type,unsupported,charset,ex,get,charset,name,catch,illegal,argument,exception,ex,throw,new,invalid,mime,type,exception,mime,type,ex,get,message
MimeTypeUtils -> public static MimeType parseMimeType(String mimeType);1520528267;Parse the given String into a single {@code MimeType}._@param mimeType the string to parse_@return the mime type_@throws InvalidMimeTypeException if the string cannot be parsed;public static MimeType parseMimeType(String mimeType) {_		if (!StringUtils.hasLength(mimeType)) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}__		int index = mimeType.indexOf('_')__		String fullType = (index >= 0 ? mimeType.substring(0, index) : mimeType).trim()__		if (fullType.isEmpty()) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}__		_		if (MimeType.WILDCARD_TYPE.equals(fullType)) {_			fullType = "*/*"__		}_		int subIndex = fullType.indexOf('/')__		if (subIndex == -1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain '/'")__		}_		if (subIndex == fullType.length() - 1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain subtype after '/'")__		}_		String type = fullType.substring(0, subIndex)__		String subtype = fullType.substring(subIndex + 1, fullType.length())__		if (MimeType.WILDCARD_TYPE.equals(type) && !MimeType.WILDCARD_TYPE.equals(subtype)) {_			throw new InvalidMimeTypeException(mimeType, "wildcard type is legal only in '*/*' (all mime types)")__		}__		Map<String, String> parameters = null__		do {_			int nextIndex = index + 1__			boolean quoted = false__			while (nextIndex < mimeType.length()) {_				char ch = mimeType.charAt(nextIndex)__				if (ch == '_') {_					if (!quoted) {_						break__					}_				}_				else if (ch == '"') {_					quoted = !quoted__				}_				nextIndex++__			}_			String parameter = mimeType.substring(index + 1, nextIndex).trim()__			if (parameter.length() > 0) {_				if (parameters == null) {_					parameters = new LinkedHashMap<>(4)__				}_				int eqIndex = parameter.indexOf('=')__				if (eqIndex >= 0) {_					String attribute = parameter.substring(0, eqIndex)__					String value = parameter.substring(eqIndex + 1, parameter.length())__					parameters.put(attribute, value)__				}_			}_			index = nextIndex__		}_		while (index < mimeType.length())___		try {_			return new MimeType(type, subtype, parameters)__		}_		catch (UnsupportedCharsetException ex) {_			throw new InvalidMimeTypeException(mimeType, "unsupported charset '" + ex.getCharsetName() + "'")__		}_		catch (IllegalArgumentException ex) {_			throw new InvalidMimeTypeException(mimeType, ex.getMessage())__		}_	};parse,the,given,string,into,a,single,code,mime,type,param,mime,type,the,string,to,parse,return,the,mime,type,throws,invalid,mime,type,exception,if,the,string,cannot,be,parsed;public,static,mime,type,parse,mime,type,string,mime,type,if,string,utils,has,length,mime,type,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,int,index,mime,type,index,of,string,full,type,index,0,mime,type,substring,0,index,mime,type,trim,if,full,type,is,empty,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,if,mime,type,equals,full,type,full,type,int,sub,index,full,type,index,of,if,sub,index,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,if,sub,index,full,type,length,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,subtype,after,string,type,full,type,substring,0,sub,index,string,subtype,full,type,substring,sub,index,1,full,type,length,if,mime,type,equals,type,mime,type,equals,subtype,throw,new,invalid,mime,type,exception,mime,type,wildcard,type,is,legal,only,in,all,mime,types,map,string,string,parameters,null,do,int,next,index,index,1,boolean,quoted,false,while,next,index,mime,type,length,char,ch,mime,type,char,at,next,index,if,ch,if,quoted,break,else,if,ch,quoted,quoted,next,index,string,parameter,mime,type,substring,index,1,next,index,trim,if,parameter,length,0,if,parameters,null,parameters,new,linked,hash,map,4,int,eq,index,parameter,index,of,if,eq,index,0,string,attribute,parameter,substring,0,eq,index,string,value,parameter,substring,eq,index,1,parameter,length,parameters,put,attribute,value,index,next,index,while,index,mime,type,length,try,return,new,mime,type,type,subtype,parameters,catch,unsupported,charset,exception,ex,throw,new,invalid,mime,type,exception,mime,type,unsupported,charset,ex,get,charset,name,catch,illegal,argument,exception,ex,throw,new,invalid,mime,type,exception,mime,type,ex,get,message
MimeTypeUtils -> public static MimeType parseMimeType(String mimeType);1521671173;Parse the given String into a single {@code MimeType}._@param mimeType the string to parse_@return the mime type_@throws InvalidMimeTypeException if the string cannot be parsed;public static MimeType parseMimeType(String mimeType) {_		if (!StringUtils.hasLength(mimeType)) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}__		int index = mimeType.indexOf('_')__		String fullType = (index >= 0 ? mimeType.substring(0, index) : mimeType).trim()__		if (fullType.isEmpty()) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}__		_		if (MimeType.WILDCARD_TYPE.equals(fullType)) {_			fullType = "*/*"__		}_		int subIndex = fullType.indexOf('/')__		if (subIndex == -1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain '/'")__		}_		if (subIndex == fullType.length() - 1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain subtype after '/'")__		}_		String type = fullType.substring(0, subIndex)__		String subtype = fullType.substring(subIndex + 1, fullType.length())__		if (MimeType.WILDCARD_TYPE.equals(type) && !MimeType.WILDCARD_TYPE.equals(subtype)) {_			throw new InvalidMimeTypeException(mimeType, "wildcard type is legal only in '*/*' (all mime types)")__		}__		Map<String, String> parameters = null__		do {_			int nextIndex = index + 1__			boolean quoted = false__			while (nextIndex < mimeType.length()) {_				char ch = mimeType.charAt(nextIndex)__				if (ch == '_') {_					if (!quoted) {_						break__					}_				}_				else if (ch == '"') {_					quoted = !quoted__				}_				nextIndex++__			}_			String parameter = mimeType.substring(index + 1, nextIndex).trim()__			if (parameter.length() > 0) {_				if (parameters == null) {_					parameters = new LinkedHashMap<>(4)__				}_				int eqIndex = parameter.indexOf('=')__				if (eqIndex >= 0) {_					String attribute = parameter.substring(0, eqIndex)__					String value = parameter.substring(eqIndex + 1, parameter.length())__					parameters.put(attribute, value)__				}_			}_			index = nextIndex__		}_		while (index < mimeType.length())___		try {_			return new MimeType(type, subtype, parameters)__		}_		catch (UnsupportedCharsetException ex) {_			throw new InvalidMimeTypeException(mimeType, "unsupported charset '" + ex.getCharsetName() + "'")__		}_		catch (IllegalArgumentException ex) {_			throw new InvalidMimeTypeException(mimeType, ex.getMessage())__		}_	};parse,the,given,string,into,a,single,code,mime,type,param,mime,type,the,string,to,parse,return,the,mime,type,throws,invalid,mime,type,exception,if,the,string,cannot,be,parsed;public,static,mime,type,parse,mime,type,string,mime,type,if,string,utils,has,length,mime,type,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,int,index,mime,type,index,of,string,full,type,index,0,mime,type,substring,0,index,mime,type,trim,if,full,type,is,empty,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,if,mime,type,equals,full,type,full,type,int,sub,index,full,type,index,of,if,sub,index,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,if,sub,index,full,type,length,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,subtype,after,string,type,full,type,substring,0,sub,index,string,subtype,full,type,substring,sub,index,1,full,type,length,if,mime,type,equals,type,mime,type,equals,subtype,throw,new,invalid,mime,type,exception,mime,type,wildcard,type,is,legal,only,in,all,mime,types,map,string,string,parameters,null,do,int,next,index,index,1,boolean,quoted,false,while,next,index,mime,type,length,char,ch,mime,type,char,at,next,index,if,ch,if,quoted,break,else,if,ch,quoted,quoted,next,index,string,parameter,mime,type,substring,index,1,next,index,trim,if,parameter,length,0,if,parameters,null,parameters,new,linked,hash,map,4,int,eq,index,parameter,index,of,if,eq,index,0,string,attribute,parameter,substring,0,eq,index,string,value,parameter,substring,eq,index,1,parameter,length,parameters,put,attribute,value,index,next,index,while,index,mime,type,length,try,return,new,mime,type,type,subtype,parameters,catch,unsupported,charset,exception,ex,throw,new,invalid,mime,type,exception,mime,type,unsupported,charset,ex,get,charset,name,catch,illegal,argument,exception,ex,throw,new,invalid,mime,type,exception,mime,type,ex,get,message
MimeTypeUtils -> public static MimeType parseMimeType(String mimeType);1521855941;Parse the given String into a single {@code MimeType}._@param mimeType the string to parse_@return the mime type_@throws InvalidMimeTypeException if the string cannot be parsed;public static MimeType parseMimeType(String mimeType) {_		if (!StringUtils.hasLength(mimeType)) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}__		int index = mimeType.indexOf('_')__		String fullType = (index >= 0 ? mimeType.substring(0, index) : mimeType).trim()__		if (fullType.isEmpty()) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}__		_		if (MimeType.WILDCARD_TYPE.equals(fullType)) {_			fullType = "*/*"__		}_		int subIndex = fullType.indexOf('/')__		if (subIndex == -1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain '/'")__		}_		if (subIndex == fullType.length() - 1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain subtype after '/'")__		}_		String type = fullType.substring(0, subIndex)__		String subtype = fullType.substring(subIndex + 1, fullType.length())__		if (MimeType.WILDCARD_TYPE.equals(type) && !MimeType.WILDCARD_TYPE.equals(subtype)) {_			throw new InvalidMimeTypeException(mimeType, "wildcard type is legal only in '*/*' (all mime types)")__		}__		Map<String, String> parameters = null__		do {_			int nextIndex = index + 1__			boolean quoted = false__			while (nextIndex < mimeType.length()) {_				char ch = mimeType.charAt(nextIndex)__				if (ch == '_') {_					if (!quoted) {_						break__					}_				}_				else if (ch == '"') {_					quoted = !quoted__				}_				nextIndex++__			}_			String parameter = mimeType.substring(index + 1, nextIndex).trim()__			if (parameter.length() > 0) {_				if (parameters == null) {_					parameters = new LinkedHashMap<>(4)__				}_				int eqIndex = parameter.indexOf('=')__				if (eqIndex >= 0) {_					String attribute = parameter.substring(0, eqIndex)__					String value = parameter.substring(eqIndex + 1, parameter.length())__					parameters.put(attribute, value)__				}_			}_			index = nextIndex__		}_		while (index < mimeType.length())___		try {_			return new MimeType(type, subtype, parameters)__		}_		catch (UnsupportedCharsetException ex) {_			throw new InvalidMimeTypeException(mimeType, "unsupported charset '" + ex.getCharsetName() + "'")__		}_		catch (IllegalArgumentException ex) {_			throw new InvalidMimeTypeException(mimeType, ex.getMessage())__		}_	};parse,the,given,string,into,a,single,code,mime,type,param,mime,type,the,string,to,parse,return,the,mime,type,throws,invalid,mime,type,exception,if,the,string,cannot,be,parsed;public,static,mime,type,parse,mime,type,string,mime,type,if,string,utils,has,length,mime,type,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,int,index,mime,type,index,of,string,full,type,index,0,mime,type,substring,0,index,mime,type,trim,if,full,type,is,empty,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,if,mime,type,equals,full,type,full,type,int,sub,index,full,type,index,of,if,sub,index,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,if,sub,index,full,type,length,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,subtype,after,string,type,full,type,substring,0,sub,index,string,subtype,full,type,substring,sub,index,1,full,type,length,if,mime,type,equals,type,mime,type,equals,subtype,throw,new,invalid,mime,type,exception,mime,type,wildcard,type,is,legal,only,in,all,mime,types,map,string,string,parameters,null,do,int,next,index,index,1,boolean,quoted,false,while,next,index,mime,type,length,char,ch,mime,type,char,at,next,index,if,ch,if,quoted,break,else,if,ch,quoted,quoted,next,index,string,parameter,mime,type,substring,index,1,next,index,trim,if,parameter,length,0,if,parameters,null,parameters,new,linked,hash,map,4,int,eq,index,parameter,index,of,if,eq,index,0,string,attribute,parameter,substring,0,eq,index,string,value,parameter,substring,eq,index,1,parameter,length,parameters,put,attribute,value,index,next,index,while,index,mime,type,length,try,return,new,mime,type,type,subtype,parameters,catch,unsupported,charset,exception,ex,throw,new,invalid,mime,type,exception,mime,type,unsupported,charset,ex,get,charset,name,catch,illegal,argument,exception,ex,throw,new,invalid,mime,type,exception,mime,type,ex,get,message
MimeTypeUtils -> public static MimeType parseMimeType(String mimeType);1522194969;Parse the given String into a single {@code MimeType}._@param mimeType the string to parse_@return the mime type_@throws InvalidMimeTypeException if the string cannot be parsed;public static MimeType parseMimeType(String mimeType) {_		if (!StringUtils.hasLength(mimeType)) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}__		int index = mimeType.indexOf('_')__		String fullType = (index >= 0 ? mimeType.substring(0, index) : mimeType).trim()__		if (fullType.isEmpty()) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}__		_		if (MimeType.WILDCARD_TYPE.equals(fullType)) {_			fullType = "*/*"__		}_		int subIndex = fullType.indexOf('/')__		if (subIndex == -1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain '/'")__		}_		if (subIndex == fullType.length() - 1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain subtype after '/'")__		}_		String type = fullType.substring(0, subIndex)__		String subtype = fullType.substring(subIndex + 1, fullType.length())__		if (MimeType.WILDCARD_TYPE.equals(type) && !MimeType.WILDCARD_TYPE.equals(subtype)) {_			throw new InvalidMimeTypeException(mimeType, "wildcard type is legal only in '*/*' (all mime types)")__		}__		Map<String, String> parameters = null__		do {_			int nextIndex = index + 1__			boolean quoted = false__			while (nextIndex < mimeType.length()) {_				char ch = mimeType.charAt(nextIndex)__				if (ch == '_') {_					if (!quoted) {_						break__					}_				}_				else if (ch == '"') {_					quoted = !quoted__				}_				nextIndex++__			}_			String parameter = mimeType.substring(index + 1, nextIndex).trim()__			if (parameter.length() > 0) {_				if (parameters == null) {_					parameters = new LinkedHashMap<>(4)__				}_				int eqIndex = parameter.indexOf('=')__				if (eqIndex >= 0) {_					String attribute = parameter.substring(0, eqIndex).trim()__					String value = parameter.substring(eqIndex + 1, parameter.length()).trim()__					parameters.put(attribute, value)__				}_			}_			index = nextIndex__		}_		while (index < mimeType.length())___		try {_			return new MimeType(type, subtype, parameters)__		}_		catch (UnsupportedCharsetException ex) {_			throw new InvalidMimeTypeException(mimeType, "unsupported charset '" + ex.getCharsetName() + "'")__		}_		catch (IllegalArgumentException ex) {_			throw new InvalidMimeTypeException(mimeType, ex.getMessage())__		}_	};parse,the,given,string,into,a,single,code,mime,type,param,mime,type,the,string,to,parse,return,the,mime,type,throws,invalid,mime,type,exception,if,the,string,cannot,be,parsed;public,static,mime,type,parse,mime,type,string,mime,type,if,string,utils,has,length,mime,type,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,int,index,mime,type,index,of,string,full,type,index,0,mime,type,substring,0,index,mime,type,trim,if,full,type,is,empty,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,if,mime,type,equals,full,type,full,type,int,sub,index,full,type,index,of,if,sub,index,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,if,sub,index,full,type,length,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,subtype,after,string,type,full,type,substring,0,sub,index,string,subtype,full,type,substring,sub,index,1,full,type,length,if,mime,type,equals,type,mime,type,equals,subtype,throw,new,invalid,mime,type,exception,mime,type,wildcard,type,is,legal,only,in,all,mime,types,map,string,string,parameters,null,do,int,next,index,index,1,boolean,quoted,false,while,next,index,mime,type,length,char,ch,mime,type,char,at,next,index,if,ch,if,quoted,break,else,if,ch,quoted,quoted,next,index,string,parameter,mime,type,substring,index,1,next,index,trim,if,parameter,length,0,if,parameters,null,parameters,new,linked,hash,map,4,int,eq,index,parameter,index,of,if,eq,index,0,string,attribute,parameter,substring,0,eq,index,trim,string,value,parameter,substring,eq,index,1,parameter,length,trim,parameters,put,attribute,value,index,next,index,while,index,mime,type,length,try,return,new,mime,type,type,subtype,parameters,catch,unsupported,charset,exception,ex,throw,new,invalid,mime,type,exception,mime,type,unsupported,charset,ex,get,charset,name,catch,illegal,argument,exception,ex,throw,new,invalid,mime,type,exception,mime,type,ex,get,message
MimeTypeUtils -> public static MimeType parseMimeType(String mimeType);1529943163;Parse the given String into a single {@code MimeType}._@param mimeType the string to parse_@return the mime type_@throws InvalidMimeTypeException if the string cannot be parsed;public static MimeType parseMimeType(String mimeType) {_		if (!StringUtils.hasLength(mimeType)) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}__		int index = mimeType.indexOf('_')__		String fullType = (index >= 0 ? mimeType.substring(0, index) : mimeType).trim()__		if (fullType.isEmpty()) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}__		_		if (MimeType.WILDCARD_TYPE.equals(fullType)) {_			fullType = "*/*"__		}_		int subIndex = fullType.indexOf('/')__		if (subIndex == -1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain '/'")__		}_		if (subIndex == fullType.length() - 1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain subtype after '/'")__		}_		String type = fullType.substring(0, subIndex)__		String subtype = fullType.substring(subIndex + 1, fullType.length())__		if (MimeType.WILDCARD_TYPE.equals(type) && !MimeType.WILDCARD_TYPE.equals(subtype)) {_			throw new InvalidMimeTypeException(mimeType, "wildcard type is legal only in '*/*' (all mime types)")__		}__		Map<String, String> parameters = null__		do {_			int nextIndex = index + 1__			boolean quoted = false__			while (nextIndex < mimeType.length()) {_				char ch = mimeType.charAt(nextIndex)__				if (ch == '_') {_					if (!quoted) {_						break__					}_				}_				else if (ch == '"') {_					quoted = !quoted__				}_				nextIndex++__			}_			String parameter = mimeType.substring(index + 1, nextIndex).trim()__			if (parameter.length() > 0) {_				if (parameters == null) {_					parameters = new LinkedHashMap<>(4)__				}_				int eqIndex = parameter.indexOf('=')__				if (eqIndex >= 0) {_					String attribute = parameter.substring(0, eqIndex).trim()__					String value = parameter.substring(eqIndex + 1, parameter.length()).trim()__					parameters.put(attribute, value)__				}_			}_			index = nextIndex__		}_		while (index < mimeType.length())___		try {_			return new MimeType(type, subtype, parameters)__		}_		catch (UnsupportedCharsetException ex) {_			throw new InvalidMimeTypeException(mimeType, "unsupported charset '" + ex.getCharsetName() + "'")__		}_		catch (IllegalArgumentException ex) {_			throw new InvalidMimeTypeException(mimeType, ex.getMessage())__		}_	};parse,the,given,string,into,a,single,code,mime,type,param,mime,type,the,string,to,parse,return,the,mime,type,throws,invalid,mime,type,exception,if,the,string,cannot,be,parsed;public,static,mime,type,parse,mime,type,string,mime,type,if,string,utils,has,length,mime,type,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,int,index,mime,type,index,of,string,full,type,index,0,mime,type,substring,0,index,mime,type,trim,if,full,type,is,empty,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,if,mime,type,equals,full,type,full,type,int,sub,index,full,type,index,of,if,sub,index,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,if,sub,index,full,type,length,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,subtype,after,string,type,full,type,substring,0,sub,index,string,subtype,full,type,substring,sub,index,1,full,type,length,if,mime,type,equals,type,mime,type,equals,subtype,throw,new,invalid,mime,type,exception,mime,type,wildcard,type,is,legal,only,in,all,mime,types,map,string,string,parameters,null,do,int,next,index,index,1,boolean,quoted,false,while,next,index,mime,type,length,char,ch,mime,type,char,at,next,index,if,ch,if,quoted,break,else,if,ch,quoted,quoted,next,index,string,parameter,mime,type,substring,index,1,next,index,trim,if,parameter,length,0,if,parameters,null,parameters,new,linked,hash,map,4,int,eq,index,parameter,index,of,if,eq,index,0,string,attribute,parameter,substring,0,eq,index,trim,string,value,parameter,substring,eq,index,1,parameter,length,trim,parameters,put,attribute,value,index,next,index,while,index,mime,type,length,try,return,new,mime,type,type,subtype,parameters,catch,unsupported,charset,exception,ex,throw,new,invalid,mime,type,exception,mime,type,unsupported,charset,ex,get,charset,name,catch,illegal,argument,exception,ex,throw,new,invalid,mime,type,exception,mime,type,ex,get,message
MimeTypeUtils -> public static MimeType parseMimeType(String mimeType);1542168307;Parse the given String into a single {@code MimeType}._@param mimeType the string to parse_@return the mime type_@throws InvalidMimeTypeException if the string cannot be parsed;public static MimeType parseMimeType(String mimeType) {_		if (!StringUtils.hasLength(mimeType)) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}__		int index = mimeType.indexOf('_')__		String fullType = (index >= 0 ? mimeType.substring(0, index) : mimeType).trim()__		if (fullType.isEmpty()) {_			throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty")__		}__		_		if (MimeType.WILDCARD_TYPE.equals(fullType)) {_			fullType = "*/*"__		}_		int subIndex = fullType.indexOf('/')__		if (subIndex == -1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain '/'")__		}_		if (subIndex == fullType.length() - 1) {_			throw new InvalidMimeTypeException(mimeType, "does not contain subtype after '/'")__		}_		String type = fullType.substring(0, subIndex)__		String subtype = fullType.substring(subIndex + 1, fullType.length())__		if (MimeType.WILDCARD_TYPE.equals(type) && !MimeType.WILDCARD_TYPE.equals(subtype)) {_			throw new InvalidMimeTypeException(mimeType, "wildcard type is legal only in '*/*' (all mime types)")__		}__		Map<String, String> parameters = null__		do {_			int nextIndex = index + 1__			boolean quoted = false__			while (nextIndex < mimeType.length()) {_				char ch = mimeType.charAt(nextIndex)__				if (ch == '_') {_					if (!quoted) {_						break__					}_				}_				else if (ch == '"') {_					quoted = !quoted__				}_				nextIndex++__			}_			String parameter = mimeType.substring(index + 1, nextIndex).trim()__			if (parameter.length() > 0) {_				if (parameters == null) {_					parameters = new LinkedHashMap<>(4)__				}_				int eqIndex = parameter.indexOf('=')__				if (eqIndex >= 0) {_					String attribute = parameter.substring(0, eqIndex).trim()__					String value = parameter.substring(eqIndex + 1, parameter.length()).trim()__					parameters.put(attribute, value)__				}_			}_			index = nextIndex__		}_		while (index < mimeType.length())___		try {_			return new MimeType(type, subtype, parameters)__		}_		catch (UnsupportedCharsetException ex) {_			throw new InvalidMimeTypeException(mimeType, "unsupported charset '" + ex.getCharsetName() + "'")__		}_		catch (IllegalArgumentException ex) {_			throw new InvalidMimeTypeException(mimeType, ex.getMessage())__		}_	};parse,the,given,string,into,a,single,code,mime,type,param,mime,type,the,string,to,parse,return,the,mime,type,throws,invalid,mime,type,exception,if,the,string,cannot,be,parsed;public,static,mime,type,parse,mime,type,string,mime,type,if,string,utils,has,length,mime,type,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,int,index,mime,type,index,of,string,full,type,index,0,mime,type,substring,0,index,mime,type,trim,if,full,type,is,empty,throw,new,invalid,mime,type,exception,mime,type,mime,type,must,not,be,empty,if,mime,type,equals,full,type,full,type,int,sub,index,full,type,index,of,if,sub,index,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,if,sub,index,full,type,length,1,throw,new,invalid,mime,type,exception,mime,type,does,not,contain,subtype,after,string,type,full,type,substring,0,sub,index,string,subtype,full,type,substring,sub,index,1,full,type,length,if,mime,type,equals,type,mime,type,equals,subtype,throw,new,invalid,mime,type,exception,mime,type,wildcard,type,is,legal,only,in,all,mime,types,map,string,string,parameters,null,do,int,next,index,index,1,boolean,quoted,false,while,next,index,mime,type,length,char,ch,mime,type,char,at,next,index,if,ch,if,quoted,break,else,if,ch,quoted,quoted,next,index,string,parameter,mime,type,substring,index,1,next,index,trim,if,parameter,length,0,if,parameters,null,parameters,new,linked,hash,map,4,int,eq,index,parameter,index,of,if,eq,index,0,string,attribute,parameter,substring,0,eq,index,trim,string,value,parameter,substring,eq,index,1,parameter,length,trim,parameters,put,attribute,value,index,next,index,while,index,mime,type,length,try,return,new,mime,type,type,subtype,parameters,catch,unsupported,charset,exception,ex,throw,new,invalid,mime,type,exception,mime,type,unsupported,charset,ex,get,charset,name,catch,illegal,argument,exception,ex,throw,new,invalid,mime,type,exception,mime,type,ex,get,message
MimeTypeUtils -> public static MimeType parseMimeType(String mimeType);1549373623;Parse the given String into a single {@code MimeType}._Recently parsed {@code MimeType} are cached for further retrieval._@param mimeType the string to parse_@return the mime type_@throws InvalidMimeTypeException if the string cannot be parsed;public static MimeType parseMimeType(String mimeType) {_		return CACHED_MIMETYPES.get(mimeType)__	};parse,the,given,string,into,a,single,code,mime,type,recently,parsed,code,mime,type,are,cached,for,further,retrieval,param,mime,type,the,string,to,parse,return,the,mime,type,throws,invalid,mime,type,exception,if,the,string,cannot,be,parsed;public,static,mime,type,parse,mime,type,string,mime,type,return,get,mime,type
MimeTypeUtils -> public static MimeType parseMimeType(String mimeType);1549375593;Parse the given String into a single {@code MimeType}._Recently parsed {@code MimeType} are cached for further retrieval._@param mimeType the string to parse_@return the mime type_@throws InvalidMimeTypeException if the string cannot be parsed;public static MimeType parseMimeType(String mimeType) {_		return CACHED_MIMETYPES.get(mimeType)__	};parse,the,given,string,into,a,single,code,mime,type,recently,parsed,code,mime,type,are,cached,for,further,retrieval,param,mime,type,the,string,to,parse,return,the,mime,type,throws,invalid,mime,type,exception,if,the,string,cannot,be,parsed;public,static,mime,type,parse,mime,type,string,mime,type,return,get,mime,type
MimeTypeUtils -> public static MimeType parseMimeType(String mimeType);1549377521;Parse the given String into a single {@code MimeType}._Recently parsed {@code MimeType} are cached for further retrieval._@param mimeType the string to parse_@return the mime type_@throws InvalidMimeTypeException if the string cannot be parsed;public static MimeType parseMimeType(String mimeType) {_		return cachedMimeTypes.get(mimeType)__	};parse,the,given,string,into,a,single,code,mime,type,recently,parsed,code,mime,type,are,cached,for,further,retrieval,param,mime,type,the,string,to,parse,return,the,mime,type,throws,invalid,mime,type,exception,if,the,string,cannot,be,parsed;public,static,mime,type,parse,mime,type,string,mime,type,return,cached,mime,types,get,mime,type
MimeTypeUtils -> public static MimeType parseMimeType(String mimeType);1549878350;Parse the given String into a single {@code MimeType}._Recently parsed {@code MimeType} are cached for further retrieval._@param mimeType the string to parse_@return the mime type_@throws InvalidMimeTypeException if the string cannot be parsed;public static MimeType parseMimeType(String mimeType) {_		return cachedMimeTypes.get(mimeType)__	};parse,the,given,string,into,a,single,code,mime,type,recently,parsed,code,mime,type,are,cached,for,further,retrieval,param,mime,type,the,string,to,parse,return,the,mime,type,throws,invalid,mime,type,exception,if,the,string,cannot,be,parsed;public,static,mime,type,parse,mime,type,string,mime,type,return,cached,mime,types,get,mime,type
MimeTypeUtils -> public static List<MimeType> parseMimeTypes(String mimeTypes);1375896097;Parse the given, comma-separated string into a list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the string cannot be parsed;public static List<MimeType> parseMimeTypes(String mimeTypes) {_		if (!StringUtils.hasLength(mimeTypes)) {_			return Collections.emptyList()__		}_		String[] tokens = mimeTypes.split(",\\s*")__		List<MimeType> result = new ArrayList<MimeType>(tokens.length)__		for (String token : tokens) {_			result.add(parseMimeType(token))__		}_		return result__	};parse,the,given,comma,separated,string,into,a,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,list,mime,type,parse,mime,types,string,mime,types,if,string,utils,has,length,mime,types,return,collections,empty,list,string,tokens,mime,types,split,s,list,mime,type,result,new,array,list,mime,type,tokens,length,for,string,token,tokens,result,add,parse,mime,type,token,return,result
MimeTypeUtils -> public static List<MimeType> parseMimeTypes(String mimeTypes);1385501137;Parse the given, comma-separated string into a list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the string cannot be parsed;public static List<MimeType> parseMimeTypes(String mimeTypes) {_		if (!StringUtils.hasLength(mimeTypes)) {_			return Collections.emptyList()__		}_		String[] tokens = mimeTypes.split(",\\s*")__		List<MimeType> result = new ArrayList<MimeType>(tokens.length)__		for (String token : tokens) {_			result.add(parseMimeType(token))__		}_		return result__	};parse,the,given,comma,separated,string,into,a,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,list,mime,type,parse,mime,types,string,mime,types,if,string,utils,has,length,mime,types,return,collections,empty,list,string,tokens,mime,types,split,s,list,mime,type,result,new,array,list,mime,type,tokens,length,for,string,token,tokens,result,add,parse,mime,type,token,return,result
MimeTypeUtils -> public static List<MimeType> parseMimeTypes(String mimeTypes);1385507478;Parse the given, comma-separated string into a list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the string cannot be parsed;public static List<MimeType> parseMimeTypes(String mimeTypes) {_		if (!StringUtils.hasLength(mimeTypes)) {_			return Collections.emptyList()__		}_		String[] tokens = mimeTypes.split(",\\s*")__		List<MimeType> result = new ArrayList<MimeType>(tokens.length)__		for (String token : tokens) {_			result.add(parseMimeType(token))__		}_		return result__	};parse,the,given,comma,separated,string,into,a,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,list,mime,type,parse,mime,types,string,mime,types,if,string,utils,has,length,mime,types,return,collections,empty,list,string,tokens,mime,types,split,s,list,mime,type,result,new,array,list,mime,type,tokens,length,for,string,token,tokens,result,add,parse,mime,type,token,return,result
MimeTypeUtils -> public static List<MimeType> parseMimeTypes(String mimeTypes);1407415845;Parse the given, comma-separated string into a list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the string cannot be parsed;public static List<MimeType> parseMimeTypes(String mimeTypes) {_		if (!StringUtils.hasLength(mimeTypes)) {_			return Collections.emptyList()__		}_		String[] tokens = mimeTypes.split(",\\s*")__		List<MimeType> result = new ArrayList<MimeType>(tokens.length)__		for (String token : tokens) {_			result.add(parseMimeType(token))__		}_		return result__	};parse,the,given,comma,separated,string,into,a,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,list,mime,type,parse,mime,types,string,mime,types,if,string,utils,has,length,mime,types,return,collections,empty,list,string,tokens,mime,types,split,s,list,mime,type,result,new,array,list,mime,type,tokens,length,for,string,token,tokens,result,add,parse,mime,type,token,return,result
MimeTypeUtils -> public static List<MimeType> parseMimeTypes(String mimeTypes);1413848647;Parse the given, comma-separated string into a list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the string cannot be parsed;public static List<MimeType> parseMimeTypes(String mimeTypes) {_		if (!StringUtils.hasLength(mimeTypes)) {_			return Collections.emptyList()__		}_		String[] tokens = mimeTypes.split(",\\s*")__		List<MimeType> result = new ArrayList<MimeType>(tokens.length)__		for (String token : tokens) {_			result.add(parseMimeType(token))__		}_		return result__	};parse,the,given,comma,separated,string,into,a,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,list,mime,type,parse,mime,types,string,mime,types,if,string,utils,has,length,mime,types,return,collections,empty,list,string,tokens,mime,types,split,s,list,mime,type,result,new,array,list,mime,type,tokens,length,for,string,token,tokens,result,add,parse,mime,type,token,return,result
MimeTypeUtils -> public static List<MimeType> parseMimeTypes(String mimeTypes);1426880143;Parse the given, comma-separated string into a list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the string cannot be parsed;public static List<MimeType> parseMimeTypes(String mimeTypes) {_		if (!StringUtils.hasLength(mimeTypes)) {_			return Collections.emptyList()__		}_		String[] tokens = mimeTypes.split(",\\s*")__		List<MimeType> result = new ArrayList<MimeType>(tokens.length)__		for (String token : tokens) {_			result.add(parseMimeType(token))__		}_		return result__	};parse,the,given,comma,separated,string,into,a,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,list,mime,type,parse,mime,types,string,mime,types,if,string,utils,has,length,mime,types,return,collections,empty,list,string,tokens,mime,types,split,s,list,mime,type,result,new,array,list,mime,type,tokens,length,for,string,token,tokens,result,add,parse,mime,type,token,return,result
MimeTypeUtils -> public static List<MimeType> parseMimeTypes(String mimeTypes);1460988078;Parse the given, comma-separated string into a list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the string cannot be parsed;public static List<MimeType> parseMimeTypes(String mimeTypes) {_		if (!StringUtils.hasLength(mimeTypes)) {_			return Collections.emptyList()__		}_		String[] tokens = mimeTypes.split(",\\s*")__		List<MimeType> result = new ArrayList<MimeType>(tokens.length)__		for (String token : tokens) {_			result.add(parseMimeType(token))__		}_		return result__	};parse,the,given,comma,separated,string,into,a,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,list,mime,type,parse,mime,types,string,mime,types,if,string,utils,has,length,mime,types,return,collections,empty,list,string,tokens,mime,types,split,s,list,mime,type,result,new,array,list,mime,type,tokens,length,for,string,token,tokens,result,add,parse,mime,type,token,return,result
MimeTypeUtils -> public static List<MimeType> parseMimeTypes(String mimeTypes);1467730834;Parse the given, comma-separated string into a list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the string cannot be parsed;public static List<MimeType> parseMimeTypes(String mimeTypes) {_		if (!StringUtils.hasLength(mimeTypes)) {_			return Collections.emptyList()__		}_		String[] tokens = mimeTypes.split(",\\s*")__		List<MimeType> result = new ArrayList<>(tokens.length)__		for (String token : tokens) {_			result.add(parseMimeType(token))__		}_		return result__	};parse,the,given,comma,separated,string,into,a,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,list,mime,type,parse,mime,types,string,mime,types,if,string,utils,has,length,mime,types,return,collections,empty,list,string,tokens,mime,types,split,s,list,mime,type,result,new,array,list,tokens,length,for,string,token,tokens,result,add,parse,mime,type,token,return,result
MimeTypeUtils -> public static List<MimeType> parseMimeTypes(String mimeTypes);1468513830;Parse the given, comma-separated string into a list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the string cannot be parsed;public static List<MimeType> parseMimeTypes(String mimeTypes) {_		if (!StringUtils.hasLength(mimeTypes)) {_			return Collections.emptyList()__		}_		String[] tokens = mimeTypes.split(",\\s*")__		List<MimeType> result = new ArrayList<>(tokens.length)__		for (String token : tokens) {_			result.add(parseMimeType(token))__		}_		return result__	};parse,the,given,comma,separated,string,into,a,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,list,mime,type,parse,mime,types,string,mime,types,if,string,utils,has,length,mime,types,return,collections,empty,list,string,tokens,mime,types,split,s,list,mime,type,result,new,array,list,tokens,length,for,string,token,tokens,result,add,parse,mime,type,token,return,result
MimeTypeUtils -> public static List<MimeType> parseMimeTypes(String mimeTypes);1468532417;Parse the given, comma-separated string into a list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the string cannot be parsed;public static List<MimeType> parseMimeTypes(String mimeTypes) {_		if (!StringUtils.hasLength(mimeTypes)) {_			return Collections.emptyList()__		}_		String[] tokens = mimeTypes.split(",\\s*")__		List<MimeType> result = new ArrayList<>(tokens.length)__		for (String token : tokens) {_			result.add(parseMimeType(token))__		}_		return result__	};parse,the,given,comma,separated,string,into,a,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,list,mime,type,parse,mime,types,string,mime,types,if,string,utils,has,length,mime,types,return,collections,empty,list,string,tokens,mime,types,split,s,list,mime,type,result,new,array,list,tokens,length,for,string,token,tokens,result,add,parse,mime,type,token,return,result
MimeTypeUtils -> public static List<MimeType> parseMimeTypes(String mimeTypes);1468947211;Parse the given, comma-separated string into a list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the string cannot be parsed;public static List<MimeType> parseMimeTypes(String mimeTypes) {_		if (!StringUtils.hasLength(mimeTypes)) {_			return Collections.emptyList()__		}_		String[] tokens = mimeTypes.split(",\\s*")__		List<MimeType> result = new ArrayList<>(tokens.length)__		for (String token : tokens) {_			result.add(parseMimeType(token))__		}_		return result__	};parse,the,given,comma,separated,string,into,a,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,list,mime,type,parse,mime,types,string,mime,types,if,string,utils,has,length,mime,types,return,collections,empty,list,string,tokens,mime,types,split,s,list,mime,type,result,new,array,list,tokens,length,for,string,token,tokens,result,add,parse,mime,type,token,return,result
MimeTypeUtils -> public static List<MimeType> parseMimeTypes(String mimeTypes);1472213779;Parse the given, comma-separated string into a list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the string cannot be parsed;public static List<MimeType> parseMimeTypes(String mimeTypes) {_		if (!StringUtils.hasLength(mimeTypes)) {_			return Collections.emptyList()__		}_		String[] tokens = mimeTypes.split(",\\s*")__		List<MimeType> result = new ArrayList<>(tokens.length)__		for (String token : tokens) {_			result.add(parseMimeType(token))__		}_		return result__	};parse,the,given,comma,separated,string,into,a,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,list,mime,type,parse,mime,types,string,mime,types,if,string,utils,has,length,mime,types,return,collections,empty,list,string,tokens,mime,types,split,s,list,mime,type,result,new,array,list,tokens,length,for,string,token,tokens,result,add,parse,mime,type,token,return,result
MimeTypeUtils -> public static List<MimeType> parseMimeTypes(String mimeTypes);1472594218;Parse the given, comma-separated string into a list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the string cannot be parsed;public static List<MimeType> parseMimeTypes(String mimeTypes) {_		if (!StringUtils.hasLength(mimeTypes)) {_			return Collections.emptyList()__		}_		String[] tokens = StringUtils.tokenizeToStringArray(mimeTypes, ",")__		List<MimeType> result = new ArrayList<>(tokens.length)__		for (String token : tokens) {_			result.add(parseMimeType(token))__		}_		return result__	};parse,the,given,comma,separated,string,into,a,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,list,mime,type,parse,mime,types,string,mime,types,if,string,utils,has,length,mime,types,return,collections,empty,list,string,tokens,string,utils,tokenize,to,string,array,mime,types,list,mime,type,result,new,array,list,tokens,length,for,string,token,tokens,result,add,parse,mime,type,token,return,result
MimeTypeUtils -> public static List<MimeType> parseMimeTypes(String mimeTypes);1481292266;Parse the given, comma-separated string into a list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the string cannot be parsed;public static List<MimeType> parseMimeTypes(String mimeTypes) {_		if (!StringUtils.hasLength(mimeTypes)) {_			return Collections.emptyList()__		}_		String[] tokens = StringUtils.tokenizeToStringArray(mimeTypes, ",")__		List<MimeType> result = new ArrayList<>(tokens.length)__		for (String token : tokens) {_			result.add(parseMimeType(token))__		}_		return result__	};parse,the,given,comma,separated,string,into,a,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,list,mime,type,parse,mime,types,string,mime,types,if,string,utils,has,length,mime,types,return,collections,empty,list,string,tokens,string,utils,tokenize,to,string,array,mime,types,list,mime,type,result,new,array,list,tokens,length,for,string,token,tokens,result,add,parse,mime,type,token,return,result
MimeTypeUtils -> public static List<MimeType> parseMimeTypes(String mimeTypes);1484249067;Parse the given, comma-separated string into a list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the string cannot be parsed;public static List<MimeType> parseMimeTypes(String mimeTypes) {_		if (!StringUtils.hasLength(mimeTypes)) {_			return Collections.emptyList()__		}_		String[] tokens = StringUtils.tokenizeToStringArray(mimeTypes, ",")__		List<MimeType> result = new ArrayList<>(tokens.length)__		for (String token : tokens) {_			result.add(parseMimeType(token))__		}_		return result__	};parse,the,given,comma,separated,string,into,a,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,list,mime,type,parse,mime,types,string,mime,types,if,string,utils,has,length,mime,types,return,collections,empty,list,string,tokens,string,utils,tokenize,to,string,array,mime,types,list,mime,type,result,new,array,list,tokens,length,for,string,token,tokens,result,add,parse,mime,type,token,return,result
MimeTypeUtils -> public static List<MimeType> parseMimeTypes(String mimeTypes);1484260257;Parse the given, comma-separated string into a list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the string cannot be parsed;public static List<MimeType> parseMimeTypes(String mimeTypes) {_		if (!StringUtils.hasLength(mimeTypes)) {_			return Collections.emptyList()__		}_		String[] tokens = StringUtils.tokenizeToStringArray(mimeTypes, ",")__		List<MimeType> result = new ArrayList<>(tokens.length)__		for (String token : tokens) {_			result.add(parseMimeType(token))__		}_		return result__	};parse,the,given,comma,separated,string,into,a,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,list,mime,type,parse,mime,types,string,mime,types,if,string,utils,has,length,mime,types,return,collections,empty,list,string,tokens,string,utils,tokenize,to,string,array,mime,types,list,mime,type,result,new,array,list,tokens,length,for,string,token,tokens,result,add,parse,mime,type,token,return,result
MimeTypeUtils -> public static List<MimeType> parseMimeTypes(String mimeTypes);1487760984;Parse the given, comma-separated string into a list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the string cannot be parsed;public static List<MimeType> parseMimeTypes(String mimeTypes) {_		if (!StringUtils.hasLength(mimeTypes)) {_			return Collections.emptyList()__		}_		String[] tokens = StringUtils.tokenizeToStringArray(mimeTypes, ",")__		List<MimeType> result = new ArrayList<>(tokens.length)__		for (String token : tokens) {_			result.add(parseMimeType(token))__		}_		return result__	};parse,the,given,comma,separated,string,into,a,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,list,mime,type,parse,mime,types,string,mime,types,if,string,utils,has,length,mime,types,return,collections,empty,list,string,tokens,string,utils,tokenize,to,string,array,mime,types,list,mime,type,result,new,array,list,tokens,length,for,string,token,tokens,result,add,parse,mime,type,token,return,result
MimeTypeUtils -> public static List<MimeType> parseMimeTypes(String mimeTypes);1518772998;Parse the given, comma-separated string into a list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the string cannot be parsed;public static List<MimeType> parseMimeTypes(String mimeTypes) {_		if (!StringUtils.hasLength(mimeTypes)) {_			return Collections.emptyList()__		}_		String[] tokens = StringUtils.tokenizeToStringArray(mimeTypes, ",")__		List<MimeType> result = new ArrayList<>(tokens.length)__		for (String token : tokens) {_			result.add(parseMimeType(token))__		}_		return result__	};parse,the,given,comma,separated,string,into,a,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,list,mime,type,parse,mime,types,string,mime,types,if,string,utils,has,length,mime,types,return,collections,empty,list,string,tokens,string,utils,tokenize,to,string,array,mime,types,list,mime,type,result,new,array,list,tokens,length,for,string,token,tokens,result,add,parse,mime,type,token,return,result
MimeTypeUtils -> public static List<MimeType> parseMimeTypes(String mimeTypes);1520528267;Parse the given, comma-separated string into a list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the string cannot be parsed;public static List<MimeType> parseMimeTypes(String mimeTypes) {_		if (!StringUtils.hasLength(mimeTypes)) {_			return Collections.emptyList()__		}_		String[] tokens = StringUtils.tokenizeToStringArray(mimeTypes, ",")__		List<MimeType> result = new ArrayList<>(tokens.length)__		for (String token : tokens) {_			result.add(parseMimeType(token))__		}_		return result__	};parse,the,given,comma,separated,string,into,a,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,list,mime,type,parse,mime,types,string,mime,types,if,string,utils,has,length,mime,types,return,collections,empty,list,string,tokens,string,utils,tokenize,to,string,array,mime,types,list,mime,type,result,new,array,list,tokens,length,for,string,token,tokens,result,add,parse,mime,type,token,return,result
MimeTypeUtils -> public static List<MimeType> parseMimeTypes(String mimeTypes);1521671173;Parse the given, comma-separated string into a list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the string cannot be parsed;public static List<MimeType> parseMimeTypes(String mimeTypes) {_		if (!StringUtils.hasLength(mimeTypes)) {_			return Collections.emptyList()__		}_		String[] tokens = StringUtils.tokenizeToStringArray(mimeTypes, ",")__		List<MimeType> result = new ArrayList<>(tokens.length)__		for (String token : tokens) {_			result.add(parseMimeType(token))__		}_		return result__	};parse,the,given,comma,separated,string,into,a,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,list,mime,type,parse,mime,types,string,mime,types,if,string,utils,has,length,mime,types,return,collections,empty,list,string,tokens,string,utils,tokenize,to,string,array,mime,types,list,mime,type,result,new,array,list,tokens,length,for,string,token,tokens,result,add,parse,mime,type,token,return,result
MimeTypeUtils -> public static List<MimeType> parseMimeTypes(String mimeTypes);1521855941;Parse the given, comma-separated string into a list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the string cannot be parsed;public static List<MimeType> parseMimeTypes(String mimeTypes) {_		if (!StringUtils.hasLength(mimeTypes)) {_			return Collections.emptyList()__		}_		String[] tokens = StringUtils.tokenizeToStringArray(mimeTypes, ",")__		List<MimeType> result = new ArrayList<>(tokens.length)__		for (String token : tokens) {_			result.add(parseMimeType(token))__		}_		return result__	};parse,the,given,comma,separated,string,into,a,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,list,mime,type,parse,mime,types,string,mime,types,if,string,utils,has,length,mime,types,return,collections,empty,list,string,tokens,string,utils,tokenize,to,string,array,mime,types,list,mime,type,result,new,array,list,tokens,length,for,string,token,tokens,result,add,parse,mime,type,token,return,result
MimeTypeUtils -> public static List<MimeType> parseMimeTypes(String mimeTypes);1522194969;Parse the given, comma-separated string into a list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the string cannot be parsed;public static List<MimeType> parseMimeTypes(String mimeTypes) {_		if (!StringUtils.hasLength(mimeTypes)) {_			return Collections.emptyList()__		}_		String[] tokens = StringUtils.tokenizeToStringArray(mimeTypes, ",")__		List<MimeType> result = new ArrayList<>(tokens.length)__		for (String token : tokens) {_			result.add(parseMimeType(token))__		}_		return result__	};parse,the,given,comma,separated,string,into,a,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,list,mime,type,parse,mime,types,string,mime,types,if,string,utils,has,length,mime,types,return,collections,empty,list,string,tokens,string,utils,tokenize,to,string,array,mime,types,list,mime,type,result,new,array,list,tokens,length,for,string,token,tokens,result,add,parse,mime,type,token,return,result
MimeTypeUtils -> public static List<MimeType> parseMimeTypes(String mimeTypes);1529943163;Parse the given, comma-separated string into a list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the string cannot be parsed;public static List<MimeType> parseMimeTypes(String mimeTypes) {_		if (!StringUtils.hasLength(mimeTypes)) {_			return Collections.emptyList()__		}_		String[] tokens = StringUtils.tokenizeToStringArray(mimeTypes, ",")__		List<MimeType> result = new ArrayList<>(tokens.length)__		for (String token : tokens) {_			result.add(parseMimeType(token))__		}_		return result__	};parse,the,given,comma,separated,string,into,a,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,list,mime,type,parse,mime,types,string,mime,types,if,string,utils,has,length,mime,types,return,collections,empty,list,string,tokens,string,utils,tokenize,to,string,array,mime,types,list,mime,type,result,new,array,list,tokens,length,for,string,token,tokens,result,add,parse,mime,type,token,return,result
MimeTypeUtils -> public static List<MimeType> parseMimeTypes(String mimeTypes);1542168307;Parse the comma-separated string into a list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws InvalidMimeTypeException if the string cannot be parsed;public static List<MimeType> parseMimeTypes(String mimeTypes) {_		if (!StringUtils.hasLength(mimeTypes)) {_			return Collections.emptyList()__		}_		return tokenize(mimeTypes).stream()_				.map(MimeTypeUtils::parseMimeType).collect(Collectors.toList())__	};parse,the,comma,separated,string,into,a,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,invalid,mime,type,exception,if,the,string,cannot,be,parsed;public,static,list,mime,type,parse,mime,types,string,mime,types,if,string,utils,has,length,mime,types,return,collections,empty,list,return,tokenize,mime,types,stream,map,mime,type,utils,parse,mime,type,collect,collectors,to,list
MimeTypeUtils -> public static List<MimeType> parseMimeTypes(String mimeTypes);1549373623;Parse the comma-separated string into a list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws InvalidMimeTypeException if the string cannot be parsed;public static List<MimeType> parseMimeTypes(String mimeTypes) {_		if (!StringUtils.hasLength(mimeTypes)) {_			return Collections.emptyList()__		}_		return tokenize(mimeTypes).stream()_				.map(MimeTypeUtils::parseMimeType).collect(Collectors.toList())__	};parse,the,comma,separated,string,into,a,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,invalid,mime,type,exception,if,the,string,cannot,be,parsed;public,static,list,mime,type,parse,mime,types,string,mime,types,if,string,utils,has,length,mime,types,return,collections,empty,list,return,tokenize,mime,types,stream,map,mime,type,utils,parse,mime,type,collect,collectors,to,list
MimeTypeUtils -> public static List<MimeType> parseMimeTypes(String mimeTypes);1549375593;Parse the comma-separated string into a list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws InvalidMimeTypeException if the string cannot be parsed;public static List<MimeType> parseMimeTypes(String mimeTypes) {_		if (!StringUtils.hasLength(mimeTypes)) {_			return Collections.emptyList()__		}_		return tokenize(mimeTypes).stream()_				.map(MimeTypeUtils::parseMimeType).collect(Collectors.toList())__	};parse,the,comma,separated,string,into,a,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,invalid,mime,type,exception,if,the,string,cannot,be,parsed;public,static,list,mime,type,parse,mime,types,string,mime,types,if,string,utils,has,length,mime,types,return,collections,empty,list,return,tokenize,mime,types,stream,map,mime,type,utils,parse,mime,type,collect,collectors,to,list
MimeTypeUtils -> public static List<MimeType> parseMimeTypes(String mimeTypes);1549377521;Parse the comma-separated string into a list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws InvalidMimeTypeException if the string cannot be parsed;public static List<MimeType> parseMimeTypes(String mimeTypes) {_		if (!StringUtils.hasLength(mimeTypes)) {_			return Collections.emptyList()__		}_		return tokenize(mimeTypes).stream()_				.map(MimeTypeUtils::parseMimeType).collect(Collectors.toList())__	};parse,the,comma,separated,string,into,a,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,invalid,mime,type,exception,if,the,string,cannot,be,parsed;public,static,list,mime,type,parse,mime,types,string,mime,types,if,string,utils,has,length,mime,types,return,collections,empty,list,return,tokenize,mime,types,stream,map,mime,type,utils,parse,mime,type,collect,collectors,to,list
MimeTypeUtils -> public static List<MimeType> parseMimeTypes(String mimeTypes);1549878350;Parse the comma-separated string into a list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws InvalidMimeTypeException if the string cannot be parsed;public static List<MimeType> parseMimeTypes(String mimeTypes) {_		if (!StringUtils.hasLength(mimeTypes)) {_			return Collections.emptyList()__		}_		return tokenize(mimeTypes).stream()_				.map(MimeTypeUtils::parseMimeType).collect(Collectors.toList())__	};parse,the,comma,separated,string,into,a,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,invalid,mime,type,exception,if,the,string,cannot,be,parsed;public,static,list,mime,type,parse,mime,types,string,mime,types,if,string,utils,has,length,mime,types,return,collections,empty,list,return,tokenize,mime,types,stream,map,mime,type,utils,parse,mime,type,collect,collectors,to,list
MimeTypeUtils -> public static byte[] generateMultipartBoundary();1426880143;Generate a random MIME boundary as bytes, often used in multipart mime types.;public static byte[] generateMultipartBoundary() {_		byte[] boundary = new byte[RND.nextInt(11) + 30]__		for (int i = 0_ i < boundary.length_ i++) {_			boundary[i] = BOUNDARY_CHARS[RND.nextInt(BOUNDARY_CHARS.length)]__		}_		return boundary__	};generate,a,random,mime,boundary,as,bytes,often,used,in,multipart,mime,types;public,static,byte,generate,multipart,boundary,byte,boundary,new,byte,rnd,next,int,11,30,for,int,i,0,i,boundary,length,i,boundary,i,rnd,next,int,length,return,boundary
MimeTypeUtils -> public static byte[] generateMultipartBoundary();1460988078;Generate a random MIME boundary as bytes, often used in multipart mime types.;public static byte[] generateMultipartBoundary() {_		byte[] boundary = new byte[RND.nextInt(11) + 30]__		for (int i = 0_ i < boundary.length_ i++) {_			boundary[i] = BOUNDARY_CHARS[RND.nextInt(BOUNDARY_CHARS.length)]__		}_		return boundary__	};generate,a,random,mime,boundary,as,bytes,often,used,in,multipart,mime,types;public,static,byte,generate,multipart,boundary,byte,boundary,new,byte,rnd,next,int,11,30,for,int,i,0,i,boundary,length,i,boundary,i,rnd,next,int,length,return,boundary
MimeTypeUtils -> public static byte[] generateMultipartBoundary();1467730834;Generate a random MIME boundary as bytes, often used in multipart mime types.;public static byte[] generateMultipartBoundary() {_		byte[] boundary = new byte[RND.nextInt(11) + 30]__		for (int i = 0_ i < boundary.length_ i++) {_			boundary[i] = BOUNDARY_CHARS[RND.nextInt(BOUNDARY_CHARS.length)]__		}_		return boundary__	};generate,a,random,mime,boundary,as,bytes,often,used,in,multipart,mime,types;public,static,byte,generate,multipart,boundary,byte,boundary,new,byte,rnd,next,int,11,30,for,int,i,0,i,boundary,length,i,boundary,i,rnd,next,int,length,return,boundary
MimeTypeUtils -> public static byte[] generateMultipartBoundary();1468513830;Generate a random MIME boundary as bytes, often used in multipart mime types.;public static byte[] generateMultipartBoundary() {_		byte[] boundary = new byte[RND.nextInt(11) + 30]__		for (int i = 0_ i < boundary.length_ i++) {_			boundary[i] = BOUNDARY_CHARS[RND.nextInt(BOUNDARY_CHARS.length)]__		}_		return boundary__	};generate,a,random,mime,boundary,as,bytes,often,used,in,multipart,mime,types;public,static,byte,generate,multipart,boundary,byte,boundary,new,byte,rnd,next,int,11,30,for,int,i,0,i,boundary,length,i,boundary,i,rnd,next,int,length,return,boundary
MimeTypeUtils -> public static byte[] generateMultipartBoundary();1468532417;Generate a random MIME boundary as bytes, often used in multipart mime types.;public static byte[] generateMultipartBoundary() {_		byte[] boundary = new byte[RND.nextInt(11) + 30]__		for (int i = 0_ i < boundary.length_ i++) {_			boundary[i] = BOUNDARY_CHARS[RND.nextInt(BOUNDARY_CHARS.length)]__		}_		return boundary__	};generate,a,random,mime,boundary,as,bytes,often,used,in,multipart,mime,types;public,static,byte,generate,multipart,boundary,byte,boundary,new,byte,rnd,next,int,11,30,for,int,i,0,i,boundary,length,i,boundary,i,rnd,next,int,length,return,boundary
MimeTypeUtils -> public static byte[] generateMultipartBoundary();1468947211;Generate a random MIME boundary as bytes, often used in multipart mime types.;public static byte[] generateMultipartBoundary() {_		byte[] boundary = new byte[RND.nextInt(11) + 30]__		for (int i = 0_ i < boundary.length_ i++) {_			boundary[i] = BOUNDARY_CHARS[RND.nextInt(BOUNDARY_CHARS.length)]__		}_		return boundary__	};generate,a,random,mime,boundary,as,bytes,often,used,in,multipart,mime,types;public,static,byte,generate,multipart,boundary,byte,boundary,new,byte,rnd,next,int,11,30,for,int,i,0,i,boundary,length,i,boundary,i,rnd,next,int,length,return,boundary
MimeTypeUtils -> public static byte[] generateMultipartBoundary();1472213779;Generate a random MIME boundary as bytes, often used in multipart mime types.;public static byte[] generateMultipartBoundary() {_		byte[] boundary = new byte[RND.nextInt(11) + 30]__		for (int i = 0_ i < boundary.length_ i++) {_			boundary[i] = BOUNDARY_CHARS[RND.nextInt(BOUNDARY_CHARS.length)]__		}_		return boundary__	};generate,a,random,mime,boundary,as,bytes,often,used,in,multipart,mime,types;public,static,byte,generate,multipart,boundary,byte,boundary,new,byte,rnd,next,int,11,30,for,int,i,0,i,boundary,length,i,boundary,i,rnd,next,int,length,return,boundary
MimeTypeUtils -> public static byte[] generateMultipartBoundary();1472594218;Generate a random MIME boundary as bytes, often used in multipart mime types.;public static byte[] generateMultipartBoundary() {_		byte[] boundary = new byte[RND.nextInt(11) + 30]__		for (int i = 0_ i < boundary.length_ i++) {_			boundary[i] = BOUNDARY_CHARS[RND.nextInt(BOUNDARY_CHARS.length)]__		}_		return boundary__	};generate,a,random,mime,boundary,as,bytes,often,used,in,multipart,mime,types;public,static,byte,generate,multipart,boundary,byte,boundary,new,byte,rnd,next,int,11,30,for,int,i,0,i,boundary,length,i,boundary,i,rnd,next,int,length,return,boundary
MimeTypeUtils -> public static byte[] generateMultipartBoundary();1481292266;Generate a random MIME boundary as bytes, often used in multipart mime types.;public static byte[] generateMultipartBoundary() {_		byte[] boundary = new byte[RND.nextInt(11) + 30]__		for (int i = 0_ i < boundary.length_ i++) {_			boundary[i] = BOUNDARY_CHARS[RND.nextInt(BOUNDARY_CHARS.length)]__		}_		return boundary__	};generate,a,random,mime,boundary,as,bytes,often,used,in,multipart,mime,types;public,static,byte,generate,multipart,boundary,byte,boundary,new,byte,rnd,next,int,11,30,for,int,i,0,i,boundary,length,i,boundary,i,rnd,next,int,length,return,boundary
MimeTypeUtils -> public static byte[] generateMultipartBoundary();1484249067;Generate a random MIME boundary as bytes, often used in multipart mime types.;public static byte[] generateMultipartBoundary() {_		byte[] boundary = new byte[RND.nextInt(11) + 30]__		for (int i = 0_ i < boundary.length_ i++) {_			boundary[i] = BOUNDARY_CHARS[RND.nextInt(BOUNDARY_CHARS.length)]__		}_		return boundary__	};generate,a,random,mime,boundary,as,bytes,often,used,in,multipart,mime,types;public,static,byte,generate,multipart,boundary,byte,boundary,new,byte,rnd,next,int,11,30,for,int,i,0,i,boundary,length,i,boundary,i,rnd,next,int,length,return,boundary
MimeTypeUtils -> public static byte[] generateMultipartBoundary();1484260257;Generate a random MIME boundary as bytes, often used in multipart mime types.;public static byte[] generateMultipartBoundary() {_		byte[] boundary = new byte[RND.nextInt(11) + 30]__		for (int i = 0_ i < boundary.length_ i++) {_			boundary[i] = BOUNDARY_CHARS[RND.nextInt(BOUNDARY_CHARS.length)]__		}_		return boundary__	};generate,a,random,mime,boundary,as,bytes,often,used,in,multipart,mime,types;public,static,byte,generate,multipart,boundary,byte,boundary,new,byte,rnd,next,int,11,30,for,int,i,0,i,boundary,length,i,boundary,i,rnd,next,int,length,return,boundary
MimeTypeUtils -> public static byte[] generateMultipartBoundary();1487760984;Generate a random MIME boundary as bytes, often used in multipart mime types.;public static byte[] generateMultipartBoundary() {_		byte[] boundary = new byte[RND.nextInt(11) + 30]__		for (int i = 0_ i < boundary.length_ i++) {_			boundary[i] = BOUNDARY_CHARS[RND.nextInt(BOUNDARY_CHARS.length)]__		}_		return boundary__	};generate,a,random,mime,boundary,as,bytes,often,used,in,multipart,mime,types;public,static,byte,generate,multipart,boundary,byte,boundary,new,byte,rnd,next,int,11,30,for,int,i,0,i,boundary,length,i,boundary,i,rnd,next,int,length,return,boundary
MimeTypeUtils -> public static byte[] generateMultipartBoundary();1518772998;Generate a random MIME boundary as bytes, often used in multipart mime types.;public static byte[] generateMultipartBoundary() {_		byte[] boundary = new byte[RND.nextInt(11) + 30]__		for (int i = 0_ i < boundary.length_ i++) {_			boundary[i] = BOUNDARY_CHARS[RND.nextInt(BOUNDARY_CHARS.length)]__		}_		return boundary__	};generate,a,random,mime,boundary,as,bytes,often,used,in,multipart,mime,types;public,static,byte,generate,multipart,boundary,byte,boundary,new,byte,rnd,next,int,11,30,for,int,i,0,i,boundary,length,i,boundary,i,rnd,next,int,length,return,boundary
MimeTypeUtils -> public static byte[] generateMultipartBoundary();1520528267;Generate a random MIME boundary as bytes, often used in multipart mime types.;public static byte[] generateMultipartBoundary() {_		byte[] boundary = new byte[RND.nextInt(11) + 30]__		for (int i = 0_ i < boundary.length_ i++) {_			boundary[i] = BOUNDARY_CHARS[RND.nextInt(BOUNDARY_CHARS.length)]__		}_		return boundary__	};generate,a,random,mime,boundary,as,bytes,often,used,in,multipart,mime,types;public,static,byte,generate,multipart,boundary,byte,boundary,new,byte,rnd,next,int,11,30,for,int,i,0,i,boundary,length,i,boundary,i,rnd,next,int,length,return,boundary
MimeTypeUtils -> public static byte[] generateMultipartBoundary();1521671173;Generate a random MIME boundary as bytes, often used in multipart mime types.;public static byte[] generateMultipartBoundary() {_		byte[] boundary = new byte[RND.nextInt(11) + 30]__		for (int i = 0_ i < boundary.length_ i++) {_			boundary[i] = BOUNDARY_CHARS[RND.nextInt(BOUNDARY_CHARS.length)]__		}_		return boundary__	};generate,a,random,mime,boundary,as,bytes,often,used,in,multipart,mime,types;public,static,byte,generate,multipart,boundary,byte,boundary,new,byte,rnd,next,int,11,30,for,int,i,0,i,boundary,length,i,boundary,i,rnd,next,int,length,return,boundary
MimeTypeUtils -> public static byte[] generateMultipartBoundary();1521855941;Generate a random MIME boundary as bytes, often used in multipart mime types.;public static byte[] generateMultipartBoundary() {_		byte[] boundary = new byte[RND.nextInt(11) + 30]__		for (int i = 0_ i < boundary.length_ i++) {_			boundary[i] = BOUNDARY_CHARS[RND.nextInt(BOUNDARY_CHARS.length)]__		}_		return boundary__	};generate,a,random,mime,boundary,as,bytes,often,used,in,multipart,mime,types;public,static,byte,generate,multipart,boundary,byte,boundary,new,byte,rnd,next,int,11,30,for,int,i,0,i,boundary,length,i,boundary,i,rnd,next,int,length,return,boundary
MimeTypeUtils -> public static byte[] generateMultipartBoundary();1522194969;Generate a random MIME boundary as bytes, often used in multipart mime types.;public static byte[] generateMultipartBoundary() {_		byte[] boundary = new byte[RND.nextInt(11) + 30]__		for (int i = 0_ i < boundary.length_ i++) {_			boundary[i] = BOUNDARY_CHARS[RND.nextInt(BOUNDARY_CHARS.length)]__		}_		return boundary__	};generate,a,random,mime,boundary,as,bytes,often,used,in,multipart,mime,types;public,static,byte,generate,multipart,boundary,byte,boundary,new,byte,rnd,next,int,11,30,for,int,i,0,i,boundary,length,i,boundary,i,rnd,next,int,length,return,boundary
MimeTypeUtils -> public static byte[] generateMultipartBoundary();1529943163;Generate a random MIME boundary as bytes, often used in multipart mime types.;public static byte[] generateMultipartBoundary() {_		Random randomToUse = initRandom()__		byte[] boundary = new byte[randomToUse.nextInt(11) + 30]__		for (int i = 0_ i < boundary.length_ i++) {_			boundary[i] = BOUNDARY_CHARS[randomToUse.nextInt(BOUNDARY_CHARS.length)]__		}_		return boundary__	};generate,a,random,mime,boundary,as,bytes,often,used,in,multipart,mime,types;public,static,byte,generate,multipart,boundary,random,random,to,use,init,random,byte,boundary,new,byte,random,to,use,next,int,11,30,for,int,i,0,i,boundary,length,i,boundary,i,random,to,use,next,int,length,return,boundary
MimeTypeUtils -> public static byte[] generateMultipartBoundary();1542168307;Generate a random MIME boundary as bytes, often used in multipart mime types.;public static byte[] generateMultipartBoundary() {_		Random randomToUse = initRandom()__		byte[] boundary = new byte[randomToUse.nextInt(11) + 30]__		for (int i = 0_ i < boundary.length_ i++) {_			boundary[i] = BOUNDARY_CHARS[randomToUse.nextInt(BOUNDARY_CHARS.length)]__		}_		return boundary__	};generate,a,random,mime,boundary,as,bytes,often,used,in,multipart,mime,types;public,static,byte,generate,multipart,boundary,random,random,to,use,init,random,byte,boundary,new,byte,random,to,use,next,int,11,30,for,int,i,0,i,boundary,length,i,boundary,i,random,to,use,next,int,length,return,boundary
MimeTypeUtils -> public static byte[] generateMultipartBoundary();1549373623;Generate a random MIME boundary as bytes, often used in multipart mime types.;public static byte[] generateMultipartBoundary() {_		Random randomToUse = initRandom()__		byte[] boundary = new byte[randomToUse.nextInt(11) + 30]__		for (int i = 0_ i < boundary.length_ i++) {_			boundary[i] = BOUNDARY_CHARS[randomToUse.nextInt(BOUNDARY_CHARS.length)]__		}_		return boundary__	};generate,a,random,mime,boundary,as,bytes,often,used,in,multipart,mime,types;public,static,byte,generate,multipart,boundary,random,random,to,use,init,random,byte,boundary,new,byte,random,to,use,next,int,11,30,for,int,i,0,i,boundary,length,i,boundary,i,random,to,use,next,int,length,return,boundary
MimeTypeUtils -> public static byte[] generateMultipartBoundary();1549375593;Generate a random MIME boundary as bytes, often used in multipart mime types.;public static byte[] generateMultipartBoundary() {_		Random randomToUse = initRandom()__		byte[] boundary = new byte[randomToUse.nextInt(11) + 30]__		for (int i = 0_ i < boundary.length_ i++) {_			boundary[i] = BOUNDARY_CHARS[randomToUse.nextInt(BOUNDARY_CHARS.length)]__		}_		return boundary__	};generate,a,random,mime,boundary,as,bytes,often,used,in,multipart,mime,types;public,static,byte,generate,multipart,boundary,random,random,to,use,init,random,byte,boundary,new,byte,random,to,use,next,int,11,30,for,int,i,0,i,boundary,length,i,boundary,i,random,to,use,next,int,length,return,boundary
MimeTypeUtils -> public static byte[] generateMultipartBoundary();1549377521;Generate a random MIME boundary as bytes, often used in multipart mime types.;public static byte[] generateMultipartBoundary() {_		Random randomToUse = initRandom()__		byte[] boundary = new byte[randomToUse.nextInt(11) + 30]__		for (int i = 0_ i < boundary.length_ i++) {_			boundary[i] = BOUNDARY_CHARS[randomToUse.nextInt(BOUNDARY_CHARS.length)]__		}_		return boundary__	};generate,a,random,mime,boundary,as,bytes,often,used,in,multipart,mime,types;public,static,byte,generate,multipart,boundary,random,random,to,use,init,random,byte,boundary,new,byte,random,to,use,next,int,11,30,for,int,i,0,i,boundary,length,i,boundary,i,random,to,use,next,int,length,return,boundary
MimeTypeUtils -> public static byte[] generateMultipartBoundary();1549878350;Generate a random MIME boundary as bytes, often used in multipart mime types.;public static byte[] generateMultipartBoundary() {_		Random randomToUse = initRandom()__		byte[] boundary = new byte[randomToUse.nextInt(11) + 30]__		for (int i = 0_ i < boundary.length_ i++) {_			boundary[i] = BOUNDARY_CHARS[randomToUse.nextInt(BOUNDARY_CHARS.length)]__		}_		return boundary__	};generate,a,random,mime,boundary,as,bytes,often,used,in,multipart,mime,types;public,static,byte,generate,multipart,boundary,random,random,to,use,init,random,byte,boundary,new,byte,random,to,use,next,int,11,30,for,int,i,0,i,boundary,length,i,boundary,i,random,to,use,next,int,length,return,boundary
MimeTypeUtils -> public static List<String> tokenize(String mimeTypes);1542168307;Tokenize the given comma-separated string of {@code MimeType} objects_into a {@code List<String>}. Unlike simple tokenization by ",", this_method takes into account quoted parameters._@param mimeTypes the string to tokenize_@return the list of tokens_@since 5.1.3;public static List<String> tokenize(String mimeTypes) {_		if (!StringUtils.hasLength(mimeTypes)) {_			return Collections.emptyList()__		}_		List<String> tokens = new ArrayList<>()__		boolean inQuotes = false__		int startIndex = 0__		int i = 0__		while (i < mimeTypes.length()) {_			switch (mimeTypes.charAt(i)) {_				case '"':_					inQuotes = !inQuotes__					break__				case ',':_					if (!inQuotes) {_						tokens.add(mimeTypes.substring(startIndex, i))__						startIndex = i + 1__					}_					break__				case '\\':_					i++__					break__			}_			i++__		}_		tokens.add(mimeTypes.substring(startIndex))__		return tokens__	};tokenize,the,given,comma,separated,string,of,code,mime,type,objects,into,a,code,list,string,unlike,simple,tokenization,by,this,method,takes,into,account,quoted,parameters,param,mime,types,the,string,to,tokenize,return,the,list,of,tokens,since,5,1,3;public,static,list,string,tokenize,string,mime,types,if,string,utils,has,length,mime,types,return,collections,empty,list,list,string,tokens,new,array,list,boolean,in,quotes,false,int,start,index,0,int,i,0,while,i,mime,types,length,switch,mime,types,char,at,i,case,in,quotes,in,quotes,break,case,if,in,quotes,tokens,add,mime,types,substring,start,index,i,start,index,i,1,break,case,i,break,i,tokens,add,mime,types,substring,start,index,return,tokens
MimeTypeUtils -> public static List<String> tokenize(String mimeTypes);1549373623;Tokenize the given comma-separated string of {@code MimeType} objects_into a {@code List<String>}. Unlike simple tokenization by ",", this_method takes into account quoted parameters._@param mimeTypes the string to tokenize_@return the list of tokens_@since 5.1.3;public static List<String> tokenize(String mimeTypes) {_		if (!StringUtils.hasLength(mimeTypes)) {_			return Collections.emptyList()__		}_		List<String> tokens = new ArrayList<>()__		boolean inQuotes = false__		int startIndex = 0__		int i = 0__		while (i < mimeTypes.length()) {_			switch (mimeTypes.charAt(i)) {_				case '"':_					inQuotes = !inQuotes__					break__				case ',':_					if (!inQuotes) {_						tokens.add(mimeTypes.substring(startIndex, i))__						startIndex = i + 1__					}_					break__				case '\\':_					i++__					break__			}_			i++__		}_		tokens.add(mimeTypes.substring(startIndex))__		return tokens__	};tokenize,the,given,comma,separated,string,of,code,mime,type,objects,into,a,code,list,string,unlike,simple,tokenization,by,this,method,takes,into,account,quoted,parameters,param,mime,types,the,string,to,tokenize,return,the,list,of,tokens,since,5,1,3;public,static,list,string,tokenize,string,mime,types,if,string,utils,has,length,mime,types,return,collections,empty,list,list,string,tokens,new,array,list,boolean,in,quotes,false,int,start,index,0,int,i,0,while,i,mime,types,length,switch,mime,types,char,at,i,case,in,quotes,in,quotes,break,case,if,in,quotes,tokens,add,mime,types,substring,start,index,i,start,index,i,1,break,case,i,break,i,tokens,add,mime,types,substring,start,index,return,tokens
MimeTypeUtils -> public static List<String> tokenize(String mimeTypes);1549375593;Tokenize the given comma-separated string of {@code MimeType} objects_into a {@code List<String>}. Unlike simple tokenization by ",", this_method takes into account quoted parameters._@param mimeTypes the string to tokenize_@return the list of tokens_@since 5.1.3;public static List<String> tokenize(String mimeTypes) {_		if (!StringUtils.hasLength(mimeTypes)) {_			return Collections.emptyList()__		}_		List<String> tokens = new ArrayList<>()__		boolean inQuotes = false__		int startIndex = 0__		int i = 0__		while (i < mimeTypes.length()) {_			switch (mimeTypes.charAt(i)) {_				case '"':_					inQuotes = !inQuotes__					break__				case ',':_					if (!inQuotes) {_						tokens.add(mimeTypes.substring(startIndex, i))__						startIndex = i + 1__					}_					break__				case '\\':_					i++__					break__			}_			i++__		}_		tokens.add(mimeTypes.substring(startIndex))__		return tokens__	};tokenize,the,given,comma,separated,string,of,code,mime,type,objects,into,a,code,list,string,unlike,simple,tokenization,by,this,method,takes,into,account,quoted,parameters,param,mime,types,the,string,to,tokenize,return,the,list,of,tokens,since,5,1,3;public,static,list,string,tokenize,string,mime,types,if,string,utils,has,length,mime,types,return,collections,empty,list,list,string,tokens,new,array,list,boolean,in,quotes,false,int,start,index,0,int,i,0,while,i,mime,types,length,switch,mime,types,char,at,i,case,in,quotes,in,quotes,break,case,if,in,quotes,tokens,add,mime,types,substring,start,index,i,start,index,i,1,break,case,i,break,i,tokens,add,mime,types,substring,start,index,return,tokens
MimeTypeUtils -> public static List<String> tokenize(String mimeTypes);1549377521;Tokenize the given comma-separated string of {@code MimeType} objects_into a {@code List<String>}. Unlike simple tokenization by ",", this_method takes into account quoted parameters._@param mimeTypes the string to tokenize_@return the list of tokens_@since 5.1.3;public static List<String> tokenize(String mimeTypes) {_		if (!StringUtils.hasLength(mimeTypes)) {_			return Collections.emptyList()__		}_		List<String> tokens = new ArrayList<>()__		boolean inQuotes = false__		int startIndex = 0__		int i = 0__		while (i < mimeTypes.length()) {_			switch (mimeTypes.charAt(i)) {_				case '"':_					inQuotes = !inQuotes__					break__				case ',':_					if (!inQuotes) {_						tokens.add(mimeTypes.substring(startIndex, i))__						startIndex = i + 1__					}_					break__				case '\\':_					i++__					break__			}_			i++__		}_		tokens.add(mimeTypes.substring(startIndex))__		return tokens__	};tokenize,the,given,comma,separated,string,of,code,mime,type,objects,into,a,code,list,string,unlike,simple,tokenization,by,this,method,takes,into,account,quoted,parameters,param,mime,types,the,string,to,tokenize,return,the,list,of,tokens,since,5,1,3;public,static,list,string,tokenize,string,mime,types,if,string,utils,has,length,mime,types,return,collections,empty,list,list,string,tokens,new,array,list,boolean,in,quotes,false,int,start,index,0,int,i,0,while,i,mime,types,length,switch,mime,types,char,at,i,case,in,quotes,in,quotes,break,case,if,in,quotes,tokens,add,mime,types,substring,start,index,i,start,index,i,1,break,case,i,break,i,tokens,add,mime,types,substring,start,index,return,tokens
MimeTypeUtils -> public static List<String> tokenize(String mimeTypes);1549878350;Tokenize the given comma-separated string of {@code MimeType} objects_into a {@code List<String>}. Unlike simple tokenization by ",", this_method takes into account quoted parameters._@param mimeTypes the string to tokenize_@return the list of tokens_@since 5.1.3;public static List<String> tokenize(String mimeTypes) {_		if (!StringUtils.hasLength(mimeTypes)) {_			return Collections.emptyList()__		}_		List<String> tokens = new ArrayList<>()__		boolean inQuotes = false__		int startIndex = 0__		int i = 0__		while (i < mimeTypes.length()) {_			switch (mimeTypes.charAt(i)) {_				case '"':_					inQuotes = !inQuotes__					break__				case ',':_					if (!inQuotes) {_						tokens.add(mimeTypes.substring(startIndex, i))__						startIndex = i + 1__					}_					break__				case '\\':_					i++__					break__			}_			i++__		}_		tokens.add(mimeTypes.substring(startIndex))__		return tokens__	};tokenize,the,given,comma,separated,string,of,code,mime,type,objects,into,a,code,list,string,unlike,simple,tokenization,by,this,method,takes,into,account,quoted,parameters,param,mime,types,the,string,to,tokenize,return,the,list,of,tokens,since,5,1,3;public,static,list,string,tokenize,string,mime,types,if,string,utils,has,length,mime,types,return,collections,empty,list,list,string,tokens,new,array,list,boolean,in,quotes,false,int,start,index,0,int,i,0,while,i,mime,types,length,switch,mime,types,char,at,i,case,in,quotes,in,quotes,break,case,if,in,quotes,tokens,add,mime,types,substring,start,index,i,start,index,i,1,break,case,i,break,i,tokens,add,mime,types,substring,start,index,return,tokens
MimeTypeUtils -> public static String toString(Collection<? extends MimeType> mimeTypes);1375896097;Return a string representation of the given list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the String cannot be parsed;public static String toString(Collection<? extends MimeType> mimeTypes) {_		StringBuilder builder = new StringBuilder()__		for (Iterator<? extends MimeType> iterator = mimeTypes.iterator()_ iterator.hasNext()_) {_			MimeType mimeType = iterator.next()__			mimeType.appendTo(builder)__			if (iterator.hasNext()) {_				builder.append(", ")__			}_		}_		return builder.toString()__	};return,a,string,representation,of,the,given,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,string,to,string,collection,extends,mime,type,mime,types,string,builder,builder,new,string,builder,for,iterator,extends,mime,type,iterator,mime,types,iterator,iterator,has,next,mime,type,mime,type,iterator,next,mime,type,append,to,builder,if,iterator,has,next,builder,append,return,builder,to,string
MimeTypeUtils -> public static String toString(Collection<? extends MimeType> mimeTypes);1385501137;Return a string representation of the given list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the String cannot be parsed;public static String toString(Collection<? extends MimeType> mimeTypes) {_		StringBuilder builder = new StringBuilder()__		for (Iterator<? extends MimeType> iterator = mimeTypes.iterator()_ iterator.hasNext()_) {_			MimeType mimeType = iterator.next()__			mimeType.appendTo(builder)__			if (iterator.hasNext()) {_				builder.append(", ")__			}_		}_		return builder.toString()__	};return,a,string,representation,of,the,given,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,string,to,string,collection,extends,mime,type,mime,types,string,builder,builder,new,string,builder,for,iterator,extends,mime,type,iterator,mime,types,iterator,iterator,has,next,mime,type,mime,type,iterator,next,mime,type,append,to,builder,if,iterator,has,next,builder,append,return,builder,to,string
MimeTypeUtils -> public static String toString(Collection<? extends MimeType> mimeTypes);1385507478;Return a string representation of the given list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the String cannot be parsed;public static String toString(Collection<? extends MimeType> mimeTypes) {_		StringBuilder builder = new StringBuilder()__		for (Iterator<? extends MimeType> iterator = mimeTypes.iterator()_ iterator.hasNext()_) {_			MimeType mimeType = iterator.next()__			mimeType.appendTo(builder)__			if (iterator.hasNext()) {_				builder.append(", ")__			}_		}_		return builder.toString()__	};return,a,string,representation,of,the,given,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,string,to,string,collection,extends,mime,type,mime,types,string,builder,builder,new,string,builder,for,iterator,extends,mime,type,iterator,mime,types,iterator,iterator,has,next,mime,type,mime,type,iterator,next,mime,type,append,to,builder,if,iterator,has,next,builder,append,return,builder,to,string
MimeTypeUtils -> public static String toString(Collection<? extends MimeType> mimeTypes);1407415845;Return a string representation of the given list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the String cannot be parsed;public static String toString(Collection<? extends MimeType> mimeTypes) {_		StringBuilder builder = new StringBuilder()__		for (Iterator<? extends MimeType> iterator = mimeTypes.iterator()_ iterator.hasNext()_) {_			MimeType mimeType = iterator.next()__			mimeType.appendTo(builder)__			if (iterator.hasNext()) {_				builder.append(", ")__			}_		}_		return builder.toString()__	};return,a,string,representation,of,the,given,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,string,to,string,collection,extends,mime,type,mime,types,string,builder,builder,new,string,builder,for,iterator,extends,mime,type,iterator,mime,types,iterator,iterator,has,next,mime,type,mime,type,iterator,next,mime,type,append,to,builder,if,iterator,has,next,builder,append,return,builder,to,string
MimeTypeUtils -> public static String toString(Collection<? extends MimeType> mimeTypes);1413848647;Return a string representation of the given list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the String cannot be parsed;public static String toString(Collection<? extends MimeType> mimeTypes) {_		StringBuilder builder = new StringBuilder()__		for (Iterator<? extends MimeType> iterator = mimeTypes.iterator()_ iterator.hasNext()_) {_			MimeType mimeType = iterator.next()__			mimeType.appendTo(builder)__			if (iterator.hasNext()) {_				builder.append(", ")__			}_		}_		return builder.toString()__	};return,a,string,representation,of,the,given,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,string,to,string,collection,extends,mime,type,mime,types,string,builder,builder,new,string,builder,for,iterator,extends,mime,type,iterator,mime,types,iterator,iterator,has,next,mime,type,mime,type,iterator,next,mime,type,append,to,builder,if,iterator,has,next,builder,append,return,builder,to,string
MimeTypeUtils -> public static String toString(Collection<? extends MimeType> mimeTypes);1426880143;Return a string representation of the given list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the String cannot be parsed;public static String toString(Collection<? extends MimeType> mimeTypes) {_		StringBuilder builder = new StringBuilder()__		for (Iterator<? extends MimeType> iterator = mimeTypes.iterator()_ iterator.hasNext()_) {_			MimeType mimeType = iterator.next()__			mimeType.appendTo(builder)__			if (iterator.hasNext()) {_				builder.append(", ")__			}_		}_		return builder.toString()__	};return,a,string,representation,of,the,given,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,string,to,string,collection,extends,mime,type,mime,types,string,builder,builder,new,string,builder,for,iterator,extends,mime,type,iterator,mime,types,iterator,iterator,has,next,mime,type,mime,type,iterator,next,mime,type,append,to,builder,if,iterator,has,next,builder,append,return,builder,to,string
MimeTypeUtils -> public static String toString(Collection<? extends MimeType> mimeTypes);1460988078;Return a string representation of the given list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the String cannot be parsed;public static String toString(Collection<? extends MimeType> mimeTypes) {_		StringBuilder builder = new StringBuilder()__		for (Iterator<? extends MimeType> iterator = mimeTypes.iterator()_ iterator.hasNext()_) {_			MimeType mimeType = iterator.next()__			mimeType.appendTo(builder)__			if (iterator.hasNext()) {_				builder.append(", ")__			}_		}_		return builder.toString()__	};return,a,string,representation,of,the,given,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,string,to,string,collection,extends,mime,type,mime,types,string,builder,builder,new,string,builder,for,iterator,extends,mime,type,iterator,mime,types,iterator,iterator,has,next,mime,type,mime,type,iterator,next,mime,type,append,to,builder,if,iterator,has,next,builder,append,return,builder,to,string
MimeTypeUtils -> public static String toString(Collection<? extends MimeType> mimeTypes);1467730834;Return a string representation of the given list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the String cannot be parsed;public static String toString(Collection<? extends MimeType> mimeTypes) {_		StringBuilder builder = new StringBuilder()__		for (Iterator<? extends MimeType> iterator = mimeTypes.iterator()_ iterator.hasNext()_) {_			MimeType mimeType = iterator.next()__			mimeType.appendTo(builder)__			if (iterator.hasNext()) {_				builder.append(", ")__			}_		}_		return builder.toString()__	};return,a,string,representation,of,the,given,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,string,to,string,collection,extends,mime,type,mime,types,string,builder,builder,new,string,builder,for,iterator,extends,mime,type,iterator,mime,types,iterator,iterator,has,next,mime,type,mime,type,iterator,next,mime,type,append,to,builder,if,iterator,has,next,builder,append,return,builder,to,string
MimeTypeUtils -> public static String toString(Collection<? extends MimeType> mimeTypes);1468513830;Return a string representation of the given list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the String cannot be parsed;public static String toString(Collection<? extends MimeType> mimeTypes) {_		StringBuilder builder = new StringBuilder()__		for (Iterator<? extends MimeType> iterator = mimeTypes.iterator()_ iterator.hasNext()_) {_			MimeType mimeType = iterator.next()__			mimeType.appendTo(builder)__			if (iterator.hasNext()) {_				builder.append(", ")__			}_		}_		return builder.toString()__	};return,a,string,representation,of,the,given,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,string,to,string,collection,extends,mime,type,mime,types,string,builder,builder,new,string,builder,for,iterator,extends,mime,type,iterator,mime,types,iterator,iterator,has,next,mime,type,mime,type,iterator,next,mime,type,append,to,builder,if,iterator,has,next,builder,append,return,builder,to,string
MimeTypeUtils -> public static String toString(Collection<? extends MimeType> mimeTypes);1468532417;Return a string representation of the given list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the String cannot be parsed;public static String toString(Collection<? extends MimeType> mimeTypes) {_		StringBuilder builder = new StringBuilder()__		for (Iterator<? extends MimeType> iterator = mimeTypes.iterator()_ iterator.hasNext()_) {_			MimeType mimeType = iterator.next()__			mimeType.appendTo(builder)__			if (iterator.hasNext()) {_				builder.append(", ")__			}_		}_		return builder.toString()__	};return,a,string,representation,of,the,given,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,string,to,string,collection,extends,mime,type,mime,types,string,builder,builder,new,string,builder,for,iterator,extends,mime,type,iterator,mime,types,iterator,iterator,has,next,mime,type,mime,type,iterator,next,mime,type,append,to,builder,if,iterator,has,next,builder,append,return,builder,to,string
MimeTypeUtils -> public static String toString(Collection<? extends MimeType> mimeTypes);1468947211;Return a string representation of the given list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the String cannot be parsed;public static String toString(Collection<? extends MimeType> mimeTypes) {_		StringBuilder builder = new StringBuilder()__		for (Iterator<? extends MimeType> iterator = mimeTypes.iterator()_ iterator.hasNext()_) {_			MimeType mimeType = iterator.next()__			mimeType.appendTo(builder)__			if (iterator.hasNext()) {_				builder.append(", ")__			}_		}_		return builder.toString()__	};return,a,string,representation,of,the,given,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,string,to,string,collection,extends,mime,type,mime,types,string,builder,builder,new,string,builder,for,iterator,extends,mime,type,iterator,mime,types,iterator,iterator,has,next,mime,type,mime,type,iterator,next,mime,type,append,to,builder,if,iterator,has,next,builder,append,return,builder,to,string
MimeTypeUtils -> public static String toString(Collection<? extends MimeType> mimeTypes);1472213779;Return a string representation of the given list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the String cannot be parsed;public static String toString(Collection<? extends MimeType> mimeTypes) {_		StringBuilder builder = new StringBuilder()__		for (Iterator<? extends MimeType> iterator = mimeTypes.iterator()_ iterator.hasNext()_) {_			MimeType mimeType = iterator.next()__			mimeType.appendTo(builder)__			if (iterator.hasNext()) {_				builder.append(", ")__			}_		}_		return builder.toString()__	};return,a,string,representation,of,the,given,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,string,to,string,collection,extends,mime,type,mime,types,string,builder,builder,new,string,builder,for,iterator,extends,mime,type,iterator,mime,types,iterator,iterator,has,next,mime,type,mime,type,iterator,next,mime,type,append,to,builder,if,iterator,has,next,builder,append,return,builder,to,string
MimeTypeUtils -> public static String toString(Collection<? extends MimeType> mimeTypes);1472594218;Return a string representation of the given list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the String cannot be parsed;public static String toString(Collection<? extends MimeType> mimeTypes) {_		StringBuilder builder = new StringBuilder()__		for (Iterator<? extends MimeType> iterator = mimeTypes.iterator()_ iterator.hasNext()_) {_			MimeType mimeType = iterator.next()__			mimeType.appendTo(builder)__			if (iterator.hasNext()) {_				builder.append(", ")__			}_		}_		return builder.toString()__	};return,a,string,representation,of,the,given,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,string,to,string,collection,extends,mime,type,mime,types,string,builder,builder,new,string,builder,for,iterator,extends,mime,type,iterator,mime,types,iterator,iterator,has,next,mime,type,mime,type,iterator,next,mime,type,append,to,builder,if,iterator,has,next,builder,append,return,builder,to,string
MimeTypeUtils -> public static String toString(Collection<? extends MimeType> mimeTypes);1481292266;Return a string representation of the given list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the String cannot be parsed;public static String toString(Collection<? extends MimeType> mimeTypes) {_		StringBuilder builder = new StringBuilder()__		for (Iterator<? extends MimeType> iterator = mimeTypes.iterator()_ iterator.hasNext()_) {_			MimeType mimeType = iterator.next()__			mimeType.appendTo(builder)__			if (iterator.hasNext()) {_				builder.append(", ")__			}_		}_		return builder.toString()__	};return,a,string,representation,of,the,given,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,string,to,string,collection,extends,mime,type,mime,types,string,builder,builder,new,string,builder,for,iterator,extends,mime,type,iterator,mime,types,iterator,iterator,has,next,mime,type,mime,type,iterator,next,mime,type,append,to,builder,if,iterator,has,next,builder,append,return,builder,to,string
MimeTypeUtils -> public static String toString(Collection<? extends MimeType> mimeTypes);1484249067;Return a string representation of the given list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the String cannot be parsed;public static String toString(Collection<? extends MimeType> mimeTypes) {_		StringBuilder builder = new StringBuilder()__		for (Iterator<? extends MimeType> iterator = mimeTypes.iterator()_ iterator.hasNext()_) {_			MimeType mimeType = iterator.next()__			mimeType.appendTo(builder)__			if (iterator.hasNext()) {_				builder.append(", ")__			}_		}_		return builder.toString()__	};return,a,string,representation,of,the,given,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,string,to,string,collection,extends,mime,type,mime,types,string,builder,builder,new,string,builder,for,iterator,extends,mime,type,iterator,mime,types,iterator,iterator,has,next,mime,type,mime,type,iterator,next,mime,type,append,to,builder,if,iterator,has,next,builder,append,return,builder,to,string
MimeTypeUtils -> public static String toString(Collection<? extends MimeType> mimeTypes);1484260257;Return a string representation of the given list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the String cannot be parsed;public static String toString(Collection<? extends MimeType> mimeTypes) {_		StringBuilder builder = new StringBuilder()__		for (Iterator<? extends MimeType> iterator = mimeTypes.iterator()_ iterator.hasNext()_) {_			MimeType mimeType = iterator.next()__			mimeType.appendTo(builder)__			if (iterator.hasNext()) {_				builder.append(", ")__			}_		}_		return builder.toString()__	};return,a,string,representation,of,the,given,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,string,to,string,collection,extends,mime,type,mime,types,string,builder,builder,new,string,builder,for,iterator,extends,mime,type,iterator,mime,types,iterator,iterator,has,next,mime,type,mime,type,iterator,next,mime,type,append,to,builder,if,iterator,has,next,builder,append,return,builder,to,string
MimeTypeUtils -> public static String toString(Collection<? extends MimeType> mimeTypes);1487760984;Return a string representation of the given list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the String cannot be parsed;public static String toString(Collection<? extends MimeType> mimeTypes) {_		StringBuilder builder = new StringBuilder()__		for (Iterator<? extends MimeType> iterator = mimeTypes.iterator()_ iterator.hasNext()_) {_			MimeType mimeType = iterator.next()__			mimeType.appendTo(builder)__			if (iterator.hasNext()) {_				builder.append(", ")__			}_		}_		return builder.toString()__	};return,a,string,representation,of,the,given,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,string,to,string,collection,extends,mime,type,mime,types,string,builder,builder,new,string,builder,for,iterator,extends,mime,type,iterator,mime,types,iterator,iterator,has,next,mime,type,mime,type,iterator,next,mime,type,append,to,builder,if,iterator,has,next,builder,append,return,builder,to,string
MimeTypeUtils -> public static String toString(Collection<? extends MimeType> mimeTypes);1518772998;Return a string representation of the given list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the String cannot be parsed;public static String toString(Collection<? extends MimeType> mimeTypes) {_		StringBuilder builder = new StringBuilder()__		for (Iterator<? extends MimeType> iterator = mimeTypes.iterator()_ iterator.hasNext()_) {_			MimeType mimeType = iterator.next()__			mimeType.appendTo(builder)__			if (iterator.hasNext()) {_				builder.append(", ")__			}_		}_		return builder.toString()__	};return,a,string,representation,of,the,given,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,string,to,string,collection,extends,mime,type,mime,types,string,builder,builder,new,string,builder,for,iterator,extends,mime,type,iterator,mime,types,iterator,iterator,has,next,mime,type,mime,type,iterator,next,mime,type,append,to,builder,if,iterator,has,next,builder,append,return,builder,to,string
MimeTypeUtils -> public static String toString(Collection<? extends MimeType> mimeTypes);1520528267;Return a string representation of the given list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the String cannot be parsed;public static String toString(Collection<? extends MimeType> mimeTypes) {_		StringBuilder builder = new StringBuilder()__		for (Iterator<? extends MimeType> iterator = mimeTypes.iterator()_ iterator.hasNext()_) {_			MimeType mimeType = iterator.next()__			mimeType.appendTo(builder)__			if (iterator.hasNext()) {_				builder.append(", ")__			}_		}_		return builder.toString()__	};return,a,string,representation,of,the,given,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,string,to,string,collection,extends,mime,type,mime,types,string,builder,builder,new,string,builder,for,iterator,extends,mime,type,iterator,mime,types,iterator,iterator,has,next,mime,type,mime,type,iterator,next,mime,type,append,to,builder,if,iterator,has,next,builder,append,return,builder,to,string
MimeTypeUtils -> public static String toString(Collection<? extends MimeType> mimeTypes);1521671173;Return a string representation of the given list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the String cannot be parsed;public static String toString(Collection<? extends MimeType> mimeTypes) {_		StringBuilder builder = new StringBuilder()__		for (Iterator<? extends MimeType> iterator = mimeTypes.iterator()_ iterator.hasNext()_) {_			MimeType mimeType = iterator.next()__			mimeType.appendTo(builder)__			if (iterator.hasNext()) {_				builder.append(", ")__			}_		}_		return builder.toString()__	};return,a,string,representation,of,the,given,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,string,to,string,collection,extends,mime,type,mime,types,string,builder,builder,new,string,builder,for,iterator,extends,mime,type,iterator,mime,types,iterator,iterator,has,next,mime,type,mime,type,iterator,next,mime,type,append,to,builder,if,iterator,has,next,builder,append,return,builder,to,string
MimeTypeUtils -> public static String toString(Collection<? extends MimeType> mimeTypes);1521855941;Return a string representation of the given list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the String cannot be parsed;public static String toString(Collection<? extends MimeType> mimeTypes) {_		StringBuilder builder = new StringBuilder()__		for (Iterator<? extends MimeType> iterator = mimeTypes.iterator()_ iterator.hasNext()_) {_			MimeType mimeType = iterator.next()__			mimeType.appendTo(builder)__			if (iterator.hasNext()) {_				builder.append(", ")__			}_		}_		return builder.toString()__	};return,a,string,representation,of,the,given,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,string,to,string,collection,extends,mime,type,mime,types,string,builder,builder,new,string,builder,for,iterator,extends,mime,type,iterator,mime,types,iterator,iterator,has,next,mime,type,mime,type,iterator,next,mime,type,append,to,builder,if,iterator,has,next,builder,append,return,builder,to,string
MimeTypeUtils -> public static String toString(Collection<? extends MimeType> mimeTypes);1522194969;Return a string representation of the given list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the String cannot be parsed;public static String toString(Collection<? extends MimeType> mimeTypes) {_		StringBuilder builder = new StringBuilder()__		for (Iterator<? extends MimeType> iterator = mimeTypes.iterator()_ iterator.hasNext()_) {_			MimeType mimeType = iterator.next()__			mimeType.appendTo(builder)__			if (iterator.hasNext()) {_				builder.append(", ")__			}_		}_		return builder.toString()__	};return,a,string,representation,of,the,given,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,string,to,string,collection,extends,mime,type,mime,types,string,builder,builder,new,string,builder,for,iterator,extends,mime,type,iterator,mime,types,iterator,iterator,has,next,mime,type,mime,type,iterator,next,mime,type,append,to,builder,if,iterator,has,next,builder,append,return,builder,to,string
MimeTypeUtils -> public static String toString(Collection<? extends MimeType> mimeTypes);1529943163;Return a string representation of the given list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the String cannot be parsed;public static String toString(Collection<? extends MimeType> mimeTypes) {_		StringBuilder builder = new StringBuilder()__		for (Iterator<? extends MimeType> iterator = mimeTypes.iterator()_ iterator.hasNext()_) {_			MimeType mimeType = iterator.next()__			mimeType.appendTo(builder)__			if (iterator.hasNext()) {_				builder.append(", ")__			}_		}_		return builder.toString()__	};return,a,string,representation,of,the,given,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,string,to,string,collection,extends,mime,type,mime,types,string,builder,builder,new,string,builder,for,iterator,extends,mime,type,iterator,mime,types,iterator,iterator,has,next,mime,type,mime,type,iterator,next,mime,type,append,to,builder,if,iterator,has,next,builder,append,return,builder,to,string
MimeTypeUtils -> public static String toString(Collection<? extends MimeType> mimeTypes);1542168307;Return a string representation of the given list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the String cannot be parsed;public static String toString(Collection<? extends MimeType> mimeTypes) {_		StringBuilder builder = new StringBuilder()__		for (Iterator<? extends MimeType> iterator = mimeTypes.iterator()_ iterator.hasNext()_) {_			MimeType mimeType = iterator.next()__			mimeType.appendTo(builder)__			if (iterator.hasNext()) {_				builder.append(", ")__			}_		}_		return builder.toString()__	};return,a,string,representation,of,the,given,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,string,to,string,collection,extends,mime,type,mime,types,string,builder,builder,new,string,builder,for,iterator,extends,mime,type,iterator,mime,types,iterator,iterator,has,next,mime,type,mime,type,iterator,next,mime,type,append,to,builder,if,iterator,has,next,builder,append,return,builder,to,string
MimeTypeUtils -> public static String toString(Collection<? extends MimeType> mimeTypes);1549373623;Return a string representation of the given list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the String cannot be parsed;public static String toString(Collection<? extends MimeType> mimeTypes) {_		StringBuilder builder = new StringBuilder()__		for (Iterator<? extends MimeType> iterator = mimeTypes.iterator()_ iterator.hasNext()_) {_			MimeType mimeType = iterator.next()__			mimeType.appendTo(builder)__			if (iterator.hasNext()) {_				builder.append(", ")__			}_		}_		return builder.toString()__	};return,a,string,representation,of,the,given,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,string,to,string,collection,extends,mime,type,mime,types,string,builder,builder,new,string,builder,for,iterator,extends,mime,type,iterator,mime,types,iterator,iterator,has,next,mime,type,mime,type,iterator,next,mime,type,append,to,builder,if,iterator,has,next,builder,append,return,builder,to,string
MimeTypeUtils -> public static String toString(Collection<? extends MimeType> mimeTypes);1549375593;Return a string representation of the given list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the String cannot be parsed;public static String toString(Collection<? extends MimeType> mimeTypes) {_		StringBuilder builder = new StringBuilder()__		for (Iterator<? extends MimeType> iterator = mimeTypes.iterator()_ iterator.hasNext()_) {_			MimeType mimeType = iterator.next()__			mimeType.appendTo(builder)__			if (iterator.hasNext()) {_				builder.append(", ")__			}_		}_		return builder.toString()__	};return,a,string,representation,of,the,given,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,string,to,string,collection,extends,mime,type,mime,types,string,builder,builder,new,string,builder,for,iterator,extends,mime,type,iterator,mime,types,iterator,iterator,has,next,mime,type,mime,type,iterator,next,mime,type,append,to,builder,if,iterator,has,next,builder,append,return,builder,to,string
MimeTypeUtils -> public static String toString(Collection<? extends MimeType> mimeTypes);1549377521;Return a string representation of the given list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the String cannot be parsed;public static String toString(Collection<? extends MimeType> mimeTypes) {_		StringBuilder builder = new StringBuilder()__		for (Iterator<? extends MimeType> iterator = mimeTypes.iterator()_ iterator.hasNext()_) {_			MimeType mimeType = iterator.next()__			mimeType.appendTo(builder)__			if (iterator.hasNext()) {_				builder.append(", ")__			}_		}_		return builder.toString()__	};return,a,string,representation,of,the,given,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,string,to,string,collection,extends,mime,type,mime,types,string,builder,builder,new,string,builder,for,iterator,extends,mime,type,iterator,mime,types,iterator,iterator,has,next,mime,type,mime,type,iterator,next,mime,type,append,to,builder,if,iterator,has,next,builder,append,return,builder,to,string
MimeTypeUtils -> public static String toString(Collection<? extends MimeType> mimeTypes);1549878350;Return a string representation of the given list of {@code MimeType} objects._@param mimeTypes the string to parse_@return the list of mime types_@throws IllegalArgumentException if the String cannot be parsed;public static String toString(Collection<? extends MimeType> mimeTypes) {_		StringBuilder builder = new StringBuilder()__		for (Iterator<? extends MimeType> iterator = mimeTypes.iterator()_ iterator.hasNext()_) {_			MimeType mimeType = iterator.next()__			mimeType.appendTo(builder)__			if (iterator.hasNext()) {_				builder.append(", ")__			}_		}_		return builder.toString()__	};return,a,string,representation,of,the,given,list,of,code,mime,type,objects,param,mime,types,the,string,to,parse,return,the,list,of,mime,types,throws,illegal,argument,exception,if,the,string,cannot,be,parsed;public,static,string,to,string,collection,extends,mime,type,mime,types,string,builder,builder,new,string,builder,for,iterator,extends,mime,type,iterator,mime,types,iterator,iterator,has,next,mime,type,mime,type,iterator,next,mime,type,append,to,builder,if,iterator,has,next,builder,append,return,builder,to,string
MimeTypeUtils -> private static Random initRandom();1529943163;Lazily initialize the {@link SecureRandom} for {@link #generateMultipartBoundary()}.;private static Random initRandom() {_		Random randomToUse = random__		if (randomToUse == null) {_			synchronized (MimeTypeUtils.class) {_				randomToUse = random__				if (randomToUse == null) {_					randomToUse = new SecureRandom()__					random = randomToUse__				}_			}_		}_		return randomToUse__	};lazily,initialize,the,link,secure,random,for,link,generate,multipart,boundary;private,static,random,init,random,random,random,to,use,random,if,random,to,use,null,synchronized,mime,type,utils,class,random,to,use,random,if,random,to,use,null,random,to,use,new,secure,random,random,random,to,use,return,random,to,use
MimeTypeUtils -> private static Random initRandom();1542168307;Lazily initialize the {@link SecureRandom} for {@link #generateMultipartBoundary()}.;private static Random initRandom() {_		Random randomToUse = random__		if (randomToUse == null) {_			synchronized (MimeTypeUtils.class) {_				randomToUse = random__				if (randomToUse == null) {_					randomToUse = new SecureRandom()__					random = randomToUse__				}_			}_		}_		return randomToUse__	};lazily,initialize,the,link,secure,random,for,link,generate,multipart,boundary;private,static,random,init,random,random,random,to,use,random,if,random,to,use,null,synchronized,mime,type,utils,class,random,to,use,random,if,random,to,use,null,random,to,use,new,secure,random,random,random,to,use,return,random,to,use
MimeTypeUtils -> private static Random initRandom();1549373623;Lazily initialize the {@link SecureRandom} for {@link #generateMultipartBoundary()}.;private static Random initRandom() {_		Random randomToUse = random__		if (randomToUse == null) {_			synchronized (MimeTypeUtils.class) {_				randomToUse = random__				if (randomToUse == null) {_					randomToUse = new SecureRandom()__					random = randomToUse__				}_			}_		}_		return randomToUse__	};lazily,initialize,the,link,secure,random,for,link,generate,multipart,boundary;private,static,random,init,random,random,random,to,use,random,if,random,to,use,null,synchronized,mime,type,utils,class,random,to,use,random,if,random,to,use,null,random,to,use,new,secure,random,random,random,to,use,return,random,to,use
MimeTypeUtils -> private static Random initRandom();1549375593;Lazily initialize the {@link SecureRandom} for {@link #generateMultipartBoundary()}.;private static Random initRandom() {_		Random randomToUse = random__		if (randomToUse == null) {_			synchronized (MimeTypeUtils.class) {_				randomToUse = random__				if (randomToUse == null) {_					randomToUse = new SecureRandom()__					random = randomToUse__				}_			}_		}_		return randomToUse__	};lazily,initialize,the,link,secure,random,for,link,generate,multipart,boundary;private,static,random,init,random,random,random,to,use,random,if,random,to,use,null,synchronized,mime,type,utils,class,random,to,use,random,if,random,to,use,null,random,to,use,new,secure,random,random,random,to,use,return,random,to,use
MimeTypeUtils -> private static Random initRandom();1549377521;Lazily initialize the {@link SecureRandom} for {@link #generateMultipartBoundary()}.;private static Random initRandom() {_		Random randomToUse = random__		if (randomToUse == null) {_			synchronized (MimeTypeUtils.class) {_				randomToUse = random__				if (randomToUse == null) {_					randomToUse = new SecureRandom()__					random = randomToUse__				}_			}_		}_		return randomToUse__	};lazily,initialize,the,link,secure,random,for,link,generate,multipart,boundary;private,static,random,init,random,random,random,to,use,random,if,random,to,use,null,synchronized,mime,type,utils,class,random,to,use,random,if,random,to,use,null,random,to,use,new,secure,random,random,random,to,use,return,random,to,use
MimeTypeUtils -> private static Random initRandom();1549878350;Lazily initialize the {@link SecureRandom} for {@link #generateMultipartBoundary()}.;private static Random initRandom() {_		Random randomToUse = random__		if (randomToUse == null) {_			synchronized (MimeTypeUtils.class) {_				randomToUse = random__				if (randomToUse == null) {_					randomToUse = new SecureRandom()__					random = randomToUse__				}_			}_		}_		return randomToUse__	};lazily,initialize,the,link,secure,random,for,link,generate,multipart,boundary;private,static,random,init,random,random,random,to,use,random,if,random,to,use,null,synchronized,mime,type,utils,class,random,to,use,random,if,random,to,use,null,random,to,use,new,secure,random,random,random,to,use,return,random,to,use
