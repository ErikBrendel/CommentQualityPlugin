commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;3;/**  * Parse the given String into a single {@code MimeType}.  * Recently parsed {@code MimeType} are cached for further retrieval.  * @param mimeType the string to parse  * @return the mime type  * @throws InvalidMimeTypeException if the string cannot be parsed  */ ;/**  * Parse the given String into a single {@code MimeType}.  * Recently parsed {@code MimeType} are cached for further retrieval.  * @param mimeType the string to parse  * @return the mime type  * @throws InvalidMimeTypeException if the string cannot be parsed  */ public static MimeType parseMimeType(String mimeType) {     return cachedMimeTypes.get(mimeType). }
false;private,static;1;70;;private static MimeType parseMimeTypeInternal(String mimeType) {     if (!StringUtils.hasLength(mimeType)) {         throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty").     }     int index = mimeType.indexOf('.').     String fullType = (index >= 0 ? mimeType.substring(0, index) : mimeType).trim().     if (fullType.isEmpty()) {         throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty").     }     // java.net.HttpURLConnection returns a *. q=.2 Accept header     if (MimeType.WILDCARD_TYPE.equals(fullType)) {         fullType = "*/*".     }     int subIndex = fullType.indexOf('/').     if (subIndex == -1) {         throw new InvalidMimeTypeException(mimeType, "does not contain '/'").     }     if (subIndex == fullType.length() - 1) {         throw new InvalidMimeTypeException(mimeType, "does not contain subtype after '/'").     }     String type = fullType.substring(0, subIndex).     String subtype = fullType.substring(subIndex + 1, fullType.length()).     if (MimeType.WILDCARD_TYPE.equals(type) && !MimeType.WILDCARD_TYPE.equals(subtype)) {         throw new InvalidMimeTypeException(mimeType, "wildcard type is legal only in '*/*' (all mime types)").     }     Map<String, String> parameters = null.     do {         int nextIndex = index + 1.         boolean quoted = false.         while (nextIndex < mimeType.length()) {             char ch = mimeType.charAt(nextIndex).             if (ch == '.') {                 if (!quoted) {                     break.                 }             } else if (ch == '"') {                 quoted = !quoted.             }             nextIndex++.         }         String parameter = mimeType.substring(index + 1, nextIndex).trim().         if (parameter.length() > 0) {             if (parameters == null) {                 parameters = new LinkedHashMap<>(4).             }             int eqIndex = parameter.indexOf('=').             if (eqIndex >= 0) {                 String attribute = parameter.substring(0, eqIndex).trim().                 String value = parameter.substring(eqIndex + 1, parameter.length()).trim().                 parameters.put(attribute, value).             }         }         index = nextIndex.     } while (index < mimeType.length()).     try {         return new MimeType(type, subtype, parameters).     } catch (UnsupportedCharsetException ex) {         throw new InvalidMimeTypeException(mimeType, "unsupported charset '" + ex.getCharsetName() + "'").     } catch (IllegalArgumentException ex) {         throw new InvalidMimeTypeException(mimeType, ex.getMessage()).     } }
true;public,static;1;7;/**  * Parse the comma-separated string into a list of {@code MimeType} objects.  * @param mimeTypes the string to parse  * @return the list of mime types  * @throws InvalidMimeTypeException if the string cannot be parsed  */ ;/**  * Parse the comma-separated string into a list of {@code MimeType} objects.  * @param mimeTypes the string to parse  * @return the list of mime types  * @throws InvalidMimeTypeException if the string cannot be parsed  */ public static List<MimeType> parseMimeTypes(String mimeTypes) {     if (!StringUtils.hasLength(mimeTypes)) {         return Collections.emptyList().     }     return tokenize(mimeTypes).stream().map(MimeTypeUtils::parseMimeType).collect(Collectors.toList()). }
true;public,static;1;28;/**  * Tokenize the given comma-separated string of {@code MimeType} objects  * into a {@code List<String>}. Unlike simple tokenization by ",", this  * method takes into account quoted parameters.  * @param mimeTypes the string to tokenize  * @return the list of tokens  * @since 5.1.3  */ ;/**  * Tokenize the given comma-separated string of {@code MimeType} objects  * into a {@code List<String>}. Unlike simple tokenization by ",", this  * method takes into account quoted parameters.  * @param mimeTypes the string to tokenize  * @return the list of tokens  * @since 5.1.3  */ public static List<String> tokenize(String mimeTypes) {     if (!StringUtils.hasLength(mimeTypes)) {         return Collections.emptyList().     }     List<String> tokens = new ArrayList<>().     boolean inQuotes = false.     int startIndex = 0.     int i = 0.     while (i < mimeTypes.length()) {         switch(mimeTypes.charAt(i)) {             case '"':                 inQuotes = !inQuotes.                 break.             case ',':                 if (!inQuotes) {                     tokens.add(mimeTypes.substring(startIndex, i)).                     startIndex = i + 1.                 }                 break.             case '\\':                 i++.                 break.         }         i++.     }     tokens.add(mimeTypes.substring(startIndex)).     return tokens. }
true;public,static;1;11;/**  * Return a string representation of the given list of {@code MimeType} objects.  * @param mimeTypes the string to parse  * @return the list of mime types  * @throws IllegalArgumentException if the String cannot be parsed  */ ;/**  * Return a string representation of the given list of {@code MimeType} objects.  * @param mimeTypes the string to parse  * @return the list of mime types  * @throws IllegalArgumentException if the String cannot be parsed  */ public static String toString(Collection<? extends MimeType> mimeTypes) {     StringBuilder builder = new StringBuilder().     for (Iterator<? extends MimeType> iterator = mimeTypes.iterator(). iterator.hasNext(). ) {         MimeType mimeType = iterator.next().         mimeType.appendTo(builder).         if (iterator.hasNext()) {             builder.append(", ").         }     }     return builder.toString(). }
true;public,static;1;6;/**  * Sorts the given list of {@code MimeType} objects by specificity.  * <p>Given two mime types:  * <ol>  * <li>if either mime type has a {@linkplain MimeType#isWildcardType() wildcard type},  * then the mime type without the wildcard is ordered before the other.</li>  * <li>if the two mime types have different {@linkplain MimeType#getType() types},  * then they are considered equal and remain their current order.</li>  * <li>if either mime type has a {@linkplain MimeType#isWildcardSubtype() wildcard subtype}  * , then the mime type without the wildcard is sorted before the other.</li>  * <li>if the two mime types have different {@linkplain MimeType#getSubtype() subtypes},  * then they are considered equal and remain their current order.</li>  * <li>if the two mime types have a different amount of  * {@linkplain MimeType#getParameter(String) parameters}, then the mime type with the most  * parameters is ordered before the other.</li>  * </ol>  * <p>For example: <blockquote>audio/basic &lt. audio/* &lt. *&#047.*</blockquote>  * <blockquote>audio/basic.level=1 &lt. audio/basic</blockquote>  * <blockquote>audio/basic == text/html</blockquote> <blockquote>audio/basic ==  * audio/wave</blockquote>  * @param mimeTypes the list of mime types to be sorted  * @see <a href="http://tools.ietf.org/html/rfc7231#section-5.3.2">HTTP 1.1: Semantics  * and Content, section 5.3.2</a>  */ ;/**  * Sorts the given list of {@code MimeType} objects by specificity.  * <p>Given two mime types:  * <ol>  * <li>if either mime type has a {@linkplain MimeType#isWildcardType() wildcard type},  * then the mime type without the wildcard is ordered before the other.</li>  * <li>if the two mime types have different {@linkplain MimeType#getType() types},  * then they are considered equal and remain their current order.</li>  * <li>if either mime type has a {@linkplain MimeType#isWildcardSubtype() wildcard subtype}  * , then the mime type without the wildcard is sorted before the other.</li>  * <li>if the two mime types have different {@linkplain MimeType#getSubtype() subtypes},  * then they are considered equal and remain their current order.</li>  * <li>if the two mime types have a different amount of  * {@linkplain MimeType#getParameter(String) parameters}, then the mime type with the most  * parameters is ordered before the other.</li>  * </ol>  * <p>For example: <blockquote>audio/basic &lt. audio/* &lt. *&#047.*</blockquote>  * <blockquote>audio/basic.level=1 &lt. audio/basic</blockquote>  * <blockquote>audio/basic == text/html</blockquote> <blockquote>audio/basic ==  * audio/wave</blockquote>  * @param mimeTypes the list of mime types to be sorted  * @see <a href="http://tools.ietf.org/html/rfc7231#section-5.3.2">HTTP 1.1: Semantics  * and Content, section 5.3.2</a>  */ public static void sortBySpecificity(List<MimeType> mimeTypes) {     Assert.notNull(mimeTypes, "'mimeTypes' must not be null").     if (mimeTypes.size() > 1) {         mimeTypes.sort(SPECIFICITY_COMPARATOR).     } }
true;private,static;0;13;/**  * Lazily initialize the {@link SecureRandom} for {@link #generateMultipartBoundary()}.  */ ;/**  * Lazily initialize the {@link SecureRandom} for {@link #generateMultipartBoundary()}.  */ private static Random initRandom() {     Random randomToUse = random.     if (randomToUse == null) {         synchronized (MimeTypeUtils.class) {             randomToUse = random.             if (randomToUse == null) {                 randomToUse = new SecureRandom().                 random = randomToUse.             }         }     }     return randomToUse. }
true;public,static;0;8;/**  * Generate a random MIME boundary as bytes, often used in multipart mime types.  */ ;/**  * Generate a random MIME boundary as bytes, often used in multipart mime types.  */ public static byte[] generateMultipartBoundary() {     Random randomToUse = initRandom().     byte[] boundary = new byte[randomToUse.nextInt(11) + 30].     for (int i = 0. i < boundary.length. i++) {         boundary[i] = BOUNDARY_CHARS[randomToUse.nextInt(BOUNDARY_CHARS.length)].     }     return boundary. }
true;public,static;0;3;/**  * Generate a random MIME boundary as String, often used in multipart mime types.  */ ;/**  * Generate a random MIME boundary as String, often used in multipart mime types.  */ public static String generateMultipartBoundaryString() {     return new String(generateMultipartBoundary(), StandardCharsets.US_ASCII). }
false;public;1;28;;public V get(K key) {     this.lock.readLock().lock().     try {         if (this.queue.remove(key)) {             this.queue.add(key).             return this.cache.get(key).         }     } finally {         this.lock.readLock().unlock().     }     this.lock.writeLock().lock().     try {         if (this.queue.size() == this.maxSize) {             K leastUsed = this.queue.poll().             if (leastUsed != null) {                 this.cache.remove(leastUsed).             }         }         V value = this.generator.apply(key).         this.queue.add(key).         this.cache.put(key, value).         return value.     } finally {         this.lock.writeLock().unlock().     } }
