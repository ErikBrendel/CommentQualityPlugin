# id;timestamp;commentText;codeText;commentWords;codeWords
Label -> @Override     public String toString();1366718246;Returns a string representation of this label.__@return a string representation of this label.;@Override_    public String toString() {_        return "L" + System.identityHashCode(this)__    };returns,a,string,representation,of,this,label,return,a,string,representation,of,this,label;override,public,string,to,string,return,l,system,identity,hash,code,this
Label -> @Override     public String toString();1385501137;Returns a string representation of this label.__@return a string representation of this label.;@Override_    public String toString() {_        return "L" + System.identityHashCode(this)__    };returns,a,string,representation,of,this,label,return,a,string,representation,of,this,label;override,public,string,to,string,return,l,system,identity,hash,code,this
Label -> @Override     public String toString();1400531367;Returns a string representation of this label.__@return a string representation of this label.;@Override_    public String toString() {_        return "L" + System.identityHashCode(this)__    };returns,a,string,representation,of,this,label,return,a,string,representation,of,this,label;override,public,string,to,string,return,l,system,identity,hash,code,this
Label -> @Override     public String toString();1416998550;Returns a string representation of this label.__@return a string representation of this label.;@Override_    public String toString() {_        return "L" + System.identityHashCode(this)__    };returns,a,string,representation,of,this,label,return,a,string,representation,of,this,label;override,public,string,to,string,return,l,system,identity,hash,code,this
Label -> @Override     public String toString();1483093254;Returns a string representation of this label.__@return a string representation of this label.;@Override_    public String toString() {_        return "L" + System.identityHashCode(this)__    };returns,a,string,representation,of,this,label,return,a,string,representation,of,this,label;override,public,string,to,string,return,l,system,identity,hash,code,this
Label -> boolean inSubroutine(final long id);1366718246;Returns true is this basic block belongs to the given subroutine.__@param id_a subroutine id._@return true is this basic block belongs to the given subroutine.;boolean inSubroutine(final long id) {_        if ((status & Label.VISITED) != 0) {_            return (srcAndRefPositions[(int) (id >>> 32)] & (int) id) != 0__        }_        return false__    };returns,true,is,this,basic,block,belongs,to,the,given,subroutine,param,id,a,subroutine,id,return,true,is,this,basic,block,belongs,to,the,given,subroutine;boolean,in,subroutine,final,long,id,if,status,label,visited,0,return,src,and,ref,positions,int,id,32,int,id,0,return,false
Label -> boolean inSubroutine(final long id);1385501137;Returns true is this basic block belongs to the given subroutine.__@param id_a subroutine id._@return true is this basic block belongs to the given subroutine.;boolean inSubroutine(final long id) {_        if ((status & Label.VISITED) != 0) {_            return (srcAndRefPositions[(int) (id >>> 32)] & (int) id) != 0__        }_        return false__    };returns,true,is,this,basic,block,belongs,to,the,given,subroutine,param,id,a,subroutine,id,return,true,is,this,basic,block,belongs,to,the,given,subroutine;boolean,in,subroutine,final,long,id,if,status,label,visited,0,return,src,and,ref,positions,int,id,32,int,id,0,return,false
Label -> boolean inSubroutine(final long id);1400531367;Returns true is this basic block belongs to the given subroutine.__@param id_a subroutine id._@return true is this basic block belongs to the given subroutine.;boolean inSubroutine(final long id) {_        if ((status & Label.VISITED) != 0) {_            return (srcAndRefPositions[(int) (id >>> 32)] & (int) id) != 0__        }_        return false__    };returns,true,is,this,basic,block,belongs,to,the,given,subroutine,param,id,a,subroutine,id,return,true,is,this,basic,block,belongs,to,the,given,subroutine;boolean,in,subroutine,final,long,id,if,status,label,visited,0,return,src,and,ref,positions,int,id,32,int,id,0,return,false
Label -> boolean inSubroutine(final long id);1416998550;Returns true is this basic block belongs to the given subroutine.__@param id_a subroutine id._@return true is this basic block belongs to the given subroutine.;boolean inSubroutine(final long id) {_        if ((status & Label.VISITED) != 0) {_            return (srcAndRefPositions[(int) (id >>> 32)] & (int) id) != 0__        }_        return false__    };returns,true,is,this,basic,block,belongs,to,the,given,subroutine,param,id,a,subroutine,id,return,true,is,this,basic,block,belongs,to,the,given,subroutine;boolean,in,subroutine,final,long,id,if,status,label,visited,0,return,src,and,ref,positions,int,id,32,int,id,0,return,false
Label -> boolean inSubroutine(final long id);1483093254;Returns true is this basic block belongs to the given subroutine.__@param id_a subroutine id._@return true is this basic block belongs to the given subroutine.;boolean inSubroutine(final long id) {_        if ((status & Label.VISITED) != 0) {_            return (srcAndRefPositions[(int) (id >>> 32)] & (int) id) != 0__        }_        return false__    };returns,true,is,this,basic,block,belongs,to,the,given,subroutine,param,id,a,subroutine,id,return,true,is,this,basic,block,belongs,to,the,given,subroutine;boolean,in,subroutine,final,long,id,if,status,label,visited,0,return,src,and,ref,positions,int,id,32,int,id,0,return,false
Label -> private void addForwardReference(       final int sourceInsnBytecodeOffset, final int referenceType, final int referenceHandle);1531241461;Adds a forward reference to this label. This method must be called only for a true forward_reference, i.e. only if this label is not resolved yet. For backward references, the relative_bytecode offset of the reference can be, and must be, computed and stored directly.__@param sourceInsnBytecodeOffset the bytecode offset of the instruction that contains the_reference stored at referenceHandle._@param referenceType either {@link #FORWARD_REFERENCE_TYPE_SHORT} or {@link_#FORWARD_REFERENCE_TYPE_WIDE}._@param referenceHandle the offset in the bytecode where the forward reference value must be_stored.;private void addForwardReference(_      final int sourceInsnBytecodeOffset, final int referenceType, final int referenceHandle) {_    if (forwardReferences == null) {_      forwardReferences = new int[FORWARD_REFERENCES_CAPACITY_INCREMENT]__    }_    int lastElementIndex = forwardReferences[0]__    if (lastElementIndex + 2 >= forwardReferences.length) {_      int[] newValues = new int[forwardReferences.length + FORWARD_REFERENCES_CAPACITY_INCREMENT]__      System.arraycopy(forwardReferences, 0, newValues, 0, forwardReferences.length)__      forwardReferences = newValues__    }_    forwardReferences[++lastElementIndex] = sourceInsnBytecodeOffset__    forwardReferences[++lastElementIndex] = referenceType | referenceHandle__    forwardReferences[0] = lastElementIndex__  };adds,a,forward,reference,to,this,label,this,method,must,be,called,only,for,a,true,forward,reference,i,e,only,if,this,label,is,not,resolved,yet,for,backward,references,the,relative,bytecode,offset,of,the,reference,can,be,and,must,be,computed,and,stored,directly,param,source,insn,bytecode,offset,the,bytecode,offset,of,the,instruction,that,contains,the,reference,stored,at,reference,handle,param,reference,type,either,link,or,link,param,reference,handle,the,offset,in,the,bytecode,where,the,forward,reference,value,must,be,stored;private,void,add,forward,reference,final,int,source,insn,bytecode,offset,final,int,reference,type,final,int,reference,handle,if,forward,references,null,forward,references,new,int,int,last,element,index,forward,references,0,if,last,element,index,2,forward,references,length,int,new,values,new,int,forward,references,length,system,arraycopy,forward,references,0,new,values,0,forward,references,length,forward,references,new,values,forward,references,last,element,index,source,insn,bytecode,offset,forward,references,last,element,index,reference,type,reference,handle,forward,references,0,last,element,index
Label -> private void addForwardReference(       final int sourceInsnBytecodeOffset, final int referenceType, final int referenceHandle);1536664245;Adds a forward reference to this label. This method must be called only for a true forward_reference, i.e. only if this label is not resolved yet. For backward references, the relative_bytecode offset of the reference can be, and must be, computed and stored directly.__@param sourceInsnBytecodeOffset the bytecode offset of the instruction that contains the_reference stored at referenceHandle._@param referenceType either {@link #FORWARD_REFERENCE_TYPE_SHORT} or {@link_#FORWARD_REFERENCE_TYPE_WIDE}._@param referenceHandle the offset in the bytecode where the forward reference value must be_stored.;private void addForwardReference(_      final int sourceInsnBytecodeOffset, final int referenceType, final int referenceHandle) {_    if (forwardReferences == null) {_      forwardReferences = new int[FORWARD_REFERENCES_CAPACITY_INCREMENT]__    }_    int lastElementIndex = forwardReferences[0]__    if (lastElementIndex + 2 >= forwardReferences.length) {_      int[] newValues = new int[forwardReferences.length + FORWARD_REFERENCES_CAPACITY_INCREMENT]__      System.arraycopy(forwardReferences, 0, newValues, 0, forwardReferences.length)__      forwardReferences = newValues__    }_    forwardReferences[++lastElementIndex] = sourceInsnBytecodeOffset__    forwardReferences[++lastElementIndex] = referenceType | referenceHandle__    forwardReferences[0] = lastElementIndex__  };adds,a,forward,reference,to,this,label,this,method,must,be,called,only,for,a,true,forward,reference,i,e,only,if,this,label,is,not,resolved,yet,for,backward,references,the,relative,bytecode,offset,of,the,reference,can,be,and,must,be,computed,and,stored,directly,param,source,insn,bytecode,offset,the,bytecode,offset,of,the,instruction,that,contains,the,reference,stored,at,reference,handle,param,reference,type,either,link,or,link,param,reference,handle,the,offset,in,the,bytecode,where,the,forward,reference,value,must,be,stored;private,void,add,forward,reference,final,int,source,insn,bytecode,offset,final,int,reference,type,final,int,reference,handle,if,forward,references,null,forward,references,new,int,int,last,element,index,forward,references,0,if,last,element,index,2,forward,references,length,int,new,values,new,int,forward,references,length,system,arraycopy,forward,references,0,new,values,0,forward,references,length,forward,references,new,values,forward,references,last,element,index,source,insn,bytecode,offset,forward,references,last,element,index,reference,type,reference,handle,forward,references,0,last,element,index
Label -> private void addForwardReference(       final int sourceInsnBytecodeOffset, final int referenceType, final int referenceHandle);1537204147;Adds a forward reference to this label. This method must be called only for a true forward_reference, i.e. only if this label is not resolved yet. For backward references, the relative_bytecode offset of the reference can be, and must be, computed and stored directly.__@param sourceInsnBytecodeOffset the bytecode offset of the instruction that contains the_reference stored at referenceHandle._@param referenceType either {@link #FORWARD_REFERENCE_TYPE_SHORT} or {@link_#FORWARD_REFERENCE_TYPE_WIDE}._@param referenceHandle the offset in the bytecode where the forward reference value must be_stored.;private void addForwardReference(_      final int sourceInsnBytecodeOffset, final int referenceType, final int referenceHandle) {_    if (forwardReferences == null) {_      forwardReferences = new int[FORWARD_REFERENCES_CAPACITY_INCREMENT]__    }_    int lastElementIndex = forwardReferences[0]__    if (lastElementIndex + 2 >= forwardReferences.length) {_      int[] newValues = new int[forwardReferences.length + FORWARD_REFERENCES_CAPACITY_INCREMENT]__      System.arraycopy(forwardReferences, 0, newValues, 0, forwardReferences.length)__      forwardReferences = newValues__    }_    forwardReferences[++lastElementIndex] = sourceInsnBytecodeOffset__    forwardReferences[++lastElementIndex] = referenceType | referenceHandle__    forwardReferences[0] = lastElementIndex__  };adds,a,forward,reference,to,this,label,this,method,must,be,called,only,for,a,true,forward,reference,i,e,only,if,this,label,is,not,resolved,yet,for,backward,references,the,relative,bytecode,offset,of,the,reference,can,be,and,must,be,computed,and,stored,directly,param,source,insn,bytecode,offset,the,bytecode,offset,of,the,instruction,that,contains,the,reference,stored,at,reference,handle,param,reference,type,either,link,or,link,param,reference,handle,the,offset,in,the,bytecode,where,the,forward,reference,value,must,be,stored;private,void,add,forward,reference,final,int,source,insn,bytecode,offset,final,int,reference,type,final,int,reference,handle,if,forward,references,null,forward,references,new,int,int,last,element,index,forward,references,0,if,last,element,index,2,forward,references,length,int,new,values,new,int,forward,references,length,system,arraycopy,forward,references,0,new,values,0,forward,references,length,forward,references,new,values,forward,references,last,element,index,source,insn,bytecode,offset,forward,references,last,element,index,reference,type,reference,handle,forward,references,0,last,element,index
Label -> public int getOffset();1366718246;Returns the offset corresponding to this label. This offset is computed_from the start of the method's bytecode. <i>This method is intended for_{@link Attribute} sub classes, and is normally not needed by class_generators or adapters.</i>__@return the offset corresponding to this label._@throws IllegalStateException_if this label is not resolved yet.;public int getOffset() {_        if ((status & RESOLVED) == 0) {_            throw new IllegalStateException(_                    "Label offset position has not been resolved yet")__        }_        return position__    };returns,the,offset,corresponding,to,this,label,this,offset,is,computed,from,the,start,of,the,method,s,bytecode,i,this,method,is,intended,for,link,attribute,sub,classes,and,is,normally,not,needed,by,class,generators,or,adapters,i,return,the,offset,corresponding,to,this,label,throws,illegal,state,exception,if,this,label,is,not,resolved,yet;public,int,get,offset,if,status,resolved,0,throw,new,illegal,state,exception,label,offset,position,has,not,been,resolved,yet,return,position
Label -> public int getOffset();1385501137;Returns the offset corresponding to this label. This offset is computed_from the start of the method's bytecode. <i>This method is intended for_{@link Attribute} sub classes, and is normally not needed by class_generators or adapters.</i>__@return the offset corresponding to this label._@throws IllegalStateException_if this label is not resolved yet.;public int getOffset() {_        if ((status & RESOLVED) == 0) {_            throw new IllegalStateException(_                    "Label offset position has not been resolved yet")__        }_        return position__    };returns,the,offset,corresponding,to,this,label,this,offset,is,computed,from,the,start,of,the,method,s,bytecode,i,this,method,is,intended,for,link,attribute,sub,classes,and,is,normally,not,needed,by,class,generators,or,adapters,i,return,the,offset,corresponding,to,this,label,throws,illegal,state,exception,if,this,label,is,not,resolved,yet;public,int,get,offset,if,status,resolved,0,throw,new,illegal,state,exception,label,offset,position,has,not,been,resolved,yet,return,position
Label -> public int getOffset();1400531367;Returns the offset corresponding to this label. This offset is computed_from the start of the method's bytecode. <i>This method is intended for_{@link Attribute} sub classes, and is normally not needed by class_generators or adapters.</i>__@return the offset corresponding to this label._@throws IllegalStateException_if this label is not resolved yet.;public int getOffset() {_        if ((status & RESOLVED) == 0) {_            throw new IllegalStateException(_                    "Label offset position has not been resolved yet")__        }_        return position__    };returns,the,offset,corresponding,to,this,label,this,offset,is,computed,from,the,start,of,the,method,s,bytecode,i,this,method,is,intended,for,link,attribute,sub,classes,and,is,normally,not,needed,by,class,generators,or,adapters,i,return,the,offset,corresponding,to,this,label,throws,illegal,state,exception,if,this,label,is,not,resolved,yet;public,int,get,offset,if,status,resolved,0,throw,new,illegal,state,exception,label,offset,position,has,not,been,resolved,yet,return,position
Label -> public int getOffset();1416998550;Returns the offset corresponding to this label. This offset is computed_from the start of the method's bytecode. <i>This method is intended for_{@link Attribute} sub classes, and is normally not needed by class_generators or adapters.</i>__@return the offset corresponding to this label._@throws IllegalStateException_if this label is not resolved yet.;public int getOffset() {_        if ((status & RESOLVED) == 0) {_            throw new IllegalStateException(_                    "Label offset position has not been resolved yet")__        }_        return position__    };returns,the,offset,corresponding,to,this,label,this,offset,is,computed,from,the,start,of,the,method,s,bytecode,i,this,method,is,intended,for,link,attribute,sub,classes,and,is,normally,not,needed,by,class,generators,or,adapters,i,return,the,offset,corresponding,to,this,label,throws,illegal,state,exception,if,this,label,is,not,resolved,yet;public,int,get,offset,if,status,resolved,0,throw,new,illegal,state,exception,label,offset,position,has,not,been,resolved,yet,return,position
Label -> public int getOffset();1483093254;Returns the offset corresponding to this label. This offset is computed_from the start of the method's bytecode. <i>This method is intended for_{@link Attribute} sub classes, and is normally not needed by class_generators or adapters.</i>__@return the offset corresponding to this label._@throws IllegalStateException_if this label is not resolved yet.;public int getOffset() {_        if ((status & RESOLVED) == 0) {_            throw new IllegalStateException(_                    "Label offset position has not been resolved yet")__        }_        return position__    };returns,the,offset,corresponding,to,this,label,this,offset,is,computed,from,the,start,of,the,method,s,bytecode,i,this,method,is,intended,for,link,attribute,sub,classes,and,is,normally,not,needed,by,class,generators,or,adapters,i,return,the,offset,corresponding,to,this,label,throws,illegal,state,exception,if,this,label,is,not,resolved,yet;public,int,get,offset,if,status,resolved,0,throw,new,illegal,state,exception,label,offset,position,has,not,been,resolved,yet,return,position
Label -> public int getOffset();1531241461;Returns the bytecode offset corresponding to this label. This offset is computed from the start_of the method's bytecode. <i>This method is intended for {@link Attribute} sub classes, and is_normally not needed by class generators or adapters.</i>__@return the bytecode offset corresponding to this label._@throws IllegalStateException if this label is not resolved yet.;public int getOffset() {_    if ((flags & FLAG_RESOLVED) == 0) {_      throw new IllegalStateException("Label offset position has not been resolved yet")__    }_    return bytecodeOffset__  };returns,the,bytecode,offset,corresponding,to,this,label,this,offset,is,computed,from,the,start,of,the,method,s,bytecode,i,this,method,is,intended,for,link,attribute,sub,classes,and,is,normally,not,needed,by,class,generators,or,adapters,i,return,the,bytecode,offset,corresponding,to,this,label,throws,illegal,state,exception,if,this,label,is,not,resolved,yet;public,int,get,offset,if,flags,0,throw,new,illegal,state,exception,label,offset,position,has,not,been,resolved,yet,return,bytecode,offset
Label -> public int getOffset();1536664245;Returns the bytecode offset corresponding to this label. This offset is computed from the start_of the method's bytecode. <i>This method is intended for {@link Attribute} sub classes, and is_normally not needed by class generators or adapters.</i>__@return the bytecode offset corresponding to this label._@throws IllegalStateException if this label is not resolved yet.;public int getOffset() {_    if ((flags & FLAG_RESOLVED) == 0) {_      throw new IllegalStateException("Label offset position has not been resolved yet")__    }_    return bytecodeOffset__  };returns,the,bytecode,offset,corresponding,to,this,label,this,offset,is,computed,from,the,start,of,the,method,s,bytecode,i,this,method,is,intended,for,link,attribute,sub,classes,and,is,normally,not,needed,by,class,generators,or,adapters,i,return,the,bytecode,offset,corresponding,to,this,label,throws,illegal,state,exception,if,this,label,is,not,resolved,yet;public,int,get,offset,if,flags,0,throw,new,illegal,state,exception,label,offset,position,has,not,been,resolved,yet,return,bytecode,offset
Label -> public int getOffset();1537204147;Returns the bytecode offset corresponding to this label. This offset is computed from the start_of the method's bytecode. <i>This method is intended for {@link Attribute} sub classes, and is_normally not needed by class generators or adapters.</i>__@return the bytecode offset corresponding to this label._@throws IllegalStateException if this label is not resolved yet.;public int getOffset() {_    if ((flags & FLAG_RESOLVED) == 0) {_      throw new IllegalStateException("Label offset position has not been resolved yet")__    }_    return bytecodeOffset__  };returns,the,bytecode,offset,corresponding,to,this,label,this,offset,is,computed,from,the,start,of,the,method,s,bytecode,i,this,method,is,intended,for,link,attribute,sub,classes,and,is,normally,not,needed,by,class,generators,or,adapters,i,return,the,bytecode,offset,corresponding,to,this,label,throws,illegal,state,exception,if,this,label,is,not,resolved,yet;public,int,get,offset,if,flags,0,throw,new,illegal,state,exception,label,offset,position,has,not,been,resolved,yet,return,bytecode,offset
Label -> boolean inSameSubroutine(final Label block);1366718246;Returns true if this basic block and the given one belong to a common_subroutine.__@param block_another basic block._@return true if this basic block and the given one belong to a common_subroutine.;boolean inSameSubroutine(final Label block) {_        if ((status & VISITED) == 0 || (block.status & VISITED) == 0) {_            return false__        }_        for (int i = 0_ i < srcAndRefPositions.length_ ++i) {_            if ((srcAndRefPositions[i] & block.srcAndRefPositions[i]) != 0) {_                return true__            }_        }_        return false__    };returns,true,if,this,basic,block,and,the,given,one,belong,to,a,common,subroutine,param,block,another,basic,block,return,true,if,this,basic,block,and,the,given,one,belong,to,a,common,subroutine;boolean,in,same,subroutine,final,label,block,if,status,visited,0,block,status,visited,0,return,false,for,int,i,0,i,src,and,ref,positions,length,i,if,src,and,ref,positions,i,block,src,and,ref,positions,i,0,return,true,return,false
Label -> boolean inSameSubroutine(final Label block);1385501137;Returns true if this basic block and the given one belong to a common_subroutine.__@param block_another basic block._@return true if this basic block and the given one belong to a common_subroutine.;boolean inSameSubroutine(final Label block) {_        if ((status & VISITED) == 0 || (block.status & VISITED) == 0) {_            return false__        }_        for (int i = 0_ i < srcAndRefPositions.length_ ++i) {_            if ((srcAndRefPositions[i] & block.srcAndRefPositions[i]) != 0) {_                return true__            }_        }_        return false__    };returns,true,if,this,basic,block,and,the,given,one,belong,to,a,common,subroutine,param,block,another,basic,block,return,true,if,this,basic,block,and,the,given,one,belong,to,a,common,subroutine;boolean,in,same,subroutine,final,label,block,if,status,visited,0,block,status,visited,0,return,false,for,int,i,0,i,src,and,ref,positions,length,i,if,src,and,ref,positions,i,block,src,and,ref,positions,i,0,return,true,return,false
Label -> boolean inSameSubroutine(final Label block);1400531367;Returns true if this basic block and the given one belong to a common_subroutine.__@param block_another basic block._@return true if this basic block and the given one belong to a common_subroutine.;boolean inSameSubroutine(final Label block) {_        if ((status & VISITED) == 0 || (block.status & VISITED) == 0) {_            return false__        }_        for (int i = 0_ i < srcAndRefPositions.length_ ++i) {_            if ((srcAndRefPositions[i] & block.srcAndRefPositions[i]) != 0) {_                return true__            }_        }_        return false__    };returns,true,if,this,basic,block,and,the,given,one,belong,to,a,common,subroutine,param,block,another,basic,block,return,true,if,this,basic,block,and,the,given,one,belong,to,a,common,subroutine;boolean,in,same,subroutine,final,label,block,if,status,visited,0,block,status,visited,0,return,false,for,int,i,0,i,src,and,ref,positions,length,i,if,src,and,ref,positions,i,block,src,and,ref,positions,i,0,return,true,return,false
Label -> boolean inSameSubroutine(final Label block);1416998550;Returns true if this basic block and the given one belong to a common_subroutine.__@param block_another basic block._@return true if this basic block and the given one belong to a common_subroutine.;boolean inSameSubroutine(final Label block) {_        if ((status & VISITED) == 0 || (block.status & VISITED) == 0) {_            return false__        }_        for (int i = 0_ i < srcAndRefPositions.length_ ++i) {_            if ((srcAndRefPositions[i] & block.srcAndRefPositions[i]) != 0) {_                return true__            }_        }_        return false__    };returns,true,if,this,basic,block,and,the,given,one,belong,to,a,common,subroutine,param,block,another,basic,block,return,true,if,this,basic,block,and,the,given,one,belong,to,a,common,subroutine;boolean,in,same,subroutine,final,label,block,if,status,visited,0,block,status,visited,0,return,false,for,int,i,0,i,src,and,ref,positions,length,i,if,src,and,ref,positions,i,block,src,and,ref,positions,i,0,return,true,return,false
Label -> boolean inSameSubroutine(final Label block);1483093254;Returns true if this basic block and the given one belong to a common_subroutine.__@param block_another basic block._@return true if this basic block and the given one belong to a common_subroutine.;boolean inSameSubroutine(final Label block) {_        if ((status & VISITED) == 0 || (block.status & VISITED) == 0) {_            return false__        }_        for (int i = 0_ i < srcAndRefPositions.length_ ++i) {_            if ((srcAndRefPositions[i] & block.srcAndRefPositions[i]) != 0) {_                return true__            }_        }_        return false__    };returns,true,if,this,basic,block,and,the,given,one,belong,to,a,common,subroutine,param,block,another,basic,block,return,true,if,this,basic,block,and,the,given,one,belong,to,a,common,subroutine;boolean,in,same,subroutine,final,label,block,if,status,visited,0,block,status,visited,0,return,false,for,int,i,0,i,src,and,ref,positions,length,i,if,src,and,ref,positions,i,block,src,and,ref,positions,i,0,return,true,return,false
Label -> void addToSubroutine(final long id, final int nbSubroutines);1366718246;Marks this basic block as belonging to the given subroutine.__@param id_a subroutine id._@param nbSubroutines_the total number of subroutines in the method.;void addToSubroutine(final long id, final int nbSubroutines) {_        if ((status & VISITED) == 0) {_            status |= VISITED__            srcAndRefPositions = new int[(nbSubroutines - 1) / 32 + 1]__        }_        srcAndRefPositions[(int) (id >>> 32)] |= (int) id__    };marks,this,basic,block,as,belonging,to,the,given,subroutine,param,id,a,subroutine,id,param,nb,subroutines,the,total,number,of,subroutines,in,the,method;void,add,to,subroutine,final,long,id,final,int,nb,subroutines,if,status,visited,0,status,visited,src,and,ref,positions,new,int,nb,subroutines,1,32,1,src,and,ref,positions,int,id,32,int,id
Label -> void addToSubroutine(final long id, final int nbSubroutines);1385501137;Marks this basic block as belonging to the given subroutine.__@param id_a subroutine id._@param nbSubroutines_the total number of subroutines in the method.;void addToSubroutine(final long id, final int nbSubroutines) {_        if ((status & VISITED) == 0) {_            status |= VISITED__            srcAndRefPositions = new int[(nbSubroutines - 1) / 32 + 1]__        }_        srcAndRefPositions[(int) (id >>> 32)] |= (int) id__    };marks,this,basic,block,as,belonging,to,the,given,subroutine,param,id,a,subroutine,id,param,nb,subroutines,the,total,number,of,subroutines,in,the,method;void,add,to,subroutine,final,long,id,final,int,nb,subroutines,if,status,visited,0,status,visited,src,and,ref,positions,new,int,nb,subroutines,1,32,1,src,and,ref,positions,int,id,32,int,id
Label -> void addToSubroutine(final long id, final int nbSubroutines);1400531367;Marks this basic block as belonging to the given subroutine.__@param id_a subroutine id._@param nbSubroutines_the total number of subroutines in the method.;void addToSubroutine(final long id, final int nbSubroutines) {_        if ((status & VISITED) == 0) {_            status |= VISITED__            srcAndRefPositions = new int[nbSubroutines / 32 + 1]__        }_        srcAndRefPositions[(int) (id >>> 32)] |= (int) id__    };marks,this,basic,block,as,belonging,to,the,given,subroutine,param,id,a,subroutine,id,param,nb,subroutines,the,total,number,of,subroutines,in,the,method;void,add,to,subroutine,final,long,id,final,int,nb,subroutines,if,status,visited,0,status,visited,src,and,ref,positions,new,int,nb,subroutines,32,1,src,and,ref,positions,int,id,32,int,id
Label -> void addToSubroutine(final long id, final int nbSubroutines);1416998550;Marks this basic block as belonging to the given subroutine.__@param id_a subroutine id._@param nbSubroutines_the total number of subroutines in the method.;void addToSubroutine(final long id, final int nbSubroutines) {_        if ((status & VISITED) == 0) {_            status |= VISITED__            srcAndRefPositions = new int[nbSubroutines / 32 + 1]__        }_        srcAndRefPositions[(int) (id >>> 32)] |= (int) id__    };marks,this,basic,block,as,belonging,to,the,given,subroutine,param,id,a,subroutine,id,param,nb,subroutines,the,total,number,of,subroutines,in,the,method;void,add,to,subroutine,final,long,id,final,int,nb,subroutines,if,status,visited,0,status,visited,src,and,ref,positions,new,int,nb,subroutines,32,1,src,and,ref,positions,int,id,32,int,id
Label -> void addToSubroutine(final long id, final int nbSubroutines);1483093254;Marks this basic block as belonging to the given subroutine.__@param id_a subroutine id._@param nbSubroutines_the total number of subroutines in the method.;void addToSubroutine(final long id, final int nbSubroutines) {_        if ((status & VISITED) == 0) {_            status |= VISITED__            srcAndRefPositions = new int[nbSubroutines / 32 + 1]__        }_        srcAndRefPositions[(int) (id >>> 32)] |= (int) id__    };marks,this,basic,block,as,belonging,to,the,given,subroutine,param,id,a,subroutine,id,param,nb,subroutines,the,total,number,of,subroutines,in,the,method;void,add,to,subroutine,final,long,id,final,int,nb,subroutines,if,status,visited,0,status,visited,src,and,ref,positions,new,int,nb,subroutines,32,1,src,and,ref,positions,int,id,32,int,id
Label -> private Label pushSuccessors(final Label listOfLabelsToProcess);1531241461;Adds the successors of this label in the method's control flow graph (except those_corresponding to a jsr target, and those already in a list of labels) to the given list of_blocks to process, and returns the new list.__@param listOfLabelsToProcess a list of basic blocks to process, linked together with their_{@link #nextListElement} field._@return the new list of blocks to process.;private Label pushSuccessors(final Label listOfLabelsToProcess) {_    Label newListOfLabelsToProcess = listOfLabelsToProcess__    Edge outgoingEdge = outgoingEdges__    while (outgoingEdge != null) {_      _      _      boolean isJsrTarget =_          (flags & Label.FLAG_SUBROUTINE_CALLER) != 0 && outgoingEdge == outgoingEdges.nextEdge__      if (!isJsrTarget && outgoingEdge.successor.nextListElement == null) {_        _        _        outgoingEdge.successor.nextListElement = newListOfLabelsToProcess__        newListOfLabelsToProcess = outgoingEdge.successor__      }_      outgoingEdge = outgoingEdge.nextEdge__    }_    return newListOfLabelsToProcess__  };adds,the,successors,of,this,label,in,the,method,s,control,flow,graph,except,those,corresponding,to,a,jsr,target,and,those,already,in,a,list,of,labels,to,the,given,list,of,blocks,to,process,and,returns,the,new,list,param,list,of,labels,to,process,a,list,of,basic,blocks,to,process,linked,together,with,their,link,next,list,element,field,return,the,new,list,of,blocks,to,process;private,label,push,successors,final,label,list,of,labels,to,process,label,new,list,of,labels,to,process,list,of,labels,to,process,edge,outgoing,edge,outgoing,edges,while,outgoing,edge,null,boolean,is,jsr,target,flags,label,0,outgoing,edge,outgoing,edges,next,edge,if,is,jsr,target,outgoing,edge,successor,next,list,element,null,outgoing,edge,successor,next,list,element,new,list,of,labels,to,process,new,list,of,labels,to,process,outgoing,edge,successor,outgoing,edge,outgoing,edge,next,edge,return,new,list,of,labels,to,process
Label -> private Label pushSuccessors(final Label listOfLabelsToProcess);1536664245;Adds the successors of this label in the method's control flow graph (except those_corresponding to a jsr target, and those already in a list of labels) to the given list of_blocks to process, and returns the new list.__@param listOfLabelsToProcess a list of basic blocks to process, linked together with their_{@link #nextListElement} field._@return the new list of blocks to process.;private Label pushSuccessors(final Label listOfLabelsToProcess) {_    Label newListOfLabelsToProcess = listOfLabelsToProcess__    Edge outgoingEdge = outgoingEdges__    while (outgoingEdge != null) {_      _      _      boolean isJsrTarget =_          (flags & Label.FLAG_SUBROUTINE_CALLER) != 0 && outgoingEdge == outgoingEdges.nextEdge__      if (!isJsrTarget && outgoingEdge.successor.nextListElement == null) {_        _        _        outgoingEdge.successor.nextListElement = newListOfLabelsToProcess__        newListOfLabelsToProcess = outgoingEdge.successor__      }_      outgoingEdge = outgoingEdge.nextEdge__    }_    return newListOfLabelsToProcess__  };adds,the,successors,of,this,label,in,the,method,s,control,flow,graph,except,those,corresponding,to,a,jsr,target,and,those,already,in,a,list,of,labels,to,the,given,list,of,blocks,to,process,and,returns,the,new,list,param,list,of,labels,to,process,a,list,of,basic,blocks,to,process,linked,together,with,their,link,next,list,element,field,return,the,new,list,of,blocks,to,process;private,label,push,successors,final,label,list,of,labels,to,process,label,new,list,of,labels,to,process,list,of,labels,to,process,edge,outgoing,edge,outgoing,edges,while,outgoing,edge,null,boolean,is,jsr,target,flags,label,0,outgoing,edge,outgoing,edges,next,edge,if,is,jsr,target,outgoing,edge,successor,next,list,element,null,outgoing,edge,successor,next,list,element,new,list,of,labels,to,process,new,list,of,labels,to,process,outgoing,edge,successor,outgoing,edge,outgoing,edge,next,edge,return,new,list,of,labels,to,process
Label -> private Label pushSuccessors(final Label listOfLabelsToProcess);1537204147;Adds the successors of this label in the method's control flow graph (except those_corresponding to a jsr target, and those already in a list of labels) to the given list of_blocks to process, and returns the new list.__@param listOfLabelsToProcess a list of basic blocks to process, linked together with their_{@link #nextListElement} field._@return the new list of blocks to process.;private Label pushSuccessors(final Label listOfLabelsToProcess) {_    Label newListOfLabelsToProcess = listOfLabelsToProcess__    Edge outgoingEdge = outgoingEdges__    while (outgoingEdge != null) {_      _      _      boolean isJsrTarget =_          (flags & Label.FLAG_SUBROUTINE_CALLER) != 0 && outgoingEdge == outgoingEdges.nextEdge__      if (!isJsrTarget && outgoingEdge.successor.nextListElement == null) {_        _        _        outgoingEdge.successor.nextListElement = newListOfLabelsToProcess__        newListOfLabelsToProcess = outgoingEdge.successor__      }_      outgoingEdge = outgoingEdge.nextEdge__    }_    return newListOfLabelsToProcess__  };adds,the,successors,of,this,label,in,the,method,s,control,flow,graph,except,those,corresponding,to,a,jsr,target,and,those,already,in,a,list,of,labels,to,the,given,list,of,blocks,to,process,and,returns,the,new,list,param,list,of,labels,to,process,a,list,of,basic,blocks,to,process,linked,together,with,their,link,next,list,element,field,return,the,new,list,of,blocks,to,process;private,label,push,successors,final,label,list,of,labels,to,process,label,new,list,of,labels,to,process,list,of,labels,to,process,edge,outgoing,edge,outgoing,edges,while,outgoing,edge,null,boolean,is,jsr,target,flags,label,0,outgoing,edge,outgoing,edges,next,edge,if,is,jsr,target,outgoing,edge,successor,next,list,element,null,outgoing,edge,successor,next,list,element,new,list,of,labels,to,process,new,list,of,labels,to,process,outgoing,edge,successor,outgoing,edge,outgoing,edge,next,edge,return,new,list,of,labels,to,process
Label -> private void addReference(final int sourcePosition,             final int referencePosition);1366718246;Adds a forward reference to this label. This method must be called only_for a true forward reference, i.e. only if this label is not resolved_yet. For backward references, the offset of the reference can be, and_must be, computed and stored directly.__@param sourcePosition_the position of the referencing instruction. This position_will be used to compute the offset of this forward reference._@param referencePosition_the position where the offset for this forward reference must_be stored.;private void addReference(final int sourcePosition,_            final int referencePosition) {_        if (srcAndRefPositions == null) {_            srcAndRefPositions = new int[6]__        }_        if (referenceCount >= srcAndRefPositions.length) {_            int[] a = new int[srcAndRefPositions.length + 6]__            System.arraycopy(srcAndRefPositions, 0, a, 0,_                    srcAndRefPositions.length)__            srcAndRefPositions = a__        }_        srcAndRefPositions[referenceCount++] = sourcePosition__        srcAndRefPositions[referenceCount++] = referencePosition__    };adds,a,forward,reference,to,this,label,this,method,must,be,called,only,for,a,true,forward,reference,i,e,only,if,this,label,is,not,resolved,yet,for,backward,references,the,offset,of,the,reference,can,be,and,must,be,computed,and,stored,directly,param,source,position,the,position,of,the,referencing,instruction,this,position,will,be,used,to,compute,the,offset,of,this,forward,reference,param,reference,position,the,position,where,the,offset,for,this,forward,reference,must,be,stored;private,void,add,reference,final,int,source,position,final,int,reference,position,if,src,and,ref,positions,null,src,and,ref,positions,new,int,6,if,reference,count,src,and,ref,positions,length,int,a,new,int,src,and,ref,positions,length,6,system,arraycopy,src,and,ref,positions,0,a,0,src,and,ref,positions,length,src,and,ref,positions,a,src,and,ref,positions,reference,count,source,position,src,and,ref,positions,reference,count,reference,position
Label -> private void addReference(final int sourcePosition,             final int referencePosition);1385501137;Adds a forward reference to this label. This method must be called only_for a true forward reference, i.e. only if this label is not resolved_yet. For backward references, the offset of the reference can be, and_must be, computed and stored directly.__@param sourcePosition_the position of the referencing instruction. This position_will be used to compute the offset of this forward reference._@param referencePosition_the position where the offset for this forward reference must_be stored.;private void addReference(final int sourcePosition,_            final int referencePosition) {_        if (srcAndRefPositions == null) {_            srcAndRefPositions = new int[6]__        }_        if (referenceCount >= srcAndRefPositions.length) {_            int[] a = new int[srcAndRefPositions.length + 6]__            System.arraycopy(srcAndRefPositions, 0, a, 0,_                    srcAndRefPositions.length)__            srcAndRefPositions = a__        }_        srcAndRefPositions[referenceCount++] = sourcePosition__        srcAndRefPositions[referenceCount++] = referencePosition__    };adds,a,forward,reference,to,this,label,this,method,must,be,called,only,for,a,true,forward,reference,i,e,only,if,this,label,is,not,resolved,yet,for,backward,references,the,offset,of,the,reference,can,be,and,must,be,computed,and,stored,directly,param,source,position,the,position,of,the,referencing,instruction,this,position,will,be,used,to,compute,the,offset,of,this,forward,reference,param,reference,position,the,position,where,the,offset,for,this,forward,reference,must,be,stored;private,void,add,reference,final,int,source,position,final,int,reference,position,if,src,and,ref,positions,null,src,and,ref,positions,new,int,6,if,reference,count,src,and,ref,positions,length,int,a,new,int,src,and,ref,positions,length,6,system,arraycopy,src,and,ref,positions,0,a,0,src,and,ref,positions,length,src,and,ref,positions,a,src,and,ref,positions,reference,count,source,position,src,and,ref,positions,reference,count,reference,position
Label -> private void addReference(final int sourcePosition,             final int referencePosition);1400531367;Adds a forward reference to this label. This method must be called only_for a true forward reference, i.e. only if this label is not resolved_yet. For backward references, the offset of the reference can be, and_must be, computed and stored directly.__@param sourcePosition_the position of the referencing instruction. This position_will be used to compute the offset of this forward reference._@param referencePosition_the position where the offset for this forward reference must_be stored.;private void addReference(final int sourcePosition,_            final int referencePosition) {_        if (srcAndRefPositions == null) {_            srcAndRefPositions = new int[6]__        }_        if (referenceCount >= srcAndRefPositions.length) {_            int[] a = new int[srcAndRefPositions.length + 6]__            System.arraycopy(srcAndRefPositions, 0, a, 0,_                    srcAndRefPositions.length)__            srcAndRefPositions = a__        }_        srcAndRefPositions[referenceCount++] = sourcePosition__        srcAndRefPositions[referenceCount++] = referencePosition__    };adds,a,forward,reference,to,this,label,this,method,must,be,called,only,for,a,true,forward,reference,i,e,only,if,this,label,is,not,resolved,yet,for,backward,references,the,offset,of,the,reference,can,be,and,must,be,computed,and,stored,directly,param,source,position,the,position,of,the,referencing,instruction,this,position,will,be,used,to,compute,the,offset,of,this,forward,reference,param,reference,position,the,position,where,the,offset,for,this,forward,reference,must,be,stored;private,void,add,reference,final,int,source,position,final,int,reference,position,if,src,and,ref,positions,null,src,and,ref,positions,new,int,6,if,reference,count,src,and,ref,positions,length,int,a,new,int,src,and,ref,positions,length,6,system,arraycopy,src,and,ref,positions,0,a,0,src,and,ref,positions,length,src,and,ref,positions,a,src,and,ref,positions,reference,count,source,position,src,and,ref,positions,reference,count,reference,position
Label -> private void addReference(final int sourcePosition,             final int referencePosition);1416998550;Adds a forward reference to this label. This method must be called only_for a true forward reference, i.e. only if this label is not resolved_yet. For backward references, the offset of the reference can be, and_must be, computed and stored directly.__@param sourcePosition_the position of the referencing instruction. This position_will be used to compute the offset of this forward reference._@param referencePosition_the position where the offset for this forward reference must_be stored.;private void addReference(final int sourcePosition,_            final int referencePosition) {_        if (srcAndRefPositions == null) {_            srcAndRefPositions = new int[6]__        }_        if (referenceCount >= srcAndRefPositions.length) {_            int[] a = new int[srcAndRefPositions.length + 6]__            System.arraycopy(srcAndRefPositions, 0, a, 0,_                    srcAndRefPositions.length)__            srcAndRefPositions = a__        }_        srcAndRefPositions[referenceCount++] = sourcePosition__        srcAndRefPositions[referenceCount++] = referencePosition__    };adds,a,forward,reference,to,this,label,this,method,must,be,called,only,for,a,true,forward,reference,i,e,only,if,this,label,is,not,resolved,yet,for,backward,references,the,offset,of,the,reference,can,be,and,must,be,computed,and,stored,directly,param,source,position,the,position,of,the,referencing,instruction,this,position,will,be,used,to,compute,the,offset,of,this,forward,reference,param,reference,position,the,position,where,the,offset,for,this,forward,reference,must,be,stored;private,void,add,reference,final,int,source,position,final,int,reference,position,if,src,and,ref,positions,null,src,and,ref,positions,new,int,6,if,reference,count,src,and,ref,positions,length,int,a,new,int,src,and,ref,positions,length,6,system,arraycopy,src,and,ref,positions,0,a,0,src,and,ref,positions,length,src,and,ref,positions,a,src,and,ref,positions,reference,count,source,position,src,and,ref,positions,reference,count,reference,position
Label -> private void addReference(final int sourcePosition,             final int referencePosition);1483093254;Adds a forward reference to this label. This method must be called only_for a true forward reference, i.e. only if this label is not resolved_yet. For backward references, the offset of the reference can be, and_must be, computed and stored directly.__@param sourcePosition_the position of the referencing instruction. This position_will be used to compute the offset of this forward reference._@param referencePosition_the position where the offset for this forward reference must_be stored.;private void addReference(final int sourcePosition,_            final int referencePosition) {_        if (srcAndRefPositions == null) {_            srcAndRefPositions = new int[6]__        }_        if (referenceCount >= srcAndRefPositions.length) {_            int[] a = new int[srcAndRefPositions.length + 6]__            System.arraycopy(srcAndRefPositions, 0, a, 0,_                    srcAndRefPositions.length)__            srcAndRefPositions = a__        }_        srcAndRefPositions[referenceCount++] = sourcePosition__        srcAndRefPositions[referenceCount++] = referencePosition__    };adds,a,forward,reference,to,this,label,this,method,must,be,called,only,for,a,true,forward,reference,i,e,only,if,this,label,is,not,resolved,yet,for,backward,references,the,offset,of,the,reference,can,be,and,must,be,computed,and,stored,directly,param,source,position,the,position,of,the,referencing,instruction,this,position,will,be,used,to,compute,the,offset,of,this,forward,reference,param,reference,position,the,position,where,the,offset,for,this,forward,reference,must,be,stored;private,void,add,reference,final,int,source,position,final,int,reference,position,if,src,and,ref,positions,null,src,and,ref,positions,new,int,6,if,reference,count,src,and,ref,positions,length,int,a,new,int,src,and,ref,positions,length,6,system,arraycopy,src,and,ref,positions,0,a,0,src,and,ref,positions,length,src,and,ref,positions,a,src,and,ref,positions,reference,count,source,position,src,and,ref,positions,reference,count,reference,position
Label -> final void accept(final MethodVisitor methodVisitor, final boolean visitLineNumbers);1531241461;Makes the given visitor visit this label and its source line numbers, if applicable.__@param methodVisitor a method visitor._@param visitLineNumbers whether to visit of the label's source line numbers, if any.;final void accept(final MethodVisitor methodVisitor, final boolean visitLineNumbers) {_    methodVisitor.visitLabel(this)__    if (visitLineNumbers && lineNumber != 0) {_      methodVisitor.visitLineNumber(lineNumber & 0xFFFF, this)__      if (otherLineNumbers != null) {_        for (int i = 1_ i <= otherLineNumbers[0]_ ++i) {_          methodVisitor.visitLineNumber(otherLineNumbers[i], this)__        }_      }_    }_  };makes,the,given,visitor,visit,this,label,and,its,source,line,numbers,if,applicable,param,method,visitor,a,method,visitor,param,visit,line,numbers,whether,to,visit,of,the,label,s,source,line,numbers,if,any;final,void,accept,final,method,visitor,method,visitor,final,boolean,visit,line,numbers,method,visitor,visit,label,this,if,visit,line,numbers,line,number,0,method,visitor,visit,line,number,line,number,0x,ffff,this,if,other,line,numbers,null,for,int,i,1,i,other,line,numbers,0,i,method,visitor,visit,line,number,other,line,numbers,i,this
Label -> final void accept(final MethodVisitor methodVisitor, final boolean visitLineNumbers);1536664245;Makes the given visitor visit this label and its source line numbers, if applicable.__@param methodVisitor a method visitor._@param visitLineNumbers whether to visit of the label's source line numbers, if any.;final void accept(final MethodVisitor methodVisitor, final boolean visitLineNumbers) {_    methodVisitor.visitLabel(this)__    if (visitLineNumbers && lineNumber != 0) {_      methodVisitor.visitLineNumber(lineNumber & 0xFFFF, this)__      if (otherLineNumbers != null) {_        for (int i = 1_ i <= otherLineNumbers[0]_ ++i) {_          methodVisitor.visitLineNumber(otherLineNumbers[i], this)__        }_      }_    }_  };makes,the,given,visitor,visit,this,label,and,its,source,line,numbers,if,applicable,param,method,visitor,a,method,visitor,param,visit,line,numbers,whether,to,visit,of,the,label,s,source,line,numbers,if,any;final,void,accept,final,method,visitor,method,visitor,final,boolean,visit,line,numbers,method,visitor,visit,label,this,if,visit,line,numbers,line,number,0,method,visitor,visit,line,number,line,number,0x,ffff,this,if,other,line,numbers,null,for,int,i,1,i,other,line,numbers,0,i,method,visitor,visit,line,number,other,line,numbers,i,this
Label -> final void accept(final MethodVisitor methodVisitor, final boolean visitLineNumbers);1537204147;Makes the given visitor visit this label and its source line numbers, if applicable.__@param methodVisitor a method visitor._@param visitLineNumbers whether to visit of the label's source line numbers, if any.;final void accept(final MethodVisitor methodVisitor, final boolean visitLineNumbers) {_    methodVisitor.visitLabel(this)__    if (visitLineNumbers && lineNumber != 0) {_      methodVisitor.visitLineNumber(lineNumber & 0xFFFF, this)__      if (otherLineNumbers != null) {_        for (int i = 1_ i <= otherLineNumbers[0]_ ++i) {_          methodVisitor.visitLineNumber(otherLineNumbers[i], this)__        }_      }_    }_  };makes,the,given,visitor,visit,this,label,and,its,source,line,numbers,if,applicable,param,method,visitor,a,method,visitor,param,visit,line,numbers,whether,to,visit,of,the,label,s,source,line,numbers,if,any;final,void,accept,final,method,visitor,method,visitor,final,boolean,visit,line,numbers,method,visitor,visit,label,this,if,visit,line,numbers,line,number,0,method,visitor,visit,line,number,line,number,0x,ffff,this,if,other,line,numbers,null,for,int,i,1,i,other,line,numbers,0,i,method,visitor,visit,line,number,other,line,numbers,i,this
Label -> final void addLineNumber(final int lineNumber);1531241461;Adds a source line number corresponding to this label.__@param lineNumber a source line number (which should be strictly positive).;final void addLineNumber(final int lineNumber) {_    if (this.lineNumber == 0) {_      this.lineNumber = (short) lineNumber__    } else {_      if (otherLineNumbers == null) {_        otherLineNumbers = new int[LINE_NUMBERS_CAPACITY_INCREMENT]__      }_      int otherLineNumberIndex = ++otherLineNumbers[0]__      if (otherLineNumberIndex >= otherLineNumbers.length) {_        int[] newLineNumbers = new int[otherLineNumbers.length + LINE_NUMBERS_CAPACITY_INCREMENT]__        System.arraycopy(otherLineNumbers, 0, newLineNumbers, 0, otherLineNumbers.length)__        otherLineNumbers = newLineNumbers__      }_      otherLineNumbers[otherLineNumberIndex] = lineNumber__    }_  };adds,a,source,line,number,corresponding,to,this,label,param,line,number,a,source,line,number,which,should,be,strictly,positive;final,void,add,line,number,final,int,line,number,if,this,line,number,0,this,line,number,short,line,number,else,if,other,line,numbers,null,other,line,numbers,new,int,int,other,line,number,index,other,line,numbers,0,if,other,line,number,index,other,line,numbers,length,int,new,line,numbers,new,int,other,line,numbers,length,system,arraycopy,other,line,numbers,0,new,line,numbers,0,other,line,numbers,length,other,line,numbers,new,line,numbers,other,line,numbers,other,line,number,index,line,number
Label -> final void addLineNumber(final int lineNumber);1536664245;Adds a source line number corresponding to this label.__@param lineNumber a source line number (which should be strictly positive).;final void addLineNumber(final int lineNumber) {_    if (this.lineNumber == 0) {_      this.lineNumber = (short) lineNumber__    } else {_      if (otherLineNumbers == null) {_        otherLineNumbers = new int[LINE_NUMBERS_CAPACITY_INCREMENT]__      }_      int otherLineNumberIndex = ++otherLineNumbers[0]__      if (otherLineNumberIndex >= otherLineNumbers.length) {_        int[] newLineNumbers = new int[otherLineNumbers.length + LINE_NUMBERS_CAPACITY_INCREMENT]__        System.arraycopy(otherLineNumbers, 0, newLineNumbers, 0, otherLineNumbers.length)__        otherLineNumbers = newLineNumbers__      }_      otherLineNumbers[otherLineNumberIndex] = lineNumber__    }_  };adds,a,source,line,number,corresponding,to,this,label,param,line,number,a,source,line,number,which,should,be,strictly,positive;final,void,add,line,number,final,int,line,number,if,this,line,number,0,this,line,number,short,line,number,else,if,other,line,numbers,null,other,line,numbers,new,int,int,other,line,number,index,other,line,numbers,0,if,other,line,number,index,other,line,numbers,length,int,new,line,numbers,new,int,other,line,numbers,length,system,arraycopy,other,line,numbers,0,new,line,numbers,0,other,line,numbers,length,other,line,numbers,new,line,numbers,other,line,numbers,other,line,number,index,line,number
Label -> final void addLineNumber(final int lineNumber);1537204147;Adds a source line number corresponding to this label.__@param lineNumber a source line number (which should be strictly positive).;final void addLineNumber(final int lineNumber) {_    if (this.lineNumber == 0) {_      this.lineNumber = (short) lineNumber__    } else {_      if (otherLineNumbers == null) {_        otherLineNumbers = new int[LINE_NUMBERS_CAPACITY_INCREMENT]__      }_      int otherLineNumberIndex = ++otherLineNumbers[0]__      if (otherLineNumberIndex >= otherLineNumbers.length) {_        int[] newLineNumbers = new int[otherLineNumbers.length + LINE_NUMBERS_CAPACITY_INCREMENT]__        System.arraycopy(otherLineNumbers, 0, newLineNumbers, 0, otherLineNumbers.length)__        otherLineNumbers = newLineNumbers__      }_      otherLineNumbers[otherLineNumberIndex] = lineNumber__    }_  };adds,a,source,line,number,corresponding,to,this,label,param,line,number,a,source,line,number,which,should,be,strictly,positive;final,void,add,line,number,final,int,line,number,if,this,line,number,0,this,line,number,short,line,number,else,if,other,line,numbers,null,other,line,numbers,new,int,int,other,line,number,index,other,line,numbers,0,if,other,line,number,index,other,line,numbers,length,int,new,line,numbers,new,int,other,line,numbers,length,system,arraycopy,other,line,numbers,0,new,line,numbers,0,other,line,numbers,length,other,line,numbers,new,line,numbers,other,line,numbers,other,line,number,index,line,number
Label -> void visitSubroutine(final Label JSR, final long id, final int nbSubroutines);1366718246;Finds the basic blocks that belong to a given subroutine, and marks these_blocks as belonging to this subroutine. This method follows the control_flow graph to find all the blocks that are reachable from the current_block WITHOUT following any JSR target.__@param JSR_a JSR block that jumps to this subroutine. If this JSR is not_null it is added to the successor of the RET blocks found in_the subroutine._@param id_the id of this subroutine._@param nbSubroutines_the total number of subroutines in the method.;void visitSubroutine(final Label JSR, final long id, final int nbSubroutines) {_        _        _        Label stack = this__        while (stack != null) {_            _            Label l = stack__            stack = l.next__            l.next = null___            if (JSR != null) {_                if ((l.status & VISITED2) != 0) {_                    continue__                }_                l.status |= VISITED2__                _                if ((l.status & RET) != 0) {_                    if (!l.inSameSubroutine(JSR)) {_                        Edge e = new Edge()__                        e.info = l.inputStackTop__                        e.successor = JSR.successors.successor__                        e.next = l.successors__                        l.successors = e__                    }_                }_            } else {_                _                if (l.inSubroutine(id)) {_                    continue__                }_                _                l.addToSubroutine(id, nbSubroutines)__            }_            _            Edge e = l.successors__            while (e != null) {_                _                _                _                if ((l.status & Label.JSR) == 0 || e != l.successors.next) {_                    _                    if (e.successor.next == null) {_                        e.successor.next = stack__                        stack = e.successor__                    }_                }_                e = e.next__            }_        }_    };finds,the,basic,blocks,that,belong,to,a,given,subroutine,and,marks,these,blocks,as,belonging,to,this,subroutine,this,method,follows,the,control,flow,graph,to,find,all,the,blocks,that,are,reachable,from,the,current,block,without,following,any,jsr,target,param,jsr,a,jsr,block,that,jumps,to,this,subroutine,if,this,jsr,is,not,null,it,is,added,to,the,successor,of,the,ret,blocks,found,in,the,subroutine,param,id,the,id,of,this,subroutine,param,nb,subroutines,the,total,number,of,subroutines,in,the,method;void,visit,subroutine,final,label,jsr,final,long,id,final,int,nb,subroutines,label,stack,this,while,stack,null,label,l,stack,stack,l,next,l,next,null,if,jsr,null,if,l,status,visited2,0,continue,l,status,visited2,if,l,status,ret,0,if,l,in,same,subroutine,jsr,edge,e,new,edge,e,info,l,input,stack,top,e,successor,jsr,successors,successor,e,next,l,successors,l,successors,e,else,if,l,in,subroutine,id,continue,l,add,to,subroutine,id,nb,subroutines,edge,e,l,successors,while,e,null,if,l,status,label,jsr,0,e,l,successors,next,if,e,successor,next,null,e,successor,next,stack,stack,e,successor,e,e,next
Label -> void visitSubroutine(final Label JSR, final long id, final int nbSubroutines);1385501137;Finds the basic blocks that belong to a given subroutine, and marks these_blocks as belonging to this subroutine. This method follows the control_flow graph to find all the blocks that are reachable from the current_block WITHOUT following any JSR target.__@param JSR_a JSR block that jumps to this subroutine. If this JSR is not_null it is added to the successor of the RET blocks found in_the subroutine._@param id_the id of this subroutine._@param nbSubroutines_the total number of subroutines in the method.;void visitSubroutine(final Label JSR, final long id, final int nbSubroutines) {_        _        _        Label stack = this__        while (stack != null) {_            _            Label l = stack__            stack = l.next__            l.next = null___            if (JSR != null) {_                if ((l.status & VISITED2) != 0) {_                    continue__                }_                l.status |= VISITED2__                _                if ((l.status & RET) != 0) {_                    if (!l.inSameSubroutine(JSR)) {_                        Edge e = new Edge()__                        e.info = l.inputStackTop__                        e.successor = JSR.successors.successor__                        e.next = l.successors__                        l.successors = e__                    }_                }_            } else {_                _                if (l.inSubroutine(id)) {_                    continue__                }_                _                l.addToSubroutine(id, nbSubroutines)__            }_            _            Edge e = l.successors__            while (e != null) {_                _                _                _                if ((l.status & Label.JSR) == 0 || e != l.successors.next) {_                    _                    if (e.successor.next == null) {_                        e.successor.next = stack__                        stack = e.successor__                    }_                }_                e = e.next__            }_        }_    };finds,the,basic,blocks,that,belong,to,a,given,subroutine,and,marks,these,blocks,as,belonging,to,this,subroutine,this,method,follows,the,control,flow,graph,to,find,all,the,blocks,that,are,reachable,from,the,current,block,without,following,any,jsr,target,param,jsr,a,jsr,block,that,jumps,to,this,subroutine,if,this,jsr,is,not,null,it,is,added,to,the,successor,of,the,ret,blocks,found,in,the,subroutine,param,id,the,id,of,this,subroutine,param,nb,subroutines,the,total,number,of,subroutines,in,the,method;void,visit,subroutine,final,label,jsr,final,long,id,final,int,nb,subroutines,label,stack,this,while,stack,null,label,l,stack,stack,l,next,l,next,null,if,jsr,null,if,l,status,visited2,0,continue,l,status,visited2,if,l,status,ret,0,if,l,in,same,subroutine,jsr,edge,e,new,edge,e,info,l,input,stack,top,e,successor,jsr,successors,successor,e,next,l,successors,l,successors,e,else,if,l,in,subroutine,id,continue,l,add,to,subroutine,id,nb,subroutines,edge,e,l,successors,while,e,null,if,l,status,label,jsr,0,e,l,successors,next,if,e,successor,next,null,e,successor,next,stack,stack,e,successor,e,e,next
Label -> void visitSubroutine(final Label JSR, final long id, final int nbSubroutines);1400531367;Finds the basic blocks that belong to a given subroutine, and marks these_blocks as belonging to this subroutine. This method follows the control_flow graph to find all the blocks that are reachable from the current_block WITHOUT following any JSR target.__@param JSR_a JSR block that jumps to this subroutine. If this JSR is not_null it is added to the successor of the RET blocks found in_the subroutine._@param id_the id of this subroutine._@param nbSubroutines_the total number of subroutines in the method.;void visitSubroutine(final Label JSR, final long id, final int nbSubroutines) {_        _        _        Label stack = this__        while (stack != null) {_            _            Label l = stack__            stack = l.next__            l.next = null___            if (JSR != null) {_                if ((l.status & VISITED2) != 0) {_                    continue__                }_                l.status |= VISITED2__                _                if ((l.status & RET) != 0) {_                    if (!l.inSameSubroutine(JSR)) {_                        Edge e = new Edge()__                        e.info = l.inputStackTop__                        e.successor = JSR.successors.successor__                        e.next = l.successors__                        l.successors = e__                    }_                }_            } else {_                _                if (l.inSubroutine(id)) {_                    continue__                }_                _                l.addToSubroutine(id, nbSubroutines)__            }_            _            Edge e = l.successors__            while (e != null) {_                _                _                _                if ((l.status & Label.JSR) == 0 || e != l.successors.next) {_                    _                    if (e.successor.next == null) {_                        e.successor.next = stack__                        stack = e.successor__                    }_                }_                e = e.next__            }_        }_    };finds,the,basic,blocks,that,belong,to,a,given,subroutine,and,marks,these,blocks,as,belonging,to,this,subroutine,this,method,follows,the,control,flow,graph,to,find,all,the,blocks,that,are,reachable,from,the,current,block,without,following,any,jsr,target,param,jsr,a,jsr,block,that,jumps,to,this,subroutine,if,this,jsr,is,not,null,it,is,added,to,the,successor,of,the,ret,blocks,found,in,the,subroutine,param,id,the,id,of,this,subroutine,param,nb,subroutines,the,total,number,of,subroutines,in,the,method;void,visit,subroutine,final,label,jsr,final,long,id,final,int,nb,subroutines,label,stack,this,while,stack,null,label,l,stack,stack,l,next,l,next,null,if,jsr,null,if,l,status,visited2,0,continue,l,status,visited2,if,l,status,ret,0,if,l,in,same,subroutine,jsr,edge,e,new,edge,e,info,l,input,stack,top,e,successor,jsr,successors,successor,e,next,l,successors,l,successors,e,else,if,l,in,subroutine,id,continue,l,add,to,subroutine,id,nb,subroutines,edge,e,l,successors,while,e,null,if,l,status,label,jsr,0,e,l,successors,next,if,e,successor,next,null,e,successor,next,stack,stack,e,successor,e,e,next
Label -> void visitSubroutine(final Label JSR, final long id, final int nbSubroutines);1416998550;Finds the basic blocks that belong to a given subroutine, and marks these_blocks as belonging to this subroutine. This method follows the control_flow graph to find all the blocks that are reachable from the current_block WITHOUT following any JSR target.__@param JSR_a JSR block that jumps to this subroutine. If this JSR is not_null it is added to the successor of the RET blocks found in_the subroutine._@param id_the id of this subroutine._@param nbSubroutines_the total number of subroutines in the method.;void visitSubroutine(final Label JSR, final long id, final int nbSubroutines) {_        _        _        Label stack = this__        while (stack != null) {_            _            Label l = stack__            stack = l.next__            l.next = null___            if (JSR != null) {_                if ((l.status & VISITED2) != 0) {_                    continue__                }_                l.status |= VISITED2__                _                if ((l.status & RET) != 0) {_                    if (!l.inSameSubroutine(JSR)) {_                        Edge e = new Edge()__                        e.info = l.inputStackTop__                        e.successor = JSR.successors.successor__                        e.next = l.successors__                        l.successors = e__                    }_                }_            } else {_                _                if (l.inSubroutine(id)) {_                    continue__                }_                _                l.addToSubroutine(id, nbSubroutines)__            }_            _            Edge e = l.successors__            while (e != null) {_                _                _                _                if ((l.status & Label.JSR) == 0 || e != l.successors.next) {_                    _                    if (e.successor.next == null) {_                        e.successor.next = stack__                        stack = e.successor__                    }_                }_                e = e.next__            }_        }_    };finds,the,basic,blocks,that,belong,to,a,given,subroutine,and,marks,these,blocks,as,belonging,to,this,subroutine,this,method,follows,the,control,flow,graph,to,find,all,the,blocks,that,are,reachable,from,the,current,block,without,following,any,jsr,target,param,jsr,a,jsr,block,that,jumps,to,this,subroutine,if,this,jsr,is,not,null,it,is,added,to,the,successor,of,the,ret,blocks,found,in,the,subroutine,param,id,the,id,of,this,subroutine,param,nb,subroutines,the,total,number,of,subroutines,in,the,method;void,visit,subroutine,final,label,jsr,final,long,id,final,int,nb,subroutines,label,stack,this,while,stack,null,label,l,stack,stack,l,next,l,next,null,if,jsr,null,if,l,status,visited2,0,continue,l,status,visited2,if,l,status,ret,0,if,l,in,same,subroutine,jsr,edge,e,new,edge,e,info,l,input,stack,top,e,successor,jsr,successors,successor,e,next,l,successors,l,successors,e,else,if,l,in,subroutine,id,continue,l,add,to,subroutine,id,nb,subroutines,edge,e,l,successors,while,e,null,if,l,status,label,jsr,0,e,l,successors,next,if,e,successor,next,null,e,successor,next,stack,stack,e,successor,e,e,next
Label -> void visitSubroutine(final Label JSR, final long id, final int nbSubroutines);1483093254;Finds the basic blocks that belong to a given subroutine, and marks these_blocks as belonging to this subroutine. This method follows the control_flow graph to find all the blocks that are reachable from the current_block WITHOUT following any JSR target.__@param JSR_a JSR block that jumps to this subroutine. If this JSR is not_null it is added to the successor of the RET blocks found in_the subroutine._@param id_the id of this subroutine._@param nbSubroutines_the total number of subroutines in the method.;void visitSubroutine(final Label JSR, final long id, final int nbSubroutines) {_        _        _        Label stack = this__        while (stack != null) {_            _            Label l = stack__            stack = l.next__            l.next = null___            if (JSR != null) {_                if ((l.status & VISITED2) != 0) {_                    continue__                }_                l.status |= VISITED2__                _                if ((l.status & RET) != 0) {_                    if (!l.inSameSubroutine(JSR)) {_                        Edge e = new Edge()__                        e.info = l.inputStackTop__                        e.successor = JSR.successors.successor__                        e.next = l.successors__                        l.successors = e__                    }_                }_            } else {_                _                if (l.inSubroutine(id)) {_                    continue__                }_                _                l.addToSubroutine(id, nbSubroutines)__            }_            _            Edge e = l.successors__            while (e != null) {_                _                _                _                if ((l.status & Label.JSR) == 0 || e != l.successors.next) {_                    _                    if (e.successor.next == null) {_                        e.successor.next = stack__                        stack = e.successor__                    }_                }_                e = e.next__            }_        }_    };finds,the,basic,blocks,that,belong,to,a,given,subroutine,and,marks,these,blocks,as,belonging,to,this,subroutine,this,method,follows,the,control,flow,graph,to,find,all,the,blocks,that,are,reachable,from,the,current,block,without,following,any,jsr,target,param,jsr,a,jsr,block,that,jumps,to,this,subroutine,if,this,jsr,is,not,null,it,is,added,to,the,successor,of,the,ret,blocks,found,in,the,subroutine,param,id,the,id,of,this,subroutine,param,nb,subroutines,the,total,number,of,subroutines,in,the,method;void,visit,subroutine,final,label,jsr,final,long,id,final,int,nb,subroutines,label,stack,this,while,stack,null,label,l,stack,stack,l,next,l,next,null,if,jsr,null,if,l,status,visited2,0,continue,l,status,visited2,if,l,status,ret,0,if,l,in,same,subroutine,jsr,edge,e,new,edge,e,info,l,input,stack,top,e,successor,jsr,successors,successor,e,next,l,successors,l,successors,e,else,if,l,in,subroutine,id,continue,l,add,to,subroutine,id,nb,subroutines,edge,e,l,successors,while,e,null,if,l,status,label,jsr,0,e,l,successors,next,if,e,successor,next,null,e,successor,next,stack,stack,e,successor,e,e,next
Label -> boolean resolve(final MethodWriter owner, final int position,             final byte[] data);1366718246;Resolves all forward references to this label. This method must be called_when this label is added to the bytecode of the method, i.e. when its_position becomes known. This method fills in the blanks that where left_in the bytecode by each forward reference previously added to this label.__@param owner_the code writer that calls this method._@param position_the position of this label in the bytecode._@param data_the bytecode of the method._@return <tt>true</tt> if a blank that was left for this label was to_small to store the offset. In such a case the corresponding jump_instruction is replaced with a pseudo instruction (using unused_opcodes) using an unsigned two bytes offset. These pseudo_instructions will need to be replaced with true instructions with_wider offsets (4 bytes instead of 2). This is done in_{@link MethodWriter#resizeInstructions}._@throws IllegalArgumentException_if this label has already been resolved, or if it has not_been created by the given code writer.;boolean resolve(final MethodWriter owner, final int position,_            final byte[] data) {_        boolean needUpdate = false__        this.status |= RESOLVED__        this.position = position__        int i = 0__        while (i < referenceCount) {_            int source = srcAndRefPositions[i++]__            int reference = srcAndRefPositions[i++]__            int offset__            if (source >= 0) {_                offset = position - source__                if (offset < Short.MIN_VALUE || offset > Short.MAX_VALUE) {_                    _                    int opcode = data[reference - 1] & 0xFF__                    if (opcode <= Opcodes.JSR) {_                        _                        data[reference - 1] = (byte) (opcode + 49)__                    } else {_                        _                        data[reference - 1] = (byte) (opcode + 20)__                    }_                    needUpdate = true__                }_                data[reference++] = (byte) (offset >>> 8)__                data[reference] = (byte) offset__            } else {_                offset = position + source + 1__                data[reference++] = (byte) (offset >>> 24)__                data[reference++] = (byte) (offset >>> 16)__                data[reference++] = (byte) (offset >>> 8)__                data[reference] = (byte) offset__            }_        }_        return needUpdate__    };resolves,all,forward,references,to,this,label,this,method,must,be,called,when,this,label,is,added,to,the,bytecode,of,the,method,i,e,when,its,position,becomes,known,this,method,fills,in,the,blanks,that,where,left,in,the,bytecode,by,each,forward,reference,previously,added,to,this,label,param,owner,the,code,writer,that,calls,this,method,param,position,the,position,of,this,label,in,the,bytecode,param,data,the,bytecode,of,the,method,return,tt,true,tt,if,a,blank,that,was,left,for,this,label,was,to,small,to,store,the,offset,in,such,a,case,the,corresponding,jump,instruction,is,replaced,with,a,pseudo,instruction,using,unused,opcodes,using,an,unsigned,two,bytes,offset,these,pseudo,instructions,will,need,to,be,replaced,with,true,instructions,with,wider,offsets,4,bytes,instead,of,2,this,is,done,in,link,method,writer,resize,instructions,throws,illegal,argument,exception,if,this,label,has,already,been,resolved,or,if,it,has,not,been,created,by,the,given,code,writer;boolean,resolve,final,method,writer,owner,final,int,position,final,byte,data,boolean,need,update,false,this,status,resolved,this,position,position,int,i,0,while,i,reference,count,int,source,src,and,ref,positions,i,int,reference,src,and,ref,positions,i,int,offset,if,source,0,offset,position,source,if,offset,short,offset,short,int,opcode,data,reference,1,0x,ff,if,opcode,opcodes,jsr,data,reference,1,byte,opcode,49,else,data,reference,1,byte,opcode,20,need,update,true,data,reference,byte,offset,8,data,reference,byte,offset,else,offset,position,source,1,data,reference,byte,offset,24,data,reference,byte,offset,16,data,reference,byte,offset,8,data,reference,byte,offset,return,need,update
Label -> boolean resolve(final MethodWriter owner, final int position,             final byte[] data);1385501137;Resolves all forward references to this label. This method must be called_when this label is added to the bytecode of the method, i.e. when its_position becomes known. This method fills in the blanks that where left_in the bytecode by each forward reference previously added to this label.__@param owner_the code writer that calls this method._@param position_the position of this label in the bytecode._@param data_the bytecode of the method._@return <tt>true</tt> if a blank that was left for this label was to_small to store the offset. In such a case the corresponding jump_instruction is replaced with a pseudo instruction (using unused_opcodes) using an unsigned two bytes offset. These pseudo_instructions will need to be replaced with true instructions with_wider offsets (4 bytes instead of 2). This is done in_{@link MethodWriter#resizeInstructions}._@throws IllegalArgumentException_if this label has already been resolved, or if it has not_been created by the given code writer.;boolean resolve(final MethodWriter owner, final int position,_            final byte[] data) {_        boolean needUpdate = false__        this.status |= RESOLVED__        this.position = position__        int i = 0__        while (i < referenceCount) {_            int source = srcAndRefPositions[i++]__            int reference = srcAndRefPositions[i++]__            int offset__            if (source >= 0) {_                offset = position - source__                if (offset < Short.MIN_VALUE || offset > Short.MAX_VALUE) {_                    _                    int opcode = data[reference - 1] & 0xFF__                    if (opcode <= Opcodes.JSR) {_                        _                        data[reference - 1] = (byte) (opcode + 49)__                    } else {_                        _                        data[reference - 1] = (byte) (opcode + 20)__                    }_                    needUpdate = true__                }_                data[reference++] = (byte) (offset >>> 8)__                data[reference] = (byte) offset__            } else {_                offset = position + source + 1__                data[reference++] = (byte) (offset >>> 24)__                data[reference++] = (byte) (offset >>> 16)__                data[reference++] = (byte) (offset >>> 8)__                data[reference] = (byte) offset__            }_        }_        return needUpdate__    };resolves,all,forward,references,to,this,label,this,method,must,be,called,when,this,label,is,added,to,the,bytecode,of,the,method,i,e,when,its,position,becomes,known,this,method,fills,in,the,blanks,that,where,left,in,the,bytecode,by,each,forward,reference,previously,added,to,this,label,param,owner,the,code,writer,that,calls,this,method,param,position,the,position,of,this,label,in,the,bytecode,param,data,the,bytecode,of,the,method,return,tt,true,tt,if,a,blank,that,was,left,for,this,label,was,to,small,to,store,the,offset,in,such,a,case,the,corresponding,jump,instruction,is,replaced,with,a,pseudo,instruction,using,unused,opcodes,using,an,unsigned,two,bytes,offset,these,pseudo,instructions,will,need,to,be,replaced,with,true,instructions,with,wider,offsets,4,bytes,instead,of,2,this,is,done,in,link,method,writer,resize,instructions,throws,illegal,argument,exception,if,this,label,has,already,been,resolved,or,if,it,has,not,been,created,by,the,given,code,writer;boolean,resolve,final,method,writer,owner,final,int,position,final,byte,data,boolean,need,update,false,this,status,resolved,this,position,position,int,i,0,while,i,reference,count,int,source,src,and,ref,positions,i,int,reference,src,and,ref,positions,i,int,offset,if,source,0,offset,position,source,if,offset,short,offset,short,int,opcode,data,reference,1,0x,ff,if,opcode,opcodes,jsr,data,reference,1,byte,opcode,49,else,data,reference,1,byte,opcode,20,need,update,true,data,reference,byte,offset,8,data,reference,byte,offset,else,offset,position,source,1,data,reference,byte,offset,24,data,reference,byte,offset,16,data,reference,byte,offset,8,data,reference,byte,offset,return,need,update
Label -> boolean resolve(final MethodWriter owner, final int position,             final byte[] data);1400531367;Resolves all forward references to this label. This method must be called_when this label is added to the bytecode of the method, i.e. when its_position becomes known. This method fills in the blanks that where left_in the bytecode by each forward reference previously added to this label.__@param owner_the code writer that calls this method._@param position_the position of this label in the bytecode._@param data_the bytecode of the method._@return <tt>true</tt> if a blank that was left for this label was to_small to store the offset. In such a case the corresponding jump_instruction is replaced with a pseudo instruction (using unused_opcodes) using an unsigned two bytes offset. These pseudo_instructions will need to be replaced with true instructions with_wider offsets (4 bytes instead of 2). This is done in_{@link MethodWriter#resizeInstructions}._@throws IllegalArgumentException_if this label has already been resolved, or if it has not_been created by the given code writer.;boolean resolve(final MethodWriter owner, final int position,_            final byte[] data) {_        boolean needUpdate = false__        this.status |= RESOLVED__        this.position = position__        int i = 0__        while (i < referenceCount) {_            int source = srcAndRefPositions[i++]__            int reference = srcAndRefPositions[i++]__            int offset__            if (source >= 0) {_                offset = position - source__                if (offset < Short.MIN_VALUE || offset > Short.MAX_VALUE) {_                    _                    int opcode = data[reference - 1] & 0xFF__                    if (opcode <= Opcodes.JSR) {_                        _                        data[reference - 1] = (byte) (opcode + 49)__                    } else {_                        _                        data[reference - 1] = (byte) (opcode + 20)__                    }_                    needUpdate = true__                }_                data[reference++] = (byte) (offset >>> 8)__                data[reference] = (byte) offset__            } else {_                offset = position + source + 1__                data[reference++] = (byte) (offset >>> 24)__                data[reference++] = (byte) (offset >>> 16)__                data[reference++] = (byte) (offset >>> 8)__                data[reference] = (byte) offset__            }_        }_        return needUpdate__    };resolves,all,forward,references,to,this,label,this,method,must,be,called,when,this,label,is,added,to,the,bytecode,of,the,method,i,e,when,its,position,becomes,known,this,method,fills,in,the,blanks,that,where,left,in,the,bytecode,by,each,forward,reference,previously,added,to,this,label,param,owner,the,code,writer,that,calls,this,method,param,position,the,position,of,this,label,in,the,bytecode,param,data,the,bytecode,of,the,method,return,tt,true,tt,if,a,blank,that,was,left,for,this,label,was,to,small,to,store,the,offset,in,such,a,case,the,corresponding,jump,instruction,is,replaced,with,a,pseudo,instruction,using,unused,opcodes,using,an,unsigned,two,bytes,offset,these,pseudo,instructions,will,need,to,be,replaced,with,true,instructions,with,wider,offsets,4,bytes,instead,of,2,this,is,done,in,link,method,writer,resize,instructions,throws,illegal,argument,exception,if,this,label,has,already,been,resolved,or,if,it,has,not,been,created,by,the,given,code,writer;boolean,resolve,final,method,writer,owner,final,int,position,final,byte,data,boolean,need,update,false,this,status,resolved,this,position,position,int,i,0,while,i,reference,count,int,source,src,and,ref,positions,i,int,reference,src,and,ref,positions,i,int,offset,if,source,0,offset,position,source,if,offset,short,offset,short,int,opcode,data,reference,1,0x,ff,if,opcode,opcodes,jsr,data,reference,1,byte,opcode,49,else,data,reference,1,byte,opcode,20,need,update,true,data,reference,byte,offset,8,data,reference,byte,offset,else,offset,position,source,1,data,reference,byte,offset,24,data,reference,byte,offset,16,data,reference,byte,offset,8,data,reference,byte,offset,return,need,update
Label -> boolean resolve(final MethodWriter owner, final int position,             final byte[] data);1416998550;Resolves all forward references to this label. This method must be called_when this label is added to the bytecode of the method, i.e. when its_position becomes known. This method fills in the blanks that where left_in the bytecode by each forward reference previously added to this label.__@param owner_the code writer that calls this method._@param position_the position of this label in the bytecode._@param data_the bytecode of the method._@return <tt>true</tt> if a blank that was left for this label was to_small to store the offset. In such a case the corresponding jump_instruction is replaced with a pseudo instruction (using unused_opcodes) using an unsigned two bytes offset. These pseudo_instructions will need to be replaced with true instructions with_wider offsets (4 bytes instead of 2). This is done in_{@link MethodWriter#resizeInstructions}._@throws IllegalArgumentException_if this label has already been resolved, or if it has not_been created by the given code writer.;boolean resolve(final MethodWriter owner, final int position,_            final byte[] data) {_        boolean needUpdate = false__        this.status |= RESOLVED__        this.position = position__        int i = 0__        while (i < referenceCount) {_            int source = srcAndRefPositions[i++]__            int reference = srcAndRefPositions[i++]__            int offset__            if (source >= 0) {_                offset = position - source__                if (offset < Short.MIN_VALUE || offset > Short.MAX_VALUE) {_                    _                    int opcode = data[reference - 1] & 0xFF__                    if (opcode <= Opcodes.JSR) {_                        _                        data[reference - 1] = (byte) (opcode + 49)__                    } else {_                        _                        data[reference - 1] = (byte) (opcode + 20)__                    }_                    needUpdate = true__                }_                data[reference++] = (byte) (offset >>> 8)__                data[reference] = (byte) offset__            } else {_                offset = position + source + 1__                data[reference++] = (byte) (offset >>> 24)__                data[reference++] = (byte) (offset >>> 16)__                data[reference++] = (byte) (offset >>> 8)__                data[reference] = (byte) offset__            }_        }_        return needUpdate__    };resolves,all,forward,references,to,this,label,this,method,must,be,called,when,this,label,is,added,to,the,bytecode,of,the,method,i,e,when,its,position,becomes,known,this,method,fills,in,the,blanks,that,where,left,in,the,bytecode,by,each,forward,reference,previously,added,to,this,label,param,owner,the,code,writer,that,calls,this,method,param,position,the,position,of,this,label,in,the,bytecode,param,data,the,bytecode,of,the,method,return,tt,true,tt,if,a,blank,that,was,left,for,this,label,was,to,small,to,store,the,offset,in,such,a,case,the,corresponding,jump,instruction,is,replaced,with,a,pseudo,instruction,using,unused,opcodes,using,an,unsigned,two,bytes,offset,these,pseudo,instructions,will,need,to,be,replaced,with,true,instructions,with,wider,offsets,4,bytes,instead,of,2,this,is,done,in,link,method,writer,resize,instructions,throws,illegal,argument,exception,if,this,label,has,already,been,resolved,or,if,it,has,not,been,created,by,the,given,code,writer;boolean,resolve,final,method,writer,owner,final,int,position,final,byte,data,boolean,need,update,false,this,status,resolved,this,position,position,int,i,0,while,i,reference,count,int,source,src,and,ref,positions,i,int,reference,src,and,ref,positions,i,int,offset,if,source,0,offset,position,source,if,offset,short,offset,short,int,opcode,data,reference,1,0x,ff,if,opcode,opcodes,jsr,data,reference,1,byte,opcode,49,else,data,reference,1,byte,opcode,20,need,update,true,data,reference,byte,offset,8,data,reference,byte,offset,else,offset,position,source,1,data,reference,byte,offset,24,data,reference,byte,offset,16,data,reference,byte,offset,8,data,reference,byte,offset,return,need,update
Label -> boolean resolve(final MethodWriter owner, final int position,             final byte[] data);1483093254;Resolves all forward references to this label. This method must be called_when this label is added to the bytecode of the method, i.e. when its_position becomes known. This method fills in the blanks that where left_in the bytecode by each forward reference previously added to this label.__@param owner_the code writer that calls this method._@param position_the position of this label in the bytecode._@param data_the bytecode of the method._@return <tt>true</tt> if a blank that was left for this label was to_small to store the offset. In such a case the corresponding jump_instruction is replaced with a pseudo instruction (using unused_opcodes) using an unsigned two bytes offset. These pseudo_instructions will be replaced with standard bytecode instructions_with wider offsets (4 bytes instead of 2), in ClassReader._@throws IllegalArgumentException_if this label has already been resolved, or if it has not_been created by the given code writer.;boolean resolve(final MethodWriter owner, final int position,_            final byte[] data) {_        boolean needUpdate = false__        this.status |= RESOLVED__        this.position = position__        int i = 0__        while (i < referenceCount) {_            int source = srcAndRefPositions[i++]__            int reference = srcAndRefPositions[i++]__            int offset__            if (source >= 0) {_                offset = position - source__                if (offset < Short.MIN_VALUE || offset > Short.MAX_VALUE) {_                    _                    int opcode = data[reference - 1] & 0xFF__                    if (opcode <= Opcodes.JSR) {_                        _                        data[reference - 1] = (byte) (opcode + 49)__                    } else {_                        _                        data[reference - 1] = (byte) (opcode + 20)__                    }_                    needUpdate = true__                }_                data[reference++] = (byte) (offset >>> 8)__                data[reference] = (byte) offset__            } else {_                offset = position + source + 1__                data[reference++] = (byte) (offset >>> 24)__                data[reference++] = (byte) (offset >>> 16)__                data[reference++] = (byte) (offset >>> 8)__                data[reference] = (byte) offset__            }_        }_        return needUpdate__    };resolves,all,forward,references,to,this,label,this,method,must,be,called,when,this,label,is,added,to,the,bytecode,of,the,method,i,e,when,its,position,becomes,known,this,method,fills,in,the,blanks,that,where,left,in,the,bytecode,by,each,forward,reference,previously,added,to,this,label,param,owner,the,code,writer,that,calls,this,method,param,position,the,position,of,this,label,in,the,bytecode,param,data,the,bytecode,of,the,method,return,tt,true,tt,if,a,blank,that,was,left,for,this,label,was,to,small,to,store,the,offset,in,such,a,case,the,corresponding,jump,instruction,is,replaced,with,a,pseudo,instruction,using,unused,opcodes,using,an,unsigned,two,bytes,offset,these,pseudo,instructions,will,be,replaced,with,standard,bytecode,instructions,with,wider,offsets,4,bytes,instead,of,2,in,class,reader,throws,illegal,argument,exception,if,this,label,has,already,been,resolved,or,if,it,has,not,been,created,by,the,given,code,writer;boolean,resolve,final,method,writer,owner,final,int,position,final,byte,data,boolean,need,update,false,this,status,resolved,this,position,position,int,i,0,while,i,reference,count,int,source,src,and,ref,positions,i,int,reference,src,and,ref,positions,i,int,offset,if,source,0,offset,position,source,if,offset,short,offset,short,int,opcode,data,reference,1,0x,ff,if,opcode,opcodes,jsr,data,reference,1,byte,opcode,49,else,data,reference,1,byte,opcode,20,need,update,true,data,reference,byte,offset,8,data,reference,byte,offset,else,offset,position,source,1,data,reference,byte,offset,24,data,reference,byte,offset,16,data,reference,byte,offset,8,data,reference,byte,offset,return,need,update
Label -> final Label getCanonicalInstance();1531241461;Returns the "canonical" {@link Label} instance corresponding to this label's bytecode offset,_if known, otherwise the label itself. The canonical instance is the first label (in the order_of their visit by {@link MethodVisitor#visitLabel}) corresponding to this bytecode offset. It_cannot be known for labels which have not been visited yet.__<p><i>This method should only be used when the {@link MethodWriter#COMPUTE_ALL_FRAMES} option_is used.</i>__@return the label itself if {@link #frame} is null, otherwise the Label's frame owner. This_corresponds to the "canonical" label instance described above thanks to the way the label_frame is set in {@link MethodWriter#visitLabel}.;final Label getCanonicalInstance() {_    return frame == null ? this : frame.owner__  };returns,the,canonical,link,label,instance,corresponding,to,this,label,s,bytecode,offset,if,known,otherwise,the,label,itself,the,canonical,instance,is,the,first,label,in,the,order,of,their,visit,by,link,method,visitor,visit,label,corresponding,to,this,bytecode,offset,it,cannot,be,known,for,labels,which,have,not,been,visited,yet,p,i,this,method,should,only,be,used,when,the,link,method,writer,option,is,used,i,return,the,label,itself,if,link,frame,is,null,otherwise,the,label,s,frame,owner,this,corresponds,to,the,canonical,label,instance,described,above,thanks,to,the,way,the,label,frame,is,set,in,link,method,writer,visit,label;final,label,get,canonical,instance,return,frame,null,this,frame,owner
Label -> final Label getCanonicalInstance();1536664245;Returns the "canonical" {@link Label} instance corresponding to this label's bytecode offset,_if known, otherwise the label itself. The canonical instance is the first label (in the order_of their visit by {@link MethodVisitor#visitLabel}) corresponding to this bytecode offset. It_cannot be known for labels which have not been visited yet.__<p><i>This method should only be used when the {@link MethodWriter#COMPUTE_ALL_FRAMES} option_is used.</i>__@return the label itself if {@link #frame} is null, otherwise the Label's frame owner. This_corresponds to the "canonical" label instance described above thanks to the way the label_frame is set in {@link MethodWriter#visitLabel}.;final Label getCanonicalInstance() {_    return frame == null ? this : frame.owner__  };returns,the,canonical,link,label,instance,corresponding,to,this,label,s,bytecode,offset,if,known,otherwise,the,label,itself,the,canonical,instance,is,the,first,label,in,the,order,of,their,visit,by,link,method,visitor,visit,label,corresponding,to,this,bytecode,offset,it,cannot,be,known,for,labels,which,have,not,been,visited,yet,p,i,this,method,should,only,be,used,when,the,link,method,writer,option,is,used,i,return,the,label,itself,if,link,frame,is,null,otherwise,the,label,s,frame,owner,this,corresponds,to,the,canonical,label,instance,described,above,thanks,to,the,way,the,label,frame,is,set,in,link,method,writer,visit,label;final,label,get,canonical,instance,return,frame,null,this,frame,owner
Label -> final Label getCanonicalInstance();1537204147;Returns the "canonical" {@link Label} instance corresponding to this label's bytecode offset,_if known, otherwise the label itself. The canonical instance is the first label (in the order_of their visit by {@link MethodVisitor#visitLabel}) corresponding to this bytecode offset. It_cannot be known for labels which have not been visited yet.__<p><i>This method should only be used when the {@link MethodWriter#COMPUTE_ALL_FRAMES} option_is used.</i>__@return the label itself if {@link #frame} is null, otherwise the Label's frame owner. This_corresponds to the "canonical" label instance described above thanks to the way the label_frame is set in {@link MethodWriter#visitLabel}.;final Label getCanonicalInstance() {_    return frame == null ? this : frame.owner__  };returns,the,canonical,link,label,instance,corresponding,to,this,label,s,bytecode,offset,if,known,otherwise,the,label,itself,the,canonical,instance,is,the,first,label,in,the,order,of,their,visit,by,link,method,visitor,visit,label,corresponding,to,this,bytecode,offset,it,cannot,be,known,for,labels,which,have,not,been,visited,yet,p,i,this,method,should,only,be,used,when,the,link,method,writer,option,is,used,i,return,the,label,itself,if,link,frame,is,null,otherwise,the,label,s,frame,owner,this,corresponds,to,the,canonical,label,instance,described,above,thanks,to,the,way,the,label,frame,is,set,in,link,method,writer,visit,label;final,label,get,canonical,instance,return,frame,null,this,frame,owner
Label -> final void markSubroutine(final short subroutineId);1531241461;Finds the basic blocks that belong to the subroutine starting with the basic block_corresponding to this label, and marks these blocks as belonging to this subroutine. This_method follows the control flow graph to find all the blocks that are reachable from the_current basic block WITHOUT following any jsr target.__<p>Note: a precondition and postcondition of this method is that all labels must have a null_{@link #nextListElement}.__@param subroutineId the id of the subroutine starting with the basic block corresponding to_this label.;final void markSubroutine(final short subroutineId) {_    _    _    _    _    Label listOfBlocksToProcess = this__    listOfBlocksToProcess.nextListElement = EMPTY_LIST__    while (listOfBlocksToProcess != EMPTY_LIST) {_      _      Label basicBlock = listOfBlocksToProcess__      listOfBlocksToProcess = listOfBlocksToProcess.nextListElement__      basicBlock.nextListElement = null___      _      _      if (basicBlock.subroutineId == 0) {_        basicBlock.subroutineId = subroutineId__        listOfBlocksToProcess = basicBlock.pushSuccessors(listOfBlocksToProcess)__      }_    }_  };finds,the,basic,blocks,that,belong,to,the,subroutine,starting,with,the,basic,block,corresponding,to,this,label,and,marks,these,blocks,as,belonging,to,this,subroutine,this,method,follows,the,control,flow,graph,to,find,all,the,blocks,that,are,reachable,from,the,current,basic,block,without,following,any,jsr,target,p,note,a,precondition,and,postcondition,of,this,method,is,that,all,labels,must,have,a,null,link,next,list,element,param,subroutine,id,the,id,of,the,subroutine,starting,with,the,basic,block,corresponding,to,this,label;final,void,mark,subroutine,final,short,subroutine,id,label,list,of,blocks,to,process,this,list,of,blocks,to,process,next,list,element,while,list,of,blocks,to,process,label,basic,block,list,of,blocks,to,process,list,of,blocks,to,process,list,of,blocks,to,process,next,list,element,basic,block,next,list,element,null,if,basic,block,subroutine,id,0,basic,block,subroutine,id,subroutine,id,list,of,blocks,to,process,basic,block,push,successors,list,of,blocks,to,process
Label -> final void markSubroutine(final short subroutineId);1536664245;Finds the basic blocks that belong to the subroutine starting with the basic block_corresponding to this label, and marks these blocks as belonging to this subroutine. This_method follows the control flow graph to find all the blocks that are reachable from the_current basic block WITHOUT following any jsr target.__<p>Note: a precondition and postcondition of this method is that all labels must have a null_{@link #nextListElement}.__@param subroutineId the id of the subroutine starting with the basic block corresponding to_this label.;final void markSubroutine(final short subroutineId) {_    _    _    _    _    Label listOfBlocksToProcess = this__    listOfBlocksToProcess.nextListElement = EMPTY_LIST__    while (listOfBlocksToProcess != EMPTY_LIST) {_      _      Label basicBlock = listOfBlocksToProcess__      listOfBlocksToProcess = listOfBlocksToProcess.nextListElement__      basicBlock.nextListElement = null___      _      _      if (basicBlock.subroutineId == 0) {_        basicBlock.subroutineId = subroutineId__        listOfBlocksToProcess = basicBlock.pushSuccessors(listOfBlocksToProcess)__      }_    }_  };finds,the,basic,blocks,that,belong,to,the,subroutine,starting,with,the,basic,block,corresponding,to,this,label,and,marks,these,blocks,as,belonging,to,this,subroutine,this,method,follows,the,control,flow,graph,to,find,all,the,blocks,that,are,reachable,from,the,current,basic,block,without,following,any,jsr,target,p,note,a,precondition,and,postcondition,of,this,method,is,that,all,labels,must,have,a,null,link,next,list,element,param,subroutine,id,the,id,of,the,subroutine,starting,with,the,basic,block,corresponding,to,this,label;final,void,mark,subroutine,final,short,subroutine,id,label,list,of,blocks,to,process,this,list,of,blocks,to,process,next,list,element,while,list,of,blocks,to,process,label,basic,block,list,of,blocks,to,process,list,of,blocks,to,process,list,of,blocks,to,process,next,list,element,basic,block,next,list,element,null,if,basic,block,subroutine,id,0,basic,block,subroutine,id,subroutine,id,list,of,blocks,to,process,basic,block,push,successors,list,of,blocks,to,process
Label -> final void markSubroutine(final short subroutineId);1537204147;Finds the basic blocks that belong to the subroutine starting with the basic block_corresponding to this label, and marks these blocks as belonging to this subroutine. This_method follows the control flow graph to find all the blocks that are reachable from the_current basic block WITHOUT following any jsr target.__<p>Note: a precondition and postcondition of this method is that all labels must have a null_{@link #nextListElement}.__@param subroutineId the id of the subroutine starting with the basic block corresponding to_this label.;final void markSubroutine(final short subroutineId) {_    _    _    _    _    Label listOfBlocksToProcess = this__    listOfBlocksToProcess.nextListElement = EMPTY_LIST__    while (listOfBlocksToProcess != EMPTY_LIST) {_      _      Label basicBlock = listOfBlocksToProcess__      listOfBlocksToProcess = listOfBlocksToProcess.nextListElement__      basicBlock.nextListElement = null___      _      _      if (basicBlock.subroutineId == 0) {_        basicBlock.subroutineId = subroutineId__        listOfBlocksToProcess = basicBlock.pushSuccessors(listOfBlocksToProcess)__      }_    }_  };finds,the,basic,blocks,that,belong,to,the,subroutine,starting,with,the,basic,block,corresponding,to,this,label,and,marks,these,blocks,as,belonging,to,this,subroutine,this,method,follows,the,control,flow,graph,to,find,all,the,blocks,that,are,reachable,from,the,current,basic,block,without,following,any,jsr,target,p,note,a,precondition,and,postcondition,of,this,method,is,that,all,labels,must,have,a,null,link,next,list,element,param,subroutine,id,the,id,of,the,subroutine,starting,with,the,basic,block,corresponding,to,this,label;final,void,mark,subroutine,final,short,subroutine,id,label,list,of,blocks,to,process,this,list,of,blocks,to,process,next,list,element,while,list,of,blocks,to,process,label,basic,block,list,of,blocks,to,process,list,of,blocks,to,process,list,of,blocks,to,process,next,list,element,basic,block,next,list,element,null,if,basic,block,subroutine,id,0,basic,block,subroutine,id,subroutine,id,list,of,blocks,to,process,basic,block,push,successors,list,of,blocks,to,process
Label -> final void put(       final ByteVector code, final int sourceInsnBytecodeOffset, final boolean wideReference);1531241461;Puts a reference to this label in the bytecode of a method. If the bytecode offset of the label_is known, the relative bytecode offset between the label and the instruction referencing it is_computed and written directly. Otherwise, a null relative offset is written and a new forward_reference is declared for this label.__@param code the bytecode of the method. This is where the reference is appended._@param sourceInsnBytecodeOffset the bytecode offset of the instruction that contains the_reference to be appended._@param wideReference whether the reference must be stored in 4 bytes (instead of 2 bytes).;final void put(_      final ByteVector code, final int sourceInsnBytecodeOffset, final boolean wideReference) {_    if ((flags & FLAG_RESOLVED) == 0) {_      if (wideReference) {_        addForwardReference(sourceInsnBytecodeOffset, FORWARD_REFERENCE_TYPE_WIDE, code.length)__        code.putInt(-1)__      } else {_        addForwardReference(sourceInsnBytecodeOffset, FORWARD_REFERENCE_TYPE_SHORT, code.length)__        code.putShort(-1)__      }_    } else {_      if (wideReference) {_        code.putInt(bytecodeOffset - sourceInsnBytecodeOffset)__      } else {_        code.putShort(bytecodeOffset - sourceInsnBytecodeOffset)__      }_    }_  };puts,a,reference,to,this,label,in,the,bytecode,of,a,method,if,the,bytecode,offset,of,the,label,is,known,the,relative,bytecode,offset,between,the,label,and,the,instruction,referencing,it,is,computed,and,written,directly,otherwise,a,null,relative,offset,is,written,and,a,new,forward,reference,is,declared,for,this,label,param,code,the,bytecode,of,the,method,this,is,where,the,reference,is,appended,param,source,insn,bytecode,offset,the,bytecode,offset,of,the,instruction,that,contains,the,reference,to,be,appended,param,wide,reference,whether,the,reference,must,be,stored,in,4,bytes,instead,of,2,bytes;final,void,put,final,byte,vector,code,final,int,source,insn,bytecode,offset,final,boolean,wide,reference,if,flags,0,if,wide,reference,add,forward,reference,source,insn,bytecode,offset,code,length,code,put,int,1,else,add,forward,reference,source,insn,bytecode,offset,code,length,code,put,short,1,else,if,wide,reference,code,put,int,bytecode,offset,source,insn,bytecode,offset,else,code,put,short,bytecode,offset,source,insn,bytecode,offset
Label -> final void put(       final ByteVector code, final int sourceInsnBytecodeOffset, final boolean wideReference);1536664245;Puts a reference to this label in the bytecode of a method. If the bytecode offset of the label_is known, the relative bytecode offset between the label and the instruction referencing it is_computed and written directly. Otherwise, a null relative offset is written and a new forward_reference is declared for this label.__@param code the bytecode of the method. This is where the reference is appended._@param sourceInsnBytecodeOffset the bytecode offset of the instruction that contains the_reference to be appended._@param wideReference whether the reference must be stored in 4 bytes (instead of 2 bytes).;final void put(_      final ByteVector code, final int sourceInsnBytecodeOffset, final boolean wideReference) {_    if ((flags & FLAG_RESOLVED) == 0) {_      if (wideReference) {_        addForwardReference(sourceInsnBytecodeOffset, FORWARD_REFERENCE_TYPE_WIDE, code.length)__        code.putInt(-1)__      } else {_        addForwardReference(sourceInsnBytecodeOffset, FORWARD_REFERENCE_TYPE_SHORT, code.length)__        code.putShort(-1)__      }_    } else {_      if (wideReference) {_        code.putInt(bytecodeOffset - sourceInsnBytecodeOffset)__      } else {_        code.putShort(bytecodeOffset - sourceInsnBytecodeOffset)__      }_    }_  };puts,a,reference,to,this,label,in,the,bytecode,of,a,method,if,the,bytecode,offset,of,the,label,is,known,the,relative,bytecode,offset,between,the,label,and,the,instruction,referencing,it,is,computed,and,written,directly,otherwise,a,null,relative,offset,is,written,and,a,new,forward,reference,is,declared,for,this,label,param,code,the,bytecode,of,the,method,this,is,where,the,reference,is,appended,param,source,insn,bytecode,offset,the,bytecode,offset,of,the,instruction,that,contains,the,reference,to,be,appended,param,wide,reference,whether,the,reference,must,be,stored,in,4,bytes,instead,of,2,bytes;final,void,put,final,byte,vector,code,final,int,source,insn,bytecode,offset,final,boolean,wide,reference,if,flags,0,if,wide,reference,add,forward,reference,source,insn,bytecode,offset,code,length,code,put,int,1,else,add,forward,reference,source,insn,bytecode,offset,code,length,code,put,short,1,else,if,wide,reference,code,put,int,bytecode,offset,source,insn,bytecode,offset,else,code,put,short,bytecode,offset,source,insn,bytecode,offset
Label -> final void put(       final ByteVector code, final int sourceInsnBytecodeOffset, final boolean wideReference);1537204147;Puts a reference to this label in the bytecode of a method. If the bytecode offset of the label_is known, the relative bytecode offset between the label and the instruction referencing it is_computed and written directly. Otherwise, a null relative offset is written and a new forward_reference is declared for this label.__@param code the bytecode of the method. This is where the reference is appended._@param sourceInsnBytecodeOffset the bytecode offset of the instruction that contains the_reference to be appended._@param wideReference whether the reference must be stored in 4 bytes (instead of 2 bytes).;final void put(_      final ByteVector code, final int sourceInsnBytecodeOffset, final boolean wideReference) {_    if ((flags & FLAG_RESOLVED) == 0) {_      if (wideReference) {_        addForwardReference(sourceInsnBytecodeOffset, FORWARD_REFERENCE_TYPE_WIDE, code.length)__        code.putInt(-1)__      } else {_        addForwardReference(sourceInsnBytecodeOffset, FORWARD_REFERENCE_TYPE_SHORT, code.length)__        code.putShort(-1)__      }_    } else {_      if (wideReference) {_        code.putInt(bytecodeOffset - sourceInsnBytecodeOffset)__      } else {_        code.putShort(bytecodeOffset - sourceInsnBytecodeOffset)__      }_    }_  };puts,a,reference,to,this,label,in,the,bytecode,of,a,method,if,the,bytecode,offset,of,the,label,is,known,the,relative,bytecode,offset,between,the,label,and,the,instruction,referencing,it,is,computed,and,written,directly,otherwise,a,null,relative,offset,is,written,and,a,new,forward,reference,is,declared,for,this,label,param,code,the,bytecode,of,the,method,this,is,where,the,reference,is,appended,param,source,insn,bytecode,offset,the,bytecode,offset,of,the,instruction,that,contains,the,reference,to,be,appended,param,wide,reference,whether,the,reference,must,be,stored,in,4,bytes,instead,of,2,bytes;final,void,put,final,byte,vector,code,final,int,source,insn,bytecode,offset,final,boolean,wide,reference,if,flags,0,if,wide,reference,add,forward,reference,source,insn,bytecode,offset,code,length,code,put,int,1,else,add,forward,reference,source,insn,bytecode,offset,code,length,code,put,short,1,else,if,wide,reference,code,put,int,bytecode,offset,source,insn,bytecode,offset,else,code,put,short,bytecode,offset,source,insn,bytecode,offset
Label -> void put(final MethodWriter owner, final ByteVector out, final int source,             final boolean wideOffset);1366718246;Puts a reference to this label in the bytecode of a method. If the_position of the label is known, the offset is computed and written_directly. Otherwise, a null offset is written and a new forward reference_is declared for this label.__@param owner_the code writer that calls this method._@param out_the bytecode of the method._@param source_the position of first byte of the bytecode instruction that_contains this label._@param wideOffset_<tt>true</tt> if the reference must be stored in 4 bytes, or_<tt>false</tt> if it must be stored with 2 bytes._@throws IllegalArgumentException_if this label has not been created by the given code writer.;void put(final MethodWriter owner, final ByteVector out, final int source,_            final boolean wideOffset) {_        if ((status & RESOLVED) == 0) {_            if (wideOffset) {_                addReference(-1 - source, out.length)__                out.putInt(-1)__            } else {_                addReference(source, out.length)__                out.putShort(-1)__            }_        } else {_            if (wideOffset) {_                out.putInt(position - source)__            } else {_                out.putShort(position - source)__            }_        }_    };puts,a,reference,to,this,label,in,the,bytecode,of,a,method,if,the,position,of,the,label,is,known,the,offset,is,computed,and,written,directly,otherwise,a,null,offset,is,written,and,a,new,forward,reference,is,declared,for,this,label,param,owner,the,code,writer,that,calls,this,method,param,out,the,bytecode,of,the,method,param,source,the,position,of,first,byte,of,the,bytecode,instruction,that,contains,this,label,param,wide,offset,tt,true,tt,if,the,reference,must,be,stored,in,4,bytes,or,tt,false,tt,if,it,must,be,stored,with,2,bytes,throws,illegal,argument,exception,if,this,label,has,not,been,created,by,the,given,code,writer;void,put,final,method,writer,owner,final,byte,vector,out,final,int,source,final,boolean,wide,offset,if,status,resolved,0,if,wide,offset,add,reference,1,source,out,length,out,put,int,1,else,add,reference,source,out,length,out,put,short,1,else,if,wide,offset,out,put,int,position,source,else,out,put,short,position,source
Label -> void put(final MethodWriter owner, final ByteVector out, final int source,             final boolean wideOffset);1385501137;Puts a reference to this label in the bytecode of a method. If the_position of the label is known, the offset is computed and written_directly. Otherwise, a null offset is written and a new forward reference_is declared for this label.__@param owner_the code writer that calls this method._@param out_the bytecode of the method._@param source_the position of first byte of the bytecode instruction that_contains this label._@param wideOffset_<tt>true</tt> if the reference must be stored in 4 bytes, or_<tt>false</tt> if it must be stored with 2 bytes._@throws IllegalArgumentException_if this label has not been created by the given code writer.;void put(final MethodWriter owner, final ByteVector out, final int source,_            final boolean wideOffset) {_        if ((status & RESOLVED) == 0) {_            if (wideOffset) {_                addReference(-1 - source, out.length)__                out.putInt(-1)__            } else {_                addReference(source, out.length)__                out.putShort(-1)__            }_        } else {_            if (wideOffset) {_                out.putInt(position - source)__            } else {_                out.putShort(position - source)__            }_        }_    };puts,a,reference,to,this,label,in,the,bytecode,of,a,method,if,the,position,of,the,label,is,known,the,offset,is,computed,and,written,directly,otherwise,a,null,offset,is,written,and,a,new,forward,reference,is,declared,for,this,label,param,owner,the,code,writer,that,calls,this,method,param,out,the,bytecode,of,the,method,param,source,the,position,of,first,byte,of,the,bytecode,instruction,that,contains,this,label,param,wide,offset,tt,true,tt,if,the,reference,must,be,stored,in,4,bytes,or,tt,false,tt,if,it,must,be,stored,with,2,bytes,throws,illegal,argument,exception,if,this,label,has,not,been,created,by,the,given,code,writer;void,put,final,method,writer,owner,final,byte,vector,out,final,int,source,final,boolean,wide,offset,if,status,resolved,0,if,wide,offset,add,reference,1,source,out,length,out,put,int,1,else,add,reference,source,out,length,out,put,short,1,else,if,wide,offset,out,put,int,position,source,else,out,put,short,position,source
Label -> void put(final MethodWriter owner, final ByteVector out, final int source,             final boolean wideOffset);1400531367;Puts a reference to this label in the bytecode of a method. If the_position of the label is known, the offset is computed and written_directly. Otherwise, a null offset is written and a new forward reference_is declared for this label.__@param owner_the code writer that calls this method._@param out_the bytecode of the method._@param source_the position of first byte of the bytecode instruction that_contains this label._@param wideOffset_<tt>true</tt> if the reference must be stored in 4 bytes, or_<tt>false</tt> if it must be stored with 2 bytes._@throws IllegalArgumentException_if this label has not been created by the given code writer.;void put(final MethodWriter owner, final ByteVector out, final int source,_            final boolean wideOffset) {_        if ((status & RESOLVED) == 0) {_            if (wideOffset) {_                addReference(-1 - source, out.length)__                out.putInt(-1)__            } else {_                addReference(source, out.length)__                out.putShort(-1)__            }_        } else {_            if (wideOffset) {_                out.putInt(position - source)__            } else {_                out.putShort(position - source)__            }_        }_    };puts,a,reference,to,this,label,in,the,bytecode,of,a,method,if,the,position,of,the,label,is,known,the,offset,is,computed,and,written,directly,otherwise,a,null,offset,is,written,and,a,new,forward,reference,is,declared,for,this,label,param,owner,the,code,writer,that,calls,this,method,param,out,the,bytecode,of,the,method,param,source,the,position,of,first,byte,of,the,bytecode,instruction,that,contains,this,label,param,wide,offset,tt,true,tt,if,the,reference,must,be,stored,in,4,bytes,or,tt,false,tt,if,it,must,be,stored,with,2,bytes,throws,illegal,argument,exception,if,this,label,has,not,been,created,by,the,given,code,writer;void,put,final,method,writer,owner,final,byte,vector,out,final,int,source,final,boolean,wide,offset,if,status,resolved,0,if,wide,offset,add,reference,1,source,out,length,out,put,int,1,else,add,reference,source,out,length,out,put,short,1,else,if,wide,offset,out,put,int,position,source,else,out,put,short,position,source
Label -> void put(final MethodWriter owner, final ByteVector out, final int source,             final boolean wideOffset);1416998550;Puts a reference to this label in the bytecode of a method. If the_position of the label is known, the offset is computed and written_directly. Otherwise, a null offset is written and a new forward reference_is declared for this label.__@param owner_the code writer that calls this method._@param out_the bytecode of the method._@param source_the position of first byte of the bytecode instruction that_contains this label._@param wideOffset_<tt>true</tt> if the reference must be stored in 4 bytes, or_<tt>false</tt> if it must be stored with 2 bytes._@throws IllegalArgumentException_if this label has not been created by the given code writer.;void put(final MethodWriter owner, final ByteVector out, final int source,_            final boolean wideOffset) {_        if ((status & RESOLVED) == 0) {_            if (wideOffset) {_                addReference(-1 - source, out.length)__                out.putInt(-1)__            } else {_                addReference(source, out.length)__                out.putShort(-1)__            }_        } else {_            if (wideOffset) {_                out.putInt(position - source)__            } else {_                out.putShort(position - source)__            }_        }_    };puts,a,reference,to,this,label,in,the,bytecode,of,a,method,if,the,position,of,the,label,is,known,the,offset,is,computed,and,written,directly,otherwise,a,null,offset,is,written,and,a,new,forward,reference,is,declared,for,this,label,param,owner,the,code,writer,that,calls,this,method,param,out,the,bytecode,of,the,method,param,source,the,position,of,first,byte,of,the,bytecode,instruction,that,contains,this,label,param,wide,offset,tt,true,tt,if,the,reference,must,be,stored,in,4,bytes,or,tt,false,tt,if,it,must,be,stored,with,2,bytes,throws,illegal,argument,exception,if,this,label,has,not,been,created,by,the,given,code,writer;void,put,final,method,writer,owner,final,byte,vector,out,final,int,source,final,boolean,wide,offset,if,status,resolved,0,if,wide,offset,add,reference,1,source,out,length,out,put,int,1,else,add,reference,source,out,length,out,put,short,1,else,if,wide,offset,out,put,int,position,source,else,out,put,short,position,source
Label -> void put(final MethodWriter owner, final ByteVector out, final int source,             final boolean wideOffset);1483093254;Puts a reference to this label in the bytecode of a method. If the_position of the label is known, the offset is computed and written_directly. Otherwise, a null offset is written and a new forward reference_is declared for this label.__@param owner_the code writer that calls this method._@param out_the bytecode of the method._@param source_the position of first byte of the bytecode instruction that_contains this label._@param wideOffset_<tt>true</tt> if the reference must be stored in 4 bytes, or_<tt>false</tt> if it must be stored with 2 bytes._@throws IllegalArgumentException_if this label has not been created by the given code writer.;void put(final MethodWriter owner, final ByteVector out, final int source,_            final boolean wideOffset) {_        if ((status & RESOLVED) == 0) {_            if (wideOffset) {_                addReference(-1 - source, out.length)__                out.putInt(-1)__            } else {_                addReference(source, out.length)__                out.putShort(-1)__            }_        } else {_            if (wideOffset) {_                out.putInt(position - source)__            } else {_                out.putShort(position - source)__            }_        }_    };puts,a,reference,to,this,label,in,the,bytecode,of,a,method,if,the,position,of,the,label,is,known,the,offset,is,computed,and,written,directly,otherwise,a,null,offset,is,written,and,a,new,forward,reference,is,declared,for,this,label,param,owner,the,code,writer,that,calls,this,method,param,out,the,bytecode,of,the,method,param,source,the,position,of,first,byte,of,the,bytecode,instruction,that,contains,this,label,param,wide,offset,tt,true,tt,if,the,reference,must,be,stored,in,4,bytes,or,tt,false,tt,if,it,must,be,stored,with,2,bytes,throws,illegal,argument,exception,if,this,label,has,not,been,created,by,the,given,code,writer;void,put,final,method,writer,owner,final,byte,vector,out,final,int,source,final,boolean,wide,offset,if,status,resolved,0,if,wide,offset,add,reference,1,source,out,length,out,put,int,1,else,add,reference,source,out,length,out,put,short,1,else,if,wide,offset,out,put,int,position,source,else,out,put,short,position,source
Label -> Label getFirst();1366718246;Returns the first label of the series to which this label belongs. For an_isolated label or for the first label in a series of successive labels,_this method returns the label itself. For other labels it returns the_first label of the series.__@return the first label of the series to which this label belongs.;Label getFirst() {_        return !ClassReader.FRAMES || frame == null ? this : frame.owner__    };returns,the,first,label,of,the,series,to,which,this,label,belongs,for,an,isolated,label,or,for,the,first,label,in,a,series,of,successive,labels,this,method,returns,the,label,itself,for,other,labels,it,returns,the,first,label,of,the,series,return,the,first,label,of,the,series,to,which,this,label,belongs;label,get,first,return,class,reader,frames,frame,null,this,frame,owner
Label -> Label getFirst();1385501137;Returns the first label of the series to which this label belongs. For an_isolated label or for the first label in a series of successive labels,_this method returns the label itself. For other labels it returns the_first label of the series.__@return the first label of the series to which this label belongs.;Label getFirst() {_        return !ClassReader.FRAMES || frame == null ? this : frame.owner__    };returns,the,first,label,of,the,series,to,which,this,label,belongs,for,an,isolated,label,or,for,the,first,label,in,a,series,of,successive,labels,this,method,returns,the,label,itself,for,other,labels,it,returns,the,first,label,of,the,series,return,the,first,label,of,the,series,to,which,this,label,belongs;label,get,first,return,class,reader,frames,frame,null,this,frame,owner
Label -> Label getFirst();1400531367;Returns the first label of the series to which this label belongs. For an_isolated label or for the first label in a series of successive labels,_this method returns the label itself. For other labels it returns the_first label of the series.__@return the first label of the series to which this label belongs.;Label getFirst() {_        return !ClassReader.FRAMES || frame == null ? this : frame.owner__    };returns,the,first,label,of,the,series,to,which,this,label,belongs,for,an,isolated,label,or,for,the,first,label,in,a,series,of,successive,labels,this,method,returns,the,label,itself,for,other,labels,it,returns,the,first,label,of,the,series,return,the,first,label,of,the,series,to,which,this,label,belongs;label,get,first,return,class,reader,frames,frame,null,this,frame,owner
Label -> Label getFirst();1416998550;Returns the first label of the series to which this label belongs. For an_isolated label or for the first label in a series of successive labels,_this method returns the label itself. For other labels it returns the_first label of the series.__@return the first label of the series to which this label belongs.;Label getFirst() {_        return !ClassReader.FRAMES || frame == null ? this : frame.owner__    };returns,the,first,label,of,the,series,to,which,this,label,belongs,for,an,isolated,label,or,for,the,first,label,in,a,series,of,successive,labels,this,method,returns,the,label,itself,for,other,labels,it,returns,the,first,label,of,the,series,return,the,first,label,of,the,series,to,which,this,label,belongs;label,get,first,return,class,reader,frames,frame,null,this,frame,owner
Label -> Label getFirst();1483093254;Returns the first label of the series to which this label belongs. For an_isolated label or for the first label in a series of successive labels,_this method returns the label itself. For other labels it returns the_first label of the series.__@return the first label of the series to which this label belongs.;Label getFirst() {_        return !ClassReader.FRAMES || frame == null ? this : frame.owner__    };returns,the,first,label,of,the,series,to,which,this,label,belongs,for,an,isolated,label,or,for,the,first,label,in,a,series,of,successive,labels,this,method,returns,the,label,itself,for,other,labels,it,returns,the,first,label,of,the,series,return,the,first,label,of,the,series,to,which,this,label,belongs;label,get,first,return,class,reader,frames,frame,null,this,frame,owner
Label -> @Override   public String toString();1531241461;Returns a string representation of this label.__@return a string representation of this label.;@Override_  public String toString() {_    return "L" + System.identityHashCode(this)__  };returns,a,string,representation,of,this,label,return,a,string,representation,of,this,label;override,public,string,to,string,return,l,system,identity,hash,code,this
Label -> @Override   public String toString();1536664245;Returns a string representation of this label.__@return a string representation of this label.;@Override_  public String toString() {_    return "L" + System.identityHashCode(this)__  };returns,a,string,representation,of,this,label,return,a,string,representation,of,this,label;override,public,string,to,string,return,l,system,identity,hash,code,this
Label -> @Override   public String toString();1537204147;Returns a string representation of this label.__@return a string representation of this label.;@Override_  public String toString() {_    return "L" + System.identityHashCode(this)__  };returns,a,string,representation,of,this,label,return,a,string,representation,of,this,label;override,public,string,to,string,return,l,system,identity,hash,code,this
Label -> public Label();1366718246;Constructs a new label.;public Label() {_    };constructs,a,new,label;public,label
Label -> public Label();1385501137;Constructs a new label.;public Label() {_    };constructs,a,new,label;public,label
Label -> public Label();1400531367;Constructs a new label.;public Label() {_    };constructs,a,new,label;public,label
Label -> public Label();1416998550;Constructs a new label.;public Label() {_    };constructs,a,new,label;public,label
Label -> public Label();1483093254;Constructs a new label.;public Label() {_    };constructs,a,new,label;public,label
Label -> public Label();1531241461;Constructs a new label.;public Label() {_    _  };constructs,a,new,label;public,label
Label -> public Label();1536664245;Constructs a new label.;public Label() {_    _  };constructs,a,new,label;public,label
Label -> public Label();1537204147;Constructs a new label.;public Label() {_    _  };constructs,a,new,label;public,label
Label -> final boolean resolve(final byte[] code, final int bytecodeOffset);1531241461;Sets the bytecode offset of this label to the given value and resolves the forward references_to this label, if any. This method must be called when this label is added to the bytecode of_the method, i.e. when its bytecode offset becomes known. This method fills in the blanks that_where left in the bytecode by each forward reference previously added to this label.__@param code the bytecode of the method._@param bytecodeOffset the bytecode offset of this label._@return <tt>true</tt> if a blank that was left for this label was too small to store the_offset. In such a case the corresponding jump instruction is replaced with an equivalent_ASM specific instruction using an unsigned two bytes offset. These ASM specific_instructions are later replaced with standard bytecode instructions with wider offsets (4_bytes instead of 2), in ClassReader.;final boolean resolve(final byte[] code, final int bytecodeOffset) {_    this.flags |= FLAG_RESOLVED__    this.bytecodeOffset = bytecodeOffset__    if (forwardReferences == null) {_      return false__    }_    boolean hasAsmInstructions = false__    for (int i = forwardReferences[0]_ i > 0_ i -= 2) {_      final int sourceInsnBytecodeOffset = forwardReferences[i - 1]__      final int reference = forwardReferences[i]__      final int relativeOffset = bytecodeOffset - sourceInsnBytecodeOffset__      int handle = reference & FORWARD_REFERENCE_HANDLE_MASK__      if ((reference & FORWARD_REFERENCE_TYPE_MASK) == FORWARD_REFERENCE_TYPE_SHORT) {_        if (relativeOffset < Short.MIN_VALUE || relativeOffset > Short.MAX_VALUE) {_          _          _          _          _          int opcode = code[sourceInsnBytecodeOffset] & 0xFF__          if (opcode < Opcodes.IFNULL) {_            _            code[sourceInsnBytecodeOffset] = (byte) (opcode + Constants.ASM_OPCODE_DELTA)__          } else {_            _            code[sourceInsnBytecodeOffset] = (byte) (opcode + Constants.ASM_IFNULL_OPCODE_DELTA)__          }_          hasAsmInstructions = true__        }_        code[handle++] = (byte) (relativeOffset >>> 8)__        code[handle] = (byte) relativeOffset__      } else {_        code[handle++] = (byte) (relativeOffset >>> 24)__        code[handle++] = (byte) (relativeOffset >>> 16)__        code[handle++] = (byte) (relativeOffset >>> 8)__        code[handle] = (byte) relativeOffset__      }_    }_    return hasAsmInstructions__  };sets,the,bytecode,offset,of,this,label,to,the,given,value,and,resolves,the,forward,references,to,this,label,if,any,this,method,must,be,called,when,this,label,is,added,to,the,bytecode,of,the,method,i,e,when,its,bytecode,offset,becomes,known,this,method,fills,in,the,blanks,that,where,left,in,the,bytecode,by,each,forward,reference,previously,added,to,this,label,param,code,the,bytecode,of,the,method,param,bytecode,offset,the,bytecode,offset,of,this,label,return,tt,true,tt,if,a,blank,that,was,left,for,this,label,was,too,small,to,store,the,offset,in,such,a,case,the,corresponding,jump,instruction,is,replaced,with,an,equivalent,asm,specific,instruction,using,an,unsigned,two,bytes,offset,these,asm,specific,instructions,are,later,replaced,with,standard,bytecode,instructions,with,wider,offsets,4,bytes,instead,of,2,in,class,reader;final,boolean,resolve,final,byte,code,final,int,bytecode,offset,this,flags,this,bytecode,offset,bytecode,offset,if,forward,references,null,return,false,boolean,has,asm,instructions,false,for,int,i,forward,references,0,i,0,i,2,final,int,source,insn,bytecode,offset,forward,references,i,1,final,int,reference,forward,references,i,final,int,relative,offset,bytecode,offset,source,insn,bytecode,offset,int,handle,reference,if,reference,if,relative,offset,short,relative,offset,short,int,opcode,code,source,insn,bytecode,offset,0x,ff,if,opcode,opcodes,ifnull,code,source,insn,bytecode,offset,byte,opcode,constants,else,code,source,insn,bytecode,offset,byte,opcode,constants,has,asm,instructions,true,code,handle,byte,relative,offset,8,code,handle,byte,relative,offset,else,code,handle,byte,relative,offset,24,code,handle,byte,relative,offset,16,code,handle,byte,relative,offset,8,code,handle,byte,relative,offset,return,has,asm,instructions
Label -> final boolean resolve(final byte[] code, final int bytecodeOffset);1536664245;Sets the bytecode offset of this label to the given value and resolves the forward references_to this label, if any. This method must be called when this label is added to the bytecode of_the method, i.e. when its bytecode offset becomes known. This method fills in the blanks that_where left in the bytecode by each forward reference previously added to this label.__@param code the bytecode of the method._@param bytecodeOffset the bytecode offset of this label._@return {@literal true} if a blank that was left for this label was too small to store the_offset. In such a case the corresponding jump instruction is replaced with an equivalent_ASM specific instruction using an unsigned two bytes offset. These ASM specific_instructions are later replaced with standard bytecode instructions with wider offsets (4_bytes instead of 2), in ClassReader.;final boolean resolve(final byte[] code, final int bytecodeOffset) {_    this.flags |= FLAG_RESOLVED__    this.bytecodeOffset = bytecodeOffset__    if (forwardReferences == null) {_      return false__    }_    boolean hasAsmInstructions = false__    for (int i = forwardReferences[0]_ i > 0_ i -= 2) {_      final int sourceInsnBytecodeOffset = forwardReferences[i - 1]__      final int reference = forwardReferences[i]__      final int relativeOffset = bytecodeOffset - sourceInsnBytecodeOffset__      int handle = reference & FORWARD_REFERENCE_HANDLE_MASK__      if ((reference & FORWARD_REFERENCE_TYPE_MASK) == FORWARD_REFERENCE_TYPE_SHORT) {_        if (relativeOffset < Short.MIN_VALUE || relativeOffset > Short.MAX_VALUE) {_          _          _          _          _          int opcode = code[sourceInsnBytecodeOffset] & 0xFF__          if (opcode < Opcodes.IFNULL) {_            _            code[sourceInsnBytecodeOffset] = (byte) (opcode + Constants.ASM_OPCODE_DELTA)__          } else {_            _            code[sourceInsnBytecodeOffset] = (byte) (opcode + Constants.ASM_IFNULL_OPCODE_DELTA)__          }_          hasAsmInstructions = true__        }_        code[handle++] = (byte) (relativeOffset >>> 8)__        code[handle] = (byte) relativeOffset__      } else {_        code[handle++] = (byte) (relativeOffset >>> 24)__        code[handle++] = (byte) (relativeOffset >>> 16)__        code[handle++] = (byte) (relativeOffset >>> 8)__        code[handle] = (byte) relativeOffset__      }_    }_    return hasAsmInstructions__  };sets,the,bytecode,offset,of,this,label,to,the,given,value,and,resolves,the,forward,references,to,this,label,if,any,this,method,must,be,called,when,this,label,is,added,to,the,bytecode,of,the,method,i,e,when,its,bytecode,offset,becomes,known,this,method,fills,in,the,blanks,that,where,left,in,the,bytecode,by,each,forward,reference,previously,added,to,this,label,param,code,the,bytecode,of,the,method,param,bytecode,offset,the,bytecode,offset,of,this,label,return,literal,true,if,a,blank,that,was,left,for,this,label,was,too,small,to,store,the,offset,in,such,a,case,the,corresponding,jump,instruction,is,replaced,with,an,equivalent,asm,specific,instruction,using,an,unsigned,two,bytes,offset,these,asm,specific,instructions,are,later,replaced,with,standard,bytecode,instructions,with,wider,offsets,4,bytes,instead,of,2,in,class,reader;final,boolean,resolve,final,byte,code,final,int,bytecode,offset,this,flags,this,bytecode,offset,bytecode,offset,if,forward,references,null,return,false,boolean,has,asm,instructions,false,for,int,i,forward,references,0,i,0,i,2,final,int,source,insn,bytecode,offset,forward,references,i,1,final,int,reference,forward,references,i,final,int,relative,offset,bytecode,offset,source,insn,bytecode,offset,int,handle,reference,if,reference,if,relative,offset,short,relative,offset,short,int,opcode,code,source,insn,bytecode,offset,0x,ff,if,opcode,opcodes,ifnull,code,source,insn,bytecode,offset,byte,opcode,constants,else,code,source,insn,bytecode,offset,byte,opcode,constants,has,asm,instructions,true,code,handle,byte,relative,offset,8,code,handle,byte,relative,offset,else,code,handle,byte,relative,offset,24,code,handle,byte,relative,offset,16,code,handle,byte,relative,offset,8,code,handle,byte,relative,offset,return,has,asm,instructions
Label -> final boolean resolve(final byte[] code, final int bytecodeOffset);1537204147;Sets the bytecode offset of this label to the given value and resolves the forward references_to this label, if any. This method must be called when this label is added to the bytecode of_the method, i.e. when its bytecode offset becomes known. This method fills in the blanks that_where left in the bytecode by each forward reference previously added to this label.__@param code the bytecode of the method._@param bytecodeOffset the bytecode offset of this label._@return {@literal true} if a blank that was left for this label was too small to store the_offset. In such a case the corresponding jump instruction is replaced with an equivalent_ASM specific instruction using an unsigned two bytes offset. These ASM specific_instructions are later replaced with standard bytecode instructions with wider offsets (4_bytes instead of 2), in ClassReader.;final boolean resolve(final byte[] code, final int bytecodeOffset) {_    this.flags |= FLAG_RESOLVED__    this.bytecodeOffset = bytecodeOffset__    if (forwardReferences == null) {_      return false__    }_    boolean hasAsmInstructions = false__    for (int i = forwardReferences[0]_ i > 0_ i -= 2) {_      final int sourceInsnBytecodeOffset = forwardReferences[i - 1]__      final int reference = forwardReferences[i]__      final int relativeOffset = bytecodeOffset - sourceInsnBytecodeOffset__      int handle = reference & FORWARD_REFERENCE_HANDLE_MASK__      if ((reference & FORWARD_REFERENCE_TYPE_MASK) == FORWARD_REFERENCE_TYPE_SHORT) {_        if (relativeOffset < Short.MIN_VALUE || relativeOffset > Short.MAX_VALUE) {_          _          _          _          _          int opcode = code[sourceInsnBytecodeOffset] & 0xFF__          if (opcode < Opcodes.IFNULL) {_            _            code[sourceInsnBytecodeOffset] = (byte) (opcode + Constants.ASM_OPCODE_DELTA)__          } else {_            _            code[sourceInsnBytecodeOffset] = (byte) (opcode + Constants.ASM_IFNULL_OPCODE_DELTA)__          }_          hasAsmInstructions = true__        }_        code[handle++] = (byte) (relativeOffset >>> 8)__        code[handle] = (byte) relativeOffset__      } else {_        code[handle++] = (byte) (relativeOffset >>> 24)__        code[handle++] = (byte) (relativeOffset >>> 16)__        code[handle++] = (byte) (relativeOffset >>> 8)__        code[handle] = (byte) relativeOffset__      }_    }_    return hasAsmInstructions__  };sets,the,bytecode,offset,of,this,label,to,the,given,value,and,resolves,the,forward,references,to,this,label,if,any,this,method,must,be,called,when,this,label,is,added,to,the,bytecode,of,the,method,i,e,when,its,bytecode,offset,becomes,known,this,method,fills,in,the,blanks,that,where,left,in,the,bytecode,by,each,forward,reference,previously,added,to,this,label,param,code,the,bytecode,of,the,method,param,bytecode,offset,the,bytecode,offset,of,this,label,return,literal,true,if,a,blank,that,was,left,for,this,label,was,too,small,to,store,the,offset,in,such,a,case,the,corresponding,jump,instruction,is,replaced,with,an,equivalent,asm,specific,instruction,using,an,unsigned,two,bytes,offset,these,asm,specific,instructions,are,later,replaced,with,standard,bytecode,instructions,with,wider,offsets,4,bytes,instead,of,2,in,class,reader;final,boolean,resolve,final,byte,code,final,int,bytecode,offset,this,flags,this,bytecode,offset,bytecode,offset,if,forward,references,null,return,false,boolean,has,asm,instructions,false,for,int,i,forward,references,0,i,0,i,2,final,int,source,insn,bytecode,offset,forward,references,i,1,final,int,reference,forward,references,i,final,int,relative,offset,bytecode,offset,source,insn,bytecode,offset,int,handle,reference,if,reference,if,relative,offset,short,relative,offset,short,int,opcode,code,source,insn,bytecode,offset,0x,ff,if,opcode,opcodes,ifnull,code,source,insn,bytecode,offset,byte,opcode,constants,else,code,source,insn,bytecode,offset,byte,opcode,constants,has,asm,instructions,true,code,handle,byte,relative,offset,8,code,handle,byte,relative,offset,else,code,handle,byte,relative,offset,24,code,handle,byte,relative,offset,16,code,handle,byte,relative,offset,8,code,handle,byte,relative,offset,return,has,asm,instructions
Label -> final void addSubroutineRetSuccessors(final Label subroutineCaller);1531241461;Finds the basic blocks that end a subroutine starting with the basic block corresponding to_this label and, for each one of them, adds an outgoing edge to the basic block following the_given subroutine call. In other words, completes the control flow graph by adding the edges_corresponding to the return from this subroutine, when called from the given caller basic_block.__<p>Note: a precondition and postcondition of this method is that all labels must have a null_{@link #nextListElement}.__@param subroutineCaller a basic block that ends with a jsr to the basic block corresponding to_this label. This label is supposed to correspond to the start of a subroutine.;final void addSubroutineRetSuccessors(final Label subroutineCaller) {_    _    _    _    _    _    Label listOfProcessedBlocks = EMPTY_LIST__    Label listOfBlocksToProcess = this__    listOfBlocksToProcess.nextListElement = EMPTY_LIST__    while (listOfBlocksToProcess != EMPTY_LIST) {_      _      Label basicBlock = listOfBlocksToProcess__      listOfBlocksToProcess = basicBlock.nextListElement__      basicBlock.nextListElement = listOfProcessedBlocks__      listOfProcessedBlocks = basicBlock___      _      _      _      if ((basicBlock.flags & FLAG_SUBROUTINE_END) != 0_          && basicBlock.subroutineId != subroutineCaller.subroutineId) {_        basicBlock.outgoingEdges =_            new Edge(_                basicBlock.outputStackSize,_                _                _                _                subroutineCaller.outgoingEdges.successor,_                basicBlock.outgoingEdges)__      }_      _      _      _      _      listOfBlocksToProcess = basicBlock.pushSuccessors(listOfBlocksToProcess)__    }_    _    _    while (listOfProcessedBlocks != EMPTY_LIST) {_      Label newListOfProcessedBlocks = listOfProcessedBlocks.nextListElement__      listOfProcessedBlocks.nextListElement = null__      listOfProcessedBlocks = newListOfProcessedBlocks__    }_  };finds,the,basic,blocks,that,end,a,subroutine,starting,with,the,basic,block,corresponding,to,this,label,and,for,each,one,of,them,adds,an,outgoing,edge,to,the,basic,block,following,the,given,subroutine,call,in,other,words,completes,the,control,flow,graph,by,adding,the,edges,corresponding,to,the,return,from,this,subroutine,when,called,from,the,given,caller,basic,block,p,note,a,precondition,and,postcondition,of,this,method,is,that,all,labels,must,have,a,null,link,next,list,element,param,subroutine,caller,a,basic,block,that,ends,with,a,jsr,to,the,basic,block,corresponding,to,this,label,this,label,is,supposed,to,correspond,to,the,start,of,a,subroutine;final,void,add,subroutine,ret,successors,final,label,subroutine,caller,label,list,of,processed,blocks,label,list,of,blocks,to,process,this,list,of,blocks,to,process,next,list,element,while,list,of,blocks,to,process,label,basic,block,list,of,blocks,to,process,list,of,blocks,to,process,basic,block,next,list,element,basic,block,next,list,element,list,of,processed,blocks,list,of,processed,blocks,basic,block,if,basic,block,flags,0,basic,block,subroutine,id,subroutine,caller,subroutine,id,basic,block,outgoing,edges,new,edge,basic,block,output,stack,size,subroutine,caller,outgoing,edges,successor,basic,block,outgoing,edges,list,of,blocks,to,process,basic,block,push,successors,list,of,blocks,to,process,while,list,of,processed,blocks,label,new,list,of,processed,blocks,list,of,processed,blocks,next,list,element,list,of,processed,blocks,next,list,element,null,list,of,processed,blocks,new,list,of,processed,blocks
Label -> final void addSubroutineRetSuccessors(final Label subroutineCaller);1536664245;Finds the basic blocks that end a subroutine starting with the basic block corresponding to_this label and, for each one of them, adds an outgoing edge to the basic block following the_given subroutine call. In other words, completes the control flow graph by adding the edges_corresponding to the return from this subroutine, when called from the given caller basic_block.__<p>Note: a precondition and postcondition of this method is that all labels must have a null_{@link #nextListElement}.__@param subroutineCaller a basic block that ends with a jsr to the basic block corresponding to_this label. This label is supposed to correspond to the start of a subroutine.;final void addSubroutineRetSuccessors(final Label subroutineCaller) {_    _    _    _    _    _    Label listOfProcessedBlocks = EMPTY_LIST__    Label listOfBlocksToProcess = this__    listOfBlocksToProcess.nextListElement = EMPTY_LIST__    while (listOfBlocksToProcess != EMPTY_LIST) {_      _      Label basicBlock = listOfBlocksToProcess__      listOfBlocksToProcess = basicBlock.nextListElement__      basicBlock.nextListElement = listOfProcessedBlocks__      listOfProcessedBlocks = basicBlock___      _      _      _      if ((basicBlock.flags & FLAG_SUBROUTINE_END) != 0_          && basicBlock.subroutineId != subroutineCaller.subroutineId) {_        basicBlock.outgoingEdges =_            new Edge(_                basicBlock.outputStackSize,_                _                _                _                subroutineCaller.outgoingEdges.successor,_                basicBlock.outgoingEdges)__      }_      _      _      _      _      listOfBlocksToProcess = basicBlock.pushSuccessors(listOfBlocksToProcess)__    }_    _    _    while (listOfProcessedBlocks != EMPTY_LIST) {_      Label newListOfProcessedBlocks = listOfProcessedBlocks.nextListElement__      listOfProcessedBlocks.nextListElement = null__      listOfProcessedBlocks = newListOfProcessedBlocks__    }_  };finds,the,basic,blocks,that,end,a,subroutine,starting,with,the,basic,block,corresponding,to,this,label,and,for,each,one,of,them,adds,an,outgoing,edge,to,the,basic,block,following,the,given,subroutine,call,in,other,words,completes,the,control,flow,graph,by,adding,the,edges,corresponding,to,the,return,from,this,subroutine,when,called,from,the,given,caller,basic,block,p,note,a,precondition,and,postcondition,of,this,method,is,that,all,labels,must,have,a,null,link,next,list,element,param,subroutine,caller,a,basic,block,that,ends,with,a,jsr,to,the,basic,block,corresponding,to,this,label,this,label,is,supposed,to,correspond,to,the,start,of,a,subroutine;final,void,add,subroutine,ret,successors,final,label,subroutine,caller,label,list,of,processed,blocks,label,list,of,blocks,to,process,this,list,of,blocks,to,process,next,list,element,while,list,of,blocks,to,process,label,basic,block,list,of,blocks,to,process,list,of,blocks,to,process,basic,block,next,list,element,basic,block,next,list,element,list,of,processed,blocks,list,of,processed,blocks,basic,block,if,basic,block,flags,0,basic,block,subroutine,id,subroutine,caller,subroutine,id,basic,block,outgoing,edges,new,edge,basic,block,output,stack,size,subroutine,caller,outgoing,edges,successor,basic,block,outgoing,edges,list,of,blocks,to,process,basic,block,push,successors,list,of,blocks,to,process,while,list,of,processed,blocks,label,new,list,of,processed,blocks,list,of,processed,blocks,next,list,element,list,of,processed,blocks,next,list,element,null,list,of,processed,blocks,new,list,of,processed,blocks
Label -> final void addSubroutineRetSuccessors(final Label subroutineCaller);1537204147;Finds the basic blocks that end a subroutine starting with the basic block corresponding to_this label and, for each one of them, adds an outgoing edge to the basic block following the_given subroutine call. In other words, completes the control flow graph by adding the edges_corresponding to the return from this subroutine, when called from the given caller basic_block.__<p>Note: a precondition and postcondition of this method is that all labels must have a null_{@link #nextListElement}.__@param subroutineCaller a basic block that ends with a jsr to the basic block corresponding to_this label. This label is supposed to correspond to the start of a subroutine.;final void addSubroutineRetSuccessors(final Label subroutineCaller) {_    _    _    _    _    _    Label listOfProcessedBlocks = EMPTY_LIST__    Label listOfBlocksToProcess = this__    listOfBlocksToProcess.nextListElement = EMPTY_LIST__    while (listOfBlocksToProcess != EMPTY_LIST) {_      _      Label basicBlock = listOfBlocksToProcess__      listOfBlocksToProcess = basicBlock.nextListElement__      basicBlock.nextListElement = listOfProcessedBlocks__      listOfProcessedBlocks = basicBlock___      _      _      _      if ((basicBlock.flags & FLAG_SUBROUTINE_END) != 0_          && basicBlock.subroutineId != subroutineCaller.subroutineId) {_        basicBlock.outgoingEdges =_            new Edge(_                basicBlock.outputStackSize,_                _                _                _                subroutineCaller.outgoingEdges.successor,_                basicBlock.outgoingEdges)__      }_      _      _      _      _      listOfBlocksToProcess = basicBlock.pushSuccessors(listOfBlocksToProcess)__    }_    _    _    while (listOfProcessedBlocks != EMPTY_LIST) {_      Label newListOfProcessedBlocks = listOfProcessedBlocks.nextListElement__      listOfProcessedBlocks.nextListElement = null__      listOfProcessedBlocks = newListOfProcessedBlocks__    }_  };finds,the,basic,blocks,that,end,a,subroutine,starting,with,the,basic,block,corresponding,to,this,label,and,for,each,one,of,them,adds,an,outgoing,edge,to,the,basic,block,following,the,given,subroutine,call,in,other,words,completes,the,control,flow,graph,by,adding,the,edges,corresponding,to,the,return,from,this,subroutine,when,called,from,the,given,caller,basic,block,p,note,a,precondition,and,postcondition,of,this,method,is,that,all,labels,must,have,a,null,link,next,list,element,param,subroutine,caller,a,basic,block,that,ends,with,a,jsr,to,the,basic,block,corresponding,to,this,label,this,label,is,supposed,to,correspond,to,the,start,of,a,subroutine;final,void,add,subroutine,ret,successors,final,label,subroutine,caller,label,list,of,processed,blocks,label,list,of,blocks,to,process,this,list,of,blocks,to,process,next,list,element,while,list,of,blocks,to,process,label,basic,block,list,of,blocks,to,process,list,of,blocks,to,process,basic,block,next,list,element,basic,block,next,list,element,list,of,processed,blocks,list,of,processed,blocks,basic,block,if,basic,block,flags,0,basic,block,subroutine,id,subroutine,caller,subroutine,id,basic,block,outgoing,edges,new,edge,basic,block,output,stack,size,subroutine,caller,outgoing,edges,successor,basic,block,outgoing,edges,list,of,blocks,to,process,basic,block,push,successors,list,of,blocks,to,process,while,list,of,processed,blocks,label,new,list,of,processed,blocks,list,of,processed,blocks,next,list,element,list,of,processed,blocks,next,list,element,null,list,of,processed,blocks,new,list,of,processed,blocks
