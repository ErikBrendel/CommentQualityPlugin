commented;modifiers;parameterAmount;loc;comment;code
true;public;0;6;/**  * Returns the bytecode offset corresponding to this label. This offset is computed from the start  * of the method's bytecode. <i>This method is intended for {@link Attribute} sub classes, and is  * normally not needed by class generators or adapters.</i>  *  * @return the bytecode offset corresponding to this label.  * @throws IllegalStateException if this label is not resolved yet.  */ ;/**  * Returns the bytecode offset corresponding to this label. This offset is computed from the start  * of the method's bytecode. <i>This method is intended for {@link Attribute} sub classes, and is  * normally not needed by class generators or adapters.</i>  *  * @return the bytecode offset corresponding to this label.  * @throws IllegalStateException if this label is not resolved yet.  */ public int getOffset() {     if ((flags & FLAG_RESOLVED) == 0) {         throw new IllegalStateException("Label offset position has not been resolved yet").     }     return bytecodeOffset. }
true;final;0;3;/**  * Returns the "canonical" {@link Label} instance corresponding to this label's bytecode offset,  * if known, otherwise the label itself. The canonical instance is the first label (in the order  * of their visit by {@link MethodVisitor#visitLabel}) corresponding to this bytecode offset. It  * cannot be known for labels which have not been visited yet.  *  * <p><i>This method should only be used when the {@link MethodWriter#COMPUTE_ALL_FRAMES} option  * is used.</i>  *  * @return the label itself if {@link #frame} is null, otherwise the Label's frame owner. This  *     corresponds to the "canonical" label instance described above thanks to the way the label  *     frame is set in {@link MethodWriter#visitLabel}.  */ ;/**  * Returns the "canonical" {@link Label} instance corresponding to this label's bytecode offset,  * if known, otherwise the label itself. The canonical instance is the first label (in the order  * of their visit by {@link MethodVisitor#visitLabel}) corresponding to this bytecode offset. It  * cannot be known for labels which have not been visited yet.  *  * <p><i>This method should only be used when the {@link MethodWriter#COMPUTE_ALL_FRAMES} option  * is used.</i>  *  * @return the label itself if {@link #frame} is null, otherwise the Label's frame owner. This  *     corresponds to the "canonical" label instance described above thanks to the way the label  *     frame is set in {@link MethodWriter#visitLabel}.  */ final Label getCanonicalInstance() {     return frame == null ? this : frame.owner. }
true;final;1;16;/**  * Adds a source line number corresponding to this label.  *  * @param lineNumber a source line number (which should be strictly positive).  */ ;// ----------------------------------------------------------------------------------------------- // Methods to manage line numbers // ----------------------------------------------------------------------------------------------- /**  * Adds a source line number corresponding to this label.  *  * @param lineNumber a source line number (which should be strictly positive).  */ final void addLineNumber(final int lineNumber) {     if (this.lineNumber == 0) {         this.lineNumber = (short) lineNumber.     } else {         if (otherLineNumbers == null) {             otherLineNumbers = new int[LINE_NUMBERS_CAPACITY_INCREMENT].         }         int otherLineNumberIndex = ++otherLineNumbers[0].         if (otherLineNumberIndex >= otherLineNumbers.length) {             int[] newLineNumbers = new int[otherLineNumbers.length + LINE_NUMBERS_CAPACITY_INCREMENT].             System.arraycopy(otherLineNumbers, 0, newLineNumbers, 0, otherLineNumbers.length).             otherLineNumbers = newLineNumbers.         }         otherLineNumbers[otherLineNumberIndex] = lineNumber.     } }
true;final;2;11;/**  * Makes the given visitor visit this label and its source line numbers, if applicable.  *  * @param methodVisitor a method visitor.  * @param visitLineNumbers whether to visit of the label's source line numbers, if any.  */ ;/**  * Makes the given visitor visit this label and its source line numbers, if applicable.  *  * @param methodVisitor a method visitor.  * @param visitLineNumbers whether to visit of the label's source line numbers, if any.  */ final void accept(final MethodVisitor methodVisitor, final boolean visitLineNumbers) {     methodVisitor.visitLabel(this).     if (visitLineNumbers && lineNumber != 0) {         methodVisitor.visitLineNumber(lineNumber & 0xFFFF, this).         if (otherLineNumbers != null) {             for (int i = 1. i <= otherLineNumbers[0]. ++i) {                 methodVisitor.visitLineNumber(otherLineNumbers[i], this).             }         }     } }
true;final;3;18;/**  * Puts a reference to this label in the bytecode of a method. If the bytecode offset of the label  * is known, the relative bytecode offset between the label and the instruction referencing it is  * computed and written directly. Otherwise, a null relative offset is written and a new forward  * reference is declared for this label.  *  * @param code the bytecode of the method. This is where the reference is appended.  * @param sourceInsnBytecodeOffset the bytecode offset of the instruction that contains the  *     reference to be appended.  * @param wideReference whether the reference must be stored in 4 bytes (instead of 2 bytes).  */ ;// ----------------------------------------------------------------------------------------------- // Methods to compute offsets and to manage forward references // ----------------------------------------------------------------------------------------------- /**  * Puts a reference to this label in the bytecode of a method. If the bytecode offset of the label  * is known, the relative bytecode offset between the label and the instruction referencing it is  * computed and written directly. Otherwise, a null relative offset is written and a new forward  * reference is declared for this label.  *  * @param code the bytecode of the method. This is where the reference is appended.  * @param sourceInsnBytecodeOffset the bytecode offset of the instruction that contains the  *     reference to be appended.  * @param wideReference whether the reference must be stored in 4 bytes (instead of 2 bytes).  */ final void put(final ByteVector code, final int sourceInsnBytecodeOffset, final boolean wideReference) {     if ((flags & FLAG_RESOLVED) == 0) {         if (wideReference) {             addForwardReference(sourceInsnBytecodeOffset, FORWARD_REFERENCE_TYPE_WIDE, code.length).             code.putInt(-1).         } else {             addForwardReference(sourceInsnBytecodeOffset, FORWARD_REFERENCE_TYPE_SHORT, code.length).             code.putShort(-1).         }     } else {         if (wideReference) {             code.putInt(bytecodeOffset - sourceInsnBytecodeOffset).         } else {             code.putShort(bytecodeOffset - sourceInsnBytecodeOffset).         }     } }
true;private;3;15;/**  * Adds a forward reference to this label. This method must be called only for a true forward  * reference, i.e. only if this label is not resolved yet. For backward references, the relative  * bytecode offset of the reference can be, and must be, computed and stored directly.  *  * @param sourceInsnBytecodeOffset the bytecode offset of the instruction that contains the  *     reference stored at referenceHandle.  * @param referenceType either {@link #FORWARD_REFERENCE_TYPE_SHORT} or {@link  *     #FORWARD_REFERENCE_TYPE_WIDE}.  * @param referenceHandle the offset in the bytecode where the forward reference value must be  *     stored.  */ ;/**  * Adds a forward reference to this label. This method must be called only for a true forward  * reference, i.e. only if this label is not resolved yet. For backward references, the relative  * bytecode offset of the reference can be, and must be, computed and stored directly.  *  * @param sourceInsnBytecodeOffset the bytecode offset of the instruction that contains the  *     reference stored at referenceHandle.  * @param referenceType either {@link #FORWARD_REFERENCE_TYPE_SHORT} or {@link  *     #FORWARD_REFERENCE_TYPE_WIDE}.  * @param referenceHandle the offset in the bytecode where the forward reference value must be  *     stored.  */ private void addForwardReference(final int sourceInsnBytecodeOffset, final int referenceType, final int referenceHandle) {     if (forwardReferences == null) {         forwardReferences = new int[FORWARD_REFERENCES_CAPACITY_INCREMENT].     }     int lastElementIndex = forwardReferences[0].     if (lastElementIndex + 2 >= forwardReferences.length) {         int[] newValues = new int[forwardReferences.length + FORWARD_REFERENCES_CAPACITY_INCREMENT].         System.arraycopy(forwardReferences, 0, newValues, 0, forwardReferences.length).         forwardReferences = newValues.     }     forwardReferences[++lastElementIndex] = sourceInsnBytecodeOffset.     forwardReferences[++lastElementIndex] = referenceType | referenceHandle.     forwardReferences[0] = lastElementIndex. }
true;final;2;39;/**  * Sets the bytecode offset of this label to the given value and resolves the forward references  * to this label, if any. This method must be called when this label is added to the bytecode of  * the method, i.e. when its bytecode offset becomes known. This method fills in the blanks that  * where left in the bytecode by each forward reference previously added to this label.  *  * @param code the bytecode of the method.  * @param bytecodeOffset the bytecode offset of this label.  * @return {@literal true} if a blank that was left for this label was too small to store the  *     offset. In such a case the corresponding jump instruction is replaced with an equivalent  *     ASM specific instruction using an unsigned two bytes offset. These ASM specific  *     instructions are later replaced with standard bytecode instructions with wider offsets (4  *     bytes instead of 2), in ClassReader.  */ ;/**  * Sets the bytecode offset of this label to the given value and resolves the forward references  * to this label, if any. This method must be called when this label is added to the bytecode of  * the method, i.e. when its bytecode offset becomes known. This method fills in the blanks that  * where left in the bytecode by each forward reference previously added to this label.  *  * @param code the bytecode of the method.  * @param bytecodeOffset the bytecode offset of this label.  * @return {@literal true} if a blank that was left for this label was too small to store the  *     offset. In such a case the corresponding jump instruction is replaced with an equivalent  *     ASM specific instruction using an unsigned two bytes offset. These ASM specific  *     instructions are later replaced with standard bytecode instructions with wider offsets (4  *     bytes instead of 2), in ClassReader.  */ final boolean resolve(final byte[] code, final int bytecodeOffset) {     this.flags |= FLAG_RESOLVED.     this.bytecodeOffset = bytecodeOffset.     if (forwardReferences == null) {         return false.     }     boolean hasAsmInstructions = false.     for (int i = forwardReferences[0]. i > 0. i -= 2) {         final int sourceInsnBytecodeOffset = forwardReferences[i - 1].         final int reference = forwardReferences[i].         final int relativeOffset = bytecodeOffset - sourceInsnBytecodeOffset.         int handle = reference & FORWARD_REFERENCE_HANDLE_MASK.         if ((reference & FORWARD_REFERENCE_TYPE_MASK) == FORWARD_REFERENCE_TYPE_SHORT) {             if (relativeOffset < Short.MIN_VALUE || relativeOffset > Short.MAX_VALUE) {                 // Change the opcode of the jump instruction, in order to be able to find it later in                 // ClassReader. These ASM specific opcodes are similar to jump instruction opcodes, except                 // that the 2 bytes offset is unsigned (and can therefore represent values from 0 to                 // 65535, which is sufficient since the size of a method is limited to 65535 bytes).                 int opcode = code[sourceInsnBytecodeOffset] & 0xFF.                 if (opcode < Opcodes.IFNULL) {                     // Change IFEQ ... JSR to ASM_IFEQ ... ASM_JSR.                     code[sourceInsnBytecodeOffset] = (byte) (opcode + Constants.ASM_OPCODE_DELTA).                 } else {                     // Change IFNULL and IFNONNULL to ASM_IFNULL and ASM_IFNONNULL.                     code[sourceInsnBytecodeOffset] = (byte) (opcode + Constants.ASM_IFNULL_OPCODE_DELTA).                 }                 hasAsmInstructions = true.             }             code[handle++] = (byte) (relativeOffset >>> 8).             code[handle] = (byte) relativeOffset.         } else {             code[handle++] = (byte) (relativeOffset >>> 24).             code[handle++] = (byte) (relativeOffset >>> 16).             code[handle++] = (byte) (relativeOffset >>> 8).             code[handle] = (byte) relativeOffset.         }     }     return hasAsmInstructions. }
true;final;1;21;/**  * Finds the basic blocks that belong to the subroutine starting with the basic block  * corresponding to this label, and marks these blocks as belonging to this subroutine. This  * method follows the control flow graph to find all the blocks that are reachable from the  * current basic block WITHOUT following any jsr target.  *  * <p>Note: a precondition and postcondition of this method is that all labels must have a null  * {@link #nextListElement}.  *  * @param subroutineId the id of the subroutine starting with the basic block corresponding to  *     this label.  */ ;// ----------------------------------------------------------------------------------------------- // Methods related to subroutines // ----------------------------------------------------------------------------------------------- /**  * Finds the basic blocks that belong to the subroutine starting with the basic block  * corresponding to this label, and marks these blocks as belonging to this subroutine. This  * method follows the control flow graph to find all the blocks that are reachable from the  * current basic block WITHOUT following any jsr target.  *  * <p>Note: a precondition and postcondition of this method is that all labels must have a null  * {@link #nextListElement}.  *  * @param subroutineId the id of the subroutine starting with the basic block corresponding to  *     this label.  */ final void markSubroutine(final short subroutineId) {     // Data flow algorithm: put this basic block in a list of blocks to process (which are blocks     // belonging to subroutine subroutineId) and, while there are blocks to process, remove one from     // the list, mark it as belonging to the subroutine, and add its successor basic blocks in the     // control flow graph to the list of blocks to process (if not already done).     Label listOfBlocksToProcess = this.     listOfBlocksToProcess.nextListElement = EMPTY_LIST.     while (listOfBlocksToProcess != EMPTY_LIST) {         // Remove a basic block from the list of blocks to process.         Label basicBlock = listOfBlocksToProcess.         listOfBlocksToProcess = listOfBlocksToProcess.nextListElement.         basicBlock.nextListElement = null.         // subroutineId and add its successors to the list of blocks to process (unless already done).         if (basicBlock.subroutineId == 0) {             basicBlock.subroutineId = subroutineId.             listOfBlocksToProcess = basicBlock.pushSuccessors(listOfBlocksToProcess).         }     } }
true;final;1;44;/**  * Finds the basic blocks that end a subroutine starting with the basic block corresponding to  * this label and, for each one of them, adds an outgoing edge to the basic block following the  * given subroutine call. In other words, completes the control flow graph by adding the edges  * corresponding to the return from this subroutine, when called from the given caller basic  * block.  *  * <p>Note: a precondition and postcondition of this method is that all labels must have a null  * {@link #nextListElement}.  *  * @param subroutineCaller a basic block that ends with a jsr to the basic block corresponding to  *     this label. This label is supposed to correspond to the start of a subroutine.  */ ;/**  * Finds the basic blocks that end a subroutine starting with the basic block corresponding to  * this label and, for each one of them, adds an outgoing edge to the basic block following the  * given subroutine call. In other words, completes the control flow graph by adding the edges  * corresponding to the return from this subroutine, when called from the given caller basic  * block.  *  * <p>Note: a precondition and postcondition of this method is that all labels must have a null  * {@link #nextListElement}.  *  * @param subroutineCaller a basic block that ends with a jsr to the basic block corresponding to  *     this label. This label is supposed to correspond to the start of a subroutine.  */ final void addSubroutineRetSuccessors(final Label subroutineCaller) {     // Data flow algorithm: put this basic block in a list blocks to process (which are blocks     // belonging to a subroutine starting with this label) and, while there are blocks to process,     // remove one from the list, put it in a list of blocks that have been processed, add a return     // edge to the successor of subroutineCaller if applicable, and add its successor basic blocks     // in the control flow graph to the list of blocks to process (if not already done).     Label listOfProcessedBlocks = EMPTY_LIST.     Label listOfBlocksToProcess = this.     listOfBlocksToProcess.nextListElement = EMPTY_LIST.     while (listOfBlocksToProcess != EMPTY_LIST) {         // Move a basic block from the list of blocks to process to the list of processed blocks.         Label basicBlock = listOfBlocksToProcess.         listOfBlocksToProcess = basicBlock.nextListElement.         basicBlock.nextListElement = listOfProcessedBlocks.         listOfProcessedBlocks = basicBlock.         // subroutine.         if ((basicBlock.flags & FLAG_SUBROUTINE_END) != 0 && basicBlock.subroutineId != subroutineCaller.subroutineId) {             basicBlock.outgoingEdges = new Edge(basicBlock.outputStackSize, // when ret is called (see {@link #FLAG_SUBROUTINE_CALLER}).             subroutineCaller.outgoingEdges.successor, basicBlock.outgoingEdges).         }         // Add its successors to the list of blocks to process. Note that {@link #pushSuccessors} does         // not push basic blocks which are already in a list. Here this means either in the list of         // blocks to process, or in the list of already processed blocks. This second list is         // important to make sure we don't reprocess an already processed block.         listOfBlocksToProcess = basicBlock.pushSuccessors(listOfBlocksToProcess).     }     // so that this method can be called again with a different subroutine or subroutine caller.     while (listOfProcessedBlocks != EMPTY_LIST) {         Label newListOfProcessedBlocks = listOfProcessedBlocks.nextListElement.         listOfProcessedBlocks.nextListElement = null.         listOfProcessedBlocks = newListOfProcessedBlocks.     } }
true;private;1;18;/**  * Adds the successors of this label in the method's control flow graph (except those  * corresponding to a jsr target, and those already in a list of labels) to the given list of  * blocks to process, and returns the new list.  *  * @param listOfLabelsToProcess a list of basic blocks to process, linked together with their  *     {@link #nextListElement} field.  * @return the new list of blocks to process.  */ ;/**  * Adds the successors of this label in the method's control flow graph (except those  * corresponding to a jsr target, and those already in a list of labels) to the given list of  * blocks to process, and returns the new list.  *  * @param listOfLabelsToProcess a list of basic blocks to process, linked together with their  *     {@link #nextListElement} field.  * @return the new list of blocks to process.  */ private Label pushSuccessors(final Label listOfLabelsToProcess) {     Label newListOfLabelsToProcess = listOfLabelsToProcess.     Edge outgoingEdge = outgoingEdges.     while (outgoingEdge != null) {         // By construction, the second outgoing edge of a basic block that ends with a jsr instruction         // leads to the jsr target (see {@link #FLAG_SUBROUTINE_CALLER}).         boolean isJsrTarget = (flags & Label.FLAG_SUBROUTINE_CALLER) != 0 && outgoingEdge == outgoingEdges.nextEdge.         if (!isJsrTarget && outgoingEdge.successor.nextListElement == null) {             // Add this successor to the list of blocks to process, if it does not already belong to a             // list of labels.             outgoingEdge.successor.nextListElement = newListOfLabelsToProcess.             newListOfLabelsToProcess = outgoingEdge.successor.         }         outgoingEdge = outgoingEdge.nextEdge.     }     return newListOfLabelsToProcess. }
true;public;0;4;/**  * Returns a string representation of this label.  *  * @return a string representation of this label.  */ ;// ----------------------------------------------------------------------------------------------- // Overridden Object methods // ----------------------------------------------------------------------------------------------- /**  * Returns a string representation of this label.  *  * @return a string representation of this label.  */ @Override public String toString() {     return "L" + System.identityHashCode(this). }
