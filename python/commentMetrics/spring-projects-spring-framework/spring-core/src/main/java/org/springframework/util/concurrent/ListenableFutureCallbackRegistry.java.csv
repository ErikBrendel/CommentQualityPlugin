commented;modifiers;parameterAmount;loc;comment;code
true;public;1;17;/**  * Add the given callback to this registry.  * @param callback the callback to add  */ ;/**  * Add the given callback to this registry.  * @param callback the callback to add  */ public void addCallback(ListenableFutureCallback<? super T> callback) {     Assert.notNull(callback, "'callback' must not be null").     synchronized (this.mutex) {         switch(this.state) {             case NEW:                 this.successCallbacks.add(callback).                 this.failureCallbacks.add(callback).                 break.             case SUCCESS:                 notifySuccess(callback).                 break.             case FAILURE:                 notifyFailure(callback).                 break.         }     } }
false;private;1;9;;@SuppressWarnings("unchecked") private void notifySuccess(SuccessCallback<? super T> callback) {     try {         callback.onSuccess((T) this.result).     } catch (Throwable ex) {     // Ignore     } }
false;private;1;9;;private void notifyFailure(FailureCallback callback) {     Assert.state(this.result instanceof Throwable, "No Throwable result for failure state").     try {         callback.onFailure((Throwable) this.result).     } catch (Throwable ex) {     // Ignore     } }
true;public;1;13;/**  * Add the given success callback to this registry.  * @param callback the success callback to add  * @since 4.1  */ ;/**  * Add the given success callback to this registry.  * @param callback the success callback to add  * @since 4.1  */ public void addSuccessCallback(SuccessCallback<? super T> callback) {     Assert.notNull(callback, "'callback' must not be null").     synchronized (this.mutex) {         switch(this.state) {             case NEW:                 this.successCallbacks.add(callback).                 break.             case SUCCESS:                 notifySuccess(callback).                 break.         }     } }
true;public;1;13;/**  * Add the given failure callback to this registry.  * @param callback the failure callback to add  * @since 4.1  */ ;/**  * Add the given failure callback to this registry.  * @param callback the failure callback to add  * @since 4.1  */ public void addFailureCallback(FailureCallback callback) {     Assert.notNull(callback, "'callback' must not be null").     synchronized (this.mutex) {         switch(this.state) {             case NEW:                 this.failureCallbacks.add(callback).                 break.             case FAILURE:                 notifyFailure(callback).                 break.         }     } }
true;public;1;10;/**  * Trigger a {@link ListenableFutureCallback#onSuccess(Object)} call on all  * added callbacks with the given result.  * @param result the result to trigger the callbacks with  */ ;/**  * Trigger a {@link ListenableFutureCallback#onSuccess(Object)} call on all  * added callbacks with the given result.  * @param result the result to trigger the callbacks with  */ public void success(@Nullable T result) {     synchronized (this.mutex) {         this.state = State.SUCCESS.         this.result = result.         SuccessCallback<? super T> callback.         while ((callback = this.successCallbacks.poll()) != null) {             notifySuccess(callback).         }     } }
true;public;1;10;/**  * Trigger a {@link ListenableFutureCallback#onFailure(Throwable)} call on all  * added callbacks with the given {@code Throwable}.  * @param ex the exception to trigger the callbacks with  */ ;/**  * Trigger a {@link ListenableFutureCallback#onFailure(Throwable)} call on all  * added callbacks with the given {@code Throwable}.  * @param ex the exception to trigger the callbacks with  */ public void failure(Throwable ex) {     synchronized (this.mutex) {         this.state = State.FAILURE.         this.result = ex.         FailureCallback callback.         while ((callback = this.failureCallbacks.poll()) != null) {             notifyFailure(callback).         }     } }
