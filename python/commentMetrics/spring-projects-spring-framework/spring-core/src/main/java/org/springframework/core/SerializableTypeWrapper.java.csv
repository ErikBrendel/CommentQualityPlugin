commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;4;/**  * Return a {@link Serializable} variant of {@link Field#getGenericType()}.  */ ;/**  * Return a {@link Serializable} variant of {@link Field#getGenericType()}.  */ @Nullable public static Type forField(Field field) {     return forTypeProvider(new FieldTypeProvider(field)). }
true;public,static;1;4;/**  * Return a {@link Serializable} variant of  * {@link MethodParameter#getGenericParameterType()}.  */ ;/**  * Return a {@link Serializable} variant of  * {@link MethodParameter#getGenericParameterType()}.  */ @Nullable public static Type forMethodParameter(MethodParameter methodParameter) {     return forTypeProvider(new MethodParameterTypeProvider(methodParameter)). }
true;public,static;1;8;/**  * Unwrap the given type, effectively returning the original non-serializable type.  * @param type the type to unwrap  * @return the original non-serializable type  */ ;/**  * Unwrap the given type, effectively returning the original non-serializable type.  * @param type the type to unwrap  * @return the original non-serializable type  */ @SuppressWarnings("unchecked") public static <T extends Type> T unwrap(T type) {     Type unwrapped = type.     while (unwrapped instanceof SerializableTypeProxy) {         unwrapped = ((SerializableTypeProxy) type).getTypeProvider().getType().     }     return (unwrapped != null ? (T) unwrapped : type). }
true;static;1;30;/**  * Return a {@link Serializable} {@link Type} backed by a {@link TypeProvider} .  * <p>If type artifacts are generally not serializable in the current runtime  * environment, this delegate will simply return the original {@code Type} as-is.  */ ;/**  * Return a {@link Serializable} {@link Type} backed by a {@link TypeProvider} .  * <p>If type artifacts are generally not serializable in the current runtime  * environment, this delegate will simply return the original {@code Type} as-is.  */ @Nullable static Type forTypeProvider(TypeProvider provider) {     Type providedType = provider.getType().     if (providedType == null || providedType instanceof Serializable) {         // No serializable type wrapping necessary (e.g. for java.lang.Class)         return providedType.     }     if (GraalDetector.inImageCode() || !Serializable.class.isAssignableFrom(Class.class)) {         // the current runtime environment (even java.lang.Class itself, e.g. on Graal)         return providedType.     }     // Obtain a serializable type proxy for the given provider...     Type cached = cache.get(providedType).     if (cached != null) {         return cached.     }     for (Class<?> type : SUPPORTED_SERIALIZABLE_TYPES) {         if (type.isInstance(providedType)) {             ClassLoader classLoader = provider.getClass().getClassLoader().             Class<?>[] interfaces = new Class<?>[] { type, SerializableTypeProxy.class, Serializable.class }.             InvocationHandler handler = new TypeProxyInvocationHandler(provider).             cached = (Type) Proxy.newProxyInstance(classLoader, interfaces, handler).             cache.put(providedType, cached).             return cached.         }     }     throw new IllegalArgumentException("Unsupported Type class: " + providedType.getClass().getName()). }
true;;0;1;/**  * Return the underlying type provider.  */ ;/**  * Return the underlying type provider.  */ TypeProvider getTypeProvider().
true;;0;2;/**  * Return the (possibly non {@link Serializable}) {@link Type}.  */ ;/**  * Return the (possibly non {@link Serializable}) {@link Type}.  */ @Nullable Type getType().
true;default;0;4;/**  * Return the source of the type, or {@code null} if not known.  * <p>The default implementations returns {@code null}.  */ ;/**  * Return the source of the type, or {@code null} if not known.  * <p>The default implementations returns {@code null}.  */ @Nullable default Object getSource() {     return null. }
false;public;3;36;;@Override @Nullable public Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable {     if (method.getName().equals("equals") && args != null) {         Object other = args[0].         // Unwrap proxies for speed         if (other instanceof Type) {             other = unwrap((Type) other).         }         return ObjectUtils.nullSafeEquals(this.provider.getType(), other).     } else if (method.getName().equals("hashCode")) {         return ObjectUtils.nullSafeHashCode(this.provider.getType()).     } else if (method.getName().equals("getTypeProvider")) {         return this.provider.     }     if (Type.class == method.getReturnType() && args == null) {         return forTypeProvider(new MethodInvokeTypeProvider(this.provider, method, -1)).     } else if (Type[].class == method.getReturnType() && args == null) {         Type[] result = new Type[((Type[]) method.invoke(this.provider.getType())).length].         for (int i = 0. i < result.length. i++) {             result[i] = forTypeProvider(new MethodInvokeTypeProvider(this.provider, method, i)).         }         return result.     }     try {         return method.invoke(this.provider.getType(), args).     } catch (InvocationTargetException ex) {         throw ex.getTargetException().     } }
false;public;0;4;;@Override public Type getType() {     return this.field.getGenericType(). }
false;public;0;4;;@Override public Object getSource() {     return this.field. }
false;private;1;9;;private void readObject(ObjectInputStream inputStream) throws IOException, ClassNotFoundException {     inputStream.defaultReadObject().     try {         this.field = this.declaringClass.getDeclaredField(this.fieldName).     } catch (Throwable ex) {         throw new IllegalStateException("Could not find original class structure", ex).     } }
false;public;0;4;;@Override public Type getType() {     return this.methodParameter.getGenericParameterType(). }
false;public;0;4;;@Override public Object getSource() {     return this.methodParameter. }
false;private;1;16;;private void readObject(ObjectInputStream inputStream) throws IOException, ClassNotFoundException {     inputStream.defaultReadObject().     try {         if (this.methodName != null) {             this.methodParameter = new MethodParameter(this.declaringClass.getDeclaredMethod(this.methodName, this.parameterTypes), this.parameterIndex).         } else {             this.methodParameter = new MethodParameter(this.declaringClass.getDeclaredConstructor(this.parameterTypes), this.parameterIndex).         }     } catch (Throwable ex) {         throw new IllegalStateException("Could not find original class structure", ex).     } }
false;public;0;12;;@Override @Nullable public Type getType() {     Object result = this.result.     if (result == null) {         // Lazy invocation of the target method on the provided type         result = ReflectionUtils.invokeMethod(this.method, this.provider.getType()).         // Cache the result for further calls to getType()         this.result = result.     }     return (result instanceof Type[] ? ((Type[]) result)[this.index] : (Type) result). }
false;public;0;5;;@Override @Nullable public Object getSource() {     return null. }
false;private;1;12;;private void readObject(ObjectInputStream inputStream) throws IOException, ClassNotFoundException {     inputStream.defaultReadObject().     Method method = ReflectionUtils.findMethod(this.declaringClass, this.methodName).     if (method == null) {         throw new IllegalStateException("Cannot find method on deserialization: " + this.methodName).     }     if (method.getReturnType() != Type.class && method.getReturnType() != Type[].class) {         throw new IllegalStateException("Invalid return type on deserialized method - needs to be Type or Type[]: " + method).     }     this.method = method. }
