commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;16;;@Override protected Class<?> resolveClass(ObjectStreamClass classDesc) throws IOException, ClassNotFoundException {     try {         if (this.classLoader != null) {             // Use the specified ClassLoader to resolve local classes.             return ClassUtils.forName(classDesc.getName(), this.classLoader).         } else {             // Use the default ClassLoader...             return super.resolveClass(classDesc).         }     } catch (ClassNotFoundException ex) {         return resolveFallbackIfPossible(classDesc.getName(), ex).     } }
false;protected;1;37;;@Override protected Class<?> resolveProxyClass(String[] interfaces) throws IOException, ClassNotFoundException {     if (!this.acceptProxyClasses) {         throw new NotSerializableException("Not allowed to accept serialized proxy classes").     }     if (this.classLoader != null) {         // Use the specified ClassLoader to resolve local proxy classes.         Class<?>[] resolvedInterfaces = new Class<?>[interfaces.length].         for (int i = 0. i < interfaces.length. i++) {             try {                 resolvedInterfaces[i] = ClassUtils.forName(interfaces[i], this.classLoader).             } catch (ClassNotFoundException ex) {                 resolvedInterfaces[i] = resolveFallbackIfPossible(interfaces[i], ex).             }         }         try {             return ClassUtils.createCompositeInterface(resolvedInterfaces, this.classLoader).         } catch (IllegalArgumentException ex) {             throw new ClassNotFoundException(null, ex).         }     } else {         // Use ObjectInputStream's default ClassLoader...         try {             return super.resolveProxyClass(interfaces).         } catch (ClassNotFoundException ex) {             Class<?>[] resolvedInterfaces = new Class<?>[interfaces.length].             for (int i = 0. i < interfaces.length. i++) {                 resolvedInterfaces[i] = resolveFallbackIfPossible(interfaces[i], ex).             }             return ClassUtils.createCompositeInterface(resolvedInterfaces, getFallbackClassLoader()).         }     } }
true;protected;2;5;/**  * Resolve the given class name against a fallback class loader.  * <p>The default implementation simply rethrows the original exception,  * since there is no fallback available.  * @param className the class name to resolve  * @param ex the original exception thrown when attempting to load the class  * @return the newly resolved class (never {@code null})  */ ;/**  * Resolve the given class name against a fallback class loader.  * <p>The default implementation simply rethrows the original exception,  * since there is no fallback available.  * @param className the class name to resolve  * @param ex the original exception thrown when attempting to load the class  * @return the newly resolved class (never {@code null})  */ protected Class<?> resolveFallbackIfPossible(String className, ClassNotFoundException ex) throws IOException, ClassNotFoundException {     throw ex. }
true;protected;0;4;/**  * Return the fallback ClassLoader to use when no ClassLoader was specified  * and ObjectInputStream's own default class loader failed.  * <p>The default implementation simply returns {@code null}, indicating  * that no specific fallback is available.  */ ;/**  * Return the fallback ClassLoader to use when no ClassLoader was specified  * and ObjectInputStream's own default class loader failed.  * <p>The default implementation simply returns {@code null}, indicating  * that no specific fallback is available.  */ @Nullable protected ClassLoader getFallbackClassLoader() throws IOException {     return null. }
