# id;timestamp;commentText;codeText;commentWords;codeWords
AntPathMatcher -> public AntPathMatcher(String pathSeparator);1405378164;Create a new AntPathMatcher._@param pathSeparator the path separator to use_@since 4.1;public AntPathMatcher(String pathSeparator) {_		if(pathSeparator != null) {_			this.pathSeparator = pathSeparator__		}_	};create,a,new,ant,path,matcher,param,path,separator,the,path,separator,to,use,since,4,1;public,ant,path,matcher,string,path,separator,if,path,separator,null,this,path,separator,path,separator
AntPathMatcher -> public AntPathMatcher(String pathSeparator);1405378165;A convenience alternative constructor to use with a custom path separator._@param pathSeparator the path separator to use, must not be {@code null}._@since 4.1;public AntPathMatcher(String pathSeparator) {_		Assert.notNull(pathSeparator, "'pathSeparator' is required")__		this.pathSeparator = pathSeparator__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(pathSeparator)__	};a,convenience,alternative,constructor,to,use,with,a,custom,path,separator,param,path,separator,the,path,separator,to,use,must,not,be,code,null,since,4,1;public,ant,path,matcher,string,path,separator,assert,not,null,path,separator,path,separator,is,required,this,path,separator,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,path,separator
AntPathMatcher -> public AntPathMatcher(String pathSeparator);1405696918;A convenience alternative constructor to use with a custom path separator._@param pathSeparator the path separator to use, must not be {@code null}._@since 4.1;public AntPathMatcher(String pathSeparator) {_		Assert.notNull(pathSeparator, "'pathSeparator' is required")__		this.pathSeparator = pathSeparator__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(pathSeparator)__	};a,convenience,alternative,constructor,to,use,with,a,custom,path,separator,param,path,separator,the,path,separator,to,use,must,not,be,code,null,since,4,1;public,ant,path,matcher,string,path,separator,assert,not,null,path,separator,path,separator,is,required,this,path,separator,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,path,separator
AntPathMatcher -> public AntPathMatcher(String pathSeparator);1409784938;A convenience alternative constructor to use with a custom path separator._@param pathSeparator the path separator to use, must not be {@code null}._@since 4.1;public AntPathMatcher(String pathSeparator) {_		Assert.notNull(pathSeparator, "'pathSeparator' is required")__		this.pathSeparator = pathSeparator__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(pathSeparator)__	};a,convenience,alternative,constructor,to,use,with,a,custom,path,separator,param,path,separator,the,path,separator,to,use,must,not,be,code,null,since,4,1;public,ant,path,matcher,string,path,separator,assert,not,null,path,separator,path,separator,is,required,this,path,separator,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,path,separator
AntPathMatcher -> public AntPathMatcher(String pathSeparator);1412083966;A convenience alternative constructor to use with a custom path separator._@param pathSeparator the path separator to use, must not be {@code null}._@since 4.1;public AntPathMatcher(String pathSeparator) {_		Assert.notNull(pathSeparator, "'pathSeparator' is required")__		this.pathSeparator = pathSeparator__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(pathSeparator)__	};a,convenience,alternative,constructor,to,use,with,a,custom,path,separator,param,path,separator,the,path,separator,to,use,must,not,be,code,null,since,4,1;public,ant,path,matcher,string,path,separator,assert,not,null,path,separator,path,separator,is,required,this,path,separator,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,path,separator
AntPathMatcher -> public AntPathMatcher(String pathSeparator);1412101078;A convenience alternative constructor to use with a custom path separator._@param pathSeparator the path separator to use, must not be {@code null}._@since 4.1;public AntPathMatcher(String pathSeparator) {_		Assert.notNull(pathSeparator, "'pathSeparator' is required")__		this.pathSeparator = pathSeparator__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(pathSeparator)__	};a,convenience,alternative,constructor,to,use,with,a,custom,path,separator,param,path,separator,the,path,separator,to,use,must,not,be,code,null,since,4,1;public,ant,path,matcher,string,path,separator,assert,not,null,path,separator,path,separator,is,required,this,path,separator,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,path,separator
AntPathMatcher -> public AntPathMatcher(String pathSeparator);1431086052;A convenient, alternative constructor to use with a custom path separator._@param pathSeparator the path separator to use, must not be {@code null}._@since 4.1;public AntPathMatcher(String pathSeparator) {_		Assert.notNull(pathSeparator, "'pathSeparator' is required")__		this.pathSeparator = pathSeparator__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(pathSeparator)__	};a,convenient,alternative,constructor,to,use,with,a,custom,path,separator,param,path,separator,the,path,separator,to,use,must,not,be,code,null,since,4,1;public,ant,path,matcher,string,path,separator,assert,not,null,path,separator,path,separator,is,required,this,path,separator,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,path,separator
AntPathMatcher -> public AntPathMatcher(String pathSeparator);1431178173;A convenient, alternative constructor to use with a custom path separator._@param pathSeparator the path separator to use, must not be {@code null}._@since 4.1;public AntPathMatcher(String pathSeparator) {_		Assert.notNull(pathSeparator, "'pathSeparator' is required")__		this.pathSeparator = pathSeparator__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(pathSeparator)__	};a,convenient,alternative,constructor,to,use,with,a,custom,path,separator,param,path,separator,the,path,separator,to,use,must,not,be,code,null,since,4,1;public,ant,path,matcher,string,path,separator,assert,not,null,path,separator,path,separator,is,required,this,path,separator,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,path,separator
AntPathMatcher -> public AntPathMatcher(String pathSeparator);1434572159;A convenient, alternative constructor to use with a custom path separator._@param pathSeparator the path separator to use, must not be {@code null}._@since 4.1;public AntPathMatcher(String pathSeparator) {_		Assert.notNull(pathSeparator, "'pathSeparator' is required")__		this.pathSeparator = pathSeparator__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(pathSeparator)__	};a,convenient,alternative,constructor,to,use,with,a,custom,path,separator,param,path,separator,the,path,separator,to,use,must,not,be,code,null,since,4,1;public,ant,path,matcher,string,path,separator,assert,not,null,path,separator,path,separator,is,required,this,path,separator,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,path,separator
AntPathMatcher -> public AntPathMatcher(String pathSeparator);1435239719;A convenient, alternative constructor to use with a custom path separator._@param pathSeparator the path separator to use, must not be {@code null}._@since 4.1;public AntPathMatcher(String pathSeparator) {_		Assert.notNull(pathSeparator, "'pathSeparator' is required")__		this.pathSeparator = pathSeparator__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(pathSeparator)__	};a,convenient,alternative,constructor,to,use,with,a,custom,path,separator,param,path,separator,the,path,separator,to,use,must,not,be,code,null,since,4,1;public,ant,path,matcher,string,path,separator,assert,not,null,path,separator,path,separator,is,required,this,path,separator,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,path,separator
AntPathMatcher -> public AntPathMatcher(String pathSeparator);1438166321;A convenient, alternative constructor to use with a custom path separator._@param pathSeparator the path separator to use, must not be {@code null}._@since 4.1;public AntPathMatcher(String pathSeparator) {_		Assert.notNull(pathSeparator, "'pathSeparator' is required")__		this.pathSeparator = pathSeparator__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(pathSeparator)__	};a,convenient,alternative,constructor,to,use,with,a,custom,path,separator,param,path,separator,the,path,separator,to,use,must,not,be,code,null,since,4,1;public,ant,path,matcher,string,path,separator,assert,not,null,path,separator,path,separator,is,required,this,path,separator,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,path,separator
AntPathMatcher -> public AntPathMatcher(String pathSeparator);1455100778;A convenient, alternative constructor to use with a custom path separator._@param pathSeparator the path separator to use, must not be {@code null}._@since 4.1;public AntPathMatcher(String pathSeparator) {_		Assert.notNull(pathSeparator, "'pathSeparator' is required")__		this.pathSeparator = pathSeparator__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(pathSeparator)__	};a,convenient,alternative,constructor,to,use,with,a,custom,path,separator,param,path,separator,the,path,separator,to,use,must,not,be,code,null,since,4,1;public,ant,path,matcher,string,path,separator,assert,not,null,path,separator,path,separator,is,required,this,path,separator,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,path,separator
AntPathMatcher -> public AntPathMatcher(String pathSeparator);1455850198;A convenient, alternative constructor to use with a custom path separator._@param pathSeparator the path separator to use, must not be {@code null}._@since 4.1;public AntPathMatcher(String pathSeparator) {_		Assert.notNull(pathSeparator, "'pathSeparator' is required")__		this.pathSeparator = pathSeparator__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(pathSeparator)__	};a,convenient,alternative,constructor,to,use,with,a,custom,path,separator,param,path,separator,the,path,separator,to,use,must,not,be,code,null,since,4,1;public,ant,path,matcher,string,path,separator,assert,not,null,path,separator,path,separator,is,required,this,path,separator,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,path,separator
AntPathMatcher -> public AntPathMatcher(String pathSeparator);1460754629;A convenient, alternative constructor to use with a custom path separator._@param pathSeparator the path separator to use, must not be {@code null}._@since 4.1;public AntPathMatcher(String pathSeparator) {_		Assert.notNull(pathSeparator, "'pathSeparator' is required")__		this.pathSeparator = pathSeparator__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(pathSeparator)__	};a,convenient,alternative,constructor,to,use,with,a,custom,path,separator,param,path,separator,the,path,separator,to,use,must,not,be,code,null,since,4,1;public,ant,path,matcher,string,path,separator,assert,not,null,path,separator,path,separator,is,required,this,path,separator,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,path,separator
AntPathMatcher -> public AntPathMatcher(String pathSeparator);1462393686;A convenient, alternative constructor to use with a custom path separator._@param pathSeparator the path separator to use, must not be {@code null}._@since 4.1;public AntPathMatcher(String pathSeparator) {_		Assert.notNull(pathSeparator, "'pathSeparator' is required")__		this.pathSeparator = pathSeparator__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(pathSeparator)__	};a,convenient,alternative,constructor,to,use,with,a,custom,path,separator,param,path,separator,the,path,separator,to,use,must,not,be,code,null,since,4,1;public,ant,path,matcher,string,path,separator,assert,not,null,path,separator,path,separator,is,required,this,path,separator,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,path,separator
AntPathMatcher -> public AntPathMatcher(String pathSeparator);1467730834;A convenient, alternative constructor to use with a custom path separator._@param pathSeparator the path separator to use, must not be {@code null}._@since 4.1;public AntPathMatcher(String pathSeparator) {_		Assert.notNull(pathSeparator, "'pathSeparator' is required")__		this.pathSeparator = pathSeparator__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(pathSeparator)__	};a,convenient,alternative,constructor,to,use,with,a,custom,path,separator,param,path,separator,the,path,separator,to,use,must,not,be,code,null,since,4,1;public,ant,path,matcher,string,path,separator,assert,not,null,path,separator,path,separator,is,required,this,path,separator,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,path,separator
AntPathMatcher -> public AntPathMatcher(String pathSeparator);1468327638;A convenient, alternative constructor to use with a custom path separator._@param pathSeparator the path separator to use, must not be {@code null}._@since 4.1;public AntPathMatcher(String pathSeparator) {_		Assert.notNull(pathSeparator, "'pathSeparator' is required")__		this.pathSeparator = pathSeparator__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(pathSeparator)__	};a,convenient,alternative,constructor,to,use,with,a,custom,path,separator,param,path,separator,the,path,separator,to,use,must,not,be,code,null,since,4,1;public,ant,path,matcher,string,path,separator,assert,not,null,path,separator,path,separator,is,required,this,path,separator,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,path,separator
AntPathMatcher -> public AntPathMatcher(String pathSeparator);1472808958;A convenient, alternative constructor to use with a custom path separator._@param pathSeparator the path separator to use, must not be {@code null}._@since 4.1;public AntPathMatcher(String pathSeparator) {_		Assert.notNull(pathSeparator, "'pathSeparator' is required")__		this.pathSeparator = pathSeparator__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(pathSeparator)__	};a,convenient,alternative,constructor,to,use,with,a,custom,path,separator,param,path,separator,the,path,separator,to,use,must,not,be,code,null,since,4,1;public,ant,path,matcher,string,path,separator,assert,not,null,path,separator,path,separator,is,required,this,path,separator,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,path,separator
AntPathMatcher -> public AntPathMatcher(String pathSeparator);1493317597;A convenient, alternative constructor to use with a custom path separator._@param pathSeparator the path separator to use, must not be {@code null}._@since 4.1;public AntPathMatcher(String pathSeparator) {_		Assert.notNull(pathSeparator, "'pathSeparator' is required")__		this.pathSeparator = pathSeparator__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(pathSeparator)__	};a,convenient,alternative,constructor,to,use,with,a,custom,path,separator,param,path,separator,the,path,separator,to,use,must,not,be,code,null,since,4,1;public,ant,path,matcher,string,path,separator,assert,not,null,path,separator,path,separator,is,required,this,path,separator,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,path,separator
AntPathMatcher -> public AntPathMatcher(String pathSeparator);1493321510;A convenient, alternative constructor to use with a custom path separator._@param pathSeparator the path separator to use, must not be {@code null}._@since 4.1;public AntPathMatcher(String pathSeparator) {_		Assert.notNull(pathSeparator, "'pathSeparator' is required")__		this.pathSeparator = pathSeparator__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(pathSeparator)__	};a,convenient,alternative,constructor,to,use,with,a,custom,path,separator,param,path,separator,the,path,separator,to,use,must,not,be,code,null,since,4,1;public,ant,path,matcher,string,path,separator,assert,not,null,path,separator,path,separator,is,required,this,path,separator,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,path,separator
AntPathMatcher -> public AntPathMatcher(String pathSeparator);1496259743;A convenient, alternative constructor to use with a custom path separator._@param pathSeparator the path separator to use, must not be {@code null}._@since 4.1;public AntPathMatcher(String pathSeparator) {_		Assert.notNull(pathSeparator, "'pathSeparator' is required")__		this.pathSeparator = pathSeparator__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(pathSeparator)__	};a,convenient,alternative,constructor,to,use,with,a,custom,path,separator,param,path,separator,the,path,separator,to,use,must,not,be,code,null,since,4,1;public,ant,path,matcher,string,path,separator,assert,not,null,path,separator,path,separator,is,required,this,path,separator,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,path,separator
AntPathMatcher -> public AntPathMatcher(String pathSeparator);1496837955;A convenient, alternative constructor to use with a custom path separator._@param pathSeparator the path separator to use, must not be {@code null}._@since 4.1;public AntPathMatcher(String pathSeparator) {_		Assert.notNull(pathSeparator, "'pathSeparator' is required")__		this.pathSeparator = pathSeparator__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(pathSeparator)__	};a,convenient,alternative,constructor,to,use,with,a,custom,path,separator,param,path,separator,the,path,separator,to,use,must,not,be,code,null,since,4,1;public,ant,path,matcher,string,path,separator,assert,not,null,path,separator,path,separator,is,required,this,path,separator,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,path,separator
AntPathMatcher -> public AntPathMatcher(String pathSeparator);1498780456;A convenient, alternative constructor to use with a custom path separator._@param pathSeparator the path separator to use, must not be {@code null}._@since 4.1;public AntPathMatcher(String pathSeparator) {_		Assert.notNull(pathSeparator, "'pathSeparator' is required")__		this.pathSeparator = pathSeparator__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(pathSeparator)__	};a,convenient,alternative,constructor,to,use,with,a,custom,path,separator,param,path,separator,the,path,separator,to,use,must,not,be,code,null,since,4,1;public,ant,path,matcher,string,path,separator,assert,not,null,path,separator,path,separator,is,required,this,path,separator,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,path,separator
AntPathMatcher -> public AntPathMatcher(String pathSeparator);1518772998;A convenient, alternative constructor to use with a custom path separator._@param pathSeparator the path separator to use, must not be {@code null}._@since 4.1;public AntPathMatcher(String pathSeparator) {_		Assert.notNull(pathSeparator, "'pathSeparator' is required")__		this.pathSeparator = pathSeparator__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(pathSeparator)__	};a,convenient,alternative,constructor,to,use,with,a,custom,path,separator,param,path,separator,the,path,separator,to,use,must,not,be,code,null,since,4,1;public,ant,path,matcher,string,path,separator,assert,not,null,path,separator,path,separator,is,required,this,path,separator,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,path,separator
AntPathMatcher -> public AntPathMatcher(String pathSeparator);1530174524;A convenient, alternative constructor to use with a custom path separator._@param pathSeparator the path separator to use, must not be {@code null}._@since 4.1;public AntPathMatcher(String pathSeparator) {_		Assert.notNull(pathSeparator, "'pathSeparator' is required")__		this.pathSeparator = pathSeparator__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(pathSeparator)__	};a,convenient,alternative,constructor,to,use,with,a,custom,path,separator,param,path,separator,the,path,separator,to,use,must,not,be,code,null,since,4,1;public,ant,path,matcher,string,path,separator,assert,not,null,path,separator,path,separator,is,required,this,path,separator,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,path,separator
AntPathMatcher -> public AntPathMatcher(String pathSeparator);1530174524;A convenient, alternative constructor to use with a custom path separator._@param pathSeparator the path separator to use, must not be {@code null}._@since 4.1;public AntPathMatcher(String pathSeparator) {_		Assert.notNull(pathSeparator, "'pathSeparator' is required")__		this.pathSeparator = pathSeparator__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(pathSeparator)__	};a,convenient,alternative,constructor,to,use,with,a,custom,path,separator,param,path,separator,the,path,separator,to,use,must,not,be,code,null,since,4,1;public,ant,path,matcher,string,path,separator,assert,not,null,path,separator,path,separator,is,required,this,path,separator,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,path,separator
AntPathMatcher -> public AntPathMatcher(String pathSeparator);1535316501;A convenient, alternative constructor to use with a custom path separator._@param pathSeparator the path separator to use, must not be {@code null}._@since 4.1;public AntPathMatcher(String pathSeparator) {_		Assert.notNull(pathSeparator, "'pathSeparator' is required")__		this.pathSeparator = pathSeparator__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(pathSeparator)__	};a,convenient,alternative,constructor,to,use,with,a,custom,path,separator,param,path,separator,the,path,separator,to,use,must,not,be,code,null,since,4,1;public,ant,path,matcher,string,path,separator,assert,not,null,path,separator,path,separator,is,required,this,path,separator,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,path,separator
AntPathMatcher -> public String combine(String pattern1, String pattern2);1328020251;Combines two patterns into a new pattern that is returned._<p>This implementation simply concatenates the two patterns, unless the first pattern_contains a file extension match (such as {@code *.html}. In that case, the second pattern_should be included in the first, or an {@code IllegalArgumentException} is thrown._<p>For example: <table>_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr> <tr><td>/hotels</td><td>{@code_null}</td><td>/hotels</td></tr> <tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr> <tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr> <tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>IllegalArgumentException</td></tr> </table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException when the two patterns cannot be combined;public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		else if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		else if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}_		else if (!pattern1.contains("{") && match(pattern1, pattern2)) {_			return pattern2__		}_		else if (pattern1.endsWith("/*")) {_			if (pattern2.startsWith("/")) {_				_				return pattern1.substring(0, pattern1.length() - 1) + pattern2.substring(1)__			}_			else {_				_				return pattern1.substring(0, pattern1.length() - 1) + pattern2__			}_		}_		else if (pattern1.endsWith("/**")) {_			if (pattern2.startsWith("/")) {_				_				return pattern1 + pattern2__			}_			else {_				_				return pattern1 + "/" + pattern2__			}_		}_		else {_			int dotPos1 = pattern1.indexOf('.')__			if (dotPos1 == -1) {_				_				if (pattern1.endsWith("/") || pattern2.startsWith("/")) {_					return pattern1 + pattern2__				}_				else {_					return pattern1 + "/" + pattern2__				}_			}_			String fileName1 = pattern1.substring(0, dotPos1)__			String extension1 = pattern1.substring(dotPos1)__			String fileName2__			String extension2__			int dotPos2 = pattern2.indexOf('.')__			if (dotPos2 != -1) {_				fileName2 = pattern2.substring(0, dotPos2)__				extension2 = pattern2.substring(dotPos2)__			}_			else {_				fileName2 = pattern2__				extension2 = ""__			}_			String fileName = fileName1.endsWith("*") ? fileName2 : fileName1__			String extension = extension1.startsWith("*") ? extension2 : extension1___			return fileName + extension__		}_	};combines,two,patterns,into,a,new,pattern,that,is,returned,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,such,as,code,html,in,that,case,the,second,pattern,should,be,included,in,the,first,or,an,code,illegal,argument,exception,is,thrown,p,for,example,table,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,when,the,two,patterns,cannot,be,combined;public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,else,if,string,utils,has,text,pattern1,return,pattern2,else,if,string,utils,has,text,pattern2,return,pattern1,else,if,pattern1,contains,match,pattern1,pattern2,return,pattern2,else,if,pattern1,ends,with,if,pattern2,starts,with,return,pattern1,substring,0,pattern1,length,1,pattern2,substring,1,else,return,pattern1,substring,0,pattern1,length,1,pattern2,else,if,pattern1,ends,with,if,pattern2,starts,with,return,pattern1,pattern2,else,return,pattern1,pattern2,else,int,dot,pos1,pattern1,index,of,if,dot,pos1,1,if,pattern1,ends,with,pattern2,starts,with,return,pattern1,pattern2,else,return,pattern1,pattern2,string,file,name1,pattern1,substring,0,dot,pos1,string,extension1,pattern1,substring,dot,pos1,string,file,name2,string,extension2,int,dot,pos2,pattern2,index,of,if,dot,pos2,1,file,name2,pattern2,substring,0,dot,pos2,extension2,pattern2,substring,dot,pos2,else,file,name2,pattern2,extension2,string,file,name,file,name1,ends,with,file,name2,file,name1,string,extension,extension1,starts,with,extension2,extension1,return,file,name,extension
AntPathMatcher -> public String combine(String pattern1, String pattern2);1333393580;Combines two patterns into a new pattern that is returned._<p>This implementation simply concatenates the two patterns, unless the first pattern_contains a file extension match (such as {@code *.html}. In that case, the second pattern_should be included in the first, or an {@code IllegalArgumentException} is thrown._<p>For example: <table>_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr> <tr><td>/hotels</td><td>{@code_null}</td><td>/hotels</td></tr> <tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr> <tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr> <tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>IllegalArgumentException</td></tr> </table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException when the two patterns cannot be combined;public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		else if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		else if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}_		else if (!pattern1.equals(pattern2) && !pattern1.contains("{") && match(pattern1, pattern2)) {_			_			_			return pattern2__		}_		else if (pattern1.endsWith("/*")) {_			if (pattern2.startsWith("/")) {_				_				return pattern1.substring(0, pattern1.length() - 1) + pattern2.substring(1)__			}_			else {_				_				return pattern1.substring(0, pattern1.length() - 1) + pattern2__			}_		}_		else if (pattern1.endsWith("/**")) {_			if (pattern2.startsWith("/")) {_				_				return pattern1 + pattern2__			}_			else {_				_				return pattern1 + "/" + pattern2__			}_		}_		else {_			int dotPos1 = pattern1.indexOf('.')__			if (dotPos1 == -1) {_				_				if (pattern1.endsWith("/") || pattern2.startsWith("/")) {_					return pattern1 + pattern2__				}_				else {_					return pattern1 + "/" + pattern2__				}_			}_			String fileName1 = pattern1.substring(0, dotPos1)__			String extension1 = pattern1.substring(dotPos1)__			String fileName2__			String extension2__			int dotPos2 = pattern2.indexOf('.')__			if (dotPos2 != -1) {_				fileName2 = pattern2.substring(0, dotPos2)__				extension2 = pattern2.substring(dotPos2)__			}_			else {_				fileName2 = pattern2__				extension2 = ""__			}_			String fileName = fileName1.endsWith("*") ? fileName2 : fileName1__			String extension = extension1.startsWith("*") ? extension2 : extension1___			return fileName + extension__		}_	};combines,two,patterns,into,a,new,pattern,that,is,returned,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,such,as,code,html,in,that,case,the,second,pattern,should,be,included,in,the,first,or,an,code,illegal,argument,exception,is,thrown,p,for,example,table,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,when,the,two,patterns,cannot,be,combined;public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,else,if,string,utils,has,text,pattern1,return,pattern2,else,if,string,utils,has,text,pattern2,return,pattern1,else,if,pattern1,equals,pattern2,pattern1,contains,match,pattern1,pattern2,return,pattern2,else,if,pattern1,ends,with,if,pattern2,starts,with,return,pattern1,substring,0,pattern1,length,1,pattern2,substring,1,else,return,pattern1,substring,0,pattern1,length,1,pattern2,else,if,pattern1,ends,with,if,pattern2,starts,with,return,pattern1,pattern2,else,return,pattern1,pattern2,else,int,dot,pos1,pattern1,index,of,if,dot,pos1,1,if,pattern1,ends,with,pattern2,starts,with,return,pattern1,pattern2,else,return,pattern1,pattern2,string,file,name1,pattern1,substring,0,dot,pos1,string,extension1,pattern1,substring,dot,pos1,string,file,name2,string,extension2,int,dot,pos2,pattern2,index,of,if,dot,pos2,1,file,name2,pattern2,substring,0,dot,pos2,extension2,pattern2,substring,dot,pos2,else,file,name2,pattern2,extension2,string,file,name,file,name1,ends,with,file,name2,file,name1,string,extension,extension1,starts,with,extension2,extension1,return,file,name,extension
AntPathMatcher -> public String combine(String pattern1, String pattern2);1347310630;Combines two patterns into a new pattern that is returned._<p>This implementation simply concatenates the two patterns, unless the first pattern_contains a file extension match (such as {@code *.html}. In that case, the second pattern_should be included in the first, or an {@code IllegalArgumentException} is thrown._<p>For example: <table>_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr> <tr><td>/hotels</td><td>{@code_null}</td><td>/hotels</td></tr> <tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr> <tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr> <tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>IllegalArgumentException</td></tr> </table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException when the two patterns cannot be combined;public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		else if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		else if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}_		else if (!pattern1.equals(pattern2) && !pattern1.contains("{") && match(pattern1, pattern2)) {_			_			_			return pattern2__		}_		else if (pattern1.endsWith("/*")) {_			if (pattern2.startsWith("/")) {_				_				return pattern1.substring(0, pattern1.length() - 1) + pattern2.substring(1)__			}_			else {_				_				return pattern1.substring(0, pattern1.length() - 1) + pattern2__			}_		}_		else if (pattern1.endsWith("/**")) {_			if (pattern2.startsWith("/")) {_				_				return pattern1 + pattern2__			}_			else {_				_				return pattern1 + "/" + pattern2__			}_		}_		else {_			int dotPos1 = pattern1.indexOf('.')__			if (dotPos1 == -1) {_				_				if (pattern1.endsWith("/") || pattern2.startsWith("/")) {_					return pattern1 + pattern2__				}_				else {_					return pattern1 + "/" + pattern2__				}_			}_			String fileName1 = pattern1.substring(0, dotPos1)__			String extension1 = pattern1.substring(dotPos1)__			String fileName2__			String extension2__			int dotPos2 = pattern2.indexOf('.')__			if (dotPos2 != -1) {_				fileName2 = pattern2.substring(0, dotPos2)__				extension2 = pattern2.substring(dotPos2)__			}_			else {_				fileName2 = pattern2__				extension2 = ""__			}_			String fileName = fileName1.endsWith("*") ? fileName2 : fileName1__			String extension = extension1.startsWith("*") ? extension2 : extension1___			return fileName + extension__		}_	};combines,two,patterns,into,a,new,pattern,that,is,returned,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,such,as,code,html,in,that,case,the,second,pattern,should,be,included,in,the,first,or,an,code,illegal,argument,exception,is,thrown,p,for,example,table,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,when,the,two,patterns,cannot,be,combined;public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,else,if,string,utils,has,text,pattern1,return,pattern2,else,if,string,utils,has,text,pattern2,return,pattern1,else,if,pattern1,equals,pattern2,pattern1,contains,match,pattern1,pattern2,return,pattern2,else,if,pattern1,ends,with,if,pattern2,starts,with,return,pattern1,substring,0,pattern1,length,1,pattern2,substring,1,else,return,pattern1,substring,0,pattern1,length,1,pattern2,else,if,pattern1,ends,with,if,pattern2,starts,with,return,pattern1,pattern2,else,return,pattern1,pattern2,else,int,dot,pos1,pattern1,index,of,if,dot,pos1,1,if,pattern1,ends,with,pattern2,starts,with,return,pattern1,pattern2,else,return,pattern1,pattern2,string,file,name1,pattern1,substring,0,dot,pos1,string,extension1,pattern1,substring,dot,pos1,string,file,name2,string,extension2,int,dot,pos2,pattern2,index,of,if,dot,pos2,1,file,name2,pattern2,substring,0,dot,pos2,extension2,pattern2,substring,dot,pos2,else,file,name2,pattern2,extension2,string,file,name,file,name1,ends,with,file,name2,file,name1,string,extension,extension1,starts,with,extension2,extension1,return,file,name,extension
AntPathMatcher -> public String combine(String pattern1, String pattern2);1355351965;Combines two patterns into a new pattern that is returned._<p>This implementation simply concatenates the two patterns, unless the first pattern_contains a file extension match (such as {@code *.html}. In that case, the second pattern_should be included in the first, or an {@code IllegalArgumentException} is thrown._<p>For example: <table>_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr> <tr><td>/hotels</td><td>{@code_null}</td><td>/hotels</td></tr> <tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr> <tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr> <tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>IllegalArgumentException</td></tr> </table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException when the two patterns cannot be combined;public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		else if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		else if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}_		else if (!pattern1.equals(pattern2) && !pattern1.contains("{") && match(pattern1, pattern2)) {_			_			_			return pattern2__		}_		else if (pattern1.endsWith("/*")) {_			if (pattern2.startsWith("/")) {_				_				return pattern1.substring(0, pattern1.length() - 1) + pattern2.substring(1)__			}_			else {_				_				return pattern1.substring(0, pattern1.length() - 1) + pattern2__			}_		}_		else if (pattern1.endsWith("/**")) {_			if (pattern2.startsWith("/")) {_				_				return pattern1 + pattern2__			}_			else {_				_				return pattern1 + "/" + pattern2__			}_		}_		else {_			int dotPos1 = pattern1.indexOf('.')__			if (dotPos1 == -1) {_				_				if (pattern1.endsWith("/") || pattern2.startsWith("/")) {_					return pattern1 + pattern2__				}_				else {_					return pattern1 + "/" + pattern2__				}_			}_			String fileName1 = pattern1.substring(0, dotPos1)__			String extension1 = pattern1.substring(dotPos1)__			String fileName2__			String extension2__			int dotPos2 = pattern2.indexOf('.')__			if (dotPos2 != -1) {_				fileName2 = pattern2.substring(0, dotPos2)__				extension2 = pattern2.substring(dotPos2)__			}_			else {_				fileName2 = pattern2__				extension2 = ""__			}_			String fileName = fileName1.endsWith("*") ? fileName2 : fileName1__			String extension = extension1.startsWith("*") ? extension2 : extension1___			return fileName + extension__		}_	};combines,two,patterns,into,a,new,pattern,that,is,returned,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,such,as,code,html,in,that,case,the,second,pattern,should,be,included,in,the,first,or,an,code,illegal,argument,exception,is,thrown,p,for,example,table,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,when,the,two,patterns,cannot,be,combined;public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,else,if,string,utils,has,text,pattern1,return,pattern2,else,if,string,utils,has,text,pattern2,return,pattern1,else,if,pattern1,equals,pattern2,pattern1,contains,match,pattern1,pattern2,return,pattern2,else,if,pattern1,ends,with,if,pattern2,starts,with,return,pattern1,substring,0,pattern1,length,1,pattern2,substring,1,else,return,pattern1,substring,0,pattern1,length,1,pattern2,else,if,pattern1,ends,with,if,pattern2,starts,with,return,pattern1,pattern2,else,return,pattern1,pattern2,else,int,dot,pos1,pattern1,index,of,if,dot,pos1,1,if,pattern1,ends,with,pattern2,starts,with,return,pattern1,pattern2,else,return,pattern1,pattern2,string,file,name1,pattern1,substring,0,dot,pos1,string,extension1,pattern1,substring,dot,pos1,string,file,name2,string,extension2,int,dot,pos2,pattern2,index,of,if,dot,pos2,1,file,name2,pattern2,substring,0,dot,pos2,extension2,pattern2,substring,dot,pos2,else,file,name2,pattern2,extension2,string,file,name,file,name1,ends,with,file,name2,file,name1,string,extension,extension1,starts,with,extension2,extension1,return,file,name,extension
AntPathMatcher -> public String combine(String pattern1, String pattern2);1357119239;Combines two patterns into a new pattern that is returned._<p>This implementation simply concatenates the two patterns, unless the first pattern_contains a file extension match (such as {@code *.html}. In that case, the second pattern_should be included in the first, or an {@code IllegalArgumentException} is thrown._<p>For example: <table>_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr> <tr><td>/hotels</td><td>{@code_null}</td><td>/hotels</td></tr> <tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr> <tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr> <tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>IllegalArgumentException</td></tr> </table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException when the two patterns cannot be combined;public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		else if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		else if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}_		else if (!pattern1.equals(pattern2) && !pattern1.contains("{") && match(pattern1, pattern2)) {_			_			_			return pattern2__		}_		else if (pattern1.endsWith("/*")) {_			if (pattern2.startsWith("/")) {_				_				return pattern1.substring(0, pattern1.length() - 1) + pattern2.substring(1)__			}_			else {_				_				return pattern1.substring(0, pattern1.length() - 1) + pattern2__			}_		}_		else if (pattern1.endsWith("/**")) {_			if (pattern2.startsWith("/")) {_				_				return pattern1 + pattern2__			}_			else {_				_				return pattern1 + "/" + pattern2__			}_		}_		else {_			int dotPos1 = pattern1.indexOf('.')__			if (dotPos1 == -1) {_				_				if (pattern1.endsWith("/") || pattern2.startsWith("/")) {_					return pattern1 + pattern2__				}_				else {_					return pattern1 + "/" + pattern2__				}_			}_			String fileName1 = pattern1.substring(0, dotPos1)__			String extension1 = pattern1.substring(dotPos1)__			String fileName2__			String extension2__			int dotPos2 = pattern2.indexOf('.')__			if (dotPos2 != -1) {_				fileName2 = pattern2.substring(0, dotPos2)__				extension2 = pattern2.substring(dotPos2)__			}_			else {_				fileName2 = pattern2__				extension2 = ""__			}_			String fileName = fileName1.endsWith("*") ? fileName2 : fileName1__			String extension = extension1.startsWith("*") ? extension2 : extension1___			return fileName + extension__		}_	};combines,two,patterns,into,a,new,pattern,that,is,returned,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,such,as,code,html,in,that,case,the,second,pattern,should,be,included,in,the,first,or,an,code,illegal,argument,exception,is,thrown,p,for,example,table,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,when,the,two,patterns,cannot,be,combined;public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,else,if,string,utils,has,text,pattern1,return,pattern2,else,if,string,utils,has,text,pattern2,return,pattern1,else,if,pattern1,equals,pattern2,pattern1,contains,match,pattern1,pattern2,return,pattern2,else,if,pattern1,ends,with,if,pattern2,starts,with,return,pattern1,substring,0,pattern1,length,1,pattern2,substring,1,else,return,pattern1,substring,0,pattern1,length,1,pattern2,else,if,pattern1,ends,with,if,pattern2,starts,with,return,pattern1,pattern2,else,return,pattern1,pattern2,else,int,dot,pos1,pattern1,index,of,if,dot,pos1,1,if,pattern1,ends,with,pattern2,starts,with,return,pattern1,pattern2,else,return,pattern1,pattern2,string,file,name1,pattern1,substring,0,dot,pos1,string,extension1,pattern1,substring,dot,pos1,string,file,name2,string,extension2,int,dot,pos2,pattern2,index,of,if,dot,pos2,1,file,name2,pattern2,substring,0,dot,pos2,extension2,pattern2,substring,dot,pos2,else,file,name2,pattern2,extension2,string,file,name,file,name1,ends,with,file,name2,file,name1,string,extension,extension1,starts,with,extension2,extension1,return,file,name,extension
AntPathMatcher -> public String combine(String pattern1, String pattern2);1362408075;Combines two patterns into a new pattern that is returned._<p>This implementation simply concatenates the two patterns, unless the first pattern_contains a file extension match (such as {@code *.html}. In that case, the second pattern_should be included in the first, or an {@code IllegalArgumentException} is thrown._<p>For example: <table>_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr> <tr><td>/hotels</td><td>{@code_null}</td><td>/hotels</td></tr> <tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr> <tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr> <tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>IllegalArgumentException</td></tr> </table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException when the two patterns cannot be combined;public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		else if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		else if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}__		boolean pattern1ContainsUriVar = pattern1.indexOf('{') != -1__		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {_			_			_			return pattern2__		}_		else if (pattern1.endsWith("/*")) {_			if (pattern2.startsWith("/")) {_				_				return pattern1.substring(0, pattern1.length() - 1) + pattern2.substring(1)__			}_			else {_				_				return pattern1.substring(0, pattern1.length() - 1) + pattern2__			}_		}_		else if (pattern1.endsWith("/**")) {_			if (pattern2.startsWith("/")) {_				_				return pattern1 + pattern2__			}_			else {_				_				return pattern1 + "/" + pattern2__			}_		}_		else {_			int dotPos1 = pattern1.indexOf('.')__			if (dotPos1 == -1 || pattern1ContainsUriVar) {_				_				if (pattern1.endsWith("/") || pattern2.startsWith("/")) {_					return pattern1 + pattern2__				}_				else {_					return pattern1 + "/" + pattern2__				}_			}_			String fileName1 = pattern1.substring(0, dotPos1)__			String extension1 = pattern1.substring(dotPos1)__			String fileName2__			String extension2__			int dotPos2 = pattern2.indexOf('.')__			if (dotPos2 != -1) {_				fileName2 = pattern2.substring(0, dotPos2)__				extension2 = pattern2.substring(dotPos2)__			}_			else {_				fileName2 = pattern2__				extension2 = ""__			}_			String fileName = fileName1.endsWith("*") ? fileName2 : fileName1__			String extension = extension1.startsWith("*") ? extension2 : extension1___			return fileName + extension__		}_	};combines,two,patterns,into,a,new,pattern,that,is,returned,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,such,as,code,html,in,that,case,the,second,pattern,should,be,included,in,the,first,or,an,code,illegal,argument,exception,is,thrown,p,for,example,table,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,when,the,two,patterns,cannot,be,combined;public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,else,if,string,utils,has,text,pattern1,return,pattern2,else,if,string,utils,has,text,pattern2,return,pattern1,boolean,pattern1contains,uri,var,pattern1,index,of,1,if,pattern1,equals,pattern2,pattern1contains,uri,var,match,pattern1,pattern2,return,pattern2,else,if,pattern1,ends,with,if,pattern2,starts,with,return,pattern1,substring,0,pattern1,length,1,pattern2,substring,1,else,return,pattern1,substring,0,pattern1,length,1,pattern2,else,if,pattern1,ends,with,if,pattern2,starts,with,return,pattern1,pattern2,else,return,pattern1,pattern2,else,int,dot,pos1,pattern1,index,of,if,dot,pos1,1,pattern1contains,uri,var,if,pattern1,ends,with,pattern2,starts,with,return,pattern1,pattern2,else,return,pattern1,pattern2,string,file,name1,pattern1,substring,0,dot,pos1,string,extension1,pattern1,substring,dot,pos1,string,file,name2,string,extension2,int,dot,pos2,pattern2,index,of,if,dot,pos2,1,file,name2,pattern2,substring,0,dot,pos2,extension2,pattern2,substring,dot,pos2,else,file,name2,pattern2,extension2,string,file,name,file,name1,ends,with,file,name2,file,name1,string,extension,extension1,starts,with,extension2,extension1,return,file,name,extension
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, @Nullable Map<String, String> uriTemplateVariables);1496837955;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, @Nullable Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					if (this.variableNames.size() != matcher.groupCount()) {_						throw new IllegalArgumentException("The number of capturing groups in the pattern segment " +_								this.pattern + " does not match the number of URI template variables it defines, " +_								"which can occur if capturing groups are used in a URI template regex. " +_								"Use non-capturing groups instead.")__					}_					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,nullable,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,if,this,variable,names,size,matcher,group,count,throw,new,illegal,argument,exception,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, @Nullable Map<String, String> uriTemplateVariables);1498780456;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, @Nullable Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					if (this.variableNames.size() != matcher.groupCount()) {_						throw new IllegalArgumentException("The number of capturing groups in the pattern segment " +_								this.pattern + " does not match the number of URI template variables it defines, " +_								"which can occur if capturing groups are used in a URI template regex. " +_								"Use non-capturing groups instead.")__					}_					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,nullable,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,if,this,variable,names,size,matcher,group,count,throw,new,illegal,argument,exception,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, @Nullable Map<String, String> uriTemplateVariables);1518772998;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, @Nullable Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					if (this.variableNames.size() != matcher.groupCount()) {_						throw new IllegalArgumentException("The number of capturing groups in the pattern segment " +_								this.pattern + " does not match the number of URI template variables it defines, " +_								"which can occur if capturing groups are used in a URI template regex. " +_								"Use non-capturing groups instead.")__					}_					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,nullable,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,if,this,variable,names,size,matcher,group,count,throw,new,illegal,argument,exception,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, @Nullable Map<String, String> uriTemplateVariables);1530174524;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, @Nullable Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					if (this.variableNames.size() != matcher.groupCount()) {_						throw new IllegalArgumentException("The number of capturing groups in the pattern segment " +_								this.pattern + " does not match the number of URI template variables it defines, " +_								"which can occur if capturing groups are used in a URI template regex. " +_								"Use non-capturing groups instead.")__					}_					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,nullable,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,if,this,variable,names,size,matcher,group,count,throw,new,illegal,argument,exception,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, @Nullable Map<String, String> uriTemplateVariables);1530174524;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, @Nullable Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					if (this.variableNames.size() != matcher.groupCount()) {_						throw new IllegalArgumentException("The number of capturing groups in the pattern segment " +_								this.pattern + " does not match the number of URI template variables it defines, " +_								"which can occur if capturing groups are used in a URI template regex. " +_								"Use non-capturing groups instead.")__					}_					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,nullable,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,if,this,variable,names,size,matcher,group,count,throw,new,illegal,argument,exception,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, @Nullable Map<String, String> uriTemplateVariables);1535316501;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, @Nullable Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					if (this.variableNames.size() != matcher.groupCount()) {_						throw new IllegalArgumentException("The number of capturing groups in the pattern segment " +_								this.pattern + " does not match the number of URI template variables it defines, " +_								"which can occur if capturing groups are used in a URI template regex. " +_								"Use non-capturing groups instead.")__					}_					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,nullable,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,if,this,variable,names,size,matcher,group,count,throw,new,illegal,argument,exception,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> protected String[] tokenizePattern(String pattern);1388766826;Tokenize the given path pattern into parts, based on this matcher's settings._<p>Performs caching based on {@link #setCachePatterns}, delegating to_{@link #tokenizePath(String)} for the actual tokenization algorithm._@param pattern the pattern to tokenize_@return the tokenized pattern parts;protected String[] tokenizePattern(String pattern) {_		String[] tokenized = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			tokenized = this.tokenizedPatternCache.get(pattern)__		}_		if (tokenized == null) {_			tokenized = tokenizePath(pattern)__			if (cachePatterns == null && this.tokenizedPatternCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return tokenized__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.tokenizedPatternCache.put(pattern, tokenized)__			}_		}_		return tokenized__	};tokenize,the,given,path,pattern,into,parts,based,on,this,matcher,s,settings,p,performs,caching,based,on,link,set,cache,patterns,delegating,to,link,tokenize,path,string,for,the,actual,tokenization,algorithm,param,pattern,the,pattern,to,tokenize,return,the,tokenized,pattern,parts;protected,string,tokenize,pattern,string,pattern,string,tokenized,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,tokenized,this,tokenized,pattern,cache,get,pattern,if,tokenized,null,tokenized,tokenize,path,pattern,if,cache,patterns,null,this,tokenized,pattern,cache,size,deactivate,pattern,cache,return,tokenized,if,cache,patterns,null,cache,patterns,boolean,value,this,tokenized,pattern,cache,put,pattern,tokenized,return,tokenized
AntPathMatcher -> protected String[] tokenizePattern(String pattern);1402512669;Tokenize the given path pattern into parts, based on this matcher's settings._<p>Performs caching based on {@link #setCachePatterns}, delegating to_{@link #tokenizePath(String)} for the actual tokenization algorithm._@param pattern the pattern to tokenize_@return the tokenized pattern parts;protected String[] tokenizePattern(String pattern) {_		String[] tokenized = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			tokenized = this.tokenizedPatternCache.get(pattern)__		}_		if (tokenized == null) {_			tokenized = tokenizePath(pattern)__			if (cachePatterns == null && this.tokenizedPatternCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return tokenized__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.tokenizedPatternCache.put(pattern, tokenized)__			}_		}_		return tokenized__	};tokenize,the,given,path,pattern,into,parts,based,on,this,matcher,s,settings,p,performs,caching,based,on,link,set,cache,patterns,delegating,to,link,tokenize,path,string,for,the,actual,tokenization,algorithm,param,pattern,the,pattern,to,tokenize,return,the,tokenized,pattern,parts;protected,string,tokenize,pattern,string,pattern,string,tokenized,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,tokenized,this,tokenized,pattern,cache,get,pattern,if,tokenized,null,tokenized,tokenize,path,pattern,if,cache,patterns,null,this,tokenized,pattern,cache,size,deactivate,pattern,cache,return,tokenized,if,cache,patterns,null,cache,patterns,boolean,value,this,tokenized,pattern,cache,put,pattern,tokenized,return,tokenized
AntPathMatcher -> protected String[] tokenizePattern(String pattern);1402512669;Tokenize the given path pattern into parts, based on this matcher's settings._<p>Performs caching based on {@link #setCachePatterns}, delegating to_{@link #tokenizePath(String)} for the actual tokenization algorithm._@param pattern the pattern to tokenize_@return the tokenized pattern parts;protected String[] tokenizePattern(String pattern) {_		String[] tokenized = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			tokenized = this.tokenizedPatternCache.get(pattern)__		}_		if (tokenized == null) {_			tokenized = tokenizePath(pattern)__			if (cachePatterns == null && this.tokenizedPatternCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return tokenized__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.tokenizedPatternCache.put(pattern, tokenized)__			}_		}_		return tokenized__	};tokenize,the,given,path,pattern,into,parts,based,on,this,matcher,s,settings,p,performs,caching,based,on,link,set,cache,patterns,delegating,to,link,tokenize,path,string,for,the,actual,tokenization,algorithm,param,pattern,the,pattern,to,tokenize,return,the,tokenized,pattern,parts;protected,string,tokenize,pattern,string,pattern,string,tokenized,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,tokenized,this,tokenized,pattern,cache,get,pattern,if,tokenized,null,tokenized,tokenize,path,pattern,if,cache,patterns,null,this,tokenized,pattern,cache,size,deactivate,pattern,cache,return,tokenized,if,cache,patterns,null,cache,patterns,boolean,value,this,tokenized,pattern,cache,put,pattern,tokenized,return,tokenized
AntPathMatcher -> protected String[] tokenizePattern(String pattern);1402512669;Tokenize the given path pattern into parts, based on this matcher's settings._<p>Performs caching based on {@link #setCachePatterns}, delegating to_{@link #tokenizePath(String)} for the actual tokenization algorithm._@param pattern the pattern to tokenize_@return the tokenized pattern parts;protected String[] tokenizePattern(String pattern) {_		String[] tokenized = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			tokenized = this.tokenizedPatternCache.get(pattern)__		}_		if (tokenized == null) {_			tokenized = tokenizePath(pattern)__			if (cachePatterns == null && this.tokenizedPatternCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return tokenized__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.tokenizedPatternCache.put(pattern, tokenized)__			}_		}_		return tokenized__	};tokenize,the,given,path,pattern,into,parts,based,on,this,matcher,s,settings,p,performs,caching,based,on,link,set,cache,patterns,delegating,to,link,tokenize,path,string,for,the,actual,tokenization,algorithm,param,pattern,the,pattern,to,tokenize,return,the,tokenized,pattern,parts;protected,string,tokenize,pattern,string,pattern,string,tokenized,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,tokenized,this,tokenized,pattern,cache,get,pattern,if,tokenized,null,tokenized,tokenize,path,pattern,if,cache,patterns,null,this,tokenized,pattern,cache,size,deactivate,pattern,cache,return,tokenized,if,cache,patterns,null,cache,patterns,boolean,value,this,tokenized,pattern,cache,put,pattern,tokenized,return,tokenized
AntPathMatcher -> protected String[] tokenizePattern(String pattern);1405378164;Tokenize the given path pattern into parts, based on this matcher's settings._<p>Performs caching based on {@link #setCachePatterns}, delegating to_{@link #tokenizePath(String)} for the actual tokenization algorithm._@param pattern the pattern to tokenize_@return the tokenized pattern parts;protected String[] tokenizePattern(String pattern) {_		String[] tokenized = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			tokenized = this.tokenizedPatternCache.get(pattern)__		}_		if (tokenized == null) {_			tokenized = tokenizePath(pattern)__			if (cachePatterns == null && this.tokenizedPatternCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return tokenized__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.tokenizedPatternCache.put(pattern, tokenized)__			}_		}_		return tokenized__	};tokenize,the,given,path,pattern,into,parts,based,on,this,matcher,s,settings,p,performs,caching,based,on,link,set,cache,patterns,delegating,to,link,tokenize,path,string,for,the,actual,tokenization,algorithm,param,pattern,the,pattern,to,tokenize,return,the,tokenized,pattern,parts;protected,string,tokenize,pattern,string,pattern,string,tokenized,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,tokenized,this,tokenized,pattern,cache,get,pattern,if,tokenized,null,tokenized,tokenize,path,pattern,if,cache,patterns,null,this,tokenized,pattern,cache,size,deactivate,pattern,cache,return,tokenized,if,cache,patterns,null,cache,patterns,boolean,value,this,tokenized,pattern,cache,put,pattern,tokenized,return,tokenized
AntPathMatcher -> protected String[] tokenizePattern(String pattern);1405378165;Tokenize the given path pattern into parts, based on this matcher's settings._<p>Performs caching based on {@link #setCachePatterns}, delegating to_{@link #tokenizePath(String)} for the actual tokenization algorithm._@param pattern the pattern to tokenize_@return the tokenized pattern parts;protected String[] tokenizePattern(String pattern) {_		String[] tokenized = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			tokenized = this.tokenizedPatternCache.get(pattern)__		}_		if (tokenized == null) {_			tokenized = tokenizePath(pattern)__			if (cachePatterns == null && this.tokenizedPatternCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return tokenized__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.tokenizedPatternCache.put(pattern, tokenized)__			}_		}_		return tokenized__	};tokenize,the,given,path,pattern,into,parts,based,on,this,matcher,s,settings,p,performs,caching,based,on,link,set,cache,patterns,delegating,to,link,tokenize,path,string,for,the,actual,tokenization,algorithm,param,pattern,the,pattern,to,tokenize,return,the,tokenized,pattern,parts;protected,string,tokenize,pattern,string,pattern,string,tokenized,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,tokenized,this,tokenized,pattern,cache,get,pattern,if,tokenized,null,tokenized,tokenize,path,pattern,if,cache,patterns,null,this,tokenized,pattern,cache,size,deactivate,pattern,cache,return,tokenized,if,cache,patterns,null,cache,patterns,boolean,value,this,tokenized,pattern,cache,put,pattern,tokenized,return,tokenized
AntPathMatcher -> protected String[] tokenizePattern(String pattern);1405696918;Tokenize the given path pattern into parts, based on this matcher's settings._<p>Performs caching based on {@link #setCachePatterns}, delegating to_{@link #tokenizePath(String)} for the actual tokenization algorithm._@param pattern the pattern to tokenize_@return the tokenized pattern parts;protected String[] tokenizePattern(String pattern) {_		String[] tokenized = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			tokenized = this.tokenizedPatternCache.get(pattern)__		}_		if (tokenized == null) {_			tokenized = tokenizePath(pattern)__			if (cachePatterns == null && this.tokenizedPatternCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return tokenized__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.tokenizedPatternCache.put(pattern, tokenized)__			}_		}_		return tokenized__	};tokenize,the,given,path,pattern,into,parts,based,on,this,matcher,s,settings,p,performs,caching,based,on,link,set,cache,patterns,delegating,to,link,tokenize,path,string,for,the,actual,tokenization,algorithm,param,pattern,the,pattern,to,tokenize,return,the,tokenized,pattern,parts;protected,string,tokenize,pattern,string,pattern,string,tokenized,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,tokenized,this,tokenized,pattern,cache,get,pattern,if,tokenized,null,tokenized,tokenize,path,pattern,if,cache,patterns,null,this,tokenized,pattern,cache,size,deactivate,pattern,cache,return,tokenized,if,cache,patterns,null,cache,patterns,boolean,value,this,tokenized,pattern,cache,put,pattern,tokenized,return,tokenized
AntPathMatcher -> protected String[] tokenizePattern(String pattern);1409784938;Tokenize the given path pattern into parts, based on this matcher's settings._<p>Performs caching based on {@link #setCachePatterns}, delegating to_{@link #tokenizePath(String)} for the actual tokenization algorithm._@param pattern the pattern to tokenize_@return the tokenized pattern parts;protected String[] tokenizePattern(String pattern) {_		String[] tokenized = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			tokenized = this.tokenizedPatternCache.get(pattern)__		}_		if (tokenized == null) {_			tokenized = tokenizePath(pattern)__			if (cachePatterns == null && this.tokenizedPatternCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return tokenized__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.tokenizedPatternCache.put(pattern, tokenized)__			}_		}_		return tokenized__	};tokenize,the,given,path,pattern,into,parts,based,on,this,matcher,s,settings,p,performs,caching,based,on,link,set,cache,patterns,delegating,to,link,tokenize,path,string,for,the,actual,tokenization,algorithm,param,pattern,the,pattern,to,tokenize,return,the,tokenized,pattern,parts;protected,string,tokenize,pattern,string,pattern,string,tokenized,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,tokenized,this,tokenized,pattern,cache,get,pattern,if,tokenized,null,tokenized,tokenize,path,pattern,if,cache,patterns,null,this,tokenized,pattern,cache,size,deactivate,pattern,cache,return,tokenized,if,cache,patterns,null,cache,patterns,boolean,value,this,tokenized,pattern,cache,put,pattern,tokenized,return,tokenized
AntPathMatcher -> protected String[] tokenizePattern(String pattern);1412083966;Tokenize the given path pattern into parts, based on this matcher's settings._<p>Performs caching based on {@link #setCachePatterns}, delegating to_{@link #tokenizePath(String)} for the actual tokenization algorithm._@param pattern the pattern to tokenize_@return the tokenized pattern parts;protected String[] tokenizePattern(String pattern) {_		String[] tokenized = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			tokenized = this.tokenizedPatternCache.get(pattern)__		}_		if (tokenized == null) {_			tokenized = tokenizePath(pattern)__			if (cachePatterns == null && this.tokenizedPatternCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return tokenized__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.tokenizedPatternCache.put(pattern, tokenized)__			}_		}_		return tokenized__	};tokenize,the,given,path,pattern,into,parts,based,on,this,matcher,s,settings,p,performs,caching,based,on,link,set,cache,patterns,delegating,to,link,tokenize,path,string,for,the,actual,tokenization,algorithm,param,pattern,the,pattern,to,tokenize,return,the,tokenized,pattern,parts;protected,string,tokenize,pattern,string,pattern,string,tokenized,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,tokenized,this,tokenized,pattern,cache,get,pattern,if,tokenized,null,tokenized,tokenize,path,pattern,if,cache,patterns,null,this,tokenized,pattern,cache,size,deactivate,pattern,cache,return,tokenized,if,cache,patterns,null,cache,patterns,boolean,value,this,tokenized,pattern,cache,put,pattern,tokenized,return,tokenized
AntPathMatcher -> protected String[] tokenizePattern(String pattern);1412101078;Tokenize the given path pattern into parts, based on this matcher's settings._<p>Performs caching based on {@link #setCachePatterns}, delegating to_{@link #tokenizePath(String)} for the actual tokenization algorithm._@param pattern the pattern to tokenize_@return the tokenized pattern parts;protected String[] tokenizePattern(String pattern) {_		String[] tokenized = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			tokenized = this.tokenizedPatternCache.get(pattern)__		}_		if (tokenized == null) {_			tokenized = tokenizePath(pattern)__			if (cachePatterns == null && this.tokenizedPatternCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return tokenized__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.tokenizedPatternCache.put(pattern, tokenized)__			}_		}_		return tokenized__	};tokenize,the,given,path,pattern,into,parts,based,on,this,matcher,s,settings,p,performs,caching,based,on,link,set,cache,patterns,delegating,to,link,tokenize,path,string,for,the,actual,tokenization,algorithm,param,pattern,the,pattern,to,tokenize,return,the,tokenized,pattern,parts;protected,string,tokenize,pattern,string,pattern,string,tokenized,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,tokenized,this,tokenized,pattern,cache,get,pattern,if,tokenized,null,tokenized,tokenize,path,pattern,if,cache,patterns,null,this,tokenized,pattern,cache,size,deactivate,pattern,cache,return,tokenized,if,cache,patterns,null,cache,patterns,boolean,value,this,tokenized,pattern,cache,put,pattern,tokenized,return,tokenized
AntPathMatcher -> protected String[] tokenizePattern(String pattern);1431086052;Tokenize the given path pattern into parts, based on this matcher's settings._<p>Performs caching based on {@link #setCachePatterns}, delegating to_{@link #tokenizePath(String)} for the actual tokenization algorithm._@param pattern the pattern to tokenize_@return the tokenized pattern parts;protected String[] tokenizePattern(String pattern) {_		String[] tokenized = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			tokenized = this.tokenizedPatternCache.get(pattern)__		}_		if (tokenized == null) {_			tokenized = tokenizePath(pattern)__			if (cachePatterns == null && this.tokenizedPatternCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return tokenized__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.tokenizedPatternCache.put(pattern, tokenized)__			}_		}_		return tokenized__	};tokenize,the,given,path,pattern,into,parts,based,on,this,matcher,s,settings,p,performs,caching,based,on,link,set,cache,patterns,delegating,to,link,tokenize,path,string,for,the,actual,tokenization,algorithm,param,pattern,the,pattern,to,tokenize,return,the,tokenized,pattern,parts;protected,string,tokenize,pattern,string,pattern,string,tokenized,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,tokenized,this,tokenized,pattern,cache,get,pattern,if,tokenized,null,tokenized,tokenize,path,pattern,if,cache,patterns,null,this,tokenized,pattern,cache,size,deactivate,pattern,cache,return,tokenized,if,cache,patterns,null,cache,patterns,boolean,value,this,tokenized,pattern,cache,put,pattern,tokenized,return,tokenized
AntPathMatcher -> protected String[] tokenizePattern(String pattern);1431178173;Tokenize the given path pattern into parts, based on this matcher's settings._<p>Performs caching based on {@link #setCachePatterns}, delegating to_{@link #tokenizePath(String)} for the actual tokenization algorithm._@param pattern the pattern to tokenize_@return the tokenized pattern parts;protected String[] tokenizePattern(String pattern) {_		String[] tokenized = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			tokenized = this.tokenizedPatternCache.get(pattern)__		}_		if (tokenized == null) {_			tokenized = tokenizePath(pattern)__			if (cachePatterns == null && this.tokenizedPatternCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return tokenized__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.tokenizedPatternCache.put(pattern, tokenized)__			}_		}_		return tokenized__	};tokenize,the,given,path,pattern,into,parts,based,on,this,matcher,s,settings,p,performs,caching,based,on,link,set,cache,patterns,delegating,to,link,tokenize,path,string,for,the,actual,tokenization,algorithm,param,pattern,the,pattern,to,tokenize,return,the,tokenized,pattern,parts;protected,string,tokenize,pattern,string,pattern,string,tokenized,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,tokenized,this,tokenized,pattern,cache,get,pattern,if,tokenized,null,tokenized,tokenize,path,pattern,if,cache,patterns,null,this,tokenized,pattern,cache,size,deactivate,pattern,cache,return,tokenized,if,cache,patterns,null,cache,patterns,boolean,value,this,tokenized,pattern,cache,put,pattern,tokenized,return,tokenized
AntPathMatcher -> protected String[] tokenizePattern(String pattern);1434572159;Tokenize the given path pattern into parts, based on this matcher's settings._<p>Performs caching based on {@link #setCachePatterns}, delegating to_{@link #tokenizePath(String)} for the actual tokenization algorithm._@param pattern the pattern to tokenize_@return the tokenized pattern parts;protected String[] tokenizePattern(String pattern) {_		String[] tokenized = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			tokenized = this.tokenizedPatternCache.get(pattern)__		}_		if (tokenized == null) {_			tokenized = tokenizePath(pattern)__			if (cachePatterns == null && this.tokenizedPatternCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return tokenized__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.tokenizedPatternCache.put(pattern, tokenized)__			}_		}_		return tokenized__	};tokenize,the,given,path,pattern,into,parts,based,on,this,matcher,s,settings,p,performs,caching,based,on,link,set,cache,patterns,delegating,to,link,tokenize,path,string,for,the,actual,tokenization,algorithm,param,pattern,the,pattern,to,tokenize,return,the,tokenized,pattern,parts;protected,string,tokenize,pattern,string,pattern,string,tokenized,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,tokenized,this,tokenized,pattern,cache,get,pattern,if,tokenized,null,tokenized,tokenize,path,pattern,if,cache,patterns,null,this,tokenized,pattern,cache,size,deactivate,pattern,cache,return,tokenized,if,cache,patterns,null,cache,patterns,boolean,value,this,tokenized,pattern,cache,put,pattern,tokenized,return,tokenized
AntPathMatcher -> protected String[] tokenizePattern(String pattern);1435239719;Tokenize the given path pattern into parts, based on this matcher's settings._<p>Performs caching based on {@link #setCachePatterns}, delegating to_{@link #tokenizePath(String)} for the actual tokenization algorithm._@param pattern the pattern to tokenize_@return the tokenized pattern parts;protected String[] tokenizePattern(String pattern) {_		String[] tokenized = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			tokenized = this.tokenizedPatternCache.get(pattern)__		}_		if (tokenized == null) {_			tokenized = tokenizePath(pattern)__			if (cachePatterns == null && this.tokenizedPatternCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return tokenized__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.tokenizedPatternCache.put(pattern, tokenized)__			}_		}_		return tokenized__	};tokenize,the,given,path,pattern,into,parts,based,on,this,matcher,s,settings,p,performs,caching,based,on,link,set,cache,patterns,delegating,to,link,tokenize,path,string,for,the,actual,tokenization,algorithm,param,pattern,the,pattern,to,tokenize,return,the,tokenized,pattern,parts;protected,string,tokenize,pattern,string,pattern,string,tokenized,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,tokenized,this,tokenized,pattern,cache,get,pattern,if,tokenized,null,tokenized,tokenize,path,pattern,if,cache,patterns,null,this,tokenized,pattern,cache,size,deactivate,pattern,cache,return,tokenized,if,cache,patterns,null,cache,patterns,boolean,value,this,tokenized,pattern,cache,put,pattern,tokenized,return,tokenized
AntPathMatcher -> protected String[] tokenizePattern(String pattern);1438166321;Tokenize the given path pattern into parts, based on this matcher's settings._<p>Performs caching based on {@link #setCachePatterns}, delegating to_{@link #tokenizePath(String)} for the actual tokenization algorithm._@param pattern the pattern to tokenize_@return the tokenized pattern parts;protected String[] tokenizePattern(String pattern) {_		String[] tokenized = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			tokenized = this.tokenizedPatternCache.get(pattern)__		}_		if (tokenized == null) {_			tokenized = tokenizePath(pattern)__			if (cachePatterns == null && this.tokenizedPatternCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return tokenized__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.tokenizedPatternCache.put(pattern, tokenized)__			}_		}_		return tokenized__	};tokenize,the,given,path,pattern,into,parts,based,on,this,matcher,s,settings,p,performs,caching,based,on,link,set,cache,patterns,delegating,to,link,tokenize,path,string,for,the,actual,tokenization,algorithm,param,pattern,the,pattern,to,tokenize,return,the,tokenized,pattern,parts;protected,string,tokenize,pattern,string,pattern,string,tokenized,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,tokenized,this,tokenized,pattern,cache,get,pattern,if,tokenized,null,tokenized,tokenize,path,pattern,if,cache,patterns,null,this,tokenized,pattern,cache,size,deactivate,pattern,cache,return,tokenized,if,cache,patterns,null,cache,patterns,boolean,value,this,tokenized,pattern,cache,put,pattern,tokenized,return,tokenized
AntPathMatcher -> protected String[] tokenizePattern(String pattern);1455850198;Tokenize the given path pattern into parts, based on this matcher's settings._<p>Performs caching based on {@link #setCachePatterns}, delegating to_{@link #tokenizePath(String)} for the actual tokenization algorithm._@param pattern the pattern to tokenize_@return the tokenized pattern parts;protected String[] tokenizePattern(String pattern) {_		String[] tokenized = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			tokenized = this.tokenizedPatternCache.get(pattern)__		}_		if (tokenized == null) {_			tokenized = tokenizePath(pattern)__			if (cachePatterns == null && this.tokenizedPatternCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return tokenized__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.tokenizedPatternCache.put(pattern, tokenized)__			}_		}_		return tokenized__	};tokenize,the,given,path,pattern,into,parts,based,on,this,matcher,s,settings,p,performs,caching,based,on,link,set,cache,patterns,delegating,to,link,tokenize,path,string,for,the,actual,tokenization,algorithm,param,pattern,the,pattern,to,tokenize,return,the,tokenized,pattern,parts;protected,string,tokenize,pattern,string,pattern,string,tokenized,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,tokenized,this,tokenized,pattern,cache,get,pattern,if,tokenized,null,tokenized,tokenize,path,pattern,if,cache,patterns,null,this,tokenized,pattern,cache,size,deactivate,pattern,cache,return,tokenized,if,cache,patterns,null,cache,patterns,boolean,value,this,tokenized,pattern,cache,put,pattern,tokenized,return,tokenized
AntPathMatcher -> protected String[] tokenizePattern(String pattern);1460754629;Tokenize the given path pattern into parts, based on this matcher's settings._<p>Performs caching based on {@link #setCachePatterns}, delegating to_{@link #tokenizePath(String)} for the actual tokenization algorithm._@param pattern the pattern to tokenize_@return the tokenized pattern parts;protected String[] tokenizePattern(String pattern) {_		String[] tokenized = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			tokenized = this.tokenizedPatternCache.get(pattern)__		}_		if (tokenized == null) {_			tokenized = tokenizePath(pattern)__			if (cachePatterns == null && this.tokenizedPatternCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return tokenized__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.tokenizedPatternCache.put(pattern, tokenized)__			}_		}_		return tokenized__	};tokenize,the,given,path,pattern,into,parts,based,on,this,matcher,s,settings,p,performs,caching,based,on,link,set,cache,patterns,delegating,to,link,tokenize,path,string,for,the,actual,tokenization,algorithm,param,pattern,the,pattern,to,tokenize,return,the,tokenized,pattern,parts;protected,string,tokenize,pattern,string,pattern,string,tokenized,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,tokenized,this,tokenized,pattern,cache,get,pattern,if,tokenized,null,tokenized,tokenize,path,pattern,if,cache,patterns,null,this,tokenized,pattern,cache,size,deactivate,pattern,cache,return,tokenized,if,cache,patterns,null,cache,patterns,boolean,value,this,tokenized,pattern,cache,put,pattern,tokenized,return,tokenized
AntPathMatcher -> protected String[] tokenizePattern(String pattern);1462393686;Tokenize the given path pattern into parts, based on this matcher's settings._<p>Performs caching based on {@link #setCachePatterns}, delegating to_{@link #tokenizePath(String)} for the actual tokenization algorithm._@param pattern the pattern to tokenize_@return the tokenized pattern parts;protected String[] tokenizePattern(String pattern) {_		String[] tokenized = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			tokenized = this.tokenizedPatternCache.get(pattern)__		}_		if (tokenized == null) {_			tokenized = tokenizePath(pattern)__			if (cachePatterns == null && this.tokenizedPatternCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return tokenized__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.tokenizedPatternCache.put(pattern, tokenized)__			}_		}_		return tokenized__	};tokenize,the,given,path,pattern,into,parts,based,on,this,matcher,s,settings,p,performs,caching,based,on,link,set,cache,patterns,delegating,to,link,tokenize,path,string,for,the,actual,tokenization,algorithm,param,pattern,the,pattern,to,tokenize,return,the,tokenized,pattern,parts;protected,string,tokenize,pattern,string,pattern,string,tokenized,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,tokenized,this,tokenized,pattern,cache,get,pattern,if,tokenized,null,tokenized,tokenize,path,pattern,if,cache,patterns,null,this,tokenized,pattern,cache,size,deactivate,pattern,cache,return,tokenized,if,cache,patterns,null,cache,patterns,boolean,value,this,tokenized,pattern,cache,put,pattern,tokenized,return,tokenized
AntPathMatcher -> protected String[] tokenizePattern(String pattern);1467730834;Tokenize the given path pattern into parts, based on this matcher's settings._<p>Performs caching based on {@link #setCachePatterns}, delegating to_{@link #tokenizePath(String)} for the actual tokenization algorithm._@param pattern the pattern to tokenize_@return the tokenized pattern parts;protected String[] tokenizePattern(String pattern) {_		String[] tokenized = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			tokenized = this.tokenizedPatternCache.get(pattern)__		}_		if (tokenized == null) {_			tokenized = tokenizePath(pattern)__			if (cachePatterns == null && this.tokenizedPatternCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return tokenized__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.tokenizedPatternCache.put(pattern, tokenized)__			}_		}_		return tokenized__	};tokenize,the,given,path,pattern,into,parts,based,on,this,matcher,s,settings,p,performs,caching,based,on,link,set,cache,patterns,delegating,to,link,tokenize,path,string,for,the,actual,tokenization,algorithm,param,pattern,the,pattern,to,tokenize,return,the,tokenized,pattern,parts;protected,string,tokenize,pattern,string,pattern,string,tokenized,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,tokenized,this,tokenized,pattern,cache,get,pattern,if,tokenized,null,tokenized,tokenize,path,pattern,if,cache,patterns,null,this,tokenized,pattern,cache,size,deactivate,pattern,cache,return,tokenized,if,cache,patterns,null,cache,patterns,boolean,value,this,tokenized,pattern,cache,put,pattern,tokenized,return,tokenized
AntPathMatcher -> protected String[] tokenizePattern(String pattern);1468327638;Tokenize the given path pattern into parts, based on this matcher's settings._<p>Performs caching based on {@link #setCachePatterns}, delegating to_{@link #tokenizePath(String)} for the actual tokenization algorithm._@param pattern the pattern to tokenize_@return the tokenized pattern parts;protected String[] tokenizePattern(String pattern) {_		String[] tokenized = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			tokenized = this.tokenizedPatternCache.get(pattern)__		}_		if (tokenized == null) {_			tokenized = tokenizePath(pattern)__			if (cachePatterns == null && this.tokenizedPatternCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return tokenized__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.tokenizedPatternCache.put(pattern, tokenized)__			}_		}_		return tokenized__	};tokenize,the,given,path,pattern,into,parts,based,on,this,matcher,s,settings,p,performs,caching,based,on,link,set,cache,patterns,delegating,to,link,tokenize,path,string,for,the,actual,tokenization,algorithm,param,pattern,the,pattern,to,tokenize,return,the,tokenized,pattern,parts;protected,string,tokenize,pattern,string,pattern,string,tokenized,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,tokenized,this,tokenized,pattern,cache,get,pattern,if,tokenized,null,tokenized,tokenize,path,pattern,if,cache,patterns,null,this,tokenized,pattern,cache,size,deactivate,pattern,cache,return,tokenized,if,cache,patterns,null,cache,patterns,boolean,value,this,tokenized,pattern,cache,put,pattern,tokenized,return,tokenized
AntPathMatcher -> protected String[] tokenizePattern(String pattern);1472808958;Tokenize the given path pattern into parts, based on this matcher's settings._<p>Performs caching based on {@link #setCachePatterns}, delegating to_{@link #tokenizePath(String)} for the actual tokenization algorithm._@param pattern the pattern to tokenize_@return the tokenized pattern parts;protected String[] tokenizePattern(String pattern) {_		String[] tokenized = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			tokenized = this.tokenizedPatternCache.get(pattern)__		}_		if (tokenized == null) {_			tokenized = tokenizePath(pattern)__			if (cachePatterns == null && this.tokenizedPatternCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return tokenized__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.tokenizedPatternCache.put(pattern, tokenized)__			}_		}_		return tokenized__	};tokenize,the,given,path,pattern,into,parts,based,on,this,matcher,s,settings,p,performs,caching,based,on,link,set,cache,patterns,delegating,to,link,tokenize,path,string,for,the,actual,tokenization,algorithm,param,pattern,the,pattern,to,tokenize,return,the,tokenized,pattern,parts;protected,string,tokenize,pattern,string,pattern,string,tokenized,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,tokenized,this,tokenized,pattern,cache,get,pattern,if,tokenized,null,tokenized,tokenize,path,pattern,if,cache,patterns,null,this,tokenized,pattern,cache,size,deactivate,pattern,cache,return,tokenized,if,cache,patterns,null,cache,patterns,boolean,value,this,tokenized,pattern,cache,put,pattern,tokenized,return,tokenized
AntPathMatcher -> protected String[] tokenizePattern(String pattern);1493317597;Tokenize the given path pattern into parts, based on this matcher's settings._<p>Performs caching based on {@link #setCachePatterns}, delegating to_{@link #tokenizePath(String)} for the actual tokenization algorithm._@param pattern the pattern to tokenize_@return the tokenized pattern parts;protected String[] tokenizePattern(String pattern) {_		String[] tokenized = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			tokenized = this.tokenizedPatternCache.get(pattern)__		}_		if (tokenized == null) {_			tokenized = tokenizePath(pattern)__			if (cachePatterns == null && this.tokenizedPatternCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return tokenized__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.tokenizedPatternCache.put(pattern, tokenized)__			}_		}_		return tokenized__	};tokenize,the,given,path,pattern,into,parts,based,on,this,matcher,s,settings,p,performs,caching,based,on,link,set,cache,patterns,delegating,to,link,tokenize,path,string,for,the,actual,tokenization,algorithm,param,pattern,the,pattern,to,tokenize,return,the,tokenized,pattern,parts;protected,string,tokenize,pattern,string,pattern,string,tokenized,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,tokenized,this,tokenized,pattern,cache,get,pattern,if,tokenized,null,tokenized,tokenize,path,pattern,if,cache,patterns,null,this,tokenized,pattern,cache,size,deactivate,pattern,cache,return,tokenized,if,cache,patterns,null,cache,patterns,boolean,value,this,tokenized,pattern,cache,put,pattern,tokenized,return,tokenized
AntPathMatcher -> protected String[] tokenizePattern(String pattern);1493321510;Tokenize the given path pattern into parts, based on this matcher's settings._<p>Performs caching based on {@link #setCachePatterns}, delegating to_{@link #tokenizePath(String)} for the actual tokenization algorithm._@param pattern the pattern to tokenize_@return the tokenized pattern parts;protected String[] tokenizePattern(String pattern) {_		String[] tokenized = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			tokenized = this.tokenizedPatternCache.get(pattern)__		}_		if (tokenized == null) {_			tokenized = tokenizePath(pattern)__			if (cachePatterns == null && this.tokenizedPatternCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return tokenized__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.tokenizedPatternCache.put(pattern, tokenized)__			}_		}_		return tokenized__	};tokenize,the,given,path,pattern,into,parts,based,on,this,matcher,s,settings,p,performs,caching,based,on,link,set,cache,patterns,delegating,to,link,tokenize,path,string,for,the,actual,tokenization,algorithm,param,pattern,the,pattern,to,tokenize,return,the,tokenized,pattern,parts;protected,string,tokenize,pattern,string,pattern,string,tokenized,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,tokenized,this,tokenized,pattern,cache,get,pattern,if,tokenized,null,tokenized,tokenize,path,pattern,if,cache,patterns,null,this,tokenized,pattern,cache,size,deactivate,pattern,cache,return,tokenized,if,cache,patterns,null,cache,patterns,boolean,value,this,tokenized,pattern,cache,put,pattern,tokenized,return,tokenized
AntPathMatcher -> protected String[] tokenizePattern(String pattern);1496259743;Tokenize the given path pattern into parts, based on this matcher's settings._<p>Performs caching based on {@link #setCachePatterns}, delegating to_{@link #tokenizePath(String)} for the actual tokenization algorithm._@param pattern the pattern to tokenize_@return the tokenized pattern parts;protected String[] tokenizePattern(String pattern) {_		String[] tokenized = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			tokenized = this.tokenizedPatternCache.get(pattern)__		}_		if (tokenized == null) {_			tokenized = tokenizePath(pattern)__			if (cachePatterns == null && this.tokenizedPatternCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return tokenized__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.tokenizedPatternCache.put(pattern, tokenized)__			}_		}_		return tokenized__	};tokenize,the,given,path,pattern,into,parts,based,on,this,matcher,s,settings,p,performs,caching,based,on,link,set,cache,patterns,delegating,to,link,tokenize,path,string,for,the,actual,tokenization,algorithm,param,pattern,the,pattern,to,tokenize,return,the,tokenized,pattern,parts;protected,string,tokenize,pattern,string,pattern,string,tokenized,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,tokenized,this,tokenized,pattern,cache,get,pattern,if,tokenized,null,tokenized,tokenize,path,pattern,if,cache,patterns,null,this,tokenized,pattern,cache,size,deactivate,pattern,cache,return,tokenized,if,cache,patterns,null,cache,patterns,boolean,value,this,tokenized,pattern,cache,put,pattern,tokenized,return,tokenized
AntPathMatcher -> protected String[] tokenizePattern(String pattern);1496837955;Tokenize the given path pattern into parts, based on this matcher's settings._<p>Performs caching based on {@link #setCachePatterns}, delegating to_{@link #tokenizePath(String)} for the actual tokenization algorithm._@param pattern the pattern to tokenize_@return the tokenized pattern parts;protected String[] tokenizePattern(String pattern) {_		String[] tokenized = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			tokenized = this.tokenizedPatternCache.get(pattern)__		}_		if (tokenized == null) {_			tokenized = tokenizePath(pattern)__			if (cachePatterns == null && this.tokenizedPatternCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return tokenized__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.tokenizedPatternCache.put(pattern, tokenized)__			}_		}_		return tokenized__	};tokenize,the,given,path,pattern,into,parts,based,on,this,matcher,s,settings,p,performs,caching,based,on,link,set,cache,patterns,delegating,to,link,tokenize,path,string,for,the,actual,tokenization,algorithm,param,pattern,the,pattern,to,tokenize,return,the,tokenized,pattern,parts;protected,string,tokenize,pattern,string,pattern,string,tokenized,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,tokenized,this,tokenized,pattern,cache,get,pattern,if,tokenized,null,tokenized,tokenize,path,pattern,if,cache,patterns,null,this,tokenized,pattern,cache,size,deactivate,pattern,cache,return,tokenized,if,cache,patterns,null,cache,patterns,boolean,value,this,tokenized,pattern,cache,put,pattern,tokenized,return,tokenized
AntPathMatcher -> protected String[] tokenizePattern(String pattern);1498780456;Tokenize the given path pattern into parts, based on this matcher's settings._<p>Performs caching based on {@link #setCachePatterns}, delegating to_{@link #tokenizePath(String)} for the actual tokenization algorithm._@param pattern the pattern to tokenize_@return the tokenized pattern parts;protected String[] tokenizePattern(String pattern) {_		String[] tokenized = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			tokenized = this.tokenizedPatternCache.get(pattern)__		}_		if (tokenized == null) {_			tokenized = tokenizePath(pattern)__			if (cachePatterns == null && this.tokenizedPatternCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return tokenized__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.tokenizedPatternCache.put(pattern, tokenized)__			}_		}_		return tokenized__	};tokenize,the,given,path,pattern,into,parts,based,on,this,matcher,s,settings,p,performs,caching,based,on,link,set,cache,patterns,delegating,to,link,tokenize,path,string,for,the,actual,tokenization,algorithm,param,pattern,the,pattern,to,tokenize,return,the,tokenized,pattern,parts;protected,string,tokenize,pattern,string,pattern,string,tokenized,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,tokenized,this,tokenized,pattern,cache,get,pattern,if,tokenized,null,tokenized,tokenize,path,pattern,if,cache,patterns,null,this,tokenized,pattern,cache,size,deactivate,pattern,cache,return,tokenized,if,cache,patterns,null,cache,patterns,boolean,value,this,tokenized,pattern,cache,put,pattern,tokenized,return,tokenized
AntPathMatcher -> protected String[] tokenizePattern(String pattern);1518772998;Tokenize the given path pattern into parts, based on this matcher's settings._<p>Performs caching based on {@link #setCachePatterns}, delegating to_{@link #tokenizePath(String)} for the actual tokenization algorithm._@param pattern the pattern to tokenize_@return the tokenized pattern parts;protected String[] tokenizePattern(String pattern) {_		String[] tokenized = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			tokenized = this.tokenizedPatternCache.get(pattern)__		}_		if (tokenized == null) {_			tokenized = tokenizePath(pattern)__			if (cachePatterns == null && this.tokenizedPatternCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return tokenized__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.tokenizedPatternCache.put(pattern, tokenized)__			}_		}_		return tokenized__	};tokenize,the,given,path,pattern,into,parts,based,on,this,matcher,s,settings,p,performs,caching,based,on,link,set,cache,patterns,delegating,to,link,tokenize,path,string,for,the,actual,tokenization,algorithm,param,pattern,the,pattern,to,tokenize,return,the,tokenized,pattern,parts;protected,string,tokenize,pattern,string,pattern,string,tokenized,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,tokenized,this,tokenized,pattern,cache,get,pattern,if,tokenized,null,tokenized,tokenize,path,pattern,if,cache,patterns,null,this,tokenized,pattern,cache,size,deactivate,pattern,cache,return,tokenized,if,cache,patterns,null,cache,patterns,boolean,value,this,tokenized,pattern,cache,put,pattern,tokenized,return,tokenized
AntPathMatcher -> protected String[] tokenizePattern(String pattern);1530174524;Tokenize the given path pattern into parts, based on this matcher's settings._<p>Performs caching based on {@link #setCachePatterns}, delegating to_{@link #tokenizePath(String)} for the actual tokenization algorithm._@param pattern the pattern to tokenize_@return the tokenized pattern parts;protected String[] tokenizePattern(String pattern) {_		String[] tokenized = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			tokenized = this.tokenizedPatternCache.get(pattern)__		}_		if (tokenized == null) {_			tokenized = tokenizePath(pattern)__			if (cachePatterns == null && this.tokenizedPatternCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return tokenized__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.tokenizedPatternCache.put(pattern, tokenized)__			}_		}_		return tokenized__	};tokenize,the,given,path,pattern,into,parts,based,on,this,matcher,s,settings,p,performs,caching,based,on,link,set,cache,patterns,delegating,to,link,tokenize,path,string,for,the,actual,tokenization,algorithm,param,pattern,the,pattern,to,tokenize,return,the,tokenized,pattern,parts;protected,string,tokenize,pattern,string,pattern,string,tokenized,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,tokenized,this,tokenized,pattern,cache,get,pattern,if,tokenized,null,tokenized,tokenize,path,pattern,if,cache,patterns,null,this,tokenized,pattern,cache,size,deactivate,pattern,cache,return,tokenized,if,cache,patterns,null,cache,patterns,boolean,value,this,tokenized,pattern,cache,put,pattern,tokenized,return,tokenized
AntPathMatcher -> protected String[] tokenizePattern(String pattern);1530174524;Tokenize the given path pattern into parts, based on this matcher's settings._<p>Performs caching based on {@link #setCachePatterns}, delegating to_{@link #tokenizePath(String)} for the actual tokenization algorithm._@param pattern the pattern to tokenize_@return the tokenized pattern parts;protected String[] tokenizePattern(String pattern) {_		String[] tokenized = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			tokenized = this.tokenizedPatternCache.get(pattern)__		}_		if (tokenized == null) {_			tokenized = tokenizePath(pattern)__			if (cachePatterns == null && this.tokenizedPatternCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return tokenized__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.tokenizedPatternCache.put(pattern, tokenized)__			}_		}_		return tokenized__	};tokenize,the,given,path,pattern,into,parts,based,on,this,matcher,s,settings,p,performs,caching,based,on,link,set,cache,patterns,delegating,to,link,tokenize,path,string,for,the,actual,tokenization,algorithm,param,pattern,the,pattern,to,tokenize,return,the,tokenized,pattern,parts;protected,string,tokenize,pattern,string,pattern,string,tokenized,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,tokenized,this,tokenized,pattern,cache,get,pattern,if,tokenized,null,tokenized,tokenize,path,pattern,if,cache,patterns,null,this,tokenized,pattern,cache,size,deactivate,pattern,cache,return,tokenized,if,cache,patterns,null,cache,patterns,boolean,value,this,tokenized,pattern,cache,put,pattern,tokenized,return,tokenized
AntPathMatcher -> protected String[] tokenizePattern(String pattern);1535316501;Tokenize the given path pattern into parts, based on this matcher's settings._<p>Performs caching based on {@link #setCachePatterns}, delegating to_{@link #tokenizePath(String)} for the actual tokenization algorithm._@param pattern the pattern to tokenize_@return the tokenized pattern parts;protected String[] tokenizePattern(String pattern) {_		String[] tokenized = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			tokenized = this.tokenizedPatternCache.get(pattern)__		}_		if (tokenized == null) {_			tokenized = tokenizePath(pattern)__			if (cachePatterns == null && this.tokenizedPatternCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return tokenized__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.tokenizedPatternCache.put(pattern, tokenized)__			}_		}_		return tokenized__	};tokenize,the,given,path,pattern,into,parts,based,on,this,matcher,s,settings,p,performs,caching,based,on,link,set,cache,patterns,delegating,to,link,tokenize,path,string,for,the,actual,tokenization,algorithm,param,pattern,the,pattern,to,tokenize,return,the,tokenized,pattern,parts;protected,string,tokenize,pattern,string,pattern,string,tokenized,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,tokenized,this,tokenized,pattern,cache,get,pattern,if,tokenized,null,tokenized,tokenize,path,pattern,if,cache,patterns,null,this,tokenized,pattern,cache,size,deactivate,pattern,cache,return,tokenized,if,cache,patterns,null,cache,patterns,boolean,value,this,tokenized,pattern,cache,put,pattern,tokenized,return,tokenized
AntPathMatcher -> AntPatternComparator -> @Override 		public int compare(String pattern1, String pattern2);1402512669;Compare two patterns to determine which should match first, i.e. which is the most specific_regarding the current path.__@return a negative integer, zero, or a positive integer as pattern1 is_more specific, equally specific, or less specific than pattern2.;@Override_		public int compare(String pattern1, String pattern2) {__			boolean pattern1NullCaptureAll = isNullOrCaptureAllPattern(pattern1)__			boolean pattern2NullCaptureAll = isNullOrCaptureAllPattern(pattern2)__			if (pattern1NullCaptureAll && pattern2NullCaptureAll) {_				return 0__			}_			else if (pattern1NullCaptureAll) {_				return 1__			}_			else if (pattern2NullCaptureAll) {_				return -1__			}__			boolean pattern1EqualsPath = pattern1.equals(path)__			boolean pattern2EqualsPath = pattern2.equals(path)__			if (pattern1EqualsPath && pattern2EqualsPath) {_				return 0__			}_			else if (pattern1EqualsPath) {_				return -1__			}_			else if (pattern2EqualsPath) {_				return 1__			}__			PatternElements pattern1Elements = new PatternElements(pattern1)__			PatternElements pattern2Elements = new PatternElements(pattern2)___			if(pattern1Elements.endsWithCatchAll && pattern2Elements.catchAllCount == 0) {_				return 1__			}_			else if(pattern2Elements.endsWithCatchAll && pattern1Elements.catchAllCount == 0) {_				return -1__			}__			int totalCount1 = pattern1Elements.bracketCount + pattern1Elements.wildcardsCount__			int totalCount2 = pattern2Elements.bracketCount + pattern2Elements.wildcardsCount___			if (totalCount1 != totalCount2) {_				return totalCount1 - totalCount2__			}__			int pattern1Length = getPatternLength(pattern1)__			int pattern2Length = getPatternLength(pattern2)___			if (pattern1Length != pattern2Length) {_				return pattern2Length - pattern1Length__			}__			if (pattern1Elements.wildcardsCount < pattern2Elements.wildcardsCount) {_				return -1__			}_			else if (pattern2Elements.wildcardsCount < pattern1Elements.wildcardsCount) {_				return 1__			}__			if (pattern1Elements.bracketCount < pattern2Elements.bracketCount) {_				return -1__			}_			else if (pattern2Elements.bracketCount < pattern1Elements.bracketCount) {_				return 1__			}__			return 0__		};compare,two,patterns,to,determine,which,should,match,first,i,e,which,is,the,most,specific,regarding,the,current,path,return,a,negative,integer,zero,or,a,positive,integer,as,pattern1,is,more,specific,equally,specific,or,less,specific,than,pattern2;override,public,int,compare,string,pattern1,string,pattern2,boolean,pattern1null,capture,all,is,null,or,capture,all,pattern,pattern1,boolean,pattern2null,capture,all,is,null,or,capture,all,pattern,pattern2,if,pattern1null,capture,all,pattern2null,capture,all,return,0,else,if,pattern1null,capture,all,return,1,else,if,pattern2null,capture,all,return,1,boolean,pattern1equals,path,pattern1,equals,path,boolean,pattern2equals,path,pattern2,equals,path,if,pattern1equals,path,pattern2equals,path,return,0,else,if,pattern1equals,path,return,1,else,if,pattern2equals,path,return,1,pattern,elements,pattern1elements,new,pattern,elements,pattern1,pattern,elements,pattern2elements,new,pattern,elements,pattern2,if,pattern1elements,ends,with,catch,all,pattern2elements,catch,all,count,0,return,1,else,if,pattern2elements,ends,with,catch,all,pattern1elements,catch,all,count,0,return,1,int,total,count1,pattern1elements,bracket,count,pattern1elements,wildcards,count,int,total,count2,pattern2elements,bracket,count,pattern2elements,wildcards,count,if,total,count1,total,count2,return,total,count1,total,count2,int,pattern1length,get,pattern,length,pattern1,int,pattern2length,get,pattern,length,pattern2,if,pattern1length,pattern2length,return,pattern2length,pattern1length,if,pattern1elements,wildcards,count,pattern2elements,wildcards,count,return,1,else,if,pattern2elements,wildcards,count,pattern1elements,wildcards,count,return,1,if,pattern1elements,bracket,count,pattern2elements,bracket,count,return,1,else,if,pattern2elements,bracket,count,pattern1elements,bracket,count,return,1,return,0
AntPathMatcher -> AntPatternComparator -> @Override 		public int compare(String pattern1, String pattern2);1402512669;Compare two patterns to determine which should match first, i.e. which is the most specific_regarding the current path.__@return a negative integer, zero, or a positive integer as pattern1 is_more specific, equally specific, or less specific than pattern2.;@Override_		public int compare(String pattern1, String pattern2) {__			PatternInfo info1 = new PatternInfo(pattern1)__			PatternInfo info2 = new PatternInfo(pattern2)___			if (info1.isLeastSpecific() && info2.isLeastSpecific()) {_				return 0__			}_			else if (info1.isLeastSpecific()) {_				return 1__			}_			else if (info2.isLeastSpecific()) {_				return -1__			}__			boolean pattern1EqualsPath = pattern1.equals(path)__			boolean pattern2EqualsPath = pattern2.equals(path)__			if (pattern1EqualsPath && pattern2EqualsPath) {_				return 0__			}_			else if (pattern1EqualsPath) {_				return -1__			}_			else if (pattern2EqualsPath) {_				return 1__			}__			if (info1.isPrefixPattern() && info2.getDoubleWildcards() == 0) {_				return 1__			}_			else if (info2.isPrefixPattern() && info1.getDoubleWildcards() == 0) {_				return -1__			}__			if (info1.getTotalCount() != info2.getTotalCount()) {_				return info1.getTotalCount() - info2.getTotalCount()__			}__			if (info1.getLength() != info2.getLength()) {_				return info2.getLength() - info1.getLength()__			}__			if (info1.getSingleWildcards() < info2.getSingleWildcards()) {_				return -1__			}_			else if (info2.getSingleWildcards() < info1.getSingleWildcards()) {_				return 1__			}__			if (info1.getUriVars() < info2.getUriVars()) {_				return -1__			}_			else if (info2.getUriVars() < info1.getUriVars()) {_				return 1__			}__			return 0__		};compare,two,patterns,to,determine,which,should,match,first,i,e,which,is,the,most,specific,regarding,the,current,path,return,a,negative,integer,zero,or,a,positive,integer,as,pattern1,is,more,specific,equally,specific,or,less,specific,than,pattern2;override,public,int,compare,string,pattern1,string,pattern2,pattern,info,info1,new,pattern,info,pattern1,pattern,info,info2,new,pattern,info,pattern2,if,info1,is,least,specific,info2,is,least,specific,return,0,else,if,info1,is,least,specific,return,1,else,if,info2,is,least,specific,return,1,boolean,pattern1equals,path,pattern1,equals,path,boolean,pattern2equals,path,pattern2,equals,path,if,pattern1equals,path,pattern2equals,path,return,0,else,if,pattern1equals,path,return,1,else,if,pattern2equals,path,return,1,if,info1,is,prefix,pattern,info2,get,double,wildcards,0,return,1,else,if,info2,is,prefix,pattern,info1,get,double,wildcards,0,return,1,if,info1,get,total,count,info2,get,total,count,return,info1,get,total,count,info2,get,total,count,if,info1,get,length,info2,get,length,return,info2,get,length,info1,get,length,if,info1,get,single,wildcards,info2,get,single,wildcards,return,1,else,if,info2,get,single,wildcards,info1,get,single,wildcards,return,1,if,info1,get,uri,vars,info2,get,uri,vars,return,1,else,if,info2,get,uri,vars,info1,get,uri,vars,return,1,return,0
AntPathMatcher -> AntPatternComparator -> @Override 		public int compare(String pattern1, String pattern2);1402512669;Compare two patterns to determine which should match first, i.e. which is the most specific_regarding the current path.__@return a negative integer, zero, or a positive integer as pattern1 is_more specific, equally specific, or less specific than pattern2.;@Override_		public int compare(String pattern1, String pattern2) {__			PatternInfo info1 = new PatternInfo(pattern1)__			PatternInfo info2 = new PatternInfo(pattern2)___			if (info1.isLeastSpecific() && info2.isLeastSpecific()) {_				return 0__			}_			else if (info1.isLeastSpecific()) {_				return 1__			}_			else if (info2.isLeastSpecific()) {_				return -1__			}__			boolean pattern1EqualsPath = pattern1.equals(path)__			boolean pattern2EqualsPath = pattern2.equals(path)__			if (pattern1EqualsPath && pattern2EqualsPath) {_				return 0__			}_			else if (pattern1EqualsPath) {_				return -1__			}_			else if (pattern2EqualsPath) {_				return 1__			}__			if (info1.isPrefixPattern() && info2.getDoubleWildcards() == 0) {_				return 1__			}_			else if (info2.isPrefixPattern() && info1.getDoubleWildcards() == 0) {_				return -1__			}__			if (info1.getTotalCount() != info2.getTotalCount()) {_				return info1.getTotalCount() - info2.getTotalCount()__			}__			if (info1.getLength() != info2.getLength()) {_				return info2.getLength() - info1.getLength()__			}__			if (info1.getSingleWildcards() < info2.getSingleWildcards()) {_				return -1__			}_			else if (info2.getSingleWildcards() < info1.getSingleWildcards()) {_				return 1__			}__			if (info1.getUriVars() < info2.getUriVars()) {_				return -1__			}_			else if (info2.getUriVars() < info1.getUriVars()) {_				return 1__			}__			return 0__		};compare,two,patterns,to,determine,which,should,match,first,i,e,which,is,the,most,specific,regarding,the,current,path,return,a,negative,integer,zero,or,a,positive,integer,as,pattern1,is,more,specific,equally,specific,or,less,specific,than,pattern2;override,public,int,compare,string,pattern1,string,pattern2,pattern,info,info1,new,pattern,info,pattern1,pattern,info,info2,new,pattern,info,pattern2,if,info1,is,least,specific,info2,is,least,specific,return,0,else,if,info1,is,least,specific,return,1,else,if,info2,is,least,specific,return,1,boolean,pattern1equals,path,pattern1,equals,path,boolean,pattern2equals,path,pattern2,equals,path,if,pattern1equals,path,pattern2equals,path,return,0,else,if,pattern1equals,path,return,1,else,if,pattern2equals,path,return,1,if,info1,is,prefix,pattern,info2,get,double,wildcards,0,return,1,else,if,info2,is,prefix,pattern,info1,get,double,wildcards,0,return,1,if,info1,get,total,count,info2,get,total,count,return,info1,get,total,count,info2,get,total,count,if,info1,get,length,info2,get,length,return,info2,get,length,info1,get,length,if,info1,get,single,wildcards,info2,get,single,wildcards,return,1,else,if,info2,get,single,wildcards,info1,get,single,wildcards,return,1,if,info1,get,uri,vars,info2,get,uri,vars,return,1,else,if,info2,get,uri,vars,info1,get,uri,vars,return,1,return,0
AntPathMatcher -> AntPatternComparator -> @Override 		public int compare(String pattern1, String pattern2);1405378164;Compare two patterns to determine which should match first, i.e. which is the most specific_regarding the current path.__@return a negative integer, zero, or a positive integer as pattern1 is_more specific, equally specific, or less specific than pattern2.;@Override_		public int compare(String pattern1, String pattern2) {__			PatternInfo info1 = new PatternInfo(pattern1)__			PatternInfo info2 = new PatternInfo(pattern2)___			if (info1.isLeastSpecific() && info2.isLeastSpecific()) {_				return 0__			}_			else if (info1.isLeastSpecific()) {_				return 1__			}_			else if (info2.isLeastSpecific()) {_				return -1__			}__			boolean pattern1EqualsPath = pattern1.equals(path)__			boolean pattern2EqualsPath = pattern2.equals(path)__			if (pattern1EqualsPath && pattern2EqualsPath) {_				return 0__			}_			else if (pattern1EqualsPath) {_				return -1__			}_			else if (pattern2EqualsPath) {_				return 1__			}__			if (info1.isPrefixPattern() && info2.getDoubleWildcards() == 0) {_				return 1__			}_			else if (info2.isPrefixPattern() && info1.getDoubleWildcards() == 0) {_				return -1__			}__			if (info1.getTotalCount() != info2.getTotalCount()) {_				return info1.getTotalCount() - info2.getTotalCount()__			}__			if (info1.getLength() != info2.getLength()) {_				return info2.getLength() - info1.getLength()__			}__			if (info1.getSingleWildcards() < info2.getSingleWildcards()) {_				return -1__			}_			else if (info2.getSingleWildcards() < info1.getSingleWildcards()) {_				return 1__			}__			if (info1.getUriVars() < info2.getUriVars()) {_				return -1__			}_			else if (info2.getUriVars() < info1.getUriVars()) {_				return 1__			}__			return 0__		};compare,two,patterns,to,determine,which,should,match,first,i,e,which,is,the,most,specific,regarding,the,current,path,return,a,negative,integer,zero,or,a,positive,integer,as,pattern1,is,more,specific,equally,specific,or,less,specific,than,pattern2;override,public,int,compare,string,pattern1,string,pattern2,pattern,info,info1,new,pattern,info,pattern1,pattern,info,info2,new,pattern,info,pattern2,if,info1,is,least,specific,info2,is,least,specific,return,0,else,if,info1,is,least,specific,return,1,else,if,info2,is,least,specific,return,1,boolean,pattern1equals,path,pattern1,equals,path,boolean,pattern2equals,path,pattern2,equals,path,if,pattern1equals,path,pattern2equals,path,return,0,else,if,pattern1equals,path,return,1,else,if,pattern2equals,path,return,1,if,info1,is,prefix,pattern,info2,get,double,wildcards,0,return,1,else,if,info2,is,prefix,pattern,info1,get,double,wildcards,0,return,1,if,info1,get,total,count,info2,get,total,count,return,info1,get,total,count,info2,get,total,count,if,info1,get,length,info2,get,length,return,info2,get,length,info1,get,length,if,info1,get,single,wildcards,info2,get,single,wildcards,return,1,else,if,info2,get,single,wildcards,info1,get,single,wildcards,return,1,if,info1,get,uri,vars,info2,get,uri,vars,return,1,else,if,info2,get,uri,vars,info1,get,uri,vars,return,1,return,0
AntPathMatcher -> AntPatternComparator -> @Override 		public int compare(String pattern1, String pattern2);1405378165;Compare two patterns to determine which should match first, i.e. which is the most specific_regarding the current path.__@return a negative integer, zero, or a positive integer as pattern1 is_more specific, equally specific, or less specific than pattern2.;@Override_		public int compare(String pattern1, String pattern2) {__			PatternInfo info1 = new PatternInfo(pattern1)__			PatternInfo info2 = new PatternInfo(pattern2)___			if (info1.isLeastSpecific() && info2.isLeastSpecific()) {_				return 0__			}_			else if (info1.isLeastSpecific()) {_				return 1__			}_			else if (info2.isLeastSpecific()) {_				return -1__			}__			boolean pattern1EqualsPath = pattern1.equals(path)__			boolean pattern2EqualsPath = pattern2.equals(path)__			if (pattern1EqualsPath && pattern2EqualsPath) {_				return 0__			}_			else if (pattern1EqualsPath) {_				return -1__			}_			else if (pattern2EqualsPath) {_				return 1__			}__			if (info1.isPrefixPattern() && info2.getDoubleWildcards() == 0) {_				return 1__			}_			else if (info2.isPrefixPattern() && info1.getDoubleWildcards() == 0) {_				return -1__			}__			if (info1.getTotalCount() != info2.getTotalCount()) {_				return info1.getTotalCount() - info2.getTotalCount()__			}__			if (info1.getLength() != info2.getLength()) {_				return info2.getLength() - info1.getLength()__			}__			if (info1.getSingleWildcards() < info2.getSingleWildcards()) {_				return -1__			}_			else if (info2.getSingleWildcards() < info1.getSingleWildcards()) {_				return 1__			}__			if (info1.getUriVars() < info2.getUriVars()) {_				return -1__			}_			else if (info2.getUriVars() < info1.getUriVars()) {_				return 1__			}__			return 0__		};compare,two,patterns,to,determine,which,should,match,first,i,e,which,is,the,most,specific,regarding,the,current,path,return,a,negative,integer,zero,or,a,positive,integer,as,pattern1,is,more,specific,equally,specific,or,less,specific,than,pattern2;override,public,int,compare,string,pattern1,string,pattern2,pattern,info,info1,new,pattern,info,pattern1,pattern,info,info2,new,pattern,info,pattern2,if,info1,is,least,specific,info2,is,least,specific,return,0,else,if,info1,is,least,specific,return,1,else,if,info2,is,least,specific,return,1,boolean,pattern1equals,path,pattern1,equals,path,boolean,pattern2equals,path,pattern2,equals,path,if,pattern1equals,path,pattern2equals,path,return,0,else,if,pattern1equals,path,return,1,else,if,pattern2equals,path,return,1,if,info1,is,prefix,pattern,info2,get,double,wildcards,0,return,1,else,if,info2,is,prefix,pattern,info1,get,double,wildcards,0,return,1,if,info1,get,total,count,info2,get,total,count,return,info1,get,total,count,info2,get,total,count,if,info1,get,length,info2,get,length,return,info2,get,length,info1,get,length,if,info1,get,single,wildcards,info2,get,single,wildcards,return,1,else,if,info2,get,single,wildcards,info1,get,single,wildcards,return,1,if,info1,get,uri,vars,info2,get,uri,vars,return,1,else,if,info2,get,uri,vars,info1,get,uri,vars,return,1,return,0
AntPathMatcher -> AntPatternComparator -> @Override 		public int compare(String pattern1, String pattern2);1405696918;Compare two patterns to determine which should match first, i.e. which is the most specific_regarding the current path.__@return a negative integer, zero, or a positive integer as pattern1 is_more specific, equally specific, or less specific than pattern2.;@Override_		public int compare(String pattern1, String pattern2) {__			PatternInfo info1 = new PatternInfo(pattern1)__			PatternInfo info2 = new PatternInfo(pattern2)___			if (info1.isLeastSpecific() && info2.isLeastSpecific()) {_				return 0__			}_			else if (info1.isLeastSpecific()) {_				return 1__			}_			else if (info2.isLeastSpecific()) {_				return -1__			}__			boolean pattern1EqualsPath = pattern1.equals(path)__			boolean pattern2EqualsPath = pattern2.equals(path)__			if (pattern1EqualsPath && pattern2EqualsPath) {_				return 0__			}_			else if (pattern1EqualsPath) {_				return -1__			}_			else if (pattern2EqualsPath) {_				return 1__			}__			if (info1.isPrefixPattern() && info2.getDoubleWildcards() == 0) {_				return 1__			}_			else if (info2.isPrefixPattern() && info1.getDoubleWildcards() == 0) {_				return -1__			}__			if (info1.getTotalCount() != info2.getTotalCount()) {_				return info1.getTotalCount() - info2.getTotalCount()__			}__			if (info1.getLength() != info2.getLength()) {_				return info2.getLength() - info1.getLength()__			}__			if (info1.getSingleWildcards() < info2.getSingleWildcards()) {_				return -1__			}_			else if (info2.getSingleWildcards() < info1.getSingleWildcards()) {_				return 1__			}__			if (info1.getUriVars() < info2.getUriVars()) {_				return -1__			}_			else if (info2.getUriVars() < info1.getUriVars()) {_				return 1__			}__			return 0__		};compare,two,patterns,to,determine,which,should,match,first,i,e,which,is,the,most,specific,regarding,the,current,path,return,a,negative,integer,zero,or,a,positive,integer,as,pattern1,is,more,specific,equally,specific,or,less,specific,than,pattern2;override,public,int,compare,string,pattern1,string,pattern2,pattern,info,info1,new,pattern,info,pattern1,pattern,info,info2,new,pattern,info,pattern2,if,info1,is,least,specific,info2,is,least,specific,return,0,else,if,info1,is,least,specific,return,1,else,if,info2,is,least,specific,return,1,boolean,pattern1equals,path,pattern1,equals,path,boolean,pattern2equals,path,pattern2,equals,path,if,pattern1equals,path,pattern2equals,path,return,0,else,if,pattern1equals,path,return,1,else,if,pattern2equals,path,return,1,if,info1,is,prefix,pattern,info2,get,double,wildcards,0,return,1,else,if,info2,is,prefix,pattern,info1,get,double,wildcards,0,return,1,if,info1,get,total,count,info2,get,total,count,return,info1,get,total,count,info2,get,total,count,if,info1,get,length,info2,get,length,return,info2,get,length,info1,get,length,if,info1,get,single,wildcards,info2,get,single,wildcards,return,1,else,if,info2,get,single,wildcards,info1,get,single,wildcards,return,1,if,info1,get,uri,vars,info2,get,uri,vars,return,1,else,if,info2,get,uri,vars,info1,get,uri,vars,return,1,return,0
AntPathMatcher -> AntPatternComparator -> @Override 		public int compare(String pattern1, String pattern2);1409784938;Compare two patterns to determine which should match first, i.e. which is the most specific_regarding the current path.__@return a negative integer, zero, or a positive integer as pattern1 is_more specific, equally specific, or less specific than pattern2.;@Override_		public int compare(String pattern1, String pattern2) {__			PatternInfo info1 = new PatternInfo(pattern1)__			PatternInfo info2 = new PatternInfo(pattern2)___			if (info1.isLeastSpecific() && info2.isLeastSpecific()) {_				return 0__			}_			else if (info1.isLeastSpecific()) {_				return 1__			}_			else if (info2.isLeastSpecific()) {_				return -1__			}__			boolean pattern1EqualsPath = pattern1.equals(path)__			boolean pattern2EqualsPath = pattern2.equals(path)__			if (pattern1EqualsPath && pattern2EqualsPath) {_				return 0__			}_			else if (pattern1EqualsPath) {_				return -1__			}_			else if (pattern2EqualsPath) {_				return 1__			}__			if (info1.isPrefixPattern() && info2.getDoubleWildcards() == 0) {_				return 1__			}_			else if (info2.isPrefixPattern() && info1.getDoubleWildcards() == 0) {_				return -1__			}__			if (info1.getTotalCount() != info2.getTotalCount()) {_				return info1.getTotalCount() - info2.getTotalCount()__			}__			if (info1.getLength() != info2.getLength()) {_				return info2.getLength() - info1.getLength()__			}__			if (info1.getSingleWildcards() < info2.getSingleWildcards()) {_				return -1__			}_			else if (info2.getSingleWildcards() < info1.getSingleWildcards()) {_				return 1__			}__			if (info1.getUriVars() < info2.getUriVars()) {_				return -1__			}_			else if (info2.getUriVars() < info1.getUriVars()) {_				return 1__			}__			return 0__		};compare,two,patterns,to,determine,which,should,match,first,i,e,which,is,the,most,specific,regarding,the,current,path,return,a,negative,integer,zero,or,a,positive,integer,as,pattern1,is,more,specific,equally,specific,or,less,specific,than,pattern2;override,public,int,compare,string,pattern1,string,pattern2,pattern,info,info1,new,pattern,info,pattern1,pattern,info,info2,new,pattern,info,pattern2,if,info1,is,least,specific,info2,is,least,specific,return,0,else,if,info1,is,least,specific,return,1,else,if,info2,is,least,specific,return,1,boolean,pattern1equals,path,pattern1,equals,path,boolean,pattern2equals,path,pattern2,equals,path,if,pattern1equals,path,pattern2equals,path,return,0,else,if,pattern1equals,path,return,1,else,if,pattern2equals,path,return,1,if,info1,is,prefix,pattern,info2,get,double,wildcards,0,return,1,else,if,info2,is,prefix,pattern,info1,get,double,wildcards,0,return,1,if,info1,get,total,count,info2,get,total,count,return,info1,get,total,count,info2,get,total,count,if,info1,get,length,info2,get,length,return,info2,get,length,info1,get,length,if,info1,get,single,wildcards,info2,get,single,wildcards,return,1,else,if,info2,get,single,wildcards,info1,get,single,wildcards,return,1,if,info1,get,uri,vars,info2,get,uri,vars,return,1,else,if,info2,get,uri,vars,info1,get,uri,vars,return,1,return,0
AntPathMatcher -> AntPatternComparator -> @Override 		public int compare(String pattern1, String pattern2);1412083966;Compare two patterns to determine which should match first, i.e. which is the most specific_regarding the current path.__@return a negative integer, zero, or a positive integer as pattern1 is_more specific, equally specific, or less specific than pattern2.;@Override_		public int compare(String pattern1, String pattern2) {__			PatternInfo info1 = new PatternInfo(pattern1)__			PatternInfo info2 = new PatternInfo(pattern2)___			if (info1.isLeastSpecific() && info2.isLeastSpecific()) {_				return 0__			}_			else if (info1.isLeastSpecific()) {_				return 1__			}_			else if (info2.isLeastSpecific()) {_				return -1__			}__			boolean pattern1EqualsPath = pattern1.equals(path)__			boolean pattern2EqualsPath = pattern2.equals(path)__			if (pattern1EqualsPath && pattern2EqualsPath) {_				return 0__			}_			else if (pattern1EqualsPath) {_				return -1__			}_			else if (pattern2EqualsPath) {_				return 1__			}__			if (info1.isPrefixPattern() && info2.getDoubleWildcards() == 0) {_				return 1__			}_			else if (info2.isPrefixPattern() && info1.getDoubleWildcards() == 0) {_				return -1__			}__			if (info1.getTotalCount() != info2.getTotalCount()) {_				return info1.getTotalCount() - info2.getTotalCount()__			}__			if (info1.getLength() != info2.getLength()) {_				return info2.getLength() - info1.getLength()__			}__			if (info1.getSingleWildcards() < info2.getSingleWildcards()) {_				return -1__			}_			else if (info2.getSingleWildcards() < info1.getSingleWildcards()) {_				return 1__			}__			if (info1.getUriVars() < info2.getUriVars()) {_				return -1__			}_			else if (info2.getUriVars() < info1.getUriVars()) {_				return 1__			}__			return 0__		};compare,two,patterns,to,determine,which,should,match,first,i,e,which,is,the,most,specific,regarding,the,current,path,return,a,negative,integer,zero,or,a,positive,integer,as,pattern1,is,more,specific,equally,specific,or,less,specific,than,pattern2;override,public,int,compare,string,pattern1,string,pattern2,pattern,info,info1,new,pattern,info,pattern1,pattern,info,info2,new,pattern,info,pattern2,if,info1,is,least,specific,info2,is,least,specific,return,0,else,if,info1,is,least,specific,return,1,else,if,info2,is,least,specific,return,1,boolean,pattern1equals,path,pattern1,equals,path,boolean,pattern2equals,path,pattern2,equals,path,if,pattern1equals,path,pattern2equals,path,return,0,else,if,pattern1equals,path,return,1,else,if,pattern2equals,path,return,1,if,info1,is,prefix,pattern,info2,get,double,wildcards,0,return,1,else,if,info2,is,prefix,pattern,info1,get,double,wildcards,0,return,1,if,info1,get,total,count,info2,get,total,count,return,info1,get,total,count,info2,get,total,count,if,info1,get,length,info2,get,length,return,info2,get,length,info1,get,length,if,info1,get,single,wildcards,info2,get,single,wildcards,return,1,else,if,info2,get,single,wildcards,info1,get,single,wildcards,return,1,if,info1,get,uri,vars,info2,get,uri,vars,return,1,else,if,info2,get,uri,vars,info1,get,uri,vars,return,1,return,0
AntPathMatcher -> AntPatternComparator -> @Override 		public int compare(String pattern1, String pattern2);1412101078;Compare two patterns to determine which should match first, i.e. which_is the most specific regarding the current path._@return a negative integer, zero, or a positive integer as pattern1 is_more specific, equally specific, or less specific than pattern2.;@Override_		public int compare(String pattern1, String pattern2) {_			PatternInfo info1 = new PatternInfo(pattern1)__			PatternInfo info2 = new PatternInfo(pattern2)___			if (info1.isLeastSpecific() && info2.isLeastSpecific()) {_				return 0__			}_			else if (info1.isLeastSpecific()) {_				return 1__			}_			else if (info2.isLeastSpecific()) {_				return -1__			}__			boolean pattern1EqualsPath = pattern1.equals(path)__			boolean pattern2EqualsPath = pattern2.equals(path)__			if (pattern1EqualsPath && pattern2EqualsPath) {_				return 0__			}_			else if (pattern1EqualsPath) {_				return -1__			}_			else if (pattern2EqualsPath) {_				return 1__			}__			if (info1.isPrefixPattern() && info2.getDoubleWildcards() == 0) {_				return 1__			}_			else if (info2.isPrefixPattern() && info1.getDoubleWildcards() == 0) {_				return -1__			}__			if (info1.getTotalCount() != info2.getTotalCount()) {_				return info1.getTotalCount() - info2.getTotalCount()__			}__			if (info1.getLength() != info2.getLength()) {_				return info2.getLength() - info1.getLength()__			}__			if (info1.getSingleWildcards() < info2.getSingleWildcards()) {_				return -1__			}_			else if (info2.getSingleWildcards() < info1.getSingleWildcards()) {_				return 1__			}__			if (info1.getUriVars() < info2.getUriVars()) {_				return -1__			}_			else if (info2.getUriVars() < info1.getUriVars()) {_				return 1__			}__			return 0__		};compare,two,patterns,to,determine,which,should,match,first,i,e,which,is,the,most,specific,regarding,the,current,path,return,a,negative,integer,zero,or,a,positive,integer,as,pattern1,is,more,specific,equally,specific,or,less,specific,than,pattern2;override,public,int,compare,string,pattern1,string,pattern2,pattern,info,info1,new,pattern,info,pattern1,pattern,info,info2,new,pattern,info,pattern2,if,info1,is,least,specific,info2,is,least,specific,return,0,else,if,info1,is,least,specific,return,1,else,if,info2,is,least,specific,return,1,boolean,pattern1equals,path,pattern1,equals,path,boolean,pattern2equals,path,pattern2,equals,path,if,pattern1equals,path,pattern2equals,path,return,0,else,if,pattern1equals,path,return,1,else,if,pattern2equals,path,return,1,if,info1,is,prefix,pattern,info2,get,double,wildcards,0,return,1,else,if,info2,is,prefix,pattern,info1,get,double,wildcards,0,return,1,if,info1,get,total,count,info2,get,total,count,return,info1,get,total,count,info2,get,total,count,if,info1,get,length,info2,get,length,return,info2,get,length,info1,get,length,if,info1,get,single,wildcards,info2,get,single,wildcards,return,1,else,if,info2,get,single,wildcards,info1,get,single,wildcards,return,1,if,info1,get,uri,vars,info2,get,uri,vars,return,1,else,if,info2,get,uri,vars,info1,get,uri,vars,return,1,return,0
AntPathMatcher -> AntPatternComparator -> @Override 		public int compare(String pattern1, String pattern2);1431086052;Compare two patterns to determine which should match first, i.e. which_is the most specific regarding the current path._@return a negative integer, zero, or a positive integer as pattern1 is_more specific, equally specific, or less specific than pattern2.;@Override_		public int compare(String pattern1, String pattern2) {_			PatternInfo info1 = new PatternInfo(pattern1)__			PatternInfo info2 = new PatternInfo(pattern2)___			if (info1.isLeastSpecific() && info2.isLeastSpecific()) {_				return 0__			}_			else if (info1.isLeastSpecific()) {_				return 1__			}_			else if (info2.isLeastSpecific()) {_				return -1__			}__			boolean pattern1EqualsPath = pattern1.equals(path)__			boolean pattern2EqualsPath = pattern2.equals(path)__			if (pattern1EqualsPath && pattern2EqualsPath) {_				return 0__			}_			else if (pattern1EqualsPath) {_				return -1__			}_			else if (pattern2EqualsPath) {_				return 1__			}__			if (info1.isPrefixPattern() && info2.getDoubleWildcards() == 0) {_				return 1__			}_			else if (info2.isPrefixPattern() && info1.getDoubleWildcards() == 0) {_				return -1__			}__			if (info1.getTotalCount() != info2.getTotalCount()) {_				return info1.getTotalCount() - info2.getTotalCount()__			}__			if (info1.getLength() != info2.getLength()) {_				return info2.getLength() - info1.getLength()__			}__			if (info1.getSingleWildcards() < info2.getSingleWildcards()) {_				return -1__			}_			else if (info2.getSingleWildcards() < info1.getSingleWildcards()) {_				return 1__			}__			if (info1.getUriVars() < info2.getUriVars()) {_				return -1__			}_			else if (info2.getUriVars() < info1.getUriVars()) {_				return 1__			}__			return 0__		};compare,two,patterns,to,determine,which,should,match,first,i,e,which,is,the,most,specific,regarding,the,current,path,return,a,negative,integer,zero,or,a,positive,integer,as,pattern1,is,more,specific,equally,specific,or,less,specific,than,pattern2;override,public,int,compare,string,pattern1,string,pattern2,pattern,info,info1,new,pattern,info,pattern1,pattern,info,info2,new,pattern,info,pattern2,if,info1,is,least,specific,info2,is,least,specific,return,0,else,if,info1,is,least,specific,return,1,else,if,info2,is,least,specific,return,1,boolean,pattern1equals,path,pattern1,equals,path,boolean,pattern2equals,path,pattern2,equals,path,if,pattern1equals,path,pattern2equals,path,return,0,else,if,pattern1equals,path,return,1,else,if,pattern2equals,path,return,1,if,info1,is,prefix,pattern,info2,get,double,wildcards,0,return,1,else,if,info2,is,prefix,pattern,info1,get,double,wildcards,0,return,1,if,info1,get,total,count,info2,get,total,count,return,info1,get,total,count,info2,get,total,count,if,info1,get,length,info2,get,length,return,info2,get,length,info1,get,length,if,info1,get,single,wildcards,info2,get,single,wildcards,return,1,else,if,info2,get,single,wildcards,info1,get,single,wildcards,return,1,if,info1,get,uri,vars,info2,get,uri,vars,return,1,else,if,info2,get,uri,vars,info1,get,uri,vars,return,1,return,0
AntPathMatcher -> AntPatternComparator -> @Override 		public int compare(String pattern1, String pattern2);1431178173;Compare two patterns to determine which should match first, i.e. which_is the most specific regarding the current path._@return a negative integer, zero, or a positive integer as pattern1 is_more specific, equally specific, or less specific than pattern2.;@Override_		public int compare(String pattern1, String pattern2) {_			PatternInfo info1 = new PatternInfo(pattern1)__			PatternInfo info2 = new PatternInfo(pattern2)___			if (info1.isLeastSpecific() && info2.isLeastSpecific()) {_				return 0__			}_			else if (info1.isLeastSpecific()) {_				return 1__			}_			else if (info2.isLeastSpecific()) {_				return -1__			}__			boolean pattern1EqualsPath = pattern1.equals(path)__			boolean pattern2EqualsPath = pattern2.equals(path)__			if (pattern1EqualsPath && pattern2EqualsPath) {_				return 0__			}_			else if (pattern1EqualsPath) {_				return -1__			}_			else if (pattern2EqualsPath) {_				return 1__			}__			if (info1.isPrefixPattern() && info2.getDoubleWildcards() == 0) {_				return 1__			}_			else if (info2.isPrefixPattern() && info1.getDoubleWildcards() == 0) {_				return -1__			}__			if (info1.getTotalCount() != info2.getTotalCount()) {_				return info1.getTotalCount() - info2.getTotalCount()__			}__			if (info1.getLength() != info2.getLength()) {_				return info2.getLength() - info1.getLength()__			}__			if (info1.getSingleWildcards() < info2.getSingleWildcards()) {_				return -1__			}_			else if (info2.getSingleWildcards() < info1.getSingleWildcards()) {_				return 1__			}__			if (info1.getUriVars() < info2.getUriVars()) {_				return -1__			}_			else if (info2.getUriVars() < info1.getUriVars()) {_				return 1__			}__			return 0__		};compare,two,patterns,to,determine,which,should,match,first,i,e,which,is,the,most,specific,regarding,the,current,path,return,a,negative,integer,zero,or,a,positive,integer,as,pattern1,is,more,specific,equally,specific,or,less,specific,than,pattern2;override,public,int,compare,string,pattern1,string,pattern2,pattern,info,info1,new,pattern,info,pattern1,pattern,info,info2,new,pattern,info,pattern2,if,info1,is,least,specific,info2,is,least,specific,return,0,else,if,info1,is,least,specific,return,1,else,if,info2,is,least,specific,return,1,boolean,pattern1equals,path,pattern1,equals,path,boolean,pattern2equals,path,pattern2,equals,path,if,pattern1equals,path,pattern2equals,path,return,0,else,if,pattern1equals,path,return,1,else,if,pattern2equals,path,return,1,if,info1,is,prefix,pattern,info2,get,double,wildcards,0,return,1,else,if,info2,is,prefix,pattern,info1,get,double,wildcards,0,return,1,if,info1,get,total,count,info2,get,total,count,return,info1,get,total,count,info2,get,total,count,if,info1,get,length,info2,get,length,return,info2,get,length,info1,get,length,if,info1,get,single,wildcards,info2,get,single,wildcards,return,1,else,if,info2,get,single,wildcards,info1,get,single,wildcards,return,1,if,info1,get,uri,vars,info2,get,uri,vars,return,1,else,if,info2,get,uri,vars,info1,get,uri,vars,return,1,return,0
AntPathMatcher -> AntPatternComparator -> @Override 		public int compare(String pattern1, String pattern2);1434572159;Compare two patterns to determine which should match first, i.e. which_is the most specific regarding the current path._@return a negative integer, zero, or a positive integer as pattern1 is_more specific, equally specific, or less specific than pattern2.;@Override_		public int compare(String pattern1, String pattern2) {_			PatternInfo info1 = new PatternInfo(pattern1)__			PatternInfo info2 = new PatternInfo(pattern2)___			if (info1.isLeastSpecific() && info2.isLeastSpecific()) {_				return 0__			}_			else if (info1.isLeastSpecific()) {_				return 1__			}_			else if (info2.isLeastSpecific()) {_				return -1__			}__			boolean pattern1EqualsPath = pattern1.equals(path)__			boolean pattern2EqualsPath = pattern2.equals(path)__			if (pattern1EqualsPath && pattern2EqualsPath) {_				return 0__			}_			else if (pattern1EqualsPath) {_				return -1__			}_			else if (pattern2EqualsPath) {_				return 1__			}__			if (info1.isPrefixPattern() && info2.getDoubleWildcards() == 0) {_				return 1__			}_			else if (info2.isPrefixPattern() && info1.getDoubleWildcards() == 0) {_				return -1__			}__			if (info1.getTotalCount() != info2.getTotalCount()) {_				return info1.getTotalCount() - info2.getTotalCount()__			}__			if (info1.getLength() != info2.getLength()) {_				return info2.getLength() - info1.getLength()__			}__			if (info1.getSingleWildcards() < info2.getSingleWildcards()) {_				return -1__			}_			else if (info2.getSingleWildcards() < info1.getSingleWildcards()) {_				return 1__			}__			if (info1.getUriVars() < info2.getUriVars()) {_				return -1__			}_			else if (info2.getUriVars() < info1.getUriVars()) {_				return 1__			}__			return 0__		};compare,two,patterns,to,determine,which,should,match,first,i,e,which,is,the,most,specific,regarding,the,current,path,return,a,negative,integer,zero,or,a,positive,integer,as,pattern1,is,more,specific,equally,specific,or,less,specific,than,pattern2;override,public,int,compare,string,pattern1,string,pattern2,pattern,info,info1,new,pattern,info,pattern1,pattern,info,info2,new,pattern,info,pattern2,if,info1,is,least,specific,info2,is,least,specific,return,0,else,if,info1,is,least,specific,return,1,else,if,info2,is,least,specific,return,1,boolean,pattern1equals,path,pattern1,equals,path,boolean,pattern2equals,path,pattern2,equals,path,if,pattern1equals,path,pattern2equals,path,return,0,else,if,pattern1equals,path,return,1,else,if,pattern2equals,path,return,1,if,info1,is,prefix,pattern,info2,get,double,wildcards,0,return,1,else,if,info2,is,prefix,pattern,info1,get,double,wildcards,0,return,1,if,info1,get,total,count,info2,get,total,count,return,info1,get,total,count,info2,get,total,count,if,info1,get,length,info2,get,length,return,info2,get,length,info1,get,length,if,info1,get,single,wildcards,info2,get,single,wildcards,return,1,else,if,info2,get,single,wildcards,info1,get,single,wildcards,return,1,if,info1,get,uri,vars,info2,get,uri,vars,return,1,else,if,info2,get,uri,vars,info1,get,uri,vars,return,1,return,0
AntPathMatcher -> AntPatternComparator -> @Override 		public int compare(String pattern1, String pattern2);1435239719;Compare two patterns to determine which should match first, i.e. which_is the most specific regarding the current path._@return a negative integer, zero, or a positive integer as pattern1 is_more specific, equally specific, or less specific than pattern2.;@Override_		public int compare(String pattern1, String pattern2) {_			PatternInfo info1 = new PatternInfo(pattern1)__			PatternInfo info2 = new PatternInfo(pattern2)___			if (info1.isLeastSpecific() && info2.isLeastSpecific()) {_				return 0__			}_			else if (info1.isLeastSpecific()) {_				return 1__			}_			else if (info2.isLeastSpecific()) {_				return -1__			}__			boolean pattern1EqualsPath = pattern1.equals(path)__			boolean pattern2EqualsPath = pattern2.equals(path)__			if (pattern1EqualsPath && pattern2EqualsPath) {_				return 0__			}_			else if (pattern1EqualsPath) {_				return -1__			}_			else if (pattern2EqualsPath) {_				return 1__			}__			if (info1.isPrefixPattern() && info2.getDoubleWildcards() == 0) {_				return 1__			}_			else if (info2.isPrefixPattern() && info1.getDoubleWildcards() == 0) {_				return -1__			}__			if (info1.getTotalCount() != info2.getTotalCount()) {_				return info1.getTotalCount() - info2.getTotalCount()__			}__			if (info1.getLength() != info2.getLength()) {_				return info2.getLength() - info1.getLength()__			}__			if (info1.getSingleWildcards() < info2.getSingleWildcards()) {_				return -1__			}_			else if (info2.getSingleWildcards() < info1.getSingleWildcards()) {_				return 1__			}__			if (info1.getUriVars() < info2.getUriVars()) {_				return -1__			}_			else if (info2.getUriVars() < info1.getUriVars()) {_				return 1__			}__			return 0__		};compare,two,patterns,to,determine,which,should,match,first,i,e,which,is,the,most,specific,regarding,the,current,path,return,a,negative,integer,zero,or,a,positive,integer,as,pattern1,is,more,specific,equally,specific,or,less,specific,than,pattern2;override,public,int,compare,string,pattern1,string,pattern2,pattern,info,info1,new,pattern,info,pattern1,pattern,info,info2,new,pattern,info,pattern2,if,info1,is,least,specific,info2,is,least,specific,return,0,else,if,info1,is,least,specific,return,1,else,if,info2,is,least,specific,return,1,boolean,pattern1equals,path,pattern1,equals,path,boolean,pattern2equals,path,pattern2,equals,path,if,pattern1equals,path,pattern2equals,path,return,0,else,if,pattern1equals,path,return,1,else,if,pattern2equals,path,return,1,if,info1,is,prefix,pattern,info2,get,double,wildcards,0,return,1,else,if,info2,is,prefix,pattern,info1,get,double,wildcards,0,return,1,if,info1,get,total,count,info2,get,total,count,return,info1,get,total,count,info2,get,total,count,if,info1,get,length,info2,get,length,return,info2,get,length,info1,get,length,if,info1,get,single,wildcards,info2,get,single,wildcards,return,1,else,if,info2,get,single,wildcards,info1,get,single,wildcards,return,1,if,info1,get,uri,vars,info2,get,uri,vars,return,1,else,if,info2,get,uri,vars,info1,get,uri,vars,return,1,return,0
AntPathMatcher -> AntPatternComparator -> @Override 		public int compare(String pattern1, String pattern2);1438166321;Compare two patterns to determine which should match first, i.e. which_is the most specific regarding the current path._@return a negative integer, zero, or a positive integer as pattern1 is_more specific, equally specific, or less specific than pattern2.;@Override_		public int compare(String pattern1, String pattern2) {_			PatternInfo info1 = new PatternInfo(pattern1)__			PatternInfo info2 = new PatternInfo(pattern2)___			if (info1.isLeastSpecific() && info2.isLeastSpecific()) {_				return 0__			}_			else if (info1.isLeastSpecific()) {_				return 1__			}_			else if (info2.isLeastSpecific()) {_				return -1__			}__			boolean pattern1EqualsPath = pattern1.equals(path)__			boolean pattern2EqualsPath = pattern2.equals(path)__			if (pattern1EqualsPath && pattern2EqualsPath) {_				return 0__			}_			else if (pattern1EqualsPath) {_				return -1__			}_			else if (pattern2EqualsPath) {_				return 1__			}__			if (info1.isPrefixPattern() && info2.getDoubleWildcards() == 0) {_				return 1__			}_			else if (info2.isPrefixPattern() && info1.getDoubleWildcards() == 0) {_				return -1__			}__			if (info1.getTotalCount() != info2.getTotalCount()) {_				return info1.getTotalCount() - info2.getTotalCount()__			}__			if (info1.getLength() != info2.getLength()) {_				return info2.getLength() - info1.getLength()__			}__			if (info1.getSingleWildcards() < info2.getSingleWildcards()) {_				return -1__			}_			else if (info2.getSingleWildcards() < info1.getSingleWildcards()) {_				return 1__			}__			if (info1.getUriVars() < info2.getUriVars()) {_				return -1__			}_			else if (info2.getUriVars() < info1.getUriVars()) {_				return 1__			}__			return 0__		};compare,two,patterns,to,determine,which,should,match,first,i,e,which,is,the,most,specific,regarding,the,current,path,return,a,negative,integer,zero,or,a,positive,integer,as,pattern1,is,more,specific,equally,specific,or,less,specific,than,pattern2;override,public,int,compare,string,pattern1,string,pattern2,pattern,info,info1,new,pattern,info,pattern1,pattern,info,info2,new,pattern,info,pattern2,if,info1,is,least,specific,info2,is,least,specific,return,0,else,if,info1,is,least,specific,return,1,else,if,info2,is,least,specific,return,1,boolean,pattern1equals,path,pattern1,equals,path,boolean,pattern2equals,path,pattern2,equals,path,if,pattern1equals,path,pattern2equals,path,return,0,else,if,pattern1equals,path,return,1,else,if,pattern2equals,path,return,1,if,info1,is,prefix,pattern,info2,get,double,wildcards,0,return,1,else,if,info2,is,prefix,pattern,info1,get,double,wildcards,0,return,1,if,info1,get,total,count,info2,get,total,count,return,info1,get,total,count,info2,get,total,count,if,info1,get,length,info2,get,length,return,info2,get,length,info1,get,length,if,info1,get,single,wildcards,info2,get,single,wildcards,return,1,else,if,info2,get,single,wildcards,info1,get,single,wildcards,return,1,if,info1,get,uri,vars,info2,get,uri,vars,return,1,else,if,info2,get,uri,vars,info1,get,uri,vars,return,1,return,0
AntPathMatcher -> AntPatternComparator -> @Override 		public int compare(String pattern1, String pattern2);1455100778;Compare two patterns to determine which should match first, i.e. which_is the most specific regarding the current path._@return a negative integer, zero, or a positive integer as pattern1 is_more specific, equally specific, or less specific than pattern2.;@Override_		public int compare(String pattern1, String pattern2) {_			PatternInfo info1 = new PatternInfo(pattern1)__			PatternInfo info2 = new PatternInfo(pattern2)___			if (info1.isLeastSpecific() && info2.isLeastSpecific()) {_				return 0__			}_			else if (info1.isLeastSpecific()) {_				return 1__			}_			else if (info2.isLeastSpecific()) {_				return -1__			}__			boolean pattern1EqualsPath = pattern1.equals(path)__			boolean pattern2EqualsPath = pattern2.equals(path)__			if (pattern1EqualsPath && pattern2EqualsPath) {_				return 0__			}_			else if (pattern1EqualsPath) {_				return -1__			}_			else if (pattern2EqualsPath) {_				return 1__			}__			if (info1.isPrefixPattern() && info2.getDoubleWildcards() == 0) {_				return 1__			}_			else if (info2.isPrefixPattern() && info1.getDoubleWildcards() == 0) {_				return -1__			}__			if (info1.getTotalCount() != info2.getTotalCount()) {_				return info1.getTotalCount() - info2.getTotalCount()__			}__			if (info1.getLength() != info2.getLength()) {_				return info2.getLength() - info1.getLength()__			}__			if (info1.getSingleWildcards() < info2.getSingleWildcards()) {_				return -1__			}_			else if (info2.getSingleWildcards() < info1.getSingleWildcards()) {_				return 1__			}__			if (info1.getUriVars() < info2.getUriVars()) {_				return -1__			}_			else if (info2.getUriVars() < info1.getUriVars()) {_				return 1__			}__			return 0__		};compare,two,patterns,to,determine,which,should,match,first,i,e,which,is,the,most,specific,regarding,the,current,path,return,a,negative,integer,zero,or,a,positive,integer,as,pattern1,is,more,specific,equally,specific,or,less,specific,than,pattern2;override,public,int,compare,string,pattern1,string,pattern2,pattern,info,info1,new,pattern,info,pattern1,pattern,info,info2,new,pattern,info,pattern2,if,info1,is,least,specific,info2,is,least,specific,return,0,else,if,info1,is,least,specific,return,1,else,if,info2,is,least,specific,return,1,boolean,pattern1equals,path,pattern1,equals,path,boolean,pattern2equals,path,pattern2,equals,path,if,pattern1equals,path,pattern2equals,path,return,0,else,if,pattern1equals,path,return,1,else,if,pattern2equals,path,return,1,if,info1,is,prefix,pattern,info2,get,double,wildcards,0,return,1,else,if,info2,is,prefix,pattern,info1,get,double,wildcards,0,return,1,if,info1,get,total,count,info2,get,total,count,return,info1,get,total,count,info2,get,total,count,if,info1,get,length,info2,get,length,return,info2,get,length,info1,get,length,if,info1,get,single,wildcards,info2,get,single,wildcards,return,1,else,if,info2,get,single,wildcards,info1,get,single,wildcards,return,1,if,info1,get,uri,vars,info2,get,uri,vars,return,1,else,if,info2,get,uri,vars,info1,get,uri,vars,return,1,return,0
AntPathMatcher -> AntPatternComparator -> @Override 		public int compare(String pattern1, String pattern2);1455850198;Compare two patterns to determine which should match first, i.e. which_is the most specific regarding the current path._@return a negative integer, zero, or a positive integer as pattern1 is_more specific, equally specific, or less specific than pattern2.;@Override_		public int compare(String pattern1, String pattern2) {_			PatternInfo info1 = new PatternInfo(pattern1)__			PatternInfo info2 = new PatternInfo(pattern2)___			if (info1.isLeastSpecific() && info2.isLeastSpecific()) {_				return 0__			}_			else if (info1.isLeastSpecific()) {_				return 1__			}_			else if (info2.isLeastSpecific()) {_				return -1__			}__			boolean pattern1EqualsPath = pattern1.equals(path)__			boolean pattern2EqualsPath = pattern2.equals(path)__			if (pattern1EqualsPath && pattern2EqualsPath) {_				return 0__			}_			else if (pattern1EqualsPath) {_				return -1__			}_			else if (pattern2EqualsPath) {_				return 1__			}__			if (info1.isPrefixPattern() && info2.getDoubleWildcards() == 0) {_				return 1__			}_			else if (info2.isPrefixPattern() && info1.getDoubleWildcards() == 0) {_				return -1__			}__			if (info1.getTotalCount() != info2.getTotalCount()) {_				return info1.getTotalCount() - info2.getTotalCount()__			}__			if (info1.getLength() != info2.getLength()) {_				return info2.getLength() - info1.getLength()__			}__			if (info1.getSingleWildcards() < info2.getSingleWildcards()) {_				return -1__			}_			else if (info2.getSingleWildcards() < info1.getSingleWildcards()) {_				return 1__			}__			if (info1.getUriVars() < info2.getUriVars()) {_				return -1__			}_			else if (info2.getUriVars() < info1.getUriVars()) {_				return 1__			}__			return 0__		};compare,two,patterns,to,determine,which,should,match,first,i,e,which,is,the,most,specific,regarding,the,current,path,return,a,negative,integer,zero,or,a,positive,integer,as,pattern1,is,more,specific,equally,specific,or,less,specific,than,pattern2;override,public,int,compare,string,pattern1,string,pattern2,pattern,info,info1,new,pattern,info,pattern1,pattern,info,info2,new,pattern,info,pattern2,if,info1,is,least,specific,info2,is,least,specific,return,0,else,if,info1,is,least,specific,return,1,else,if,info2,is,least,specific,return,1,boolean,pattern1equals,path,pattern1,equals,path,boolean,pattern2equals,path,pattern2,equals,path,if,pattern1equals,path,pattern2equals,path,return,0,else,if,pattern1equals,path,return,1,else,if,pattern2equals,path,return,1,if,info1,is,prefix,pattern,info2,get,double,wildcards,0,return,1,else,if,info2,is,prefix,pattern,info1,get,double,wildcards,0,return,1,if,info1,get,total,count,info2,get,total,count,return,info1,get,total,count,info2,get,total,count,if,info1,get,length,info2,get,length,return,info2,get,length,info1,get,length,if,info1,get,single,wildcards,info2,get,single,wildcards,return,1,else,if,info2,get,single,wildcards,info1,get,single,wildcards,return,1,if,info1,get,uri,vars,info2,get,uri,vars,return,1,else,if,info2,get,uri,vars,info1,get,uri,vars,return,1,return,0
AntPathMatcher -> AntPatternComparator -> @Override 		public int compare(String pattern1, String pattern2);1460754629;Compare two patterns to determine which should match first, i.e. which_is the most specific regarding the current path._@return a negative integer, zero, or a positive integer as pattern1 is_more specific, equally specific, or less specific than pattern2.;@Override_		public int compare(String pattern1, String pattern2) {_			PatternInfo info1 = new PatternInfo(pattern1)__			PatternInfo info2 = new PatternInfo(pattern2)___			if (info1.isLeastSpecific() && info2.isLeastSpecific()) {_				return 0__			}_			else if (info1.isLeastSpecific()) {_				return 1__			}_			else if (info2.isLeastSpecific()) {_				return -1__			}__			boolean pattern1EqualsPath = pattern1.equals(path)__			boolean pattern2EqualsPath = pattern2.equals(path)__			if (pattern1EqualsPath && pattern2EqualsPath) {_				return 0__			}_			else if (pattern1EqualsPath) {_				return -1__			}_			else if (pattern2EqualsPath) {_				return 1__			}__			if (info1.isPrefixPattern() && info2.getDoubleWildcards() == 0) {_				return 1__			}_			else if (info2.isPrefixPattern() && info1.getDoubleWildcards() == 0) {_				return -1__			}__			if (info1.getTotalCount() != info2.getTotalCount()) {_				return info1.getTotalCount() - info2.getTotalCount()__			}__			if (info1.getLength() != info2.getLength()) {_				return info2.getLength() - info1.getLength()__			}__			if (info1.getSingleWildcards() < info2.getSingleWildcards()) {_				return -1__			}_			else if (info2.getSingleWildcards() < info1.getSingleWildcards()) {_				return 1__			}__			if (info1.getUriVars() < info2.getUriVars()) {_				return -1__			}_			else if (info2.getUriVars() < info1.getUriVars()) {_				return 1__			}__			return 0__		};compare,two,patterns,to,determine,which,should,match,first,i,e,which,is,the,most,specific,regarding,the,current,path,return,a,negative,integer,zero,or,a,positive,integer,as,pattern1,is,more,specific,equally,specific,or,less,specific,than,pattern2;override,public,int,compare,string,pattern1,string,pattern2,pattern,info,info1,new,pattern,info,pattern1,pattern,info,info2,new,pattern,info,pattern2,if,info1,is,least,specific,info2,is,least,specific,return,0,else,if,info1,is,least,specific,return,1,else,if,info2,is,least,specific,return,1,boolean,pattern1equals,path,pattern1,equals,path,boolean,pattern2equals,path,pattern2,equals,path,if,pattern1equals,path,pattern2equals,path,return,0,else,if,pattern1equals,path,return,1,else,if,pattern2equals,path,return,1,if,info1,is,prefix,pattern,info2,get,double,wildcards,0,return,1,else,if,info2,is,prefix,pattern,info1,get,double,wildcards,0,return,1,if,info1,get,total,count,info2,get,total,count,return,info1,get,total,count,info2,get,total,count,if,info1,get,length,info2,get,length,return,info2,get,length,info1,get,length,if,info1,get,single,wildcards,info2,get,single,wildcards,return,1,else,if,info2,get,single,wildcards,info1,get,single,wildcards,return,1,if,info1,get,uri,vars,info2,get,uri,vars,return,1,else,if,info2,get,uri,vars,info1,get,uri,vars,return,1,return,0
AntPathMatcher -> AntPatternComparator -> @Override 		public int compare(String pattern1, String pattern2);1462393686;Compare two patterns to determine which should match first, i.e. which_is the most specific regarding the current path._@return a negative integer, zero, or a positive integer as pattern1 is_more specific, equally specific, or less specific than pattern2.;@Override_		public int compare(String pattern1, String pattern2) {_			PatternInfo info1 = new PatternInfo(pattern1)__			PatternInfo info2 = new PatternInfo(pattern2)___			if (info1.isLeastSpecific() && info2.isLeastSpecific()) {_				return 0__			}_			else if (info1.isLeastSpecific()) {_				return 1__			}_			else if (info2.isLeastSpecific()) {_				return -1__			}__			boolean pattern1EqualsPath = pattern1.equals(path)__			boolean pattern2EqualsPath = pattern2.equals(path)__			if (pattern1EqualsPath && pattern2EqualsPath) {_				return 0__			}_			else if (pattern1EqualsPath) {_				return -1__			}_			else if (pattern2EqualsPath) {_				return 1__			}__			if (info1.isPrefixPattern() && info2.getDoubleWildcards() == 0) {_				return 1__			}_			else if (info2.isPrefixPattern() && info1.getDoubleWildcards() == 0) {_				return -1__			}__			if (info1.getTotalCount() != info2.getTotalCount()) {_				return info1.getTotalCount() - info2.getTotalCount()__			}__			if (info1.getLength() != info2.getLength()) {_				return info2.getLength() - info1.getLength()__			}__			if (info1.getSingleWildcards() < info2.getSingleWildcards()) {_				return -1__			}_			else if (info2.getSingleWildcards() < info1.getSingleWildcards()) {_				return 1__			}__			if (info1.getUriVars() < info2.getUriVars()) {_				return -1__			}_			else if (info2.getUriVars() < info1.getUriVars()) {_				return 1__			}__			return 0__		};compare,two,patterns,to,determine,which,should,match,first,i,e,which,is,the,most,specific,regarding,the,current,path,return,a,negative,integer,zero,or,a,positive,integer,as,pattern1,is,more,specific,equally,specific,or,less,specific,than,pattern2;override,public,int,compare,string,pattern1,string,pattern2,pattern,info,info1,new,pattern,info,pattern1,pattern,info,info2,new,pattern,info,pattern2,if,info1,is,least,specific,info2,is,least,specific,return,0,else,if,info1,is,least,specific,return,1,else,if,info2,is,least,specific,return,1,boolean,pattern1equals,path,pattern1,equals,path,boolean,pattern2equals,path,pattern2,equals,path,if,pattern1equals,path,pattern2equals,path,return,0,else,if,pattern1equals,path,return,1,else,if,pattern2equals,path,return,1,if,info1,is,prefix,pattern,info2,get,double,wildcards,0,return,1,else,if,info2,is,prefix,pattern,info1,get,double,wildcards,0,return,1,if,info1,get,total,count,info2,get,total,count,return,info1,get,total,count,info2,get,total,count,if,info1,get,length,info2,get,length,return,info2,get,length,info1,get,length,if,info1,get,single,wildcards,info2,get,single,wildcards,return,1,else,if,info2,get,single,wildcards,info1,get,single,wildcards,return,1,if,info1,get,uri,vars,info2,get,uri,vars,return,1,else,if,info2,get,uri,vars,info1,get,uri,vars,return,1,return,0
AntPathMatcher -> AntPatternComparator -> @Override 		public int compare(String pattern1, String pattern2);1467730834;Compare two patterns to determine which should match first, i.e. which_is the most specific regarding the current path._@return a negative integer, zero, or a positive integer as pattern1 is_more specific, equally specific, or less specific than pattern2.;@Override_		public int compare(String pattern1, String pattern2) {_			PatternInfo info1 = new PatternInfo(pattern1)__			PatternInfo info2 = new PatternInfo(pattern2)___			if (info1.isLeastSpecific() && info2.isLeastSpecific()) {_				return 0__			}_			else if (info1.isLeastSpecific()) {_				return 1__			}_			else if (info2.isLeastSpecific()) {_				return -1__			}__			boolean pattern1EqualsPath = pattern1.equals(path)__			boolean pattern2EqualsPath = pattern2.equals(path)__			if (pattern1EqualsPath && pattern2EqualsPath) {_				return 0__			}_			else if (pattern1EqualsPath) {_				return -1__			}_			else if (pattern2EqualsPath) {_				return 1__			}__			if (info1.isPrefixPattern() && info2.getDoubleWildcards() == 0) {_				return 1__			}_			else if (info2.isPrefixPattern() && info1.getDoubleWildcards() == 0) {_				return -1__			}__			if (info1.getTotalCount() != info2.getTotalCount()) {_				return info1.getTotalCount() - info2.getTotalCount()__			}__			if (info1.getLength() != info2.getLength()) {_				return info2.getLength() - info1.getLength()__			}__			if (info1.getSingleWildcards() < info2.getSingleWildcards()) {_				return -1__			}_			else if (info2.getSingleWildcards() < info1.getSingleWildcards()) {_				return 1__			}__			if (info1.getUriVars() < info2.getUriVars()) {_				return -1__			}_			else if (info2.getUriVars() < info1.getUriVars()) {_				return 1__			}__			return 0__		};compare,two,patterns,to,determine,which,should,match,first,i,e,which,is,the,most,specific,regarding,the,current,path,return,a,negative,integer,zero,or,a,positive,integer,as,pattern1,is,more,specific,equally,specific,or,less,specific,than,pattern2;override,public,int,compare,string,pattern1,string,pattern2,pattern,info,info1,new,pattern,info,pattern1,pattern,info,info2,new,pattern,info,pattern2,if,info1,is,least,specific,info2,is,least,specific,return,0,else,if,info1,is,least,specific,return,1,else,if,info2,is,least,specific,return,1,boolean,pattern1equals,path,pattern1,equals,path,boolean,pattern2equals,path,pattern2,equals,path,if,pattern1equals,path,pattern2equals,path,return,0,else,if,pattern1equals,path,return,1,else,if,pattern2equals,path,return,1,if,info1,is,prefix,pattern,info2,get,double,wildcards,0,return,1,else,if,info2,is,prefix,pattern,info1,get,double,wildcards,0,return,1,if,info1,get,total,count,info2,get,total,count,return,info1,get,total,count,info2,get,total,count,if,info1,get,length,info2,get,length,return,info2,get,length,info1,get,length,if,info1,get,single,wildcards,info2,get,single,wildcards,return,1,else,if,info2,get,single,wildcards,info1,get,single,wildcards,return,1,if,info1,get,uri,vars,info2,get,uri,vars,return,1,else,if,info2,get,uri,vars,info1,get,uri,vars,return,1,return,0
AntPathMatcher -> AntPatternComparator -> @Override 		public int compare(String pattern1, String pattern2);1468327638;Compare two patterns to determine which should match first, i.e. which_is the most specific regarding the current path._@return a negative integer, zero, or a positive integer as pattern1 is_more specific, equally specific, or less specific than pattern2.;@Override_		public int compare(String pattern1, String pattern2) {_			PatternInfo info1 = new PatternInfo(pattern1)__			PatternInfo info2 = new PatternInfo(pattern2)___			if (info1.isLeastSpecific() && info2.isLeastSpecific()) {_				return 0__			}_			else if (info1.isLeastSpecific()) {_				return 1__			}_			else if (info2.isLeastSpecific()) {_				return -1__			}__			boolean pattern1EqualsPath = pattern1.equals(path)__			boolean pattern2EqualsPath = pattern2.equals(path)__			if (pattern1EqualsPath && pattern2EqualsPath) {_				return 0__			}_			else if (pattern1EqualsPath) {_				return -1__			}_			else if (pattern2EqualsPath) {_				return 1__			}__			if (info1.isPrefixPattern() && info2.getDoubleWildcards() == 0) {_				return 1__			}_			else if (info2.isPrefixPattern() && info1.getDoubleWildcards() == 0) {_				return -1__			}__			if (info1.getTotalCount() != info2.getTotalCount()) {_				return info1.getTotalCount() - info2.getTotalCount()__			}__			if (info1.getLength() != info2.getLength()) {_				return info2.getLength() - info1.getLength()__			}__			if (info1.getSingleWildcards() < info2.getSingleWildcards()) {_				return -1__			}_			else if (info2.getSingleWildcards() < info1.getSingleWildcards()) {_				return 1__			}__			if (info1.getUriVars() < info2.getUriVars()) {_				return -1__			}_			else if (info2.getUriVars() < info1.getUriVars()) {_				return 1__			}__			return 0__		};compare,two,patterns,to,determine,which,should,match,first,i,e,which,is,the,most,specific,regarding,the,current,path,return,a,negative,integer,zero,or,a,positive,integer,as,pattern1,is,more,specific,equally,specific,or,less,specific,than,pattern2;override,public,int,compare,string,pattern1,string,pattern2,pattern,info,info1,new,pattern,info,pattern1,pattern,info,info2,new,pattern,info,pattern2,if,info1,is,least,specific,info2,is,least,specific,return,0,else,if,info1,is,least,specific,return,1,else,if,info2,is,least,specific,return,1,boolean,pattern1equals,path,pattern1,equals,path,boolean,pattern2equals,path,pattern2,equals,path,if,pattern1equals,path,pattern2equals,path,return,0,else,if,pattern1equals,path,return,1,else,if,pattern2equals,path,return,1,if,info1,is,prefix,pattern,info2,get,double,wildcards,0,return,1,else,if,info2,is,prefix,pattern,info1,get,double,wildcards,0,return,1,if,info1,get,total,count,info2,get,total,count,return,info1,get,total,count,info2,get,total,count,if,info1,get,length,info2,get,length,return,info2,get,length,info1,get,length,if,info1,get,single,wildcards,info2,get,single,wildcards,return,1,else,if,info2,get,single,wildcards,info1,get,single,wildcards,return,1,if,info1,get,uri,vars,info2,get,uri,vars,return,1,else,if,info2,get,uri,vars,info1,get,uri,vars,return,1,return,0
AntPathMatcher -> AntPatternComparator -> @Override 		public int compare(String pattern1, String pattern2);1472808958;Compare two patterns to determine which should match first, i.e. which_is the most specific regarding the current path._@return a negative integer, zero, or a positive integer as pattern1 is_more specific, equally specific, or less specific than pattern2.;@Override_		public int compare(String pattern1, String pattern2) {_			PatternInfo info1 = new PatternInfo(pattern1)__			PatternInfo info2 = new PatternInfo(pattern2)___			if (info1.isLeastSpecific() && info2.isLeastSpecific()) {_				return 0__			}_			else if (info1.isLeastSpecific()) {_				return 1__			}_			else if (info2.isLeastSpecific()) {_				return -1__			}__			boolean pattern1EqualsPath = pattern1.equals(path)__			boolean pattern2EqualsPath = pattern2.equals(path)__			if (pattern1EqualsPath && pattern2EqualsPath) {_				return 0__			}_			else if (pattern1EqualsPath) {_				return -1__			}_			else if (pattern2EqualsPath) {_				return 1__			}__			if (info1.isPrefixPattern() && info2.getDoubleWildcards() == 0) {_				return 1__			}_			else if (info2.isPrefixPattern() && info1.getDoubleWildcards() == 0) {_				return -1__			}__			if (info1.getTotalCount() != info2.getTotalCount()) {_				return info1.getTotalCount() - info2.getTotalCount()__			}__			if (info1.getLength() != info2.getLength()) {_				return info2.getLength() - info1.getLength()__			}__			if (info1.getSingleWildcards() < info2.getSingleWildcards()) {_				return -1__			}_			else if (info2.getSingleWildcards() < info1.getSingleWildcards()) {_				return 1__			}__			if (info1.getUriVars() < info2.getUriVars()) {_				return -1__			}_			else if (info2.getUriVars() < info1.getUriVars()) {_				return 1__			}__			return 0__		};compare,two,patterns,to,determine,which,should,match,first,i,e,which,is,the,most,specific,regarding,the,current,path,return,a,negative,integer,zero,or,a,positive,integer,as,pattern1,is,more,specific,equally,specific,or,less,specific,than,pattern2;override,public,int,compare,string,pattern1,string,pattern2,pattern,info,info1,new,pattern,info,pattern1,pattern,info,info2,new,pattern,info,pattern2,if,info1,is,least,specific,info2,is,least,specific,return,0,else,if,info1,is,least,specific,return,1,else,if,info2,is,least,specific,return,1,boolean,pattern1equals,path,pattern1,equals,path,boolean,pattern2equals,path,pattern2,equals,path,if,pattern1equals,path,pattern2equals,path,return,0,else,if,pattern1equals,path,return,1,else,if,pattern2equals,path,return,1,if,info1,is,prefix,pattern,info2,get,double,wildcards,0,return,1,else,if,info2,is,prefix,pattern,info1,get,double,wildcards,0,return,1,if,info1,get,total,count,info2,get,total,count,return,info1,get,total,count,info2,get,total,count,if,info1,get,length,info2,get,length,return,info2,get,length,info1,get,length,if,info1,get,single,wildcards,info2,get,single,wildcards,return,1,else,if,info2,get,single,wildcards,info1,get,single,wildcards,return,1,if,info1,get,uri,vars,info2,get,uri,vars,return,1,else,if,info2,get,uri,vars,info1,get,uri,vars,return,1,return,0
AntPathMatcher -> AntPatternComparator -> @Override 		public int compare(String pattern1, String pattern2);1493317597;Compare two patterns to determine which should match first, i.e. which_is the most specific regarding the current path._@return a negative integer, zero, or a positive integer as pattern1 is_more specific, equally specific, or less specific than pattern2.;@Override_		public int compare(String pattern1, String pattern2) {_			PatternInfo info1 = new PatternInfo(pattern1)__			PatternInfo info2 = new PatternInfo(pattern2)___			if (info1.isLeastSpecific() && info2.isLeastSpecific()) {_				return 0__			}_			else if (info1.isLeastSpecific()) {_				return 1__			}_			else if (info2.isLeastSpecific()) {_				return -1__			}__			boolean pattern1EqualsPath = pattern1.equals(path)__			boolean pattern2EqualsPath = pattern2.equals(path)__			if (pattern1EqualsPath && pattern2EqualsPath) {_				return 0__			}_			else if (pattern1EqualsPath) {_				return -1__			}_			else if (pattern2EqualsPath) {_				return 1__			}__			if (info1.isPrefixPattern() && info2.getDoubleWildcards() == 0) {_				return 1__			}_			else if (info2.isPrefixPattern() && info1.getDoubleWildcards() == 0) {_				return -1__			}__			if (info1.getTotalCount() != info2.getTotalCount()) {_				return info1.getTotalCount() - info2.getTotalCount()__			}__			if (info1.getLength() != info2.getLength()) {_				return info2.getLength() - info1.getLength()__			}__			if (info1.getSingleWildcards() < info2.getSingleWildcards()) {_				return -1__			}_			else if (info2.getSingleWildcards() < info1.getSingleWildcards()) {_				return 1__			}__			if (info1.getUriVars() < info2.getUriVars()) {_				return -1__			}_			else if (info2.getUriVars() < info1.getUriVars()) {_				return 1__			}__			return 0__		};compare,two,patterns,to,determine,which,should,match,first,i,e,which,is,the,most,specific,regarding,the,current,path,return,a,negative,integer,zero,or,a,positive,integer,as,pattern1,is,more,specific,equally,specific,or,less,specific,than,pattern2;override,public,int,compare,string,pattern1,string,pattern2,pattern,info,info1,new,pattern,info,pattern1,pattern,info,info2,new,pattern,info,pattern2,if,info1,is,least,specific,info2,is,least,specific,return,0,else,if,info1,is,least,specific,return,1,else,if,info2,is,least,specific,return,1,boolean,pattern1equals,path,pattern1,equals,path,boolean,pattern2equals,path,pattern2,equals,path,if,pattern1equals,path,pattern2equals,path,return,0,else,if,pattern1equals,path,return,1,else,if,pattern2equals,path,return,1,if,info1,is,prefix,pattern,info2,get,double,wildcards,0,return,1,else,if,info2,is,prefix,pattern,info1,get,double,wildcards,0,return,1,if,info1,get,total,count,info2,get,total,count,return,info1,get,total,count,info2,get,total,count,if,info1,get,length,info2,get,length,return,info2,get,length,info1,get,length,if,info1,get,single,wildcards,info2,get,single,wildcards,return,1,else,if,info2,get,single,wildcards,info1,get,single,wildcards,return,1,if,info1,get,uri,vars,info2,get,uri,vars,return,1,else,if,info2,get,uri,vars,info1,get,uri,vars,return,1,return,0
AntPathMatcher -> AntPatternComparator -> @Override 		public int compare(String pattern1, String pattern2);1493321510;Compare two patterns to determine which should match first, i.e. which_is the most specific regarding the current path._@return a negative integer, zero, or a positive integer as pattern1 is_more specific, equally specific, or less specific than pattern2.;@Override_		public int compare(String pattern1, String pattern2) {_			PatternInfo info1 = new PatternInfo(pattern1)__			PatternInfo info2 = new PatternInfo(pattern2)___			if (info1.isLeastSpecific() && info2.isLeastSpecific()) {_				return 0__			}_			else if (info1.isLeastSpecific()) {_				return 1__			}_			else if (info2.isLeastSpecific()) {_				return -1__			}__			boolean pattern1EqualsPath = pattern1.equals(path)__			boolean pattern2EqualsPath = pattern2.equals(path)__			if (pattern1EqualsPath && pattern2EqualsPath) {_				return 0__			}_			else if (pattern1EqualsPath) {_				return -1__			}_			else if (pattern2EqualsPath) {_				return 1__			}__			if (info1.isPrefixPattern() && info2.getDoubleWildcards() == 0) {_				return 1__			}_			else if (info2.isPrefixPattern() && info1.getDoubleWildcards() == 0) {_				return -1__			}__			if (info1.getTotalCount() != info2.getTotalCount()) {_				return info1.getTotalCount() - info2.getTotalCount()__			}__			if (info1.getLength() != info2.getLength()) {_				return info2.getLength() - info1.getLength()__			}__			if (info1.getSingleWildcards() < info2.getSingleWildcards()) {_				return -1__			}_			else if (info2.getSingleWildcards() < info1.getSingleWildcards()) {_				return 1__			}__			if (info1.getUriVars() < info2.getUriVars()) {_				return -1__			}_			else if (info2.getUriVars() < info1.getUriVars()) {_				return 1__			}__			return 0__		};compare,two,patterns,to,determine,which,should,match,first,i,e,which,is,the,most,specific,regarding,the,current,path,return,a,negative,integer,zero,or,a,positive,integer,as,pattern1,is,more,specific,equally,specific,or,less,specific,than,pattern2;override,public,int,compare,string,pattern1,string,pattern2,pattern,info,info1,new,pattern,info,pattern1,pattern,info,info2,new,pattern,info,pattern2,if,info1,is,least,specific,info2,is,least,specific,return,0,else,if,info1,is,least,specific,return,1,else,if,info2,is,least,specific,return,1,boolean,pattern1equals,path,pattern1,equals,path,boolean,pattern2equals,path,pattern2,equals,path,if,pattern1equals,path,pattern2equals,path,return,0,else,if,pattern1equals,path,return,1,else,if,pattern2equals,path,return,1,if,info1,is,prefix,pattern,info2,get,double,wildcards,0,return,1,else,if,info2,is,prefix,pattern,info1,get,double,wildcards,0,return,1,if,info1,get,total,count,info2,get,total,count,return,info1,get,total,count,info2,get,total,count,if,info1,get,length,info2,get,length,return,info2,get,length,info1,get,length,if,info1,get,single,wildcards,info2,get,single,wildcards,return,1,else,if,info2,get,single,wildcards,info1,get,single,wildcards,return,1,if,info1,get,uri,vars,info2,get,uri,vars,return,1,else,if,info2,get,uri,vars,info1,get,uri,vars,return,1,return,0
AntPathMatcher -> AntPatternComparator -> @Override 		public int compare(String pattern1, String pattern2);1496259743;Compare two patterns to determine which should match first, i.e. which_is the most specific regarding the current path._@return a negative integer, zero, or a positive integer as pattern1 is_more specific, equally specific, or less specific than pattern2.;@Override_		public int compare(String pattern1, String pattern2) {_			PatternInfo info1 = new PatternInfo(pattern1)__			PatternInfo info2 = new PatternInfo(pattern2)___			if (info1.isLeastSpecific() && info2.isLeastSpecific()) {_				return 0__			}_			else if (info1.isLeastSpecific()) {_				return 1__			}_			else if (info2.isLeastSpecific()) {_				return -1__			}__			boolean pattern1EqualsPath = pattern1.equals(path)__			boolean pattern2EqualsPath = pattern2.equals(path)__			if (pattern1EqualsPath && pattern2EqualsPath) {_				return 0__			}_			else if (pattern1EqualsPath) {_				return -1__			}_			else if (pattern2EqualsPath) {_				return 1__			}__			if (info1.isPrefixPattern() && info2.getDoubleWildcards() == 0) {_				return 1__			}_			else if (info2.isPrefixPattern() && info1.getDoubleWildcards() == 0) {_				return -1__			}__			if (info1.getTotalCount() != info2.getTotalCount()) {_				return info1.getTotalCount() - info2.getTotalCount()__			}__			if (info1.getLength() != info2.getLength()) {_				return info2.getLength() - info1.getLength()__			}__			if (info1.getSingleWildcards() < info2.getSingleWildcards()) {_				return -1__			}_			else if (info2.getSingleWildcards() < info1.getSingleWildcards()) {_				return 1__			}__			if (info1.getUriVars() < info2.getUriVars()) {_				return -1__			}_			else if (info2.getUriVars() < info1.getUriVars()) {_				return 1__			}__			return 0__		};compare,two,patterns,to,determine,which,should,match,first,i,e,which,is,the,most,specific,regarding,the,current,path,return,a,negative,integer,zero,or,a,positive,integer,as,pattern1,is,more,specific,equally,specific,or,less,specific,than,pattern2;override,public,int,compare,string,pattern1,string,pattern2,pattern,info,info1,new,pattern,info,pattern1,pattern,info,info2,new,pattern,info,pattern2,if,info1,is,least,specific,info2,is,least,specific,return,0,else,if,info1,is,least,specific,return,1,else,if,info2,is,least,specific,return,1,boolean,pattern1equals,path,pattern1,equals,path,boolean,pattern2equals,path,pattern2,equals,path,if,pattern1equals,path,pattern2equals,path,return,0,else,if,pattern1equals,path,return,1,else,if,pattern2equals,path,return,1,if,info1,is,prefix,pattern,info2,get,double,wildcards,0,return,1,else,if,info2,is,prefix,pattern,info1,get,double,wildcards,0,return,1,if,info1,get,total,count,info2,get,total,count,return,info1,get,total,count,info2,get,total,count,if,info1,get,length,info2,get,length,return,info2,get,length,info1,get,length,if,info1,get,single,wildcards,info2,get,single,wildcards,return,1,else,if,info2,get,single,wildcards,info1,get,single,wildcards,return,1,if,info1,get,uri,vars,info2,get,uri,vars,return,1,else,if,info2,get,uri,vars,info1,get,uri,vars,return,1,return,0
AntPathMatcher -> AntPatternComparator -> @Override 		public int compare(String pattern1, String pattern2);1496837955;Compare two patterns to determine which should match first, i.e. which_is the most specific regarding the current path._@return a negative integer, zero, or a positive integer as pattern1 is_more specific, equally specific, or less specific than pattern2.;@Override_		public int compare(String pattern1, String pattern2) {_			PatternInfo info1 = new PatternInfo(pattern1)__			PatternInfo info2 = new PatternInfo(pattern2)___			if (info1.isLeastSpecific() && info2.isLeastSpecific()) {_				return 0__			}_			else if (info1.isLeastSpecific()) {_				return 1__			}_			else if (info2.isLeastSpecific()) {_				return -1__			}__			boolean pattern1EqualsPath = pattern1.equals(path)__			boolean pattern2EqualsPath = pattern2.equals(path)__			if (pattern1EqualsPath && pattern2EqualsPath) {_				return 0__			}_			else if (pattern1EqualsPath) {_				return -1__			}_			else if (pattern2EqualsPath) {_				return 1__			}__			if (info1.isPrefixPattern() && info2.getDoubleWildcards() == 0) {_				return 1__			}_			else if (info2.isPrefixPattern() && info1.getDoubleWildcards() == 0) {_				return -1__			}__			if (info1.getTotalCount() != info2.getTotalCount()) {_				return info1.getTotalCount() - info2.getTotalCount()__			}__			if (info1.getLength() != info2.getLength()) {_				return info2.getLength() - info1.getLength()__			}__			if (info1.getSingleWildcards() < info2.getSingleWildcards()) {_				return -1__			}_			else if (info2.getSingleWildcards() < info1.getSingleWildcards()) {_				return 1__			}__			if (info1.getUriVars() < info2.getUriVars()) {_				return -1__			}_			else if (info2.getUriVars() < info1.getUriVars()) {_				return 1__			}__			return 0__		};compare,two,patterns,to,determine,which,should,match,first,i,e,which,is,the,most,specific,regarding,the,current,path,return,a,negative,integer,zero,or,a,positive,integer,as,pattern1,is,more,specific,equally,specific,or,less,specific,than,pattern2;override,public,int,compare,string,pattern1,string,pattern2,pattern,info,info1,new,pattern,info,pattern1,pattern,info,info2,new,pattern,info,pattern2,if,info1,is,least,specific,info2,is,least,specific,return,0,else,if,info1,is,least,specific,return,1,else,if,info2,is,least,specific,return,1,boolean,pattern1equals,path,pattern1,equals,path,boolean,pattern2equals,path,pattern2,equals,path,if,pattern1equals,path,pattern2equals,path,return,0,else,if,pattern1equals,path,return,1,else,if,pattern2equals,path,return,1,if,info1,is,prefix,pattern,info2,get,double,wildcards,0,return,1,else,if,info2,is,prefix,pattern,info1,get,double,wildcards,0,return,1,if,info1,get,total,count,info2,get,total,count,return,info1,get,total,count,info2,get,total,count,if,info1,get,length,info2,get,length,return,info2,get,length,info1,get,length,if,info1,get,single,wildcards,info2,get,single,wildcards,return,1,else,if,info2,get,single,wildcards,info1,get,single,wildcards,return,1,if,info1,get,uri,vars,info2,get,uri,vars,return,1,else,if,info2,get,uri,vars,info1,get,uri,vars,return,1,return,0
AntPathMatcher -> AntPatternComparator -> @Override 		public int compare(String pattern1, String pattern2);1498780456;Compare two patterns to determine which should match first, i.e. which_is the most specific regarding the current path._@return a negative integer, zero, or a positive integer as pattern1 is_more specific, equally specific, or less specific than pattern2.;@Override_		public int compare(String pattern1, String pattern2) {_			PatternInfo info1 = new PatternInfo(pattern1)__			PatternInfo info2 = new PatternInfo(pattern2)___			if (info1.isLeastSpecific() && info2.isLeastSpecific()) {_				return 0__			}_			else if (info1.isLeastSpecific()) {_				return 1__			}_			else if (info2.isLeastSpecific()) {_				return -1__			}__			boolean pattern1EqualsPath = pattern1.equals(path)__			boolean pattern2EqualsPath = pattern2.equals(path)__			if (pattern1EqualsPath && pattern2EqualsPath) {_				return 0__			}_			else if (pattern1EqualsPath) {_				return -1__			}_			else if (pattern2EqualsPath) {_				return 1__			}__			if (info1.isPrefixPattern() && info2.getDoubleWildcards() == 0) {_				return 1__			}_			else if (info2.isPrefixPattern() && info1.getDoubleWildcards() == 0) {_				return -1__			}__			if (info1.getTotalCount() != info2.getTotalCount()) {_				return info1.getTotalCount() - info2.getTotalCount()__			}__			if (info1.getLength() != info2.getLength()) {_				return info2.getLength() - info1.getLength()__			}__			if (info1.getSingleWildcards() < info2.getSingleWildcards()) {_				return -1__			}_			else if (info2.getSingleWildcards() < info1.getSingleWildcards()) {_				return 1__			}__			if (info1.getUriVars() < info2.getUriVars()) {_				return -1__			}_			else if (info2.getUriVars() < info1.getUriVars()) {_				return 1__			}__			return 0__		};compare,two,patterns,to,determine,which,should,match,first,i,e,which,is,the,most,specific,regarding,the,current,path,return,a,negative,integer,zero,or,a,positive,integer,as,pattern1,is,more,specific,equally,specific,or,less,specific,than,pattern2;override,public,int,compare,string,pattern1,string,pattern2,pattern,info,info1,new,pattern,info,pattern1,pattern,info,info2,new,pattern,info,pattern2,if,info1,is,least,specific,info2,is,least,specific,return,0,else,if,info1,is,least,specific,return,1,else,if,info2,is,least,specific,return,1,boolean,pattern1equals,path,pattern1,equals,path,boolean,pattern2equals,path,pattern2,equals,path,if,pattern1equals,path,pattern2equals,path,return,0,else,if,pattern1equals,path,return,1,else,if,pattern2equals,path,return,1,if,info1,is,prefix,pattern,info2,get,double,wildcards,0,return,1,else,if,info2,is,prefix,pattern,info1,get,double,wildcards,0,return,1,if,info1,get,total,count,info2,get,total,count,return,info1,get,total,count,info2,get,total,count,if,info1,get,length,info2,get,length,return,info2,get,length,info1,get,length,if,info1,get,single,wildcards,info2,get,single,wildcards,return,1,else,if,info2,get,single,wildcards,info1,get,single,wildcards,return,1,if,info1,get,uri,vars,info2,get,uri,vars,return,1,else,if,info2,get,uri,vars,info1,get,uri,vars,return,1,return,0
AntPathMatcher -> AntPatternComparator -> @Override 		public int compare(String pattern1, String pattern2);1518772998;Compare two patterns to determine which should match first, i.e. which_is the most specific regarding the current path._@return a negative integer, zero, or a positive integer as pattern1 is_more specific, equally specific, or less specific than pattern2.;@Override_		public int compare(String pattern1, String pattern2) {_			PatternInfo info1 = new PatternInfo(pattern1)__			PatternInfo info2 = new PatternInfo(pattern2)___			if (info1.isLeastSpecific() && info2.isLeastSpecific()) {_				return 0__			}_			else if (info1.isLeastSpecific()) {_				return 1__			}_			else if (info2.isLeastSpecific()) {_				return -1__			}__			boolean pattern1EqualsPath = pattern1.equals(path)__			boolean pattern2EqualsPath = pattern2.equals(path)__			if (pattern1EqualsPath && pattern2EqualsPath) {_				return 0__			}_			else if (pattern1EqualsPath) {_				return -1__			}_			else if (pattern2EqualsPath) {_				return 1__			}__			if (info1.isPrefixPattern() && info2.getDoubleWildcards() == 0) {_				return 1__			}_			else if (info2.isPrefixPattern() && info1.getDoubleWildcards() == 0) {_				return -1__			}__			if (info1.getTotalCount() != info2.getTotalCount()) {_				return info1.getTotalCount() - info2.getTotalCount()__			}__			if (info1.getLength() != info2.getLength()) {_				return info2.getLength() - info1.getLength()__			}__			if (info1.getSingleWildcards() < info2.getSingleWildcards()) {_				return -1__			}_			else if (info2.getSingleWildcards() < info1.getSingleWildcards()) {_				return 1__			}__			if (info1.getUriVars() < info2.getUriVars()) {_				return -1__			}_			else if (info2.getUriVars() < info1.getUriVars()) {_				return 1__			}__			return 0__		};compare,two,patterns,to,determine,which,should,match,first,i,e,which,is,the,most,specific,regarding,the,current,path,return,a,negative,integer,zero,or,a,positive,integer,as,pattern1,is,more,specific,equally,specific,or,less,specific,than,pattern2;override,public,int,compare,string,pattern1,string,pattern2,pattern,info,info1,new,pattern,info,pattern1,pattern,info,info2,new,pattern,info,pattern2,if,info1,is,least,specific,info2,is,least,specific,return,0,else,if,info1,is,least,specific,return,1,else,if,info2,is,least,specific,return,1,boolean,pattern1equals,path,pattern1,equals,path,boolean,pattern2equals,path,pattern2,equals,path,if,pattern1equals,path,pattern2equals,path,return,0,else,if,pattern1equals,path,return,1,else,if,pattern2equals,path,return,1,if,info1,is,prefix,pattern,info2,get,double,wildcards,0,return,1,else,if,info2,is,prefix,pattern,info1,get,double,wildcards,0,return,1,if,info1,get,total,count,info2,get,total,count,return,info1,get,total,count,info2,get,total,count,if,info1,get,length,info2,get,length,return,info2,get,length,info1,get,length,if,info1,get,single,wildcards,info2,get,single,wildcards,return,1,else,if,info2,get,single,wildcards,info1,get,single,wildcards,return,1,if,info1,get,uri,vars,info2,get,uri,vars,return,1,else,if,info2,get,uri,vars,info1,get,uri,vars,return,1,return,0
AntPathMatcher -> AntPatternComparator -> @Override 		public int compare(String pattern1, String pattern2);1530174524;Compare two patterns to determine which should match first, i.e. which_is the most specific regarding the current path._@return a negative integer, zero, or a positive integer as pattern1 is_more specific, equally specific, or less specific than pattern2.;@Override_		public int compare(String pattern1, String pattern2) {_			PatternInfo info1 = new PatternInfo(pattern1)__			PatternInfo info2 = new PatternInfo(pattern2)___			if (info1.isLeastSpecific() && info2.isLeastSpecific()) {_				return 0__			}_			else if (info1.isLeastSpecific()) {_				return 1__			}_			else if (info2.isLeastSpecific()) {_				return -1__			}__			boolean pattern1EqualsPath = pattern1.equals(path)__			boolean pattern2EqualsPath = pattern2.equals(path)__			if (pattern1EqualsPath && pattern2EqualsPath) {_				return 0__			}_			else if (pattern1EqualsPath) {_				return -1__			}_			else if (pattern2EqualsPath) {_				return 1__			}__			if (info1.isPrefixPattern() && info2.getDoubleWildcards() == 0) {_				return 1__			}_			else if (info2.isPrefixPattern() && info1.getDoubleWildcards() == 0) {_				return -1__			}__			if (info1.getTotalCount() != info2.getTotalCount()) {_				return info1.getTotalCount() - info2.getTotalCount()__			}__			if (info1.getLength() != info2.getLength()) {_				return info2.getLength() - info1.getLength()__			}__			if (info1.getSingleWildcards() < info2.getSingleWildcards()) {_				return -1__			}_			else if (info2.getSingleWildcards() < info1.getSingleWildcards()) {_				return 1__			}__			if (info1.getUriVars() < info2.getUriVars()) {_				return -1__			}_			else if (info2.getUriVars() < info1.getUriVars()) {_				return 1__			}__			return 0__		};compare,two,patterns,to,determine,which,should,match,first,i,e,which,is,the,most,specific,regarding,the,current,path,return,a,negative,integer,zero,or,a,positive,integer,as,pattern1,is,more,specific,equally,specific,or,less,specific,than,pattern2;override,public,int,compare,string,pattern1,string,pattern2,pattern,info,info1,new,pattern,info,pattern1,pattern,info,info2,new,pattern,info,pattern2,if,info1,is,least,specific,info2,is,least,specific,return,0,else,if,info1,is,least,specific,return,1,else,if,info2,is,least,specific,return,1,boolean,pattern1equals,path,pattern1,equals,path,boolean,pattern2equals,path,pattern2,equals,path,if,pattern1equals,path,pattern2equals,path,return,0,else,if,pattern1equals,path,return,1,else,if,pattern2equals,path,return,1,if,info1,is,prefix,pattern,info2,get,double,wildcards,0,return,1,else,if,info2,is,prefix,pattern,info1,get,double,wildcards,0,return,1,if,info1,get,total,count,info2,get,total,count,return,info1,get,total,count,info2,get,total,count,if,info1,get,length,info2,get,length,return,info2,get,length,info1,get,length,if,info1,get,single,wildcards,info2,get,single,wildcards,return,1,else,if,info2,get,single,wildcards,info1,get,single,wildcards,return,1,if,info1,get,uri,vars,info2,get,uri,vars,return,1,else,if,info2,get,uri,vars,info1,get,uri,vars,return,1,return,0
AntPathMatcher -> AntPatternComparator -> @Override 		public int compare(String pattern1, String pattern2);1530174524;Compare two patterns to determine which should match first, i.e. which_is the most specific regarding the current path._@return a negative integer, zero, or a positive integer as pattern1 is_more specific, equally specific, or less specific than pattern2.;@Override_		public int compare(String pattern1, String pattern2) {_			PatternInfo info1 = new PatternInfo(pattern1)__			PatternInfo info2 = new PatternInfo(pattern2)___			if (info1.isLeastSpecific() && info2.isLeastSpecific()) {_				return 0__			}_			else if (info1.isLeastSpecific()) {_				return 1__			}_			else if (info2.isLeastSpecific()) {_				return -1__			}__			boolean pattern1EqualsPath = pattern1.equals(this.path)__			boolean pattern2EqualsPath = pattern2.equals(this.path)__			if (pattern1EqualsPath && pattern2EqualsPath) {_				return 0__			}_			else if (pattern1EqualsPath) {_				return -1__			}_			else if (pattern2EqualsPath) {_				return 1__			}__			if (info1.isPrefixPattern() && info2.getDoubleWildcards() == 0) {_				return 1__			}_			else if (info2.isPrefixPattern() && info1.getDoubleWildcards() == 0) {_				return -1__			}__			if (info1.getTotalCount() != info2.getTotalCount()) {_				return info1.getTotalCount() - info2.getTotalCount()__			}__			if (info1.getLength() != info2.getLength()) {_				return info2.getLength() - info1.getLength()__			}__			if (info1.getSingleWildcards() < info2.getSingleWildcards()) {_				return -1__			}_			else if (info2.getSingleWildcards() < info1.getSingleWildcards()) {_				return 1__			}__			if (info1.getUriVars() < info2.getUriVars()) {_				return -1__			}_			else if (info2.getUriVars() < info1.getUriVars()) {_				return 1__			}__			return 0__		};compare,two,patterns,to,determine,which,should,match,first,i,e,which,is,the,most,specific,regarding,the,current,path,return,a,negative,integer,zero,or,a,positive,integer,as,pattern1,is,more,specific,equally,specific,or,less,specific,than,pattern2;override,public,int,compare,string,pattern1,string,pattern2,pattern,info,info1,new,pattern,info,pattern1,pattern,info,info2,new,pattern,info,pattern2,if,info1,is,least,specific,info2,is,least,specific,return,0,else,if,info1,is,least,specific,return,1,else,if,info2,is,least,specific,return,1,boolean,pattern1equals,path,pattern1,equals,this,path,boolean,pattern2equals,path,pattern2,equals,this,path,if,pattern1equals,path,pattern2equals,path,return,0,else,if,pattern1equals,path,return,1,else,if,pattern2equals,path,return,1,if,info1,is,prefix,pattern,info2,get,double,wildcards,0,return,1,else,if,info2,is,prefix,pattern,info1,get,double,wildcards,0,return,1,if,info1,get,total,count,info2,get,total,count,return,info1,get,total,count,info2,get,total,count,if,info1,get,length,info2,get,length,return,info2,get,length,info1,get,length,if,info1,get,single,wildcards,info2,get,single,wildcards,return,1,else,if,info2,get,single,wildcards,info1,get,single,wildcards,return,1,if,info1,get,uri,vars,info2,get,uri,vars,return,1,else,if,info2,get,uri,vars,info1,get,uri,vars,return,1,return,0
AntPathMatcher -> AntPatternComparator -> @Override 		public int compare(String pattern1, String pattern2);1535316501;Compare two patterns to determine which should match first, i.e. which_is the most specific regarding the current path._@return a negative integer, zero, or a positive integer as pattern1 is_more specific, equally specific, or less specific than pattern2.;@Override_		public int compare(String pattern1, String pattern2) {_			PatternInfo info1 = new PatternInfo(pattern1)__			PatternInfo info2 = new PatternInfo(pattern2)___			if (info1.isLeastSpecific() && info2.isLeastSpecific()) {_				return 0__			}_			else if (info1.isLeastSpecific()) {_				return 1__			}_			else if (info2.isLeastSpecific()) {_				return -1__			}__			boolean pattern1EqualsPath = pattern1.equals(this.path)__			boolean pattern2EqualsPath = pattern2.equals(this.path)__			if (pattern1EqualsPath && pattern2EqualsPath) {_				return 0__			}_			else if (pattern1EqualsPath) {_				return -1__			}_			else if (pattern2EqualsPath) {_				return 1__			}__			if (info1.isPrefixPattern() && info2.getDoubleWildcards() == 0) {_				return 1__			}_			else if (info2.isPrefixPattern() && info1.getDoubleWildcards() == 0) {_				return -1__			}__			if (info1.getTotalCount() != info2.getTotalCount()) {_				return info1.getTotalCount() - info2.getTotalCount()__			}__			if (info1.getLength() != info2.getLength()) {_				return info2.getLength() - info1.getLength()__			}__			if (info1.getSingleWildcards() < info2.getSingleWildcards()) {_				return -1__			}_			else if (info2.getSingleWildcards() < info1.getSingleWildcards()) {_				return 1__			}__			if (info1.getUriVars() < info2.getUriVars()) {_				return -1__			}_			else if (info2.getUriVars() < info1.getUriVars()) {_				return 1__			}__			return 0__		};compare,two,patterns,to,determine,which,should,match,first,i,e,which,is,the,most,specific,regarding,the,current,path,return,a,negative,integer,zero,or,a,positive,integer,as,pattern1,is,more,specific,equally,specific,or,less,specific,than,pattern2;override,public,int,compare,string,pattern1,string,pattern2,pattern,info,info1,new,pattern,info,pattern1,pattern,info,info2,new,pattern,info,pattern2,if,info1,is,least,specific,info2,is,least,specific,return,0,else,if,info1,is,least,specific,return,1,else,if,info2,is,least,specific,return,1,boolean,pattern1equals,path,pattern1,equals,this,path,boolean,pattern2equals,path,pattern2,equals,this,path,if,pattern1equals,path,pattern2equals,path,return,0,else,if,pattern1equals,path,return,1,else,if,pattern2equals,path,return,1,if,info1,is,prefix,pattern,info2,get,double,wildcards,0,return,1,else,if,info2,is,prefix,pattern,info1,get,double,wildcards,0,return,1,if,info1,get,total,count,info2,get,total,count,return,info1,get,total,count,info2,get,total,count,if,info1,get,length,info2,get,length,return,info2,get,length,info1,get,length,if,info1,get,single,wildcards,info2,get,single,wildcards,return,1,else,if,info2,get,single,wildcards,info1,get,single,wildcards,return,1,if,info1,get,uri,vars,info2,get,uri,vars,return,1,else,if,info2,get,uri,vars,info1,get,uri,vars,return,1,return,0
AntPathMatcher -> public void setTrimTokens(boolean trimTokens);1362408075;Whether to trim tokenized paths and patterns.;public void setTrimTokens(boolean trimTokens) {_		this.trimTokens  = trimTokens__	};whether,to,trim,tokenized,paths,and,patterns;public,void,set,trim,tokens,boolean,trim,tokens,this,trim,tokens,trim,tokens
AntPathMatcher -> public void setTrimTokens(boolean trimTokens);1368482696;Whether to trim tokenized paths and patterns.;public void setTrimTokens(boolean trimTokens) {_		this.trimTokens  = trimTokens__	};whether,to,trim,tokenized,paths,and,patterns;public,void,set,trim,tokens,boolean,trim,tokens,this,trim,tokens,trim,tokens
AntPathMatcher -> public void setTrimTokens(boolean trimTokens);1377725408;Whether to trim tokenized paths and patterns.;public void setTrimTokens(boolean trimTokens) {_		this.trimTokens  = trimTokens__	};whether,to,trim,tokenized,paths,and,patterns;public,void,set,trim,tokens,boolean,trim,tokens,this,trim,tokens,trim,tokens
AntPathMatcher -> public void setTrimTokens(boolean trimTokens);1377735685;Whether to trim tokenized paths and patterns.;public void setTrimTokens(boolean trimTokens) {_		this.trimTokens  = trimTokens__	};whether,to,trim,tokenized,paths,and,patterns;public,void,set,trim,tokens,boolean,trim,tokens,this,trim,tokens,trim,tokens
AntPathMatcher -> public void setTrimTokens(boolean trimTokens);1383090798;Specify whether to trim tokenized paths and patterns._Default is {@code true}.;public void setTrimTokens(boolean trimTokens) {_		this.trimTokens  = trimTokens__	};specify,whether,to,trim,tokenized,paths,and,patterns,default,is,code,true;public,void,set,trim,tokens,boolean,trim,tokens,this,trim,tokens,trim,tokens
AntPathMatcher -> public void setTrimTokens(boolean trimTokens);1383157688;Specify whether to trim tokenized paths and patterns._Default is {@code true}.;public void setTrimTokens(boolean trimTokens) {_		this.trimTokens  = trimTokens__	};specify,whether,to,trim,tokenized,paths,and,patterns,default,is,code,true;public,void,set,trim,tokens,boolean,trim,tokens,this,trim,tokens,trim,tokens
AntPathMatcher -> public void setTrimTokens(boolean trimTokens);1385501137;Specify whether to trim tokenized paths and patterns._Default is {@code true}.;public void setTrimTokens(boolean trimTokens) {_		this.trimTokens  = trimTokens__	};specify,whether,to,trim,tokenized,paths,and,patterns,default,is,code,true;public,void,set,trim,tokens,boolean,trim,tokens,this,trim,tokens,trim,tokens
AntPathMatcher -> public void setTrimTokens(boolean trimTokens);1388766826;Specify whether to trim tokenized paths and patterns._Default is {@code true}.;public void setTrimTokens(boolean trimTokens) {_		this.trimTokens = trimTokens__	};specify,whether,to,trim,tokenized,paths,and,patterns,default,is,code,true;public,void,set,trim,tokens,boolean,trim,tokens,this,trim,tokens,trim,tokens
AntPathMatcher -> public void setTrimTokens(boolean trimTokens);1402512669;Specify whether to trim tokenized paths and patterns._Default is {@code true}.;public void setTrimTokens(boolean trimTokens) {_		this.trimTokens = trimTokens__	};specify,whether,to,trim,tokenized,paths,and,patterns,default,is,code,true;public,void,set,trim,tokens,boolean,trim,tokens,this,trim,tokens,trim,tokens
AntPathMatcher -> public void setTrimTokens(boolean trimTokens);1402512669;Specify whether to trim tokenized paths and patterns._Default is {@code true}.;public void setTrimTokens(boolean trimTokens) {_		this.trimTokens = trimTokens__	};specify,whether,to,trim,tokenized,paths,and,patterns,default,is,code,true;public,void,set,trim,tokens,boolean,trim,tokens,this,trim,tokens,trim,tokens
AntPathMatcher -> public void setTrimTokens(boolean trimTokens);1402512669;Specify whether to trim tokenized paths and patterns._Default is {@code true}.;public void setTrimTokens(boolean trimTokens) {_		this.trimTokens = trimTokens__	};specify,whether,to,trim,tokenized,paths,and,patterns,default,is,code,true;public,void,set,trim,tokens,boolean,trim,tokens,this,trim,tokens,trim,tokens
AntPathMatcher -> public void setTrimTokens(boolean trimTokens);1405378164;Specify whether to trim tokenized paths and patterns._Default is {@code true}.;public void setTrimTokens(boolean trimTokens) {_		this.trimTokens = trimTokens__	};specify,whether,to,trim,tokenized,paths,and,patterns,default,is,code,true;public,void,set,trim,tokens,boolean,trim,tokens,this,trim,tokens,trim,tokens
AntPathMatcher -> public void setTrimTokens(boolean trimTokens);1405378165;Specify whether to trim tokenized paths and patterns._Default is {@code true}.;public void setTrimTokens(boolean trimTokens) {_		this.trimTokens = trimTokens__	};specify,whether,to,trim,tokenized,paths,and,patterns,default,is,code,true;public,void,set,trim,tokens,boolean,trim,tokens,this,trim,tokens,trim,tokens
AntPathMatcher -> public void setTrimTokens(boolean trimTokens);1405696918;Specify whether to trim tokenized paths and patterns._Default is {@code true}.;public void setTrimTokens(boolean trimTokens) {_		this.trimTokens = trimTokens__	};specify,whether,to,trim,tokenized,paths,and,patterns,default,is,code,true;public,void,set,trim,tokens,boolean,trim,tokens,this,trim,tokens,trim,tokens
AntPathMatcher -> public void setTrimTokens(boolean trimTokens);1409784938;Specify whether to trim tokenized paths and patterns._Default is {@code true}.;public void setTrimTokens(boolean trimTokens) {_		this.trimTokens = trimTokens__	};specify,whether,to,trim,tokenized,paths,and,patterns,default,is,code,true;public,void,set,trim,tokens,boolean,trim,tokens,this,trim,tokens,trim,tokens
AntPathMatcher -> public void setTrimTokens(boolean trimTokens);1412083966;Specify whether to trim tokenized paths and patterns._Default is {@code true}.;public void setTrimTokens(boolean trimTokens) {_		this.trimTokens = trimTokens__	};specify,whether,to,trim,tokenized,paths,and,patterns,default,is,code,true;public,void,set,trim,tokens,boolean,trim,tokens,this,trim,tokens,trim,tokens
AntPathMatcher -> public void setTrimTokens(boolean trimTokens);1412101078;Specify whether to trim tokenized paths and patterns._Default is {@code true}.;public void setTrimTokens(boolean trimTokens) {_		this.trimTokens = trimTokens__	};specify,whether,to,trim,tokenized,paths,and,patterns,default,is,code,true;public,void,set,trim,tokens,boolean,trim,tokens,this,trim,tokens,trim,tokens
AntPathMatcher -> public void setTrimTokens(boolean trimTokens);1431086052;Specify whether to trim tokenized paths and patterns._<p>Default is {@code true}.;public void setTrimTokens(boolean trimTokens) {_		this.trimTokens = trimTokens__	};specify,whether,to,trim,tokenized,paths,and,patterns,p,default,is,code,true;public,void,set,trim,tokens,boolean,trim,tokens,this,trim,tokens,trim,tokens
AntPathMatcher -> public void setTrimTokens(boolean trimTokens);1431178173;Specify whether to trim tokenized paths and patterns._<p>Default is {@code true}.;public void setTrimTokens(boolean trimTokens) {_		this.trimTokens = trimTokens__	};specify,whether,to,trim,tokenized,paths,and,patterns,p,default,is,code,true;public,void,set,trim,tokens,boolean,trim,tokens,this,trim,tokens,trim,tokens
AntPathMatcher -> public void setTrimTokens(boolean trimTokens);1434572159;Specify whether to trim tokenized paths and patterns._<p>Default is {@code true}.;public void setTrimTokens(boolean trimTokens) {_		this.trimTokens = trimTokens__	};specify,whether,to,trim,tokenized,paths,and,patterns,p,default,is,code,true;public,void,set,trim,tokens,boolean,trim,tokens,this,trim,tokens,trim,tokens
AntPathMatcher -> public void setTrimTokens(boolean trimTokens);1435239719;Specify whether to trim tokenized paths and patterns._<p>Default is {@code true}.;public void setTrimTokens(boolean trimTokens) {_		this.trimTokens = trimTokens__	};specify,whether,to,trim,tokenized,paths,and,patterns,p,default,is,code,true;public,void,set,trim,tokens,boolean,trim,tokens,this,trim,tokens,trim,tokens
AntPathMatcher -> public void setTrimTokens(boolean trimTokens);1438166321;Specify whether to trim tokenized paths and patterns._<p>Default is {@code true}.;public void setTrimTokens(boolean trimTokens) {_		this.trimTokens = trimTokens__	};specify,whether,to,trim,tokenized,paths,and,patterns,p,default,is,code,true;public,void,set,trim,tokens,boolean,trim,tokens,this,trim,tokens,trim,tokens
AntPathMatcher -> public void setTrimTokens(boolean trimTokens);1455100778;Specify whether to trim tokenized paths and patterns._<p>Default is {@code true}.;public void setTrimTokens(boolean trimTokens) {_		this.trimTokens = trimTokens__	};specify,whether,to,trim,tokenized,paths,and,patterns,p,default,is,code,true;public,void,set,trim,tokens,boolean,trim,tokens,this,trim,tokens,trim,tokens
AntPathMatcher -> public void setTrimTokens(boolean trimTokens);1455850198;Specify whether to trim tokenized paths and patterns._<p>Default is {@code true}.;public void setTrimTokens(boolean trimTokens) {_		this.trimTokens = trimTokens__	};specify,whether,to,trim,tokenized,paths,and,patterns,p,default,is,code,true;public,void,set,trim,tokens,boolean,trim,tokens,this,trim,tokens,trim,tokens
AntPathMatcher -> public void setTrimTokens(boolean trimTokens);1460754629;Specify whether to trim tokenized paths and patterns._<p>Default is {@code true}.;public void setTrimTokens(boolean trimTokens) {_		this.trimTokens = trimTokens__	};specify,whether,to,trim,tokenized,paths,and,patterns,p,default,is,code,true;public,void,set,trim,tokens,boolean,trim,tokens,this,trim,tokens,trim,tokens
AntPathMatcher -> public void setTrimTokens(boolean trimTokens);1462393686;Specify whether to trim tokenized paths and patterns._<p>Default is {@code true}.;public void setTrimTokens(boolean trimTokens) {_		this.trimTokens = trimTokens__	};specify,whether,to,trim,tokenized,paths,and,patterns,p,default,is,code,true;public,void,set,trim,tokens,boolean,trim,tokens,this,trim,tokens,trim,tokens
AntPathMatcher -> public void setTrimTokens(boolean trimTokens);1467730834;Specify whether to trim tokenized paths and patterns._<p>Default is {@code true}.;public void setTrimTokens(boolean trimTokens) {_		this.trimTokens = trimTokens__	};specify,whether,to,trim,tokenized,paths,and,patterns,p,default,is,code,true;public,void,set,trim,tokens,boolean,trim,tokens,this,trim,tokens,trim,tokens
AntPathMatcher -> public void setTrimTokens(boolean trimTokens);1468327638;Specify whether to trim tokenized paths and patterns._<p>Default is {@code false}.;public void setTrimTokens(boolean trimTokens) {_		this.trimTokens = trimTokens__	};specify,whether,to,trim,tokenized,paths,and,patterns,p,default,is,code,false;public,void,set,trim,tokens,boolean,trim,tokens,this,trim,tokens,trim,tokens
AntPathMatcher -> public void setTrimTokens(boolean trimTokens);1472808958;Specify whether to trim tokenized paths and patterns._<p>Default is {@code false}.;public void setTrimTokens(boolean trimTokens) {_		this.trimTokens = trimTokens__	};specify,whether,to,trim,tokenized,paths,and,patterns,p,default,is,code,false;public,void,set,trim,tokens,boolean,trim,tokens,this,trim,tokens,trim,tokens
AntPathMatcher -> public void setTrimTokens(boolean trimTokens);1493317597;Specify whether to trim tokenized paths and patterns._<p>Default is {@code false}.;public void setTrimTokens(boolean trimTokens) {_		this.trimTokens = trimTokens__	};specify,whether,to,trim,tokenized,paths,and,patterns,p,default,is,code,false;public,void,set,trim,tokens,boolean,trim,tokens,this,trim,tokens,trim,tokens
AntPathMatcher -> public void setTrimTokens(boolean trimTokens);1493321510;Specify whether to trim tokenized paths and patterns._<p>Default is {@code false}.;public void setTrimTokens(boolean trimTokens) {_		this.trimTokens = trimTokens__	};specify,whether,to,trim,tokenized,paths,and,patterns,p,default,is,code,false;public,void,set,trim,tokens,boolean,trim,tokens,this,trim,tokens,trim,tokens
AntPathMatcher -> public void setTrimTokens(boolean trimTokens);1496259743;Specify whether to trim tokenized paths and patterns._<p>Default is {@code false}.;public void setTrimTokens(boolean trimTokens) {_		this.trimTokens = trimTokens__	};specify,whether,to,trim,tokenized,paths,and,patterns,p,default,is,code,false;public,void,set,trim,tokens,boolean,trim,tokens,this,trim,tokens,trim,tokens
AntPathMatcher -> public void setTrimTokens(boolean trimTokens);1496837955;Specify whether to trim tokenized paths and patterns._<p>Default is {@code false}.;public void setTrimTokens(boolean trimTokens) {_		this.trimTokens = trimTokens__	};specify,whether,to,trim,tokenized,paths,and,patterns,p,default,is,code,false;public,void,set,trim,tokens,boolean,trim,tokens,this,trim,tokens,trim,tokens
AntPathMatcher -> public void setTrimTokens(boolean trimTokens);1498780456;Specify whether to trim tokenized paths and patterns._<p>Default is {@code false}.;public void setTrimTokens(boolean trimTokens) {_		this.trimTokens = trimTokens__	};specify,whether,to,trim,tokenized,paths,and,patterns,p,default,is,code,false;public,void,set,trim,tokens,boolean,trim,tokens,this,trim,tokens,trim,tokens
AntPathMatcher -> public void setTrimTokens(boolean trimTokens);1518772998;Specify whether to trim tokenized paths and patterns._<p>Default is {@code false}.;public void setTrimTokens(boolean trimTokens) {_		this.trimTokens = trimTokens__	};specify,whether,to,trim,tokenized,paths,and,patterns,p,default,is,code,false;public,void,set,trim,tokens,boolean,trim,tokens,this,trim,tokens,trim,tokens
AntPathMatcher -> public void setTrimTokens(boolean trimTokens);1530174524;Specify whether to trim tokenized paths and patterns._<p>Default is {@code false}.;public void setTrimTokens(boolean trimTokens) {_		this.trimTokens = trimTokens__	};specify,whether,to,trim,tokenized,paths,and,patterns,p,default,is,code,false;public,void,set,trim,tokens,boolean,trim,tokens,this,trim,tokens,trim,tokens
AntPathMatcher -> public void setTrimTokens(boolean trimTokens);1530174524;Specify whether to trim tokenized paths and patterns._<p>Default is {@code false}.;public void setTrimTokens(boolean trimTokens) {_		this.trimTokens = trimTokens__	};specify,whether,to,trim,tokenized,paths,and,patterns,p,default,is,code,false;public,void,set,trim,tokens,boolean,trim,tokens,this,trim,tokens,trim,tokens
AntPathMatcher -> public void setTrimTokens(boolean trimTokens);1535316501;Specify whether to trim tokenized paths and patterns._<p>Default is {@code false}.;public void setTrimTokens(boolean trimTokens) {_		this.trimTokens = trimTokens__	};specify,whether,to,trim,tokenized,paths,and,patterns,p,default,is,code,false;public,void,set,trim,tokens,boolean,trim,tokens,this,trim,tokens,trim,tokens
AntPathMatcher -> public void setPathSeparator(@Nullable String pathSeparator);1496837955;Set the path separator to use for pattern parsing._<p>Default is "/", as in Ant.;public void setPathSeparator(@Nullable String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(this.pathSeparator)__	};set,the,path,separator,to,use,for,pattern,parsing,p,default,is,as,in,ant;public,void,set,path,separator,nullable,string,path,separator,this,path,separator,path,separator,null,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,this,path,separator
AntPathMatcher -> public void setPathSeparator(@Nullable String pathSeparator);1498780456;Set the path separator to use for pattern parsing._<p>Default is "/", as in Ant.;public void setPathSeparator(@Nullable String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(this.pathSeparator)__	};set,the,path,separator,to,use,for,pattern,parsing,p,default,is,as,in,ant;public,void,set,path,separator,nullable,string,path,separator,this,path,separator,path,separator,null,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,this,path,separator
AntPathMatcher -> public void setPathSeparator(@Nullable String pathSeparator);1518772998;Set the path separator to use for pattern parsing._<p>Default is "/", as in Ant.;public void setPathSeparator(@Nullable String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(this.pathSeparator)__	};set,the,path,separator,to,use,for,pattern,parsing,p,default,is,as,in,ant;public,void,set,path,separator,nullable,string,path,separator,this,path,separator,path,separator,null,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,this,path,separator
AntPathMatcher -> public void setPathSeparator(@Nullable String pathSeparator);1530174524;Set the path separator to use for pattern parsing._<p>Default is "/", as in Ant.;public void setPathSeparator(@Nullable String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(this.pathSeparator)__	};set,the,path,separator,to,use,for,pattern,parsing,p,default,is,as,in,ant;public,void,set,path,separator,nullable,string,path,separator,this,path,separator,path,separator,null,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,this,path,separator
AntPathMatcher -> public void setPathSeparator(@Nullable String pathSeparator);1530174524;Set the path separator to use for pattern parsing._<p>Default is "/", as in Ant.;public void setPathSeparator(@Nullable String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(this.pathSeparator)__	};set,the,path,separator,to,use,for,pattern,parsing,p,default,is,as,in,ant;public,void,set,path,separator,nullable,string,path,separator,this,path,separator,path,separator,null,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,this,path,separator
AntPathMatcher -> public void setPathSeparator(@Nullable String pathSeparator);1535316501;Set the path separator to use for pattern parsing._<p>Default is "/", as in Ant.;public void setPathSeparator(@Nullable String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(this.pathSeparator)__	};set,the,path,separator,to,use,for,pattern,parsing,p,default,is,as,in,ant;public,void,set,path,separator,nullable,string,path,separator,this,path,separator,path,separator,null,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,this,path,separator
AntPathMatcher -> public AntPathMatcher();1405378164;Create a new AntPathMatcher with the default Ant path separator "/".;public AntPathMatcher() {__	};create,a,new,ant,path,matcher,with,the,default,ant,path,separator;public,ant,path,matcher
AntPathMatcher -> public AntPathMatcher();1405378165;Create a new instance with the {@link #DEFAULT_PATH_SEPARATOR}.;public AntPathMatcher() {__	};create,a,new,instance,with,the,link;public,ant,path,matcher
AntPathMatcher -> public AntPathMatcher();1405696918;Create a new instance with the {@link #DEFAULT_PATH_SEPARATOR}.;public AntPathMatcher() {__	};create,a,new,instance,with,the,link;public,ant,path,matcher
AntPathMatcher -> public AntPathMatcher();1409784938;Create a new instance with the {@link #DEFAULT_PATH_SEPARATOR}.;public AntPathMatcher() {_	};create,a,new,instance,with,the,link;public,ant,path,matcher
AntPathMatcher -> public AntPathMatcher();1412083966;Create a new instance with the {@link #DEFAULT_PATH_SEPARATOR}.;public AntPathMatcher() {_	};create,a,new,instance,with,the,link;public,ant,path,matcher
AntPathMatcher -> public AntPathMatcher();1412101078;Create a new instance with the {@link #DEFAULT_PATH_SEPARATOR}.;public AntPathMatcher() {_		this.pathSeparator = DEFAULT_PATH_SEPARATOR__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(DEFAULT_PATH_SEPARATOR)__	};create,a,new,instance,with,the,link;public,ant,path,matcher,this,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache
AntPathMatcher -> public AntPathMatcher();1431086052;Create a new instance with the {@link #DEFAULT_PATH_SEPARATOR}.;public AntPathMatcher() {_		this.pathSeparator = DEFAULT_PATH_SEPARATOR__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(DEFAULT_PATH_SEPARATOR)__	};create,a,new,instance,with,the,link;public,ant,path,matcher,this,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache
AntPathMatcher -> public AntPathMatcher();1431178173;Create a new instance with the {@link #DEFAULT_PATH_SEPARATOR}.;public AntPathMatcher() {_		this.pathSeparator = DEFAULT_PATH_SEPARATOR__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(DEFAULT_PATH_SEPARATOR)__	};create,a,new,instance,with,the,link;public,ant,path,matcher,this,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache
AntPathMatcher -> public AntPathMatcher();1434572159;Create a new instance with the {@link #DEFAULT_PATH_SEPARATOR}.;public AntPathMatcher() {_		this.pathSeparator = DEFAULT_PATH_SEPARATOR__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(DEFAULT_PATH_SEPARATOR)__	};create,a,new,instance,with,the,link;public,ant,path,matcher,this,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache
AntPathMatcher -> public AntPathMatcher();1435239719;Create a new instance with the {@link #DEFAULT_PATH_SEPARATOR}.;public AntPathMatcher() {_		this.pathSeparator = DEFAULT_PATH_SEPARATOR__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(DEFAULT_PATH_SEPARATOR)__	};create,a,new,instance,with,the,link;public,ant,path,matcher,this,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache
AntPathMatcher -> public AntPathMatcher();1438166321;Create a new instance with the {@link #DEFAULT_PATH_SEPARATOR}.;public AntPathMatcher() {_		this.pathSeparator = DEFAULT_PATH_SEPARATOR__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(DEFAULT_PATH_SEPARATOR)__	};create,a,new,instance,with,the,link;public,ant,path,matcher,this,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache
AntPathMatcher -> public AntPathMatcher();1455100778;Create a new instance with the {@link #DEFAULT_PATH_SEPARATOR}.;public AntPathMatcher() {_		this.pathSeparator = DEFAULT_PATH_SEPARATOR__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(DEFAULT_PATH_SEPARATOR)__	};create,a,new,instance,with,the,link;public,ant,path,matcher,this,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache
AntPathMatcher -> public AntPathMatcher();1455850198;Create a new instance with the {@link #DEFAULT_PATH_SEPARATOR}.;public AntPathMatcher() {_		this.pathSeparator = DEFAULT_PATH_SEPARATOR__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(DEFAULT_PATH_SEPARATOR)__	};create,a,new,instance,with,the,link;public,ant,path,matcher,this,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache
AntPathMatcher -> public AntPathMatcher();1460754629;Create a new instance with the {@link #DEFAULT_PATH_SEPARATOR}.;public AntPathMatcher() {_		this.pathSeparator = DEFAULT_PATH_SEPARATOR__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(DEFAULT_PATH_SEPARATOR)__	};create,a,new,instance,with,the,link;public,ant,path,matcher,this,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache
AntPathMatcher -> public AntPathMatcher();1462393686;Create a new instance with the {@link #DEFAULT_PATH_SEPARATOR}.;public AntPathMatcher() {_		this.pathSeparator = DEFAULT_PATH_SEPARATOR__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(DEFAULT_PATH_SEPARATOR)__	};create,a,new,instance,with,the,link;public,ant,path,matcher,this,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache
AntPathMatcher -> public AntPathMatcher();1467730834;Create a new instance with the {@link #DEFAULT_PATH_SEPARATOR}.;public AntPathMatcher() {_		this.pathSeparator = DEFAULT_PATH_SEPARATOR__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(DEFAULT_PATH_SEPARATOR)__	};create,a,new,instance,with,the,link;public,ant,path,matcher,this,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache
AntPathMatcher -> public AntPathMatcher();1468327638;Create a new instance with the {@link #DEFAULT_PATH_SEPARATOR}.;public AntPathMatcher() {_		this.pathSeparator = DEFAULT_PATH_SEPARATOR__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(DEFAULT_PATH_SEPARATOR)__	};create,a,new,instance,with,the,link;public,ant,path,matcher,this,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache
AntPathMatcher -> public AntPathMatcher();1472808958;Create a new instance with the {@link #DEFAULT_PATH_SEPARATOR}.;public AntPathMatcher() {_		this.pathSeparator = DEFAULT_PATH_SEPARATOR__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(DEFAULT_PATH_SEPARATOR)__	};create,a,new,instance,with,the,link;public,ant,path,matcher,this,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache
AntPathMatcher -> public AntPathMatcher();1493317597;Create a new instance with the {@link #DEFAULT_PATH_SEPARATOR}.;public AntPathMatcher() {_		this.pathSeparator = DEFAULT_PATH_SEPARATOR__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(DEFAULT_PATH_SEPARATOR)__	};create,a,new,instance,with,the,link;public,ant,path,matcher,this,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache
AntPathMatcher -> public AntPathMatcher();1493321510;Create a new instance with the {@link #DEFAULT_PATH_SEPARATOR}.;public AntPathMatcher() {_		this.pathSeparator = DEFAULT_PATH_SEPARATOR__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(DEFAULT_PATH_SEPARATOR)__	};create,a,new,instance,with,the,link;public,ant,path,matcher,this,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache
AntPathMatcher -> public AntPathMatcher();1496259743;Create a new instance with the {@link #DEFAULT_PATH_SEPARATOR}.;public AntPathMatcher() {_		this.pathSeparator = DEFAULT_PATH_SEPARATOR__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(DEFAULT_PATH_SEPARATOR)__	};create,a,new,instance,with,the,link;public,ant,path,matcher,this,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache
AntPathMatcher -> public AntPathMatcher();1496837955;Create a new instance with the {@link #DEFAULT_PATH_SEPARATOR}.;public AntPathMatcher() {_		this.pathSeparator = DEFAULT_PATH_SEPARATOR__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(DEFAULT_PATH_SEPARATOR)__	};create,a,new,instance,with,the,link;public,ant,path,matcher,this,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache
AntPathMatcher -> public AntPathMatcher();1498780456;Create a new instance with the {@link #DEFAULT_PATH_SEPARATOR}.;public AntPathMatcher() {_		this.pathSeparator = DEFAULT_PATH_SEPARATOR__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(DEFAULT_PATH_SEPARATOR)__	};create,a,new,instance,with,the,link;public,ant,path,matcher,this,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache
AntPathMatcher -> public AntPathMatcher();1518772998;Create a new instance with the {@link #DEFAULT_PATH_SEPARATOR}.;public AntPathMatcher() {_		this.pathSeparator = DEFAULT_PATH_SEPARATOR__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(DEFAULT_PATH_SEPARATOR)__	};create,a,new,instance,with,the,link;public,ant,path,matcher,this,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache
AntPathMatcher -> public AntPathMatcher();1530174524;Create a new instance with the {@link #DEFAULT_PATH_SEPARATOR}.;public AntPathMatcher() {_		this.pathSeparator = DEFAULT_PATH_SEPARATOR__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(DEFAULT_PATH_SEPARATOR)__	};create,a,new,instance,with,the,link;public,ant,path,matcher,this,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache
AntPathMatcher -> public AntPathMatcher();1530174524;Create a new instance with the {@link #DEFAULT_PATH_SEPARATOR}.;public AntPathMatcher() {_		this.pathSeparator = DEFAULT_PATH_SEPARATOR__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(DEFAULT_PATH_SEPARATOR)__	};create,a,new,instance,with,the,link;public,ant,path,matcher,this,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache
AntPathMatcher -> public AntPathMatcher();1535316501;Create a new instance with the {@link #DEFAULT_PATH_SEPARATOR}.;public AntPathMatcher() {_		this.pathSeparator = DEFAULT_PATH_SEPARATOR__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(DEFAULT_PATH_SEPARATOR)__	};create,a,new,instance,with,the,link;public,ant,path,matcher,this,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache
AntPathMatcher -> @Override 	public Comparator<String> getPatternComparator(String path);1356735495;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of explicitness._<p>The returned {@code Comparator} will {@linkplain java.util.Collections#sort(java.util.List,_java.util.Comparator) sort} a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns: <ol> <li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li> </ol> the returned comparator will sort this_list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path is {@code /hotels/2},_the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;@Override_	public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,the,returned,code,comparator,will,linkplain,java,util,collections,sort,java,util,list,java,util,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;override,public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> @Override 	public Comparator<String> getPatternComparator(String path);1368482696;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of explicitness._<p>The returned {@code Comparator} will {@linkplain java.util.Collections#sort(java.util.List,_java.util.Comparator) sort} a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns: <ol> <li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li> </ol> the returned comparator will sort this_list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path is {@code /hotels/2},_the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;@Override_	public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,the,returned,code,comparator,will,linkplain,java,util,collections,sort,java,util,list,java,util,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;override,public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> @Override 	public Comparator<String> getPatternComparator(String path);1377725408;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of explicitness._<p>The returned {@code Comparator} will {@linkplain java.util.Collections#sort(java.util.List,_java.util.Comparator) sort} a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns: <ol> <li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li> </ol> the returned comparator will sort this_list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path is {@code /hotels/2},_the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;@Override_	public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,the,returned,code,comparator,will,linkplain,java,util,collections,sort,java,util,list,java,util,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;override,public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> @Override 	public Comparator<String> getPatternComparator(String path);1377735685;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of explicitness._<p>The returned {@code Comparator} will {@linkplain java.util.Collections#sort(java.util.List,_java.util.Comparator) sort} a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns: <ol> <li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li> </ol> the returned comparator will sort this_list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path is {@code /hotels/2},_the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;@Override_	public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,the,returned,code,comparator,will,linkplain,java,util,collections,sort,java,util,list,java,util,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;override,public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> @Override 	public Comparator<String> getPatternComparator(String path);1383090798;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of explicitness._<p>The returned {@code Comparator} will {@linkplain java.util.Collections#sort(java.util.List,_java.util.Comparator) sort} a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns: <ol> <li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li> </ol> the returned comparator will sort this_list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path is {@code /hotels/2},_the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;@Override_	public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,the,returned,code,comparator,will,linkplain,java,util,collections,sort,java,util,list,java,util,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;override,public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> @Override 	public Comparator<String> getPatternComparator(String path);1383157688;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of explicitness._<p>The returned {@code Comparator} will {@linkplain java.util.Collections#sort(java.util.List,_java.util.Comparator) sort} a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns: <ol> <li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li> </ol> the returned comparator will sort this_list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path is {@code /hotels/2},_the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;@Override_	public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,the,returned,code,comparator,will,linkplain,java,util,collections,sort,java,util,list,java,util,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;override,public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> @Override 	public Comparator<String> getPatternComparator(String path);1385501137;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of explicitness._<p>The returned {@code Comparator} will {@linkplain java.util.Collections#sort(java.util.List,_java.util.Comparator) sort} a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns: <ol> <li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li> </ol> the returned comparator will sort this_list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path is {@code /hotels/2},_the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;@Override_	public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,the,returned,code,comparator,will,linkplain,java,util,collections,sort,java,util,list,java,util,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;override,public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> @Override 	public Comparator<String> getPatternComparator(String path);1388766826;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of explicitness._<p>The returned {@code Comparator} will {@linkplain java.util.Collections#sort(java.util.List,_java.util.Comparator) sort} a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns: <ol> <li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li> </ol> the returned comparator will sort this_list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path is {@code /hotels/2},_the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;@Override_	public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,the,returned,code,comparator,will,linkplain,java,util,collections,sort,java,util,list,java,util,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;override,public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> @Override 	public Comparator<String> getPatternComparator(String path);1402512669;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of explicitness._<p>The returned {@code Comparator} will {@linkplain java.util.Collections#sort(java.util.List,_java.util.Comparator) sort} a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns: <ol> <li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li> </ol> the returned comparator will sort this_list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path is {@code /hotels/2},_the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;@Override_	public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,the,returned,code,comparator,will,linkplain,java,util,collections,sort,java,util,list,java,util,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;override,public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> @Override 	public Comparator<String> getPatternComparator(String path);1402512669;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of explicitness._<p>The returned {@code Comparator} will {@linkplain java.util.Collections#sort(java.util.List,_java.util.Comparator) sort} a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns: <ol> <li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li> </ol> the returned comparator will sort this_list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path is {@code /hotels/2},_the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;@Override_	public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,the,returned,code,comparator,will,linkplain,java,util,collections,sort,java,util,list,java,util,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;override,public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> @Override 	public Comparator<String> getPatternComparator(String path);1402512669;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of explicitness._<p>The returned {@code Comparator} will {@linkplain java.util.Collections#sort(java.util.List,_java.util.Comparator) sort} a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns: <ol> <li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li> </ol> the returned comparator will sort this_list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path is {@code /hotels/2},_the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;@Override_	public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,the,returned,code,comparator,will,linkplain,java,util,collections,sort,java,util,list,java,util,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;override,public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> @Override 	public Comparator<String> getPatternComparator(String path);1405378164;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of explicitness._<p>The returned {@code Comparator} will {@linkplain java.util.Collections#sort(java.util.List,_java.util.Comparator) sort} a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns: <ol> <li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li> </ol> the returned comparator will sort this_list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path is {@code /hotels/2},_the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;@Override_	public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,the,returned,code,comparator,will,linkplain,java,util,collections,sort,java,util,list,java,util,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;override,public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> @Override 	public Comparator<String> getPatternComparator(String path);1405378165;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of explicitness._<p>The returned {@code Comparator} will {@linkplain java.util.Collections#sort(java.util.List,_java.util.Comparator) sort} a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns: <ol> <li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li> </ol> the returned comparator will sort this_list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path is {@code /hotels/2},_the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;@Override_	public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,the,returned,code,comparator,will,linkplain,java,util,collections,sort,java,util,list,java,util,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;override,public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> @Override 	public Comparator<String> getPatternComparator(String path);1405696918;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of explicitness._<p>The returned {@code Comparator} will {@linkplain java.util.Collections#sort(java.util.List,_java.util.Comparator) sort} a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns: <ol> <li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li> </ol> the returned comparator will sort this_list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path is {@code /hotels/2},_the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;@Override_	public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,the,returned,code,comparator,will,linkplain,java,util,collections,sort,java,util,list,java,util,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;override,public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> @Override 	public Comparator<String> getPatternComparator(String path);1409784938;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of explicitness._<p>The returned {@code Comparator} will {@linkplain java.util.Collections#sort(java.util.List,_java.util.Comparator) sort} a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns: <ol> <li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li> </ol> the returned comparator will sort this_list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path is {@code /hotels/2},_the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;@Override_	public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,the,returned,code,comparator,will,linkplain,java,util,collections,sort,java,util,list,java,util,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;override,public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> @Override 	public Comparator<String> getPatternComparator(String path);1412083966;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of explicitness._<p>The returned {@code Comparator} will {@linkplain java.util.Collections#sort(java.util.List,_java.util.Comparator) sort} a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns: <ol> <li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li> </ol> the returned comparator will sort this_list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path is {@code /hotels/2},_the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;@Override_	public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,the,returned,code,comparator,will,linkplain,java,util,collections,sort,java,util,list,java,util,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;override,public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> @Override 	public Comparator<String> getPatternComparator(String path);1412101078;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of explicitness._<p>The returned {@code Comparator} will {@linkplain java.util.Collections#sort(java.util.List,_java.util.Comparator) sort} a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns: <ol> <li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li> </ol> the returned comparator will sort this_list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path is {@code /hotels/2},_the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;@Override_	public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,the,returned,code,comparator,will,linkplain,java,util,collections,sort,java,util,list,java,util,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;override,public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> @Override 	public Comparator<String> getPatternComparator(String path);1431086052;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of explicitness._<p>The returned {@code Comparator} will {@linkplain java.util.Collections#sort(java.util.List,_java.util.Comparator) sort} a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns: <ol> <li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li> </ol> the returned comparator will sort this_list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path is {@code /hotels/2},_the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;@Override_	public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,the,returned,code,comparator,will,linkplain,java,util,collections,sort,java,util,list,java,util,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;override,public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> @Override 	public Comparator<String> getPatternComparator(String path);1431178173;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of_explicitness._<p>This{@code Comparator} will {@linkplain java.util.Collections#sort(List, Comparator) sort}_a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns:_<ol>_<li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li>_</ol>_the returned comparator will sort this list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path_is {@code /hotels/2}, the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;@Override_	public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,this,code,comparator,will,linkplain,java,util,collections,sort,list,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;override,public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> @Override 	public Comparator<String> getPatternComparator(String path);1434572159;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of_explicitness._<p>This{@code Comparator} will {@linkplain java.util.Collections#sort(List, Comparator) sort}_a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns:_<ol>_<li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li>_</ol>_the returned comparator will sort this list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path_is {@code /hotels/2}, the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;@Override_	public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,this,code,comparator,will,linkplain,java,util,collections,sort,list,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;override,public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> @Override 	public Comparator<String> getPatternComparator(String path);1435239719;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of_explicitness._<p>This{@code Comparator} will {@linkplain java.util.Collections#sort(List, Comparator) sort}_a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns:_<ol>_<li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li>_</ol>_the returned comparator will sort this list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path_is {@code /hotels/2}, the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;@Override_	public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,this,code,comparator,will,linkplain,java,util,collections,sort,list,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;override,public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> @Override 	public Comparator<String> getPatternComparator(String path);1438166321;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of_explicitness._<p>This{@code Comparator} will {@linkplain java.util.Collections#sort(List, Comparator) sort}_a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns:_<ol>_<li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li>_</ol>_the returned comparator will sort this list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path_is {@code /hotels/2}, the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;@Override_	public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,this,code,comparator,will,linkplain,java,util,collections,sort,list,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;override,public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> @Override 	public Comparator<String> getPatternComparator(String path);1455100778;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of_explicitness._<p>This{@code Comparator} will {@linkplain java.util.Collections#sort(List, Comparator) sort}_a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns:_<ol>_<li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li>_</ol>_the returned comparator will sort this list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path_is {@code /hotels/2}, the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;@Override_	public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,this,code,comparator,will,linkplain,java,util,collections,sort,list,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;override,public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> @Override 	public Comparator<String> getPatternComparator(String path);1455850198;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of_explicitness._<p>This{@code Comparator} will {@linkplain java.util.Collections#sort(List, Comparator) sort}_a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns:_<ol>_<li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li>_</ol>_the returned comparator will sort this list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path_is {@code /hotels/2}, the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;@Override_	public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,this,code,comparator,will,linkplain,java,util,collections,sort,list,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;override,public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> @Override 	public Comparator<String> getPatternComparator(String path);1460754629;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of_explicitness._<p>This{@code Comparator} will {@linkplain java.util.Collections#sort(List, Comparator) sort}_a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns:_<ol>_<li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li>_</ol>_the returned comparator will sort this list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path_is {@code /hotels/2}, the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;@Override_	public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,this,code,comparator,will,linkplain,java,util,collections,sort,list,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;override,public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> @Override 	public Comparator<String> getPatternComparator(String path);1462393686;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of_explicitness._<p>This{@code Comparator} will {@linkplain java.util.Collections#sort(List, Comparator) sort}_a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns:_<ol>_<li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li>_</ol>_the returned comparator will sort this list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path_is {@code /hotels/2}, the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;@Override_	public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,this,code,comparator,will,linkplain,java,util,collections,sort,list,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;override,public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> @Override 	public Comparator<String> getPatternComparator(String path);1467730834;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of_explicitness._<p>This{@code Comparator} will {@linkplain java.util.Collections#sort(List, Comparator) sort}_a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns:_<ol>_<li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li>_</ol>_the returned comparator will sort this list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path_is {@code /hotels/2}, the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;@Override_	public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,this,code,comparator,will,linkplain,java,util,collections,sort,list,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;override,public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> @Override 	public Comparator<String> getPatternComparator(String path);1468327638;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of_explicitness._<p>This{@code Comparator} will {@linkplain java.util.Collections#sort(List, Comparator) sort}_a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns:_<ol>_<li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li>_</ol>_the returned comparator will sort this list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path_is {@code /hotels/2}, the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;@Override_	public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,this,code,comparator,will,linkplain,java,util,collections,sort,list,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;override,public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> @Override 	public Comparator<String> getPatternComparator(String path);1472808958;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of_explicitness._<p>This{@code Comparator} will {@linkplain java.util.Collections#sort(List, Comparator) sort}_a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns:_<ol>_<li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li>_</ol>_the returned comparator will sort this list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path_is {@code /hotels/2}, the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;@Override_	public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,this,code,comparator,will,linkplain,java,util,collections,sort,list,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;override,public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> @Override 	public Comparator<String> getPatternComparator(String path);1493317597;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of_explicitness._<p>This{@code Comparator} will {@linkplain java.util.Collections#sort(List, Comparator) sort}_a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns:_<ol>_<li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li>_</ol>_the returned comparator will sort this list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path_is {@code /hotels/2}, the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;@Override_	public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,this,code,comparator,will,linkplain,java,util,collections,sort,list,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;override,public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> @Override 	public Comparator<String> getPatternComparator(String path);1493321510;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of_explicitness._<p>This{@code Comparator} will {@linkplain java.util.Collections#sort(List, Comparator) sort}_a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns:_<ol>_<li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li>_</ol>_the returned comparator will sort this list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path_is {@code /hotels/2}, the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;@Override_	public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,this,code,comparator,will,linkplain,java,util,collections,sort,list,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;override,public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> @Override 	public Comparator<String> getPatternComparator(String path);1496259743;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of_explicitness._<p>This{@code Comparator} will {@linkplain java.util.Collections#sort(List, Comparator) sort}_a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns:_<ol>_<li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li>_</ol>_the returned comparator will sort this list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path_is {@code /hotels/2}, the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;@Override_	public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,this,code,comparator,will,linkplain,java,util,collections,sort,list,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;override,public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> @Override 	public Comparator<String> getPatternComparator(String path);1496837955;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of_explicitness._<p>This{@code Comparator} will {@linkplain java.util.Collections#sort(List, Comparator) sort}_a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns:_<ol>_<li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li>_</ol>_the returned comparator will sort this list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path_is {@code /hotels/2}, the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;@Override_	public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,this,code,comparator,will,linkplain,java,util,collections,sort,list,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;override,public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> @Override 	public Comparator<String> getPatternComparator(String path);1498780456;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of_explicitness._<p>This{@code Comparator} will {@linkplain java.util.Collections#sort(List, Comparator) sort}_a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns:_<ol>_<li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li>_</ol>_the returned comparator will sort this list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path_is {@code /hotels/2}, the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;@Override_	public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,this,code,comparator,will,linkplain,java,util,collections,sort,list,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;override,public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> @Override 	public Comparator<String> getPatternComparator(String path);1518772998;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of_explicitness._<p>This{@code Comparator} will {@linkplain java.util.List#sort(Comparator) sort}_a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns:_<ol>_<li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li>_</ol>_the returned comparator will sort this list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path_is {@code /hotels/2}, the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;@Override_	public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,this,code,comparator,will,linkplain,java,util,list,sort,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;override,public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> @Override 	public Comparator<String> getPatternComparator(String path);1530174524;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of_explicitness._<p>This{@code Comparator} will {@linkplain java.util.List#sort(Comparator) sort}_a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns:_<ol>_<li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li>_</ol>_the returned comparator will sort this list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path_is {@code /hotels/2}, the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;@Override_	public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,this,code,comparator,will,linkplain,java,util,list,sort,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;override,public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> @Override 	public Comparator<String> getPatternComparator(String path);1530174524;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of_explicitness._<p>This{@code Comparator} will {@linkplain java.util.List#sort(Comparator) sort}_a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns:_<ol>_<li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li>_</ol>_the returned comparator will sort this list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path_is {@code /hotels/2}, the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;@Override_	public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,this,code,comparator,will,linkplain,java,util,list,sort,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;override,public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> @Override 	public Comparator<String> getPatternComparator(String path);1535316501;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of_explicitness._<p>This{@code Comparator} will {@linkplain java.util.List#sort(Comparator) sort}_a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns:_<ol>_<li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li>_</ol>_the returned comparator will sort this list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path_is {@code /hotels/2}, the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;@Override_	public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,this,code,comparator,will,linkplain,java,util,list,sort,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;override,public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> protected String[] tokenizePath(String path);1388766826;Tokenize the given path String into parts, based on this matcher's settings._@param path the path to tokenize_@return the tokenized path parts;protected String[] tokenizePath(String path) {_		return StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__	};tokenize,the,given,path,string,into,parts,based,on,this,matcher,s,settings,param,path,the,path,to,tokenize,return,the,tokenized,path,parts;protected,string,tokenize,path,string,path,return,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true
AntPathMatcher -> protected String[] tokenizePath(String path);1402512669;Tokenize the given path String into parts, based on this matcher's settings._@param path the path to tokenize_@return the tokenized path parts;protected String[] tokenizePath(String path) {_		return StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__	};tokenize,the,given,path,string,into,parts,based,on,this,matcher,s,settings,param,path,the,path,to,tokenize,return,the,tokenized,path,parts;protected,string,tokenize,path,string,path,return,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true
AntPathMatcher -> protected String[] tokenizePath(String path);1402512669;Tokenize the given path String into parts, based on this matcher's settings._@param path the path to tokenize_@return the tokenized path parts;protected String[] tokenizePath(String path) {_		return StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__	};tokenize,the,given,path,string,into,parts,based,on,this,matcher,s,settings,param,path,the,path,to,tokenize,return,the,tokenized,path,parts;protected,string,tokenize,path,string,path,return,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true
AntPathMatcher -> protected String[] tokenizePath(String path);1402512669;Tokenize the given path String into parts, based on this matcher's settings._@param path the path to tokenize_@return the tokenized path parts;protected String[] tokenizePath(String path) {_		return StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__	};tokenize,the,given,path,string,into,parts,based,on,this,matcher,s,settings,param,path,the,path,to,tokenize,return,the,tokenized,path,parts;protected,string,tokenize,path,string,path,return,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true
AntPathMatcher -> protected String[] tokenizePath(String path);1405378164;Tokenize the given path String into parts, based on this matcher's settings._@param path the path to tokenize_@return the tokenized path parts;protected String[] tokenizePath(String path) {_		return StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__	};tokenize,the,given,path,string,into,parts,based,on,this,matcher,s,settings,param,path,the,path,to,tokenize,return,the,tokenized,path,parts;protected,string,tokenize,path,string,path,return,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true
AntPathMatcher -> protected String[] tokenizePath(String path);1405378165;Tokenize the given path String into parts, based on this matcher's settings._@param path the path to tokenize_@return the tokenized path parts;protected String[] tokenizePath(String path) {_		return StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__	};tokenize,the,given,path,string,into,parts,based,on,this,matcher,s,settings,param,path,the,path,to,tokenize,return,the,tokenized,path,parts;protected,string,tokenize,path,string,path,return,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true
AntPathMatcher -> protected String[] tokenizePath(String path);1405696918;Tokenize the given path String into parts, based on this matcher's settings._@param path the path to tokenize_@return the tokenized path parts;protected String[] tokenizePath(String path) {_		return StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__	};tokenize,the,given,path,string,into,parts,based,on,this,matcher,s,settings,param,path,the,path,to,tokenize,return,the,tokenized,path,parts;protected,string,tokenize,path,string,path,return,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true
AntPathMatcher -> protected String[] tokenizePath(String path);1409784938;Tokenize the given path String into parts, based on this matcher's settings._@param path the path to tokenize_@return the tokenized path parts;protected String[] tokenizePath(String path) {_		return StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__	};tokenize,the,given,path,string,into,parts,based,on,this,matcher,s,settings,param,path,the,path,to,tokenize,return,the,tokenized,path,parts;protected,string,tokenize,path,string,path,return,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true
AntPathMatcher -> protected String[] tokenizePath(String path);1412083966;Tokenize the given path String into parts, based on this matcher's settings._@param path the path to tokenize_@return the tokenized path parts;protected String[] tokenizePath(String path) {_		return StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__	};tokenize,the,given,path,string,into,parts,based,on,this,matcher,s,settings,param,path,the,path,to,tokenize,return,the,tokenized,path,parts;protected,string,tokenize,path,string,path,return,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true
AntPathMatcher -> protected String[] tokenizePath(String path);1412101078;Tokenize the given path String into parts, based on this matcher's settings._@param path the path to tokenize_@return the tokenized path parts;protected String[] tokenizePath(String path) {_		return StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__	};tokenize,the,given,path,string,into,parts,based,on,this,matcher,s,settings,param,path,the,path,to,tokenize,return,the,tokenized,path,parts;protected,string,tokenize,path,string,path,return,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true
AntPathMatcher -> protected String[] tokenizePath(String path);1431086052;Tokenize the given path String into parts, based on this matcher's settings._@param path the path to tokenize_@return the tokenized path parts;protected String[] tokenizePath(String path) {_		return StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__	};tokenize,the,given,path,string,into,parts,based,on,this,matcher,s,settings,param,path,the,path,to,tokenize,return,the,tokenized,path,parts;protected,string,tokenize,path,string,path,return,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true
AntPathMatcher -> protected String[] tokenizePath(String path);1431178173;Tokenize the given path String into parts, based on this matcher's settings._@param path the path to tokenize_@return the tokenized path parts;protected String[] tokenizePath(String path) {_		return StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__	};tokenize,the,given,path,string,into,parts,based,on,this,matcher,s,settings,param,path,the,path,to,tokenize,return,the,tokenized,path,parts;protected,string,tokenize,path,string,path,return,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true
AntPathMatcher -> protected String[] tokenizePath(String path);1434572159;Tokenize the given path String into parts, based on this matcher's settings._@param path the path to tokenize_@return the tokenized path parts;protected String[] tokenizePath(String path) {_		return StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__	};tokenize,the,given,path,string,into,parts,based,on,this,matcher,s,settings,param,path,the,path,to,tokenize,return,the,tokenized,path,parts;protected,string,tokenize,path,string,path,return,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true
AntPathMatcher -> protected String[] tokenizePath(String path);1435239719;Tokenize the given path String into parts, based on this matcher's settings._@param path the path to tokenize_@return the tokenized path parts;protected String[] tokenizePath(String path) {_		return StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__	};tokenize,the,given,path,string,into,parts,based,on,this,matcher,s,settings,param,path,the,path,to,tokenize,return,the,tokenized,path,parts;protected,string,tokenize,path,string,path,return,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true
AntPathMatcher -> protected String[] tokenizePath(String path);1438166321;Tokenize the given path String into parts, based on this matcher's settings._@param path the path to tokenize_@return the tokenized path parts;protected String[] tokenizePath(String path) {_		return StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__	};tokenize,the,given,path,string,into,parts,based,on,this,matcher,s,settings,param,path,the,path,to,tokenize,return,the,tokenized,path,parts;protected,string,tokenize,path,string,path,return,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true
AntPathMatcher -> protected String[] tokenizePath(String path);1455100778;Tokenize the given path String into parts, based on this matcher's settings._@param path the path to tokenize_@return the tokenized path parts;protected String[] tokenizePath(String path) {_		return StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__	};tokenize,the,given,path,string,into,parts,based,on,this,matcher,s,settings,param,path,the,path,to,tokenize,return,the,tokenized,path,parts;protected,string,tokenize,path,string,path,return,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true
AntPathMatcher -> protected String[] tokenizePath(String path);1455850198;Tokenize the given path String into parts, based on this matcher's settings._@param path the path to tokenize_@return the tokenized path parts;protected String[] tokenizePath(String path) {_		return StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__	};tokenize,the,given,path,string,into,parts,based,on,this,matcher,s,settings,param,path,the,path,to,tokenize,return,the,tokenized,path,parts;protected,string,tokenize,path,string,path,return,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true
AntPathMatcher -> protected String[] tokenizePath(String path);1460754629;Tokenize the given path String into parts, based on this matcher's settings._@param path the path to tokenize_@return the tokenized path parts;protected String[] tokenizePath(String path) {_		return StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__	};tokenize,the,given,path,string,into,parts,based,on,this,matcher,s,settings,param,path,the,path,to,tokenize,return,the,tokenized,path,parts;protected,string,tokenize,path,string,path,return,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true
AntPathMatcher -> protected String[] tokenizePath(String path);1462393686;Tokenize the given path String into parts, based on this matcher's settings._@param path the path to tokenize_@return the tokenized path parts;protected String[] tokenizePath(String path) {_		return StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__	};tokenize,the,given,path,string,into,parts,based,on,this,matcher,s,settings,param,path,the,path,to,tokenize,return,the,tokenized,path,parts;protected,string,tokenize,path,string,path,return,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true
AntPathMatcher -> protected String[] tokenizePath(String path);1467730834;Tokenize the given path String into parts, based on this matcher's settings._@param path the path to tokenize_@return the tokenized path parts;protected String[] tokenizePath(String path) {_		return StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__	};tokenize,the,given,path,string,into,parts,based,on,this,matcher,s,settings,param,path,the,path,to,tokenize,return,the,tokenized,path,parts;protected,string,tokenize,path,string,path,return,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true
AntPathMatcher -> protected String[] tokenizePath(String path);1468327638;Tokenize the given path String into parts, based on this matcher's settings._@param path the path to tokenize_@return the tokenized path parts;protected String[] tokenizePath(String path) {_		return StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__	};tokenize,the,given,path,string,into,parts,based,on,this,matcher,s,settings,param,path,the,path,to,tokenize,return,the,tokenized,path,parts;protected,string,tokenize,path,string,path,return,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true
AntPathMatcher -> protected String[] tokenizePath(String path);1472808958;Tokenize the given path String into parts, based on this matcher's settings._@param path the path to tokenize_@return the tokenized path parts;protected String[] tokenizePath(String path) {_		return StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__	};tokenize,the,given,path,string,into,parts,based,on,this,matcher,s,settings,param,path,the,path,to,tokenize,return,the,tokenized,path,parts;protected,string,tokenize,path,string,path,return,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true
AntPathMatcher -> protected String[] tokenizePath(String path);1493317597;Tokenize the given path String into parts, based on this matcher's settings._@param path the path to tokenize_@return the tokenized path parts;protected String[] tokenizePath(String path) {_		return StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__	};tokenize,the,given,path,string,into,parts,based,on,this,matcher,s,settings,param,path,the,path,to,tokenize,return,the,tokenized,path,parts;protected,string,tokenize,path,string,path,return,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true
AntPathMatcher -> protected String[] tokenizePath(String path);1493321510;Tokenize the given path String into parts, based on this matcher's settings._@param path the path to tokenize_@return the tokenized path parts;protected String[] tokenizePath(String path) {_		return StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__	};tokenize,the,given,path,string,into,parts,based,on,this,matcher,s,settings,param,path,the,path,to,tokenize,return,the,tokenized,path,parts;protected,string,tokenize,path,string,path,return,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true
AntPathMatcher -> protected String[] tokenizePath(String path);1496259743;Tokenize the given path String into parts, based on this matcher's settings._@param path the path to tokenize_@return the tokenized path parts;protected String[] tokenizePath(String path) {_		return StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__	};tokenize,the,given,path,string,into,parts,based,on,this,matcher,s,settings,param,path,the,path,to,tokenize,return,the,tokenized,path,parts;protected,string,tokenize,path,string,path,return,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true
AntPathMatcher -> protected String[] tokenizePath(String path);1496837955;Tokenize the given path String into parts, based on this matcher's settings._@param path the path to tokenize_@return the tokenized path parts;protected String[] tokenizePath(String path) {_		return StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__	};tokenize,the,given,path,string,into,parts,based,on,this,matcher,s,settings,param,path,the,path,to,tokenize,return,the,tokenized,path,parts;protected,string,tokenize,path,string,path,return,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true
AntPathMatcher -> protected String[] tokenizePath(String path);1498780456;Tokenize the given path String into parts, based on this matcher's settings._@param path the path to tokenize_@return the tokenized path parts;protected String[] tokenizePath(String path) {_		return StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__	};tokenize,the,given,path,string,into,parts,based,on,this,matcher,s,settings,param,path,the,path,to,tokenize,return,the,tokenized,path,parts;protected,string,tokenize,path,string,path,return,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true
AntPathMatcher -> protected String[] tokenizePath(String path);1518772998;Tokenize the given path String into parts, based on this matcher's settings._@param path the path to tokenize_@return the tokenized path parts;protected String[] tokenizePath(String path) {_		return StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__	};tokenize,the,given,path,string,into,parts,based,on,this,matcher,s,settings,param,path,the,path,to,tokenize,return,the,tokenized,path,parts;protected,string,tokenize,path,string,path,return,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true
AntPathMatcher -> protected String[] tokenizePath(String path);1530174524;Tokenize the given path String into parts, based on this matcher's settings._@param path the path to tokenize_@return the tokenized path parts;protected String[] tokenizePath(String path) {_		return StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__	};tokenize,the,given,path,string,into,parts,based,on,this,matcher,s,settings,param,path,the,path,to,tokenize,return,the,tokenized,path,parts;protected,string,tokenize,path,string,path,return,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true
AntPathMatcher -> protected String[] tokenizePath(String path);1530174524;Tokenize the given path String into parts, based on this matcher's settings._@param path the path to tokenize_@return the tokenized path parts;protected String[] tokenizePath(String path) {_		return StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__	};tokenize,the,given,path,string,into,parts,based,on,this,matcher,s,settings,param,path,the,path,to,tokenize,return,the,tokenized,path,parts;protected,string,tokenize,path,string,path,return,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true
AntPathMatcher -> protected String[] tokenizePath(String path);1535316501;Tokenize the given path String into parts, based on this matcher's settings._@param path the path to tokenize_@return the tokenized path parts;protected String[] tokenizePath(String path) {_		return StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__	};tokenize,the,given,path,string,into,parts,based,on,this,matcher,s,settings,param,path,the,path,to,tokenize,return,the,tokenized,path,parts;protected,string,tokenize,path,string,path,return,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true
AntPathMatcher -> AntPatternComparator -> private int getPatternLength(String pattern);1328020251;Returns the length of the given pattern, where template variables are considered to be 1 long.;private int getPatternLength(String pattern) {_			Matcher m = VARIABLE_PATTERN.matcher(pattern)__			return m.replaceAll("#").length()__		};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;private,int,get,pattern,length,string,pattern,matcher,m,matcher,pattern,return,m,replace,all,length
AntPathMatcher -> AntPatternComparator -> private int getPatternLength(String pattern);1333393580;Returns the length of the given pattern, where template variables are considered to be 1 long.;private int getPatternLength(String pattern) {_			Matcher m = VARIABLE_PATTERN.matcher(pattern)__			return m.replaceAll("#").length()__		};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;private,int,get,pattern,length,string,pattern,matcher,m,matcher,pattern,return,m,replace,all,length
AntPathMatcher -> AntPatternComparator -> private int getPatternLength(String pattern);1347310630;Returns the length of the given pattern, where template variables are considered to be 1 long.;private int getPatternLength(String pattern) {_			Matcher m = VARIABLE_PATTERN.matcher(pattern)__			return m.replaceAll("#").length()__		};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;private,int,get,pattern,length,string,pattern,matcher,m,matcher,pattern,return,m,replace,all,length
AntPathMatcher -> AntPatternComparator -> private int getPatternLength(String pattern);1355351965;Returns the length of the given pattern, where template variables are considered to be 1 long.;private int getPatternLength(String pattern) {_			Matcher m = VARIABLE_PATTERN.matcher(pattern)__			return m.replaceAll("#").length()__		};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;private,int,get,pattern,length,string,pattern,matcher,m,matcher,pattern,return,m,replace,all,length
AntPathMatcher -> AntPatternComparator -> private int getPatternLength(String pattern);1356735495;Returns the length of the given pattern, where template variables are considered to be 1 long.;private int getPatternLength(String pattern) {_			Matcher m = VARIABLE_PATTERN.matcher(pattern)__			return m.replaceAll("#").length()__		};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;private,int,get,pattern,length,string,pattern,matcher,m,matcher,pattern,return,m,replace,all,length
AntPathMatcher -> AntPatternComparator -> private int getPatternLength(String pattern);1357119239;Returns the length of the given pattern, where template variables are considered to be 1 long.;private int getPatternLength(String pattern) {_			Matcher m = VARIABLE_PATTERN.matcher(pattern)__			return m.replaceAll("#").length()__		};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;private,int,get,pattern,length,string,pattern,matcher,m,matcher,pattern,return,m,replace,all,length
AntPathMatcher -> AntPatternComparator -> private int getPatternLength(String pattern);1362408075;Returns the length of the given pattern, where template variables are considered to be 1 long.;private int getPatternLength(String pattern) {_			Matcher m = VARIABLE_PATTERN.matcher(pattern)__			return m.replaceAll("#").length()__		};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;private,int,get,pattern,length,string,pattern,matcher,m,matcher,pattern,return,m,replace,all,length
AntPathMatcher -> AntPatternComparator -> private int getPatternLength(String pattern);1368482696;Returns the length of the given pattern, where template variables are considered to be 1 long.;private int getPatternLength(String pattern) {_			Matcher m = VARIABLE_PATTERN.matcher(pattern)__			return m.replaceAll("#").length()__		};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;private,int,get,pattern,length,string,pattern,matcher,m,matcher,pattern,return,m,replace,all,length
AntPathMatcher -> AntPatternComparator -> private int getPatternLength(String pattern);1377725408;Returns the length of the given pattern, where template variables are considered to be 1 long.;private int getPatternLength(String pattern) {_			Matcher m = VARIABLE_PATTERN.matcher(pattern)__			return m.replaceAll("#").length()__		};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;private,int,get,pattern,length,string,pattern,matcher,m,matcher,pattern,return,m,replace,all,length
AntPathMatcher -> AntPatternComparator -> private int getPatternLength(String pattern);1377735685;Returns the length of the given pattern, where template variables are considered to be 1 long.;private int getPatternLength(String pattern) {_			Matcher m = VARIABLE_PATTERN.matcher(pattern)__			return m.replaceAll("#").length()__		};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;private,int,get,pattern,length,string,pattern,matcher,m,matcher,pattern,return,m,replace,all,length
AntPathMatcher -> AntPatternComparator -> private int getPatternLength(String pattern);1383090798;Returns the length of the given pattern, where template variables are considered to be 1 long.;private int getPatternLength(String pattern) {_			return VARIABLE_PATTERN.matcher(pattern).replaceAll("#").length()__		};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;private,int,get,pattern,length,string,pattern,return,matcher,pattern,replace,all,length
AntPathMatcher -> AntPatternComparator -> private int getPatternLength(String pattern);1383157688;Returns the length of the given pattern, where template variables are considered to be 1 long.;private int getPatternLength(String pattern) {_			return VARIABLE_PATTERN.matcher(pattern).replaceAll("#").length()__		};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;private,int,get,pattern,length,string,pattern,return,matcher,pattern,replace,all,length
AntPathMatcher -> AntPatternComparator -> private int getPatternLength(String pattern);1385501137;Returns the length of the given pattern, where template variables are considered to be 1 long.;private int getPatternLength(String pattern) {_			return VARIABLE_PATTERN.matcher(pattern).replaceAll("#").length()__		};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;private,int,get,pattern,length,string,pattern,return,matcher,pattern,replace,all,length
AntPathMatcher -> AntPatternComparator -> private int getPatternLength(String pattern);1388766826;Returns the length of the given pattern, where template variables are considered to be 1 long.;private int getPatternLength(String pattern) {_			return VARIABLE_PATTERN.matcher(pattern).replaceAll("#").length()__		};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;private,int,get,pattern,length,string,pattern,return,matcher,pattern,replace,all,length
AntPathMatcher -> AntPatternComparator -> private int getPatternLength(String pattern);1402512669;Returns the length of the given pattern, where template variables are considered to be 1 long.;private int getPatternLength(String pattern) {_			return VARIABLE_PATTERN.matcher(pattern).replaceAll("#").length()__		};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;private,int,get,pattern,length,string,pattern,return,matcher,pattern,replace,all,length
AntPathMatcher -> protected AntPathStringMatcher getStringMatcher(String pattern);1383090798;Build or retrieve an {@link AntPathStringMatcher} for the given pattern._<p>The default implementation checks this AntPathMatcher's internal cache_(see {@link #setCachePatterns}, creating a new AntPathStringMatcher instance_through {@link AntPathStringMatcher#AntPathStringMatcher(String)} if none found._When encountering too many patterns to cache at runtime (the threshold is 65536),_it turns the default cache off, assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a reoccurring pattern._<p>This method may get overridden to implement a custom cache strategy._@param pattern the pattern to match against (never {@code null})_@return a corresponding AntPathStringMatcher (never {@code null})_@see #setCachePatterns;protected AntPathStringMatcher getStringMatcher(String pattern) {_		AntPathStringMatcher matcher = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			matcher = this.stringMatcherCache.get(pattern)__		}_		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern)__			if (cachePatterns == null && this.stringMatcherCache.size() == CACHE_TURNOFF_THRESHOLD) {_				_				_				_				this.cachePatterns = false__				this.stringMatcherCache.clear()__				return matcher__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.stringMatcherCache.put(pattern, matcher)__			}_		}_		return matcher__	};build,or,retrieve,an,link,ant,path,string,matcher,for,the,given,pattern,p,the,default,implementation,checks,this,ant,path,matcher,s,internal,cache,see,link,set,cache,patterns,creating,a,new,ant,path,string,matcher,instance,through,link,ant,path,string,matcher,ant,path,string,matcher,string,if,none,found,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,it,turns,the,default,cache,off,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,reoccurring,pattern,p,this,method,may,get,overridden,to,implement,a,custom,cache,strategy,param,pattern,the,pattern,to,match,against,never,code,null,return,a,corresponding,ant,path,string,matcher,never,code,null,see,set,cache,patterns;protected,ant,path,string,matcher,get,string,matcher,string,pattern,ant,path,string,matcher,matcher,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,if,cache,patterns,null,this,string,matcher,cache,size,this,cache,patterns,false,this,string,matcher,cache,clear,return,matcher,if,cache,patterns,null,cache,patterns,boolean,value,this,string,matcher,cache,put,pattern,matcher,return,matcher
AntPathMatcher -> protected AntPathStringMatcher getStringMatcher(String pattern);1383157688;Build or retrieve an {@link AntPathStringMatcher} for the given pattern._<p>The default implementation checks this AntPathMatcher's internal cache_(see {@link #setCachePatterns}, creating a new AntPathStringMatcher instance_through {@link AntPathStringMatcher#AntPathStringMatcher(String)} if none found._When encountering too many patterns to cache at runtime (the threshold is 65536),_it turns the default cache off, assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a reoccurring pattern._<p>This method may get overridden to implement a custom cache strategy._@param pattern the pattern to match against (never {@code null})_@return a corresponding AntPathStringMatcher (never {@code null})_@see #setCachePatterns;protected AntPathStringMatcher getStringMatcher(String pattern) {_		AntPathStringMatcher matcher = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			matcher = this.stringMatcherCache.get(pattern)__		}_		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern)__			if (cachePatterns == null && this.stringMatcherCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				this.cachePatterns = false__				this.stringMatcherCache.clear()__				return matcher__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.stringMatcherCache.put(pattern, matcher)__			}_		}_		return matcher__	};build,or,retrieve,an,link,ant,path,string,matcher,for,the,given,pattern,p,the,default,implementation,checks,this,ant,path,matcher,s,internal,cache,see,link,set,cache,patterns,creating,a,new,ant,path,string,matcher,instance,through,link,ant,path,string,matcher,ant,path,string,matcher,string,if,none,found,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,it,turns,the,default,cache,off,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,reoccurring,pattern,p,this,method,may,get,overridden,to,implement,a,custom,cache,strategy,param,pattern,the,pattern,to,match,against,never,code,null,return,a,corresponding,ant,path,string,matcher,never,code,null,see,set,cache,patterns;protected,ant,path,string,matcher,get,string,matcher,string,pattern,ant,path,string,matcher,matcher,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,if,cache,patterns,null,this,string,matcher,cache,size,this,cache,patterns,false,this,string,matcher,cache,clear,return,matcher,if,cache,patterns,null,cache,patterns,boolean,value,this,string,matcher,cache,put,pattern,matcher,return,matcher
AntPathMatcher -> protected AntPathStringMatcher getStringMatcher(String pattern);1385501137;Build or retrieve an {@link AntPathStringMatcher} for the given pattern._<p>The default implementation checks this AntPathMatcher's internal cache_(see {@link #setCachePatterns}), creating a new AntPathStringMatcher instance_if no cached copy is found._When encountering too many patterns to cache at runtime (the threshold is 65536),_it turns the default cache off, assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a reoccurring pattern._<p>This method may get overridden to implement a custom cache strategy._@param pattern the pattern to match against (never {@code null})_@return a corresponding AntPathStringMatcher (never {@code null})_@see #setCachePatterns;protected AntPathStringMatcher getStringMatcher(String pattern) {_		AntPathStringMatcher matcher = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			matcher = this.stringMatcherCache.get(pattern)__		}_		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern)__			if (cachePatterns == null && this.stringMatcherCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				this.cachePatterns = false__				this.stringMatcherCache.clear()__				return matcher__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.stringMatcherCache.put(pattern, matcher)__			}_		}_		return matcher__	};build,or,retrieve,an,link,ant,path,string,matcher,for,the,given,pattern,p,the,default,implementation,checks,this,ant,path,matcher,s,internal,cache,see,link,set,cache,patterns,creating,a,new,ant,path,string,matcher,instance,if,no,cached,copy,is,found,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,it,turns,the,default,cache,off,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,reoccurring,pattern,p,this,method,may,get,overridden,to,implement,a,custom,cache,strategy,param,pattern,the,pattern,to,match,against,never,code,null,return,a,corresponding,ant,path,string,matcher,never,code,null,see,set,cache,patterns;protected,ant,path,string,matcher,get,string,matcher,string,pattern,ant,path,string,matcher,matcher,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,if,cache,patterns,null,this,string,matcher,cache,size,this,cache,patterns,false,this,string,matcher,cache,clear,return,matcher,if,cache,patterns,null,cache,patterns,boolean,value,this,string,matcher,cache,put,pattern,matcher,return,matcher
AntPathMatcher -> protected AntPathStringMatcher getStringMatcher(String pattern);1388766826;Build or retrieve an {@link AntPathStringMatcher} for the given pattern._<p>The default implementation checks this AntPathMatcher's internal cache_(see {@link #setCachePatterns}), creating a new AntPathStringMatcher instance_if no cached copy is found._When encountering too many patterns to cache at runtime (the threshold is 65536),_it turns the default cache off, assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a reoccurring pattern._<p>This method may get overridden to implement a custom cache strategy._@param pattern the pattern to match against (never {@code null})_@return a corresponding AntPathStringMatcher (never {@code null})_@see #setCachePatterns;protected AntPathStringMatcher getStringMatcher(String pattern) {_		AntPathStringMatcher matcher = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			matcher = this.stringMatcherCache.get(pattern)__		}_		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern)__			if (cachePatterns == null && this.stringMatcherCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return matcher__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.stringMatcherCache.put(pattern, matcher)__			}_		}_		return matcher__	};build,or,retrieve,an,link,ant,path,string,matcher,for,the,given,pattern,p,the,default,implementation,checks,this,ant,path,matcher,s,internal,cache,see,link,set,cache,patterns,creating,a,new,ant,path,string,matcher,instance,if,no,cached,copy,is,found,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,it,turns,the,default,cache,off,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,reoccurring,pattern,p,this,method,may,get,overridden,to,implement,a,custom,cache,strategy,param,pattern,the,pattern,to,match,against,never,code,null,return,a,corresponding,ant,path,string,matcher,never,code,null,see,set,cache,patterns;protected,ant,path,string,matcher,get,string,matcher,string,pattern,ant,path,string,matcher,matcher,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,if,cache,patterns,null,this,string,matcher,cache,size,deactivate,pattern,cache,return,matcher,if,cache,patterns,null,cache,patterns,boolean,value,this,string,matcher,cache,put,pattern,matcher,return,matcher
AntPathMatcher -> protected AntPathStringMatcher getStringMatcher(String pattern);1402512669;Build or retrieve an {@link AntPathStringMatcher} for the given pattern._<p>The default implementation checks this AntPathMatcher's internal cache_(see {@link #setCachePatterns}), creating a new AntPathStringMatcher instance_if no cached copy is found._When encountering too many patterns to cache at runtime (the threshold is 65536),_it turns the default cache off, assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a reoccurring pattern._<p>This method may get overridden to implement a custom cache strategy._@param pattern the pattern to match against (never {@code null})_@return a corresponding AntPathStringMatcher (never {@code null})_@see #setCachePatterns;protected AntPathStringMatcher getStringMatcher(String pattern) {_		AntPathStringMatcher matcher = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			matcher = this.stringMatcherCache.get(pattern)__		}_		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern)__			if (cachePatterns == null && this.stringMatcherCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return matcher__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.stringMatcherCache.put(pattern, matcher)__			}_		}_		return matcher__	};build,or,retrieve,an,link,ant,path,string,matcher,for,the,given,pattern,p,the,default,implementation,checks,this,ant,path,matcher,s,internal,cache,see,link,set,cache,patterns,creating,a,new,ant,path,string,matcher,instance,if,no,cached,copy,is,found,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,it,turns,the,default,cache,off,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,reoccurring,pattern,p,this,method,may,get,overridden,to,implement,a,custom,cache,strategy,param,pattern,the,pattern,to,match,against,never,code,null,return,a,corresponding,ant,path,string,matcher,never,code,null,see,set,cache,patterns;protected,ant,path,string,matcher,get,string,matcher,string,pattern,ant,path,string,matcher,matcher,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,if,cache,patterns,null,this,string,matcher,cache,size,deactivate,pattern,cache,return,matcher,if,cache,patterns,null,cache,patterns,boolean,value,this,string,matcher,cache,put,pattern,matcher,return,matcher
AntPathMatcher -> protected AntPathStringMatcher getStringMatcher(String pattern);1402512669;Build or retrieve an {@link AntPathStringMatcher} for the given pattern._<p>The default implementation checks this AntPathMatcher's internal cache_(see {@link #setCachePatterns}), creating a new AntPathStringMatcher instance_if no cached copy is found._When encountering too many patterns to cache at runtime (the threshold is 65536),_it turns the default cache off, assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a reoccurring pattern._<p>This method may get overridden to implement a custom cache strategy._@param pattern the pattern to match against (never {@code null})_@return a corresponding AntPathStringMatcher (never {@code null})_@see #setCachePatterns;protected AntPathStringMatcher getStringMatcher(String pattern) {_		AntPathStringMatcher matcher = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			matcher = this.stringMatcherCache.get(pattern)__		}_		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern)__			if (cachePatterns == null && this.stringMatcherCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return matcher__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.stringMatcherCache.put(pattern, matcher)__			}_		}_		return matcher__	};build,or,retrieve,an,link,ant,path,string,matcher,for,the,given,pattern,p,the,default,implementation,checks,this,ant,path,matcher,s,internal,cache,see,link,set,cache,patterns,creating,a,new,ant,path,string,matcher,instance,if,no,cached,copy,is,found,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,it,turns,the,default,cache,off,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,reoccurring,pattern,p,this,method,may,get,overridden,to,implement,a,custom,cache,strategy,param,pattern,the,pattern,to,match,against,never,code,null,return,a,corresponding,ant,path,string,matcher,never,code,null,see,set,cache,patterns;protected,ant,path,string,matcher,get,string,matcher,string,pattern,ant,path,string,matcher,matcher,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,if,cache,patterns,null,this,string,matcher,cache,size,deactivate,pattern,cache,return,matcher,if,cache,patterns,null,cache,patterns,boolean,value,this,string,matcher,cache,put,pattern,matcher,return,matcher
AntPathMatcher -> protected AntPathStringMatcher getStringMatcher(String pattern);1402512669;Build or retrieve an {@link AntPathStringMatcher} for the given pattern._<p>The default implementation checks this AntPathMatcher's internal cache_(see {@link #setCachePatterns}), creating a new AntPathStringMatcher instance_if no cached copy is found._When encountering too many patterns to cache at runtime (the threshold is 65536),_it turns the default cache off, assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a reoccurring pattern._<p>This method may get overridden to implement a custom cache strategy._@param pattern the pattern to match against (never {@code null})_@return a corresponding AntPathStringMatcher (never {@code null})_@see #setCachePatterns;protected AntPathStringMatcher getStringMatcher(String pattern) {_		AntPathStringMatcher matcher = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			matcher = this.stringMatcherCache.get(pattern)__		}_		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern)__			if (cachePatterns == null && this.stringMatcherCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return matcher__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.stringMatcherCache.put(pattern, matcher)__			}_		}_		return matcher__	};build,or,retrieve,an,link,ant,path,string,matcher,for,the,given,pattern,p,the,default,implementation,checks,this,ant,path,matcher,s,internal,cache,see,link,set,cache,patterns,creating,a,new,ant,path,string,matcher,instance,if,no,cached,copy,is,found,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,it,turns,the,default,cache,off,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,reoccurring,pattern,p,this,method,may,get,overridden,to,implement,a,custom,cache,strategy,param,pattern,the,pattern,to,match,against,never,code,null,return,a,corresponding,ant,path,string,matcher,never,code,null,see,set,cache,patterns;protected,ant,path,string,matcher,get,string,matcher,string,pattern,ant,path,string,matcher,matcher,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,if,cache,patterns,null,this,string,matcher,cache,size,deactivate,pattern,cache,return,matcher,if,cache,patterns,null,cache,patterns,boolean,value,this,string,matcher,cache,put,pattern,matcher,return,matcher
AntPathMatcher -> protected AntPathStringMatcher getStringMatcher(String pattern);1405378164;Build or retrieve an {@link AntPathStringMatcher} for the given pattern._<p>The default implementation checks this AntPathMatcher's internal cache_(see {@link #setCachePatterns}), creating a new AntPathStringMatcher instance_if no cached copy is found._When encountering too many patterns to cache at runtime (the threshold is 65536),_it turns the default cache off, assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a reoccurring pattern._<p>This method may get overridden to implement a custom cache strategy._@param pattern the pattern to match against (never {@code null})_@return a corresponding AntPathStringMatcher (never {@code null})_@see #setCachePatterns;protected AntPathStringMatcher getStringMatcher(String pattern) {_		AntPathStringMatcher matcher = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			matcher = this.stringMatcherCache.get(pattern)__		}_		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern)__			if (cachePatterns == null && this.stringMatcherCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return matcher__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.stringMatcherCache.put(pattern, matcher)__			}_		}_		return matcher__	};build,or,retrieve,an,link,ant,path,string,matcher,for,the,given,pattern,p,the,default,implementation,checks,this,ant,path,matcher,s,internal,cache,see,link,set,cache,patterns,creating,a,new,ant,path,string,matcher,instance,if,no,cached,copy,is,found,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,it,turns,the,default,cache,off,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,reoccurring,pattern,p,this,method,may,get,overridden,to,implement,a,custom,cache,strategy,param,pattern,the,pattern,to,match,against,never,code,null,return,a,corresponding,ant,path,string,matcher,never,code,null,see,set,cache,patterns;protected,ant,path,string,matcher,get,string,matcher,string,pattern,ant,path,string,matcher,matcher,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,if,cache,patterns,null,this,string,matcher,cache,size,deactivate,pattern,cache,return,matcher,if,cache,patterns,null,cache,patterns,boolean,value,this,string,matcher,cache,put,pattern,matcher,return,matcher
AntPathMatcher -> protected AntPathStringMatcher getStringMatcher(String pattern);1405378165;Build or retrieve an {@link AntPathStringMatcher} for the given pattern._<p>The default implementation checks this AntPathMatcher's internal cache_(see {@link #setCachePatterns}), creating a new AntPathStringMatcher instance_if no cached copy is found._When encountering too many patterns to cache at runtime (the threshold is 65536),_it turns the default cache off, assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a reoccurring pattern._<p>This method may get overridden to implement a custom cache strategy._@param pattern the pattern to match against (never {@code null})_@return a corresponding AntPathStringMatcher (never {@code null})_@see #setCachePatterns;protected AntPathStringMatcher getStringMatcher(String pattern) {_		AntPathStringMatcher matcher = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			matcher = this.stringMatcherCache.get(pattern)__		}_		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern)__			if (cachePatterns == null && this.stringMatcherCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return matcher__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.stringMatcherCache.put(pattern, matcher)__			}_		}_		return matcher__	};build,or,retrieve,an,link,ant,path,string,matcher,for,the,given,pattern,p,the,default,implementation,checks,this,ant,path,matcher,s,internal,cache,see,link,set,cache,patterns,creating,a,new,ant,path,string,matcher,instance,if,no,cached,copy,is,found,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,it,turns,the,default,cache,off,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,reoccurring,pattern,p,this,method,may,get,overridden,to,implement,a,custom,cache,strategy,param,pattern,the,pattern,to,match,against,never,code,null,return,a,corresponding,ant,path,string,matcher,never,code,null,see,set,cache,patterns;protected,ant,path,string,matcher,get,string,matcher,string,pattern,ant,path,string,matcher,matcher,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,if,cache,patterns,null,this,string,matcher,cache,size,deactivate,pattern,cache,return,matcher,if,cache,patterns,null,cache,patterns,boolean,value,this,string,matcher,cache,put,pattern,matcher,return,matcher
AntPathMatcher -> protected AntPathStringMatcher getStringMatcher(String pattern);1405696918;Build or retrieve an {@link AntPathStringMatcher} for the given pattern._<p>The default implementation checks this AntPathMatcher's internal cache_(see {@link #setCachePatterns}), creating a new AntPathStringMatcher instance_if no cached copy is found._When encountering too many patterns to cache at runtime (the threshold is 65536),_it turns the default cache off, assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a reoccurring pattern._<p>This method may get overridden to implement a custom cache strategy._@param pattern the pattern to match against (never {@code null})_@return a corresponding AntPathStringMatcher (never {@code null})_@see #setCachePatterns;protected AntPathStringMatcher getStringMatcher(String pattern) {_		AntPathStringMatcher matcher = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			matcher = this.stringMatcherCache.get(pattern)__		}_		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern)__			if (cachePatterns == null && this.stringMatcherCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return matcher__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.stringMatcherCache.put(pattern, matcher)__			}_		}_		return matcher__	};build,or,retrieve,an,link,ant,path,string,matcher,for,the,given,pattern,p,the,default,implementation,checks,this,ant,path,matcher,s,internal,cache,see,link,set,cache,patterns,creating,a,new,ant,path,string,matcher,instance,if,no,cached,copy,is,found,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,it,turns,the,default,cache,off,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,reoccurring,pattern,p,this,method,may,get,overridden,to,implement,a,custom,cache,strategy,param,pattern,the,pattern,to,match,against,never,code,null,return,a,corresponding,ant,path,string,matcher,never,code,null,see,set,cache,patterns;protected,ant,path,string,matcher,get,string,matcher,string,pattern,ant,path,string,matcher,matcher,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,if,cache,patterns,null,this,string,matcher,cache,size,deactivate,pattern,cache,return,matcher,if,cache,patterns,null,cache,patterns,boolean,value,this,string,matcher,cache,put,pattern,matcher,return,matcher
AntPathMatcher -> protected AntPathStringMatcher getStringMatcher(String pattern);1409784938;Build or retrieve an {@link AntPathStringMatcher} for the given pattern._<p>The default implementation checks this AntPathMatcher's internal cache_(see {@link #setCachePatterns}), creating a new AntPathStringMatcher instance_if no cached copy is found._When encountering too many patterns to cache at runtime (the threshold is 65536),_it turns the default cache off, assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a reoccurring pattern._<p>This method may get overridden to implement a custom cache strategy._@param pattern the pattern to match against (never {@code null})_@return a corresponding AntPathStringMatcher (never {@code null})_@see #setCachePatterns;protected AntPathStringMatcher getStringMatcher(String pattern) {_		AntPathStringMatcher matcher = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			matcher = this.stringMatcherCache.get(pattern)__		}_		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern)__			if (cachePatterns == null && this.stringMatcherCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return matcher__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.stringMatcherCache.put(pattern, matcher)__			}_		}_		return matcher__	};build,or,retrieve,an,link,ant,path,string,matcher,for,the,given,pattern,p,the,default,implementation,checks,this,ant,path,matcher,s,internal,cache,see,link,set,cache,patterns,creating,a,new,ant,path,string,matcher,instance,if,no,cached,copy,is,found,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,it,turns,the,default,cache,off,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,reoccurring,pattern,p,this,method,may,get,overridden,to,implement,a,custom,cache,strategy,param,pattern,the,pattern,to,match,against,never,code,null,return,a,corresponding,ant,path,string,matcher,never,code,null,see,set,cache,patterns;protected,ant,path,string,matcher,get,string,matcher,string,pattern,ant,path,string,matcher,matcher,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,if,cache,patterns,null,this,string,matcher,cache,size,deactivate,pattern,cache,return,matcher,if,cache,patterns,null,cache,patterns,boolean,value,this,string,matcher,cache,put,pattern,matcher,return,matcher
AntPathMatcher -> protected AntPathStringMatcher getStringMatcher(String pattern);1412083966;Build or retrieve an {@link AntPathStringMatcher} for the given pattern._<p>The default implementation checks this AntPathMatcher's internal cache_(see {@link #setCachePatterns}), creating a new AntPathStringMatcher instance_if no cached copy is found._When encountering too many patterns to cache at runtime (the threshold is 65536),_it turns the default cache off, assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a reoccurring pattern._<p>This method may get overridden to implement a custom cache strategy._@param pattern the pattern to match against (never {@code null})_@return a corresponding AntPathStringMatcher (never {@code null})_@see #setCachePatterns;protected AntPathStringMatcher getStringMatcher(String pattern) {_		AntPathStringMatcher matcher = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			matcher = this.stringMatcherCache.get(pattern)__		}_		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern)__			if (cachePatterns == null && this.stringMatcherCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return matcher__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.stringMatcherCache.put(pattern, matcher)__			}_		}_		return matcher__	};build,or,retrieve,an,link,ant,path,string,matcher,for,the,given,pattern,p,the,default,implementation,checks,this,ant,path,matcher,s,internal,cache,see,link,set,cache,patterns,creating,a,new,ant,path,string,matcher,instance,if,no,cached,copy,is,found,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,it,turns,the,default,cache,off,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,reoccurring,pattern,p,this,method,may,get,overridden,to,implement,a,custom,cache,strategy,param,pattern,the,pattern,to,match,against,never,code,null,return,a,corresponding,ant,path,string,matcher,never,code,null,see,set,cache,patterns;protected,ant,path,string,matcher,get,string,matcher,string,pattern,ant,path,string,matcher,matcher,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,if,cache,patterns,null,this,string,matcher,cache,size,deactivate,pattern,cache,return,matcher,if,cache,patterns,null,cache,patterns,boolean,value,this,string,matcher,cache,put,pattern,matcher,return,matcher
AntPathMatcher -> protected AntPathStringMatcher getStringMatcher(String pattern);1412101078;Build or retrieve an {@link AntPathStringMatcher} for the given pattern._<p>The default implementation checks this AntPathMatcher's internal cache_(see {@link #setCachePatterns}), creating a new AntPathStringMatcher instance_if no cached copy is found._When encountering too many patterns to cache at runtime (the threshold is 65536),_it turns the default cache off, assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a reoccurring pattern._<p>This method may get overridden to implement a custom cache strategy._@param pattern the pattern to match against (never {@code null})_@return a corresponding AntPathStringMatcher (never {@code null})_@see #setCachePatterns;protected AntPathStringMatcher getStringMatcher(String pattern) {_		AntPathStringMatcher matcher = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			matcher = this.stringMatcherCache.get(pattern)__		}_		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern)__			if (cachePatterns == null && this.stringMatcherCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return matcher__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.stringMatcherCache.put(pattern, matcher)__			}_		}_		return matcher__	};build,or,retrieve,an,link,ant,path,string,matcher,for,the,given,pattern,p,the,default,implementation,checks,this,ant,path,matcher,s,internal,cache,see,link,set,cache,patterns,creating,a,new,ant,path,string,matcher,instance,if,no,cached,copy,is,found,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,it,turns,the,default,cache,off,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,reoccurring,pattern,p,this,method,may,get,overridden,to,implement,a,custom,cache,strategy,param,pattern,the,pattern,to,match,against,never,code,null,return,a,corresponding,ant,path,string,matcher,never,code,null,see,set,cache,patterns;protected,ant,path,string,matcher,get,string,matcher,string,pattern,ant,path,string,matcher,matcher,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,if,cache,patterns,null,this,string,matcher,cache,size,deactivate,pattern,cache,return,matcher,if,cache,patterns,null,cache,patterns,boolean,value,this,string,matcher,cache,put,pattern,matcher,return,matcher
AntPathMatcher -> protected AntPathStringMatcher getStringMatcher(String pattern);1431086052;Build or retrieve an {@link AntPathStringMatcher} for the given pattern._<p>The default implementation checks this AntPathMatcher's internal cache_(see {@link #setCachePatterns}), creating a new AntPathStringMatcher instance_if no cached copy is found._<p>When encountering too many patterns to cache at runtime (the threshold is 65536),_it turns the default cache off, assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._<p>This method may be overridden to implement a custom cache strategy._@param pattern the pattern to match against (never {@code null})_@return a corresponding AntPathStringMatcher (never {@code null})_@see #setCachePatterns;protected AntPathStringMatcher getStringMatcher(String pattern) {_		AntPathStringMatcher matcher = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			matcher = this.stringMatcherCache.get(pattern)__		}_		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern)__			if (cachePatterns == null && this.stringMatcherCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return matcher__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.stringMatcherCache.put(pattern, matcher)__			}_		}_		return matcher__	};build,or,retrieve,an,link,ant,path,string,matcher,for,the,given,pattern,p,the,default,implementation,checks,this,ant,path,matcher,s,internal,cache,see,link,set,cache,patterns,creating,a,new,ant,path,string,matcher,instance,if,no,cached,copy,is,found,p,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,it,turns,the,default,cache,off,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,p,this,method,may,be,overridden,to,implement,a,custom,cache,strategy,param,pattern,the,pattern,to,match,against,never,code,null,return,a,corresponding,ant,path,string,matcher,never,code,null,see,set,cache,patterns;protected,ant,path,string,matcher,get,string,matcher,string,pattern,ant,path,string,matcher,matcher,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,if,cache,patterns,null,this,string,matcher,cache,size,deactivate,pattern,cache,return,matcher,if,cache,patterns,null,cache,patterns,boolean,value,this,string,matcher,cache,put,pattern,matcher,return,matcher
AntPathMatcher -> protected AntPathStringMatcher getStringMatcher(String pattern);1431178173;Build or retrieve an {@link AntPathStringMatcher} for the given pattern._<p>The default implementation checks this AntPathMatcher's internal cache_(see {@link #setCachePatterns}), creating a new AntPathStringMatcher instance_if no cached copy is found._<p>When encountering too many patterns to cache at runtime (the threshold is 65536),_it turns the default cache off, assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._<p>This method may be overridden to implement a custom cache strategy._@param pattern the pattern to match against (never {@code null})_@return a corresponding AntPathStringMatcher (never {@code null})_@see #setCachePatterns;protected AntPathStringMatcher getStringMatcher(String pattern) {_		AntPathStringMatcher matcher = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			matcher = this.stringMatcherCache.get(pattern)__		}_		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern)__			if (cachePatterns == null && this.stringMatcherCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return matcher__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.stringMatcherCache.put(pattern, matcher)__			}_		}_		return matcher__	};build,or,retrieve,an,link,ant,path,string,matcher,for,the,given,pattern,p,the,default,implementation,checks,this,ant,path,matcher,s,internal,cache,see,link,set,cache,patterns,creating,a,new,ant,path,string,matcher,instance,if,no,cached,copy,is,found,p,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,it,turns,the,default,cache,off,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,p,this,method,may,be,overridden,to,implement,a,custom,cache,strategy,param,pattern,the,pattern,to,match,against,never,code,null,return,a,corresponding,ant,path,string,matcher,never,code,null,see,set,cache,patterns;protected,ant,path,string,matcher,get,string,matcher,string,pattern,ant,path,string,matcher,matcher,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,if,cache,patterns,null,this,string,matcher,cache,size,deactivate,pattern,cache,return,matcher,if,cache,patterns,null,cache,patterns,boolean,value,this,string,matcher,cache,put,pattern,matcher,return,matcher
AntPathMatcher -> protected AntPathStringMatcher getStringMatcher(String pattern);1434572159;Build or retrieve an {@link AntPathStringMatcher} for the given pattern._<p>The default implementation checks this AntPathMatcher's internal cache_(see {@link #setCachePatterns}), creating a new AntPathStringMatcher instance_if no cached copy is found._<p>When encountering too many patterns to cache at runtime (the threshold is 65536),_it turns the default cache off, assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._<p>This method may be overridden to implement a custom cache strategy._@param pattern the pattern to match against (never {@code null})_@return a corresponding AntPathStringMatcher (never {@code null})_@see #setCachePatterns;protected AntPathStringMatcher getStringMatcher(String pattern) {_		AntPathStringMatcher matcher = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			matcher = this.stringMatcherCache.get(pattern)__		}_		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern)__			if (cachePatterns == null && this.stringMatcherCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return matcher__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.stringMatcherCache.put(pattern, matcher)__			}_		}_		return matcher__	};build,or,retrieve,an,link,ant,path,string,matcher,for,the,given,pattern,p,the,default,implementation,checks,this,ant,path,matcher,s,internal,cache,see,link,set,cache,patterns,creating,a,new,ant,path,string,matcher,instance,if,no,cached,copy,is,found,p,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,it,turns,the,default,cache,off,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,p,this,method,may,be,overridden,to,implement,a,custom,cache,strategy,param,pattern,the,pattern,to,match,against,never,code,null,return,a,corresponding,ant,path,string,matcher,never,code,null,see,set,cache,patterns;protected,ant,path,string,matcher,get,string,matcher,string,pattern,ant,path,string,matcher,matcher,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,if,cache,patterns,null,this,string,matcher,cache,size,deactivate,pattern,cache,return,matcher,if,cache,patterns,null,cache,patterns,boolean,value,this,string,matcher,cache,put,pattern,matcher,return,matcher
AntPathMatcher -> protected AntPathStringMatcher getStringMatcher(String pattern);1435239719;Build or retrieve an {@link AntPathStringMatcher} for the given pattern._<p>The default implementation checks this AntPathMatcher's internal cache_(see {@link #setCachePatterns}), creating a new AntPathStringMatcher instance_if no cached copy is found._<p>When encountering too many patterns to cache at runtime (the threshold is 65536),_it turns the default cache off, assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._<p>This method may be overridden to implement a custom cache strategy._@param pattern the pattern to match against (never {@code null})_@return a corresponding AntPathStringMatcher (never {@code null})_@see #setCachePatterns;protected AntPathStringMatcher getStringMatcher(String pattern) {_		AntPathStringMatcher matcher = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			matcher = this.stringMatcherCache.get(pattern)__		}_		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern)__			if (cachePatterns == null && this.stringMatcherCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return matcher__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.stringMatcherCache.put(pattern, matcher)__			}_		}_		return matcher__	};build,or,retrieve,an,link,ant,path,string,matcher,for,the,given,pattern,p,the,default,implementation,checks,this,ant,path,matcher,s,internal,cache,see,link,set,cache,patterns,creating,a,new,ant,path,string,matcher,instance,if,no,cached,copy,is,found,p,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,it,turns,the,default,cache,off,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,p,this,method,may,be,overridden,to,implement,a,custom,cache,strategy,param,pattern,the,pattern,to,match,against,never,code,null,return,a,corresponding,ant,path,string,matcher,never,code,null,see,set,cache,patterns;protected,ant,path,string,matcher,get,string,matcher,string,pattern,ant,path,string,matcher,matcher,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,if,cache,patterns,null,this,string,matcher,cache,size,deactivate,pattern,cache,return,matcher,if,cache,patterns,null,cache,patterns,boolean,value,this,string,matcher,cache,put,pattern,matcher,return,matcher
AntPathMatcher -> protected AntPathStringMatcher getStringMatcher(String pattern);1438166321;Build or retrieve an {@link AntPathStringMatcher} for the given pattern._<p>The default implementation checks this AntPathMatcher's internal cache_(see {@link #setCachePatterns}), creating a new AntPathStringMatcher instance_if no cached copy is found._<p>When encountering too many patterns to cache at runtime (the threshold is 65536),_it turns the default cache off, assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._<p>This method may be overridden to implement a custom cache strategy._@param pattern the pattern to match against (never {@code null})_@return a corresponding AntPathStringMatcher (never {@code null})_@see #setCachePatterns;protected AntPathStringMatcher getStringMatcher(String pattern) {_		AntPathStringMatcher matcher = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			matcher = this.stringMatcherCache.get(pattern)__		}_		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern, this.caseSensitive)__			if (cachePatterns == null && this.stringMatcherCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return matcher__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.stringMatcherCache.put(pattern, matcher)__			}_		}_		return matcher__	};build,or,retrieve,an,link,ant,path,string,matcher,for,the,given,pattern,p,the,default,implementation,checks,this,ant,path,matcher,s,internal,cache,see,link,set,cache,patterns,creating,a,new,ant,path,string,matcher,instance,if,no,cached,copy,is,found,p,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,it,turns,the,default,cache,off,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,p,this,method,may,be,overridden,to,implement,a,custom,cache,strategy,param,pattern,the,pattern,to,match,against,never,code,null,return,a,corresponding,ant,path,string,matcher,never,code,null,see,set,cache,patterns;protected,ant,path,string,matcher,get,string,matcher,string,pattern,ant,path,string,matcher,matcher,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,this,case,sensitive,if,cache,patterns,null,this,string,matcher,cache,size,deactivate,pattern,cache,return,matcher,if,cache,patterns,null,cache,patterns,boolean,value,this,string,matcher,cache,put,pattern,matcher,return,matcher
AntPathMatcher -> protected AntPathStringMatcher getStringMatcher(String pattern);1455100778;Build or retrieve an {@link AntPathStringMatcher} for the given pattern._<p>The default implementation checks this AntPathMatcher's internal cache_(see {@link #setCachePatterns}), creating a new AntPathStringMatcher instance_if no cached copy is found._<p>When encountering too many patterns to cache at runtime (the threshold is 65536),_it turns the default cache off, assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._<p>This method may be overridden to implement a custom cache strategy._@param pattern the pattern to match against (never {@code null})_@return a corresponding AntPathStringMatcher (never {@code null})_@see #setCachePatterns;protected AntPathStringMatcher getStringMatcher(String pattern) {_		AntPathStringMatcher matcher = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			matcher = this.stringMatcherCache.get(pattern)__		}_		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern, this.caseSensitive)__			if (cachePatterns == null && this.stringMatcherCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return matcher__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.stringMatcherCache.put(pattern, matcher)__			}_		}_		return matcher__	};build,or,retrieve,an,link,ant,path,string,matcher,for,the,given,pattern,p,the,default,implementation,checks,this,ant,path,matcher,s,internal,cache,see,link,set,cache,patterns,creating,a,new,ant,path,string,matcher,instance,if,no,cached,copy,is,found,p,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,it,turns,the,default,cache,off,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,p,this,method,may,be,overridden,to,implement,a,custom,cache,strategy,param,pattern,the,pattern,to,match,against,never,code,null,return,a,corresponding,ant,path,string,matcher,never,code,null,see,set,cache,patterns;protected,ant,path,string,matcher,get,string,matcher,string,pattern,ant,path,string,matcher,matcher,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,this,case,sensitive,if,cache,patterns,null,this,string,matcher,cache,size,deactivate,pattern,cache,return,matcher,if,cache,patterns,null,cache,patterns,boolean,value,this,string,matcher,cache,put,pattern,matcher,return,matcher
AntPathMatcher -> protected AntPathStringMatcher getStringMatcher(String pattern);1455850198;Build or retrieve an {@link AntPathStringMatcher} for the given pattern._<p>The default implementation checks this AntPathMatcher's internal cache_(see {@link #setCachePatterns}), creating a new AntPathStringMatcher instance_if no cached copy is found._<p>When encountering too many patterns to cache at runtime (the threshold is 65536),_it turns the default cache off, assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._<p>This method may be overridden to implement a custom cache strategy._@param pattern the pattern to match against (never {@code null})_@return a corresponding AntPathStringMatcher (never {@code null})_@see #setCachePatterns;protected AntPathStringMatcher getStringMatcher(String pattern) {_		AntPathStringMatcher matcher = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			matcher = this.stringMatcherCache.get(pattern)__		}_		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern, this.caseSensitive)__			if (cachePatterns == null && this.stringMatcherCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return matcher__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.stringMatcherCache.put(pattern, matcher)__			}_		}_		return matcher__	};build,or,retrieve,an,link,ant,path,string,matcher,for,the,given,pattern,p,the,default,implementation,checks,this,ant,path,matcher,s,internal,cache,see,link,set,cache,patterns,creating,a,new,ant,path,string,matcher,instance,if,no,cached,copy,is,found,p,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,it,turns,the,default,cache,off,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,p,this,method,may,be,overridden,to,implement,a,custom,cache,strategy,param,pattern,the,pattern,to,match,against,never,code,null,return,a,corresponding,ant,path,string,matcher,never,code,null,see,set,cache,patterns;protected,ant,path,string,matcher,get,string,matcher,string,pattern,ant,path,string,matcher,matcher,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,this,case,sensitive,if,cache,patterns,null,this,string,matcher,cache,size,deactivate,pattern,cache,return,matcher,if,cache,patterns,null,cache,patterns,boolean,value,this,string,matcher,cache,put,pattern,matcher,return,matcher
AntPathMatcher -> protected AntPathStringMatcher getStringMatcher(String pattern);1460754629;Build or retrieve an {@link AntPathStringMatcher} for the given pattern._<p>The default implementation checks this AntPathMatcher's internal cache_(see {@link #setCachePatterns}), creating a new AntPathStringMatcher instance_if no cached copy is found._<p>When encountering too many patterns to cache at runtime (the threshold is 65536),_it turns the default cache off, assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._<p>This method may be overridden to implement a custom cache strategy._@param pattern the pattern to match against (never {@code null})_@return a corresponding AntPathStringMatcher (never {@code null})_@see #setCachePatterns;protected AntPathStringMatcher getStringMatcher(String pattern) {_		AntPathStringMatcher matcher = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			matcher = this.stringMatcherCache.get(pattern)__		}_		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern, this.caseSensitive)__			if (cachePatterns == null && this.stringMatcherCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return matcher__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.stringMatcherCache.put(pattern, matcher)__			}_		}_		return matcher__	};build,or,retrieve,an,link,ant,path,string,matcher,for,the,given,pattern,p,the,default,implementation,checks,this,ant,path,matcher,s,internal,cache,see,link,set,cache,patterns,creating,a,new,ant,path,string,matcher,instance,if,no,cached,copy,is,found,p,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,it,turns,the,default,cache,off,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,p,this,method,may,be,overridden,to,implement,a,custom,cache,strategy,param,pattern,the,pattern,to,match,against,never,code,null,return,a,corresponding,ant,path,string,matcher,never,code,null,see,set,cache,patterns;protected,ant,path,string,matcher,get,string,matcher,string,pattern,ant,path,string,matcher,matcher,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,this,case,sensitive,if,cache,patterns,null,this,string,matcher,cache,size,deactivate,pattern,cache,return,matcher,if,cache,patterns,null,cache,patterns,boolean,value,this,string,matcher,cache,put,pattern,matcher,return,matcher
AntPathMatcher -> protected AntPathStringMatcher getStringMatcher(String pattern);1462393686;Build or retrieve an {@link AntPathStringMatcher} for the given pattern._<p>The default implementation checks this AntPathMatcher's internal cache_(see {@link #setCachePatterns}), creating a new AntPathStringMatcher instance_if no cached copy is found._<p>When encountering too many patterns to cache at runtime (the threshold is 65536),_it turns the default cache off, assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._<p>This method may be overridden to implement a custom cache strategy._@param pattern the pattern to match against (never {@code null})_@return a corresponding AntPathStringMatcher (never {@code null})_@see #setCachePatterns;protected AntPathStringMatcher getStringMatcher(String pattern) {_		AntPathStringMatcher matcher = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			matcher = this.stringMatcherCache.get(pattern)__		}_		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern, this.caseSensitive)__			if (cachePatterns == null && this.stringMatcherCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return matcher__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.stringMatcherCache.put(pattern, matcher)__			}_		}_		return matcher__	};build,or,retrieve,an,link,ant,path,string,matcher,for,the,given,pattern,p,the,default,implementation,checks,this,ant,path,matcher,s,internal,cache,see,link,set,cache,patterns,creating,a,new,ant,path,string,matcher,instance,if,no,cached,copy,is,found,p,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,it,turns,the,default,cache,off,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,p,this,method,may,be,overridden,to,implement,a,custom,cache,strategy,param,pattern,the,pattern,to,match,against,never,code,null,return,a,corresponding,ant,path,string,matcher,never,code,null,see,set,cache,patterns;protected,ant,path,string,matcher,get,string,matcher,string,pattern,ant,path,string,matcher,matcher,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,this,case,sensitive,if,cache,patterns,null,this,string,matcher,cache,size,deactivate,pattern,cache,return,matcher,if,cache,patterns,null,cache,patterns,boolean,value,this,string,matcher,cache,put,pattern,matcher,return,matcher
AntPathMatcher -> protected AntPathStringMatcher getStringMatcher(String pattern);1467730834;Build or retrieve an {@link AntPathStringMatcher} for the given pattern._<p>The default implementation checks this AntPathMatcher's internal cache_(see {@link #setCachePatterns}), creating a new AntPathStringMatcher instance_if no cached copy is found._<p>When encountering too many patterns to cache at runtime (the threshold is 65536),_it turns the default cache off, assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._<p>This method may be overridden to implement a custom cache strategy._@param pattern the pattern to match against (never {@code null})_@return a corresponding AntPathStringMatcher (never {@code null})_@see #setCachePatterns;protected AntPathStringMatcher getStringMatcher(String pattern) {_		AntPathStringMatcher matcher = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			matcher = this.stringMatcherCache.get(pattern)__		}_		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern, this.caseSensitive)__			if (cachePatterns == null && this.stringMatcherCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return matcher__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.stringMatcherCache.put(pattern, matcher)__			}_		}_		return matcher__	};build,or,retrieve,an,link,ant,path,string,matcher,for,the,given,pattern,p,the,default,implementation,checks,this,ant,path,matcher,s,internal,cache,see,link,set,cache,patterns,creating,a,new,ant,path,string,matcher,instance,if,no,cached,copy,is,found,p,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,it,turns,the,default,cache,off,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,p,this,method,may,be,overridden,to,implement,a,custom,cache,strategy,param,pattern,the,pattern,to,match,against,never,code,null,return,a,corresponding,ant,path,string,matcher,never,code,null,see,set,cache,patterns;protected,ant,path,string,matcher,get,string,matcher,string,pattern,ant,path,string,matcher,matcher,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,this,case,sensitive,if,cache,patterns,null,this,string,matcher,cache,size,deactivate,pattern,cache,return,matcher,if,cache,patterns,null,cache,patterns,boolean,value,this,string,matcher,cache,put,pattern,matcher,return,matcher
AntPathMatcher -> protected AntPathStringMatcher getStringMatcher(String pattern);1468327638;Build or retrieve an {@link AntPathStringMatcher} for the given pattern._<p>The default implementation checks this AntPathMatcher's internal cache_(see {@link #setCachePatterns}), creating a new AntPathStringMatcher instance_if no cached copy is found._<p>When encountering too many patterns to cache at runtime (the threshold is 65536),_it turns the default cache off, assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._<p>This method may be overridden to implement a custom cache strategy._@param pattern the pattern to match against (never {@code null})_@return a corresponding AntPathStringMatcher (never {@code null})_@see #setCachePatterns;protected AntPathStringMatcher getStringMatcher(String pattern) {_		AntPathStringMatcher matcher = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			matcher = this.stringMatcherCache.get(pattern)__		}_		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern, this.caseSensitive)__			if (cachePatterns == null && this.stringMatcherCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return matcher__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.stringMatcherCache.put(pattern, matcher)__			}_		}_		return matcher__	};build,or,retrieve,an,link,ant,path,string,matcher,for,the,given,pattern,p,the,default,implementation,checks,this,ant,path,matcher,s,internal,cache,see,link,set,cache,patterns,creating,a,new,ant,path,string,matcher,instance,if,no,cached,copy,is,found,p,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,it,turns,the,default,cache,off,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,p,this,method,may,be,overridden,to,implement,a,custom,cache,strategy,param,pattern,the,pattern,to,match,against,never,code,null,return,a,corresponding,ant,path,string,matcher,never,code,null,see,set,cache,patterns;protected,ant,path,string,matcher,get,string,matcher,string,pattern,ant,path,string,matcher,matcher,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,this,case,sensitive,if,cache,patterns,null,this,string,matcher,cache,size,deactivate,pattern,cache,return,matcher,if,cache,patterns,null,cache,patterns,boolean,value,this,string,matcher,cache,put,pattern,matcher,return,matcher
AntPathMatcher -> protected AntPathStringMatcher getStringMatcher(String pattern);1472808958;Build or retrieve an {@link AntPathStringMatcher} for the given pattern._<p>The default implementation checks this AntPathMatcher's internal cache_(see {@link #setCachePatterns}), creating a new AntPathStringMatcher instance_if no cached copy is found._<p>When encountering too many patterns to cache at runtime (the threshold is 65536),_it turns the default cache off, assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._<p>This method may be overridden to implement a custom cache strategy._@param pattern the pattern to match against (never {@code null})_@return a corresponding AntPathStringMatcher (never {@code null})_@see #setCachePatterns;protected AntPathStringMatcher getStringMatcher(String pattern) {_		AntPathStringMatcher matcher = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			matcher = this.stringMatcherCache.get(pattern)__		}_		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern, this.caseSensitive)__			if (cachePatterns == null && this.stringMatcherCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return matcher__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.stringMatcherCache.put(pattern, matcher)__			}_		}_		return matcher__	};build,or,retrieve,an,link,ant,path,string,matcher,for,the,given,pattern,p,the,default,implementation,checks,this,ant,path,matcher,s,internal,cache,see,link,set,cache,patterns,creating,a,new,ant,path,string,matcher,instance,if,no,cached,copy,is,found,p,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,it,turns,the,default,cache,off,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,p,this,method,may,be,overridden,to,implement,a,custom,cache,strategy,param,pattern,the,pattern,to,match,against,never,code,null,return,a,corresponding,ant,path,string,matcher,never,code,null,see,set,cache,patterns;protected,ant,path,string,matcher,get,string,matcher,string,pattern,ant,path,string,matcher,matcher,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,this,case,sensitive,if,cache,patterns,null,this,string,matcher,cache,size,deactivate,pattern,cache,return,matcher,if,cache,patterns,null,cache,patterns,boolean,value,this,string,matcher,cache,put,pattern,matcher,return,matcher
AntPathMatcher -> protected AntPathStringMatcher getStringMatcher(String pattern);1493317597;Build or retrieve an {@link AntPathStringMatcher} for the given pattern._<p>The default implementation checks this AntPathMatcher's internal cache_(see {@link #setCachePatterns}), creating a new AntPathStringMatcher instance_if no cached copy is found._<p>When encountering too many patterns to cache at runtime (the threshold is 65536),_it turns the default cache off, assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._<p>This method may be overridden to implement a custom cache strategy._@param pattern the pattern to match against (never {@code null})_@return a corresponding AntPathStringMatcher (never {@code null})_@see #setCachePatterns;protected AntPathStringMatcher getStringMatcher(String pattern) {_		AntPathStringMatcher matcher = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			matcher = this.stringMatcherCache.get(pattern)__		}_		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern, this.caseSensitive)__			if (cachePatterns == null && this.stringMatcherCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return matcher__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.stringMatcherCache.put(pattern, matcher)__			}_		}_		return matcher__	};build,or,retrieve,an,link,ant,path,string,matcher,for,the,given,pattern,p,the,default,implementation,checks,this,ant,path,matcher,s,internal,cache,see,link,set,cache,patterns,creating,a,new,ant,path,string,matcher,instance,if,no,cached,copy,is,found,p,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,it,turns,the,default,cache,off,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,p,this,method,may,be,overridden,to,implement,a,custom,cache,strategy,param,pattern,the,pattern,to,match,against,never,code,null,return,a,corresponding,ant,path,string,matcher,never,code,null,see,set,cache,patterns;protected,ant,path,string,matcher,get,string,matcher,string,pattern,ant,path,string,matcher,matcher,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,this,case,sensitive,if,cache,patterns,null,this,string,matcher,cache,size,deactivate,pattern,cache,return,matcher,if,cache,patterns,null,cache,patterns,boolean,value,this,string,matcher,cache,put,pattern,matcher,return,matcher
AntPathMatcher -> protected AntPathStringMatcher getStringMatcher(String pattern);1493321510;Build or retrieve an {@link AntPathStringMatcher} for the given pattern._<p>The default implementation checks this AntPathMatcher's internal cache_(see {@link #setCachePatterns}), creating a new AntPathStringMatcher instance_if no cached copy is found._<p>When encountering too many patterns to cache at runtime (the threshold is 65536),_it turns the default cache off, assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._<p>This method may be overridden to implement a custom cache strategy._@param pattern the pattern to match against (never {@code null})_@return a corresponding AntPathStringMatcher (never {@code null})_@see #setCachePatterns;protected AntPathStringMatcher getStringMatcher(String pattern) {_		AntPathStringMatcher matcher = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			matcher = this.stringMatcherCache.get(pattern)__		}_		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern, this.caseSensitive)__			if (cachePatterns == null && this.stringMatcherCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return matcher__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.stringMatcherCache.put(pattern, matcher)__			}_		}_		return matcher__	};build,or,retrieve,an,link,ant,path,string,matcher,for,the,given,pattern,p,the,default,implementation,checks,this,ant,path,matcher,s,internal,cache,see,link,set,cache,patterns,creating,a,new,ant,path,string,matcher,instance,if,no,cached,copy,is,found,p,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,it,turns,the,default,cache,off,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,p,this,method,may,be,overridden,to,implement,a,custom,cache,strategy,param,pattern,the,pattern,to,match,against,never,code,null,return,a,corresponding,ant,path,string,matcher,never,code,null,see,set,cache,patterns;protected,ant,path,string,matcher,get,string,matcher,string,pattern,ant,path,string,matcher,matcher,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,this,case,sensitive,if,cache,patterns,null,this,string,matcher,cache,size,deactivate,pattern,cache,return,matcher,if,cache,patterns,null,cache,patterns,boolean,value,this,string,matcher,cache,put,pattern,matcher,return,matcher
AntPathMatcher -> protected AntPathStringMatcher getStringMatcher(String pattern);1496259743;Build or retrieve an {@link AntPathStringMatcher} for the given pattern._<p>The default implementation checks this AntPathMatcher's internal cache_(see {@link #setCachePatterns}), creating a new AntPathStringMatcher instance_if no cached copy is found._<p>When encountering too many patterns to cache at runtime (the threshold is 65536),_it turns the default cache off, assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._<p>This method may be overridden to implement a custom cache strategy._@param pattern the pattern to match against (never {@code null})_@return a corresponding AntPathStringMatcher (never {@code null})_@see #setCachePatterns;protected AntPathStringMatcher getStringMatcher(String pattern) {_		AntPathStringMatcher matcher = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			matcher = this.stringMatcherCache.get(pattern)__		}_		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern, this.caseSensitive)__			if (cachePatterns == null && this.stringMatcherCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return matcher__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.stringMatcherCache.put(pattern, matcher)__			}_		}_		return matcher__	};build,or,retrieve,an,link,ant,path,string,matcher,for,the,given,pattern,p,the,default,implementation,checks,this,ant,path,matcher,s,internal,cache,see,link,set,cache,patterns,creating,a,new,ant,path,string,matcher,instance,if,no,cached,copy,is,found,p,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,it,turns,the,default,cache,off,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,p,this,method,may,be,overridden,to,implement,a,custom,cache,strategy,param,pattern,the,pattern,to,match,against,never,code,null,return,a,corresponding,ant,path,string,matcher,never,code,null,see,set,cache,patterns;protected,ant,path,string,matcher,get,string,matcher,string,pattern,ant,path,string,matcher,matcher,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,this,case,sensitive,if,cache,patterns,null,this,string,matcher,cache,size,deactivate,pattern,cache,return,matcher,if,cache,patterns,null,cache,patterns,boolean,value,this,string,matcher,cache,put,pattern,matcher,return,matcher
AntPathMatcher -> protected AntPathStringMatcher getStringMatcher(String pattern);1496837955;Build or retrieve an {@link AntPathStringMatcher} for the given pattern._<p>The default implementation checks this AntPathMatcher's internal cache_(see {@link #setCachePatterns}), creating a new AntPathStringMatcher instance_if no cached copy is found._<p>When encountering too many patterns to cache at runtime (the threshold is 65536),_it turns the default cache off, assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._<p>This method may be overridden to implement a custom cache strategy._@param pattern the pattern to match against (never {@code null})_@return a corresponding AntPathStringMatcher (never {@code null})_@see #setCachePatterns;protected AntPathStringMatcher getStringMatcher(String pattern) {_		AntPathStringMatcher matcher = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			matcher = this.stringMatcherCache.get(pattern)__		}_		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern, this.caseSensitive)__			if (cachePatterns == null && this.stringMatcherCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return matcher__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.stringMatcherCache.put(pattern, matcher)__			}_		}_		return matcher__	};build,or,retrieve,an,link,ant,path,string,matcher,for,the,given,pattern,p,the,default,implementation,checks,this,ant,path,matcher,s,internal,cache,see,link,set,cache,patterns,creating,a,new,ant,path,string,matcher,instance,if,no,cached,copy,is,found,p,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,it,turns,the,default,cache,off,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,p,this,method,may,be,overridden,to,implement,a,custom,cache,strategy,param,pattern,the,pattern,to,match,against,never,code,null,return,a,corresponding,ant,path,string,matcher,never,code,null,see,set,cache,patterns;protected,ant,path,string,matcher,get,string,matcher,string,pattern,ant,path,string,matcher,matcher,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,this,case,sensitive,if,cache,patterns,null,this,string,matcher,cache,size,deactivate,pattern,cache,return,matcher,if,cache,patterns,null,cache,patterns,boolean,value,this,string,matcher,cache,put,pattern,matcher,return,matcher
AntPathMatcher -> protected AntPathStringMatcher getStringMatcher(String pattern);1498780456;Build or retrieve an {@link AntPathStringMatcher} for the given pattern._<p>The default implementation checks this AntPathMatcher's internal cache_(see {@link #setCachePatterns}), creating a new AntPathStringMatcher instance_if no cached copy is found._<p>When encountering too many patterns to cache at runtime (the threshold is 65536),_it turns the default cache off, assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._<p>This method may be overridden to implement a custom cache strategy._@param pattern the pattern to match against (never {@code null})_@return a corresponding AntPathStringMatcher (never {@code null})_@see #setCachePatterns;protected AntPathStringMatcher getStringMatcher(String pattern) {_		AntPathStringMatcher matcher = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			matcher = this.stringMatcherCache.get(pattern)__		}_		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern, this.caseSensitive)__			if (cachePatterns == null && this.stringMatcherCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return matcher__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.stringMatcherCache.put(pattern, matcher)__			}_		}_		return matcher__	};build,or,retrieve,an,link,ant,path,string,matcher,for,the,given,pattern,p,the,default,implementation,checks,this,ant,path,matcher,s,internal,cache,see,link,set,cache,patterns,creating,a,new,ant,path,string,matcher,instance,if,no,cached,copy,is,found,p,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,it,turns,the,default,cache,off,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,p,this,method,may,be,overridden,to,implement,a,custom,cache,strategy,param,pattern,the,pattern,to,match,against,never,code,null,return,a,corresponding,ant,path,string,matcher,never,code,null,see,set,cache,patterns;protected,ant,path,string,matcher,get,string,matcher,string,pattern,ant,path,string,matcher,matcher,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,this,case,sensitive,if,cache,patterns,null,this,string,matcher,cache,size,deactivate,pattern,cache,return,matcher,if,cache,patterns,null,cache,patterns,boolean,value,this,string,matcher,cache,put,pattern,matcher,return,matcher
AntPathMatcher -> protected AntPathStringMatcher getStringMatcher(String pattern);1518772998;Build or retrieve an {@link AntPathStringMatcher} for the given pattern._<p>The default implementation checks this AntPathMatcher's internal cache_(see {@link #setCachePatterns}), creating a new AntPathStringMatcher instance_if no cached copy is found._<p>When encountering too many patterns to cache at runtime (the threshold is 65536),_it turns the default cache off, assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._<p>This method may be overridden to implement a custom cache strategy._@param pattern the pattern to match against (never {@code null})_@return a corresponding AntPathStringMatcher (never {@code null})_@see #setCachePatterns;protected AntPathStringMatcher getStringMatcher(String pattern) {_		AntPathStringMatcher matcher = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			matcher = this.stringMatcherCache.get(pattern)__		}_		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern, this.caseSensitive)__			if (cachePatterns == null && this.stringMatcherCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return matcher__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.stringMatcherCache.put(pattern, matcher)__			}_		}_		return matcher__	};build,or,retrieve,an,link,ant,path,string,matcher,for,the,given,pattern,p,the,default,implementation,checks,this,ant,path,matcher,s,internal,cache,see,link,set,cache,patterns,creating,a,new,ant,path,string,matcher,instance,if,no,cached,copy,is,found,p,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,it,turns,the,default,cache,off,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,p,this,method,may,be,overridden,to,implement,a,custom,cache,strategy,param,pattern,the,pattern,to,match,against,never,code,null,return,a,corresponding,ant,path,string,matcher,never,code,null,see,set,cache,patterns;protected,ant,path,string,matcher,get,string,matcher,string,pattern,ant,path,string,matcher,matcher,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,this,case,sensitive,if,cache,patterns,null,this,string,matcher,cache,size,deactivate,pattern,cache,return,matcher,if,cache,patterns,null,cache,patterns,boolean,value,this,string,matcher,cache,put,pattern,matcher,return,matcher
AntPathMatcher -> protected AntPathStringMatcher getStringMatcher(String pattern);1530174524;Build or retrieve an {@link AntPathStringMatcher} for the given pattern._<p>The default implementation checks this AntPathMatcher's internal cache_(see {@link #setCachePatterns}), creating a new AntPathStringMatcher instance_if no cached copy is found._<p>When encountering too many patterns to cache at runtime (the threshold is 65536),_it turns the default cache off, assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._<p>This method may be overridden to implement a custom cache strategy._@param pattern the pattern to match against (never {@code null})_@return a corresponding AntPathStringMatcher (never {@code null})_@see #setCachePatterns;protected AntPathStringMatcher getStringMatcher(String pattern) {_		AntPathStringMatcher matcher = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			matcher = this.stringMatcherCache.get(pattern)__		}_		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern, this.caseSensitive)__			if (cachePatterns == null && this.stringMatcherCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return matcher__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.stringMatcherCache.put(pattern, matcher)__			}_		}_		return matcher__	};build,or,retrieve,an,link,ant,path,string,matcher,for,the,given,pattern,p,the,default,implementation,checks,this,ant,path,matcher,s,internal,cache,see,link,set,cache,patterns,creating,a,new,ant,path,string,matcher,instance,if,no,cached,copy,is,found,p,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,it,turns,the,default,cache,off,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,p,this,method,may,be,overridden,to,implement,a,custom,cache,strategy,param,pattern,the,pattern,to,match,against,never,code,null,return,a,corresponding,ant,path,string,matcher,never,code,null,see,set,cache,patterns;protected,ant,path,string,matcher,get,string,matcher,string,pattern,ant,path,string,matcher,matcher,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,this,case,sensitive,if,cache,patterns,null,this,string,matcher,cache,size,deactivate,pattern,cache,return,matcher,if,cache,patterns,null,cache,patterns,boolean,value,this,string,matcher,cache,put,pattern,matcher,return,matcher
AntPathMatcher -> protected AntPathStringMatcher getStringMatcher(String pattern);1530174524;Build or retrieve an {@link AntPathStringMatcher} for the given pattern._<p>The default implementation checks this AntPathMatcher's internal cache_(see {@link #setCachePatterns}), creating a new AntPathStringMatcher instance_if no cached copy is found._<p>When encountering too many patterns to cache at runtime (the threshold is 65536),_it turns the default cache off, assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._<p>This method may be overridden to implement a custom cache strategy._@param pattern the pattern to match against (never {@code null})_@return a corresponding AntPathStringMatcher (never {@code null})_@see #setCachePatterns;protected AntPathStringMatcher getStringMatcher(String pattern) {_		AntPathStringMatcher matcher = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			matcher = this.stringMatcherCache.get(pattern)__		}_		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern, this.caseSensitive)__			if (cachePatterns == null && this.stringMatcherCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return matcher__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.stringMatcherCache.put(pattern, matcher)__			}_		}_		return matcher__	};build,or,retrieve,an,link,ant,path,string,matcher,for,the,given,pattern,p,the,default,implementation,checks,this,ant,path,matcher,s,internal,cache,see,link,set,cache,patterns,creating,a,new,ant,path,string,matcher,instance,if,no,cached,copy,is,found,p,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,it,turns,the,default,cache,off,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,p,this,method,may,be,overridden,to,implement,a,custom,cache,strategy,param,pattern,the,pattern,to,match,against,never,code,null,return,a,corresponding,ant,path,string,matcher,never,code,null,see,set,cache,patterns;protected,ant,path,string,matcher,get,string,matcher,string,pattern,ant,path,string,matcher,matcher,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,this,case,sensitive,if,cache,patterns,null,this,string,matcher,cache,size,deactivate,pattern,cache,return,matcher,if,cache,patterns,null,cache,patterns,boolean,value,this,string,matcher,cache,put,pattern,matcher,return,matcher
AntPathMatcher -> protected AntPathStringMatcher getStringMatcher(String pattern);1535316501;Build or retrieve an {@link AntPathStringMatcher} for the given pattern._<p>The default implementation checks this AntPathMatcher's internal cache_(see {@link #setCachePatterns}), creating a new AntPathStringMatcher instance_if no cached copy is found._<p>When encountering too many patterns to cache at runtime (the threshold is 65536),_it turns the default cache off, assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._<p>This method may be overridden to implement a custom cache strategy._@param pattern the pattern to match against (never {@code null})_@return a corresponding AntPathStringMatcher (never {@code null})_@see #setCachePatterns;protected AntPathStringMatcher getStringMatcher(String pattern) {_		AntPathStringMatcher matcher = null__		Boolean cachePatterns = this.cachePatterns__		if (cachePatterns == null || cachePatterns.booleanValue()) {_			matcher = this.stringMatcherCache.get(pattern)__		}_		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern, this.caseSensitive)__			if (cachePatterns == null && this.stringMatcherCache.size() >= CACHE_TURNOFF_THRESHOLD) {_				_				_				_				deactivatePatternCache()__				return matcher__			}_			if (cachePatterns == null || cachePatterns.booleanValue()) {_				this.stringMatcherCache.put(pattern, matcher)__			}_		}_		return matcher__	};build,or,retrieve,an,link,ant,path,string,matcher,for,the,given,pattern,p,the,default,implementation,checks,this,ant,path,matcher,s,internal,cache,see,link,set,cache,patterns,creating,a,new,ant,path,string,matcher,instance,if,no,cached,copy,is,found,p,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,it,turns,the,default,cache,off,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,p,this,method,may,be,overridden,to,implement,a,custom,cache,strategy,param,pattern,the,pattern,to,match,against,never,code,null,return,a,corresponding,ant,path,string,matcher,never,code,null,see,set,cache,patterns;protected,ant,path,string,matcher,get,string,matcher,string,pattern,ant,path,string,matcher,matcher,null,boolean,cache,patterns,this,cache,patterns,if,cache,patterns,null,cache,patterns,boolean,value,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,this,case,sensitive,if,cache,patterns,null,this,string,matcher,cache,size,deactivate,pattern,cache,return,matcher,if,cache,patterns,null,cache,patterns,boolean,value,this,string,matcher,cache,put,pattern,matcher,return,matcher
AntPathMatcher -> public String extractPathWithinPattern(String pattern, String path);1328020251;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'<code>/docs/cvs/commit.html</code>' and '<code>/docs/cvs/commit.html</code> -> ''</li>_<li>'<code>/docs/*</code>' and '<code>/docs/cvs/commit</code> -> '<code>cvs/commit</code>'</li>_<li>'<code>/docs/cvs/*.html</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>commit.html</code>'</li>_<li>'<code>/docs/**</code>' and '<code>/docs/cvs/commit</code> -> '<code>cvs/commit</code>'</li>_<li>'<code>/docs/**\/*.html</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>cvs/commit.html</code>'</li>_<li>'<code>/*.html</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>docs/cvs/commit.html</code>'</li>_<li>'<code>*.html</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>/docs/cvs/commit.html</code>'</li>_<li>'<code>*</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>/docs/cvs/commit.html</code>'</li> </ul>_<p>Assumes that {@link #match} returns <code>true</code> for '<code>pattern</code>' and '<code>path</code>', but_does <strong>not</strong> enforce this.;public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator)___		StringBuilder builder = new StringBuilder()___		_		int puts = 0__		for (int i = 0_ i < patternParts.length_ i++) {_			String patternPart = patternParts[i]__			if ((patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) && pathParts.length >= i + 1) {_				if (puts > 0 || (i == 0 && !pattern.startsWith(this.pathSeparator))) {_					builder.append(this.pathSeparator)__				}_				builder.append(pathParts[i])__				puts++__			}_		}__		_		for (int i = patternParts.length_ i < pathParts.length_ i++) {_			if (puts > 0 || i > 0) {_				builder.append(this.pathSeparator)__			}_			builder.append(pathParts[i])__		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,code,and,code,docs,cvs,commit,html,code,li,li,code,docs,code,and,code,docs,cvs,commit,code,code,cvs,commit,code,li,li,code,docs,cvs,html,code,and,code,docs,cvs,commit,html,code,code,commit,html,code,li,li,code,docs,code,and,code,docs,cvs,commit,code,code,cvs,commit,code,li,li,code,docs,html,code,and,code,docs,cvs,commit,html,code,code,cvs,commit,html,code,li,li,code,html,code,and,code,docs,cvs,commit,html,code,code,docs,cvs,commit,html,code,li,li,code,html,code,and,code,docs,cvs,commit,html,code,code,docs,cvs,commit,html,code,li,li,code,code,and,code,docs,cvs,commit,html,code,code,docs,cvs,commit,html,code,li,ul,p,assumes,that,link,match,returns,code,true,code,for,code,pattern,code,and,code,path,code,but,does,strong,not,strong,enforce,this;public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,string,builder,builder,new,string,builder,int,puts,0,for,int,i,0,i,pattern,parts,length,i,string,pattern,part,pattern,parts,i,if,pattern,part,index,of,1,pattern,part,index,of,1,path,parts,length,i,1,if,puts,0,i,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,i,puts,for,int,i,pattern,parts,length,i,path,parts,length,i,if,puts,0,i,0,builder,append,this,path,separator,builder,append,path,parts,i,return,builder,to,string
AntPathMatcher -> public String extractPathWithinPattern(String pattern, String path);1333393580;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'<code>/docs/cvs/commit.html</code>' and '<code>/docs/cvs/commit.html</code> -> ''</li>_<li>'<code>/docs/*</code>' and '<code>/docs/cvs/commit</code> -> '<code>cvs/commit</code>'</li>_<li>'<code>/docs/cvs/*.html</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>commit.html</code>'</li>_<li>'<code>/docs/**</code>' and '<code>/docs/cvs/commit</code> -> '<code>cvs/commit</code>'</li>_<li>'<code>/docs/**\/*.html</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>cvs/commit.html</code>'</li>_<li>'<code>/*.html</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>docs/cvs/commit.html</code>'</li>_<li>'<code>*.html</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>/docs/cvs/commit.html</code>'</li>_<li>'<code>*</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>/docs/cvs/commit.html</code>'</li> </ul>_<p>Assumes that {@link #match} returns <code>true</code> for '<code>pattern</code>' and '<code>path</code>', but_does <strong>not</strong> enforce this.;public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator)___		StringBuilder builder = new StringBuilder()___		_		int puts = 0__		for (int i = 0_ i < patternParts.length_ i++) {_			String patternPart = patternParts[i]__			if ((patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) && pathParts.length >= i + 1) {_				if (puts > 0 || (i == 0 && !pattern.startsWith(this.pathSeparator))) {_					builder.append(this.pathSeparator)__				}_				builder.append(pathParts[i])__				puts++__			}_		}__		_		for (int i = patternParts.length_ i < pathParts.length_ i++) {_			if (puts > 0 || i > 0) {_				builder.append(this.pathSeparator)__			}_			builder.append(pathParts[i])__		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,code,and,code,docs,cvs,commit,html,code,li,li,code,docs,code,and,code,docs,cvs,commit,code,code,cvs,commit,code,li,li,code,docs,cvs,html,code,and,code,docs,cvs,commit,html,code,code,commit,html,code,li,li,code,docs,code,and,code,docs,cvs,commit,code,code,cvs,commit,code,li,li,code,docs,html,code,and,code,docs,cvs,commit,html,code,code,cvs,commit,html,code,li,li,code,html,code,and,code,docs,cvs,commit,html,code,code,docs,cvs,commit,html,code,li,li,code,html,code,and,code,docs,cvs,commit,html,code,code,docs,cvs,commit,html,code,li,li,code,code,and,code,docs,cvs,commit,html,code,code,docs,cvs,commit,html,code,li,ul,p,assumes,that,link,match,returns,code,true,code,for,code,pattern,code,and,code,path,code,but,does,strong,not,strong,enforce,this;public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,string,builder,builder,new,string,builder,int,puts,0,for,int,i,0,i,pattern,parts,length,i,string,pattern,part,pattern,parts,i,if,pattern,part,index,of,1,pattern,part,index,of,1,path,parts,length,i,1,if,puts,0,i,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,i,puts,for,int,i,pattern,parts,length,i,path,parts,length,i,if,puts,0,i,0,builder,append,this,path,separator,builder,append,path,parts,i,return,builder,to,string
AntPathMatcher -> public String extractPathWithinPattern(String pattern, String path);1347310630;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'<code>/docs/cvs/commit.html</code>' and '<code>/docs/cvs/commit.html</code> -> ''</li>_<li>'<code>/docs/*</code>' and '<code>/docs/cvs/commit</code> -> '<code>cvs/commit</code>'</li>_<li>'<code>/docs/cvs/*.html</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>commit.html</code>'</li>_<li>'<code>/docs/**</code>' and '<code>/docs/cvs/commit</code> -> '<code>cvs/commit</code>'</li>_<li>'<code>/docs/**\/*.html</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>cvs/commit.html</code>'</li>_<li>'<code>/*.html</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>docs/cvs/commit.html</code>'</li>_<li>'<code>*.html</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>/docs/cvs/commit.html</code>'</li>_<li>'<code>*</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>/docs/cvs/commit.html</code>'</li> </ul>_<p>Assumes that {@link #match} returns <code>true</code> for '<code>pattern</code>' and '<code>path</code>', but_does <strong>not</strong> enforce this.;public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator)___		StringBuilder builder = new StringBuilder()___		_		int puts = 0__		for (int i = 0_ i < patternParts.length_ i++) {_			String patternPart = patternParts[i]__			if ((patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) && pathParts.length >= i + 1) {_				if (puts > 0 || (i == 0 && !pattern.startsWith(this.pathSeparator))) {_					builder.append(this.pathSeparator)__				}_				builder.append(pathParts[i])__				puts++__			}_		}__		_		for (int i = patternParts.length_ i < pathParts.length_ i++) {_			if (puts > 0 || i > 0) {_				builder.append(this.pathSeparator)__			}_			builder.append(pathParts[i])__		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,code,and,code,docs,cvs,commit,html,code,li,li,code,docs,code,and,code,docs,cvs,commit,code,code,cvs,commit,code,li,li,code,docs,cvs,html,code,and,code,docs,cvs,commit,html,code,code,commit,html,code,li,li,code,docs,code,and,code,docs,cvs,commit,code,code,cvs,commit,code,li,li,code,docs,html,code,and,code,docs,cvs,commit,html,code,code,cvs,commit,html,code,li,li,code,html,code,and,code,docs,cvs,commit,html,code,code,docs,cvs,commit,html,code,li,li,code,html,code,and,code,docs,cvs,commit,html,code,code,docs,cvs,commit,html,code,li,li,code,code,and,code,docs,cvs,commit,html,code,code,docs,cvs,commit,html,code,li,ul,p,assumes,that,link,match,returns,code,true,code,for,code,pattern,code,and,code,path,code,but,does,strong,not,strong,enforce,this;public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,string,builder,builder,new,string,builder,int,puts,0,for,int,i,0,i,pattern,parts,length,i,string,pattern,part,pattern,parts,i,if,pattern,part,index,of,1,pattern,part,index,of,1,path,parts,length,i,1,if,puts,0,i,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,i,puts,for,int,i,pattern,parts,length,i,path,parts,length,i,if,puts,0,i,0,builder,append,this,path,separator,builder,append,path,parts,i,return,builder,to,string
AntPathMatcher -> public String extractPathWithinPattern(String pattern, String path);1355351965;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'<code>/docs/cvs/commit.html</code>' and '<code>/docs/cvs/commit.html</code> -> ''</li>_<li>'<code>/docs/*</code>' and '<code>/docs/cvs/commit</code> -> '<code>cvs/commit</code>'</li>_<li>'<code>/docs/cvs/*.html</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>commit.html</code>'</li>_<li>'<code>/docs/**</code>' and '<code>/docs/cvs/commit</code> -> '<code>cvs/commit</code>'</li>_<li>'<code>/docs/**\/*.html</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>cvs/commit.html</code>'</li>_<li>'<code>/*.html</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>docs/cvs/commit.html</code>'</li>_<li>'<code>*.html</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>/docs/cvs/commit.html</code>'</li>_<li>'<code>*</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>/docs/cvs/commit.html</code>'</li> </ul>_<p>Assumes that {@link #match} returns <code>true</code> for '<code>pattern</code>' and '<code>path</code>', but_does <strong>not</strong> enforce this.;public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator)___		StringBuilder builder = new StringBuilder()___		_		int puts = 0__		for (int i = 0_ i < patternParts.length_ i++) {_			String patternPart = patternParts[i]__			if ((patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) && pathParts.length >= i + 1) {_				if (puts > 0 || (i == 0 && !pattern.startsWith(this.pathSeparator))) {_					builder.append(this.pathSeparator)__				}_				builder.append(pathParts[i])__				puts++__			}_		}__		_		for (int i = patternParts.length_ i < pathParts.length_ i++) {_			if (puts > 0 || i > 0) {_				builder.append(this.pathSeparator)__			}_			builder.append(pathParts[i])__		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,code,and,code,docs,cvs,commit,html,code,li,li,code,docs,code,and,code,docs,cvs,commit,code,code,cvs,commit,code,li,li,code,docs,cvs,html,code,and,code,docs,cvs,commit,html,code,code,commit,html,code,li,li,code,docs,code,and,code,docs,cvs,commit,code,code,cvs,commit,code,li,li,code,docs,html,code,and,code,docs,cvs,commit,html,code,code,cvs,commit,html,code,li,li,code,html,code,and,code,docs,cvs,commit,html,code,code,docs,cvs,commit,html,code,li,li,code,html,code,and,code,docs,cvs,commit,html,code,code,docs,cvs,commit,html,code,li,li,code,code,and,code,docs,cvs,commit,html,code,code,docs,cvs,commit,html,code,li,ul,p,assumes,that,link,match,returns,code,true,code,for,code,pattern,code,and,code,path,code,but,does,strong,not,strong,enforce,this;public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,string,builder,builder,new,string,builder,int,puts,0,for,int,i,0,i,pattern,parts,length,i,string,pattern,part,pattern,parts,i,if,pattern,part,index,of,1,pattern,part,index,of,1,path,parts,length,i,1,if,puts,0,i,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,i,puts,for,int,i,pattern,parts,length,i,path,parts,length,i,if,puts,0,i,0,builder,append,this,path,separator,builder,append,path,parts,i,return,builder,to,string
AntPathMatcher -> public String extractPathWithinPattern(String pattern, String path);1357119239;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator)___		StringBuilder builder = new StringBuilder()___		_		int puts = 0__		for (int i = 0_ i < patternParts.length_ i++) {_			String patternPart = patternParts[i]__			if ((patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) && pathParts.length >= i + 1) {_				if (puts > 0 || (i == 0 && !pattern.startsWith(this.pathSeparator))) {_					builder.append(this.pathSeparator)__				}_				builder.append(pathParts[i])__				puts++__			}_		}__		_		for (int i = patternParts.length_ i < pathParts.length_ i++) {_			if (puts > 0 || i > 0) {_				builder.append(this.pathSeparator)__			}_			builder.append(pathParts[i])__		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,string,builder,builder,new,string,builder,int,puts,0,for,int,i,0,i,pattern,parts,length,i,string,pattern,part,pattern,parts,i,if,pattern,part,index,of,1,pattern,part,index,of,1,path,parts,length,i,1,if,puts,0,i,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,i,puts,for,int,i,pattern,parts,length,i,path,parts,length,i,if,puts,0,i,0,builder,append,this,path,separator,builder,append,path,parts,i,return,builder,to,string
AntPathMatcher -> public String extractPathWithinPattern(String pattern, String path);1362408075;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)___		StringBuilder builder = new StringBuilder()___		_		int puts = 0__		for (int i = 0_ i < patternParts.length_ i++) {_			String patternPart = patternParts[i]__			if ((patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) && pathParts.length >= i + 1) {_				if (puts > 0 || (i == 0 && !pattern.startsWith(this.pathSeparator))) {_					builder.append(this.pathSeparator)__				}_				builder.append(pathParts[i])__				puts++__			}_		}__		_		for (int i = patternParts.length_ i < pathParts.length_ i++) {_			if (puts > 0 || i > 0) {_				builder.append(this.pathSeparator)__			}_			builder.append(pathParts[i])__		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,string,builder,builder,new,string,builder,int,puts,0,for,int,i,0,i,pattern,parts,length,i,string,pattern,part,pattern,parts,i,if,pattern,part,index,of,1,pattern,part,index,of,1,path,parts,length,i,1,if,puts,0,i,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,i,puts,for,int,i,pattern,parts,length,i,path,parts,length,i,if,puts,0,i,0,builder,append,this,path,separator,builder,append,path,parts,i,return,builder,to,string
AntPathMatcher -> public void setPathSeparator(String pathSeparator);1328020251;Set the path separator to use for pattern parsing. Default is "/", as in Ant.;public void setPathSeparator(String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__	};set,the,path,separator,to,use,for,pattern,parsing,default,is,as,in,ant;public,void,set,path,separator,string,path,separator,this,path,separator,path,separator,null,path,separator
AntPathMatcher -> public void setPathSeparator(String pathSeparator);1333393580;Set the path separator to use for pattern parsing. Default is "/", as in Ant.;public void setPathSeparator(String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__	};set,the,path,separator,to,use,for,pattern,parsing,default,is,as,in,ant;public,void,set,path,separator,string,path,separator,this,path,separator,path,separator,null,path,separator
AntPathMatcher -> public void setPathSeparator(String pathSeparator);1347310630;Set the path separator to use for pattern parsing. Default is "/", as in Ant.;public void setPathSeparator(String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__	};set,the,path,separator,to,use,for,pattern,parsing,default,is,as,in,ant;public,void,set,path,separator,string,path,separator,this,path,separator,path,separator,null,path,separator
AntPathMatcher -> public void setPathSeparator(String pathSeparator);1355351965;Set the path separator to use for pattern parsing. Default is "/", as in Ant.;public void setPathSeparator(String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__	};set,the,path,separator,to,use,for,pattern,parsing,default,is,as,in,ant;public,void,set,path,separator,string,path,separator,this,path,separator,path,separator,null,path,separator
AntPathMatcher -> public void setPathSeparator(String pathSeparator);1356735495;Set the path separator to use for pattern parsing. Default is "/", as in Ant.;public void setPathSeparator(String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__	};set,the,path,separator,to,use,for,pattern,parsing,default,is,as,in,ant;public,void,set,path,separator,string,path,separator,this,path,separator,path,separator,null,path,separator
AntPathMatcher -> public void setPathSeparator(String pathSeparator);1357119239;Set the path separator to use for pattern parsing. Default is "/", as in Ant.;public void setPathSeparator(String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__	};set,the,path,separator,to,use,for,pattern,parsing,default,is,as,in,ant;public,void,set,path,separator,string,path,separator,this,path,separator,path,separator,null,path,separator
AntPathMatcher -> public void setPathSeparator(String pathSeparator);1362408075;Set the path separator to use for pattern parsing. Default is "/", as in Ant.;public void setPathSeparator(String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__	};set,the,path,separator,to,use,for,pattern,parsing,default,is,as,in,ant;public,void,set,path,separator,string,path,separator,this,path,separator,path,separator,null,path,separator
AntPathMatcher -> public void setPathSeparator(String pathSeparator);1368482696;Set the path separator to use for pattern parsing. Default is "/", as in Ant.;public void setPathSeparator(String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__	};set,the,path,separator,to,use,for,pattern,parsing,default,is,as,in,ant;public,void,set,path,separator,string,path,separator,this,path,separator,path,separator,null,path,separator
AntPathMatcher -> public void setPathSeparator(String pathSeparator);1377725408;Set the path separator to use for pattern parsing. Default is "/", as in Ant.;public void setPathSeparator(String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__	};set,the,path,separator,to,use,for,pattern,parsing,default,is,as,in,ant;public,void,set,path,separator,string,path,separator,this,path,separator,path,separator,null,path,separator
AntPathMatcher -> public void setPathSeparator(String pathSeparator);1377735685;Set the path separator to use for pattern parsing. Default is "/", as in Ant.;public void setPathSeparator(String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__	};set,the,path,separator,to,use,for,pattern,parsing,default,is,as,in,ant;public,void,set,path,separator,string,path,separator,this,path,separator,path,separator,null,path,separator
AntPathMatcher -> public void setPathSeparator(String pathSeparator);1383090798;Set the path separator to use for pattern parsing._Default is "/", as in Ant.;public void setPathSeparator(String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__	};set,the,path,separator,to,use,for,pattern,parsing,default,is,as,in,ant;public,void,set,path,separator,string,path,separator,this,path,separator,path,separator,null,path,separator
AntPathMatcher -> public void setPathSeparator(String pathSeparator);1383157688;Set the path separator to use for pattern parsing._Default is "/", as in Ant.;public void setPathSeparator(String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__	};set,the,path,separator,to,use,for,pattern,parsing,default,is,as,in,ant;public,void,set,path,separator,string,path,separator,this,path,separator,path,separator,null,path,separator
AntPathMatcher -> public void setPathSeparator(String pathSeparator);1385501137;Set the path separator to use for pattern parsing._Default is "/", as in Ant.;public void setPathSeparator(String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__	};set,the,path,separator,to,use,for,pattern,parsing,default,is,as,in,ant;public,void,set,path,separator,string,path,separator,this,path,separator,path,separator,null,path,separator
AntPathMatcher -> public void setPathSeparator(String pathSeparator);1388766826;Set the path separator to use for pattern parsing._Default is "/", as in Ant.;public void setPathSeparator(String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__	};set,the,path,separator,to,use,for,pattern,parsing,default,is,as,in,ant;public,void,set,path,separator,string,path,separator,this,path,separator,path,separator,null,path,separator
AntPathMatcher -> public void setPathSeparator(String pathSeparator);1402512669;Set the path separator to use for pattern parsing._Default is "/", as in Ant.;public void setPathSeparator(String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__	};set,the,path,separator,to,use,for,pattern,parsing,default,is,as,in,ant;public,void,set,path,separator,string,path,separator,this,path,separator,path,separator,null,path,separator
AntPathMatcher -> public void setPathSeparator(String pathSeparator);1402512669;Set the path separator to use for pattern parsing._Default is "/", as in Ant.;public void setPathSeparator(String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__	};set,the,path,separator,to,use,for,pattern,parsing,default,is,as,in,ant;public,void,set,path,separator,string,path,separator,this,path,separator,path,separator,null,path,separator
AntPathMatcher -> public void setPathSeparator(String pathSeparator);1402512669;Set the path separator to use for pattern parsing._Default is "/", as in Ant.;public void setPathSeparator(String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__	};set,the,path,separator,to,use,for,pattern,parsing,default,is,as,in,ant;public,void,set,path,separator,string,path,separator,this,path,separator,path,separator,null,path,separator
AntPathMatcher -> public void setPathSeparator(String pathSeparator);1405378164;Set the path separator to use for pattern parsing._Default is "/", as in Ant.;public void setPathSeparator(String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__	};set,the,path,separator,to,use,for,pattern,parsing,default,is,as,in,ant;public,void,set,path,separator,string,path,separator,this,path,separator,path,separator,null,path,separator
AntPathMatcher -> public void setPathSeparator(String pathSeparator);1405378165;Set the path separator to use for pattern parsing._Default is "/", as in Ant.;public void setPathSeparator(String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(this.pathSeparator)__	};set,the,path,separator,to,use,for,pattern,parsing,default,is,as,in,ant;public,void,set,path,separator,string,path,separator,this,path,separator,path,separator,null,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,this,path,separator
AntPathMatcher -> public void setPathSeparator(String pathSeparator);1405696918;Set the path separator to use for pattern parsing._Default is "/", as in Ant.;public void setPathSeparator(String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(this.pathSeparator)__	};set,the,path,separator,to,use,for,pattern,parsing,default,is,as,in,ant;public,void,set,path,separator,string,path,separator,this,path,separator,path,separator,null,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,this,path,separator
AntPathMatcher -> public void setPathSeparator(String pathSeparator);1409784938;Set the path separator to use for pattern parsing._Default is "/", as in Ant.;public void setPathSeparator(String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(this.pathSeparator)__	};set,the,path,separator,to,use,for,pattern,parsing,default,is,as,in,ant;public,void,set,path,separator,string,path,separator,this,path,separator,path,separator,null,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,this,path,separator
AntPathMatcher -> public void setPathSeparator(String pathSeparator);1412083966;Set the path separator to use for pattern parsing._Default is "/", as in Ant.;public void setPathSeparator(String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(this.pathSeparator)__	};set,the,path,separator,to,use,for,pattern,parsing,default,is,as,in,ant;public,void,set,path,separator,string,path,separator,this,path,separator,path,separator,null,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,this,path,separator
AntPathMatcher -> public void setPathSeparator(String pathSeparator);1412101078;Set the path separator to use for pattern parsing._Default is "/", as in Ant.;public void setPathSeparator(String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(this.pathSeparator)__	};set,the,path,separator,to,use,for,pattern,parsing,default,is,as,in,ant;public,void,set,path,separator,string,path,separator,this,path,separator,path,separator,null,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,this,path,separator
AntPathMatcher -> public void setPathSeparator(String pathSeparator);1431086052;Set the path separator to use for pattern parsing._<p>Default is "/", as in Ant.;public void setPathSeparator(String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(this.pathSeparator)__	};set,the,path,separator,to,use,for,pattern,parsing,p,default,is,as,in,ant;public,void,set,path,separator,string,path,separator,this,path,separator,path,separator,null,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,this,path,separator
AntPathMatcher -> public void setPathSeparator(String pathSeparator);1431178173;Set the path separator to use for pattern parsing._<p>Default is "/", as in Ant.;public void setPathSeparator(String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(this.pathSeparator)__	};set,the,path,separator,to,use,for,pattern,parsing,p,default,is,as,in,ant;public,void,set,path,separator,string,path,separator,this,path,separator,path,separator,null,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,this,path,separator
AntPathMatcher -> public void setPathSeparator(String pathSeparator);1434572159;Set the path separator to use for pattern parsing._<p>Default is "/", as in Ant.;public void setPathSeparator(String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(this.pathSeparator)__	};set,the,path,separator,to,use,for,pattern,parsing,p,default,is,as,in,ant;public,void,set,path,separator,string,path,separator,this,path,separator,path,separator,null,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,this,path,separator
AntPathMatcher -> public void setPathSeparator(String pathSeparator);1435239719;Set the path separator to use for pattern parsing._<p>Default is "/", as in Ant.;public void setPathSeparator(String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(this.pathSeparator)__	};set,the,path,separator,to,use,for,pattern,parsing,p,default,is,as,in,ant;public,void,set,path,separator,string,path,separator,this,path,separator,path,separator,null,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,this,path,separator
AntPathMatcher -> public void setPathSeparator(String pathSeparator);1438166321;Set the path separator to use for pattern parsing._<p>Default is "/", as in Ant.;public void setPathSeparator(String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(this.pathSeparator)__	};set,the,path,separator,to,use,for,pattern,parsing,p,default,is,as,in,ant;public,void,set,path,separator,string,path,separator,this,path,separator,path,separator,null,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,this,path,separator
AntPathMatcher -> public void setPathSeparator(String pathSeparator);1455100778;Set the path separator to use for pattern parsing._<p>Default is "/", as in Ant.;public void setPathSeparator(String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(this.pathSeparator)__	};set,the,path,separator,to,use,for,pattern,parsing,p,default,is,as,in,ant;public,void,set,path,separator,string,path,separator,this,path,separator,path,separator,null,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,this,path,separator
AntPathMatcher -> public void setPathSeparator(String pathSeparator);1455850198;Set the path separator to use for pattern parsing._<p>Default is "/", as in Ant.;public void setPathSeparator(String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(this.pathSeparator)__	};set,the,path,separator,to,use,for,pattern,parsing,p,default,is,as,in,ant;public,void,set,path,separator,string,path,separator,this,path,separator,path,separator,null,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,this,path,separator
AntPathMatcher -> public void setPathSeparator(String pathSeparator);1460754629;Set the path separator to use for pattern parsing._<p>Default is "/", as in Ant.;public void setPathSeparator(String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(this.pathSeparator)__	};set,the,path,separator,to,use,for,pattern,parsing,p,default,is,as,in,ant;public,void,set,path,separator,string,path,separator,this,path,separator,path,separator,null,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,this,path,separator
AntPathMatcher -> public void setPathSeparator(String pathSeparator);1462393686;Set the path separator to use for pattern parsing._<p>Default is "/", as in Ant.;public void setPathSeparator(String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(this.pathSeparator)__	};set,the,path,separator,to,use,for,pattern,parsing,p,default,is,as,in,ant;public,void,set,path,separator,string,path,separator,this,path,separator,path,separator,null,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,this,path,separator
AntPathMatcher -> public void setPathSeparator(String pathSeparator);1467730834;Set the path separator to use for pattern parsing._<p>Default is "/", as in Ant.;public void setPathSeparator(String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(this.pathSeparator)__	};set,the,path,separator,to,use,for,pattern,parsing,p,default,is,as,in,ant;public,void,set,path,separator,string,path,separator,this,path,separator,path,separator,null,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,this,path,separator
AntPathMatcher -> public void setPathSeparator(String pathSeparator);1468327638;Set the path separator to use for pattern parsing._<p>Default is "/", as in Ant.;public void setPathSeparator(String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(this.pathSeparator)__	};set,the,path,separator,to,use,for,pattern,parsing,p,default,is,as,in,ant;public,void,set,path,separator,string,path,separator,this,path,separator,path,separator,null,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,this,path,separator
AntPathMatcher -> public void setPathSeparator(String pathSeparator);1472808958;Set the path separator to use for pattern parsing._<p>Default is "/", as in Ant.;public void setPathSeparator(String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(this.pathSeparator)__	};set,the,path,separator,to,use,for,pattern,parsing,p,default,is,as,in,ant;public,void,set,path,separator,string,path,separator,this,path,separator,path,separator,null,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,this,path,separator
AntPathMatcher -> public void setPathSeparator(String pathSeparator);1493317597;Set the path separator to use for pattern parsing._<p>Default is "/", as in Ant.;public void setPathSeparator(String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(this.pathSeparator)__	};set,the,path,separator,to,use,for,pattern,parsing,p,default,is,as,in,ant;public,void,set,path,separator,string,path,separator,this,path,separator,path,separator,null,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,this,path,separator
AntPathMatcher -> public void setPathSeparator(String pathSeparator);1493321510;Set the path separator to use for pattern parsing._<p>Default is "/", as in Ant.;public void setPathSeparator(String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(this.pathSeparator)__	};set,the,path,separator,to,use,for,pattern,parsing,p,default,is,as,in,ant;public,void,set,path,separator,string,path,separator,this,path,separator,path,separator,null,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,this,path,separator
AntPathMatcher -> public void setPathSeparator(String pathSeparator);1496259743;Set the path separator to use for pattern parsing._<p>Default is "/", as in Ant.;public void setPathSeparator(String pathSeparator) {_		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR)__		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(this.pathSeparator)__	};set,the,path,separator,to,use,for,pattern,parsing,p,default,is,as,in,ant;public,void,set,path,separator,string,path,separator,this,path,separator,path,separator,null,path,separator,this,path,separator,pattern,cache,new,path,separator,pattern,cache,this,path,separator
AntPathMatcher -> AntPatternComparator -> PatternInfo -> public int getLength();1402512669;Returns the length of the given pattern, where template variables are considered to be 1 long.;public int getLength() {_				if (this.length == null) {_					this.length = VARIABLE_PATTERN.matcher(this.pattern).replaceAll("#").length()__				}_				return this.length__			};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;public,int,get,length,if,this,length,null,this,length,matcher,this,pattern,replace,all,length,return,this,length
AntPathMatcher -> AntPatternComparator -> PatternInfo -> public int getLength();1402512669;Returns the length of the given pattern, where template variables are considered to be 1 long.;public int getLength() {_				if (this.length == null) {_					this.length = VARIABLE_PATTERN.matcher(this.pattern).replaceAll("#").length()__				}_				return this.length__			};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;public,int,get,length,if,this,length,null,this,length,matcher,this,pattern,replace,all,length,return,this,length
AntPathMatcher -> AntPatternComparator -> PatternInfo -> public int getLength();1405378164;Returns the length of the given pattern, where template variables are considered to be 1 long.;public int getLength() {_				if (this.length == null) {_					this.length = VARIABLE_PATTERN.matcher(this.pattern).replaceAll("#").length()__				}_				return this.length__			};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;public,int,get,length,if,this,length,null,this,length,matcher,this,pattern,replace,all,length,return,this,length
AntPathMatcher -> AntPatternComparator -> PatternInfo -> public int getLength();1405378165;Returns the length of the given pattern, where template variables are considered to be 1 long.;public int getLength() {_				if (this.length == null) {_					this.length = VARIABLE_PATTERN.matcher(this.pattern).replaceAll("#").length()__				}_				return this.length__			};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;public,int,get,length,if,this,length,null,this,length,matcher,this,pattern,replace,all,length,return,this,length
AntPathMatcher -> AntPatternComparator -> PatternInfo -> public int getLength();1405696918;Returns the length of the given pattern, where template variables are considered to be 1 long.;public int getLength() {_				if (this.length == null) {_					this.length = VARIABLE_PATTERN.matcher(this.pattern).replaceAll("#").length()__				}_				return this.length__			};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;public,int,get,length,if,this,length,null,this,length,matcher,this,pattern,replace,all,length,return,this,length
AntPathMatcher -> AntPatternComparator -> PatternInfo -> public int getLength();1409784938;Returns the length of the given pattern, where template variables are considered to be 1 long.;public int getLength() {_				if (this.length == null) {_					this.length = VARIABLE_PATTERN.matcher(this.pattern).replaceAll("#").length()__				}_				return this.length__			};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;public,int,get,length,if,this,length,null,this,length,matcher,this,pattern,replace,all,length,return,this,length
AntPathMatcher -> AntPatternComparator -> PatternInfo -> public int getLength();1412083966;Returns the length of the given pattern, where template variables are considered to be 1 long.;public int getLength() {_				if (this.length == null) {_					this.length = VARIABLE_PATTERN.matcher(this.pattern).replaceAll("#").length()__				}_				return this.length__			};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;public,int,get,length,if,this,length,null,this,length,matcher,this,pattern,replace,all,length,return,this,length
AntPathMatcher -> AntPatternComparator -> PatternInfo -> public int getLength();1412101078;Returns the length of the given pattern, where template variables are considered to be 1 long.;public int getLength() {_				if (this.length == null) {_					this.length = VARIABLE_PATTERN.matcher(this.pattern).replaceAll("#").length()__				}_				return this.length__			};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;public,int,get,length,if,this,length,null,this,length,matcher,this,pattern,replace,all,length,return,this,length
AntPathMatcher -> AntPatternComparator -> PatternInfo -> public int getLength();1431086052;Returns the length of the given pattern, where template variables are considered to be 1 long.;public int getLength() {_				if (this.length == null) {_					this.length = VARIABLE_PATTERN.matcher(this.pattern).replaceAll("#").length()__				}_				return this.length__			};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;public,int,get,length,if,this,length,null,this,length,matcher,this,pattern,replace,all,length,return,this,length
AntPathMatcher -> AntPatternComparator -> PatternInfo -> public int getLength();1431178173;Returns the length of the given pattern, where template variables are considered to be 1 long.;public int getLength() {_				if (this.length == null) {_					this.length = VARIABLE_PATTERN.matcher(this.pattern).replaceAll("#").length()__				}_				return this.length__			};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;public,int,get,length,if,this,length,null,this,length,matcher,this,pattern,replace,all,length,return,this,length
AntPathMatcher -> AntPatternComparator -> PatternInfo -> public int getLength();1434572159;Returns the length of the given pattern, where template variables are considered to be 1 long.;public int getLength() {_				if (this.length == null) {_					this.length = VARIABLE_PATTERN.matcher(this.pattern).replaceAll("#").length()__				}_				return this.length__			};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;public,int,get,length,if,this,length,null,this,length,matcher,this,pattern,replace,all,length,return,this,length
AntPathMatcher -> AntPatternComparator -> PatternInfo -> public int getLength();1435239719;Returns the length of the given pattern, where template variables are considered to be 1 long.;public int getLength() {_				if (this.length == null) {_					this.length = VARIABLE_PATTERN.matcher(this.pattern).replaceAll("#").length()__				}_				return this.length__			};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;public,int,get,length,if,this,length,null,this,length,matcher,this,pattern,replace,all,length,return,this,length
AntPathMatcher -> AntPatternComparator -> PatternInfo -> public int getLength();1438166321;Returns the length of the given pattern, where template variables are considered to be 1 long.;public int getLength() {_				if (this.length == null) {_					this.length = VARIABLE_PATTERN.matcher(this.pattern).replaceAll("#").length()__				}_				return this.length__			};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;public,int,get,length,if,this,length,null,this,length,matcher,this,pattern,replace,all,length,return,this,length
AntPathMatcher -> AntPatternComparator -> PatternInfo -> public int getLength();1455100778;Returns the length of the given pattern, where template variables are considered to be 1 long.;public int getLength() {_				if (this.length == null) {_					this.length = VARIABLE_PATTERN.matcher(this.pattern).replaceAll("#").length()__				}_				return this.length__			};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;public,int,get,length,if,this,length,null,this,length,matcher,this,pattern,replace,all,length,return,this,length
AntPathMatcher -> AntPatternComparator -> PatternInfo -> public int getLength();1455850198;Returns the length of the given pattern, where template variables are considered to be 1 long.;public int getLength() {_				if (this.length == null) {_					this.length = VARIABLE_PATTERN.matcher(this.pattern).replaceAll("#").length()__				}_				return this.length__			};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;public,int,get,length,if,this,length,null,this,length,matcher,this,pattern,replace,all,length,return,this,length
AntPathMatcher -> AntPatternComparator -> PatternInfo -> public int getLength();1460754629;Returns the length of the given pattern, where template variables are considered to be 1 long.;public int getLength() {_				if (this.length == null) {_					this.length = VARIABLE_PATTERN.matcher(this.pattern).replaceAll("#").length()__				}_				return this.length__			};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;public,int,get,length,if,this,length,null,this,length,matcher,this,pattern,replace,all,length,return,this,length
AntPathMatcher -> AntPatternComparator -> PatternInfo -> public int getLength();1462393686;Returns the length of the given pattern, where template variables are considered to be 1 long.;public int getLength() {_				if (this.length == null) {_					this.length = VARIABLE_PATTERN.matcher(this.pattern).replaceAll("#").length()__				}_				return this.length__			};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;public,int,get,length,if,this,length,null,this,length,matcher,this,pattern,replace,all,length,return,this,length
AntPathMatcher -> AntPatternComparator -> PatternInfo -> public int getLength();1467730834;Returns the length of the given pattern, where template variables are considered to be 1 long.;public int getLength() {_				if (this.length == null) {_					this.length = VARIABLE_PATTERN.matcher(this.pattern).replaceAll("#").length()__				}_				return this.length__			};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;public,int,get,length,if,this,length,null,this,length,matcher,this,pattern,replace,all,length,return,this,length
AntPathMatcher -> AntPatternComparator -> PatternInfo -> public int getLength();1468327638;Returns the length of the given pattern, where template variables are considered to be 1 long.;public int getLength() {_				if (this.length == null) {_					this.length = VARIABLE_PATTERN.matcher(this.pattern).replaceAll("#").length()__				}_				return this.length__			};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;public,int,get,length,if,this,length,null,this,length,matcher,this,pattern,replace,all,length,return,this,length
AntPathMatcher -> AntPatternComparator -> PatternInfo -> public int getLength();1472808958;Returns the length of the given pattern, where template variables are considered to be 1 long.;public int getLength() {_				if (this.length == null) {_					this.length = VARIABLE_PATTERN.matcher(this.pattern).replaceAll("#").length()__				}_				return this.length__			};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;public,int,get,length,if,this,length,null,this,length,matcher,this,pattern,replace,all,length,return,this,length
AntPathMatcher -> AntPatternComparator -> PatternInfo -> public int getLength();1493317597;Returns the length of the given pattern, where template variables are considered to be 1 long.;public int getLength() {_				if (this.length == null) {_					this.length = VARIABLE_PATTERN.matcher(this.pattern).replaceAll("#").length()__				}_				return this.length__			};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;public,int,get,length,if,this,length,null,this,length,matcher,this,pattern,replace,all,length,return,this,length
AntPathMatcher -> AntPatternComparator -> PatternInfo -> public int getLength();1493321510;Returns the length of the given pattern, where template variables are considered to be 1 long.;public int getLength() {_				if (this.length == null) {_					this.length = VARIABLE_PATTERN.matcher(this.pattern).replaceAll("#").length()__				}_				return this.length__			};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;public,int,get,length,if,this,length,null,this,length,matcher,this,pattern,replace,all,length,return,this,length
AntPathMatcher -> AntPatternComparator -> PatternInfo -> public int getLength();1496259743;Returns the length of the given pattern, where template variables are considered to be 1 long.;public int getLength() {_				if (this.length == null) {_					this.length = VARIABLE_PATTERN.matcher(this.pattern).replaceAll("#").length()__				}_				return this.length__			};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;public,int,get,length,if,this,length,null,this,length,matcher,this,pattern,replace,all,length,return,this,length
AntPathMatcher -> AntPatternComparator -> PatternInfo -> public int getLength();1496837955;Returns the length of the given pattern, where template variables are considered to be 1 long.;public int getLength() {_				if (this.length == null) {_					this.length = VARIABLE_PATTERN.matcher(this.pattern).replaceAll("#").length()__				}_				return this.length__			};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;public,int,get,length,if,this,length,null,this,length,matcher,this,pattern,replace,all,length,return,this,length
AntPathMatcher -> AntPatternComparator -> PatternInfo -> public int getLength();1498780456;Returns the length of the given pattern, where template variables are considered to be 1 long.;public int getLength() {_				if (this.length == null) {_					this.length = (this.pattern != null ?_							VARIABLE_PATTERN.matcher(this.pattern).replaceAll("#").length() : 0)__				}_				return this.length__			};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;public,int,get,length,if,this,length,null,this,length,this,pattern,null,matcher,this,pattern,replace,all,length,0,return,this,length
AntPathMatcher -> AntPatternComparator -> PatternInfo -> public int getLength();1518772998;Returns the length of the given pattern, where template variables are considered to be 1 long.;public int getLength() {_				if (this.length == null) {_					this.length = (this.pattern != null ?_							VARIABLE_PATTERN.matcher(this.pattern).replaceAll("#").length() : 0)__				}_				return this.length__			};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;public,int,get,length,if,this,length,null,this,length,this,pattern,null,matcher,this,pattern,replace,all,length,0,return,this,length
AntPathMatcher -> AntPatternComparator -> PatternInfo -> public int getLength();1530174524;Returns the length of the given pattern, where template variables are considered to be 1 long.;public int getLength() {_				if (this.length == null) {_					this.length = (this.pattern != null ?_							VARIABLE_PATTERN.matcher(this.pattern).replaceAll("#").length() : 0)__				}_				return this.length__			};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;public,int,get,length,if,this,length,null,this,length,this,pattern,null,matcher,this,pattern,replace,all,length,0,return,this,length
AntPathMatcher -> AntPatternComparator -> PatternInfo -> public int getLength();1530174524;Returns the length of the given pattern, where template variables are considered to be 1 long.;public int getLength() {_				if (this.length == null) {_					this.length = (this.pattern != null ?_							VARIABLE_PATTERN.matcher(this.pattern).replaceAll("#").length() : 0)__				}_				return this.length__			};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;public,int,get,length,if,this,length,null,this,length,this,pattern,null,matcher,this,pattern,replace,all,length,0,return,this,length
AntPathMatcher -> AntPatternComparator -> PatternInfo -> public int getLength();1535316501;Returns the length of the given pattern, where template variables are considered to be 1 long.;public int getLength() {_				if (this.length == null) {_					this.length = (this.pattern != null ?_							VARIABLE_PATTERN.matcher(this.pattern).replaceAll("#").length() : 0)__				}_				return this.length__			};returns,the,length,of,the,given,pattern,where,template,variables,are,considered,to,be,1,long;public,int,get,length,if,this,length,null,this,length,this,pattern,null,matcher,this,pattern,replace,all,length,0,return,this,length
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables);1383090798;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables) {_		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathDirs = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxStart]__			if ("**".equals(pattDir)) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) :_						!path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxEnd]__			if (pattDir.equals("**")) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,dirs,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,start,if,equals,patt,dir,break,if,match,strings,patt,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,end,if,patt,dir,equals,break,if,match,strings,patt,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables);1383157688;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables) {_		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathDirs = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxStart]__			if ("**".equals(pattDir)) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) :_						!path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxEnd]__			if (pattDir.equals("**")) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,dirs,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,start,if,equals,patt,dir,break,if,match,strings,patt,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,end,if,patt,dir,equals,break,if,match,strings,patt,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables);1385501137;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables) {_		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathDirs = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxStart]__			if ("**".equals(pattDir)) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) :_						!path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxEnd]__			if (pattDir.equals("**")) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,dirs,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,start,if,equals,patt,dir,break,if,match,strings,patt,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,end,if,patt,dir,equals,break,if,match,strings,patt,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables);1388766826;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables) {_		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = tokenizePattern(pattern)__		String[] pathDirs = tokenizePath(path)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxStart]__			if ("**".equals(pattDir)) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) :_						!path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxEnd]__			if (pattDir.equals("**")) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,tokenize,pattern,pattern,string,path,dirs,tokenize,path,path,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,start,if,equals,patt,dir,break,if,match,strings,patt,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,end,if,patt,dir,equals,break,if,match,strings,patt,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables);1402512669;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables) {_		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = tokenizePattern(pattern)__		String[] pathDirs = tokenizePath(path)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxStart]__			if ("**".equals(pattDir)) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) :_						!path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxEnd]__			if (pattDir.equals("**")) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,tokenize,pattern,pattern,string,path,dirs,tokenize,path,path,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,start,if,equals,patt,dir,break,if,match,strings,patt,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,end,if,patt,dir,equals,break,if,match,strings,patt,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables);1402512669;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables) {_		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = tokenizePattern(pattern)__		String[] pathDirs = tokenizePath(path)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxStart]__			if ("**".equals(pattDir)) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) :_						!path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxEnd]__			if (pattDir.equals("**")) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,tokenize,pattern,pattern,string,path,dirs,tokenize,path,path,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,start,if,equals,patt,dir,break,if,match,strings,patt,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,end,if,patt,dir,equals,break,if,match,strings,patt,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables);1402512669;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables) {_		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = tokenizePattern(pattern)__		String[] pathDirs = tokenizePath(path)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxStart]__			if ("**".equals(pattDir)) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) :_						!path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxEnd]__			if (pattDir.equals("**")) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,tokenize,pattern,pattern,string,path,dirs,tokenize,path,path,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,start,if,equals,patt,dir,break,if,match,strings,patt,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,end,if,patt,dir,equals,break,if,match,strings,patt,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables);1405378164;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables) {_		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = tokenizePattern(pattern)__		String[] pathDirs = tokenizePath(path)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxStart]__			if ("**".equals(pattDir)) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) :_						!path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxEnd]__			if (pattDir.equals("**")) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,tokenize,pattern,pattern,string,path,dirs,tokenize,path,path,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,start,if,equals,patt,dir,break,if,match,strings,patt,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,end,if,patt,dir,equals,break,if,match,strings,patt,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables);1405378165;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables) {_		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = tokenizePattern(pattern)__		String[] pathDirs = tokenizePath(path)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxStart]__			if ("**".equals(pattDir)) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) :_						!path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxEnd]__			if (pattDir.equals("**")) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,tokenize,pattern,pattern,string,path,dirs,tokenize,path,path,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,start,if,equals,patt,dir,break,if,match,strings,patt,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,end,if,patt,dir,equals,break,if,match,strings,patt,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables);1405696918;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables) {_		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = tokenizePattern(pattern)__		String[] pathDirs = tokenizePath(path)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxStart]__			if ("**".equals(pattDir)) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) :_						!path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxEnd]__			if (pattDir.equals("**")) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,tokenize,pattern,pattern,string,path,dirs,tokenize,path,path,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,start,if,equals,patt,dir,break,if,match,strings,patt,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,end,if,patt,dir,equals,break,if,match,strings,patt,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables);1409784938;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables) {_		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = tokenizePattern(pattern)__		String[] pathDirs = tokenizePath(path)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxStart]__			if ("**".equals(pattDir)) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) :_						!path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxEnd]__			if (pattDir.equals("**")) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,tokenize,pattern,pattern,string,path,dirs,tokenize,path,path,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,start,if,equals,patt,dir,break,if,match,strings,patt,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,end,if,patt,dir,equals,break,if,match,strings,patt,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables);1412083966;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables) {_		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = tokenizePattern(pattern)__		String[] pathDirs = tokenizePath(path)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxStart]__			if ("**".equals(pattDir)) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) :_						!path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxEnd]__			if (pattDir.equals("**")) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,tokenize,pattern,pattern,string,path,dirs,tokenize,path,path,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,start,if,equals,patt,dir,break,if,match,strings,patt,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,end,if,patt,dir,equals,break,if,match,strings,patt,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables);1412101078;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables) {_		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = tokenizePattern(pattern)__		String[] pathDirs = tokenizePath(path)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxStart]__			if ("**".equals(pattDir)) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) :_						!path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxEnd]__			if (pattDir.equals("**")) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,tokenize,pattern,pattern,string,path,dirs,tokenize,path,path,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,start,if,equals,patt,dir,break,if,match,strings,patt,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,end,if,patt,dir,equals,break,if,match,strings,patt,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables);1431086052;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables) {_		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = tokenizePattern(pattern)__		String[] pathDirs = tokenizePath(path)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxStart]__			if ("**".equals(pattDir)) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) :_						!path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxEnd]__			if (pattDir.equals("**")) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,tokenize,pattern,pattern,string,path,dirs,tokenize,path,path,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,start,if,equals,patt,dir,break,if,match,strings,patt,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,end,if,patt,dir,equals,break,if,match,strings,patt,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables);1431178173;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables) {_		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = tokenizePattern(pattern)__		String[] pathDirs = tokenizePath(path)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxStart]__			if ("**".equals(pattDir)) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) :_						!path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxEnd]__			if (pattDir.equals("**")) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,tokenize,pattern,pattern,string,path,dirs,tokenize,path,path,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,start,if,equals,patt,dir,break,if,match,strings,patt,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,end,if,patt,dir,equals,break,if,match,strings,patt,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables);1434572159;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables) {_		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = tokenizePattern(pattern)__		String[] pathDirs = tokenizePath(path)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxStart]__			if ("**".equals(pattDir)) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) :_						!path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxEnd]__			if (pattDir.equals("**")) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,tokenize,pattern,pattern,string,path,dirs,tokenize,path,path,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,start,if,equals,patt,dir,break,if,match,strings,patt,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,end,if,patt,dir,equals,break,if,match,strings,patt,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables);1435239719;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables) {_		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = tokenizePattern(pattern)__		String[] pathDirs = tokenizePath(path)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxStart]__			if ("**".equals(pattDir)) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) :_						!path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxEnd]__			if (pattDir.equals("**")) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,tokenize,pattern,pattern,string,path,dirs,tokenize,path,path,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,start,if,equals,patt,dir,break,if,match,strings,patt,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,end,if,patt,dir,equals,break,if,match,strings,patt,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables);1438166321;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables) {_		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = tokenizePattern(pattern)__		String[] pathDirs = tokenizePath(path)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxStart]__			if ("**".equals(pattDir)) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) :_						!path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxEnd]__			if (pattDir.equals("**")) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,tokenize,pattern,pattern,string,path,dirs,tokenize,path,path,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,start,if,equals,patt,dir,break,if,match,strings,patt,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,end,if,patt,dir,equals,break,if,match,strings,patt,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables);1455100778;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables) {_		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		PreprocessedPattern preprocessedPattern = tokenizePattern(pattern)__		if (fullMatch && this.caseSensitive && preprocessedPattern.certainlyNotMatch(path)) {_			return false__		}_		String[] pattDirs = preprocessedPattern.tokenized__		String[] pathDirs = tokenizePath(path)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxStart]__			if ("**".equals(pattDir)) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) :_						!path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxEnd]__			if (pattDir.equals("**")) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,preprocessed,pattern,preprocessed,pattern,tokenize,pattern,pattern,if,full,match,this,case,sensitive,preprocessed,pattern,certainly,not,match,path,return,false,string,patt,dirs,preprocessed,pattern,tokenized,string,path,dirs,tokenize,path,path,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,start,if,equals,patt,dir,break,if,match,strings,patt,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,end,if,patt,dir,equals,break,if,match,strings,patt,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables);1455850198;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables) {_		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = tokenizePattern(pattern)__		if (fullMatch && this.caseSensitive && !isPotentialMatch(path, pattDirs)) {_			return false__		}__		String[] pathDirs = tokenizePath(path)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxStart]__			if ("**".equals(pattDir)) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) :_						!path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxEnd]__			if (pattDir.equals("**")) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,tokenize,pattern,pattern,if,full,match,this,case,sensitive,is,potential,match,path,patt,dirs,return,false,string,path,dirs,tokenize,path,path,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,start,if,equals,patt,dir,break,if,match,strings,patt,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,end,if,patt,dir,equals,break,if,match,strings,patt,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables);1460754629;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables) {_		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = tokenizePattern(pattern)__		if (fullMatch && this.caseSensitive && !isPotentialMatch(path, pattDirs)) {_			return false__		}__		String[] pathDirs = tokenizePath(path)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxStart]__			if ("**".equals(pattDir)) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) :_						!path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxEnd]__			if (pattDir.equals("**")) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,tokenize,pattern,pattern,if,full,match,this,case,sensitive,is,potential,match,path,patt,dirs,return,false,string,path,dirs,tokenize,path,path,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,start,if,equals,patt,dir,break,if,match,strings,patt,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,end,if,patt,dir,equals,break,if,match,strings,patt,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables);1462393686;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables) {_		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = tokenizePattern(pattern)__		if (fullMatch && this.caseSensitive && !isPotentialMatch(path, pattDirs)) {_			return false__		}__		String[] pathDirs = tokenizePath(path)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxStart]__			if ("**".equals(pattDir)) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) :_						!path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxEnd]__			if (pattDir.equals("**")) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,tokenize,pattern,pattern,if,full,match,this,case,sensitive,is,potential,match,path,patt,dirs,return,false,string,path,dirs,tokenize,path,path,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,start,if,equals,patt,dir,break,if,match,strings,patt,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,end,if,patt,dir,equals,break,if,match,strings,patt,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables);1467730834;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables) {_		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = tokenizePattern(pattern)__		if (fullMatch && this.caseSensitive && !isPotentialMatch(path, pattDirs)) {_			return false__		}__		String[] pathDirs = tokenizePath(path)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxStart]__			if ("**".equals(pattDir)) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) :_						!path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxEnd]__			if (pattDir.equals("**")) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,tokenize,pattern,pattern,if,full,match,this,case,sensitive,is,potential,match,path,patt,dirs,return,false,string,path,dirs,tokenize,path,path,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,start,if,equals,patt,dir,break,if,match,strings,patt,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,end,if,patt,dir,equals,break,if,match,strings,patt,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables);1468327638;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables) {_		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = tokenizePattern(pattern)__		if (fullMatch && this.caseSensitive && !isPotentialMatch(path, pattDirs)) {_			return false__		}__		String[] pathDirs = tokenizePath(path)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxStart]__			if ("**".equals(pattDir)) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) :_						!path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxEnd]__			if (pattDir.equals("**")) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,tokenize,pattern,pattern,if,full,match,this,case,sensitive,is,potential,match,path,patt,dirs,return,false,string,path,dirs,tokenize,path,path,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,start,if,equals,patt,dir,break,if,match,strings,patt,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,end,if,patt,dir,equals,break,if,match,strings,patt,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables);1472808958;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables) {_		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = tokenizePattern(pattern)__		if (fullMatch && this.caseSensitive && !isPotentialMatch(path, pattDirs)) {_			return false__		}__		String[] pathDirs = tokenizePath(path)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxStart]__			if ("**".equals(pattDir)) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) :_						!path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxEnd]__			if (pattDir.equals("**")) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,tokenize,pattern,pattern,if,full,match,this,case,sensitive,is,potential,match,path,patt,dirs,return,false,string,path,dirs,tokenize,path,path,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,start,if,equals,patt,dir,break,if,match,strings,patt,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,end,if,patt,dir,equals,break,if,match,strings,patt,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables);1493317597;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables) {_		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = tokenizePattern(pattern)__		if (fullMatch && this.caseSensitive && !isPotentialMatch(path, pattDirs)) {_			return false__		}__		String[] pathDirs = tokenizePath(path)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxStart]__			if ("**".equals(pattDir)) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) :_						!path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxEnd]__			if (pattDir.equals("**")) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,tokenize,pattern,pattern,if,full,match,this,case,sensitive,is,potential,match,path,patt,dirs,return,false,string,path,dirs,tokenize,path,path,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,start,if,equals,patt,dir,break,if,match,strings,patt,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,end,if,patt,dir,equals,break,if,match,strings,patt,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables);1493321510;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables) {_		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = tokenizePattern(pattern)__		if (fullMatch && this.caseSensitive && !isPotentialMatch(path, pattDirs)) {_			return false__		}__		String[] pathDirs = tokenizePath(path)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxStart]__			if ("**".equals(pattDir)) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) == path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxEnd]__			if (pattDir.equals("**")) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,tokenize,pattern,pattern,if,full,match,this,case,sensitive,is,potential,match,path,patt,dirs,return,false,string,path,dirs,tokenize,path,path,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,start,if,equals,patt,dir,break,if,match,strings,patt,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,end,if,patt,dir,equals,break,if,match,strings,patt,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> @Override 	public String extractPathWithinPattern(String pattern, String path);1356735495;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;@Override_	public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator)___		StringBuilder builder = new StringBuilder()___		_		int puts = 0__		for (int i = 0_ i < patternParts.length_ i++) {_			String patternPart = patternParts[i]__			if ((patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) && pathParts.length >= i + 1) {_				if (puts > 0 || (i == 0 && !pattern.startsWith(this.pathSeparator))) {_					builder.append(this.pathSeparator)__				}_				builder.append(pathParts[i])__				puts++__			}_		}__		_		for (int i = patternParts.length_ i < pathParts.length_ i++) {_			if (puts > 0 || i > 0) {_				builder.append(this.pathSeparator)__			}_			builder.append(pathParts[i])__		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;override,public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,string,builder,builder,new,string,builder,int,puts,0,for,int,i,0,i,pattern,parts,length,i,string,pattern,part,pattern,parts,i,if,pattern,part,index,of,1,pattern,part,index,of,1,path,parts,length,i,1,if,puts,0,i,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,i,puts,for,int,i,pattern,parts,length,i,path,parts,length,i,if,puts,0,i,0,builder,append,this,path,separator,builder,append,path,parts,i,return,builder,to,string
AntPathMatcher -> @Override 	public String extractPathWithinPattern(String pattern, String path);1368482696;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;@Override_	public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)___		StringBuilder builder = new StringBuilder()___		_		int puts = 0__		for (int i = 0_ i < patternParts.length_ i++) {_			String patternPart = patternParts[i]__			if ((patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) && pathParts.length >= i + 1) {_				if (puts > 0 || (i == 0 && !pattern.startsWith(this.pathSeparator))) {_					builder.append(this.pathSeparator)__				}_				builder.append(pathParts[i])__				puts++__			}_		}__		_		for (int i = patternParts.length_ i < pathParts.length_ i++) {_			if (puts > 0 || i > 0) {_				builder.append(this.pathSeparator)__			}_			builder.append(pathParts[i])__		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;override,public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,string,builder,builder,new,string,builder,int,puts,0,for,int,i,0,i,pattern,parts,length,i,string,pattern,part,pattern,parts,i,if,pattern,part,index,of,1,pattern,part,index,of,1,path,parts,length,i,1,if,puts,0,i,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,i,puts,for,int,i,pattern,parts,length,i,path,parts,length,i,if,puts,0,i,0,builder,append,this,path,separator,builder,append,path,parts,i,return,builder,to,string
AntPathMatcher -> @Override 	public String extractPathWithinPattern(String pattern, String path);1377725408;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;@Override_	public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)___		StringBuilder builder = new StringBuilder()___		_		int puts = 0__		for (int i = 0_ i < patternParts.length_ i++) {_			String patternPart = patternParts[i]__			if ((patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) && pathParts.length >= i + 1) {_				if (puts > 0 || (i == 0 && !pattern.startsWith(this.pathSeparator))) {_					builder.append(this.pathSeparator)__				}_				builder.append(pathParts[i])__				puts++__			}_		}__		_		for (int i = patternParts.length_ i < pathParts.length_ i++) {_			if (puts > 0 || i > 0) {_				builder.append(this.pathSeparator)__			}_			builder.append(pathParts[i])__		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;override,public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,string,builder,builder,new,string,builder,int,puts,0,for,int,i,0,i,pattern,parts,length,i,string,pattern,part,pattern,parts,i,if,pattern,part,index,of,1,pattern,part,index,of,1,path,parts,length,i,1,if,puts,0,i,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,i,puts,for,int,i,pattern,parts,length,i,path,parts,length,i,if,puts,0,i,0,builder,append,this,path,separator,builder,append,path,parts,i,return,builder,to,string
AntPathMatcher -> @Override 	public String extractPathWithinPattern(String pattern, String path);1377735685;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;@Override_	public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)___		StringBuilder builder = new StringBuilder()___		_		int puts = 0__		for (int i = 0_ i < patternParts.length_ i++) {_			String patternPart = patternParts[i]__			if ((patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) && pathParts.length >= i + 1) {_				if (puts > 0 || (i == 0 && !pattern.startsWith(this.pathSeparator))) {_					builder.append(this.pathSeparator)__				}_				builder.append(pathParts[i])__				puts++__			}_		}__		_		for (int i = patternParts.length_ i < pathParts.length_ i++) {_			if (puts > 0 || i > 0) {_				builder.append(this.pathSeparator)__			}_			builder.append(pathParts[i])__		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;override,public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,string,builder,builder,new,string,builder,int,puts,0,for,int,i,0,i,pattern,parts,length,i,string,pattern,part,pattern,parts,i,if,pattern,part,index,of,1,pattern,part,index,of,1,path,parts,length,i,1,if,puts,0,i,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,i,puts,for,int,i,pattern,parts,length,i,path,parts,length,i,if,puts,0,i,0,builder,append,this,path,separator,builder,append,path,parts,i,return,builder,to,string
AntPathMatcher -> @Override 	public String extractPathWithinPattern(String pattern, String path);1383090798;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;@Override_	public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)___		StringBuilder builder = new StringBuilder()___		_		int puts = 0__		for (int i = 0_ i < patternParts.length_ i++) {_			String patternPart = patternParts[i]__			if ((patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) && pathParts.length >= i + 1) {_				if (puts > 0 || (i == 0 && !pattern.startsWith(this.pathSeparator))) {_					builder.append(this.pathSeparator)__				}_				builder.append(pathParts[i])__				puts++__			}_		}__		_		for (int i = patternParts.length_ i < pathParts.length_ i++) {_			if (puts > 0 || i > 0) {_				builder.append(this.pathSeparator)__			}_			builder.append(pathParts[i])__		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;override,public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,string,builder,builder,new,string,builder,int,puts,0,for,int,i,0,i,pattern,parts,length,i,string,pattern,part,pattern,parts,i,if,pattern,part,index,of,1,pattern,part,index,of,1,path,parts,length,i,1,if,puts,0,i,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,i,puts,for,int,i,pattern,parts,length,i,path,parts,length,i,if,puts,0,i,0,builder,append,this,path,separator,builder,append,path,parts,i,return,builder,to,string
AntPathMatcher -> @Override 	public String extractPathWithinPattern(String pattern, String path);1383157688;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;@Override_	public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)___		StringBuilder builder = new StringBuilder()___		_		int puts = 0__		for (int i = 0_ i < patternParts.length_ i++) {_			String patternPart = patternParts[i]__			if ((patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) && pathParts.length >= i + 1) {_				if (puts > 0 || (i == 0 && !pattern.startsWith(this.pathSeparator))) {_					builder.append(this.pathSeparator)__				}_				builder.append(pathParts[i])__				puts++__			}_		}__		_		for (int i = patternParts.length_ i < pathParts.length_ i++) {_			if (puts > 0 || i > 0) {_				builder.append(this.pathSeparator)__			}_			builder.append(pathParts[i])__		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;override,public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,string,builder,builder,new,string,builder,int,puts,0,for,int,i,0,i,pattern,parts,length,i,string,pattern,part,pattern,parts,i,if,pattern,part,index,of,1,pattern,part,index,of,1,path,parts,length,i,1,if,puts,0,i,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,i,puts,for,int,i,pattern,parts,length,i,path,parts,length,i,if,puts,0,i,0,builder,append,this,path,separator,builder,append,path,parts,i,return,builder,to,string
AntPathMatcher -> @Override 	public String extractPathWithinPattern(String pattern, String path);1385501137;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;@Override_	public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)___		StringBuilder builder = new StringBuilder()___		_		int puts = 0__		for (int i = 0_ i < patternParts.length_ i++) {_			String patternPart = patternParts[i]__			if ((patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) && pathParts.length >= i + 1) {_				if (puts > 0 || (i == 0 && !pattern.startsWith(this.pathSeparator))) {_					builder.append(this.pathSeparator)__				}_				builder.append(pathParts[i])__				puts++__			}_		}__		_		for (int i = patternParts.length_ i < pathParts.length_ i++) {_			if (puts > 0 || i > 0) {_				builder.append(this.pathSeparator)__			}_			builder.append(pathParts[i])__		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;override,public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,string,builder,builder,new,string,builder,int,puts,0,for,int,i,0,i,pattern,parts,length,i,string,pattern,part,pattern,parts,i,if,pattern,part,index,of,1,pattern,part,index,of,1,path,parts,length,i,1,if,puts,0,i,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,i,puts,for,int,i,pattern,parts,length,i,path,parts,length,i,if,puts,0,i,0,builder,append,this,path,separator,builder,append,path,parts,i,return,builder,to,string
AntPathMatcher -> @Override 	public String extractPathWithinPattern(String pattern, String path);1388766826;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;@Override_	public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)___		StringBuilder builder = new StringBuilder()___		_		int puts = 0__		for (int i = 0_ i < patternParts.length_ i++) {_			String patternPart = patternParts[i]__			if ((patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) && pathParts.length >= i + 1) {_				if (puts > 0 || (i == 0 && !pattern.startsWith(this.pathSeparator))) {_					builder.append(this.pathSeparator)__				}_				builder.append(pathParts[i])__				puts++__			}_		}__		_		for (int i = patternParts.length_ i < pathParts.length_ i++) {_			if (puts > 0 || i > 0) {_				builder.append(this.pathSeparator)__			}_			builder.append(pathParts[i])__		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;override,public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,string,builder,builder,new,string,builder,int,puts,0,for,int,i,0,i,pattern,parts,length,i,string,pattern,part,pattern,parts,i,if,pattern,part,index,of,1,pattern,part,index,of,1,path,parts,length,i,1,if,puts,0,i,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,i,puts,for,int,i,pattern,parts,length,i,path,parts,length,i,if,puts,0,i,0,builder,append,this,path,separator,builder,append,path,parts,i,return,builder,to,string
AntPathMatcher -> @Override 	public String extractPathWithinPattern(String pattern, String path);1402512669;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;@Override_	public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)___		StringBuilder builder = new StringBuilder()___		_		int puts = 0__		for (int i = 0_ i < patternParts.length_ i++) {_			String patternPart = patternParts[i]__			if ((patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) && pathParts.length >= i + 1) {_				if (puts > 0 || (i == 0 && !pattern.startsWith(this.pathSeparator))) {_					builder.append(this.pathSeparator)__				}_				builder.append(pathParts[i])__				puts++__			}_		}__		_		for (int i = patternParts.length_ i < pathParts.length_ i++) {_			if (puts > 0 || i > 0) {_				builder.append(this.pathSeparator)__			}_			builder.append(pathParts[i])__		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;override,public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,string,builder,builder,new,string,builder,int,puts,0,for,int,i,0,i,pattern,parts,length,i,string,pattern,part,pattern,parts,i,if,pattern,part,index,of,1,pattern,part,index,of,1,path,parts,length,i,1,if,puts,0,i,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,i,puts,for,int,i,pattern,parts,length,i,path,parts,length,i,if,puts,0,i,0,builder,append,this,path,separator,builder,append,path,parts,i,return,builder,to,string
AntPathMatcher -> @Override 	public String extractPathWithinPattern(String pattern, String path);1402512669;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;@Override_	public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)___		StringBuilder builder = new StringBuilder()___		_		int puts = 0__		for (int i = 0_ i < patternParts.length_ i++) {_			String patternPart = patternParts[i]__			if ((patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) && pathParts.length >= i + 1) {_				if (puts > 0 || (i == 0 && !pattern.startsWith(this.pathSeparator))) {_					builder.append(this.pathSeparator)__				}_				builder.append(pathParts[i])__				puts++__			}_		}__		_		for (int i = patternParts.length_ i < pathParts.length_ i++) {_			if (puts > 0 || i > 0) {_				builder.append(this.pathSeparator)__			}_			builder.append(pathParts[i])__		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;override,public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,string,builder,builder,new,string,builder,int,puts,0,for,int,i,0,i,pattern,parts,length,i,string,pattern,part,pattern,parts,i,if,pattern,part,index,of,1,pattern,part,index,of,1,path,parts,length,i,1,if,puts,0,i,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,i,puts,for,int,i,pattern,parts,length,i,path,parts,length,i,if,puts,0,i,0,builder,append,this,path,separator,builder,append,path,parts,i,return,builder,to,string
AntPathMatcher -> @Override 	public String extractPathWithinPattern(String pattern, String path);1402512669;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;@Override_	public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)___		StringBuilder builder = new StringBuilder()___		_		int puts = 0__		for (int i = 0_ i < patternParts.length_ i++) {_			String patternPart = patternParts[i]__			if ((patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) && pathParts.length >= i + 1) {_				if (puts > 0 || (i == 0 && !pattern.startsWith(this.pathSeparator))) {_					builder.append(this.pathSeparator)__				}_				builder.append(pathParts[i])__				puts++__			}_		}__		_		for (int i = patternParts.length_ i < pathParts.length_ i++) {_			if (puts > 0 || i > 0) {_				builder.append(this.pathSeparator)__			}_			builder.append(pathParts[i])__		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;override,public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,string,builder,builder,new,string,builder,int,puts,0,for,int,i,0,i,pattern,parts,length,i,string,pattern,part,pattern,parts,i,if,pattern,part,index,of,1,pattern,part,index,of,1,path,parts,length,i,1,if,puts,0,i,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,i,puts,for,int,i,pattern,parts,length,i,path,parts,length,i,if,puts,0,i,0,builder,append,this,path,separator,builder,append,path,parts,i,return,builder,to,string
AntPathMatcher -> @Override 	public String extractPathWithinPattern(String pattern, String path);1405378164;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;@Override_	public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)___		StringBuilder builder = new StringBuilder()___		_		int puts = 0__		for (int i = 0_ i < patternParts.length_ i++) {_			String patternPart = patternParts[i]__			if ((patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) && pathParts.length >= i + 1) {_				if (puts > 0 || (i == 0 && !pattern.startsWith(this.pathSeparator))) {_					builder.append(this.pathSeparator)__				}_				builder.append(pathParts[i])__				puts++__			}_		}__		_		for (int i = patternParts.length_ i < pathParts.length_ i++) {_			if (puts > 0 || i > 0) {_				builder.append(this.pathSeparator)__			}_			builder.append(pathParts[i])__		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;override,public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,string,builder,builder,new,string,builder,int,puts,0,for,int,i,0,i,pattern,parts,length,i,string,pattern,part,pattern,parts,i,if,pattern,part,index,of,1,pattern,part,index,of,1,path,parts,length,i,1,if,puts,0,i,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,i,puts,for,int,i,pattern,parts,length,i,path,parts,length,i,if,puts,0,i,0,builder,append,this,path,separator,builder,append,path,parts,i,return,builder,to,string
AntPathMatcher -> @Override 	public String extractPathWithinPattern(String pattern, String path);1405378165;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;@Override_	public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)___		StringBuilder builder = new StringBuilder()___		_		int puts = 0__		for (int i = 0_ i < patternParts.length_ i++) {_			String patternPart = patternParts[i]__			if ((patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) && pathParts.length >= i + 1) {_				if (puts > 0 || (i == 0 && !pattern.startsWith(this.pathSeparator))) {_					builder.append(this.pathSeparator)__				}_				builder.append(pathParts[i])__				puts++__			}_		}__		_		for (int i = patternParts.length_ i < pathParts.length_ i++) {_			if (puts > 0 || i > 0) {_				builder.append(this.pathSeparator)__			}_			builder.append(pathParts[i])__		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;override,public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,string,builder,builder,new,string,builder,int,puts,0,for,int,i,0,i,pattern,parts,length,i,string,pattern,part,pattern,parts,i,if,pattern,part,index,of,1,pattern,part,index,of,1,path,parts,length,i,1,if,puts,0,i,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,i,puts,for,int,i,pattern,parts,length,i,path,parts,length,i,if,puts,0,i,0,builder,append,this,path,separator,builder,append,path,parts,i,return,builder,to,string
AntPathMatcher -> @Override 	public String extractPathWithinPattern(String pattern, String path);1405696918;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;@Override_	public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)___		StringBuilder builder = new StringBuilder()___		_		int puts = 0__		for (int i = 0_ i < patternParts.length_ i++) {_			String patternPart = patternParts[i]__			if ((patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) && pathParts.length >= i + 1) {_				if (puts > 0 || (i == 0 && !pattern.startsWith(this.pathSeparator))) {_					builder.append(this.pathSeparator)__				}_				builder.append(pathParts[i])__				puts++__			}_		}__		_		for (int i = patternParts.length_ i < pathParts.length_ i++) {_			if (puts > 0 || i > 0) {_				builder.append(this.pathSeparator)__			}_			builder.append(pathParts[i])__		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;override,public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,string,builder,builder,new,string,builder,int,puts,0,for,int,i,0,i,pattern,parts,length,i,string,pattern,part,pattern,parts,i,if,pattern,part,index,of,1,pattern,part,index,of,1,path,parts,length,i,1,if,puts,0,i,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,i,puts,for,int,i,pattern,parts,length,i,path,parts,length,i,if,puts,0,i,0,builder,append,this,path,separator,builder,append,path,parts,i,return,builder,to,string
AntPathMatcher -> @Override 	public String extractPathWithinPattern(String pattern, String path);1409784938;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;@Override_	public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)___		StringBuilder builder = new StringBuilder()___		_		int puts = 0__		for (int i = 0_ i < patternParts.length_ i++) {_			String patternPart = patternParts[i]__			if ((patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) && pathParts.length >= i + 1) {_				if (puts > 0 || (i == 0 && !pattern.startsWith(this.pathSeparator))) {_					builder.append(this.pathSeparator)__				}_				builder.append(pathParts[i])__				puts++__			}_		}__		_		for (int i = patternParts.length_ i < pathParts.length_ i++) {_			if (puts > 0 || i > 0) {_				builder.append(this.pathSeparator)__			}_			builder.append(pathParts[i])__		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;override,public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,string,builder,builder,new,string,builder,int,puts,0,for,int,i,0,i,pattern,parts,length,i,string,pattern,part,pattern,parts,i,if,pattern,part,index,of,1,pattern,part,index,of,1,path,parts,length,i,1,if,puts,0,i,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,i,puts,for,int,i,pattern,parts,length,i,path,parts,length,i,if,puts,0,i,0,builder,append,this,path,separator,builder,append,path,parts,i,return,builder,to,string
AntPathMatcher -> @Override 	public String extractPathWithinPattern(String pattern, String path);1412083966;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;@Override_	public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__		StringBuilder builder = new StringBuilder()__		boolean pathStarted = false___		for (int segment = 0_ segment < patternParts.length_ segment++) {_			String patternPart = patternParts[segment]__			if (patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) {_				for (_ segment < pathParts.length_ segment++) {_					if (pathStarted || (segment == 0 && !pattern.startsWith(this.pathSeparator))) {_						builder.append(this.pathSeparator)__					}_					builder.append(pathParts[segment])__					pathStarted = true__				}_			}_		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;override,public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,string,builder,builder,new,string,builder,boolean,path,started,false,for,int,segment,0,segment,pattern,parts,length,segment,string,pattern,part,pattern,parts,segment,if,pattern,part,index,of,1,pattern,part,index,of,1,for,segment,path,parts,length,segment,if,path,started,segment,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,segment,path,started,true,return,builder,to,string
AntPathMatcher -> @Override 	public String extractPathWithinPattern(String pattern, String path);1412101078;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;@Override_	public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__		StringBuilder builder = new StringBuilder()__		boolean pathStarted = false___		for (int segment = 0_ segment < patternParts.length_ segment++) {_			String patternPart = patternParts[segment]__			if (patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) {_				for (_ segment < pathParts.length_ segment++) {_					if (pathStarted || (segment == 0 && !pattern.startsWith(this.pathSeparator))) {_						builder.append(this.pathSeparator)__					}_					builder.append(pathParts[segment])__					pathStarted = true__				}_			}_		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;override,public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,string,builder,builder,new,string,builder,boolean,path,started,false,for,int,segment,0,segment,pattern,parts,length,segment,string,pattern,part,pattern,parts,segment,if,pattern,part,index,of,1,pattern,part,index,of,1,for,segment,path,parts,length,segment,if,path,started,segment,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,segment,path,started,true,return,builder,to,string
AntPathMatcher -> @Override 	public String extractPathWithinPattern(String pattern, String path);1431086052;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;@Override_	public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__		StringBuilder builder = new StringBuilder()__		boolean pathStarted = false___		for (int segment = 0_ segment < patternParts.length_ segment++) {_			String patternPart = patternParts[segment]__			if (patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) {_				for (_ segment < pathParts.length_ segment++) {_					if (pathStarted || (segment == 0 && !pattern.startsWith(this.pathSeparator))) {_						builder.append(this.pathSeparator)__					}_					builder.append(pathParts[segment])__					pathStarted = true__				}_			}_		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;override,public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,string,builder,builder,new,string,builder,boolean,path,started,false,for,int,segment,0,segment,pattern,parts,length,segment,string,pattern,part,pattern,parts,segment,if,pattern,part,index,of,1,pattern,part,index,of,1,for,segment,path,parts,length,segment,if,path,started,segment,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,segment,path,started,true,return,builder,to,string
AntPathMatcher -> @Override 	public String extractPathWithinPattern(String pattern, String path);1431178173;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;@Override_	public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__		StringBuilder builder = new StringBuilder()__		boolean pathStarted = false___		for (int segment = 0_ segment < patternParts.length_ segment++) {_			String patternPart = patternParts[segment]__			if (patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) {_				for (_ segment < pathParts.length_ segment++) {_					if (pathStarted || (segment == 0 && !pattern.startsWith(this.pathSeparator))) {_						builder.append(this.pathSeparator)__					}_					builder.append(pathParts[segment])__					pathStarted = true__				}_			}_		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;override,public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,string,builder,builder,new,string,builder,boolean,path,started,false,for,int,segment,0,segment,pattern,parts,length,segment,string,pattern,part,pattern,parts,segment,if,pattern,part,index,of,1,pattern,part,index,of,1,for,segment,path,parts,length,segment,if,path,started,segment,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,segment,path,started,true,return,builder,to,string
AntPathMatcher -> @Override 	public String extractPathWithinPattern(String pattern, String path);1434572159;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;@Override_	public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__		StringBuilder builder = new StringBuilder()__		boolean pathStarted = false___		for (int segment = 0_ segment < patternParts.length_ segment++) {_			String patternPart = patternParts[segment]__			if (patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) {_				for (_ segment < pathParts.length_ segment++) {_					if (pathStarted || (segment == 0 && !pattern.startsWith(this.pathSeparator))) {_						builder.append(this.pathSeparator)__					}_					builder.append(pathParts[segment])__					pathStarted = true__				}_			}_		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;override,public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,string,builder,builder,new,string,builder,boolean,path,started,false,for,int,segment,0,segment,pattern,parts,length,segment,string,pattern,part,pattern,parts,segment,if,pattern,part,index,of,1,pattern,part,index,of,1,for,segment,path,parts,length,segment,if,path,started,segment,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,segment,path,started,true,return,builder,to,string
AntPathMatcher -> @Override 	public String extractPathWithinPattern(String pattern, String path);1435239719;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;@Override_	public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__		StringBuilder builder = new StringBuilder()__		boolean pathStarted = false___		for (int segment = 0_ segment < patternParts.length_ segment++) {_			String patternPart = patternParts[segment]__			if (patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) {_				for (_ segment < pathParts.length_ segment++) {_					if (pathStarted || (segment == 0 && !pattern.startsWith(this.pathSeparator))) {_						builder.append(this.pathSeparator)__					}_					builder.append(pathParts[segment])__					pathStarted = true__				}_			}_		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;override,public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,string,builder,builder,new,string,builder,boolean,path,started,false,for,int,segment,0,segment,pattern,parts,length,segment,string,pattern,part,pattern,parts,segment,if,pattern,part,index,of,1,pattern,part,index,of,1,for,segment,path,parts,length,segment,if,path,started,segment,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,segment,path,started,true,return,builder,to,string
AntPathMatcher -> @Override 	public String extractPathWithinPattern(String pattern, String path);1438166321;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;@Override_	public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__		StringBuilder builder = new StringBuilder()__		boolean pathStarted = false___		for (int segment = 0_ segment < patternParts.length_ segment++) {_			String patternPart = patternParts[segment]__			if (patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) {_				for (_ segment < pathParts.length_ segment++) {_					if (pathStarted || (segment == 0 && !pattern.startsWith(this.pathSeparator))) {_						builder.append(this.pathSeparator)__					}_					builder.append(pathParts[segment])__					pathStarted = true__				}_			}_		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;override,public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,string,builder,builder,new,string,builder,boolean,path,started,false,for,int,segment,0,segment,pattern,parts,length,segment,string,pattern,part,pattern,parts,segment,if,pattern,part,index,of,1,pattern,part,index,of,1,for,segment,path,parts,length,segment,if,path,started,segment,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,segment,path,started,true,return,builder,to,string
AntPathMatcher -> @Override 	public String extractPathWithinPattern(String pattern, String path);1455100778;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;@Override_	public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__		StringBuilder builder = new StringBuilder()__		boolean pathStarted = false___		for (int segment = 0_ segment < patternParts.length_ segment++) {_			String patternPart = patternParts[segment]__			if (patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) {_				for (_ segment < pathParts.length_ segment++) {_					if (pathStarted || (segment == 0 && !pattern.startsWith(this.pathSeparator))) {_						builder.append(this.pathSeparator)__					}_					builder.append(pathParts[segment])__					pathStarted = true__				}_			}_		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;override,public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,string,builder,builder,new,string,builder,boolean,path,started,false,for,int,segment,0,segment,pattern,parts,length,segment,string,pattern,part,pattern,parts,segment,if,pattern,part,index,of,1,pattern,part,index,of,1,for,segment,path,parts,length,segment,if,path,started,segment,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,segment,path,started,true,return,builder,to,string
AntPathMatcher -> @Override 	public String extractPathWithinPattern(String pattern, String path);1455850198;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;@Override_	public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__		StringBuilder builder = new StringBuilder()__		boolean pathStarted = false___		for (int segment = 0_ segment < patternParts.length_ segment++) {_			String patternPart = patternParts[segment]__			if (patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) {_				for (_ segment < pathParts.length_ segment++) {_					if (pathStarted || (segment == 0 && !pattern.startsWith(this.pathSeparator))) {_						builder.append(this.pathSeparator)__					}_					builder.append(pathParts[segment])__					pathStarted = true__				}_			}_		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;override,public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,string,builder,builder,new,string,builder,boolean,path,started,false,for,int,segment,0,segment,pattern,parts,length,segment,string,pattern,part,pattern,parts,segment,if,pattern,part,index,of,1,pattern,part,index,of,1,for,segment,path,parts,length,segment,if,path,started,segment,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,segment,path,started,true,return,builder,to,string
AntPathMatcher -> @Override 	public String extractPathWithinPattern(String pattern, String path);1460754629;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;@Override_	public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__		StringBuilder builder = new StringBuilder()__		boolean pathStarted = false___		for (int segment = 0_ segment < patternParts.length_ segment++) {_			String patternPart = patternParts[segment]__			if (patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) {_				for (_ segment < pathParts.length_ segment++) {_					if (pathStarted || (segment == 0 && !pattern.startsWith(this.pathSeparator))) {_						builder.append(this.pathSeparator)__					}_					builder.append(pathParts[segment])__					pathStarted = true__				}_			}_		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;override,public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,string,builder,builder,new,string,builder,boolean,path,started,false,for,int,segment,0,segment,pattern,parts,length,segment,string,pattern,part,pattern,parts,segment,if,pattern,part,index,of,1,pattern,part,index,of,1,for,segment,path,parts,length,segment,if,path,started,segment,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,segment,path,started,true,return,builder,to,string
AntPathMatcher -> @Override 	public String extractPathWithinPattern(String pattern, String path);1462393686;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;@Override_	public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__		StringBuilder builder = new StringBuilder()__		boolean pathStarted = false___		for (int segment = 0_ segment < patternParts.length_ segment++) {_			String patternPart = patternParts[segment]__			if (patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) {_				for (_ segment < pathParts.length_ segment++) {_					if (pathStarted || (segment == 0 && !pattern.startsWith(this.pathSeparator))) {_						builder.append(this.pathSeparator)__					}_					builder.append(pathParts[segment])__					pathStarted = true__				}_			}_		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;override,public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,string,builder,builder,new,string,builder,boolean,path,started,false,for,int,segment,0,segment,pattern,parts,length,segment,string,pattern,part,pattern,parts,segment,if,pattern,part,index,of,1,pattern,part,index,of,1,for,segment,path,parts,length,segment,if,path,started,segment,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,segment,path,started,true,return,builder,to,string
AntPathMatcher -> @Override 	public String extractPathWithinPattern(String pattern, String path);1467730834;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;@Override_	public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__		StringBuilder builder = new StringBuilder()__		boolean pathStarted = false___		for (int segment = 0_ segment < patternParts.length_ segment++) {_			String patternPart = patternParts[segment]__			if (patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) {_				for (_ segment < pathParts.length_ segment++) {_					if (pathStarted || (segment == 0 && !pattern.startsWith(this.pathSeparator))) {_						builder.append(this.pathSeparator)__					}_					builder.append(pathParts[segment])__					pathStarted = true__				}_			}_		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;override,public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,string,builder,builder,new,string,builder,boolean,path,started,false,for,int,segment,0,segment,pattern,parts,length,segment,string,pattern,part,pattern,parts,segment,if,pattern,part,index,of,1,pattern,part,index,of,1,for,segment,path,parts,length,segment,if,path,started,segment,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,segment,path,started,true,return,builder,to,string
AntPathMatcher -> @Override 	public String extractPathWithinPattern(String pattern, String path);1468327638;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;@Override_	public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__		StringBuilder builder = new StringBuilder()__		boolean pathStarted = false___		for (int segment = 0_ segment < patternParts.length_ segment++) {_			String patternPart = patternParts[segment]__			if (patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) {_				for (_ segment < pathParts.length_ segment++) {_					if (pathStarted || (segment == 0 && !pattern.startsWith(this.pathSeparator))) {_						builder.append(this.pathSeparator)__					}_					builder.append(pathParts[segment])__					pathStarted = true__				}_			}_		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;override,public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,string,builder,builder,new,string,builder,boolean,path,started,false,for,int,segment,0,segment,pattern,parts,length,segment,string,pattern,part,pattern,parts,segment,if,pattern,part,index,of,1,pattern,part,index,of,1,for,segment,path,parts,length,segment,if,path,started,segment,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,segment,path,started,true,return,builder,to,string
AntPathMatcher -> @Override 	public String extractPathWithinPattern(String pattern, String path);1472808958;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;@Override_	public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__		StringBuilder builder = new StringBuilder()__		boolean pathStarted = false___		for (int segment = 0_ segment < patternParts.length_ segment++) {_			String patternPart = patternParts[segment]__			if (patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) {_				for (_ segment < pathParts.length_ segment++) {_					if (pathStarted || (segment == 0 && !pattern.startsWith(this.pathSeparator))) {_						builder.append(this.pathSeparator)__					}_					builder.append(pathParts[segment])__					pathStarted = true__				}_			}_		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;override,public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,string,builder,builder,new,string,builder,boolean,path,started,false,for,int,segment,0,segment,pattern,parts,length,segment,string,pattern,part,pattern,parts,segment,if,pattern,part,index,of,1,pattern,part,index,of,1,for,segment,path,parts,length,segment,if,path,started,segment,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,segment,path,started,true,return,builder,to,string
AntPathMatcher -> @Override 	public String extractPathWithinPattern(String pattern, String path);1493317597;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;@Override_	public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__		StringBuilder builder = new StringBuilder()__		boolean pathStarted = false___		for (int segment = 0_ segment < patternParts.length_ segment++) {_			String patternPart = patternParts[segment]__			if (patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) {_				for (_ segment < pathParts.length_ segment++) {_					if (pathStarted || (segment == 0 && !pattern.startsWith(this.pathSeparator))) {_						builder.append(this.pathSeparator)__					}_					builder.append(pathParts[segment])__					pathStarted = true__				}_			}_		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;override,public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,string,builder,builder,new,string,builder,boolean,path,started,false,for,int,segment,0,segment,pattern,parts,length,segment,string,pattern,part,pattern,parts,segment,if,pattern,part,index,of,1,pattern,part,index,of,1,for,segment,path,parts,length,segment,if,path,started,segment,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,segment,path,started,true,return,builder,to,string
AntPathMatcher -> @Override 	public String extractPathWithinPattern(String pattern, String path);1493321510;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;@Override_	public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__		StringBuilder builder = new StringBuilder()__		boolean pathStarted = false___		for (int segment = 0_ segment < patternParts.length_ segment++) {_			String patternPart = patternParts[segment]__			if (patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) {_				for (_ segment < pathParts.length_ segment++) {_					if (pathStarted || (segment == 0 && !pattern.startsWith(this.pathSeparator))) {_						builder.append(this.pathSeparator)__					}_					builder.append(pathParts[segment])__					pathStarted = true__				}_			}_		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;override,public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,string,builder,builder,new,string,builder,boolean,path,started,false,for,int,segment,0,segment,pattern,parts,length,segment,string,pattern,part,pattern,parts,segment,if,pattern,part,index,of,1,pattern,part,index,of,1,for,segment,path,parts,length,segment,if,path,started,segment,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,segment,path,started,true,return,builder,to,string
AntPathMatcher -> @Override 	public String extractPathWithinPattern(String pattern, String path);1496259743;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;@Override_	public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__		StringBuilder builder = new StringBuilder()__		boolean pathStarted = false___		for (int segment = 0_ segment < patternParts.length_ segment++) {_			String patternPart = patternParts[segment]__			if (patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) {_				for (_ segment < pathParts.length_ segment++) {_					if (pathStarted || (segment == 0 && !pattern.startsWith(this.pathSeparator))) {_						builder.append(this.pathSeparator)__					}_					builder.append(pathParts[segment])__					pathStarted = true__				}_			}_		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;override,public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,string,builder,builder,new,string,builder,boolean,path,started,false,for,int,segment,0,segment,pattern,parts,length,segment,string,pattern,part,pattern,parts,segment,if,pattern,part,index,of,1,pattern,part,index,of,1,for,segment,path,parts,length,segment,if,path,started,segment,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,segment,path,started,true,return,builder,to,string
AntPathMatcher -> @Override 	public String extractPathWithinPattern(String pattern, String path);1496837955;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;@Override_	public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__		StringBuilder builder = new StringBuilder()__		boolean pathStarted = false___		for (int segment = 0_ segment < patternParts.length_ segment++) {_			String patternPart = patternParts[segment]__			if (patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) {_				for (_ segment < pathParts.length_ segment++) {_					if (pathStarted || (segment == 0 && !pattern.startsWith(this.pathSeparator))) {_						builder.append(this.pathSeparator)__					}_					builder.append(pathParts[segment])__					pathStarted = true__				}_			}_		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;override,public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,string,builder,builder,new,string,builder,boolean,path,started,false,for,int,segment,0,segment,pattern,parts,length,segment,string,pattern,part,pattern,parts,segment,if,pattern,part,index,of,1,pattern,part,index,of,1,for,segment,path,parts,length,segment,if,path,started,segment,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,segment,path,started,true,return,builder,to,string
AntPathMatcher -> @Override 	public String extractPathWithinPattern(String pattern, String path);1498780456;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;@Override_	public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__		StringBuilder builder = new StringBuilder()__		boolean pathStarted = false___		for (int segment = 0_ segment < patternParts.length_ segment++) {_			String patternPart = patternParts[segment]__			if (patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) {_				for (_ segment < pathParts.length_ segment++) {_					if (pathStarted || (segment == 0 && !pattern.startsWith(this.pathSeparator))) {_						builder.append(this.pathSeparator)__					}_					builder.append(pathParts[segment])__					pathStarted = true__				}_			}_		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;override,public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,string,builder,builder,new,string,builder,boolean,path,started,false,for,int,segment,0,segment,pattern,parts,length,segment,string,pattern,part,pattern,parts,segment,if,pattern,part,index,of,1,pattern,part,index,of,1,for,segment,path,parts,length,segment,if,path,started,segment,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,segment,path,started,true,return,builder,to,string
AntPathMatcher -> @Override 	public String extractPathWithinPattern(String pattern, String path);1518772998;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;@Override_	public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__		StringBuilder builder = new StringBuilder()__		boolean pathStarted = false___		for (int segment = 0_ segment < patternParts.length_ segment++) {_			String patternPart = patternParts[segment]__			if (patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) {_				for (_ segment < pathParts.length_ segment++) {_					if (pathStarted || (segment == 0 && !pattern.startsWith(this.pathSeparator))) {_						builder.append(this.pathSeparator)__					}_					builder.append(pathParts[segment])__					pathStarted = true__				}_			}_		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;override,public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,string,builder,builder,new,string,builder,boolean,path,started,false,for,int,segment,0,segment,pattern,parts,length,segment,string,pattern,part,pattern,parts,segment,if,pattern,part,index,of,1,pattern,part,index,of,1,for,segment,path,parts,length,segment,if,path,started,segment,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,segment,path,started,true,return,builder,to,string
AntPathMatcher -> @Override 	public String extractPathWithinPattern(String pattern, String path);1530174524;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;@Override_	public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__		StringBuilder builder = new StringBuilder()__		boolean pathStarted = false___		for (int segment = 0_ segment < patternParts.length_ segment++) {_			String patternPart = patternParts[segment]__			if (patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) {_				for (_ segment < pathParts.length_ segment++) {_					if (pathStarted || (segment == 0 && !pattern.startsWith(this.pathSeparator))) {_						builder.append(this.pathSeparator)__					}_					builder.append(pathParts[segment])__					pathStarted = true__				}_			}_		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;override,public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,string,builder,builder,new,string,builder,boolean,path,started,false,for,int,segment,0,segment,pattern,parts,length,segment,string,pattern,part,pattern,parts,segment,if,pattern,part,index,of,1,pattern,part,index,of,1,for,segment,path,parts,length,segment,if,path,started,segment,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,segment,path,started,true,return,builder,to,string
AntPathMatcher -> @Override 	public String extractPathWithinPattern(String pattern, String path);1530174524;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;@Override_	public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__		StringBuilder builder = new StringBuilder()__		boolean pathStarted = false___		for (int segment = 0_ segment < patternParts.length_ segment++) {_			String patternPart = patternParts[segment]__			if (patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) {_				for (_ segment < pathParts.length_ segment++) {_					if (pathStarted || (segment == 0 && !pattern.startsWith(this.pathSeparator))) {_						builder.append(this.pathSeparator)__					}_					builder.append(pathParts[segment])__					pathStarted = true__				}_			}_		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;override,public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,string,builder,builder,new,string,builder,boolean,path,started,false,for,int,segment,0,segment,pattern,parts,length,segment,string,pattern,part,pattern,parts,segment,if,pattern,part,index,of,1,pattern,part,index,of,1,for,segment,path,parts,length,segment,if,path,started,segment,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,segment,path,started,true,return,builder,to,string
AntPathMatcher -> @Override 	public String extractPathWithinPattern(String pattern, String path);1535316501;Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>_<li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>_<li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>_<li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>_<li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>_<li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>_<li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>_<li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>_<p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but_does <strong>not</strong> enforce this.;@Override_	public String extractPathWithinPattern(String pattern, String path) {_		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)__		StringBuilder builder = new StringBuilder()__		boolean pathStarted = false___		for (int segment = 0_ segment < patternParts.length_ segment++) {_			String patternPart = patternParts[segment]__			if (patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) {_				for (_ segment < pathParts.length_ segment++) {_					if (pathStarted || (segment == 0 && !pattern.startsWith(this.pathSeparator))) {_						builder.append(this.pathSeparator)__					}_					builder.append(pathParts[segment])__					pathStarted = true__				}_			}_		}__		return builder.toString()__	};given,a,pattern,and,a,full,path,determine,the,pattern,mapped,part,p,for,example,ul,li,code,docs,cvs,commit,html,and,code,docs,cvs,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,cvs,html,and,code,docs,cvs,commit,html,code,commit,html,li,li,code,docs,and,code,docs,cvs,commit,code,cvs,commit,li,li,code,docs,html,and,code,docs,cvs,commit,html,code,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,html,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,li,code,and,code,docs,cvs,commit,html,code,docs,cvs,commit,html,li,ul,p,assumes,that,link,match,returns,code,true,for,code,pattern,and,code,path,but,does,strong,not,strong,enforce,this;override,public,string,extract,path,within,pattern,string,pattern,string,path,string,pattern,parts,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,parts,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,string,builder,builder,new,string,builder,boolean,path,started,false,for,int,segment,0,segment,pattern,parts,length,segment,string,pattern,part,pattern,parts,segment,if,pattern,part,index,of,1,pattern,part,index,of,1,for,segment,path,parts,length,segment,if,path,started,segment,0,pattern,starts,with,this,path,separator,builder,append,this,path,separator,builder,append,path,parts,segment,path,started,true,return,builder,to,string
AntPathMatcher -> public Comparator<String> getPatternComparator(String path);1328020251;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of explicitness._<p>The returned <code>Comparator</code> will {@linkplain java.util.Collections#sort(java.util.List,_java.util.Comparator) sort} a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns: <ol> <li><code>/hotels/new</code></li>_<li><code>/hotels/{hotel}</code></li> <li><code>/hotels/*</code></li> </ol> the returned comparator will sort this_list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path is {@code /hotels/2},_the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,the,returned,code,comparator,code,will,linkplain,java,util,collections,sort,java,util,list,java,util,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,code,li,li,code,hotels,hotel,code,li,li,code,hotels,code,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> public Comparator<String> getPatternComparator(String path);1333393580;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of explicitness._<p>The returned <code>Comparator</code> will {@linkplain java.util.Collections#sort(java.util.List,_java.util.Comparator) sort} a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns: <ol> <li><code>/hotels/new</code></li>_<li><code>/hotels/{hotel}</code></li> <li><code>/hotels/*</code></li> </ol> the returned comparator will sort this_list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path is {@code /hotels/2},_the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,the,returned,code,comparator,code,will,linkplain,java,util,collections,sort,java,util,list,java,util,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,code,li,li,code,hotels,hotel,code,li,li,code,hotels,code,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> public Comparator<String> getPatternComparator(String path);1347310630;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of explicitness._<p>The returned <code>Comparator</code> will {@linkplain java.util.Collections#sort(java.util.List,_java.util.Comparator) sort} a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns: <ol> <li><code>/hotels/new</code></li>_<li><code>/hotels/{hotel}</code></li> <li><code>/hotels/*</code></li> </ol> the returned comparator will sort this_list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path is {@code /hotels/2},_the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,the,returned,code,comparator,code,will,linkplain,java,util,collections,sort,java,util,list,java,util,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,code,li,li,code,hotels,hotel,code,li,li,code,hotels,code,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> public Comparator<String> getPatternComparator(String path);1355351965;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of explicitness._<p>The returned <code>Comparator</code> will {@linkplain java.util.Collections#sort(java.util.List,_java.util.Comparator) sort} a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns: <ol> <li><code>/hotels/new</code></li>_<li><code>/hotels/{hotel}</code></li> <li><code>/hotels/*</code></li> </ol> the returned comparator will sort this_list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path is {@code /hotels/2},_the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,the,returned,code,comparator,code,will,linkplain,java,util,collections,sort,java,util,list,java,util,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,code,li,li,code,hotels,hotel,code,li,li,code,hotels,code,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> public Comparator<String> getPatternComparator(String path);1357119239;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of explicitness._<p>The returned {@code Comparator} will {@linkplain java.util.Collections#sort(java.util.List,_java.util.Comparator) sort} a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns: <ol> <li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li> </ol> the returned comparator will sort this_list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path is {@code /hotels/2},_the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,the,returned,code,comparator,will,linkplain,java,util,collections,sort,java,util,list,java,util,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> public Comparator<String> getPatternComparator(String path);1362408075;Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of explicitness._<p>The returned {@code Comparator} will {@linkplain java.util.Collections#sort(java.util.List,_java.util.Comparator) sort} a list so that more specific patterns (without uri templates or wild cards) come before_generic patterns. So given a list with the following patterns: <ol> <li>{@code /hotels/new}</li>_<li>{@code /hotels/{hotel}}</li> <li>{@code /hotels/*}</li> </ol> the returned comparator will sort this_list so that the order will be as indicated._<p>The full path given as parameter is used to test for exact matches. So when the given path is {@code /hotels/2},_the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}._@param path the full path to use for comparison_@return a comparator capable of sorting patterns in order of explicitness;public Comparator<String> getPatternComparator(String path) {_		return new AntPatternComparator(path)__	};given,a,full,path,returns,a,link,comparator,suitable,for,sorting,patterns,in,order,of,explicitness,p,the,returned,code,comparator,will,linkplain,java,util,collections,sort,java,util,list,java,util,comparator,sort,a,list,so,that,more,specific,patterns,without,uri,templates,or,wild,cards,come,before,generic,patterns,so,given,a,list,with,the,following,patterns,ol,li,code,hotels,new,li,li,code,hotels,hotel,li,li,code,hotels,li,ol,the,returned,comparator,will,sort,this,list,so,that,the,order,will,be,as,indicated,p,the,full,path,given,as,parameter,is,used,to,test,for,exact,matches,so,when,the,given,path,is,code,hotels,2,the,pattern,code,hotels,2,will,be,sorted,before,code,hotels,1,param,path,the,full,path,to,use,for,comparison,return,a,comparator,capable,of,sorting,patterns,in,order,of,explicitness;public,comparator,string,get,pattern,comparator,string,path,return,new,ant,pattern,comparator,path
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, Map<String, String> uriTemplateVariables);1355351965;Main entry point._@return <code>true</code> if the string matches against the pattern, or <code>false</code> otherwise.;public boolean matchStrings(String str, Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					Assert.isTrue(this.variableNames.size() == matcher.groupCount(),_							"The number of capturing groups in the pattern segment " + this.pattern +_							" does not match the number of URI template variables it defines, which can occur if " +_							" capturing groups are used in a URI template regex. Use non-capturing groups instead.")__					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,code,if,the,string,matches,against,the,pattern,or,code,false,code,otherwise;public,boolean,match,strings,string,str,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,assert,is,true,this,variable,names,size,matcher,group,count,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, Map<String, String> uriTemplateVariables);1356735495;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					Assert.isTrue(this.variableNames.size() == matcher.groupCount(),_							"The number of capturing groups in the pattern segment " + this.pattern +_							" does not match the number of URI template variables it defines, which can occur if " +_							" capturing groups are used in a URI template regex. Use non-capturing groups instead.")__					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,assert,is,true,this,variable,names,size,matcher,group,count,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, Map<String, String> uriTemplateVariables);1357119239;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					Assert.isTrue(this.variableNames.size() == matcher.groupCount(),_							"The number of capturing groups in the pattern segment " + this.pattern +_							" does not match the number of URI template variables it defines, which can occur if " +_							" capturing groups are used in a URI template regex. Use non-capturing groups instead.")__					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,assert,is,true,this,variable,names,size,matcher,group,count,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, Map<String, String> uriTemplateVariables);1362408075;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					Assert.isTrue(this.variableNames.size() == matcher.groupCount(),_							"The number of capturing groups in the pattern segment " + this.pattern +_							" does not match the number of URI template variables it defines, which can occur if " +_							" capturing groups are used in a URI template regex. Use non-capturing groups instead.")__					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,assert,is,true,this,variable,names,size,matcher,group,count,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, Map<String, String> uriTemplateVariables);1368482696;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					Assert.isTrue(this.variableNames.size() == matcher.groupCount(),_							"The number of capturing groups in the pattern segment " + this.pattern +_							" does not match the number of URI template variables it defines, which can occur if " +_							" capturing groups are used in a URI template regex. Use non-capturing groups instead.")__					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,assert,is,true,this,variable,names,size,matcher,group,count,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, Map<String, String> uriTemplateVariables);1377725408;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					Assert.isTrue(this.variableNames.size() == matcher.groupCount(),_							"The number of capturing groups in the pattern segment " + this.pattern +_							" does not match the number of URI template variables it defines, which can occur if " +_							" capturing groups are used in a URI template regex. Use non-capturing groups instead.")__					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,assert,is,true,this,variable,names,size,matcher,group,count,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, Map<String, String> uriTemplateVariables);1377735685;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					Assert.isTrue(this.variableNames.size() == matcher.groupCount(),_							"The number of capturing groups in the pattern segment " + this.pattern +_							" does not match the number of URI template variables it defines, which can occur if " +_							" capturing groups are used in a URI template regex. Use non-capturing groups instead.")__					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,assert,is,true,this,variable,names,size,matcher,group,count,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, Map<String, String> uriTemplateVariables);1383090798;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					Assert.isTrue(this.variableNames.size() == matcher.groupCount(),_							"The number of capturing groups in the pattern segment " + this.pattern +_							" does not match the number of URI template variables it defines, which can occur if " +_							" capturing groups are used in a URI template regex. Use non-capturing groups instead.")__					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,assert,is,true,this,variable,names,size,matcher,group,count,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, Map<String, String> uriTemplateVariables);1383157688;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					Assert.isTrue(this.variableNames.size() == matcher.groupCount(),_							"The number of capturing groups in the pattern segment " + this.pattern +_							" does not match the number of URI template variables it defines, which can occur if " +_							" capturing groups are used in a URI template regex. Use non-capturing groups instead.")__					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,assert,is,true,this,variable,names,size,matcher,group,count,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, Map<String, String> uriTemplateVariables);1385501137;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					Assert.isTrue(this.variableNames.size() == matcher.groupCount(),_							"The number of capturing groups in the pattern segment " + this.pattern +_							" does not match the number of URI template variables it defines, which can occur if " +_							" capturing groups are used in a URI template regex. Use non-capturing groups instead.")__					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,assert,is,true,this,variable,names,size,matcher,group,count,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, Map<String, String> uriTemplateVariables);1388766826;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					Assert.isTrue(this.variableNames.size() == matcher.groupCount(),_							"The number of capturing groups in the pattern segment " + this.pattern +_							" does not match the number of URI template variables it defines, which can occur if " +_							" capturing groups are used in a URI template regex. Use non-capturing groups instead.")__					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,assert,is,true,this,variable,names,size,matcher,group,count,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, Map<String, String> uriTemplateVariables);1402512669;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					Assert.isTrue(this.variableNames.size() == matcher.groupCount(),_							"The number of capturing groups in the pattern segment " + this.pattern +_							" does not match the number of URI template variables it defines, which can occur if " +_							" capturing groups are used in a URI template regex. Use non-capturing groups instead.")__					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,assert,is,true,this,variable,names,size,matcher,group,count,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, Map<String, String> uriTemplateVariables);1402512669;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					Assert.isTrue(this.variableNames.size() == matcher.groupCount(),_							"The number of capturing groups in the pattern segment " + this.pattern +_							" does not match the number of URI template variables it defines, which can occur if " +_							" capturing groups are used in a URI template regex. Use non-capturing groups instead.")__					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,assert,is,true,this,variable,names,size,matcher,group,count,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, Map<String, String> uriTemplateVariables);1402512669;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					Assert.isTrue(this.variableNames.size() == matcher.groupCount(),_							"The number of capturing groups in the pattern segment " + this.pattern +_							" does not match the number of URI template variables it defines, which can occur if " +_							" capturing groups are used in a URI template regex. Use non-capturing groups instead.")__					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,assert,is,true,this,variable,names,size,matcher,group,count,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, Map<String, String> uriTemplateVariables);1405378164;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					Assert.isTrue(this.variableNames.size() == matcher.groupCount(),_							"The number of capturing groups in the pattern segment " + this.pattern +_							" does not match the number of URI template variables it defines, which can occur if " +_							" capturing groups are used in a URI template regex. Use non-capturing groups instead.")__					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,assert,is,true,this,variable,names,size,matcher,group,count,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, Map<String, String> uriTemplateVariables);1405378165;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					Assert.isTrue(this.variableNames.size() == matcher.groupCount(),_							"The number of capturing groups in the pattern segment " + this.pattern +_							" does not match the number of URI template variables it defines, which can occur if " +_							" capturing groups are used in a URI template regex. Use non-capturing groups instead.")__					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,assert,is,true,this,variable,names,size,matcher,group,count,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, Map<String, String> uriTemplateVariables);1405696918;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					Assert.isTrue(this.variableNames.size() == matcher.groupCount(),_							"The number of capturing groups in the pattern segment " + this.pattern +_							" does not match the number of URI template variables it defines, which can occur if " +_							" capturing groups are used in a URI template regex. Use non-capturing groups instead.")__					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,assert,is,true,this,variable,names,size,matcher,group,count,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, Map<String, String> uriTemplateVariables);1409784938;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					Assert.isTrue(this.variableNames.size() == matcher.groupCount(),_							"The number of capturing groups in the pattern segment " + this.pattern +_							" does not match the number of URI template variables it defines, which can occur if " +_							" capturing groups are used in a URI template regex. Use non-capturing groups instead.")__					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,assert,is,true,this,variable,names,size,matcher,group,count,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, Map<String, String> uriTemplateVariables);1412083966;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					Assert.isTrue(this.variableNames.size() == matcher.groupCount(),_							"The number of capturing groups in the pattern segment " + this.pattern +_							" does not match the number of URI template variables it defines, which can occur if " +_							" capturing groups are used in a URI template regex. Use non-capturing groups instead.")__					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,assert,is,true,this,variable,names,size,matcher,group,count,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, Map<String, String> uriTemplateVariables);1412101078;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					Assert.isTrue(this.variableNames.size() == matcher.groupCount(),_							"The number of capturing groups in the pattern segment " + this.pattern +_							" does not match the number of URI template variables it defines, which can occur if " +_							" capturing groups are used in a URI template regex. Use non-capturing groups instead.")__					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,assert,is,true,this,variable,names,size,matcher,group,count,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, Map<String, String> uriTemplateVariables);1431086052;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					Assert.isTrue(this.variableNames.size() == matcher.groupCount(),_							"The number of capturing groups in the pattern segment " + this.pattern +_							" does not match the number of URI template variables it defines, which can occur if " +_							" capturing groups are used in a URI template regex. Use non-capturing groups instead.")__					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,assert,is,true,this,variable,names,size,matcher,group,count,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, Map<String, String> uriTemplateVariables);1431178173;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					Assert.isTrue(this.variableNames.size() == matcher.groupCount(),_							"The number of capturing groups in the pattern segment " + this.pattern +_							" does not match the number of URI template variables it defines, which can occur if " +_							" capturing groups are used in a URI template regex. Use non-capturing groups instead.")__					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,assert,is,true,this,variable,names,size,matcher,group,count,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, Map<String, String> uriTemplateVariables);1434572159;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					Assert.isTrue(this.variableNames.size() == matcher.groupCount(),_							"The number of capturing groups in the pattern segment " + this.pattern +_							" does not match the number of URI template variables it defines, which can occur if " +_							" capturing groups are used in a URI template regex. Use non-capturing groups instead.")__					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,assert,is,true,this,variable,names,size,matcher,group,count,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, Map<String, String> uriTemplateVariables);1435239719;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					Assert.isTrue(this.variableNames.size() == matcher.groupCount(),_							"The number of capturing groups in the pattern segment " + this.pattern +_							" does not match the number of URI template variables it defines, which can occur if " +_							" capturing groups are used in a URI template regex. Use non-capturing groups instead.")__					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,assert,is,true,this,variable,names,size,matcher,group,count,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, Map<String, String> uriTemplateVariables);1438166321;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					if (this.variableNames.size() != matcher.groupCount()) {_						throw new IllegalArgumentException("The number of capturing groups in the pattern segment " +_								this.pattern + " does not match the number of URI template variables it defines, " +_								"which can occur if capturing groups are used in a URI template regex. " +_								"Use non-capturing groups instead.")__					}_					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,if,this,variable,names,size,matcher,group,count,throw,new,illegal,argument,exception,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, Map<String, String> uriTemplateVariables);1455100778;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					if (this.variableNames.size() != matcher.groupCount()) {_						throw new IllegalArgumentException("The number of capturing groups in the pattern segment " +_								this.pattern + " does not match the number of URI template variables it defines, " +_								"which can occur if capturing groups are used in a URI template regex. " +_								"Use non-capturing groups instead.")__					}_					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,if,this,variable,names,size,matcher,group,count,throw,new,illegal,argument,exception,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, Map<String, String> uriTemplateVariables);1455850198;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					if (this.variableNames.size() != matcher.groupCount()) {_						throw new IllegalArgumentException("The number of capturing groups in the pattern segment " +_								this.pattern + " does not match the number of URI template variables it defines, " +_								"which can occur if capturing groups are used in a URI template regex. " +_								"Use non-capturing groups instead.")__					}_					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,if,this,variable,names,size,matcher,group,count,throw,new,illegal,argument,exception,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, Map<String, String> uriTemplateVariables);1460754629;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					if (this.variableNames.size() != matcher.groupCount()) {_						throw new IllegalArgumentException("The number of capturing groups in the pattern segment " +_								this.pattern + " does not match the number of URI template variables it defines, " +_								"which can occur if capturing groups are used in a URI template regex. " +_								"Use non-capturing groups instead.")__					}_					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,if,this,variable,names,size,matcher,group,count,throw,new,illegal,argument,exception,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, Map<String, String> uriTemplateVariables);1462393686;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					if (this.variableNames.size() != matcher.groupCount()) {_						throw new IllegalArgumentException("The number of capturing groups in the pattern segment " +_								this.pattern + " does not match the number of URI template variables it defines, " +_								"which can occur if capturing groups are used in a URI template regex. " +_								"Use non-capturing groups instead.")__					}_					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,if,this,variable,names,size,matcher,group,count,throw,new,illegal,argument,exception,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, Map<String, String> uriTemplateVariables);1467730834;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					if (this.variableNames.size() != matcher.groupCount()) {_						throw new IllegalArgumentException("The number of capturing groups in the pattern segment " +_								this.pattern + " does not match the number of URI template variables it defines, " +_								"which can occur if capturing groups are used in a URI template regex. " +_								"Use non-capturing groups instead.")__					}_					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,if,this,variable,names,size,matcher,group,count,throw,new,illegal,argument,exception,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, Map<String, String> uriTemplateVariables);1468327638;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					if (this.variableNames.size() != matcher.groupCount()) {_						throw new IllegalArgumentException("The number of capturing groups in the pattern segment " +_								this.pattern + " does not match the number of URI template variables it defines, " +_								"which can occur if capturing groups are used in a URI template regex. " +_								"Use non-capturing groups instead.")__					}_					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,if,this,variable,names,size,matcher,group,count,throw,new,illegal,argument,exception,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, Map<String, String> uriTemplateVariables);1472808958;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					if (this.variableNames.size() != matcher.groupCount()) {_						throw new IllegalArgumentException("The number of capturing groups in the pattern segment " +_								this.pattern + " does not match the number of URI template variables it defines, " +_								"which can occur if capturing groups are used in a URI template regex. " +_								"Use non-capturing groups instead.")__					}_					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,if,this,variable,names,size,matcher,group,count,throw,new,illegal,argument,exception,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, Map<String, String> uriTemplateVariables);1493317597;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					if (this.variableNames.size() != matcher.groupCount()) {_						throw new IllegalArgumentException("The number of capturing groups in the pattern segment " +_								this.pattern + " does not match the number of URI template variables it defines, " +_								"which can occur if capturing groups are used in a URI template regex. " +_								"Use non-capturing groups instead.")__					}_					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,if,this,variable,names,size,matcher,group,count,throw,new,illegal,argument,exception,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, Map<String, String> uriTemplateVariables);1493321510;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					if (this.variableNames.size() != matcher.groupCount()) {_						throw new IllegalArgumentException("The number of capturing groups in the pattern segment " +_								this.pattern + " does not match the number of URI template variables it defines, " +_								"which can occur if capturing groups are used in a URI template regex. " +_								"Use non-capturing groups instead.")__					}_					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,if,this,variable,names,size,matcher,group,count,throw,new,illegal,argument,exception,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> AntPathStringMatcher -> public boolean matchStrings(String str, Map<String, String> uriTemplateVariables);1496259743;Main entry point._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;public boolean matchStrings(String str, Map<String, String> uriTemplateVariables) {_			Matcher matcher = this.pattern.matcher(str)__			if (matcher.matches()) {_				if (uriTemplateVariables != null) {_					_					if (this.variableNames.size() != matcher.groupCount()) {_						throw new IllegalArgumentException("The number of capturing groups in the pattern segment " +_								this.pattern + " does not match the number of URI template variables it defines, " +_								"which can occur if capturing groups are used in a URI template regex. " +_								"Use non-capturing groups instead.")__					}_					for (int i = 1_ i <= matcher.groupCount()_ i++) {_						String name = this.variableNames.get(i - 1)__						String value = matcher.group(i)__						uriTemplateVariables.put(name, value)__					}_				}_				return true__			}_			else {_				return false__			}_		};main,entry,point,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;public,boolean,match,strings,string,str,map,string,string,uri,template,variables,matcher,matcher,this,pattern,matcher,str,if,matcher,matches,if,uri,template,variables,null,if,this,variable,names,size,matcher,group,count,throw,new,illegal,argument,exception,the,number,of,capturing,groups,in,the,pattern,segment,this,pattern,does,not,match,the,number,of,uri,template,variables,it,defines,which,can,occur,if,capturing,groups,are,used,in,a,uri,template,regex,use,non,capturing,groups,instead,for,int,i,1,i,matcher,group,count,i,string,name,this,variable,names,get,i,1,string,value,matcher,group,i,uri,template,variables,put,name,value,return,true,else,return,false
AntPathMatcher -> public void setCaseSensitive(boolean caseSensitive);1438166321;Specify whether to perform pattern matching in a case-sensitive fashion._<p>Default is {@code true}. Switch this to {@code false} for case-insensitive matching._@since 4.2;public void setCaseSensitive(boolean caseSensitive) {_		this.caseSensitive = caseSensitive__	};specify,whether,to,perform,pattern,matching,in,a,case,sensitive,fashion,p,default,is,code,true,switch,this,to,code,false,for,case,insensitive,matching,since,4,2;public,void,set,case,sensitive,boolean,case,sensitive,this,case,sensitive,case,sensitive
AntPathMatcher -> public void setCaseSensitive(boolean caseSensitive);1455100778;Specify whether to perform pattern matching in a case-sensitive fashion._<p>Default is {@code true}. Switch this to {@code false} for case-insensitive matching._@since 4.2;public void setCaseSensitive(boolean caseSensitive) {_		this.caseSensitive = caseSensitive__	};specify,whether,to,perform,pattern,matching,in,a,case,sensitive,fashion,p,default,is,code,true,switch,this,to,code,false,for,case,insensitive,matching,since,4,2;public,void,set,case,sensitive,boolean,case,sensitive,this,case,sensitive,case,sensitive
AntPathMatcher -> public void setCaseSensitive(boolean caseSensitive);1455850198;Specify whether to perform pattern matching in a case-sensitive fashion._<p>Default is {@code true}. Switch this to {@code false} for case-insensitive matching._@since 4.2;public void setCaseSensitive(boolean caseSensitive) {_		this.caseSensitive = caseSensitive__	};specify,whether,to,perform,pattern,matching,in,a,case,sensitive,fashion,p,default,is,code,true,switch,this,to,code,false,for,case,insensitive,matching,since,4,2;public,void,set,case,sensitive,boolean,case,sensitive,this,case,sensitive,case,sensitive
AntPathMatcher -> public void setCaseSensitive(boolean caseSensitive);1460754629;Specify whether to perform pattern matching in a case-sensitive fashion._<p>Default is {@code true}. Switch this to {@code false} for case-insensitive matching._@since 4.2;public void setCaseSensitive(boolean caseSensitive) {_		this.caseSensitive = caseSensitive__	};specify,whether,to,perform,pattern,matching,in,a,case,sensitive,fashion,p,default,is,code,true,switch,this,to,code,false,for,case,insensitive,matching,since,4,2;public,void,set,case,sensitive,boolean,case,sensitive,this,case,sensitive,case,sensitive
AntPathMatcher -> public void setCaseSensitive(boolean caseSensitive);1462393686;Specify whether to perform pattern matching in a case-sensitive fashion._<p>Default is {@code true}. Switch this to {@code false} for case-insensitive matching._@since 4.2;public void setCaseSensitive(boolean caseSensitive) {_		this.caseSensitive = caseSensitive__	};specify,whether,to,perform,pattern,matching,in,a,case,sensitive,fashion,p,default,is,code,true,switch,this,to,code,false,for,case,insensitive,matching,since,4,2;public,void,set,case,sensitive,boolean,case,sensitive,this,case,sensitive,case,sensitive
AntPathMatcher -> public void setCaseSensitive(boolean caseSensitive);1467730834;Specify whether to perform pattern matching in a case-sensitive fashion._<p>Default is {@code true}. Switch this to {@code false} for case-insensitive matching._@since 4.2;public void setCaseSensitive(boolean caseSensitive) {_		this.caseSensitive = caseSensitive__	};specify,whether,to,perform,pattern,matching,in,a,case,sensitive,fashion,p,default,is,code,true,switch,this,to,code,false,for,case,insensitive,matching,since,4,2;public,void,set,case,sensitive,boolean,case,sensitive,this,case,sensitive,case,sensitive
AntPathMatcher -> public void setCaseSensitive(boolean caseSensitive);1468327638;Specify whether to perform pattern matching in a case-sensitive fashion._<p>Default is {@code true}. Switch this to {@code false} for case-insensitive matching._@since 4.2;public void setCaseSensitive(boolean caseSensitive) {_		this.caseSensitive = caseSensitive__	};specify,whether,to,perform,pattern,matching,in,a,case,sensitive,fashion,p,default,is,code,true,switch,this,to,code,false,for,case,insensitive,matching,since,4,2;public,void,set,case,sensitive,boolean,case,sensitive,this,case,sensitive,case,sensitive
AntPathMatcher -> public void setCaseSensitive(boolean caseSensitive);1472808958;Specify whether to perform pattern matching in a case-sensitive fashion._<p>Default is {@code true}. Switch this to {@code false} for case-insensitive matching._@since 4.2;public void setCaseSensitive(boolean caseSensitive) {_		this.caseSensitive = caseSensitive__	};specify,whether,to,perform,pattern,matching,in,a,case,sensitive,fashion,p,default,is,code,true,switch,this,to,code,false,for,case,insensitive,matching,since,4,2;public,void,set,case,sensitive,boolean,case,sensitive,this,case,sensitive,case,sensitive
AntPathMatcher -> public void setCaseSensitive(boolean caseSensitive);1493317597;Specify whether to perform pattern matching in a case-sensitive fashion._<p>Default is {@code true}. Switch this to {@code false} for case-insensitive matching._@since 4.2;public void setCaseSensitive(boolean caseSensitive) {_		this.caseSensitive = caseSensitive__	};specify,whether,to,perform,pattern,matching,in,a,case,sensitive,fashion,p,default,is,code,true,switch,this,to,code,false,for,case,insensitive,matching,since,4,2;public,void,set,case,sensitive,boolean,case,sensitive,this,case,sensitive,case,sensitive
AntPathMatcher -> public void setCaseSensitive(boolean caseSensitive);1493321510;Specify whether to perform pattern matching in a case-sensitive fashion._<p>Default is {@code true}. Switch this to {@code false} for case-insensitive matching._@since 4.2;public void setCaseSensitive(boolean caseSensitive) {_		this.caseSensitive = caseSensitive__	};specify,whether,to,perform,pattern,matching,in,a,case,sensitive,fashion,p,default,is,code,true,switch,this,to,code,false,for,case,insensitive,matching,since,4,2;public,void,set,case,sensitive,boolean,case,sensitive,this,case,sensitive,case,sensitive
AntPathMatcher -> public void setCaseSensitive(boolean caseSensitive);1496259743;Specify whether to perform pattern matching in a case-sensitive fashion._<p>Default is {@code true}. Switch this to {@code false} for case-insensitive matching._@since 4.2;public void setCaseSensitive(boolean caseSensitive) {_		this.caseSensitive = caseSensitive__	};specify,whether,to,perform,pattern,matching,in,a,case,sensitive,fashion,p,default,is,code,true,switch,this,to,code,false,for,case,insensitive,matching,since,4,2;public,void,set,case,sensitive,boolean,case,sensitive,this,case,sensitive,case,sensitive
AntPathMatcher -> public void setCaseSensitive(boolean caseSensitive);1496837955;Specify whether to perform pattern matching in a case-sensitive fashion._<p>Default is {@code true}. Switch this to {@code false} for case-insensitive matching._@since 4.2;public void setCaseSensitive(boolean caseSensitive) {_		this.caseSensitive = caseSensitive__	};specify,whether,to,perform,pattern,matching,in,a,case,sensitive,fashion,p,default,is,code,true,switch,this,to,code,false,for,case,insensitive,matching,since,4,2;public,void,set,case,sensitive,boolean,case,sensitive,this,case,sensitive,case,sensitive
AntPathMatcher -> public void setCaseSensitive(boolean caseSensitive);1498780456;Specify whether to perform pattern matching in a case-sensitive fashion._<p>Default is {@code true}. Switch this to {@code false} for case-insensitive matching._@since 4.2;public void setCaseSensitive(boolean caseSensitive) {_		this.caseSensitive = caseSensitive__	};specify,whether,to,perform,pattern,matching,in,a,case,sensitive,fashion,p,default,is,code,true,switch,this,to,code,false,for,case,insensitive,matching,since,4,2;public,void,set,case,sensitive,boolean,case,sensitive,this,case,sensitive,case,sensitive
AntPathMatcher -> public void setCaseSensitive(boolean caseSensitive);1518772998;Specify whether to perform pattern matching in a case-sensitive fashion._<p>Default is {@code true}. Switch this to {@code false} for case-insensitive matching._@since 4.2;public void setCaseSensitive(boolean caseSensitive) {_		this.caseSensitive = caseSensitive__	};specify,whether,to,perform,pattern,matching,in,a,case,sensitive,fashion,p,default,is,code,true,switch,this,to,code,false,for,case,insensitive,matching,since,4,2;public,void,set,case,sensitive,boolean,case,sensitive,this,case,sensitive,case,sensitive
AntPathMatcher -> public void setCaseSensitive(boolean caseSensitive);1530174524;Specify whether to perform pattern matching in a case-sensitive fashion._<p>Default is {@code true}. Switch this to {@code false} for case-insensitive matching._@since 4.2;public void setCaseSensitive(boolean caseSensitive) {_		this.caseSensitive = caseSensitive__	};specify,whether,to,perform,pattern,matching,in,a,case,sensitive,fashion,p,default,is,code,true,switch,this,to,code,false,for,case,insensitive,matching,since,4,2;public,void,set,case,sensitive,boolean,case,sensitive,this,case,sensitive,case,sensitive
AntPathMatcher -> public void setCaseSensitive(boolean caseSensitive);1530174524;Specify whether to perform pattern matching in a case-sensitive fashion._<p>Default is {@code true}. Switch this to {@code false} for case-insensitive matching._@since 4.2;public void setCaseSensitive(boolean caseSensitive) {_		this.caseSensitive = caseSensitive__	};specify,whether,to,perform,pattern,matching,in,a,case,sensitive,fashion,p,default,is,code,true,switch,this,to,code,false,for,case,insensitive,matching,since,4,2;public,void,set,case,sensitive,boolean,case,sensitive,this,case,sensitive,case,sensitive
AntPathMatcher -> public void setCaseSensitive(boolean caseSensitive);1535316501;Specify whether to perform pattern matching in a case-sensitive fashion._<p>Default is {@code true}. Switch this to {@code false} for case-insensitive matching._@since 4.2;public void setCaseSensitive(boolean caseSensitive) {_		this.caseSensitive = caseSensitive__	};specify,whether,to,perform,pattern,matching,in,a,case,sensitive,fashion,p,default,is,code,true,switch,this,to,code,false,for,case,insensitive,matching,since,4,2;public,void,set,case,sensitive,boolean,case,sensitive,this,case,sensitive,case,sensitive
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, 			@Nullable Map<String, String> uriTemplateVariables);1496837955;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch,_			@Nullable Map<String, String> uriTemplateVariables) {__		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = tokenizePattern(pattern)__		if (fullMatch && this.caseSensitive && !isPotentialMatch(path, pattDirs)) {_			return false__		}__		String[] pathDirs = tokenizePath(path)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxStart]__			if ("**".equals(pattDir)) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) == path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxEnd]__			if (pattDir.equals("**")) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,nullable,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,tokenize,pattern,pattern,if,full,match,this,case,sensitive,is,potential,match,path,patt,dirs,return,false,string,path,dirs,tokenize,path,path,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,start,if,equals,patt,dir,break,if,match,strings,patt,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,end,if,patt,dir,equals,break,if,match,strings,patt,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, 			@Nullable Map<String, String> uriTemplateVariables);1498780456;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch,_			@Nullable Map<String, String> uriTemplateVariables) {__		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = tokenizePattern(pattern)__		if (fullMatch && this.caseSensitive && !isPotentialMatch(path, pattDirs)) {_			return false__		}__		String[] pathDirs = tokenizePath(path)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxStart]__			if ("**".equals(pattDir)) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) == path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxEnd]__			if (pattDir.equals("**")) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,nullable,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,tokenize,pattern,pattern,if,full,match,this,case,sensitive,is,potential,match,path,patt,dirs,return,false,string,path,dirs,tokenize,path,path,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,start,if,equals,patt,dir,break,if,match,strings,patt,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,end,if,patt,dir,equals,break,if,match,strings,patt,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, 			@Nullable Map<String, String> uriTemplateVariables);1518772998;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch,_			@Nullable Map<String, String> uriTemplateVariables) {__		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = tokenizePattern(pattern)__		if (fullMatch && this.caseSensitive && !isPotentialMatch(path, pattDirs)) {_			return false__		}__		String[] pathDirs = tokenizePath(path)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxStart]__			if ("**".equals(pattDir)) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) == path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxEnd]__			if (pattDir.equals("**")) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,nullable,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,tokenize,pattern,pattern,if,full,match,this,case,sensitive,is,potential,match,path,patt,dirs,return,false,string,path,dirs,tokenize,path,path,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,start,if,equals,patt,dir,break,if,match,strings,patt,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,end,if,patt,dir,equals,break,if,match,strings,patt,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, 			@Nullable Map<String, String> uriTemplateVariables);1530174524;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch,_			@Nullable Map<String, String> uriTemplateVariables) {__		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = tokenizePattern(pattern)__		if (fullMatch && this.caseSensitive && !isPotentialMatch(path, pattDirs)) {_			return false__		}__		String[] pathDirs = tokenizePath(path)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxStart]__			if ("**".equals(pattDir)) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) == path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxEnd]__			if (pattDir.equals("**")) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,nullable,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,tokenize,pattern,pattern,if,full,match,this,case,sensitive,is,potential,match,path,patt,dirs,return,false,string,path,dirs,tokenize,path,path,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,start,if,equals,patt,dir,break,if,match,strings,patt,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,end,if,patt,dir,equals,break,if,match,strings,patt,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, 			@Nullable Map<String, String> uriTemplateVariables);1530174524;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch,_			@Nullable Map<String, String> uriTemplateVariables) {__		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = tokenizePattern(pattern)__		if (fullMatch && this.caseSensitive && !isPotentialMatch(path, pattDirs)) {_			return false__		}__		String[] pathDirs = tokenizePath(path)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxStart]__			if ("**".equals(pattDir)) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) == path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxEnd]__			if (pattDir.equals("**")) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,nullable,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,tokenize,pattern,pattern,if,full,match,this,case,sensitive,is,potential,match,path,patt,dirs,return,false,string,path,dirs,tokenize,path,path,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,start,if,equals,patt,dir,break,if,match,strings,patt,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,end,if,patt,dir,equals,break,if,match,strings,patt,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, 			@Nullable Map<String, String> uriTemplateVariables);1535316501;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch,_			@Nullable Map<String, String> uriTemplateVariables) {__		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = tokenizePattern(pattern)__		if (fullMatch && this.caseSensitive && !isPotentialMatch(path, pattDirs)) {_			return false__		}__		String[] pathDirs = tokenizePath(path)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxStart]__			if ("**".equals(pattDir)) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) == path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String pattDir = pattDirs[pattIdxEnd]__			if (pattDir.equals("**")) {_				break__			}_			if (!matchStrings(pattDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,nullable,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,tokenize,pattern,pattern,if,full,match,this,case,sensitive,is,potential,match,path,patt,dirs,return,false,string,path,dirs,tokenize,path,path,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,start,if,equals,patt,dir,break,if,match,strings,patt,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,patt,dir,patt,dirs,patt,idx,end,if,patt,dir,equals,break,if,match,strings,patt,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);1328020251;Tests whether or not a string matches against a pattern. The pattern may contain two special characters:<br> '*'_means zero or more characters<br> '?' means one and only one character_@param pattern pattern to match against. Must not be <code>null</code>._@param str string which must be matched against the pattern. Must not be <code>null</code>._@return <code>true</code> if the string matches against the pattern, or <code>false</code> otherwise.;private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {_		AntPathStringMatcher matcher = new AntPathStringMatcher(pattern, str, uriTemplateVariables)__		return matcher.matchStrings()__	};tests,whether,or,not,a,string,matches,against,a,pattern,the,pattern,may,contain,two,special,characters,br,means,zero,or,more,characters,br,means,one,and,only,one,character,param,pattern,pattern,to,match,against,must,not,be,code,null,code,param,str,string,which,must,be,matched,against,the,pattern,must,not,be,code,null,code,return,code,true,code,if,the,string,matches,against,the,pattern,or,code,false,code,otherwise;private,boolean,match,strings,string,pattern,string,str,map,string,string,uri,template,variables,ant,path,string,matcher,matcher,new,ant,path,string,matcher,pattern,str,uri,template,variables,return,matcher,match,strings
AntPathMatcher -> private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);1333393580;Tests whether or not a string matches against a pattern. The pattern may contain two special characters:<br> '*'_means zero or more characters<br> '?' means one and only one character_@param pattern pattern to match against. Must not be <code>null</code>._@param str string which must be matched against the pattern. Must not be <code>null</code>._@return <code>true</code> if the string matches against the pattern, or <code>false</code> otherwise.;private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {_		AntPathStringMatcher matcher = new AntPathStringMatcher(pattern, str, uriTemplateVariables)__		return matcher.matchStrings()__	};tests,whether,or,not,a,string,matches,against,a,pattern,the,pattern,may,contain,two,special,characters,br,means,zero,or,more,characters,br,means,one,and,only,one,character,param,pattern,pattern,to,match,against,must,not,be,code,null,code,param,str,string,which,must,be,matched,against,the,pattern,must,not,be,code,null,code,return,code,true,code,if,the,string,matches,against,the,pattern,or,code,false,code,otherwise;private,boolean,match,strings,string,pattern,string,str,map,string,string,uri,template,variables,ant,path,string,matcher,matcher,new,ant,path,string,matcher,pattern,str,uri,template,variables,return,matcher,match,strings
AntPathMatcher -> private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);1347310630;Tests whether or not a string matches against a pattern. The pattern may contain two special characters:<br> '*'_means zero or more characters<br> '?' means one and only one character_@param pattern pattern to match against. Must not be <code>null</code>._@param str string which must be matched against the pattern. Must not be <code>null</code>._@return <code>true</code> if the string matches against the pattern, or <code>false</code> otherwise.;private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {_		AntPathStringMatcher matcher = this.stringMatcherCache.get(pattern)__		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern)__			this.stringMatcherCache.put(pattern, matcher)__		}_		return matcher.matchStrings(str, uriTemplateVariables)__	};tests,whether,or,not,a,string,matches,against,a,pattern,the,pattern,may,contain,two,special,characters,br,means,zero,or,more,characters,br,means,one,and,only,one,character,param,pattern,pattern,to,match,against,must,not,be,code,null,code,param,str,string,which,must,be,matched,against,the,pattern,must,not,be,code,null,code,return,code,true,code,if,the,string,matches,against,the,pattern,or,code,false,code,otherwise;private,boolean,match,strings,string,pattern,string,str,map,string,string,uri,template,variables,ant,path,string,matcher,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,this,string,matcher,cache,put,pattern,matcher,return,matcher,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);1355351965;Tests whether or not a string matches against a pattern. The pattern may contain two special characters:_<br>'*' means zero or more characters_<br>'?' means one and only one character_@param pattern pattern to match against. Must not be <code>null</code>._@param str string which must be matched against the pattern. Must not be <code>null</code>._@return <code>true</code> if the string matches against the pattern, or <code>false</code> otherwise.;private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {_		AntPathStringMatcher matcher = this.stringMatcherCache.get(pattern)__		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern)__			this.stringMatcherCache.put(pattern, matcher)__		}_		return matcher.matchStrings(str, uriTemplateVariables)__	};tests,whether,or,not,a,string,matches,against,a,pattern,the,pattern,may,contain,two,special,characters,br,means,zero,or,more,characters,br,means,one,and,only,one,character,param,pattern,pattern,to,match,against,must,not,be,code,null,code,param,str,string,which,must,be,matched,against,the,pattern,must,not,be,code,null,code,return,code,true,code,if,the,string,matches,against,the,pattern,or,code,false,code,otherwise;private,boolean,match,strings,string,pattern,string,str,map,string,string,uri,template,variables,ant,path,string,matcher,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,this,string,matcher,cache,put,pattern,matcher,return,matcher,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);1356735495;Tests whether or not a string matches against a pattern. The pattern may contain two special characters:_<br>'*' means zero or more characters_<br>'?' means one and only one character_@param pattern pattern to match against. Must not be {@code null}._@param str string which must be matched against the pattern. Must not be {@code null}._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {_		AntPathStringMatcher matcher = this.stringMatcherCache.get(pattern)__		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern)__			this.stringMatcherCache.put(pattern, matcher)__		}_		return matcher.matchStrings(str, uriTemplateVariables)__	};tests,whether,or,not,a,string,matches,against,a,pattern,the,pattern,may,contain,two,special,characters,br,means,zero,or,more,characters,br,means,one,and,only,one,character,param,pattern,pattern,to,match,against,must,not,be,code,null,param,str,string,which,must,be,matched,against,the,pattern,must,not,be,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,map,string,string,uri,template,variables,ant,path,string,matcher,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,this,string,matcher,cache,put,pattern,matcher,return,matcher,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);1357119239;Tests whether or not a string matches against a pattern. The pattern may contain two special characters:_<br>'*' means zero or more characters_<br>'?' means one and only one character_@param pattern pattern to match against. Must not be {@code null}._@param str string which must be matched against the pattern. Must not be {@code null}._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {_		AntPathStringMatcher matcher = this.stringMatcherCache.get(pattern)__		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern)__			this.stringMatcherCache.put(pattern, matcher)__		}_		return matcher.matchStrings(str, uriTemplateVariables)__	};tests,whether,or,not,a,string,matches,against,a,pattern,the,pattern,may,contain,two,special,characters,br,means,zero,or,more,characters,br,means,one,and,only,one,character,param,pattern,pattern,to,match,against,must,not,be,code,null,param,str,string,which,must,be,matched,against,the,pattern,must,not,be,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,map,string,string,uri,template,variables,ant,path,string,matcher,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,this,string,matcher,cache,put,pattern,matcher,return,matcher,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);1362408075;Tests whether or not a string matches against a pattern. The pattern may contain two special characters:_<br>'*' means zero or more characters_<br>'?' means one and only one character_@param pattern pattern to match against. Must not be {@code null}._@param str string which must be matched against the pattern. Must not be {@code null}._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {_		AntPathStringMatcher matcher = this.stringMatcherCache.get(pattern)__		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern)__			this.stringMatcherCache.put(pattern, matcher)__		}_		return matcher.matchStrings(str, uriTemplateVariables)__	};tests,whether,or,not,a,string,matches,against,a,pattern,the,pattern,may,contain,two,special,characters,br,means,zero,or,more,characters,br,means,one,and,only,one,character,param,pattern,pattern,to,match,against,must,not,be,code,null,param,str,string,which,must,be,matched,against,the,pattern,must,not,be,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,map,string,string,uri,template,variables,ant,path,string,matcher,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,this,string,matcher,cache,put,pattern,matcher,return,matcher,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);1368482696;Tests whether or not a string matches against a pattern. The pattern may contain two special characters:_<br>'*' means zero or more characters_<br>'?' means one and only one character_@param pattern pattern to match against. Must not be {@code null}._@param str string which must be matched against the pattern. Must not be {@code null}._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {_		AntPathStringMatcher matcher = this.stringMatcherCache.get(pattern)__		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern)__			this.stringMatcherCache.put(pattern, matcher)__		}_		return matcher.matchStrings(str, uriTemplateVariables)__	};tests,whether,or,not,a,string,matches,against,a,pattern,the,pattern,may,contain,two,special,characters,br,means,zero,or,more,characters,br,means,one,and,only,one,character,param,pattern,pattern,to,match,against,must,not,be,code,null,param,str,string,which,must,be,matched,against,the,pattern,must,not,be,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,map,string,string,uri,template,variables,ant,path,string,matcher,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,this,string,matcher,cache,put,pattern,matcher,return,matcher,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);1377725408;Tests whether or not a string matches against a pattern. The pattern may contain two special characters:_<br>'*' means zero or more characters_<br>'?' means one and only one character_@param pattern pattern to match against. Must not be {@code null}._@param str string which must be matched against the pattern. Must not be {@code null}._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {_		AntPathStringMatcher matcher = this.stringMatcherCache.get(pattern)__		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern)__			this.stringMatcherCache.put(pattern, matcher)__		}_		return matcher.matchStrings(str, uriTemplateVariables)__	};tests,whether,or,not,a,string,matches,against,a,pattern,the,pattern,may,contain,two,special,characters,br,means,zero,or,more,characters,br,means,one,and,only,one,character,param,pattern,pattern,to,match,against,must,not,be,code,null,param,str,string,which,must,be,matched,against,the,pattern,must,not,be,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,map,string,string,uri,template,variables,ant,path,string,matcher,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,this,string,matcher,cache,put,pattern,matcher,return,matcher,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);1377735685;Tests whether or not a string matches against a pattern. The pattern may contain two special characters:_<br>'*' means zero or more characters_<br>'?' means one and only one character_@param pattern pattern to match against. Must not be {@code null}._@param str string which must be matched against the pattern. Must not be {@code null}._@return {@code true} if the string matches against the pattern, or {@code false} otherwise.;private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {_		AntPathStringMatcher matcher = this.stringMatcherCache.get(pattern)__		if (matcher == null) {_			matcher = new AntPathStringMatcher(pattern)__			this.stringMatcherCache.put(pattern, matcher)__		}_		return matcher.matchStrings(str, uriTemplateVariables)__	};tests,whether,or,not,a,string,matches,against,a,pattern,the,pattern,may,contain,two,special,characters,br,means,zero,or,more,characters,br,means,one,and,only,one,character,param,pattern,pattern,to,match,against,must,not,be,code,null,param,str,string,which,must,be,matched,against,the,pattern,must,not,be,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,map,string,string,uri,template,variables,ant,path,string,matcher,matcher,this,string,matcher,cache,get,pattern,if,matcher,null,matcher,new,ant,path,string,matcher,pattern,this,string,matcher,cache,put,pattern,matcher,return,matcher,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);1383090798;Tests whether or not a string matches against a pattern._@param pattern the pattern to match against (never {@code null})_@param str the String which must be matched against the pattern (never {@code null})_@return {@code true} if the string matches against the pattern, or {@code false} otherwise;private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {_		return getStringMatcher(pattern).matchStrings(str, uriTemplateVariables)__	};tests,whether,or,not,a,string,matches,against,a,pattern,param,pattern,the,pattern,to,match,against,never,code,null,param,str,the,string,which,must,be,matched,against,the,pattern,never,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,map,string,string,uri,template,variables,return,get,string,matcher,pattern,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);1383157688;Tests whether or not a string matches against a pattern._@param pattern the pattern to match against (never {@code null})_@param str the String which must be matched against the pattern (never {@code null})_@return {@code true} if the string matches against the pattern, or {@code false} otherwise;private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {_		return getStringMatcher(pattern).matchStrings(str, uriTemplateVariables)__	};tests,whether,or,not,a,string,matches,against,a,pattern,param,pattern,the,pattern,to,match,against,never,code,null,param,str,the,string,which,must,be,matched,against,the,pattern,never,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,map,string,string,uri,template,variables,return,get,string,matcher,pattern,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);1385501137;Tests whether or not a string matches against a pattern._@param pattern the pattern to match against (never {@code null})_@param str the String which must be matched against the pattern (never {@code null})_@return {@code true} if the string matches against the pattern, or {@code false} otherwise;private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {_		return getStringMatcher(pattern).matchStrings(str, uriTemplateVariables)__	};tests,whether,or,not,a,string,matches,against,a,pattern,param,pattern,the,pattern,to,match,against,never,code,null,param,str,the,string,which,must,be,matched,against,the,pattern,never,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,map,string,string,uri,template,variables,return,get,string,matcher,pattern,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);1388766826;Tests whether or not a string matches against a pattern._@param pattern the pattern to match against (never {@code null})_@param str the String which must be matched against the pattern (never {@code null})_@return {@code true} if the string matches against the pattern, or {@code false} otherwise;private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {_		return getStringMatcher(pattern).matchStrings(str, uriTemplateVariables)__	};tests,whether,or,not,a,string,matches,against,a,pattern,param,pattern,the,pattern,to,match,against,never,code,null,param,str,the,string,which,must,be,matched,against,the,pattern,never,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,map,string,string,uri,template,variables,return,get,string,matcher,pattern,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);1402512669;Tests whether or not a string matches against a pattern._@param pattern the pattern to match against (never {@code null})_@param str the String which must be matched against the pattern (never {@code null})_@return {@code true} if the string matches against the pattern, or {@code false} otherwise;private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {_		return getStringMatcher(pattern).matchStrings(str, uriTemplateVariables)__	};tests,whether,or,not,a,string,matches,against,a,pattern,param,pattern,the,pattern,to,match,against,never,code,null,param,str,the,string,which,must,be,matched,against,the,pattern,never,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,map,string,string,uri,template,variables,return,get,string,matcher,pattern,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);1402512669;Tests whether or not a string matches against a pattern._@param pattern the pattern to match against (never {@code null})_@param str the String which must be matched against the pattern (never {@code null})_@return {@code true} if the string matches against the pattern, or {@code false} otherwise;private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {_		return getStringMatcher(pattern).matchStrings(str, uriTemplateVariables)__	};tests,whether,or,not,a,string,matches,against,a,pattern,param,pattern,the,pattern,to,match,against,never,code,null,param,str,the,string,which,must,be,matched,against,the,pattern,never,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,map,string,string,uri,template,variables,return,get,string,matcher,pattern,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);1402512669;Tests whether or not a string matches against a pattern._@param pattern the pattern to match against (never {@code null})_@param str the String which must be matched against the pattern (never {@code null})_@return {@code true} if the string matches against the pattern, or {@code false} otherwise;private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {_		return getStringMatcher(pattern).matchStrings(str, uriTemplateVariables)__	};tests,whether,or,not,a,string,matches,against,a,pattern,param,pattern,the,pattern,to,match,against,never,code,null,param,str,the,string,which,must,be,matched,against,the,pattern,never,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,map,string,string,uri,template,variables,return,get,string,matcher,pattern,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);1405378164;Tests whether or not a string matches against a pattern._@param pattern the pattern to match against (never {@code null})_@param str the String which must be matched against the pattern (never {@code null})_@return {@code true} if the string matches against the pattern, or {@code false} otherwise;private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {_		return getStringMatcher(pattern).matchStrings(str, uriTemplateVariables)__	};tests,whether,or,not,a,string,matches,against,a,pattern,param,pattern,the,pattern,to,match,against,never,code,null,param,str,the,string,which,must,be,matched,against,the,pattern,never,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,map,string,string,uri,template,variables,return,get,string,matcher,pattern,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);1405378165;Tests whether or not a string matches against a pattern._@param pattern the pattern to match against (never {@code null})_@param str the String which must be matched against the pattern (never {@code null})_@return {@code true} if the string matches against the pattern, or {@code false} otherwise;private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {_		return getStringMatcher(pattern).matchStrings(str, uriTemplateVariables)__	};tests,whether,or,not,a,string,matches,against,a,pattern,param,pattern,the,pattern,to,match,against,never,code,null,param,str,the,string,which,must,be,matched,against,the,pattern,never,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,map,string,string,uri,template,variables,return,get,string,matcher,pattern,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);1405696918;Tests whether or not a string matches against a pattern._@param pattern the pattern to match against (never {@code null})_@param str the String which must be matched against the pattern (never {@code null})_@return {@code true} if the string matches against the pattern, or {@code false} otherwise;private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {_		return getStringMatcher(pattern).matchStrings(str, uriTemplateVariables)__	};tests,whether,or,not,a,string,matches,against,a,pattern,param,pattern,the,pattern,to,match,against,never,code,null,param,str,the,string,which,must,be,matched,against,the,pattern,never,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,map,string,string,uri,template,variables,return,get,string,matcher,pattern,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);1409784938;Tests whether or not a string matches against a pattern._@param pattern the pattern to match against (never {@code null})_@param str the String which must be matched against the pattern (never {@code null})_@return {@code true} if the string matches against the pattern, or {@code false} otherwise;private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {_		return getStringMatcher(pattern).matchStrings(str, uriTemplateVariables)__	};tests,whether,or,not,a,string,matches,against,a,pattern,param,pattern,the,pattern,to,match,against,never,code,null,param,str,the,string,which,must,be,matched,against,the,pattern,never,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,map,string,string,uri,template,variables,return,get,string,matcher,pattern,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);1412083966;Tests whether or not a string matches against a pattern._@param pattern the pattern to match against (never {@code null})_@param str the String which must be matched against the pattern (never {@code null})_@return {@code true} if the string matches against the pattern, or {@code false} otherwise;private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {_		return getStringMatcher(pattern).matchStrings(str, uriTemplateVariables)__	};tests,whether,or,not,a,string,matches,against,a,pattern,param,pattern,the,pattern,to,match,against,never,code,null,param,str,the,string,which,must,be,matched,against,the,pattern,never,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,map,string,string,uri,template,variables,return,get,string,matcher,pattern,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);1412101078;Tests whether or not a string matches against a pattern._@param pattern the pattern to match against (never {@code null})_@param str the String which must be matched against the pattern (never {@code null})_@return {@code true} if the string matches against the pattern, or {@code false} otherwise;private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {_		return getStringMatcher(pattern).matchStrings(str, uriTemplateVariables)__	};tests,whether,or,not,a,string,matches,against,a,pattern,param,pattern,the,pattern,to,match,against,never,code,null,param,str,the,string,which,must,be,matched,against,the,pattern,never,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,map,string,string,uri,template,variables,return,get,string,matcher,pattern,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);1431086052;Test whether or not a string matches against a pattern._@param pattern the pattern to match against (never {@code null})_@param str the String which must be matched against the pattern (never {@code null})_@return {@code true} if the string matches against the pattern, or {@code false} otherwise;private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {_		return getStringMatcher(pattern).matchStrings(str, uriTemplateVariables)__	};test,whether,or,not,a,string,matches,against,a,pattern,param,pattern,the,pattern,to,match,against,never,code,null,param,str,the,string,which,must,be,matched,against,the,pattern,never,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,map,string,string,uri,template,variables,return,get,string,matcher,pattern,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);1431178173;Test whether or not a string matches against a pattern._@param pattern the pattern to match against (never {@code null})_@param str the String which must be matched against the pattern (never {@code null})_@return {@code true} if the string matches against the pattern, or {@code false} otherwise;private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {_		return getStringMatcher(pattern).matchStrings(str, uriTemplateVariables)__	};test,whether,or,not,a,string,matches,against,a,pattern,param,pattern,the,pattern,to,match,against,never,code,null,param,str,the,string,which,must,be,matched,against,the,pattern,never,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,map,string,string,uri,template,variables,return,get,string,matcher,pattern,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);1434572159;Test whether or not a string matches against a pattern._@param pattern the pattern to match against (never {@code null})_@param str the String which must be matched against the pattern (never {@code null})_@return {@code true} if the string matches against the pattern, or {@code false} otherwise;private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {_		return getStringMatcher(pattern).matchStrings(str, uriTemplateVariables)__	};test,whether,or,not,a,string,matches,against,a,pattern,param,pattern,the,pattern,to,match,against,never,code,null,param,str,the,string,which,must,be,matched,against,the,pattern,never,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,map,string,string,uri,template,variables,return,get,string,matcher,pattern,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);1435239719;Test whether or not a string matches against a pattern._@param pattern the pattern to match against (never {@code null})_@param str the String which must be matched against the pattern (never {@code null})_@return {@code true} if the string matches against the pattern, or {@code false} otherwise;private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {_		return getStringMatcher(pattern).matchStrings(str, uriTemplateVariables)__	};test,whether,or,not,a,string,matches,against,a,pattern,param,pattern,the,pattern,to,match,against,never,code,null,param,str,the,string,which,must,be,matched,against,the,pattern,never,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,map,string,string,uri,template,variables,return,get,string,matcher,pattern,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);1438166321;Test whether or not a string matches against a pattern._@param pattern the pattern to match against (never {@code null})_@param str the String which must be matched against the pattern (never {@code null})_@return {@code true} if the string matches against the pattern, or {@code false} otherwise;private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {_		return getStringMatcher(pattern).matchStrings(str, uriTemplateVariables)__	};test,whether,or,not,a,string,matches,against,a,pattern,param,pattern,the,pattern,to,match,against,never,code,null,param,str,the,string,which,must,be,matched,against,the,pattern,never,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,map,string,string,uri,template,variables,return,get,string,matcher,pattern,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);1455100778;Test whether or not a string matches against a pattern._@param pattern the pattern to match against (never {@code null})_@param str the String which must be matched against the pattern (never {@code null})_@return {@code true} if the string matches against the pattern, or {@code false} otherwise;private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {_		return getStringMatcher(pattern).matchStrings(str, uriTemplateVariables)__	};test,whether,or,not,a,string,matches,against,a,pattern,param,pattern,the,pattern,to,match,against,never,code,null,param,str,the,string,which,must,be,matched,against,the,pattern,never,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,map,string,string,uri,template,variables,return,get,string,matcher,pattern,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);1455850198;Test whether or not a string matches against a pattern._@param pattern the pattern to match against (never {@code null})_@param str the String which must be matched against the pattern (never {@code null})_@return {@code true} if the string matches against the pattern, or {@code false} otherwise;private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {_		return getStringMatcher(pattern).matchStrings(str, uriTemplateVariables)__	};test,whether,or,not,a,string,matches,against,a,pattern,param,pattern,the,pattern,to,match,against,never,code,null,param,str,the,string,which,must,be,matched,against,the,pattern,never,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,map,string,string,uri,template,variables,return,get,string,matcher,pattern,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);1460754629;Test whether or not a string matches against a pattern._@param pattern the pattern to match against (never {@code null})_@param str the String which must be matched against the pattern (never {@code null})_@return {@code true} if the string matches against the pattern, or {@code false} otherwise;private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {_		return getStringMatcher(pattern).matchStrings(str, uriTemplateVariables)__	};test,whether,or,not,a,string,matches,against,a,pattern,param,pattern,the,pattern,to,match,against,never,code,null,param,str,the,string,which,must,be,matched,against,the,pattern,never,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,map,string,string,uri,template,variables,return,get,string,matcher,pattern,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);1462393686;Test whether or not a string matches against a pattern._@param pattern the pattern to match against (never {@code null})_@param str the String which must be matched against the pattern (never {@code null})_@return {@code true} if the string matches against the pattern, or {@code false} otherwise;private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {_		return getStringMatcher(pattern).matchStrings(str, uriTemplateVariables)__	};test,whether,or,not,a,string,matches,against,a,pattern,param,pattern,the,pattern,to,match,against,never,code,null,param,str,the,string,which,must,be,matched,against,the,pattern,never,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,map,string,string,uri,template,variables,return,get,string,matcher,pattern,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);1467730834;Test whether or not a string matches against a pattern._@param pattern the pattern to match against (never {@code null})_@param str the String which must be matched against the pattern (never {@code null})_@return {@code true} if the string matches against the pattern, or {@code false} otherwise;private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {_		return getStringMatcher(pattern).matchStrings(str, uriTemplateVariables)__	};test,whether,or,not,a,string,matches,against,a,pattern,param,pattern,the,pattern,to,match,against,never,code,null,param,str,the,string,which,must,be,matched,against,the,pattern,never,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,map,string,string,uri,template,variables,return,get,string,matcher,pattern,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);1468327638;Test whether or not a string matches against a pattern._@param pattern the pattern to match against (never {@code null})_@param str the String which must be matched against the pattern (never {@code null})_@return {@code true} if the string matches against the pattern, or {@code false} otherwise;private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {_		return getStringMatcher(pattern).matchStrings(str, uriTemplateVariables)__	};test,whether,or,not,a,string,matches,against,a,pattern,param,pattern,the,pattern,to,match,against,never,code,null,param,str,the,string,which,must,be,matched,against,the,pattern,never,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,map,string,string,uri,template,variables,return,get,string,matcher,pattern,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);1472808958;Test whether or not a string matches against a pattern._@param pattern the pattern to match against (never {@code null})_@param str the String which must be matched against the pattern (never {@code null})_@return {@code true} if the string matches against the pattern, or {@code false} otherwise;private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {_		return getStringMatcher(pattern).matchStrings(str, uriTemplateVariables)__	};test,whether,or,not,a,string,matches,against,a,pattern,param,pattern,the,pattern,to,match,against,never,code,null,param,str,the,string,which,must,be,matched,against,the,pattern,never,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,map,string,string,uri,template,variables,return,get,string,matcher,pattern,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);1493317597;Test whether or not a string matches against a pattern._@param pattern the pattern to match against (never {@code null})_@param str the String which must be matched against the pattern (never {@code null})_@return {@code true} if the string matches against the pattern, or {@code false} otherwise;private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {_		return getStringMatcher(pattern).matchStrings(str, uriTemplateVariables)__	};test,whether,or,not,a,string,matches,against,a,pattern,param,pattern,the,pattern,to,match,against,never,code,null,param,str,the,string,which,must,be,matched,against,the,pattern,never,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,map,string,string,uri,template,variables,return,get,string,matcher,pattern,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);1493321510;Test whether or not a string matches against a pattern._@param pattern the pattern to match against (never {@code null})_@param str the String which must be matched against the pattern (never {@code null})_@return {@code true} if the string matches against the pattern, or {@code false} otherwise;private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {_		return getStringMatcher(pattern).matchStrings(str, uriTemplateVariables)__	};test,whether,or,not,a,string,matches,against,a,pattern,param,pattern,the,pattern,to,match,against,never,code,null,param,str,the,string,which,must,be,matched,against,the,pattern,never,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,map,string,string,uri,template,variables,return,get,string,matcher,pattern,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);1496259743;Test whether or not a string matches against a pattern._@param pattern the pattern to match against (never {@code null})_@param str the String which must be matched against the pattern (never {@code null})_@return {@code true} if the string matches against the pattern, or {@code false} otherwise;private boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {_		return getStringMatcher(pattern).matchStrings(str, uriTemplateVariables)__	};test,whether,or,not,a,string,matches,against,a,pattern,param,pattern,the,pattern,to,match,against,never,code,null,param,str,the,string,which,must,be,matched,against,the,pattern,never,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,map,string,string,uri,template,variables,return,get,string,matcher,pattern,match,strings,str,uri,template,variables
AntPathMatcher -> @Override 	public String combine(String pattern1, String pattern2);1356735495;Combines two patterns into a new pattern that is returned._<p>This implementation simply concatenates the two patterns, unless the first pattern_contains a file extension match (such as {@code *.html}. In that case, the second pattern_should be included in the first, or an {@code IllegalArgumentException} is thrown._<p>For example: <table>_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr> <tr><td>/hotels</td><td>{@code_null}</td><td>/hotels</td></tr> <tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr> <tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr> <tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>IllegalArgumentException</td></tr> </table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException when the two patterns cannot be combined;@Override_	public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		else if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		else if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}_		else if (!pattern1.equals(pattern2) && !pattern1.contains("{") && match(pattern1, pattern2)) {_			_			_			return pattern2__		}_		else if (pattern1.endsWith("/*")) {_			if (pattern2.startsWith("/")) {_				_				return pattern1.substring(0, pattern1.length() - 1) + pattern2.substring(1)__			}_			else {_				_				return pattern1.substring(0, pattern1.length() - 1) + pattern2__			}_		}_		else if (pattern1.endsWith("/**")) {_			if (pattern2.startsWith("/")) {_				_				return pattern1 + pattern2__			}_			else {_				_				return pattern1 + "/" + pattern2__			}_		}_		else {_			int dotPos1 = pattern1.indexOf('.')__			if (dotPos1 == -1) {_				_				if (pattern1.endsWith("/") || pattern2.startsWith("/")) {_					return pattern1 + pattern2__				}_				else {_					return pattern1 + "/" + pattern2__				}_			}_			String fileName1 = pattern1.substring(0, dotPos1)__			String extension1 = pattern1.substring(dotPos1)__			String fileName2__			String extension2__			int dotPos2 = pattern2.indexOf('.')__			if (dotPos2 != -1) {_				fileName2 = pattern2.substring(0, dotPos2)__				extension2 = pattern2.substring(dotPos2)__			}_			else {_				fileName2 = pattern2__				extension2 = ""__			}_			String fileName = fileName1.endsWith("*") ? fileName2 : fileName1__			String extension = extension1.startsWith("*") ? extension2 : extension1___			return fileName + extension__		}_	};combines,two,patterns,into,a,new,pattern,that,is,returned,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,such,as,code,html,in,that,case,the,second,pattern,should,be,included,in,the,first,or,an,code,illegal,argument,exception,is,thrown,p,for,example,table,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,when,the,two,patterns,cannot,be,combined;override,public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,else,if,string,utils,has,text,pattern1,return,pattern2,else,if,string,utils,has,text,pattern2,return,pattern1,else,if,pattern1,equals,pattern2,pattern1,contains,match,pattern1,pattern2,return,pattern2,else,if,pattern1,ends,with,if,pattern2,starts,with,return,pattern1,substring,0,pattern1,length,1,pattern2,substring,1,else,return,pattern1,substring,0,pattern1,length,1,pattern2,else,if,pattern1,ends,with,if,pattern2,starts,with,return,pattern1,pattern2,else,return,pattern1,pattern2,else,int,dot,pos1,pattern1,index,of,if,dot,pos1,1,if,pattern1,ends,with,pattern2,starts,with,return,pattern1,pattern2,else,return,pattern1,pattern2,string,file,name1,pattern1,substring,0,dot,pos1,string,extension1,pattern1,substring,dot,pos1,string,file,name2,string,extension2,int,dot,pos2,pattern2,index,of,if,dot,pos2,1,file,name2,pattern2,substring,0,dot,pos2,extension2,pattern2,substring,dot,pos2,else,file,name2,pattern2,extension2,string,file,name,file,name1,ends,with,file,name2,file,name1,string,extension,extension1,starts,with,extension2,extension1,return,file,name,extension
AntPathMatcher -> @Override 	public String combine(String pattern1, String pattern2);1368482696;Combines two patterns into a new pattern that is returned._<p>This implementation simply concatenates the two patterns, unless the first pattern_contains a file extension match (such as {@code *.html}. In that case, the second pattern_should be included in the first, or an {@code IllegalArgumentException} is thrown._<p>For example: <table>_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr> <tr><td>/hotels</td><td>{@code_null}</td><td>/hotels</td></tr> <tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr> <tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr> <tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>IllegalArgumentException</td></tr> </table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException when the two patterns cannot be combined;@Override_	public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		else if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		else if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}__		boolean pattern1ContainsUriVar = pattern1.indexOf('{') != -1__		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {_			_			_			return pattern2__		}_		else if (pattern1.endsWith("/*")) {_			if (pattern2.startsWith("/")) {_				_				return pattern1.substring(0, pattern1.length() - 1) + pattern2.substring(1)__			}_			else {_				_				return pattern1.substring(0, pattern1.length() - 1) + pattern2__			}_		}_		else if (pattern1.endsWith("/**")) {_			if (pattern2.startsWith("/")) {_				_				return pattern1 + pattern2__			}_			else {_				_				return pattern1 + "/" + pattern2__			}_		}_		else {_			int dotPos1 = pattern1.indexOf('.')__			if (dotPos1 == -1 || pattern1ContainsUriVar) {_				_				if (pattern1.endsWith("/") || pattern2.startsWith("/")) {_					return pattern1 + pattern2__				}_				else {_					return pattern1 + "/" + pattern2__				}_			}_			String fileName1 = pattern1.substring(0, dotPos1)__			String extension1 = pattern1.substring(dotPos1)__			String fileName2__			String extension2__			int dotPos2 = pattern2.indexOf('.')__			if (dotPos2 != -1) {_				fileName2 = pattern2.substring(0, dotPos2)__				extension2 = pattern2.substring(dotPos2)__			}_			else {_				fileName2 = pattern2__				extension2 = ""__			}_			String fileName = fileName1.endsWith("*") ? fileName2 : fileName1__			String extension = extension1.startsWith("*") ? extension2 : extension1___			return fileName + extension__		}_	};combines,two,patterns,into,a,new,pattern,that,is,returned,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,such,as,code,html,in,that,case,the,second,pattern,should,be,included,in,the,first,or,an,code,illegal,argument,exception,is,thrown,p,for,example,table,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,when,the,two,patterns,cannot,be,combined;override,public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,else,if,string,utils,has,text,pattern1,return,pattern2,else,if,string,utils,has,text,pattern2,return,pattern1,boolean,pattern1contains,uri,var,pattern1,index,of,1,if,pattern1,equals,pattern2,pattern1contains,uri,var,match,pattern1,pattern2,return,pattern2,else,if,pattern1,ends,with,if,pattern2,starts,with,return,pattern1,substring,0,pattern1,length,1,pattern2,substring,1,else,return,pattern1,substring,0,pattern1,length,1,pattern2,else,if,pattern1,ends,with,if,pattern2,starts,with,return,pattern1,pattern2,else,return,pattern1,pattern2,else,int,dot,pos1,pattern1,index,of,if,dot,pos1,1,pattern1contains,uri,var,if,pattern1,ends,with,pattern2,starts,with,return,pattern1,pattern2,else,return,pattern1,pattern2,string,file,name1,pattern1,substring,0,dot,pos1,string,extension1,pattern1,substring,dot,pos1,string,file,name2,string,extension2,int,dot,pos2,pattern2,index,of,if,dot,pos2,1,file,name2,pattern2,substring,0,dot,pos2,extension2,pattern2,substring,dot,pos2,else,file,name2,pattern2,extension2,string,file,name,file,name1,ends,with,file,name2,file,name1,string,extension,extension1,starts,with,extension2,extension1,return,file,name,extension
AntPathMatcher -> @Override 	public String combine(String pattern1, String pattern2);1377725408;Combines two patterns into a new pattern that is returned._<p>This implementation simply concatenates the two patterns, unless the first pattern_contains a file extension match (such as {@code *.html}. In that case, the second pattern_should be included in the first, or an {@code IllegalArgumentException} is thrown._<p>For example: <table>_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr> <tr><td>/hotels</td><td>{@code_null}</td><td>/hotels</td></tr> <tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr> <tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr> <tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>IllegalArgumentException</td></tr> </table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException when the two patterns cannot be combined;@Override_	public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}__		boolean pattern1ContainsUriVar = pattern1.indexOf('{') != -1__		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {_			_			_			return pattern2__		}__		_		_		if (pattern1.endsWith("/*")) {_			return slashConcat(pattern1.substring(0, pattern1.length() - 2), pattern2)__		}__		_		_		if (pattern1.endsWith("/**")) {_			return slashConcat(pattern1, pattern2)__		}__		int starDotPos1 = pattern1.indexOf("*.")__		if (pattern1ContainsUriVar || starDotPos1 == -1) {_			_			return slashConcat(pattern1, pattern2)__		}_		String extension1 = pattern1.substring(starDotPos1 + 1)__		int dotPos2 = pattern2.indexOf('.')__		String fileName2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2))__		String extension2 = (dotPos2 == -1 ? "" : pattern2.substring(dotPos2))__		String extension = extension1.startsWith("*") ? extension2 : extension1__		return fileName2 + extension__	};combines,two,patterns,into,a,new,pattern,that,is,returned,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,such,as,code,html,in,that,case,the,second,pattern,should,be,included,in,the,first,or,an,code,illegal,argument,exception,is,thrown,p,for,example,table,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,when,the,two,patterns,cannot,be,combined;override,public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,if,string,utils,has,text,pattern1,return,pattern2,if,string,utils,has,text,pattern2,return,pattern1,boolean,pattern1contains,uri,var,pattern1,index,of,1,if,pattern1,equals,pattern2,pattern1contains,uri,var,match,pattern1,pattern2,return,pattern2,if,pattern1,ends,with,return,slash,concat,pattern1,substring,0,pattern1,length,2,pattern2,if,pattern1,ends,with,return,slash,concat,pattern1,pattern2,int,star,dot,pos1,pattern1,index,of,if,pattern1contains,uri,var,star,dot,pos1,1,return,slash,concat,pattern1,pattern2,string,extension1,pattern1,substring,star,dot,pos1,1,int,dot,pos2,pattern2,index,of,string,file,name2,dot,pos2,1,pattern2,pattern2,substring,0,dot,pos2,string,extension2,dot,pos2,1,pattern2,substring,dot,pos2,string,extension,extension1,starts,with,extension2,extension1,return,file,name2,extension
AntPathMatcher -> @Override 	public String combine(String pattern1, String pattern2);1377735685;Combines two patterns into a new pattern that is returned._<p>This implementation simply concatenates the two patterns, unless the first pattern_contains a file extension match (such as {@code *.html}. In that case, the second pattern_should be included in the first, or an {@code IllegalArgumentException} is thrown._<p>For example: <table>_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr> <tr><td>/hotels</td><td>{@code_null}</td><td>/hotels</td></tr> <tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr> <tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr> <tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>IllegalArgumentException</td></tr> </table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException when the two patterns cannot be combined;@Override_	public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}__		boolean pattern1ContainsUriVar = pattern1.indexOf('{') != -1__		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {_			_			_			return pattern2__		}__		_		_		if (pattern1.endsWith("/*")) {_			return slashConcat(pattern1.substring(0, pattern1.length() - 2), pattern2)__		}__		_		_		if (pattern1.endsWith("/**")) {_			return slashConcat(pattern1, pattern2)__		}__		int starDotPos1 = pattern1.indexOf("*.")__		if (pattern1ContainsUriVar || starDotPos1 == -1) {_			_			return slashConcat(pattern1, pattern2)__		}_		String extension1 = pattern1.substring(starDotPos1 + 1)__		int dotPos2 = pattern2.indexOf('.')__		String fileName2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2))__		String extension2 = (dotPos2 == -1 ? "" : pattern2.substring(dotPos2))__		String extension = extension1.startsWith("*") ? extension2 : extension1__		return fileName2 + extension__	};combines,two,patterns,into,a,new,pattern,that,is,returned,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,such,as,code,html,in,that,case,the,second,pattern,should,be,included,in,the,first,or,an,code,illegal,argument,exception,is,thrown,p,for,example,table,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,when,the,two,patterns,cannot,be,combined;override,public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,if,string,utils,has,text,pattern1,return,pattern2,if,string,utils,has,text,pattern2,return,pattern1,boolean,pattern1contains,uri,var,pattern1,index,of,1,if,pattern1,equals,pattern2,pattern1contains,uri,var,match,pattern1,pattern2,return,pattern2,if,pattern1,ends,with,return,slash,concat,pattern1,substring,0,pattern1,length,2,pattern2,if,pattern1,ends,with,return,slash,concat,pattern1,pattern2,int,star,dot,pos1,pattern1,index,of,if,pattern1contains,uri,var,star,dot,pos1,1,return,slash,concat,pattern1,pattern2,string,extension1,pattern1,substring,star,dot,pos1,1,int,dot,pos2,pattern2,index,of,string,file,name2,dot,pos2,1,pattern2,pattern2,substring,0,dot,pos2,string,extension2,dot,pos2,1,pattern2,substring,dot,pos2,string,extension,extension1,starts,with,extension2,extension1,return,file,name2,extension
AntPathMatcher -> @Override 	public String combine(String pattern1, String pattern2);1383090798;Combines two patterns into a new pattern that is returned._<p>This implementation simply concatenates the two patterns, unless the first pattern_contains a file extension match (such as {@code *.html}. In that case, the second pattern_should be included in the first, or an {@code IllegalArgumentException} is thrown._<p>For example: <table>_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr> <tr><td>/hotels</td><td>{@code_null}</td><td>/hotels</td></tr> <tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr> <tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr> <tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>IllegalArgumentException</td></tr> </table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException when the two patterns cannot be combined;@Override_	public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}__		boolean pattern1ContainsUriVar = pattern1.indexOf('{') != -1__		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {_			_			_			return pattern2__		}__		_		_		if (pattern1.endsWith("/*")) {_			return slashConcat(pattern1.substring(0, pattern1.length() - 2), pattern2)__		}__		_		_		if (pattern1.endsWith("/**")) {_			return slashConcat(pattern1, pattern2)__		}__		int starDotPos1 = pattern1.indexOf("*.")__		if (pattern1ContainsUriVar || starDotPos1 == -1) {_			_			return slashConcat(pattern1, pattern2)__		}_		String extension1 = pattern1.substring(starDotPos1 + 1)__		int dotPos2 = pattern2.indexOf('.')__		String fileName2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2))__		String extension2 = (dotPos2 == -1 ? "" : pattern2.substring(dotPos2))__		String extension = extension1.startsWith("*") ? extension2 : extension1__		return fileName2 + extension__	};combines,two,patterns,into,a,new,pattern,that,is,returned,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,such,as,code,html,in,that,case,the,second,pattern,should,be,included,in,the,first,or,an,code,illegal,argument,exception,is,thrown,p,for,example,table,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,when,the,two,patterns,cannot,be,combined;override,public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,if,string,utils,has,text,pattern1,return,pattern2,if,string,utils,has,text,pattern2,return,pattern1,boolean,pattern1contains,uri,var,pattern1,index,of,1,if,pattern1,equals,pattern2,pattern1contains,uri,var,match,pattern1,pattern2,return,pattern2,if,pattern1,ends,with,return,slash,concat,pattern1,substring,0,pattern1,length,2,pattern2,if,pattern1,ends,with,return,slash,concat,pattern1,pattern2,int,star,dot,pos1,pattern1,index,of,if,pattern1contains,uri,var,star,dot,pos1,1,return,slash,concat,pattern1,pattern2,string,extension1,pattern1,substring,star,dot,pos1,1,int,dot,pos2,pattern2,index,of,string,file,name2,dot,pos2,1,pattern2,pattern2,substring,0,dot,pos2,string,extension2,dot,pos2,1,pattern2,substring,dot,pos2,string,extension,extension1,starts,with,extension2,extension1,return,file,name2,extension
AntPathMatcher -> @Override 	public String combine(String pattern1, String pattern2);1383157688;Combines two patterns into a new pattern that is returned._<p>This implementation simply concatenates the two patterns, unless the first pattern_contains a file extension match (such as {@code *.html}. In that case, the second pattern_should be included in the first, or an {@code IllegalArgumentException} is thrown._<p>For example: <table>_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr> <tr><td>/hotels</td><td>{@code_null}</td><td>/hotels</td></tr> <tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr> <tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr> <tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>IllegalArgumentException</td></tr> </table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException when the two patterns cannot be combined;@Override_	public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}__		boolean pattern1ContainsUriVar = pattern1.indexOf('{') != -1__		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {_			_			_			return pattern2__		}__		_		_		if (pattern1.endsWith("/*")) {_			return slashConcat(pattern1.substring(0, pattern1.length() - 2), pattern2)__		}__		_		_		if (pattern1.endsWith("/**")) {_			return slashConcat(pattern1, pattern2)__		}__		int starDotPos1 = pattern1.indexOf("*.")__		if (pattern1ContainsUriVar || starDotPos1 == -1) {_			_			return slashConcat(pattern1, pattern2)__		}_		String extension1 = pattern1.substring(starDotPos1 + 1)__		int dotPos2 = pattern2.indexOf('.')__		String fileName2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2))__		String extension2 = (dotPos2 == -1 ? "" : pattern2.substring(dotPos2))__		String extension = extension1.startsWith("*") ? extension2 : extension1__		return fileName2 + extension__	};combines,two,patterns,into,a,new,pattern,that,is,returned,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,such,as,code,html,in,that,case,the,second,pattern,should,be,included,in,the,first,or,an,code,illegal,argument,exception,is,thrown,p,for,example,table,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,when,the,two,patterns,cannot,be,combined;override,public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,if,string,utils,has,text,pattern1,return,pattern2,if,string,utils,has,text,pattern2,return,pattern1,boolean,pattern1contains,uri,var,pattern1,index,of,1,if,pattern1,equals,pattern2,pattern1contains,uri,var,match,pattern1,pattern2,return,pattern2,if,pattern1,ends,with,return,slash,concat,pattern1,substring,0,pattern1,length,2,pattern2,if,pattern1,ends,with,return,slash,concat,pattern1,pattern2,int,star,dot,pos1,pattern1,index,of,if,pattern1contains,uri,var,star,dot,pos1,1,return,slash,concat,pattern1,pattern2,string,extension1,pattern1,substring,star,dot,pos1,1,int,dot,pos2,pattern2,index,of,string,file,name2,dot,pos2,1,pattern2,pattern2,substring,0,dot,pos2,string,extension2,dot,pos2,1,pattern2,substring,dot,pos2,string,extension,extension1,starts,with,extension2,extension1,return,file,name2,extension
AntPathMatcher -> @Override 	public String combine(String pattern1, String pattern2);1385501137;Combines two patterns into a new pattern that is returned._<p>This implementation simply concatenates the two patterns, unless the first pattern_contains a file extension match (such as {@code *.html}. In that case, the second pattern_should be included in the first, or an {@code IllegalArgumentException} is thrown._<p>For example: <table>_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr> <tr><td>/hotels</td><td>{@code_null}</td><td>/hotels</td></tr> <tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr> <tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr> <tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>IllegalArgumentException</td></tr> </table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException when the two patterns cannot be combined;@Override_	public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}__		boolean pattern1ContainsUriVar = pattern1.indexOf('{') != -1__		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {_			_			_			return pattern2__		}__		_		_		if (pattern1.endsWith("/*")) {_			return slashConcat(pattern1.substring(0, pattern1.length() - 2), pattern2)__		}__		_		_		if (pattern1.endsWith("/**")) {_			return slashConcat(pattern1, pattern2)__		}__		int starDotPos1 = pattern1.indexOf("*.")__		if (pattern1ContainsUriVar || starDotPos1 == -1) {_			_			return slashConcat(pattern1, pattern2)__		}_		String extension1 = pattern1.substring(starDotPos1 + 1)__		int dotPos2 = pattern2.indexOf('.')__		String fileName2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2))__		String extension2 = (dotPos2 == -1 ? "" : pattern2.substring(dotPos2))__		String extension = extension1.startsWith("*") ? extension2 : extension1__		return fileName2 + extension__	};combines,two,patterns,into,a,new,pattern,that,is,returned,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,such,as,code,html,in,that,case,the,second,pattern,should,be,included,in,the,first,or,an,code,illegal,argument,exception,is,thrown,p,for,example,table,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,when,the,two,patterns,cannot,be,combined;override,public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,if,string,utils,has,text,pattern1,return,pattern2,if,string,utils,has,text,pattern2,return,pattern1,boolean,pattern1contains,uri,var,pattern1,index,of,1,if,pattern1,equals,pattern2,pattern1contains,uri,var,match,pattern1,pattern2,return,pattern2,if,pattern1,ends,with,return,slash,concat,pattern1,substring,0,pattern1,length,2,pattern2,if,pattern1,ends,with,return,slash,concat,pattern1,pattern2,int,star,dot,pos1,pattern1,index,of,if,pattern1contains,uri,var,star,dot,pos1,1,return,slash,concat,pattern1,pattern2,string,extension1,pattern1,substring,star,dot,pos1,1,int,dot,pos2,pattern2,index,of,string,file,name2,dot,pos2,1,pattern2,pattern2,substring,0,dot,pos2,string,extension2,dot,pos2,1,pattern2,substring,dot,pos2,string,extension,extension1,starts,with,extension2,extension1,return,file,name2,extension
AntPathMatcher -> @Override 	public String combine(String pattern1, String pattern2);1388766826;Combines two patterns into a new pattern that is returned._<p>This implementation simply concatenates the two patterns, unless the first pattern_contains a file extension match (such as {@code *.html}. In that case, the second pattern_should be included in the first, or an {@code IllegalArgumentException} is thrown._<p>For example: <table>_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr> <tr><td>/hotels</td><td>{@code_null}</td><td>/hotels</td></tr> <tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr> <tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr> <tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>IllegalArgumentException</td></tr> </table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException when the two patterns cannot be combined;@Override_	public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}__		boolean pattern1ContainsUriVar = pattern1.indexOf('{') != -1__		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {_			_			_			return pattern2__		}__		_		_		if (pattern1.endsWith("/*")) {_			return slashConcat(pattern1.substring(0, pattern1.length() - 2), pattern2)__		}__		_		_		if (pattern1.endsWith("/**")) {_			return slashConcat(pattern1, pattern2)__		}__		int starDotPos1 = pattern1.indexOf("*.")__		if (pattern1ContainsUriVar || starDotPos1 == -1) {_			_			return slashConcat(pattern1, pattern2)__		}_		String extension1 = pattern1.substring(starDotPos1 + 1)__		int dotPos2 = pattern2.indexOf('.')__		String fileName2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2))__		String extension2 = (dotPos2 == -1 ? "" : pattern2.substring(dotPos2))__		String extension = extension1.startsWith("*") ? extension2 : extension1__		return fileName2 + extension__	};combines,two,patterns,into,a,new,pattern,that,is,returned,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,such,as,code,html,in,that,case,the,second,pattern,should,be,included,in,the,first,or,an,code,illegal,argument,exception,is,thrown,p,for,example,table,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,when,the,two,patterns,cannot,be,combined;override,public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,if,string,utils,has,text,pattern1,return,pattern2,if,string,utils,has,text,pattern2,return,pattern1,boolean,pattern1contains,uri,var,pattern1,index,of,1,if,pattern1,equals,pattern2,pattern1contains,uri,var,match,pattern1,pattern2,return,pattern2,if,pattern1,ends,with,return,slash,concat,pattern1,substring,0,pattern1,length,2,pattern2,if,pattern1,ends,with,return,slash,concat,pattern1,pattern2,int,star,dot,pos1,pattern1,index,of,if,pattern1contains,uri,var,star,dot,pos1,1,return,slash,concat,pattern1,pattern2,string,extension1,pattern1,substring,star,dot,pos1,1,int,dot,pos2,pattern2,index,of,string,file,name2,dot,pos2,1,pattern2,pattern2,substring,0,dot,pos2,string,extension2,dot,pos2,1,pattern2,substring,dot,pos2,string,extension,extension1,starts,with,extension2,extension1,return,file,name2,extension
AntPathMatcher -> @Override 	public String combine(String pattern1, String pattern2);1402512669;Combines two patterns into a new pattern that is returned._<p>This implementation simply concatenates the two patterns, unless the first pattern_contains a file extension match (such as {@code *.html}. In that case, the second pattern_should be included in the first, or an {@code IllegalArgumentException} is thrown._<p>For example: <table>_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr> <tr><td>/hotels</td><td>{@code_null}</td><td>/hotels</td></tr> <tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr> <tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr> <tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>IllegalArgumentException</td></tr> </table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException when the two patterns cannot be combined;@Override_	public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}__		boolean pattern1ContainsUriVar = pattern1.indexOf('{') != -1__		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {_			_			_			return pattern2__		}__		_		_		if (pattern1.endsWith("/*")) {_			return slashConcat(pattern1.substring(0, pattern1.length() - 2), pattern2)__		}__		_		_		if (pattern1.endsWith("/**")) {_			return slashConcat(pattern1, pattern2)__		}__		int starDotPos1 = pattern1.indexOf("*.")__		if (pattern1ContainsUriVar || starDotPos1 == -1) {_			_			return slashConcat(pattern1, pattern2)__		}_		String extension1 = pattern1.substring(starDotPos1 + 1)__		int dotPos2 = pattern2.indexOf('.')__		String fileName2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2))__		String extension2 = (dotPos2 == -1 ? "" : pattern2.substring(dotPos2))__		String extension = extension1.startsWith("*") ? extension2 : extension1__		return fileName2 + extension__	};combines,two,patterns,into,a,new,pattern,that,is,returned,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,such,as,code,html,in,that,case,the,second,pattern,should,be,included,in,the,first,or,an,code,illegal,argument,exception,is,thrown,p,for,example,table,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,when,the,two,patterns,cannot,be,combined;override,public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,if,string,utils,has,text,pattern1,return,pattern2,if,string,utils,has,text,pattern2,return,pattern1,boolean,pattern1contains,uri,var,pattern1,index,of,1,if,pattern1,equals,pattern2,pattern1contains,uri,var,match,pattern1,pattern2,return,pattern2,if,pattern1,ends,with,return,slash,concat,pattern1,substring,0,pattern1,length,2,pattern2,if,pattern1,ends,with,return,slash,concat,pattern1,pattern2,int,star,dot,pos1,pattern1,index,of,if,pattern1contains,uri,var,star,dot,pos1,1,return,slash,concat,pattern1,pattern2,string,extension1,pattern1,substring,star,dot,pos1,1,int,dot,pos2,pattern2,index,of,string,file,name2,dot,pos2,1,pattern2,pattern2,substring,0,dot,pos2,string,extension2,dot,pos2,1,pattern2,substring,dot,pos2,string,extension,extension1,starts,with,extension2,extension1,return,file,name2,extension
AntPathMatcher -> @Override 	public String combine(String pattern1, String pattern2);1402512669;Combines two patterns into a new pattern that is returned._<p>This implementation simply concatenates the two patterns, unless the first pattern_contains a file extension match (such as {@code *.html}. In that case, the second pattern_should be included in the first, or an {@code IllegalArgumentException} is thrown._<p>For example: <table>_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr> <tr><td>/hotels</td><td>{@code_null}</td><td>/hotels</td></tr> <tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr> <tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr> <tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>IllegalArgumentException</td></tr> </table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException when the two patterns cannot be combined;@Override_	public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}__		boolean pattern1ContainsUriVar = pattern1.indexOf('{') != -1__		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {_			_			_			return pattern2__		}__		_		_		if (pattern1.endsWith("/*")) {_			return slashConcat(pattern1.substring(0, pattern1.length() - 2), pattern2)__		}__		_		_		if (pattern1.endsWith("/**")) {_			return slashConcat(pattern1, pattern2)__		}__		int starDotPos1 = pattern1.indexOf("*.")__		if (pattern1ContainsUriVar || starDotPos1 == -1) {_			_			return slashConcat(pattern1, pattern2)__		}_		String extension1 = pattern1.substring(starDotPos1 + 1)__		int dotPos2 = pattern2.indexOf('.')__		String fileName2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2))__		String extension2 = (dotPos2 == -1 ? "" : pattern2.substring(dotPos2))__		String extension = extension1.startsWith("*") ? extension2 : extension1__		return fileName2 + extension__	};combines,two,patterns,into,a,new,pattern,that,is,returned,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,such,as,code,html,in,that,case,the,second,pattern,should,be,included,in,the,first,or,an,code,illegal,argument,exception,is,thrown,p,for,example,table,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,when,the,two,patterns,cannot,be,combined;override,public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,if,string,utils,has,text,pattern1,return,pattern2,if,string,utils,has,text,pattern2,return,pattern1,boolean,pattern1contains,uri,var,pattern1,index,of,1,if,pattern1,equals,pattern2,pattern1contains,uri,var,match,pattern1,pattern2,return,pattern2,if,pattern1,ends,with,return,slash,concat,pattern1,substring,0,pattern1,length,2,pattern2,if,pattern1,ends,with,return,slash,concat,pattern1,pattern2,int,star,dot,pos1,pattern1,index,of,if,pattern1contains,uri,var,star,dot,pos1,1,return,slash,concat,pattern1,pattern2,string,extension1,pattern1,substring,star,dot,pos1,1,int,dot,pos2,pattern2,index,of,string,file,name2,dot,pos2,1,pattern2,pattern2,substring,0,dot,pos2,string,extension2,dot,pos2,1,pattern2,substring,dot,pos2,string,extension,extension1,starts,with,extension2,extension1,return,file,name2,extension
AntPathMatcher -> @Override 	public String combine(String pattern1, String pattern2);1402512669;Combines two patterns into a new pattern that is returned._<p>This implementation simply concatenates the two patterns, unless the first pattern_contains a file extension match (such as {@code *.html}. In that case, the second pattern_should be included in the first, or an {@code IllegalArgumentException} is thrown._<p>For example: <table>_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr> <tr><td>/hotels</td><td>{@code_null}</td><td>/hotels</td></tr> <tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr> <tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr> <tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>IllegalArgumentException</td></tr> </table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException when the two patterns cannot be combined;@Override_	public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}__		boolean pattern1ContainsUriVar = pattern1.indexOf('{') != -1__		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {_			_			_			return pattern2__		}__		_		_		if (pattern1.endsWith("/*")) {_			return slashConcat(pattern1.substring(0, pattern1.length() - 2), pattern2)__		}__		_		_		if (pattern1.endsWith("/**")) {_			return slashConcat(pattern1, pattern2)__		}__		int starDotPos1 = pattern1.indexOf("*.")__		if (pattern1ContainsUriVar || starDotPos1 == -1) {_			_			return slashConcat(pattern1, pattern2)__		}_		String extension1 = pattern1.substring(starDotPos1 + 1)__		int dotPos2 = pattern2.indexOf('.')__		String fileName2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2))__		String extension2 = (dotPos2 == -1 ? "" : pattern2.substring(dotPos2))__		String extension = extension1.startsWith("*") ? extension2 : extension1__		return fileName2 + extension__	};combines,two,patterns,into,a,new,pattern,that,is,returned,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,such,as,code,html,in,that,case,the,second,pattern,should,be,included,in,the,first,or,an,code,illegal,argument,exception,is,thrown,p,for,example,table,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,when,the,two,patterns,cannot,be,combined;override,public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,if,string,utils,has,text,pattern1,return,pattern2,if,string,utils,has,text,pattern2,return,pattern1,boolean,pattern1contains,uri,var,pattern1,index,of,1,if,pattern1,equals,pattern2,pattern1contains,uri,var,match,pattern1,pattern2,return,pattern2,if,pattern1,ends,with,return,slash,concat,pattern1,substring,0,pattern1,length,2,pattern2,if,pattern1,ends,with,return,slash,concat,pattern1,pattern2,int,star,dot,pos1,pattern1,index,of,if,pattern1contains,uri,var,star,dot,pos1,1,return,slash,concat,pattern1,pattern2,string,extension1,pattern1,substring,star,dot,pos1,1,int,dot,pos2,pattern2,index,of,string,file,name2,dot,pos2,1,pattern2,pattern2,substring,0,dot,pos2,string,extension2,dot,pos2,1,pattern2,substring,dot,pos2,string,extension,extension1,starts,with,extension2,extension1,return,file,name2,extension
AntPathMatcher -> @Override 	public String combine(String pattern1, String pattern2);1405378164;Combines two patterns into a new pattern that is returned._<p>This implementation simply concatenates the two patterns, unless the first pattern_contains a file extension match (such as {@code *.html}. In that case, the second pattern_should be included in the first, or an {@code IllegalArgumentException} is thrown._<p>For example: <table>_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr> <tr><td>/hotels</td><td>{@code_null}</td><td>/hotels</td></tr> <tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr> <tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr> <tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>IllegalArgumentException</td></tr> </table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException when the two patterns cannot be combined;@Override_	public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}__		boolean pattern1ContainsUriVar = pattern1.indexOf('{') != -1__		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {_			_			_			return pattern2__		}__		_		_		if (pattern1.endsWith(this.pathSeparator + "*")) {_			return separatorConcat(pattern1.substring(0, pattern1.length() - 2), pattern2)__		}__		_		_		if (pattern1.endsWith(this.pathSeparator + "**")) {_			return separatorConcat(pattern1, pattern2)__		}__		int starDotPos1 = pattern1.indexOf("*.")__		if (pattern1ContainsUriVar || starDotPos1 == -1 || this.pathSeparator.equals(".")) {_			_			return separatorConcat(pattern1, pattern2)__		}_		String extension1 = pattern1.substring(starDotPos1 + 1)__		int dotPos2 = pattern2.indexOf('.')__		String fileName2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2))__		String extension2 = (dotPos2 == -1 ? "" : pattern2.substring(dotPos2))__		String extension = extension1.startsWith("*") ? extension2 : extension1__		return fileName2 + extension__	};combines,two,patterns,into,a,new,pattern,that,is,returned,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,such,as,code,html,in,that,case,the,second,pattern,should,be,included,in,the,first,or,an,code,illegal,argument,exception,is,thrown,p,for,example,table,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,when,the,two,patterns,cannot,be,combined;override,public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,if,string,utils,has,text,pattern1,return,pattern2,if,string,utils,has,text,pattern2,return,pattern1,boolean,pattern1contains,uri,var,pattern1,index,of,1,if,pattern1,equals,pattern2,pattern1contains,uri,var,match,pattern1,pattern2,return,pattern2,if,pattern1,ends,with,this,path,separator,return,separator,concat,pattern1,substring,0,pattern1,length,2,pattern2,if,pattern1,ends,with,this,path,separator,return,separator,concat,pattern1,pattern2,int,star,dot,pos1,pattern1,index,of,if,pattern1contains,uri,var,star,dot,pos1,1,this,path,separator,equals,return,separator,concat,pattern1,pattern2,string,extension1,pattern1,substring,star,dot,pos1,1,int,dot,pos2,pattern2,index,of,string,file,name2,dot,pos2,1,pattern2,pattern2,substring,0,dot,pos2,string,extension2,dot,pos2,1,pattern2,substring,dot,pos2,string,extension,extension1,starts,with,extension2,extension1,return,file,name2,extension
AntPathMatcher -> @Override 	public String combine(String pattern1, String pattern2);1405378165;Combines two patterns into a new pattern that is returned._<p>This implementation simply concatenates the two patterns, unless the first pattern_contains a file extension match (such as {@code *.html}. In that case, the second pattern_should be included in the first, or an {@code IllegalArgumentException} is thrown._<p>For example: <table>_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr> <tr><td>/hotels</td><td>{@code_null}</td><td>/hotels</td></tr> <tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr> <tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr> <tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>IllegalArgumentException</td></tr> </table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException when the two patterns cannot be combined;@Override_	public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}__		boolean pattern1ContainsUriVar = pattern1.indexOf('{') != -1__		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {_			_			_			return pattern2__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnWildCard())) {_			return concat(pattern1.substring(0, pattern1.length() - 2), pattern2)__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnDoubleWildCard())) {_			return concat(pattern1, pattern2)__		}__		int starDotPos1 = pattern1.indexOf("*.")__		if (pattern1ContainsUriVar || starDotPos1 == -1 || this.pathSeparator.equals(".")) {_			_			return concat(pattern1, pattern2)__		}_		String extension1 = pattern1.substring(starDotPos1 + 1)__		int dotPos2 = pattern2.indexOf('.')__		String fileName2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2))__		String extension2 = (dotPos2 == -1 ? "" : pattern2.substring(dotPos2))__		String extension = extension1.startsWith("*") ? extension2 : extension1__		return fileName2 + extension__	};combines,two,patterns,into,a,new,pattern,that,is,returned,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,such,as,code,html,in,that,case,the,second,pattern,should,be,included,in,the,first,or,an,code,illegal,argument,exception,is,thrown,p,for,example,table,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,when,the,two,patterns,cannot,be,combined;override,public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,if,string,utils,has,text,pattern1,return,pattern2,if,string,utils,has,text,pattern2,return,pattern1,boolean,pattern1contains,uri,var,pattern1,index,of,1,if,pattern1,equals,pattern2,pattern1contains,uri,var,match,pattern1,pattern2,return,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,wild,card,return,concat,pattern1,substring,0,pattern1,length,2,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,double,wild,card,return,concat,pattern1,pattern2,int,star,dot,pos1,pattern1,index,of,if,pattern1contains,uri,var,star,dot,pos1,1,this,path,separator,equals,return,concat,pattern1,pattern2,string,extension1,pattern1,substring,star,dot,pos1,1,int,dot,pos2,pattern2,index,of,string,file,name2,dot,pos2,1,pattern2,pattern2,substring,0,dot,pos2,string,extension2,dot,pos2,1,pattern2,substring,dot,pos2,string,extension,extension1,starts,with,extension2,extension1,return,file,name2,extension
AntPathMatcher -> @Override 	public String combine(String pattern1, String pattern2);1405696918;Combines two patterns into a new pattern that is returned._<p>This implementation simply concatenates the two patterns, unless the first pattern_contains a file extension match (such as {@code *.html}. In that case, the second pattern_should be included in the first, or an {@code IllegalArgumentException} is thrown._<p>For example: <table>_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr> <tr><td>/hotels</td><td>{@code_null}</td><td>/hotels</td></tr> <tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr> <tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr> <tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>IllegalArgumentException</td></tr> </table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException when the two patterns cannot be combined;@Override_	public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}__		boolean pattern1ContainsUriVar = pattern1.indexOf('{') != -1__		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {_			_			_			return pattern2__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnWildCard())) {_			return concat(pattern1.substring(0, pattern1.length() - 2), pattern2)__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnDoubleWildCard())) {_			return concat(pattern1, pattern2)__		}__		int starDotPos1 = pattern1.indexOf("*.")__		if (pattern1ContainsUriVar || starDotPos1 == -1 || this.pathSeparator.equals(".")) {_			_			return concat(pattern1, pattern2)__		}_		String extension1 = pattern1.substring(starDotPos1 + 1)__		int dotPos2 = pattern2.indexOf('.')__		String fileName2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2))__		String extension2 = (dotPos2 == -1 ? "" : pattern2.substring(dotPos2))__		String extension = extension1.startsWith("*") ? extension2 : extension1__		return fileName2 + extension__	};combines,two,patterns,into,a,new,pattern,that,is,returned,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,such,as,code,html,in,that,case,the,second,pattern,should,be,included,in,the,first,or,an,code,illegal,argument,exception,is,thrown,p,for,example,table,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,when,the,two,patterns,cannot,be,combined;override,public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,if,string,utils,has,text,pattern1,return,pattern2,if,string,utils,has,text,pattern2,return,pattern1,boolean,pattern1contains,uri,var,pattern1,index,of,1,if,pattern1,equals,pattern2,pattern1contains,uri,var,match,pattern1,pattern2,return,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,wild,card,return,concat,pattern1,substring,0,pattern1,length,2,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,double,wild,card,return,concat,pattern1,pattern2,int,star,dot,pos1,pattern1,index,of,if,pattern1contains,uri,var,star,dot,pos1,1,this,path,separator,equals,return,concat,pattern1,pattern2,string,extension1,pattern1,substring,star,dot,pos1,1,int,dot,pos2,pattern2,index,of,string,file,name2,dot,pos2,1,pattern2,pattern2,substring,0,dot,pos2,string,extension2,dot,pos2,1,pattern2,substring,dot,pos2,string,extension,extension1,starts,with,extension2,extension1,return,file,name2,extension
AntPathMatcher -> @Override 	public String combine(String pattern1, String pattern2);1409784938;Combines two patterns into a new pattern that is returned._<p>This implementation simply concatenates the two patterns, unless the first pattern_contains a file extension match (such as {@code *.html}. In that case, the second pattern_should be included in the first, or an {@code IllegalArgumentException} is thrown._<p>For example: <table>_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr> <tr><td>/hotels</td><td>{@code_null}</td><td>/hotels</td></tr> <tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr> <tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr> <tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>IllegalArgumentException</td></tr> </table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException when the two patterns cannot be combined;@Override_	public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}__		boolean pattern1ContainsUriVar = pattern1.indexOf('{') != -1__		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {_			_			_			return pattern2__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnWildCard())) {_			return concat(pattern1.substring(0, pattern1.length() - 2), pattern2)__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnDoubleWildCard())) {_			return concat(pattern1, pattern2)__		}__		int starDotPos1 = pattern1.indexOf("*.")__		if (pattern1ContainsUriVar || starDotPos1 == -1 || this.pathSeparator.equals(".")) {_			_			return concat(pattern1, pattern2)__		}_		String extension1 = pattern1.substring(starDotPos1 + 1)__		int dotPos2 = pattern2.indexOf('.')__		String fileName2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2))__		String extension2 = (dotPos2 == -1 ? "" : pattern2.substring(dotPos2))__		String extension = extension1.startsWith("*") ? extension2 : extension1__		return fileName2 + extension__	};combines,two,patterns,into,a,new,pattern,that,is,returned,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,such,as,code,html,in,that,case,the,second,pattern,should,be,included,in,the,first,or,an,code,illegal,argument,exception,is,thrown,p,for,example,table,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,when,the,two,patterns,cannot,be,combined;override,public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,if,string,utils,has,text,pattern1,return,pattern2,if,string,utils,has,text,pattern2,return,pattern1,boolean,pattern1contains,uri,var,pattern1,index,of,1,if,pattern1,equals,pattern2,pattern1contains,uri,var,match,pattern1,pattern2,return,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,wild,card,return,concat,pattern1,substring,0,pattern1,length,2,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,double,wild,card,return,concat,pattern1,pattern2,int,star,dot,pos1,pattern1,index,of,if,pattern1contains,uri,var,star,dot,pos1,1,this,path,separator,equals,return,concat,pattern1,pattern2,string,extension1,pattern1,substring,star,dot,pos1,1,int,dot,pos2,pattern2,index,of,string,file,name2,dot,pos2,1,pattern2,pattern2,substring,0,dot,pos2,string,extension2,dot,pos2,1,pattern2,substring,dot,pos2,string,extension,extension1,starts,with,extension2,extension1,return,file,name2,extension
AntPathMatcher -> @Override 	public String combine(String pattern1, String pattern2);1412083966;Combines two patterns into a new pattern that is returned._<p>This implementation simply concatenates the two patterns, unless the first pattern_contains a file extension match (such as {@code *.html}. In that case, the second pattern_should be included in the first, or an {@code IllegalArgumentException} is thrown._<p>For example: <table>_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr> <tr><td>/hotels</td><td>{@code_null}</td><td>/hotels</td></tr> <tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr> <tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr> <tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>IllegalArgumentException</td></tr> </table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException when the two patterns cannot be combined;@Override_	public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}__		boolean pattern1ContainsUriVar = pattern1.indexOf('{') != -1__		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {_			_			_			return pattern2__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnWildCard())) {_			return concat(pattern1.substring(0, pattern1.length() - 2), pattern2)__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnDoubleWildCard())) {_			return concat(pattern1, pattern2)__		}__		int starDotPos1 = pattern1.indexOf("*.")__		if (pattern1ContainsUriVar || starDotPos1 == -1 || this.pathSeparator.equals(".")) {_			_			return concat(pattern1, pattern2)__		}_		String extension1 = pattern1.substring(starDotPos1 + 1)__		int dotPos2 = pattern2.indexOf('.')__		String fileName2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2))__		String extension2 = (dotPos2 == -1 ? "" : pattern2.substring(dotPos2))__		String extension = extension1.startsWith("*") ? extension2 : extension1__		return fileName2 + extension__	};combines,two,patterns,into,a,new,pattern,that,is,returned,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,such,as,code,html,in,that,case,the,second,pattern,should,be,included,in,the,first,or,an,code,illegal,argument,exception,is,thrown,p,for,example,table,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,when,the,two,patterns,cannot,be,combined;override,public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,if,string,utils,has,text,pattern1,return,pattern2,if,string,utils,has,text,pattern2,return,pattern1,boolean,pattern1contains,uri,var,pattern1,index,of,1,if,pattern1,equals,pattern2,pattern1contains,uri,var,match,pattern1,pattern2,return,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,wild,card,return,concat,pattern1,substring,0,pattern1,length,2,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,double,wild,card,return,concat,pattern1,pattern2,int,star,dot,pos1,pattern1,index,of,if,pattern1contains,uri,var,star,dot,pos1,1,this,path,separator,equals,return,concat,pattern1,pattern2,string,extension1,pattern1,substring,star,dot,pos1,1,int,dot,pos2,pattern2,index,of,string,file,name2,dot,pos2,1,pattern2,pattern2,substring,0,dot,pos2,string,extension2,dot,pos2,1,pattern2,substring,dot,pos2,string,extension,extension1,starts,with,extension2,extension1,return,file,name2,extension
AntPathMatcher -> @Override 	public String combine(String pattern1, String pattern2);1412101078;Combines two patterns into a new pattern that is returned._<p>This implementation simply concatenates the two patterns, unless the first pattern_contains a file extension match (such as {@code *.html}. In that case, the second pattern_should be included in the first, or an {@code IllegalArgumentException} is thrown._<p>For example: <table>_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr> <tr><td>/hotels</td><td>{@code_null}</td><td>/hotels</td></tr> <tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr> <tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr> <tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr> <tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>IllegalArgumentException</td></tr> </table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException when the two patterns cannot be combined;@Override_	public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}__		boolean pattern1ContainsUriVar = pattern1.indexOf('{') != -1__		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {_			_			_			return pattern2__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnWildCard())) {_			return concat(pattern1.substring(0, pattern1.length() - 2), pattern2)__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnDoubleWildCard())) {_			return concat(pattern1, pattern2)__		}__		int starDotPos1 = pattern1.indexOf("*.")__		if (pattern1ContainsUriVar || starDotPos1 == -1 || this.pathSeparator.equals(".")) {_			_			return concat(pattern1, pattern2)__		}_		String extension1 = pattern1.substring(starDotPos1 + 1)__		int dotPos2 = pattern2.indexOf('.')__		String fileName2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2))__		String extension2 = (dotPos2 == -1 ? "" : pattern2.substring(dotPos2))__		String extension = extension1.startsWith("*") ? extension2 : extension1__		return fileName2 + extension__	};combines,two,patterns,into,a,new,pattern,that,is,returned,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,such,as,code,html,in,that,case,the,second,pattern,should,be,included,in,the,first,or,an,code,illegal,argument,exception,is,thrown,p,for,example,table,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,when,the,two,patterns,cannot,be,combined;override,public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,if,string,utils,has,text,pattern1,return,pattern2,if,string,utils,has,text,pattern2,return,pattern1,boolean,pattern1contains,uri,var,pattern1,index,of,1,if,pattern1,equals,pattern2,pattern1contains,uri,var,match,pattern1,pattern2,return,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,wild,card,return,concat,pattern1,substring,0,pattern1,length,2,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,double,wild,card,return,concat,pattern1,pattern2,int,star,dot,pos1,pattern1,index,of,if,pattern1contains,uri,var,star,dot,pos1,1,this,path,separator,equals,return,concat,pattern1,pattern2,string,extension1,pattern1,substring,star,dot,pos1,1,int,dot,pos2,pattern2,index,of,string,file,name2,dot,pos2,1,pattern2,pattern2,substring,0,dot,pos2,string,extension2,dot,pos2,1,pattern2,substring,dot,pos2,string,extension,extension1,starts,with,extension2,extension1,return,file,name2,extension
AntPathMatcher -> @Override 	public String combine(String pattern1, String pattern2);1431086052;Combine two patterns into a new pattern.__<p>This implementation simply concatenates the two patterns, unless_the first pattern contains a file extension match (e.g., {@code *.html})._In that case, the second pattern will be merged into the first. Otherwise,_an {@code IllegalArgumentException} will be thrown.__<h3>Examples</h3>_<table border="1">_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr>_<tr><td>{@code null}</td><td>{@code null}</td><td>&nbsp_</td></tr>_<tr><td>/hotels</td><td>{@code null}</td><td>/hotels</td></tr>_<tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>{@code IllegalArgumentException}</td></tr>_</table>__@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException if the two patterns cannot be combined;@Override_	public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}__		boolean pattern1ContainsUriVar = pattern1.indexOf('{') != -1__		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {_			_			_			return pattern2__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnWildCard())) {_			return concat(pattern1.substring(0, pattern1.length() - 2), pattern2)__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnDoubleWildCard())) {_			return concat(pattern1, pattern2)__		}__		int starDotPos1 = pattern1.indexOf("*.")__		if (pattern1ContainsUriVar || starDotPos1 == -1 || this.pathSeparator.equals(".")) {_			_			return concat(pattern1, pattern2)__		}_		String extension1 = pattern1.substring(starDotPos1 + 1)__		int dotPos2 = pattern2.indexOf('.')__		String fileName2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2))__		String extension2 = (dotPos2 == -1 ? "" : pattern2.substring(dotPos2))__		String extension = extension1.startsWith("*") ? extension2 : extension1__		return fileName2 + extension__	};combine,two,patterns,into,a,new,pattern,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,e,g,code,html,in,that,case,the,second,pattern,will,be,merged,into,the,first,otherwise,an,code,illegal,argument,exception,will,be,thrown,h3,examples,h3,table,border,1,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,code,null,td,td,code,null,td,td,nbsp,td,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,code,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,if,the,two,patterns,cannot,be,combined;override,public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,if,string,utils,has,text,pattern1,return,pattern2,if,string,utils,has,text,pattern2,return,pattern1,boolean,pattern1contains,uri,var,pattern1,index,of,1,if,pattern1,equals,pattern2,pattern1contains,uri,var,match,pattern1,pattern2,return,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,wild,card,return,concat,pattern1,substring,0,pattern1,length,2,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,double,wild,card,return,concat,pattern1,pattern2,int,star,dot,pos1,pattern1,index,of,if,pattern1contains,uri,var,star,dot,pos1,1,this,path,separator,equals,return,concat,pattern1,pattern2,string,extension1,pattern1,substring,star,dot,pos1,1,int,dot,pos2,pattern2,index,of,string,file,name2,dot,pos2,1,pattern2,pattern2,substring,0,dot,pos2,string,extension2,dot,pos2,1,pattern2,substring,dot,pos2,string,extension,extension1,starts,with,extension2,extension1,return,file,name2,extension
AntPathMatcher -> @Override 	public String combine(String pattern1, String pattern2);1431178173;Combine two patterns into a new pattern._<p>This implementation simply concatenates the two patterns, unless_the first pattern contains a file extension match (e.g., {@code *.html})._In that case, the second pattern will be merged into the first. Otherwise,_an {@code IllegalArgumentException} will be thrown._<h3>Examples</h3>_<table border="1">_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr>_<tr><td>{@code null}</td><td>{@code null}</td><td>&nbsp_</td></tr>_<tr><td>/hotels</td><td>{@code null}</td><td>/hotels</td></tr>_<tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>{@code IllegalArgumentException}</td></tr>_</table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException if the two patterns cannot be combined;@Override_	public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}__		boolean pattern1ContainsUriVar = (pattern1.indexOf('{') != -1)__		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {_			_			_			return pattern2__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnWildCard())) {_			return concat(pattern1.substring(0, pattern1.length() - 2), pattern2)__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnDoubleWildCard())) {_			return concat(pattern1, pattern2)__		}__		int starDotPos1 = pattern1.indexOf("*.")__		if (pattern1ContainsUriVar || starDotPos1 == -1 || this.pathSeparator.equals(".")) {_			_			return concat(pattern1, pattern2)__		}__		String ext1 = pattern1.substring(starDotPos1 + 1)__		int dotPos2 = pattern2.indexOf('.')__		String file2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2))__		String ext2 = (dotPos2 == -1 ? "" : pattern2.substring(dotPos2))__		boolean ext1All = (ext1.equals(".*") || ext1.equals(""))__		boolean ext2All = (ext2.equals(".*") || ext2.equals(""))__		if (!ext1All && !ext2All) {_			throw new IllegalArgumentException("Cannot combine patterns: " + pattern1 + " vs " + pattern2)__		}_		String ext = (ext1All ? ext2 : ext1)__		return file2 + ext__	};combine,two,patterns,into,a,new,pattern,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,e,g,code,html,in,that,case,the,second,pattern,will,be,merged,into,the,first,otherwise,an,code,illegal,argument,exception,will,be,thrown,h3,examples,h3,table,border,1,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,code,null,td,td,code,null,td,td,nbsp,td,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,code,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,if,the,two,patterns,cannot,be,combined;override,public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,if,string,utils,has,text,pattern1,return,pattern2,if,string,utils,has,text,pattern2,return,pattern1,boolean,pattern1contains,uri,var,pattern1,index,of,1,if,pattern1,equals,pattern2,pattern1contains,uri,var,match,pattern1,pattern2,return,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,wild,card,return,concat,pattern1,substring,0,pattern1,length,2,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,double,wild,card,return,concat,pattern1,pattern2,int,star,dot,pos1,pattern1,index,of,if,pattern1contains,uri,var,star,dot,pos1,1,this,path,separator,equals,return,concat,pattern1,pattern2,string,ext1,pattern1,substring,star,dot,pos1,1,int,dot,pos2,pattern2,index,of,string,file2,dot,pos2,1,pattern2,pattern2,substring,0,dot,pos2,string,ext2,dot,pos2,1,pattern2,substring,dot,pos2,boolean,ext1all,ext1,equals,ext1,equals,boolean,ext2all,ext2,equals,ext2,equals,if,ext1all,ext2all,throw,new,illegal,argument,exception,cannot,combine,patterns,pattern1,vs,pattern2,string,ext,ext1all,ext2,ext1,return,file2,ext
AntPathMatcher -> @Override 	public String combine(String pattern1, String pattern2);1434572159;Combine two patterns into a new pattern._<p>This implementation simply concatenates the two patterns, unless_the first pattern contains a file extension match (e.g., {@code *.html})._In that case, the second pattern will be merged into the first. Otherwise,_an {@code IllegalArgumentException} will be thrown._<h3>Examples</h3>_<table border="1">_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr>_<tr><td>{@code null}</td><td>{@code null}</td><td>&nbsp_</td></tr>_<tr><td>/hotels</td><td>{@code null}</td><td>/hotels</td></tr>_<tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>{@code IllegalArgumentException}</td></tr>_</table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException if the two patterns cannot be combined;@Override_	public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}__		boolean pattern1ContainsUriVar = (pattern1.indexOf('{') != -1)__		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {_			_			_			return pattern2__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnWildCard())) {_			return concat(pattern1.substring(0, pattern1.length() - 2), pattern2)__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnDoubleWildCard())) {_			return concat(pattern1, pattern2)__		}__		int starDotPos1 = pattern1.indexOf("*.")__		if (pattern1ContainsUriVar || starDotPos1 == -1 || this.pathSeparator.equals(".")) {_			_			return concat(pattern1, pattern2)__		}__		String ext1 = pattern1.substring(starDotPos1 + 1)__		int dotPos2 = pattern2.indexOf('.')__		String file2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2))__		String ext2 = (dotPos2 == -1 ? "" : pattern2.substring(dotPos2))__		boolean ext1All = (ext1.equals(".*") || ext1.equals(""))__		boolean ext2All = (ext2.equals(".*") || ext2.equals(""))__		if (!ext1All && !ext2All) {_			throw new IllegalArgumentException("Cannot combine patterns: " + pattern1 + " vs " + pattern2)__		}_		String ext = (ext1All ? ext2 : ext1)__		return file2 + ext__	};combine,two,patterns,into,a,new,pattern,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,e,g,code,html,in,that,case,the,second,pattern,will,be,merged,into,the,first,otherwise,an,code,illegal,argument,exception,will,be,thrown,h3,examples,h3,table,border,1,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,code,null,td,td,code,null,td,td,nbsp,td,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,code,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,if,the,two,patterns,cannot,be,combined;override,public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,if,string,utils,has,text,pattern1,return,pattern2,if,string,utils,has,text,pattern2,return,pattern1,boolean,pattern1contains,uri,var,pattern1,index,of,1,if,pattern1,equals,pattern2,pattern1contains,uri,var,match,pattern1,pattern2,return,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,wild,card,return,concat,pattern1,substring,0,pattern1,length,2,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,double,wild,card,return,concat,pattern1,pattern2,int,star,dot,pos1,pattern1,index,of,if,pattern1contains,uri,var,star,dot,pos1,1,this,path,separator,equals,return,concat,pattern1,pattern2,string,ext1,pattern1,substring,star,dot,pos1,1,int,dot,pos2,pattern2,index,of,string,file2,dot,pos2,1,pattern2,pattern2,substring,0,dot,pos2,string,ext2,dot,pos2,1,pattern2,substring,dot,pos2,boolean,ext1all,ext1,equals,ext1,equals,boolean,ext2all,ext2,equals,ext2,equals,if,ext1all,ext2all,throw,new,illegal,argument,exception,cannot,combine,patterns,pattern1,vs,pattern2,string,ext,ext1all,ext2,ext1,return,file2,ext
AntPathMatcher -> @Override 	public String combine(String pattern1, String pattern2);1435239719;Combine two patterns into a new pattern._<p>This implementation simply concatenates the two patterns, unless_the first pattern contains a file extension match (e.g., {@code *.html})._In that case, the second pattern will be merged into the first. Otherwise,_an {@code IllegalArgumentException} will be thrown._<h3>Examples</h3>_<table border="1">_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr>_<tr><td>{@code null}</td><td>{@code null}</td><td>&nbsp_</td></tr>_<tr><td>/hotels</td><td>{@code null}</td><td>/hotels</td></tr>_<tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>{@code IllegalArgumentException}</td></tr>_</table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException if the two patterns cannot be combined;@Override_	public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}__		boolean pattern1ContainsUriVar = (pattern1.indexOf('{') != -1)__		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {_			_			_			return pattern2__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnWildCard())) {_			return concat(pattern1.substring(0, pattern1.length() - 2), pattern2)__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnDoubleWildCard())) {_			return concat(pattern1, pattern2)__		}__		int starDotPos1 = pattern1.indexOf("*.")__		if (pattern1ContainsUriVar || starDotPos1 == -1 || this.pathSeparator.equals(".")) {_			_			return concat(pattern1, pattern2)__		}__		String ext1 = pattern1.substring(starDotPos1 + 1)__		int dotPos2 = pattern2.indexOf('.')__		String file2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2))__		String ext2 = (dotPos2 == -1 ? "" : pattern2.substring(dotPos2))__		boolean ext1All = (ext1.equals(".*") || ext1.equals(""))__		boolean ext2All = (ext2.equals(".*") || ext2.equals(""))__		if (!ext1All && !ext2All) {_			throw new IllegalArgumentException("Cannot combine patterns: " + pattern1 + " vs " + pattern2)__		}_		String ext = (ext1All ? ext2 : ext1)__		return file2 + ext__	};combine,two,patterns,into,a,new,pattern,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,e,g,code,html,in,that,case,the,second,pattern,will,be,merged,into,the,first,otherwise,an,code,illegal,argument,exception,will,be,thrown,h3,examples,h3,table,border,1,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,code,null,td,td,code,null,td,td,nbsp,td,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,code,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,if,the,two,patterns,cannot,be,combined;override,public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,if,string,utils,has,text,pattern1,return,pattern2,if,string,utils,has,text,pattern2,return,pattern1,boolean,pattern1contains,uri,var,pattern1,index,of,1,if,pattern1,equals,pattern2,pattern1contains,uri,var,match,pattern1,pattern2,return,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,wild,card,return,concat,pattern1,substring,0,pattern1,length,2,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,double,wild,card,return,concat,pattern1,pattern2,int,star,dot,pos1,pattern1,index,of,if,pattern1contains,uri,var,star,dot,pos1,1,this,path,separator,equals,return,concat,pattern1,pattern2,string,ext1,pattern1,substring,star,dot,pos1,1,int,dot,pos2,pattern2,index,of,string,file2,dot,pos2,1,pattern2,pattern2,substring,0,dot,pos2,string,ext2,dot,pos2,1,pattern2,substring,dot,pos2,boolean,ext1all,ext1,equals,ext1,equals,boolean,ext2all,ext2,equals,ext2,equals,if,ext1all,ext2all,throw,new,illegal,argument,exception,cannot,combine,patterns,pattern1,vs,pattern2,string,ext,ext1all,ext2,ext1,return,file2,ext
AntPathMatcher -> @Override 	public String combine(String pattern1, String pattern2);1438166321;Combine two patterns into a new pattern._<p>This implementation simply concatenates the two patterns, unless_the first pattern contains a file extension match (e.g., {@code *.html})._In that case, the second pattern will be merged into the first. Otherwise,_an {@code IllegalArgumentException} will be thrown._<h3>Examples</h3>_<table border="1">_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr>_<tr><td>{@code null}</td><td>{@code null}</td><td>&nbsp_</td></tr>_<tr><td>/hotels</td><td>{@code null}</td><td>/hotels</td></tr>_<tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>{@code IllegalArgumentException}</td></tr>_</table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException if the two patterns cannot be combined;@Override_	public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}__		boolean pattern1ContainsUriVar = (pattern1.indexOf('{') != -1)__		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {_			_			_			return pattern2__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnWildCard())) {_			return concat(pattern1.substring(0, pattern1.length() - 2), pattern2)__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnDoubleWildCard())) {_			return concat(pattern1, pattern2)__		}__		int starDotPos1 = pattern1.indexOf("*.")__		if (pattern1ContainsUriVar || starDotPos1 == -1 || this.pathSeparator.equals(".")) {_			_			return concat(pattern1, pattern2)__		}__		String ext1 = pattern1.substring(starDotPos1 + 1)__		int dotPos2 = pattern2.indexOf('.')__		String file2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2))__		String ext2 = (dotPos2 == -1 ? "" : pattern2.substring(dotPos2))__		boolean ext1All = (ext1.equals(".*") || ext1.equals(""))__		boolean ext2All = (ext2.equals(".*") || ext2.equals(""))__		if (!ext1All && !ext2All) {_			throw new IllegalArgumentException("Cannot combine patterns: " + pattern1 + " vs " + pattern2)__		}_		String ext = (ext1All ? ext2 : ext1)__		return file2 + ext__	};combine,two,patterns,into,a,new,pattern,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,e,g,code,html,in,that,case,the,second,pattern,will,be,merged,into,the,first,otherwise,an,code,illegal,argument,exception,will,be,thrown,h3,examples,h3,table,border,1,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,code,null,td,td,code,null,td,td,nbsp,td,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,code,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,if,the,two,patterns,cannot,be,combined;override,public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,if,string,utils,has,text,pattern1,return,pattern2,if,string,utils,has,text,pattern2,return,pattern1,boolean,pattern1contains,uri,var,pattern1,index,of,1,if,pattern1,equals,pattern2,pattern1contains,uri,var,match,pattern1,pattern2,return,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,wild,card,return,concat,pattern1,substring,0,pattern1,length,2,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,double,wild,card,return,concat,pattern1,pattern2,int,star,dot,pos1,pattern1,index,of,if,pattern1contains,uri,var,star,dot,pos1,1,this,path,separator,equals,return,concat,pattern1,pattern2,string,ext1,pattern1,substring,star,dot,pos1,1,int,dot,pos2,pattern2,index,of,string,file2,dot,pos2,1,pattern2,pattern2,substring,0,dot,pos2,string,ext2,dot,pos2,1,pattern2,substring,dot,pos2,boolean,ext1all,ext1,equals,ext1,equals,boolean,ext2all,ext2,equals,ext2,equals,if,ext1all,ext2all,throw,new,illegal,argument,exception,cannot,combine,patterns,pattern1,vs,pattern2,string,ext,ext1all,ext2,ext1,return,file2,ext
AntPathMatcher -> @Override 	public String combine(String pattern1, String pattern2);1455100778;Combine two patterns into a new pattern._<p>This implementation simply concatenates the two patterns, unless_the first pattern contains a file extension match (e.g., {@code *.html})._In that case, the second pattern will be merged into the first. Otherwise,_an {@code IllegalArgumentException} will be thrown._<h3>Examples</h3>_<table border="1">_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr>_<tr><td>{@code null}</td><td>{@code null}</td><td>&nbsp_</td></tr>_<tr><td>/hotels</td><td>{@code null}</td><td>/hotels</td></tr>_<tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>{@code IllegalArgumentException}</td></tr>_</table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException if the two patterns cannot be combined;@Override_	public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}__		boolean pattern1ContainsUriVar = (pattern1.indexOf('{') != -1)__		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {_			_			_			return pattern2__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnWildCard())) {_			return concat(pattern1.substring(0, pattern1.length() - 2), pattern2)__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnDoubleWildCard())) {_			return concat(pattern1, pattern2)__		}__		int starDotPos1 = pattern1.indexOf("*.")__		if (pattern1ContainsUriVar || starDotPos1 == -1 || this.pathSeparator.equals(".")) {_			_			return concat(pattern1, pattern2)__		}__		String ext1 = pattern1.substring(starDotPos1 + 1)__		int dotPos2 = pattern2.indexOf('.')__		String file2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2))__		String ext2 = (dotPos2 == -1 ? "" : pattern2.substring(dotPos2))__		boolean ext1All = (ext1.equals(".*") || ext1.equals(""))__		boolean ext2All = (ext2.equals(".*") || ext2.equals(""))__		if (!ext1All && !ext2All) {_			throw new IllegalArgumentException("Cannot combine patterns: " + pattern1 + " vs " + pattern2)__		}_		String ext = (ext1All ? ext2 : ext1)__		return file2 + ext__	};combine,two,patterns,into,a,new,pattern,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,e,g,code,html,in,that,case,the,second,pattern,will,be,merged,into,the,first,otherwise,an,code,illegal,argument,exception,will,be,thrown,h3,examples,h3,table,border,1,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,code,null,td,td,code,null,td,td,nbsp,td,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,code,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,if,the,two,patterns,cannot,be,combined;override,public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,if,string,utils,has,text,pattern1,return,pattern2,if,string,utils,has,text,pattern2,return,pattern1,boolean,pattern1contains,uri,var,pattern1,index,of,1,if,pattern1,equals,pattern2,pattern1contains,uri,var,match,pattern1,pattern2,return,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,wild,card,return,concat,pattern1,substring,0,pattern1,length,2,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,double,wild,card,return,concat,pattern1,pattern2,int,star,dot,pos1,pattern1,index,of,if,pattern1contains,uri,var,star,dot,pos1,1,this,path,separator,equals,return,concat,pattern1,pattern2,string,ext1,pattern1,substring,star,dot,pos1,1,int,dot,pos2,pattern2,index,of,string,file2,dot,pos2,1,pattern2,pattern2,substring,0,dot,pos2,string,ext2,dot,pos2,1,pattern2,substring,dot,pos2,boolean,ext1all,ext1,equals,ext1,equals,boolean,ext2all,ext2,equals,ext2,equals,if,ext1all,ext2all,throw,new,illegal,argument,exception,cannot,combine,patterns,pattern1,vs,pattern2,string,ext,ext1all,ext2,ext1,return,file2,ext
AntPathMatcher -> @Override 	public String combine(String pattern1, String pattern2);1455850198;Combine two patterns into a new pattern._<p>This implementation simply concatenates the two patterns, unless_the first pattern contains a file extension match (e.g., {@code *.html})._In that case, the second pattern will be merged into the first. Otherwise,_an {@code IllegalArgumentException} will be thrown._<h3>Examples</h3>_<table border="1">_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr>_<tr><td>{@code null}</td><td>{@code null}</td><td>&nbsp_</td></tr>_<tr><td>/hotels</td><td>{@code null}</td><td>/hotels</td></tr>_<tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>{@code IllegalArgumentException}</td></tr>_</table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException if the two patterns cannot be combined;@Override_	public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}__		boolean pattern1ContainsUriVar = (pattern1.indexOf('{') != -1)__		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {_			_			_			return pattern2__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnWildCard())) {_			return concat(pattern1.substring(0, pattern1.length() - 2), pattern2)__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnDoubleWildCard())) {_			return concat(pattern1, pattern2)__		}__		int starDotPos1 = pattern1.indexOf("*.")__		if (pattern1ContainsUriVar || starDotPos1 == -1 || this.pathSeparator.equals(".")) {_			_			return concat(pattern1, pattern2)__		}__		String ext1 = pattern1.substring(starDotPos1 + 1)__		int dotPos2 = pattern2.indexOf('.')__		String file2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2))__		String ext2 = (dotPos2 == -1 ? "" : pattern2.substring(dotPos2))__		boolean ext1All = (ext1.equals(".*") || ext1.equals(""))__		boolean ext2All = (ext2.equals(".*") || ext2.equals(""))__		if (!ext1All && !ext2All) {_			throw new IllegalArgumentException("Cannot combine patterns: " + pattern1 + " vs " + pattern2)__		}_		String ext = (ext1All ? ext2 : ext1)__		return file2 + ext__	};combine,two,patterns,into,a,new,pattern,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,e,g,code,html,in,that,case,the,second,pattern,will,be,merged,into,the,first,otherwise,an,code,illegal,argument,exception,will,be,thrown,h3,examples,h3,table,border,1,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,code,null,td,td,code,null,td,td,nbsp,td,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,code,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,if,the,two,patterns,cannot,be,combined;override,public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,if,string,utils,has,text,pattern1,return,pattern2,if,string,utils,has,text,pattern2,return,pattern1,boolean,pattern1contains,uri,var,pattern1,index,of,1,if,pattern1,equals,pattern2,pattern1contains,uri,var,match,pattern1,pattern2,return,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,wild,card,return,concat,pattern1,substring,0,pattern1,length,2,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,double,wild,card,return,concat,pattern1,pattern2,int,star,dot,pos1,pattern1,index,of,if,pattern1contains,uri,var,star,dot,pos1,1,this,path,separator,equals,return,concat,pattern1,pattern2,string,ext1,pattern1,substring,star,dot,pos1,1,int,dot,pos2,pattern2,index,of,string,file2,dot,pos2,1,pattern2,pattern2,substring,0,dot,pos2,string,ext2,dot,pos2,1,pattern2,substring,dot,pos2,boolean,ext1all,ext1,equals,ext1,equals,boolean,ext2all,ext2,equals,ext2,equals,if,ext1all,ext2all,throw,new,illegal,argument,exception,cannot,combine,patterns,pattern1,vs,pattern2,string,ext,ext1all,ext2,ext1,return,file2,ext
AntPathMatcher -> @Override 	public String combine(String pattern1, String pattern2);1460754629;Combine two patterns into a new pattern._<p>This implementation simply concatenates the two patterns, unless_the first pattern contains a file extension match (e.g., {@code *.html})._In that case, the second pattern will be merged into the first. Otherwise,_an {@code IllegalArgumentException} will be thrown._<h3>Examples</h3>_<table border="1">_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr>_<tr><td>{@code null}</td><td>{@code null}</td><td>&nbsp_</td></tr>_<tr><td>/hotels</td><td>{@code null}</td><td>/hotels</td></tr>_<tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>{@code IllegalArgumentException}</td></tr>_</table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException if the two patterns cannot be combined;@Override_	public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}__		boolean pattern1ContainsUriVar = (pattern1.indexOf('{') != -1)__		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {_			_			_			return pattern2__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnWildCard())) {_			return concat(pattern1.substring(0, pattern1.length() - 2), pattern2)__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnDoubleWildCard())) {_			return concat(pattern1, pattern2)__		}__		int starDotPos1 = pattern1.indexOf("*.")__		if (pattern1ContainsUriVar || starDotPos1 == -1 || this.pathSeparator.equals(".")) {_			_			return concat(pattern1, pattern2)__		}__		String ext1 = pattern1.substring(starDotPos1 + 1)__		int dotPos2 = pattern2.indexOf('.')__		String file2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2))__		String ext2 = (dotPos2 == -1 ? "" : pattern2.substring(dotPos2))__		boolean ext1All = (ext1.equals(".*") || ext1.equals(""))__		boolean ext2All = (ext2.equals(".*") || ext2.equals(""))__		if (!ext1All && !ext2All) {_			throw new IllegalArgumentException("Cannot combine patterns: " + pattern1 + " vs " + pattern2)__		}_		String ext = (ext1All ? ext2 : ext1)__		return file2 + ext__	};combine,two,patterns,into,a,new,pattern,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,e,g,code,html,in,that,case,the,second,pattern,will,be,merged,into,the,first,otherwise,an,code,illegal,argument,exception,will,be,thrown,h3,examples,h3,table,border,1,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,code,null,td,td,code,null,td,td,nbsp,td,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,code,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,if,the,two,patterns,cannot,be,combined;override,public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,if,string,utils,has,text,pattern1,return,pattern2,if,string,utils,has,text,pattern2,return,pattern1,boolean,pattern1contains,uri,var,pattern1,index,of,1,if,pattern1,equals,pattern2,pattern1contains,uri,var,match,pattern1,pattern2,return,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,wild,card,return,concat,pattern1,substring,0,pattern1,length,2,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,double,wild,card,return,concat,pattern1,pattern2,int,star,dot,pos1,pattern1,index,of,if,pattern1contains,uri,var,star,dot,pos1,1,this,path,separator,equals,return,concat,pattern1,pattern2,string,ext1,pattern1,substring,star,dot,pos1,1,int,dot,pos2,pattern2,index,of,string,file2,dot,pos2,1,pattern2,pattern2,substring,0,dot,pos2,string,ext2,dot,pos2,1,pattern2,substring,dot,pos2,boolean,ext1all,ext1,equals,ext1,equals,boolean,ext2all,ext2,equals,ext2,equals,if,ext1all,ext2all,throw,new,illegal,argument,exception,cannot,combine,patterns,pattern1,vs,pattern2,string,ext,ext1all,ext2,ext1,return,file2,ext
AntPathMatcher -> @Override 	public String combine(String pattern1, String pattern2);1462393686;Combine two patterns into a new pattern._<p>This implementation simply concatenates the two patterns, unless_the first pattern contains a file extension match (e.g., {@code *.html})._In that case, the second pattern will be merged into the first. Otherwise,_an {@code IllegalArgumentException} will be thrown._<h3>Examples</h3>_<table border="1">_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr>_<tr><td>{@code null}</td><td>{@code null}</td><td>&nbsp_</td></tr>_<tr><td>/hotels</td><td>{@code null}</td><td>/hotels</td></tr>_<tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>{@code IllegalArgumentException}</td></tr>_</table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException if the two patterns cannot be combined;@Override_	public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}__		boolean pattern1ContainsUriVar = (pattern1.indexOf('{') != -1)__		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {_			_			_			return pattern2__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnWildCard())) {_			return concat(pattern1.substring(0, pattern1.length() - 2), pattern2)__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnDoubleWildCard())) {_			return concat(pattern1, pattern2)__		}__		int starDotPos1 = pattern1.indexOf("*.")__		if (pattern1ContainsUriVar || starDotPos1 == -1 || this.pathSeparator.equals(".")) {_			_			return concat(pattern1, pattern2)__		}__		String ext1 = pattern1.substring(starDotPos1 + 1)__		int dotPos2 = pattern2.indexOf('.')__		String file2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2))__		String ext2 = (dotPos2 == -1 ? "" : pattern2.substring(dotPos2))__		boolean ext1All = (ext1.equals(".*") || ext1.equals(""))__		boolean ext2All = (ext2.equals(".*") || ext2.equals(""))__		if (!ext1All && !ext2All) {_			throw new IllegalArgumentException("Cannot combine patterns: " + pattern1 + " vs " + pattern2)__		}_		String ext = (ext1All ? ext2 : ext1)__		return file2 + ext__	};combine,two,patterns,into,a,new,pattern,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,e,g,code,html,in,that,case,the,second,pattern,will,be,merged,into,the,first,otherwise,an,code,illegal,argument,exception,will,be,thrown,h3,examples,h3,table,border,1,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,code,null,td,td,code,null,td,td,nbsp,td,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,code,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,if,the,two,patterns,cannot,be,combined;override,public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,if,string,utils,has,text,pattern1,return,pattern2,if,string,utils,has,text,pattern2,return,pattern1,boolean,pattern1contains,uri,var,pattern1,index,of,1,if,pattern1,equals,pattern2,pattern1contains,uri,var,match,pattern1,pattern2,return,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,wild,card,return,concat,pattern1,substring,0,pattern1,length,2,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,double,wild,card,return,concat,pattern1,pattern2,int,star,dot,pos1,pattern1,index,of,if,pattern1contains,uri,var,star,dot,pos1,1,this,path,separator,equals,return,concat,pattern1,pattern2,string,ext1,pattern1,substring,star,dot,pos1,1,int,dot,pos2,pattern2,index,of,string,file2,dot,pos2,1,pattern2,pattern2,substring,0,dot,pos2,string,ext2,dot,pos2,1,pattern2,substring,dot,pos2,boolean,ext1all,ext1,equals,ext1,equals,boolean,ext2all,ext2,equals,ext2,equals,if,ext1all,ext2all,throw,new,illegal,argument,exception,cannot,combine,patterns,pattern1,vs,pattern2,string,ext,ext1all,ext2,ext1,return,file2,ext
AntPathMatcher -> @Override 	public String combine(String pattern1, String pattern2);1467730834;Combine two patterns into a new pattern._<p>This implementation simply concatenates the two patterns, unless_the first pattern contains a file extension match (e.g., {@code *.html})._In that case, the second pattern will be merged into the first. Otherwise,_an {@code IllegalArgumentException} will be thrown._<h3>Examples</h3>_<table border="1">_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr>_<tr><td>{@code null}</td><td>{@code null}</td><td>&nbsp_</td></tr>_<tr><td>/hotels</td><td>{@code null}</td><td>/hotels</td></tr>_<tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>{@code IllegalArgumentException}</td></tr>_</table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException if the two patterns cannot be combined;@Override_	public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}__		boolean pattern1ContainsUriVar = (pattern1.indexOf('{') != -1)__		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {_			_			_			return pattern2__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnWildCard())) {_			return concat(pattern1.substring(0, pattern1.length() - 2), pattern2)__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnDoubleWildCard())) {_			return concat(pattern1, pattern2)__		}__		int starDotPos1 = pattern1.indexOf("*.")__		if (pattern1ContainsUriVar || starDotPos1 == -1 || this.pathSeparator.equals(".")) {_			_			return concat(pattern1, pattern2)__		}__		String ext1 = pattern1.substring(starDotPos1 + 1)__		int dotPos2 = pattern2.indexOf('.')__		String file2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2))__		String ext2 = (dotPos2 == -1 ? "" : pattern2.substring(dotPos2))__		boolean ext1All = (ext1.equals(".*") || ext1.equals(""))__		boolean ext2All = (ext2.equals(".*") || ext2.equals(""))__		if (!ext1All && !ext2All) {_			throw new IllegalArgumentException("Cannot combine patterns: " + pattern1 + " vs " + pattern2)__		}_		String ext = (ext1All ? ext2 : ext1)__		return file2 + ext__	};combine,two,patterns,into,a,new,pattern,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,e,g,code,html,in,that,case,the,second,pattern,will,be,merged,into,the,first,otherwise,an,code,illegal,argument,exception,will,be,thrown,h3,examples,h3,table,border,1,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,code,null,td,td,code,null,td,td,nbsp,td,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,code,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,if,the,two,patterns,cannot,be,combined;override,public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,if,string,utils,has,text,pattern1,return,pattern2,if,string,utils,has,text,pattern2,return,pattern1,boolean,pattern1contains,uri,var,pattern1,index,of,1,if,pattern1,equals,pattern2,pattern1contains,uri,var,match,pattern1,pattern2,return,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,wild,card,return,concat,pattern1,substring,0,pattern1,length,2,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,double,wild,card,return,concat,pattern1,pattern2,int,star,dot,pos1,pattern1,index,of,if,pattern1contains,uri,var,star,dot,pos1,1,this,path,separator,equals,return,concat,pattern1,pattern2,string,ext1,pattern1,substring,star,dot,pos1,1,int,dot,pos2,pattern2,index,of,string,file2,dot,pos2,1,pattern2,pattern2,substring,0,dot,pos2,string,ext2,dot,pos2,1,pattern2,substring,dot,pos2,boolean,ext1all,ext1,equals,ext1,equals,boolean,ext2all,ext2,equals,ext2,equals,if,ext1all,ext2all,throw,new,illegal,argument,exception,cannot,combine,patterns,pattern1,vs,pattern2,string,ext,ext1all,ext2,ext1,return,file2,ext
AntPathMatcher -> @Override 	public String combine(String pattern1, String pattern2);1468327638;Combine two patterns into a new pattern._<p>This implementation simply concatenates the two patterns, unless_the first pattern contains a file extension match (e.g., {@code *.html})._In that case, the second pattern will be merged into the first. Otherwise,_an {@code IllegalArgumentException} will be thrown._<h3>Examples</h3>_<table border="1">_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr>_<tr><td>{@code null}</td><td>{@code null}</td><td>&nbsp_</td></tr>_<tr><td>/hotels</td><td>{@code null}</td><td>/hotels</td></tr>_<tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>{@code IllegalArgumentException}</td></tr>_</table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException if the two patterns cannot be combined;@Override_	public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}__		boolean pattern1ContainsUriVar = (pattern1.indexOf('{') != -1)__		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {_			_			_			return pattern2__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnWildCard())) {_			return concat(pattern1.substring(0, pattern1.length() - 2), pattern2)__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnDoubleWildCard())) {_			return concat(pattern1, pattern2)__		}__		int starDotPos1 = pattern1.indexOf("*.")__		if (pattern1ContainsUriVar || starDotPos1 == -1 || this.pathSeparator.equals(".")) {_			_			return concat(pattern1, pattern2)__		}__		String ext1 = pattern1.substring(starDotPos1 + 1)__		int dotPos2 = pattern2.indexOf('.')__		String file2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2))__		String ext2 = (dotPos2 == -1 ? "" : pattern2.substring(dotPos2))__		boolean ext1All = (ext1.equals(".*") || ext1.equals(""))__		boolean ext2All = (ext2.equals(".*") || ext2.equals(""))__		if (!ext1All && !ext2All) {_			throw new IllegalArgumentException("Cannot combine patterns: " + pattern1 + " vs " + pattern2)__		}_		String ext = (ext1All ? ext2 : ext1)__		return file2 + ext__	};combine,two,patterns,into,a,new,pattern,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,e,g,code,html,in,that,case,the,second,pattern,will,be,merged,into,the,first,otherwise,an,code,illegal,argument,exception,will,be,thrown,h3,examples,h3,table,border,1,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,code,null,td,td,code,null,td,td,nbsp,td,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,code,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,if,the,two,patterns,cannot,be,combined;override,public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,if,string,utils,has,text,pattern1,return,pattern2,if,string,utils,has,text,pattern2,return,pattern1,boolean,pattern1contains,uri,var,pattern1,index,of,1,if,pattern1,equals,pattern2,pattern1contains,uri,var,match,pattern1,pattern2,return,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,wild,card,return,concat,pattern1,substring,0,pattern1,length,2,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,double,wild,card,return,concat,pattern1,pattern2,int,star,dot,pos1,pattern1,index,of,if,pattern1contains,uri,var,star,dot,pos1,1,this,path,separator,equals,return,concat,pattern1,pattern2,string,ext1,pattern1,substring,star,dot,pos1,1,int,dot,pos2,pattern2,index,of,string,file2,dot,pos2,1,pattern2,pattern2,substring,0,dot,pos2,string,ext2,dot,pos2,1,pattern2,substring,dot,pos2,boolean,ext1all,ext1,equals,ext1,equals,boolean,ext2all,ext2,equals,ext2,equals,if,ext1all,ext2all,throw,new,illegal,argument,exception,cannot,combine,patterns,pattern1,vs,pattern2,string,ext,ext1all,ext2,ext1,return,file2,ext
AntPathMatcher -> @Override 	public String combine(String pattern1, String pattern2);1472808958;Combine two patterns into a new pattern._<p>This implementation simply concatenates the two patterns, unless_the first pattern contains a file extension match (e.g., {@code *.html})._In that case, the second pattern will be merged into the first. Otherwise,_an {@code IllegalArgumentException} will be thrown._<h3>Examples</h3>_<table border="1">_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr>_<tr><td>{@code null}</td><td>{@code null}</td><td>&nbsp_</td></tr>_<tr><td>/hotels</td><td>{@code null}</td><td>/hotels</td></tr>_<tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>{@code IllegalArgumentException}</td></tr>_</table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException if the two patterns cannot be combined;@Override_	public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}__		boolean pattern1ContainsUriVar = (pattern1.indexOf('{') != -1)__		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {_			_			_			return pattern2__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnWildCard())) {_			return concat(pattern1.substring(0, pattern1.length() - 2), pattern2)__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnDoubleWildCard())) {_			return concat(pattern1, pattern2)__		}__		int starDotPos1 = pattern1.indexOf("*.")__		if (pattern1ContainsUriVar || starDotPos1 == -1 || this.pathSeparator.equals(".")) {_			_			return concat(pattern1, pattern2)__		}__		String ext1 = pattern1.substring(starDotPos1 + 1)__		int dotPos2 = pattern2.indexOf('.')__		String file2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2))__		String ext2 = (dotPos2 == -1 ? "" : pattern2.substring(dotPos2))__		boolean ext1All = (ext1.equals(".*") || ext1.equals(""))__		boolean ext2All = (ext2.equals(".*") || ext2.equals(""))__		if (!ext1All && !ext2All) {_			throw new IllegalArgumentException("Cannot combine patterns: " + pattern1 + " vs " + pattern2)__		}_		String ext = (ext1All ? ext2 : ext1)__		return file2 + ext__	};combine,two,patterns,into,a,new,pattern,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,e,g,code,html,in,that,case,the,second,pattern,will,be,merged,into,the,first,otherwise,an,code,illegal,argument,exception,will,be,thrown,h3,examples,h3,table,border,1,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,code,null,td,td,code,null,td,td,nbsp,td,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,code,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,if,the,two,patterns,cannot,be,combined;override,public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,if,string,utils,has,text,pattern1,return,pattern2,if,string,utils,has,text,pattern2,return,pattern1,boolean,pattern1contains,uri,var,pattern1,index,of,1,if,pattern1,equals,pattern2,pattern1contains,uri,var,match,pattern1,pattern2,return,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,wild,card,return,concat,pattern1,substring,0,pattern1,length,2,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,double,wild,card,return,concat,pattern1,pattern2,int,star,dot,pos1,pattern1,index,of,if,pattern1contains,uri,var,star,dot,pos1,1,this,path,separator,equals,return,concat,pattern1,pattern2,string,ext1,pattern1,substring,star,dot,pos1,1,int,dot,pos2,pattern2,index,of,string,file2,dot,pos2,1,pattern2,pattern2,substring,0,dot,pos2,string,ext2,dot,pos2,1,pattern2,substring,dot,pos2,boolean,ext1all,ext1,equals,ext1,equals,boolean,ext2all,ext2,equals,ext2,equals,if,ext1all,ext2all,throw,new,illegal,argument,exception,cannot,combine,patterns,pattern1,vs,pattern2,string,ext,ext1all,ext2,ext1,return,file2,ext
AntPathMatcher -> @Override 	public String combine(String pattern1, String pattern2);1493317597;Combine two patterns into a new pattern._<p>This implementation simply concatenates the two patterns, unless_the first pattern contains a file extension match (e.g., {@code *.html})._In that case, the second pattern will be merged into the first. Otherwise,_an {@code IllegalArgumentException} will be thrown._<h3>Examples</h3>_<table border="1">_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr>_<tr><td>{@code null}</td><td>{@code null}</td><td>&nbsp_</td></tr>_<tr><td>/hotels</td><td>{@code null}</td><td>/hotels</td></tr>_<tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>{@code IllegalArgumentException}</td></tr>_</table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException if the two patterns cannot be combined;@Override_	public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}__		boolean pattern1ContainsUriVar = (pattern1.indexOf('{') != -1)__		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {_			_			_			return pattern2__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnWildCard())) {_			return concat(pattern1.substring(0, pattern1.length() - 2), pattern2)__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnDoubleWildCard())) {_			return concat(pattern1, pattern2)__		}__		int starDotPos1 = pattern1.indexOf("*.")__		if (pattern1ContainsUriVar || starDotPos1 == -1 || this.pathSeparator.equals(".")) {_			_			return concat(pattern1, pattern2)__		}__		String ext1 = pattern1.substring(starDotPos1 + 1)__		int dotPos2 = pattern2.indexOf('.')__		String file2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2))__		String ext2 = (dotPos2 == -1 ? "" : pattern2.substring(dotPos2))__		boolean ext1All = (ext1.equals(".*") || ext1.equals(""))__		boolean ext2All = (ext2.equals(".*") || ext2.equals(""))__		if (!ext1All && !ext2All) {_			throw new IllegalArgumentException("Cannot combine patterns: " + pattern1 + " vs " + pattern2)__		}_		String ext = (ext1All ? ext2 : ext1)__		return file2 + ext__	};combine,two,patterns,into,a,new,pattern,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,e,g,code,html,in,that,case,the,second,pattern,will,be,merged,into,the,first,otherwise,an,code,illegal,argument,exception,will,be,thrown,h3,examples,h3,table,border,1,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,code,null,td,td,code,null,td,td,nbsp,td,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,code,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,if,the,two,patterns,cannot,be,combined;override,public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,if,string,utils,has,text,pattern1,return,pattern2,if,string,utils,has,text,pattern2,return,pattern1,boolean,pattern1contains,uri,var,pattern1,index,of,1,if,pattern1,equals,pattern2,pattern1contains,uri,var,match,pattern1,pattern2,return,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,wild,card,return,concat,pattern1,substring,0,pattern1,length,2,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,double,wild,card,return,concat,pattern1,pattern2,int,star,dot,pos1,pattern1,index,of,if,pattern1contains,uri,var,star,dot,pos1,1,this,path,separator,equals,return,concat,pattern1,pattern2,string,ext1,pattern1,substring,star,dot,pos1,1,int,dot,pos2,pattern2,index,of,string,file2,dot,pos2,1,pattern2,pattern2,substring,0,dot,pos2,string,ext2,dot,pos2,1,pattern2,substring,dot,pos2,boolean,ext1all,ext1,equals,ext1,equals,boolean,ext2all,ext2,equals,ext2,equals,if,ext1all,ext2all,throw,new,illegal,argument,exception,cannot,combine,patterns,pattern1,vs,pattern2,string,ext,ext1all,ext2,ext1,return,file2,ext
AntPathMatcher -> @Override 	public String combine(String pattern1, String pattern2);1493321510;Combine two patterns into a new pattern._<p>This implementation simply concatenates the two patterns, unless_the first pattern contains a file extension match (e.g., {@code *.html})._In that case, the second pattern will be merged into the first. Otherwise,_an {@code IllegalArgumentException} will be thrown._<h3>Examples</h3>_<table border="1">_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr>_<tr><td>{@code null}</td><td>{@code null}</td><td>&nbsp_</td></tr>_<tr><td>/hotels</td><td>{@code null}</td><td>/hotels</td></tr>_<tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>{@code IllegalArgumentException}</td></tr>_</table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException if the two patterns cannot be combined;@Override_	public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}__		boolean pattern1ContainsUriVar = (pattern1.indexOf('{') != -1)__		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {_			_			_			return pattern2__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnWildCard())) {_			return concat(pattern1.substring(0, pattern1.length() - 2), pattern2)__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnDoubleWildCard())) {_			return concat(pattern1, pattern2)__		}__		int starDotPos1 = pattern1.indexOf("*.")__		if (pattern1ContainsUriVar || starDotPos1 == -1 || this.pathSeparator.equals(".")) {_			_			return concat(pattern1, pattern2)__		}__		String ext1 = pattern1.substring(starDotPos1 + 1)__		int dotPos2 = pattern2.indexOf('.')__		String file2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2))__		String ext2 = (dotPos2 == -1 ? "" : pattern2.substring(dotPos2))__		boolean ext1All = (ext1.equals(".*") || ext1.equals(""))__		boolean ext2All = (ext2.equals(".*") || ext2.equals(""))__		if (!ext1All && !ext2All) {_			throw new IllegalArgumentException("Cannot combine patterns: " + pattern1 + " vs " + pattern2)__		}_		String ext = (ext1All ? ext2 : ext1)__		return file2 + ext__	};combine,two,patterns,into,a,new,pattern,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,e,g,code,html,in,that,case,the,second,pattern,will,be,merged,into,the,first,otherwise,an,code,illegal,argument,exception,will,be,thrown,h3,examples,h3,table,border,1,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,code,null,td,td,code,null,td,td,nbsp,td,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,code,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,if,the,two,patterns,cannot,be,combined;override,public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,if,string,utils,has,text,pattern1,return,pattern2,if,string,utils,has,text,pattern2,return,pattern1,boolean,pattern1contains,uri,var,pattern1,index,of,1,if,pattern1,equals,pattern2,pattern1contains,uri,var,match,pattern1,pattern2,return,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,wild,card,return,concat,pattern1,substring,0,pattern1,length,2,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,double,wild,card,return,concat,pattern1,pattern2,int,star,dot,pos1,pattern1,index,of,if,pattern1contains,uri,var,star,dot,pos1,1,this,path,separator,equals,return,concat,pattern1,pattern2,string,ext1,pattern1,substring,star,dot,pos1,1,int,dot,pos2,pattern2,index,of,string,file2,dot,pos2,1,pattern2,pattern2,substring,0,dot,pos2,string,ext2,dot,pos2,1,pattern2,substring,dot,pos2,boolean,ext1all,ext1,equals,ext1,equals,boolean,ext2all,ext2,equals,ext2,equals,if,ext1all,ext2all,throw,new,illegal,argument,exception,cannot,combine,patterns,pattern1,vs,pattern2,string,ext,ext1all,ext2,ext1,return,file2,ext
AntPathMatcher -> @Override 	public String combine(String pattern1, String pattern2);1496259743;Combine two patterns into a new pattern._<p>This implementation simply concatenates the two patterns, unless_the first pattern contains a file extension match (e.g., {@code *.html})._In that case, the second pattern will be merged into the first. Otherwise,_an {@code IllegalArgumentException} will be thrown._<h3>Examples</h3>_<table border="1">_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr>_<tr><td>{@code null}</td><td>{@code null}</td><td>&nbsp_</td></tr>_<tr><td>/hotels</td><td>{@code null}</td><td>/hotels</td></tr>_<tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>{@code IllegalArgumentException}</td></tr>_</table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException if the two patterns cannot be combined;@Override_	public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}__		boolean pattern1ContainsUriVar = (pattern1.indexOf('{') != -1)__		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {_			_			_			return pattern2__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnWildCard())) {_			return concat(pattern1.substring(0, pattern1.length() - 2), pattern2)__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnDoubleWildCard())) {_			return concat(pattern1, pattern2)__		}__		int starDotPos1 = pattern1.indexOf("*.")__		if (pattern1ContainsUriVar || starDotPos1 == -1 || this.pathSeparator.equals(".")) {_			_			return concat(pattern1, pattern2)__		}__		String ext1 = pattern1.substring(starDotPos1 + 1)__		int dotPos2 = pattern2.indexOf('.')__		String file2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2))__		String ext2 = (dotPos2 == -1 ? "" : pattern2.substring(dotPos2))__		boolean ext1All = (ext1.equals(".*") || ext1.equals(""))__		boolean ext2All = (ext2.equals(".*") || ext2.equals(""))__		if (!ext1All && !ext2All) {_			throw new IllegalArgumentException("Cannot combine patterns: " + pattern1 + " vs " + pattern2)__		}_		String ext = (ext1All ? ext2 : ext1)__		return file2 + ext__	};combine,two,patterns,into,a,new,pattern,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,e,g,code,html,in,that,case,the,second,pattern,will,be,merged,into,the,first,otherwise,an,code,illegal,argument,exception,will,be,thrown,h3,examples,h3,table,border,1,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,code,null,td,td,code,null,td,td,nbsp,td,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,code,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,if,the,two,patterns,cannot,be,combined;override,public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,if,string,utils,has,text,pattern1,return,pattern2,if,string,utils,has,text,pattern2,return,pattern1,boolean,pattern1contains,uri,var,pattern1,index,of,1,if,pattern1,equals,pattern2,pattern1contains,uri,var,match,pattern1,pattern2,return,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,wild,card,return,concat,pattern1,substring,0,pattern1,length,2,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,double,wild,card,return,concat,pattern1,pattern2,int,star,dot,pos1,pattern1,index,of,if,pattern1contains,uri,var,star,dot,pos1,1,this,path,separator,equals,return,concat,pattern1,pattern2,string,ext1,pattern1,substring,star,dot,pos1,1,int,dot,pos2,pattern2,index,of,string,file2,dot,pos2,1,pattern2,pattern2,substring,0,dot,pos2,string,ext2,dot,pos2,1,pattern2,substring,dot,pos2,boolean,ext1all,ext1,equals,ext1,equals,boolean,ext2all,ext2,equals,ext2,equals,if,ext1all,ext2all,throw,new,illegal,argument,exception,cannot,combine,patterns,pattern1,vs,pattern2,string,ext,ext1all,ext2,ext1,return,file2,ext
AntPathMatcher -> @Override 	public String combine(String pattern1, String pattern2);1496837955;Combine two patterns into a new pattern._<p>This implementation simply concatenates the two patterns, unless_the first pattern contains a file extension match (e.g., {@code *.html})._In that case, the second pattern will be merged into the first. Otherwise,_an {@code IllegalArgumentException} will be thrown._<h3>Examples</h3>_<table border="1">_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr>_<tr><td>{@code null}</td><td>{@code null}</td><td>&nbsp_</td></tr>_<tr><td>/hotels</td><td>{@code null}</td><td>/hotels</td></tr>_<tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>{@code IllegalArgumentException}</td></tr>_</table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException if the two patterns cannot be combined;@Override_	public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}__		boolean pattern1ContainsUriVar = (pattern1.indexOf('{') != -1)__		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {_			_			_			return pattern2__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnWildCard())) {_			return concat(pattern1.substring(0, pattern1.length() - 2), pattern2)__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnDoubleWildCard())) {_			return concat(pattern1, pattern2)__		}__		int starDotPos1 = pattern1.indexOf("*.")__		if (pattern1ContainsUriVar || starDotPos1 == -1 || this.pathSeparator.equals(".")) {_			_			return concat(pattern1, pattern2)__		}__		String ext1 = pattern1.substring(starDotPos1 + 1)__		int dotPos2 = pattern2.indexOf('.')__		String file2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2))__		String ext2 = (dotPos2 == -1 ? "" : pattern2.substring(dotPos2))__		boolean ext1All = (ext1.equals(".*") || ext1.equals(""))__		boolean ext2All = (ext2.equals(".*") || ext2.equals(""))__		if (!ext1All && !ext2All) {_			throw new IllegalArgumentException("Cannot combine patterns: " + pattern1 + " vs " + pattern2)__		}_		String ext = (ext1All ? ext2 : ext1)__		return file2 + ext__	};combine,two,patterns,into,a,new,pattern,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,e,g,code,html,in,that,case,the,second,pattern,will,be,merged,into,the,first,otherwise,an,code,illegal,argument,exception,will,be,thrown,h3,examples,h3,table,border,1,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,code,null,td,td,code,null,td,td,nbsp,td,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,code,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,if,the,two,patterns,cannot,be,combined;override,public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,if,string,utils,has,text,pattern1,return,pattern2,if,string,utils,has,text,pattern2,return,pattern1,boolean,pattern1contains,uri,var,pattern1,index,of,1,if,pattern1,equals,pattern2,pattern1contains,uri,var,match,pattern1,pattern2,return,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,wild,card,return,concat,pattern1,substring,0,pattern1,length,2,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,double,wild,card,return,concat,pattern1,pattern2,int,star,dot,pos1,pattern1,index,of,if,pattern1contains,uri,var,star,dot,pos1,1,this,path,separator,equals,return,concat,pattern1,pattern2,string,ext1,pattern1,substring,star,dot,pos1,1,int,dot,pos2,pattern2,index,of,string,file2,dot,pos2,1,pattern2,pattern2,substring,0,dot,pos2,string,ext2,dot,pos2,1,pattern2,substring,dot,pos2,boolean,ext1all,ext1,equals,ext1,equals,boolean,ext2all,ext2,equals,ext2,equals,if,ext1all,ext2all,throw,new,illegal,argument,exception,cannot,combine,patterns,pattern1,vs,pattern2,string,ext,ext1all,ext2,ext1,return,file2,ext
AntPathMatcher -> @Override 	public String combine(String pattern1, String pattern2);1498780456;Combine two patterns into a new pattern._<p>This implementation simply concatenates the two patterns, unless_the first pattern contains a file extension match (e.g., {@code *.html})._In that case, the second pattern will be merged into the first. Otherwise,_an {@code IllegalArgumentException} will be thrown._<h3>Examples</h3>_<table border="1">_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr>_<tr><td>{@code null}</td><td>{@code null}</td><td>&nbsp_</td></tr>_<tr><td>/hotels</td><td>{@code null}</td><td>/hotels</td></tr>_<tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>{@code IllegalArgumentException}</td></tr>_</table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException if the two patterns cannot be combined;@Override_	public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}__		boolean pattern1ContainsUriVar = (pattern1.indexOf('{') != -1)__		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {_			_			_			return pattern2__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnWildCard())) {_			return concat(pattern1.substring(0, pattern1.length() - 2), pattern2)__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnDoubleWildCard())) {_			return concat(pattern1, pattern2)__		}__		int starDotPos1 = pattern1.indexOf("*.")__		if (pattern1ContainsUriVar || starDotPos1 == -1 || this.pathSeparator.equals(".")) {_			_			return concat(pattern1, pattern2)__		}__		String ext1 = pattern1.substring(starDotPos1 + 1)__		int dotPos2 = pattern2.indexOf('.')__		String file2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2))__		String ext2 = (dotPos2 == -1 ? "" : pattern2.substring(dotPos2))__		boolean ext1All = (ext1.equals(".*") || ext1.equals(""))__		boolean ext2All = (ext2.equals(".*") || ext2.equals(""))__		if (!ext1All && !ext2All) {_			throw new IllegalArgumentException("Cannot combine patterns: " + pattern1 + " vs " + pattern2)__		}_		String ext = (ext1All ? ext2 : ext1)__		return file2 + ext__	};combine,two,patterns,into,a,new,pattern,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,e,g,code,html,in,that,case,the,second,pattern,will,be,merged,into,the,first,otherwise,an,code,illegal,argument,exception,will,be,thrown,h3,examples,h3,table,border,1,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,code,null,td,td,code,null,td,td,nbsp,td,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,code,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,if,the,two,patterns,cannot,be,combined;override,public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,if,string,utils,has,text,pattern1,return,pattern2,if,string,utils,has,text,pattern2,return,pattern1,boolean,pattern1contains,uri,var,pattern1,index,of,1,if,pattern1,equals,pattern2,pattern1contains,uri,var,match,pattern1,pattern2,return,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,wild,card,return,concat,pattern1,substring,0,pattern1,length,2,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,double,wild,card,return,concat,pattern1,pattern2,int,star,dot,pos1,pattern1,index,of,if,pattern1contains,uri,var,star,dot,pos1,1,this,path,separator,equals,return,concat,pattern1,pattern2,string,ext1,pattern1,substring,star,dot,pos1,1,int,dot,pos2,pattern2,index,of,string,file2,dot,pos2,1,pattern2,pattern2,substring,0,dot,pos2,string,ext2,dot,pos2,1,pattern2,substring,dot,pos2,boolean,ext1all,ext1,equals,ext1,equals,boolean,ext2all,ext2,equals,ext2,equals,if,ext1all,ext2all,throw,new,illegal,argument,exception,cannot,combine,patterns,pattern1,vs,pattern2,string,ext,ext1all,ext2,ext1,return,file2,ext
AntPathMatcher -> @Override 	public String combine(String pattern1, String pattern2);1518772998;Combine two patterns into a new pattern._<p>This implementation simply concatenates the two patterns, unless_the first pattern contains a file extension match (e.g., {@code *.html})._In that case, the second pattern will be merged into the first. Otherwise,_an {@code IllegalArgumentException} will be thrown._<h3>Examples</h3>_<table border="1">_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr>_<tr><td>{@code null}</td><td>{@code null}</td><td>&nbsp_</td></tr>_<tr><td>/hotels</td><td>{@code null}</td><td>/hotels</td></tr>_<tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>{@code IllegalArgumentException}</td></tr>_</table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException if the two patterns cannot be combined;@Override_	public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}__		boolean pattern1ContainsUriVar = (pattern1.indexOf('{') != -1)__		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {_			_			_			return pattern2__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnWildCard())) {_			return concat(pattern1.substring(0, pattern1.length() - 2), pattern2)__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnDoubleWildCard())) {_			return concat(pattern1, pattern2)__		}__		int starDotPos1 = pattern1.indexOf("*.")__		if (pattern1ContainsUriVar || starDotPos1 == -1 || this.pathSeparator.equals(".")) {_			_			return concat(pattern1, pattern2)__		}__		String ext1 = pattern1.substring(starDotPos1 + 1)__		int dotPos2 = pattern2.indexOf('.')__		String file2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2))__		String ext2 = (dotPos2 == -1 ? "" : pattern2.substring(dotPos2))__		boolean ext1All = (ext1.equals(".*") || ext1.equals(""))__		boolean ext2All = (ext2.equals(".*") || ext2.equals(""))__		if (!ext1All && !ext2All) {_			throw new IllegalArgumentException("Cannot combine patterns: " + pattern1 + " vs " + pattern2)__		}_		String ext = (ext1All ? ext2 : ext1)__		return file2 + ext__	};combine,two,patterns,into,a,new,pattern,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,e,g,code,html,in,that,case,the,second,pattern,will,be,merged,into,the,first,otherwise,an,code,illegal,argument,exception,will,be,thrown,h3,examples,h3,table,border,1,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,code,null,td,td,code,null,td,td,nbsp,td,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,code,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,if,the,two,patterns,cannot,be,combined;override,public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,if,string,utils,has,text,pattern1,return,pattern2,if,string,utils,has,text,pattern2,return,pattern1,boolean,pattern1contains,uri,var,pattern1,index,of,1,if,pattern1,equals,pattern2,pattern1contains,uri,var,match,pattern1,pattern2,return,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,wild,card,return,concat,pattern1,substring,0,pattern1,length,2,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,double,wild,card,return,concat,pattern1,pattern2,int,star,dot,pos1,pattern1,index,of,if,pattern1contains,uri,var,star,dot,pos1,1,this,path,separator,equals,return,concat,pattern1,pattern2,string,ext1,pattern1,substring,star,dot,pos1,1,int,dot,pos2,pattern2,index,of,string,file2,dot,pos2,1,pattern2,pattern2,substring,0,dot,pos2,string,ext2,dot,pos2,1,pattern2,substring,dot,pos2,boolean,ext1all,ext1,equals,ext1,equals,boolean,ext2all,ext2,equals,ext2,equals,if,ext1all,ext2all,throw,new,illegal,argument,exception,cannot,combine,patterns,pattern1,vs,pattern2,string,ext,ext1all,ext2,ext1,return,file2,ext
AntPathMatcher -> @Override 	public String combine(String pattern1, String pattern2);1530174524;Combine two patterns into a new pattern._<p>This implementation simply concatenates the two patterns, unless_the first pattern contains a file extension match (e.g., {@code *.html})._In that case, the second pattern will be merged into the first. Otherwise,_an {@code IllegalArgumentException} will be thrown._<h3>Examples</h3>_<table border="1">_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr>_<tr><td>{@code null}</td><td>{@code null}</td><td>&nbsp_</td></tr>_<tr><td>/hotels</td><td>{@code null}</td><td>/hotels</td></tr>_<tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>{@code IllegalArgumentException}</td></tr>_</table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException if the two patterns cannot be combined;@Override_	public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}__		boolean pattern1ContainsUriVar = (pattern1.indexOf('{') != -1)__		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {_			_			_			return pattern2__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnWildCard())) {_			return concat(pattern1.substring(0, pattern1.length() - 2), pattern2)__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnDoubleWildCard())) {_			return concat(pattern1, pattern2)__		}__		int starDotPos1 = pattern1.indexOf("*.")__		if (pattern1ContainsUriVar || starDotPos1 == -1 || this.pathSeparator.equals(".")) {_			_			return concat(pattern1, pattern2)__		}__		String ext1 = pattern1.substring(starDotPos1 + 1)__		int dotPos2 = pattern2.indexOf('.')__		String file2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2))__		String ext2 = (dotPos2 == -1 ? "" : pattern2.substring(dotPos2))__		boolean ext1All = (ext1.equals(".*") || ext1.equals(""))__		boolean ext2All = (ext2.equals(".*") || ext2.equals(""))__		if (!ext1All && !ext2All) {_			throw new IllegalArgumentException("Cannot combine patterns: " + pattern1 + " vs " + pattern2)__		}_		String ext = (ext1All ? ext2 : ext1)__		return file2 + ext__	};combine,two,patterns,into,a,new,pattern,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,e,g,code,html,in,that,case,the,second,pattern,will,be,merged,into,the,first,otherwise,an,code,illegal,argument,exception,will,be,thrown,h3,examples,h3,table,border,1,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,code,null,td,td,code,null,td,td,nbsp,td,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,code,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,if,the,two,patterns,cannot,be,combined;override,public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,if,string,utils,has,text,pattern1,return,pattern2,if,string,utils,has,text,pattern2,return,pattern1,boolean,pattern1contains,uri,var,pattern1,index,of,1,if,pattern1,equals,pattern2,pattern1contains,uri,var,match,pattern1,pattern2,return,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,wild,card,return,concat,pattern1,substring,0,pattern1,length,2,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,double,wild,card,return,concat,pattern1,pattern2,int,star,dot,pos1,pattern1,index,of,if,pattern1contains,uri,var,star,dot,pos1,1,this,path,separator,equals,return,concat,pattern1,pattern2,string,ext1,pattern1,substring,star,dot,pos1,1,int,dot,pos2,pattern2,index,of,string,file2,dot,pos2,1,pattern2,pattern2,substring,0,dot,pos2,string,ext2,dot,pos2,1,pattern2,substring,dot,pos2,boolean,ext1all,ext1,equals,ext1,equals,boolean,ext2all,ext2,equals,ext2,equals,if,ext1all,ext2all,throw,new,illegal,argument,exception,cannot,combine,patterns,pattern1,vs,pattern2,string,ext,ext1all,ext2,ext1,return,file2,ext
AntPathMatcher -> @Override 	public String combine(String pattern1, String pattern2);1530174524;Combine two patterns into a new pattern._<p>This implementation simply concatenates the two patterns, unless_the first pattern contains a file extension match (e.g., {@code *.html})._In that case, the second pattern will be merged into the first. Otherwise,_an {@code IllegalArgumentException} will be thrown._<h3>Examples</h3>_<table border="1">_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr>_<tr><td>{@code null}</td><td>{@code null}</td><td>&nbsp_</td></tr>_<tr><td>/hotels</td><td>{@code null}</td><td>/hotels</td></tr>_<tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>{@code IllegalArgumentException}</td></tr>_</table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException if the two patterns cannot be combined;@Override_	public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}__		boolean pattern1ContainsUriVar = (pattern1.indexOf('{') != -1)__		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {_			_			_			return pattern2__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnWildCard())) {_			return concat(pattern1.substring(0, pattern1.length() - 2), pattern2)__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnDoubleWildCard())) {_			return concat(pattern1, pattern2)__		}__		int starDotPos1 = pattern1.indexOf("*.")__		if (pattern1ContainsUriVar || starDotPos1 == -1 || this.pathSeparator.equals(".")) {_			_			return concat(pattern1, pattern2)__		}__		String ext1 = pattern1.substring(starDotPos1 + 1)__		int dotPos2 = pattern2.indexOf('.')__		String file2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2))__		String ext2 = (dotPos2 == -1 ? "" : pattern2.substring(dotPos2))__		boolean ext1All = (ext1.equals(".*") || ext1.equals(""))__		boolean ext2All = (ext2.equals(".*") || ext2.equals(""))__		if (!ext1All && !ext2All) {_			throw new IllegalArgumentException("Cannot combine patterns: " + pattern1 + " vs " + pattern2)__		}_		String ext = (ext1All ? ext2 : ext1)__		return file2 + ext__	};combine,two,patterns,into,a,new,pattern,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,e,g,code,html,in,that,case,the,second,pattern,will,be,merged,into,the,first,otherwise,an,code,illegal,argument,exception,will,be,thrown,h3,examples,h3,table,border,1,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,code,null,td,td,code,null,td,td,nbsp,td,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,code,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,if,the,two,patterns,cannot,be,combined;override,public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,if,string,utils,has,text,pattern1,return,pattern2,if,string,utils,has,text,pattern2,return,pattern1,boolean,pattern1contains,uri,var,pattern1,index,of,1,if,pattern1,equals,pattern2,pattern1contains,uri,var,match,pattern1,pattern2,return,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,wild,card,return,concat,pattern1,substring,0,pattern1,length,2,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,double,wild,card,return,concat,pattern1,pattern2,int,star,dot,pos1,pattern1,index,of,if,pattern1contains,uri,var,star,dot,pos1,1,this,path,separator,equals,return,concat,pattern1,pattern2,string,ext1,pattern1,substring,star,dot,pos1,1,int,dot,pos2,pattern2,index,of,string,file2,dot,pos2,1,pattern2,pattern2,substring,0,dot,pos2,string,ext2,dot,pos2,1,pattern2,substring,dot,pos2,boolean,ext1all,ext1,equals,ext1,equals,boolean,ext2all,ext2,equals,ext2,equals,if,ext1all,ext2all,throw,new,illegal,argument,exception,cannot,combine,patterns,pattern1,vs,pattern2,string,ext,ext1all,ext2,ext1,return,file2,ext
AntPathMatcher -> @Override 	public String combine(String pattern1, String pattern2);1535316501;Combine two patterns into a new pattern._<p>This implementation simply concatenates the two patterns, unless_the first pattern contains a file extension match (e.g., {@code *.html})._In that case, the second pattern will be merged into the first. Otherwise,_an {@code IllegalArgumentException} will be thrown._<h3>Examples</h3>_<table border="1">_<tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr>_<tr><td>{@code null}</td><td>{@code null}</td><td>&nbsp_</td></tr>_<tr><td>/hotels</td><td>{@code null}</td><td>/hotels</td></tr>_<tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>_<tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>/bookings</td><td>/hotels/&#42_&#42_/bookings</td></tr>_<tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>_<tr><td>/hotels/&#42_&#42_</td><td>{hotel}</td><td>/hotels/&#42_&#42_/{hotel}</td></tr>_<tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>_<tr><td>/*.html</td><td>/*.txt</td><td>{@code IllegalArgumentException}</td></tr>_</table>_@param pattern1 the first pattern_@param pattern2 the second pattern_@return the combination of the two patterns_@throws IllegalArgumentException if the two patterns cannot be combined;@Override_	public String combine(String pattern1, String pattern2) {_		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {_			return ""__		}_		if (!StringUtils.hasText(pattern1)) {_			return pattern2__		}_		if (!StringUtils.hasText(pattern2)) {_			return pattern1__		}__		boolean pattern1ContainsUriVar = (pattern1.indexOf('{') != -1)__		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {_			_			_			return pattern2__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnWildCard())) {_			return concat(pattern1.substring(0, pattern1.length() - 2), pattern2)__		}__		_		_		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnDoubleWildCard())) {_			return concat(pattern1, pattern2)__		}__		int starDotPos1 = pattern1.indexOf("*.")__		if (pattern1ContainsUriVar || starDotPos1 == -1 || this.pathSeparator.equals(".")) {_			_			return concat(pattern1, pattern2)__		}__		String ext1 = pattern1.substring(starDotPos1 + 1)__		int dotPos2 = pattern2.indexOf('.')__		String file2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2))__		String ext2 = (dotPos2 == -1 ? "" : pattern2.substring(dotPos2))__		boolean ext1All = (ext1.equals(".*") || ext1.isEmpty())__		boolean ext2All = (ext2.equals(".*") || ext2.isEmpty())__		if (!ext1All && !ext2All) {_			throw new IllegalArgumentException("Cannot combine patterns: " + pattern1 + " vs " + pattern2)__		}_		String ext = (ext1All ? ext2 : ext1)__		return file2 + ext__	};combine,two,patterns,into,a,new,pattern,p,this,implementation,simply,concatenates,the,two,patterns,unless,the,first,pattern,contains,a,file,extension,match,e,g,code,html,in,that,case,the,second,pattern,will,be,merged,into,the,first,otherwise,an,code,illegal,argument,exception,will,be,thrown,h3,examples,h3,table,border,1,tr,th,pattern,1,th,th,pattern,2,th,th,result,th,tr,tr,td,code,null,td,td,code,null,td,td,nbsp,td,tr,tr,td,hotels,td,td,code,null,td,td,hotels,td,tr,tr,td,code,null,td,td,hotels,td,td,hotels,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,td,td,bookings,td,td,hotels,bookings,td,tr,tr,td,hotels,42,42,td,td,bookings,td,td,hotels,42,42,bookings,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,td,td,hotel,td,td,hotels,hotel,td,tr,tr,td,hotels,42,42,td,td,hotel,td,td,hotels,42,42,hotel,td,tr,tr,td,html,td,td,hotels,html,td,td,hotels,html,td,tr,tr,td,html,td,td,hotels,td,td,hotels,html,td,tr,tr,td,html,td,td,txt,td,td,code,illegal,argument,exception,td,tr,table,param,pattern1,the,first,pattern,param,pattern2,the,second,pattern,return,the,combination,of,the,two,patterns,throws,illegal,argument,exception,if,the,two,patterns,cannot,be,combined;override,public,string,combine,string,pattern1,string,pattern2,if,string,utils,has,text,pattern1,string,utils,has,text,pattern2,return,if,string,utils,has,text,pattern1,return,pattern2,if,string,utils,has,text,pattern2,return,pattern1,boolean,pattern1contains,uri,var,pattern1,index,of,1,if,pattern1,equals,pattern2,pattern1contains,uri,var,match,pattern1,pattern2,return,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,wild,card,return,concat,pattern1,substring,0,pattern1,length,2,pattern2,if,pattern1,ends,with,this,path,separator,pattern,cache,get,ends,on,double,wild,card,return,concat,pattern1,pattern2,int,star,dot,pos1,pattern1,index,of,if,pattern1contains,uri,var,star,dot,pos1,1,this,path,separator,equals,return,concat,pattern1,pattern2,string,ext1,pattern1,substring,star,dot,pos1,1,int,dot,pos2,pattern2,index,of,string,file2,dot,pos2,1,pattern2,pattern2,substring,0,dot,pos2,string,ext2,dot,pos2,1,pattern2,substring,dot,pos2,boolean,ext1all,ext1,equals,ext1,is,empty,boolean,ext2all,ext2,equals,ext2,is,empty,if,ext1all,ext2all,throw,new,illegal,argument,exception,cannot,combine,patterns,pattern1,vs,pattern2,string,ext,ext1all,ext2,ext1,return,file2,ext
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, 			Map<String, String> uriTemplateVariables);1328020251;Actually match the given <code>path</code> against the given <code>pattern</code>._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return <code>true</code> if the supplied <code>path</code> matched, <code>false</code> if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch,_			Map<String, String> uriTemplateVariables) {__		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator)__		String[] pathDirs = StringUtils.tokenizeToStringArray(path, this.pathSeparator)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String patDir = pattDirs[pattIdxStart]__			if ("**".equals(patDir)) {_				break__			}_			if (!matchStrings(patDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) :_						!path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String patDir = pattDirs[pattIdxEnd]__			if (patDir.equals("**")) {_				break__			}_			if (!matchStrings(patDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,code,against,the,given,code,pattern,code,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,code,if,the,supplied,code,path,code,matched,code,false,code,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,string,utils,tokenize,to,string,array,pattern,this,path,separator,string,path,dirs,string,utils,tokenize,to,string,array,path,this,path,separator,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,pat,dir,patt,dirs,patt,idx,start,if,equals,pat,dir,break,if,match,strings,pat,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,pat,dir,patt,dirs,patt,idx,end,if,pat,dir,equals,break,if,match,strings,pat,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, 			Map<String, String> uriTemplateVariables);1333393580;Actually match the given <code>path</code> against the given <code>pattern</code>._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return <code>true</code> if the supplied <code>path</code> matched, <code>false</code> if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch,_			Map<String, String> uriTemplateVariables) {__		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator)__		String[] pathDirs = StringUtils.tokenizeToStringArray(path, this.pathSeparator)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String patDir = pattDirs[pattIdxStart]__			if ("**".equals(patDir)) {_				break__			}_			if (!matchStrings(patDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) :_						!path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String patDir = pattDirs[pattIdxEnd]__			if (patDir.equals("**")) {_				break__			}_			if (!matchStrings(patDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,code,against,the,given,code,pattern,code,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,code,if,the,supplied,code,path,code,matched,code,false,code,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,string,utils,tokenize,to,string,array,pattern,this,path,separator,string,path,dirs,string,utils,tokenize,to,string,array,path,this,path,separator,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,pat,dir,patt,dirs,patt,idx,start,if,equals,pat,dir,break,if,match,strings,pat,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,pat,dir,patt,dirs,patt,idx,end,if,pat,dir,equals,break,if,match,strings,pat,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, 			Map<String, String> uriTemplateVariables);1347310630;Actually match the given <code>path</code> against the given <code>pattern</code>._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return <code>true</code> if the supplied <code>path</code> matched, <code>false</code> if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch,_			Map<String, String> uriTemplateVariables) {__		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator)__		String[] pathDirs = StringUtils.tokenizeToStringArray(path, this.pathSeparator)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String patDir = pattDirs[pattIdxStart]__			if ("**".equals(patDir)) {_				break__			}_			if (!matchStrings(patDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) :_						!path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String patDir = pattDirs[pattIdxEnd]__			if (patDir.equals("**")) {_				break__			}_			if (!matchStrings(patDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,code,against,the,given,code,pattern,code,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,code,if,the,supplied,code,path,code,matched,code,false,code,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,string,utils,tokenize,to,string,array,pattern,this,path,separator,string,path,dirs,string,utils,tokenize,to,string,array,path,this,path,separator,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,pat,dir,patt,dirs,patt,idx,start,if,equals,pat,dir,break,if,match,strings,pat,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,pat,dir,patt,dirs,patt,idx,end,if,pat,dir,equals,break,if,match,strings,pat,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, 			Map<String, String> uriTemplateVariables);1355351965;Actually match the given <code>path</code> against the given <code>pattern</code>._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return <code>true</code> if the supplied <code>path</code> matched, <code>false</code> if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch,_			Map<String, String> uriTemplateVariables) {__		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator)__		String[] pathDirs = StringUtils.tokenizeToStringArray(path, this.pathSeparator)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String patDir = pattDirs[pattIdxStart]__			if ("**".equals(patDir)) {_				break__			}_			if (!matchStrings(patDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) :_						!path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String patDir = pattDirs[pattIdxEnd]__			if (patDir.equals("**")) {_				break__			}_			if (!matchStrings(patDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,code,against,the,given,code,pattern,code,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,code,if,the,supplied,code,path,code,matched,code,false,code,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,string,utils,tokenize,to,string,array,pattern,this,path,separator,string,path,dirs,string,utils,tokenize,to,string,array,path,this,path,separator,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,pat,dir,patt,dirs,patt,idx,start,if,equals,pat,dir,break,if,match,strings,pat,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,pat,dir,patt,dirs,patt,idx,end,if,pat,dir,equals,break,if,match,strings,pat,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, 			Map<String, String> uriTemplateVariables);1356735495;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch,_			Map<String, String> uriTemplateVariables) {__		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator)__		String[] pathDirs = StringUtils.tokenizeToStringArray(path, this.pathSeparator)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String patDir = pattDirs[pattIdxStart]__			if ("**".equals(patDir)) {_				break__			}_			if (!matchStrings(patDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) :_						!path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String patDir = pattDirs[pattIdxEnd]__			if (patDir.equals("**")) {_				break__			}_			if (!matchStrings(patDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,string,utils,tokenize,to,string,array,pattern,this,path,separator,string,path,dirs,string,utils,tokenize,to,string,array,path,this,path,separator,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,pat,dir,patt,dirs,patt,idx,start,if,equals,pat,dir,break,if,match,strings,pat,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,pat,dir,patt,dirs,patt,idx,end,if,pat,dir,equals,break,if,match,strings,pat,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, 			Map<String, String> uriTemplateVariables);1357119239;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch,_			Map<String, String> uriTemplateVariables) {__		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator)__		String[] pathDirs = StringUtils.tokenizeToStringArray(path, this.pathSeparator)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String patDir = pattDirs[pattIdxStart]__			if ("**".equals(patDir)) {_				break__			}_			if (!matchStrings(patDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) :_						!path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String patDir = pattDirs[pattIdxEnd]__			if (patDir.equals("**")) {_				break__			}_			if (!matchStrings(patDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,string,utils,tokenize,to,string,array,pattern,this,path,separator,string,path,dirs,string,utils,tokenize,to,string,array,path,this,path,separator,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,pat,dir,patt,dirs,patt,idx,start,if,equals,pat,dir,break,if,match,strings,pat,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,pat,dir,patt,dirs,patt,idx,end,if,pat,dir,equals,break,if,match,strings,pat,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, 			Map<String, String> uriTemplateVariables);1362408075;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch,_			Map<String, String> uriTemplateVariables) {__		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathDirs = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String patDir = pattDirs[pattIdxStart]__			if ("**".equals(patDir)) {_				break__			}_			if (!matchStrings(patDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) :_						!path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String patDir = pattDirs[pattIdxEnd]__			if (patDir.equals("**")) {_				break__			}_			if (!matchStrings(patDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,dirs,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,pat,dir,patt,dirs,patt,idx,start,if,equals,pat,dir,break,if,match,strings,pat,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,pat,dir,patt,dirs,patt,idx,end,if,pat,dir,equals,break,if,match,strings,pat,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, 			Map<String, String> uriTemplateVariables);1368482696;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch,_			Map<String, String> uriTemplateVariables) {__		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathDirs = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String patDir = pattDirs[pattIdxStart]__			if ("**".equals(patDir)) {_				break__			}_			if (!matchStrings(patDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) :_						!path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String patDir = pattDirs[pattIdxEnd]__			if (patDir.equals("**")) {_				break__			}_			if (!matchStrings(patDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,dirs,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,pat,dir,patt,dirs,patt,idx,start,if,equals,pat,dir,break,if,match,strings,pat,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,pat,dir,patt,dirs,patt,idx,end,if,pat,dir,equals,break,if,match,strings,pat,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, 			Map<String, String> uriTemplateVariables);1377725408;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch,_			Map<String, String> uriTemplateVariables) {__		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathDirs = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String patDir = pattDirs[pattIdxStart]__			if ("**".equals(patDir)) {_				break__			}_			if (!matchStrings(patDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) :_						!path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String patDir = pattDirs[pattIdxEnd]__			if (patDir.equals("**")) {_				break__			}_			if (!matchStrings(patDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,dirs,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,pat,dir,patt,dirs,patt,idx,start,if,equals,pat,dir,break,if,match,strings,pat,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,pat,dir,patt,dirs,patt,idx,end,if,pat,dir,equals,break,if,match,strings,pat,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> protected boolean doMatch(String pattern, String path, boolean fullMatch, 			Map<String, String> uriTemplateVariables);1377735685;Actually match the given {@code path} against the given {@code pattern}._@param pattern the pattern to match against_@param path the path String to test_@param fullMatch whether a full pattern match is required (else a pattern match_as far as the given base path goes is sufficient)_@return {@code true} if the supplied {@code path} matched, {@code false} if it didn't;protected boolean doMatch(String pattern, String path, boolean fullMatch,_			Map<String, String> uriTemplateVariables) {__		if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {_			return false__		}__		String[] pattDirs = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true)__		String[] pathDirs = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true)___		int pattIdxStart = 0__		int pattIdxEnd = pattDirs.length - 1__		int pathIdxStart = 0__		int pathIdxEnd = pathDirs.length - 1___		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String patDir = pattDirs[pattIdxStart]__			if ("**".equals(patDir)) {_				break__			}_			if (!matchStrings(patDir, pathDirs[pathIdxStart], uriTemplateVariables)) {_				return false__			}_			pattIdxStart++__			pathIdxStart++__		}__		if (pathIdxStart > pathIdxEnd) {_			_			if (pattIdxStart > pattIdxEnd) {_				return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) :_						!path.endsWith(this.pathSeparator))__			}_			if (!fullMatch) {_				return true__			}_			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {_				return true__			}_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}_		else if (pattIdxStart > pattIdxEnd) {_			_			return false__		}_		else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {_			_			return true__		}__		_		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			String patDir = pattDirs[pattIdxEnd]__			if (patDir.equals("**")) {_				break__			}_			if (!matchStrings(patDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {_				return false__			}_			pattIdxEnd--__			pathIdxEnd--__		}_		if (pathIdxStart > pathIdxEnd) {_			_			for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_				if (!pattDirs[i].equals("**")) {_					return false__				}_			}_			return true__		}__		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {_			int patIdxTmp = -1__			for (int i = pattIdxStart + 1_ i <= pattIdxEnd_ i++) {_				if (pattDirs[i].equals("**")) {_					patIdxTmp = i__					break__				}_			}_			if (patIdxTmp == pattIdxStart + 1) {_				_				pattIdxStart++__				continue__			}_			_			_			int patLength = (patIdxTmp - pattIdxStart - 1)__			int strLength = (pathIdxEnd - pathIdxStart + 1)__			int foundIdx = -1___			strLoop:_			for (int i = 0_ i <= strLength - patLength_ i++) {_				for (int j = 0_ j < patLength_ j++) {_					String subPat = pattDirs[pattIdxStart + j + 1]__					String subStr = pathDirs[pathIdxStart + i + j]__					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {_						continue strLoop__					}_				}_				foundIdx = pathIdxStart + i__				break__			}__			if (foundIdx == -1) {_				return false__			}__			pattIdxStart = patIdxTmp__			pathIdxStart = foundIdx + patLength__		}__		for (int i = pattIdxStart_ i <= pattIdxEnd_ i++) {_			if (!pattDirs[i].equals("**")) {_				return false__			}_		}__		return true__	};actually,match,the,given,code,path,against,the,given,code,pattern,param,pattern,the,pattern,to,match,against,param,path,the,path,string,to,test,param,full,match,whether,a,full,pattern,match,is,required,else,a,pattern,match,as,far,as,the,given,base,path,goes,is,sufficient,return,code,true,if,the,supplied,code,path,matched,code,false,if,it,didn,t;protected,boolean,do,match,string,pattern,string,path,boolean,full,match,map,string,string,uri,template,variables,if,path,starts,with,this,path,separator,pattern,starts,with,this,path,separator,return,false,string,patt,dirs,string,utils,tokenize,to,string,array,pattern,this,path,separator,this,trim,tokens,true,string,path,dirs,string,utils,tokenize,to,string,array,path,this,path,separator,this,trim,tokens,true,int,patt,idx,start,0,int,patt,idx,end,patt,dirs,length,1,int,path,idx,start,0,int,path,idx,end,path,dirs,length,1,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,pat,dir,patt,dirs,patt,idx,start,if,equals,pat,dir,break,if,match,strings,pat,dir,path,dirs,path,idx,start,uri,template,variables,return,false,patt,idx,start,path,idx,start,if,path,idx,start,path,idx,end,if,patt,idx,start,patt,idx,end,return,pattern,ends,with,this,path,separator,path,ends,with,this,path,separator,path,ends,with,this,path,separator,if,full,match,return,true,if,patt,idx,start,patt,idx,end,patt,dirs,patt,idx,start,equals,path,ends,with,this,path,separator,return,true,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,else,if,patt,idx,start,patt,idx,end,return,false,else,if,full,match,equals,patt,dirs,patt,idx,start,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,string,pat,dir,patt,dirs,patt,idx,end,if,pat,dir,equals,break,if,match,strings,pat,dir,path,dirs,path,idx,end,uri,template,variables,return,false,patt,idx,end,path,idx,end,if,path,idx,start,path,idx,end,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true,while,patt,idx,start,patt,idx,end,path,idx,start,path,idx,end,int,pat,idx,tmp,1,for,int,i,patt,idx,start,1,i,patt,idx,end,i,if,patt,dirs,i,equals,pat,idx,tmp,i,break,if,pat,idx,tmp,patt,idx,start,1,patt,idx,start,continue,int,pat,length,pat,idx,tmp,patt,idx,start,1,int,str,length,path,idx,end,path,idx,start,1,int,found,idx,1,str,loop,for,int,i,0,i,str,length,pat,length,i,for,int,j,0,j,pat,length,j,string,sub,pat,patt,dirs,patt,idx,start,j,1,string,sub,str,path,dirs,path,idx,start,i,j,if,match,strings,sub,pat,sub,str,uri,template,variables,continue,str,loop,found,idx,path,idx,start,i,break,if,found,idx,1,return,false,patt,idx,start,pat,idx,tmp,path,idx,start,found,idx,pat,length,for,int,i,patt,idx,start,i,patt,idx,end,i,if,patt,dirs,i,equals,return,false,return,true
AntPathMatcher -> public void setCachePatterns(boolean cachePatterns);1383090798;Specify whether to cache parsed pattern metadata for patterns passed_into this matcher's {@link #match} method. A value of {@code true}_activates an unlimited pattern cache_ a value of {@code false} turns_the pattern cache off completely._<p>Default is for the cache to be on, but with the variant to automatically_turn it off when encountering too many patterns to cache at runtime_(the threshold is 65536), assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a reoccurring pattern._@see #getStringMatcher(String);public void setCachePatterns(boolean cachePatterns) {_		this.cachePatterns = cachePatterns__	};specify,whether,to,cache,parsed,pattern,metadata,for,patterns,passed,into,this,matcher,s,link,match,method,a,value,of,code,true,activates,an,unlimited,pattern,cache,a,value,of,code,false,turns,the,pattern,cache,off,completely,p,default,is,for,the,cache,to,be,on,but,with,the,variant,to,automatically,turn,it,off,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,reoccurring,pattern,see,get,string,matcher,string;public,void,set,cache,patterns,boolean,cache,patterns,this,cache,patterns,cache,patterns
AntPathMatcher -> public void setCachePatterns(boolean cachePatterns);1383157688;Specify whether to cache parsed pattern metadata for patterns passed_into this matcher's {@link #match} method. A value of {@code true}_activates an unlimited pattern cache_ a value of {@code false} turns_the pattern cache off completely._<p>Default is for the cache to be on, but with the variant to automatically_turn it off when encountering too many patterns to cache at runtime_(the threshold is 65536), assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a reoccurring pattern._@see #getStringMatcher(String);public void setCachePatterns(boolean cachePatterns) {_		this.cachePatterns = cachePatterns__	};specify,whether,to,cache,parsed,pattern,metadata,for,patterns,passed,into,this,matcher,s,link,match,method,a,value,of,code,true,activates,an,unlimited,pattern,cache,a,value,of,code,false,turns,the,pattern,cache,off,completely,p,default,is,for,the,cache,to,be,on,but,with,the,variant,to,automatically,turn,it,off,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,reoccurring,pattern,see,get,string,matcher,string;public,void,set,cache,patterns,boolean,cache,patterns,this,cache,patterns,cache,patterns
AntPathMatcher -> public void setCachePatterns(boolean cachePatterns);1385501137;Specify whether to cache parsed pattern metadata for patterns passed_into this matcher's {@link #match} method. A value of {@code true}_activates an unlimited pattern cache_ a value of {@code false} turns_the pattern cache off completely._<p>Default is for the cache to be on, but with the variant to automatically_turn it off when encountering too many patterns to cache at runtime_(the threshold is 65536), assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a reoccurring pattern._@see #getStringMatcher(String);public void setCachePatterns(boolean cachePatterns) {_		this.cachePatterns = cachePatterns__	};specify,whether,to,cache,parsed,pattern,metadata,for,patterns,passed,into,this,matcher,s,link,match,method,a,value,of,code,true,activates,an,unlimited,pattern,cache,a,value,of,code,false,turns,the,pattern,cache,off,completely,p,default,is,for,the,cache,to,be,on,but,with,the,variant,to,automatically,turn,it,off,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,reoccurring,pattern,see,get,string,matcher,string;public,void,set,cache,patterns,boolean,cache,patterns,this,cache,patterns,cache,patterns
AntPathMatcher -> public void setCachePatterns(boolean cachePatterns);1388766826;Specify whether to cache parsed pattern metadata for patterns passed_into this matcher's {@link #match} method. A value of {@code true}_activates an unlimited pattern cache_ a value of {@code false} turns_the pattern cache off completely._<p>Default is for the cache to be on, but with the variant to automatically_turn it off when encountering too many patterns to cache at runtime_(the threshold is 65536), assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a reoccurring pattern._@see #getStringMatcher(String);public void setCachePatterns(boolean cachePatterns) {_		this.cachePatterns = cachePatterns__	};specify,whether,to,cache,parsed,pattern,metadata,for,patterns,passed,into,this,matcher,s,link,match,method,a,value,of,code,true,activates,an,unlimited,pattern,cache,a,value,of,code,false,turns,the,pattern,cache,off,completely,p,default,is,for,the,cache,to,be,on,but,with,the,variant,to,automatically,turn,it,off,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,reoccurring,pattern,see,get,string,matcher,string;public,void,set,cache,patterns,boolean,cache,patterns,this,cache,patterns,cache,patterns
AntPathMatcher -> public void setCachePatterns(boolean cachePatterns);1402512669;Specify whether to cache parsed pattern metadata for patterns passed_into this matcher's {@link #match} method. A value of {@code true}_activates an unlimited pattern cache_ a value of {@code false} turns_the pattern cache off completely._<p>Default is for the cache to be on, but with the variant to automatically_turn it off when encountering too many patterns to cache at runtime_(the threshold is 65536), assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a reoccurring pattern._@see #getStringMatcher(String);public void setCachePatterns(boolean cachePatterns) {_		this.cachePatterns = cachePatterns__	};specify,whether,to,cache,parsed,pattern,metadata,for,patterns,passed,into,this,matcher,s,link,match,method,a,value,of,code,true,activates,an,unlimited,pattern,cache,a,value,of,code,false,turns,the,pattern,cache,off,completely,p,default,is,for,the,cache,to,be,on,but,with,the,variant,to,automatically,turn,it,off,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,reoccurring,pattern,see,get,string,matcher,string;public,void,set,cache,patterns,boolean,cache,patterns,this,cache,patterns,cache,patterns
AntPathMatcher -> public void setCachePatterns(boolean cachePatterns);1402512669;Specify whether to cache parsed pattern metadata for patterns passed_into this matcher's {@link #match} method. A value of {@code true}_activates an unlimited pattern cache_ a value of {@code false} turns_the pattern cache off completely._<p>Default is for the cache to be on, but with the variant to automatically_turn it off when encountering too many patterns to cache at runtime_(the threshold is 65536), assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a reoccurring pattern._@see #getStringMatcher(String);public void setCachePatterns(boolean cachePatterns) {_		this.cachePatterns = cachePatterns__	};specify,whether,to,cache,parsed,pattern,metadata,for,patterns,passed,into,this,matcher,s,link,match,method,a,value,of,code,true,activates,an,unlimited,pattern,cache,a,value,of,code,false,turns,the,pattern,cache,off,completely,p,default,is,for,the,cache,to,be,on,but,with,the,variant,to,automatically,turn,it,off,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,reoccurring,pattern,see,get,string,matcher,string;public,void,set,cache,patterns,boolean,cache,patterns,this,cache,patterns,cache,patterns
AntPathMatcher -> public void setCachePatterns(boolean cachePatterns);1402512669;Specify whether to cache parsed pattern metadata for patterns passed_into this matcher's {@link #match} method. A value of {@code true}_activates an unlimited pattern cache_ a value of {@code false} turns_the pattern cache off completely._<p>Default is for the cache to be on, but with the variant to automatically_turn it off when encountering too many patterns to cache at runtime_(the threshold is 65536), assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a reoccurring pattern._@see #getStringMatcher(String);public void setCachePatterns(boolean cachePatterns) {_		this.cachePatterns = cachePatterns__	};specify,whether,to,cache,parsed,pattern,metadata,for,patterns,passed,into,this,matcher,s,link,match,method,a,value,of,code,true,activates,an,unlimited,pattern,cache,a,value,of,code,false,turns,the,pattern,cache,off,completely,p,default,is,for,the,cache,to,be,on,but,with,the,variant,to,automatically,turn,it,off,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,reoccurring,pattern,see,get,string,matcher,string;public,void,set,cache,patterns,boolean,cache,patterns,this,cache,patterns,cache,patterns
AntPathMatcher -> public void setCachePatterns(boolean cachePatterns);1405378164;Specify whether to cache parsed pattern metadata for patterns passed_into this matcher's {@link #match} method. A value of {@code true}_activates an unlimited pattern cache_ a value of {@code false} turns_the pattern cache off completely._<p>Default is for the cache to be on, but with the variant to automatically_turn it off when encountering too many patterns to cache at runtime_(the threshold is 65536), assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a reoccurring pattern._@see #getStringMatcher(String);public void setCachePatterns(boolean cachePatterns) {_		this.cachePatterns = cachePatterns__	};specify,whether,to,cache,parsed,pattern,metadata,for,patterns,passed,into,this,matcher,s,link,match,method,a,value,of,code,true,activates,an,unlimited,pattern,cache,a,value,of,code,false,turns,the,pattern,cache,off,completely,p,default,is,for,the,cache,to,be,on,but,with,the,variant,to,automatically,turn,it,off,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,reoccurring,pattern,see,get,string,matcher,string;public,void,set,cache,patterns,boolean,cache,patterns,this,cache,patterns,cache,patterns
AntPathMatcher -> public void setCachePatterns(boolean cachePatterns);1405378165;Specify whether to cache parsed pattern metadata for patterns passed_into this matcher's {@link #match} method. A value of {@code true}_activates an unlimited pattern cache_ a value of {@code false} turns_the pattern cache off completely._<p>Default is for the cache to be on, but with the variant to automatically_turn it off when encountering too many patterns to cache at runtime_(the threshold is 65536), assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a reoccurring pattern._@see #getStringMatcher(String);public void setCachePatterns(boolean cachePatterns) {_		this.cachePatterns = cachePatterns__	};specify,whether,to,cache,parsed,pattern,metadata,for,patterns,passed,into,this,matcher,s,link,match,method,a,value,of,code,true,activates,an,unlimited,pattern,cache,a,value,of,code,false,turns,the,pattern,cache,off,completely,p,default,is,for,the,cache,to,be,on,but,with,the,variant,to,automatically,turn,it,off,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,reoccurring,pattern,see,get,string,matcher,string;public,void,set,cache,patterns,boolean,cache,patterns,this,cache,patterns,cache,patterns
AntPathMatcher -> public void setCachePatterns(boolean cachePatterns);1405696918;Specify whether to cache parsed pattern metadata for patterns passed_into this matcher's {@link #match} method. A value of {@code true}_activates an unlimited pattern cache_ a value of {@code false} turns_the pattern cache off completely._<p>Default is for the cache to be on, but with the variant to automatically_turn it off when encountering too many patterns to cache at runtime_(the threshold is 65536), assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a reoccurring pattern._@see #getStringMatcher(String);public void setCachePatterns(boolean cachePatterns) {_		this.cachePatterns = cachePatterns__	};specify,whether,to,cache,parsed,pattern,metadata,for,patterns,passed,into,this,matcher,s,link,match,method,a,value,of,code,true,activates,an,unlimited,pattern,cache,a,value,of,code,false,turns,the,pattern,cache,off,completely,p,default,is,for,the,cache,to,be,on,but,with,the,variant,to,automatically,turn,it,off,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,reoccurring,pattern,see,get,string,matcher,string;public,void,set,cache,patterns,boolean,cache,patterns,this,cache,patterns,cache,patterns
AntPathMatcher -> public void setCachePatterns(boolean cachePatterns);1409784938;Specify whether to cache parsed pattern metadata for patterns passed_into this matcher's {@link #match} method. A value of {@code true}_activates an unlimited pattern cache_ a value of {@code false} turns_the pattern cache off completely._<p>Default is for the cache to be on, but with the variant to automatically_turn it off when encountering too many patterns to cache at runtime_(the threshold is 65536), assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a reoccurring pattern._@see #getStringMatcher(String);public void setCachePatterns(boolean cachePatterns) {_		this.cachePatterns = cachePatterns__	};specify,whether,to,cache,parsed,pattern,metadata,for,patterns,passed,into,this,matcher,s,link,match,method,a,value,of,code,true,activates,an,unlimited,pattern,cache,a,value,of,code,false,turns,the,pattern,cache,off,completely,p,default,is,for,the,cache,to,be,on,but,with,the,variant,to,automatically,turn,it,off,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,reoccurring,pattern,see,get,string,matcher,string;public,void,set,cache,patterns,boolean,cache,patterns,this,cache,patterns,cache,patterns
AntPathMatcher -> public void setCachePatterns(boolean cachePatterns);1412083966;Specify whether to cache parsed pattern metadata for patterns passed_into this matcher's {@link #match} method. A value of {@code true}_activates an unlimited pattern cache_ a value of {@code false} turns_the pattern cache off completely._<p>Default is for the cache to be on, but with the variant to automatically_turn it off when encountering too many patterns to cache at runtime_(the threshold is 65536), assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a reoccurring pattern._@see #getStringMatcher(String);public void setCachePatterns(boolean cachePatterns) {_		this.cachePatterns = cachePatterns__	};specify,whether,to,cache,parsed,pattern,metadata,for,patterns,passed,into,this,matcher,s,link,match,method,a,value,of,code,true,activates,an,unlimited,pattern,cache,a,value,of,code,false,turns,the,pattern,cache,off,completely,p,default,is,for,the,cache,to,be,on,but,with,the,variant,to,automatically,turn,it,off,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,reoccurring,pattern,see,get,string,matcher,string;public,void,set,cache,patterns,boolean,cache,patterns,this,cache,patterns,cache,patterns
AntPathMatcher -> public void setCachePatterns(boolean cachePatterns);1412101078;Specify whether to cache parsed pattern metadata for patterns passed_into this matcher's {@link #match} method. A value of {@code true}_activates an unlimited pattern cache_ a value of {@code false} turns_the pattern cache off completely._<p>Default is for the cache to be on, but with the variant to automatically_turn it off when encountering too many patterns to cache at runtime_(the threshold is 65536), assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a reoccurring pattern._@see #getStringMatcher(String);public void setCachePatterns(boolean cachePatterns) {_		this.cachePatterns = cachePatterns__	};specify,whether,to,cache,parsed,pattern,metadata,for,patterns,passed,into,this,matcher,s,link,match,method,a,value,of,code,true,activates,an,unlimited,pattern,cache,a,value,of,code,false,turns,the,pattern,cache,off,completely,p,default,is,for,the,cache,to,be,on,but,with,the,variant,to,automatically,turn,it,off,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,reoccurring,pattern,see,get,string,matcher,string;public,void,set,cache,patterns,boolean,cache,patterns,this,cache,patterns,cache,patterns
AntPathMatcher -> public void setCachePatterns(boolean cachePatterns);1431086052;Specify whether to cache parsed pattern metadata for patterns passed_into this matcher's {@link #match} method. A value of {@code true}_activates an unlimited pattern cache_ a value of {@code false} turns_the pattern cache off completely._<p>Default is for the cache to be on, but with the variant to automatically_turn it off when encountering too many patterns to cache at runtime_(the threshold is 65536), assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._@see #getStringMatcher(String);public void setCachePatterns(boolean cachePatterns) {_		this.cachePatterns = cachePatterns__	};specify,whether,to,cache,parsed,pattern,metadata,for,patterns,passed,into,this,matcher,s,link,match,method,a,value,of,code,true,activates,an,unlimited,pattern,cache,a,value,of,code,false,turns,the,pattern,cache,off,completely,p,default,is,for,the,cache,to,be,on,but,with,the,variant,to,automatically,turn,it,off,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,see,get,string,matcher,string;public,void,set,cache,patterns,boolean,cache,patterns,this,cache,patterns,cache,patterns
AntPathMatcher -> public void setCachePatterns(boolean cachePatterns);1431178173;Specify whether to cache parsed pattern metadata for patterns passed_into this matcher's {@link #match} method. A value of {@code true}_activates an unlimited pattern cache_ a value of {@code false} turns_the pattern cache off completely._<p>Default is for the cache to be on, but with the variant to automatically_turn it off when encountering too many patterns to cache at runtime_(the threshold is 65536), assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._@see #getStringMatcher(String);public void setCachePatterns(boolean cachePatterns) {_		this.cachePatterns = cachePatterns__	};specify,whether,to,cache,parsed,pattern,metadata,for,patterns,passed,into,this,matcher,s,link,match,method,a,value,of,code,true,activates,an,unlimited,pattern,cache,a,value,of,code,false,turns,the,pattern,cache,off,completely,p,default,is,for,the,cache,to,be,on,but,with,the,variant,to,automatically,turn,it,off,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,see,get,string,matcher,string;public,void,set,cache,patterns,boolean,cache,patterns,this,cache,patterns,cache,patterns
AntPathMatcher -> public void setCachePatterns(boolean cachePatterns);1434572159;Specify whether to cache parsed pattern metadata for patterns passed_into this matcher's {@link #match} method. A value of {@code true}_activates an unlimited pattern cache_ a value of {@code false} turns_the pattern cache off completely._<p>Default is for the cache to be on, but with the variant to automatically_turn it off when encountering too many patterns to cache at runtime_(the threshold is 65536), assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._@see #getStringMatcher(String);public void setCachePatterns(boolean cachePatterns) {_		this.cachePatterns = cachePatterns__	};specify,whether,to,cache,parsed,pattern,metadata,for,patterns,passed,into,this,matcher,s,link,match,method,a,value,of,code,true,activates,an,unlimited,pattern,cache,a,value,of,code,false,turns,the,pattern,cache,off,completely,p,default,is,for,the,cache,to,be,on,but,with,the,variant,to,automatically,turn,it,off,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,see,get,string,matcher,string;public,void,set,cache,patterns,boolean,cache,patterns,this,cache,patterns,cache,patterns
AntPathMatcher -> public void setCachePatterns(boolean cachePatterns);1435239719;Specify whether to cache parsed pattern metadata for patterns passed_into this matcher's {@link #match} method. A value of {@code true}_activates an unlimited pattern cache_ a value of {@code false} turns_the pattern cache off completely._<p>Default is for the cache to be on, but with the variant to automatically_turn it off when encountering too many patterns to cache at runtime_(the threshold is 65536), assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._@see #getStringMatcher(String);public void setCachePatterns(boolean cachePatterns) {_		this.cachePatterns = cachePatterns__	};specify,whether,to,cache,parsed,pattern,metadata,for,patterns,passed,into,this,matcher,s,link,match,method,a,value,of,code,true,activates,an,unlimited,pattern,cache,a,value,of,code,false,turns,the,pattern,cache,off,completely,p,default,is,for,the,cache,to,be,on,but,with,the,variant,to,automatically,turn,it,off,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,see,get,string,matcher,string;public,void,set,cache,patterns,boolean,cache,patterns,this,cache,patterns,cache,patterns
AntPathMatcher -> public void setCachePatterns(boolean cachePatterns);1438166321;Specify whether to cache parsed pattern metadata for patterns passed_into this matcher's {@link #match} method. A value of {@code true}_activates an unlimited pattern cache_ a value of {@code false} turns_the pattern cache off completely._<p>Default is for the cache to be on, but with the variant to automatically_turn it off when encountering too many patterns to cache at runtime_(the threshold is 65536), assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._@since 4.0.1_@see #getStringMatcher(String);public void setCachePatterns(boolean cachePatterns) {_		this.cachePatterns = cachePatterns__	};specify,whether,to,cache,parsed,pattern,metadata,for,patterns,passed,into,this,matcher,s,link,match,method,a,value,of,code,true,activates,an,unlimited,pattern,cache,a,value,of,code,false,turns,the,pattern,cache,off,completely,p,default,is,for,the,cache,to,be,on,but,with,the,variant,to,automatically,turn,it,off,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,since,4,0,1,see,get,string,matcher,string;public,void,set,cache,patterns,boolean,cache,patterns,this,cache,patterns,cache,patterns
AntPathMatcher -> public void setCachePatterns(boolean cachePatterns);1455100778;Specify whether to cache parsed pattern metadata for patterns passed_into this matcher's {@link #match} method. A value of {@code true}_activates an unlimited pattern cache_ a value of {@code false} turns_the pattern cache off completely._<p>Default is for the cache to be on, but with the variant to automatically_turn it off when encountering too many patterns to cache at runtime_(the threshold is 65536), assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._@since 4.0.1_@see #getStringMatcher(String);public void setCachePatterns(boolean cachePatterns) {_		this.cachePatterns = cachePatterns__	};specify,whether,to,cache,parsed,pattern,metadata,for,patterns,passed,into,this,matcher,s,link,match,method,a,value,of,code,true,activates,an,unlimited,pattern,cache,a,value,of,code,false,turns,the,pattern,cache,off,completely,p,default,is,for,the,cache,to,be,on,but,with,the,variant,to,automatically,turn,it,off,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,since,4,0,1,see,get,string,matcher,string;public,void,set,cache,patterns,boolean,cache,patterns,this,cache,patterns,cache,patterns
AntPathMatcher -> public void setCachePatterns(boolean cachePatterns);1455850198;Specify whether to cache parsed pattern metadata for patterns passed_into this matcher's {@link #match} method. A value of {@code true}_activates an unlimited pattern cache_ a value of {@code false} turns_the pattern cache off completely._<p>Default is for the cache to be on, but with the variant to automatically_turn it off when encountering too many patterns to cache at runtime_(the threshold is 65536), assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._@since 4.0.1_@see #getStringMatcher(String);public void setCachePatterns(boolean cachePatterns) {_		this.cachePatterns = cachePatterns__	};specify,whether,to,cache,parsed,pattern,metadata,for,patterns,passed,into,this,matcher,s,link,match,method,a,value,of,code,true,activates,an,unlimited,pattern,cache,a,value,of,code,false,turns,the,pattern,cache,off,completely,p,default,is,for,the,cache,to,be,on,but,with,the,variant,to,automatically,turn,it,off,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,since,4,0,1,see,get,string,matcher,string;public,void,set,cache,patterns,boolean,cache,patterns,this,cache,patterns,cache,patterns
AntPathMatcher -> public void setCachePatterns(boolean cachePatterns);1460754629;Specify whether to cache parsed pattern metadata for patterns passed_into this matcher's {@link #match} method. A value of {@code true}_activates an unlimited pattern cache_ a value of {@code false} turns_the pattern cache off completely._<p>Default is for the cache to be on, but with the variant to automatically_turn it off when encountering too many patterns to cache at runtime_(the threshold is 65536), assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._@since 4.0.1_@see #getStringMatcher(String);public void setCachePatterns(boolean cachePatterns) {_		this.cachePatterns = cachePatterns__	};specify,whether,to,cache,parsed,pattern,metadata,for,patterns,passed,into,this,matcher,s,link,match,method,a,value,of,code,true,activates,an,unlimited,pattern,cache,a,value,of,code,false,turns,the,pattern,cache,off,completely,p,default,is,for,the,cache,to,be,on,but,with,the,variant,to,automatically,turn,it,off,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,since,4,0,1,see,get,string,matcher,string;public,void,set,cache,patterns,boolean,cache,patterns,this,cache,patterns,cache,patterns
AntPathMatcher -> public void setCachePatterns(boolean cachePatterns);1462393686;Specify whether to cache parsed pattern metadata for patterns passed_into this matcher's {@link #match} method. A value of {@code true}_activates an unlimited pattern cache_ a value of {@code false} turns_the pattern cache off completely._<p>Default is for the cache to be on, but with the variant to automatically_turn it off when encountering too many patterns to cache at runtime_(the threshold is 65536), assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._@since 4.0.1_@see #getStringMatcher(String);public void setCachePatterns(boolean cachePatterns) {_		this.cachePatterns = cachePatterns__	};specify,whether,to,cache,parsed,pattern,metadata,for,patterns,passed,into,this,matcher,s,link,match,method,a,value,of,code,true,activates,an,unlimited,pattern,cache,a,value,of,code,false,turns,the,pattern,cache,off,completely,p,default,is,for,the,cache,to,be,on,but,with,the,variant,to,automatically,turn,it,off,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,since,4,0,1,see,get,string,matcher,string;public,void,set,cache,patterns,boolean,cache,patterns,this,cache,patterns,cache,patterns
AntPathMatcher -> public void setCachePatterns(boolean cachePatterns);1467730834;Specify whether to cache parsed pattern metadata for patterns passed_into this matcher's {@link #match} method. A value of {@code true}_activates an unlimited pattern cache_ a value of {@code false} turns_the pattern cache off completely._<p>Default is for the cache to be on, but with the variant to automatically_turn it off when encountering too many patterns to cache at runtime_(the threshold is 65536), assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._@since 4.0.1_@see #getStringMatcher(String);public void setCachePatterns(boolean cachePatterns) {_		this.cachePatterns = cachePatterns__	};specify,whether,to,cache,parsed,pattern,metadata,for,patterns,passed,into,this,matcher,s,link,match,method,a,value,of,code,true,activates,an,unlimited,pattern,cache,a,value,of,code,false,turns,the,pattern,cache,off,completely,p,default,is,for,the,cache,to,be,on,but,with,the,variant,to,automatically,turn,it,off,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,since,4,0,1,see,get,string,matcher,string;public,void,set,cache,patterns,boolean,cache,patterns,this,cache,patterns,cache,patterns
AntPathMatcher -> public void setCachePatterns(boolean cachePatterns);1468327638;Specify whether to cache parsed pattern metadata for patterns passed_into this matcher's {@link #match} method. A value of {@code true}_activates an unlimited pattern cache_ a value of {@code false} turns_the pattern cache off completely._<p>Default is for the cache to be on, but with the variant to automatically_turn it off when encountering too many patterns to cache at runtime_(the threshold is 65536), assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._@since 4.0.1_@see #getStringMatcher(String);public void setCachePatterns(boolean cachePatterns) {_		this.cachePatterns = cachePatterns__	};specify,whether,to,cache,parsed,pattern,metadata,for,patterns,passed,into,this,matcher,s,link,match,method,a,value,of,code,true,activates,an,unlimited,pattern,cache,a,value,of,code,false,turns,the,pattern,cache,off,completely,p,default,is,for,the,cache,to,be,on,but,with,the,variant,to,automatically,turn,it,off,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,since,4,0,1,see,get,string,matcher,string;public,void,set,cache,patterns,boolean,cache,patterns,this,cache,patterns,cache,patterns
AntPathMatcher -> public void setCachePatterns(boolean cachePatterns);1472808958;Specify whether to cache parsed pattern metadata for patterns passed_into this matcher's {@link #match} method. A value of {@code true}_activates an unlimited pattern cache_ a value of {@code false} turns_the pattern cache off completely._<p>Default is for the cache to be on, but with the variant to automatically_turn it off when encountering too many patterns to cache at runtime_(the threshold is 65536), assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._@since 4.0.1_@see #getStringMatcher(String);public void setCachePatterns(boolean cachePatterns) {_		this.cachePatterns = cachePatterns__	};specify,whether,to,cache,parsed,pattern,metadata,for,patterns,passed,into,this,matcher,s,link,match,method,a,value,of,code,true,activates,an,unlimited,pattern,cache,a,value,of,code,false,turns,the,pattern,cache,off,completely,p,default,is,for,the,cache,to,be,on,but,with,the,variant,to,automatically,turn,it,off,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,since,4,0,1,see,get,string,matcher,string;public,void,set,cache,patterns,boolean,cache,patterns,this,cache,patterns,cache,patterns
AntPathMatcher -> public void setCachePatterns(boolean cachePatterns);1493317597;Specify whether to cache parsed pattern metadata for patterns passed_into this matcher's {@link #match} method. A value of {@code true}_activates an unlimited pattern cache_ a value of {@code false} turns_the pattern cache off completely._<p>Default is for the cache to be on, but with the variant to automatically_turn it off when encountering too many patterns to cache at runtime_(the threshold is 65536), assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._@since 4.0.1_@see #getStringMatcher(String);public void setCachePatterns(boolean cachePatterns) {_		this.cachePatterns = cachePatterns__	};specify,whether,to,cache,parsed,pattern,metadata,for,patterns,passed,into,this,matcher,s,link,match,method,a,value,of,code,true,activates,an,unlimited,pattern,cache,a,value,of,code,false,turns,the,pattern,cache,off,completely,p,default,is,for,the,cache,to,be,on,but,with,the,variant,to,automatically,turn,it,off,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,since,4,0,1,see,get,string,matcher,string;public,void,set,cache,patterns,boolean,cache,patterns,this,cache,patterns,cache,patterns
AntPathMatcher -> public void setCachePatterns(boolean cachePatterns);1493321510;Specify whether to cache parsed pattern metadata for patterns passed_into this matcher's {@link #match} method. A value of {@code true}_activates an unlimited pattern cache_ a value of {@code false} turns_the pattern cache off completely._<p>Default is for the cache to be on, but with the variant to automatically_turn it off when encountering too many patterns to cache at runtime_(the threshold is 65536), assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._@since 4.0.1_@see #getStringMatcher(String);public void setCachePatterns(boolean cachePatterns) {_		this.cachePatterns = cachePatterns__	};specify,whether,to,cache,parsed,pattern,metadata,for,patterns,passed,into,this,matcher,s,link,match,method,a,value,of,code,true,activates,an,unlimited,pattern,cache,a,value,of,code,false,turns,the,pattern,cache,off,completely,p,default,is,for,the,cache,to,be,on,but,with,the,variant,to,automatically,turn,it,off,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,since,4,0,1,see,get,string,matcher,string;public,void,set,cache,patterns,boolean,cache,patterns,this,cache,patterns,cache,patterns
AntPathMatcher -> public void setCachePatterns(boolean cachePatterns);1496259743;Specify whether to cache parsed pattern metadata for patterns passed_into this matcher's {@link #match} method. A value of {@code true}_activates an unlimited pattern cache_ a value of {@code false} turns_the pattern cache off completely._<p>Default is for the cache to be on, but with the variant to automatically_turn it off when encountering too many patterns to cache at runtime_(the threshold is 65536), assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._@since 4.0.1_@see #getStringMatcher(String);public void setCachePatterns(boolean cachePatterns) {_		this.cachePatterns = cachePatterns__	};specify,whether,to,cache,parsed,pattern,metadata,for,patterns,passed,into,this,matcher,s,link,match,method,a,value,of,code,true,activates,an,unlimited,pattern,cache,a,value,of,code,false,turns,the,pattern,cache,off,completely,p,default,is,for,the,cache,to,be,on,but,with,the,variant,to,automatically,turn,it,off,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,since,4,0,1,see,get,string,matcher,string;public,void,set,cache,patterns,boolean,cache,patterns,this,cache,patterns,cache,patterns
AntPathMatcher -> public void setCachePatterns(boolean cachePatterns);1496837955;Specify whether to cache parsed pattern metadata for patterns passed_into this matcher's {@link #match} method. A value of {@code true}_activates an unlimited pattern cache_ a value of {@code false} turns_the pattern cache off completely._<p>Default is for the cache to be on, but with the variant to automatically_turn it off when encountering too many patterns to cache at runtime_(the threshold is 65536), assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._@since 4.0.1_@see #getStringMatcher(String);public void setCachePatterns(boolean cachePatterns) {_		this.cachePatterns = cachePatterns__	};specify,whether,to,cache,parsed,pattern,metadata,for,patterns,passed,into,this,matcher,s,link,match,method,a,value,of,code,true,activates,an,unlimited,pattern,cache,a,value,of,code,false,turns,the,pattern,cache,off,completely,p,default,is,for,the,cache,to,be,on,but,with,the,variant,to,automatically,turn,it,off,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,since,4,0,1,see,get,string,matcher,string;public,void,set,cache,patterns,boolean,cache,patterns,this,cache,patterns,cache,patterns
AntPathMatcher -> public void setCachePatterns(boolean cachePatterns);1498780456;Specify whether to cache parsed pattern metadata for patterns passed_into this matcher's {@link #match} method. A value of {@code true}_activates an unlimited pattern cache_ a value of {@code false} turns_the pattern cache off completely._<p>Default is for the cache to be on, but with the variant to automatically_turn it off when encountering too many patterns to cache at runtime_(the threshold is 65536), assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._@since 4.0.1_@see #getStringMatcher(String);public void setCachePatterns(boolean cachePatterns) {_		this.cachePatterns = cachePatterns__	};specify,whether,to,cache,parsed,pattern,metadata,for,patterns,passed,into,this,matcher,s,link,match,method,a,value,of,code,true,activates,an,unlimited,pattern,cache,a,value,of,code,false,turns,the,pattern,cache,off,completely,p,default,is,for,the,cache,to,be,on,but,with,the,variant,to,automatically,turn,it,off,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,since,4,0,1,see,get,string,matcher,string;public,void,set,cache,patterns,boolean,cache,patterns,this,cache,patterns,cache,patterns
AntPathMatcher -> public void setCachePatterns(boolean cachePatterns);1518772998;Specify whether to cache parsed pattern metadata for patterns passed_into this matcher's {@link #match} method. A value of {@code true}_activates an unlimited pattern cache_ a value of {@code false} turns_the pattern cache off completely._<p>Default is for the cache to be on, but with the variant to automatically_turn it off when encountering too many patterns to cache at runtime_(the threshold is 65536), assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._@since 4.0.1_@see #getStringMatcher(String);public void setCachePatterns(boolean cachePatterns) {_		this.cachePatterns = cachePatterns__	};specify,whether,to,cache,parsed,pattern,metadata,for,patterns,passed,into,this,matcher,s,link,match,method,a,value,of,code,true,activates,an,unlimited,pattern,cache,a,value,of,code,false,turns,the,pattern,cache,off,completely,p,default,is,for,the,cache,to,be,on,but,with,the,variant,to,automatically,turn,it,off,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,since,4,0,1,see,get,string,matcher,string;public,void,set,cache,patterns,boolean,cache,patterns,this,cache,patterns,cache,patterns
AntPathMatcher -> public void setCachePatterns(boolean cachePatterns);1530174524;Specify whether to cache parsed pattern metadata for patterns passed_into this matcher's {@link #match} method. A value of {@code true}_activates an unlimited pattern cache_ a value of {@code false} turns_the pattern cache off completely._<p>Default is for the cache to be on, but with the variant to automatically_turn it off when encountering too many patterns to cache at runtime_(the threshold is 65536), assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._@since 4.0.1_@see #getStringMatcher(String);public void setCachePatterns(boolean cachePatterns) {_		this.cachePatterns = cachePatterns__	};specify,whether,to,cache,parsed,pattern,metadata,for,patterns,passed,into,this,matcher,s,link,match,method,a,value,of,code,true,activates,an,unlimited,pattern,cache,a,value,of,code,false,turns,the,pattern,cache,off,completely,p,default,is,for,the,cache,to,be,on,but,with,the,variant,to,automatically,turn,it,off,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,since,4,0,1,see,get,string,matcher,string;public,void,set,cache,patterns,boolean,cache,patterns,this,cache,patterns,cache,patterns
AntPathMatcher -> public void setCachePatterns(boolean cachePatterns);1530174524;Specify whether to cache parsed pattern metadata for patterns passed_into this matcher's {@link #match} method. A value of {@code true}_activates an unlimited pattern cache_ a value of {@code false} turns_the pattern cache off completely._<p>Default is for the cache to be on, but with the variant to automatically_turn it off when encountering too many patterns to cache at runtime_(the threshold is 65536), assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._@since 4.0.1_@see #getStringMatcher(String);public void setCachePatterns(boolean cachePatterns) {_		this.cachePatterns = cachePatterns__	};specify,whether,to,cache,parsed,pattern,metadata,for,patterns,passed,into,this,matcher,s,link,match,method,a,value,of,code,true,activates,an,unlimited,pattern,cache,a,value,of,code,false,turns,the,pattern,cache,off,completely,p,default,is,for,the,cache,to,be,on,but,with,the,variant,to,automatically,turn,it,off,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,since,4,0,1,see,get,string,matcher,string;public,void,set,cache,patterns,boolean,cache,patterns,this,cache,patterns,cache,patterns
AntPathMatcher -> public void setCachePatterns(boolean cachePatterns);1535316501;Specify whether to cache parsed pattern metadata for patterns passed_into this matcher's {@link #match} method. A value of {@code true}_activates an unlimited pattern cache_ a value of {@code false} turns_the pattern cache off completely._<p>Default is for the cache to be on, but with the variant to automatically_turn it off when encountering too many patterns to cache at runtime_(the threshold is 65536), assuming that arbitrary permutations of patterns_are coming in, with little chance for encountering a recurring pattern._@since 4.0.1_@see #getStringMatcher(String);public void setCachePatterns(boolean cachePatterns) {_		this.cachePatterns = cachePatterns__	};specify,whether,to,cache,parsed,pattern,metadata,for,patterns,passed,into,this,matcher,s,link,match,method,a,value,of,code,true,activates,an,unlimited,pattern,cache,a,value,of,code,false,turns,the,pattern,cache,off,completely,p,default,is,for,the,cache,to,be,on,but,with,the,variant,to,automatically,turn,it,off,when,encountering,too,many,patterns,to,cache,at,runtime,the,threshold,is,65536,assuming,that,arbitrary,permutations,of,patterns,are,coming,in,with,little,chance,for,encountering,a,recurring,pattern,since,4,0,1,see,get,string,matcher,string;public,void,set,cache,patterns,boolean,cache,patterns,this,cache,patterns,cache,patterns
AntPathMatcher -> private boolean matchStrings(String pattern, String str, 			@Nullable Map<String, String> uriTemplateVariables);1496837955;Test whether or not a string matches against a pattern._@param pattern the pattern to match against (never {@code null})_@param str the String which must be matched against the pattern (never {@code null})_@return {@code true} if the string matches against the pattern, or {@code false} otherwise;private boolean matchStrings(String pattern, String str,_			@Nullable Map<String, String> uriTemplateVariables) {__		return getStringMatcher(pattern).matchStrings(str, uriTemplateVariables)__	};test,whether,or,not,a,string,matches,against,a,pattern,param,pattern,the,pattern,to,match,against,never,code,null,param,str,the,string,which,must,be,matched,against,the,pattern,never,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,nullable,map,string,string,uri,template,variables,return,get,string,matcher,pattern,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, 			@Nullable Map<String, String> uriTemplateVariables);1498780456;Test whether or not a string matches against a pattern._@param pattern the pattern to match against (never {@code null})_@param str the String which must be matched against the pattern (never {@code null})_@return {@code true} if the string matches against the pattern, or {@code false} otherwise;private boolean matchStrings(String pattern, String str,_			@Nullable Map<String, String> uriTemplateVariables) {__		return getStringMatcher(pattern).matchStrings(str, uriTemplateVariables)__	};test,whether,or,not,a,string,matches,against,a,pattern,param,pattern,the,pattern,to,match,against,never,code,null,param,str,the,string,which,must,be,matched,against,the,pattern,never,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,nullable,map,string,string,uri,template,variables,return,get,string,matcher,pattern,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, 			@Nullable Map<String, String> uriTemplateVariables);1518772998;Test whether or not a string matches against a pattern._@param pattern the pattern to match against (never {@code null})_@param str the String which must be matched against the pattern (never {@code null})_@return {@code true} if the string matches against the pattern, or {@code false} otherwise;private boolean matchStrings(String pattern, String str,_			@Nullable Map<String, String> uriTemplateVariables) {__		return getStringMatcher(pattern).matchStrings(str, uriTemplateVariables)__	};test,whether,or,not,a,string,matches,against,a,pattern,param,pattern,the,pattern,to,match,against,never,code,null,param,str,the,string,which,must,be,matched,against,the,pattern,never,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,nullable,map,string,string,uri,template,variables,return,get,string,matcher,pattern,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, 			@Nullable Map<String, String> uriTemplateVariables);1530174524;Test whether or not a string matches against a pattern._@param pattern the pattern to match against (never {@code null})_@param str the String which must be matched against the pattern (never {@code null})_@return {@code true} if the string matches against the pattern, or {@code false} otherwise;private boolean matchStrings(String pattern, String str,_			@Nullable Map<String, String> uriTemplateVariables) {__		return getStringMatcher(pattern).matchStrings(str, uriTemplateVariables)__	};test,whether,or,not,a,string,matches,against,a,pattern,param,pattern,the,pattern,to,match,against,never,code,null,param,str,the,string,which,must,be,matched,against,the,pattern,never,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,nullable,map,string,string,uri,template,variables,return,get,string,matcher,pattern,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, 			@Nullable Map<String, String> uriTemplateVariables);1530174524;Test whether or not a string matches against a pattern._@param pattern the pattern to match against (never {@code null})_@param str the String which must be matched against the pattern (never {@code null})_@return {@code true} if the string matches against the pattern, or {@code false} otherwise;private boolean matchStrings(String pattern, String str,_			@Nullable Map<String, String> uriTemplateVariables) {__		return getStringMatcher(pattern).matchStrings(str, uriTemplateVariables)__	};test,whether,or,not,a,string,matches,against,a,pattern,param,pattern,the,pattern,to,match,against,never,code,null,param,str,the,string,which,must,be,matched,against,the,pattern,never,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,nullable,map,string,string,uri,template,variables,return,get,string,matcher,pattern,match,strings,str,uri,template,variables
AntPathMatcher -> private boolean matchStrings(String pattern, String str, 			@Nullable Map<String, String> uriTemplateVariables);1535316501;Test whether or not a string matches against a pattern._@param pattern the pattern to match against (never {@code null})_@param str the String which must be matched against the pattern (never {@code null})_@return {@code true} if the string matches against the pattern, or {@code false} otherwise;private boolean matchStrings(String pattern, String str,_			@Nullable Map<String, String> uriTemplateVariables) {__		return getStringMatcher(pattern).matchStrings(str, uriTemplateVariables)__	};test,whether,or,not,a,string,matches,against,a,pattern,param,pattern,the,pattern,to,match,against,never,code,null,param,str,the,string,which,must,be,matched,against,the,pattern,never,code,null,return,code,true,if,the,string,matches,against,the,pattern,or,code,false,otherwise;private,boolean,match,strings,string,pattern,string,str,nullable,map,string,string,uri,template,variables,return,get,string,matcher,pattern,match,strings,str,uri,template,variables
