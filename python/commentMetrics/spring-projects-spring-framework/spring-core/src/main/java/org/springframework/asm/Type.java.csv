commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;3;/**  * Returns the {@link Type} corresponding to the given type descriptor.  *  * @param typeDescriptor a field or method type descriptor.  * @return the {@link Type} corresponding to the given type descriptor.  */ ;// ----------------------------------------------------------------------------------------------- // Methods to get Type(s) from a descriptor, a reflected Method or Constructor, other types, etc. // ----------------------------------------------------------------------------------------------- /**  * Returns the {@link Type} corresponding to the given type descriptor.  *  * @param typeDescriptor a field or method type descriptor.  * @return the {@link Type} corresponding to the given type descriptor.  */ public static Type getType(final String typeDescriptor) {     return getTypeInternal(typeDescriptor, 0, typeDescriptor.length()). }
true;public,static;1;27;/**  * Returns the {@link Type} corresponding to the given class.  *  * @param clazz a class.  * @return the {@link Type} corresponding to the given class.  */ ;/**  * Returns the {@link Type} corresponding to the given class.  *  * @param clazz a class.  * @return the {@link Type} corresponding to the given class.  */ public static Type getType(final Class<?> clazz) {     if (clazz.isPrimitive()) {         if (clazz == Integer.TYPE) {             return INT_TYPE.         } else if (clazz == Void.TYPE) {             return VOID_TYPE.         } else if (clazz == Boolean.TYPE) {             return BOOLEAN_TYPE.         } else if (clazz == Byte.TYPE) {             return BYTE_TYPE.         } else if (clazz == Character.TYPE) {             return CHAR_TYPE.         } else if (clazz == Short.TYPE) {             return SHORT_TYPE.         } else if (clazz == Double.TYPE) {             return DOUBLE_TYPE.         } else if (clazz == Float.TYPE) {             return FLOAT_TYPE.         } else if (clazz == Long.TYPE) {             return LONG_TYPE.         } else {             throw new AssertionError().         }     } else {         return getType(getDescriptor(clazz)).     } }
true;public,static;1;3;/**  * Returns the method {@link Type} corresponding to the given constructor.  *  * @param constructor a {@link Constructor} object.  * @return the method {@link Type} corresponding to the given constructor.  */ ;/**  * Returns the method {@link Type} corresponding to the given constructor.  *  * @param constructor a {@link Constructor} object.  * @return the method {@link Type} corresponding to the given constructor.  */ public static Type getType(final Constructor<?> constructor) {     return getType(getConstructorDescriptor(constructor)). }
true;public,static;1;3;/**  * Returns the method {@link Type} corresponding to the given method.  *  * @param method a {@link Method} object.  * @return the method {@link Type} corresponding to the given method.  */ ;/**  * Returns the method {@link Type} corresponding to the given method.  *  * @param method a {@link Method} object.  * @return the method {@link Type} corresponding to the given method.  */ public static Type getType(final Method method) {     return getType(getMethodDescriptor(method)). }
true;public;0;4;/**  * Returns the type of the elements of this array type. This method should only be used for an  * array type.  *  * @return Returns the type of the elements of this array type.  */ ;/**  * Returns the type of the elements of this array type. This method should only be used for an  * array type.  *  * @return Returns the type of the elements of this array type.  */ public Type getElementType() {     final int numDimensions = getDimensions().     return getTypeInternal(valueBuffer, valueBegin + numDimensions, valueEnd). }
true;public,static;1;4;/**  * Returns the {@link Type} corresponding to the given internal name.  *  * @param internalName an internal name.  * @return the {@link Type} corresponding to the given internal name.  */ ;/**  * Returns the {@link Type} corresponding to the given internal name.  *  * @param internalName an internal name.  * @return the {@link Type} corresponding to the given internal name.  */ public static Type getObjectType(final String internalName) {     return new Type(internalName.charAt(0) == '[' ? ARRAY : INTERNAL, internalName, 0, internalName.length()). }
true;public,static;1;3;/**  * Returns the {@link Type} corresponding to the given method descriptor. Equivalent to <code>  * Type.getType(methodDescriptor)</code>.  *  * @param methodDescriptor a method descriptor.  * @return the {@link Type} corresponding to the given method descriptor.  */ ;/**  * Returns the {@link Type} corresponding to the given method descriptor. Equivalent to <code>  * Type.getType(methodDescriptor)</code>.  *  * @param methodDescriptor a method descriptor.  * @return the {@link Type} corresponding to the given method descriptor.  */ public static Type getMethodType(final String methodDescriptor) {     return new Type(METHOD, methodDescriptor, 0, methodDescriptor.length()). }
true;public,static;2;3;/**  * Returns the method {@link Type} corresponding to the given argument and return types.  *  * @param returnType the return type of the method.  * @param argumentTypes the argument types of the method.  * @return the method {@link Type} corresponding to the given argument and return types.  */ ;/**  * Returns the method {@link Type} corresponding to the given argument and return types.  *  * @param returnType the return type of the method.  * @param argumentTypes the argument types of the method.  * @return the method {@link Type} corresponding to the given argument and return types.  */ public static Type getMethodType(final Type returnType, final Type... argumentTypes) {     return getType(getMethodDescriptor(returnType, argumentTypes)). }
true;public;0;3;/**  * Returns the argument types of methods of this type. This method should only be used for method  * types.  *  * @return the argument types of methods of this type.  */ ;/**  * Returns the argument types of methods of this type. This method should only be used for method  * types.  *  * @return the argument types of methods of this type.  */ public Type[] getArgumentTypes() {     return getArgumentTypes(getDescriptor()). }
true;public,static;1;37;/**  * Returns the {@link Type} values corresponding to the argument types of the given method  * descriptor.  *  * @param methodDescriptor a method descriptor.  * @return the {@link Type} values corresponding to the argument types of the given method  *     descriptor.  */ ;/**  * Returns the {@link Type} values corresponding to the argument types of the given method  * descriptor.  *  * @param methodDescriptor a method descriptor.  * @return the {@link Type} values corresponding to the argument types of the given method  *     descriptor.  */ public static Type[] getArgumentTypes(final String methodDescriptor) {     // First step: compute the number of argument types in methodDescriptor.     int numArgumentTypes = 0.     // Skip the first character, which is always a '('.     int currentOffset = 1.     // Parse the argument types, one at a each loop iteration.     while (methodDescriptor.charAt(currentOffset) != ')') {         while (methodDescriptor.charAt(currentOffset) == '[') {             currentOffset++.         }         if (methodDescriptor.charAt(currentOffset++) == 'L') {             // Skip the argument descriptor content.             currentOffset = methodDescriptor.indexOf('.', currentOffset) + 1.         }         ++numArgumentTypes.     }     // Second step: create a Type instance for each argument type.     Type[] argumentTypes = new Type[numArgumentTypes].     // Skip the first character, which is always a '('.     currentOffset = 1.     // Parse and create the argument types, one at each loop iteration.     int currentArgumentTypeIndex = 0.     while (methodDescriptor.charAt(currentOffset) != ')') {         final int currentArgumentTypeOffset = currentOffset.         while (methodDescriptor.charAt(currentOffset) == '[') {             currentOffset++.         }         if (methodDescriptor.charAt(currentOffset++) == 'L') {             // Skip the argument descriptor content.             currentOffset = methodDescriptor.indexOf('.', currentOffset) + 1.         }         argumentTypes[currentArgumentTypeIndex++] = getTypeInternal(methodDescriptor, currentArgumentTypeOffset, currentOffset).     }     return argumentTypes. }
true;public,static;1;8;/**  * Returns the {@link Type} values corresponding to the argument types of the given method.  *  * @param method a method.  * @return the {@link Type} values corresponding to the argument types of the given method.  */ ;/**  * Returns the {@link Type} values corresponding to the argument types of the given method.  *  * @param method a method.  * @return the {@link Type} values corresponding to the argument types of the given method.  */ public static Type[] getArgumentTypes(final Method method) {     Class<?>[] classes = method.getParameterTypes().     Type[] types = new Type[classes.length].     for (int i = classes.length - 1. i >= 0. --i) {         types[i] = getType(classes[i]).     }     return types. }
true;public;0;3;/**  * Returns the return type of methods of this type. This method should only be used for method  * types.  *  * @return the return type of methods of this type.  */ ;/**  * Returns the return type of methods of this type. This method should only be used for method  * types.  *  * @return the return type of methods of this type.  */ public Type getReturnType() {     return getReturnType(getDescriptor()). }
true;public,static;1;15;/**  * Returns the {@link Type} corresponding to the return type of the given method descriptor.  *  * @param methodDescriptor a method descriptor.  * @return the {@link Type} corresponding to the return type of the given method descriptor.  */ ;/**  * Returns the {@link Type} corresponding to the return type of the given method descriptor.  *  * @param methodDescriptor a method descriptor.  * @return the {@link Type} corresponding to the return type of the given method descriptor.  */ public static Type getReturnType(final String methodDescriptor) {     // Skip the first character, which is always a '('.     int currentOffset = 1.     // Skip the argument types, one at a each loop iteration.     while (methodDescriptor.charAt(currentOffset) != ')') {         while (methodDescriptor.charAt(currentOffset) == '[') {             currentOffset++.         }         if (methodDescriptor.charAt(currentOffset++) == 'L') {             // Skip the argument descriptor content.             currentOffset = methodDescriptor.indexOf('.', currentOffset) + 1.         }     }     return getTypeInternal(methodDescriptor, currentOffset + 1, methodDescriptor.length()). }
true;public,static;1;3;/**  * Returns the {@link Type} corresponding to the return type of the given method.  *  * @param method a method.  * @return the {@link Type} corresponding to the return type of the given method.  */ ;/**  * Returns the {@link Type} corresponding to the return type of the given method.  *  * @param method a method.  * @return the {@link Type} corresponding to the return type of the given method.  */ public static Type getReturnType(final Method method) {     return getType(method.getReturnType()). }
true;private,static;3;31;/**  * Returns the {@link Type} corresponding to the given field or method descriptor.  *  * @param descriptorBuffer a buffer containing the field or method descriptor.  * @param descriptorBegin the beginning index, inclusive, of the field or method descriptor in  *     descriptorBuffer.  * @param descriptorEnd the end index, exclusive, of the field or method descriptor in  *     descriptorBuffer.  * @return the {@link Type} corresponding to the given type descriptor.  */ ;/**  * Returns the {@link Type} corresponding to the given field or method descriptor.  *  * @param descriptorBuffer a buffer containing the field or method descriptor.  * @param descriptorBegin the beginning index, inclusive, of the field or method descriptor in  *     descriptorBuffer.  * @param descriptorEnd the end index, exclusive, of the field or method descriptor in  *     descriptorBuffer.  * @return the {@link Type} corresponding to the given type descriptor.  */ private static Type getTypeInternal(final String descriptorBuffer, final int descriptorBegin, final int descriptorEnd) {     switch(descriptorBuffer.charAt(descriptorBegin)) {         case 'V':             return VOID_TYPE.         case 'Z':             return BOOLEAN_TYPE.         case 'C':             return CHAR_TYPE.         case 'B':             return BYTE_TYPE.         case 'S':             return SHORT_TYPE.         case 'I':             return INT_TYPE.         case 'F':             return FLOAT_TYPE.         case 'J':             return LONG_TYPE.         case 'D':             return DOUBLE_TYPE.         case '[':             return new Type(ARRAY, descriptorBuffer, descriptorBegin, descriptorEnd).         case 'L':             return new Type(OBJECT, descriptorBuffer, descriptorBegin + 1, descriptorEnd - 1).         case '(':             return new Type(METHOD, descriptorBuffer, descriptorBegin, descriptorEnd).         default:             throw new IllegalArgumentException().     } }
true;public;0;33;/**  * Returns the binary name of the class corresponding to this type. This method must not be used  * on method types.  *  * @return the binary name of the class corresponding to this type.  */ ;// ----------------------------------------------------------------------------------------------- // Methods to get class names, internal names or descriptors. // ----------------------------------------------------------------------------------------------- /**  * Returns the binary name of the class corresponding to this type. This method must not be used  * on method types.  *  * @return the binary name of the class corresponding to this type.  */ public String getClassName() {     switch(sort) {         case VOID:             return "void".         case BOOLEAN:             return "boolean".         case CHAR:             return "char".         case BYTE:             return "byte".         case SHORT:             return "short".         case INT:             return "int".         case FLOAT:             return "float".         case LONG:             return "long".         case DOUBLE:             return "double".         case ARRAY:             StringBuilder stringBuilder = new StringBuilder(getElementType().getClassName()).             for (int i = getDimensions(). i > 0. --i) {                 stringBuilder.append("[]").             }             return stringBuilder.toString().         case OBJECT:         case INTERNAL:             return valueBuffer.substring(valueBegin, valueEnd).replace('/', '.').         default:             throw new AssertionError().     } }
true;public;0;3;/**  * Returns the internal name of the class corresponding to this object or array type. The internal  * name of a class is its fully qualified name (as returned by Class.getName(), where '.' are  * replaced by '/'). This method should only be used for an object or array type.  *  * @return the internal name of the class corresponding to this object type.  */ ;/**  * Returns the internal name of the class corresponding to this object or array type. The internal  * name of a class is its fully qualified name (as returned by Class.getName(), where '.' are  * replaced by '/'). This method should only be used for an object or array type.  *  * @return the internal name of the class corresponding to this object type.  */ public String getInternalName() {     return valueBuffer.substring(valueBegin, valueEnd). }
true;public,static;1;3;/**  * Returns the internal name of the given class. The internal name of a class is its fully  * qualified name, as returned by Class.getName(), where '.' are replaced by '/'.  *  * @param clazz an object or array class.  * @return the internal name of the given class.  */ ;/**  * Returns the internal name of the given class. The internal name of a class is its fully  * qualified name, as returned by Class.getName(), where '.' are replaced by '/'.  *  * @param clazz an object or array class.  * @return the internal name of the given class.  */ public static String getInternalName(final Class<?> clazz) {     return clazz.getName().replace('.', '/'). }
true;public;0;13;/**  * Returns the descriptor corresponding to this type.  *  * @return the descriptor corresponding to this type.  */ ;/**  * Returns the descriptor corresponding to this type.  *  * @return the descriptor corresponding to this type.  */ public String getDescriptor() {     if (sort == OBJECT) {         return valueBuffer.substring(valueBegin - 1, valueEnd + 1).     } else if (sort == INTERNAL) {         return new StringBuilder().append('L').append(valueBuffer, valueBegin, valueEnd).append('.').toString().     } else {         return valueBuffer.substring(valueBegin, valueEnd).     } }
true;public,static;1;5;/**  * Returns the descriptor corresponding to the given class.  *  * @param clazz an object class, a primitive class or an array class.  * @return the descriptor corresponding to the given class.  */ ;/**  * Returns the descriptor corresponding to the given class.  *  * @param clazz an object class, a primitive class or an array class.  * @return the descriptor corresponding to the given class.  */ public static String getDescriptor(final Class<?> clazz) {     StringBuilder stringBuilder = new StringBuilder().     appendDescriptor(clazz, stringBuilder).     return stringBuilder.toString(). }
true;public,static;1;9;/**  * Returns the descriptor corresponding to the given constructor.  *  * @param constructor a {@link Constructor} object.  * @return the descriptor of the given constructor.  */ ;/**  * Returns the descriptor corresponding to the given constructor.  *  * @param constructor a {@link Constructor} object.  * @return the descriptor of the given constructor.  */ public static String getConstructorDescriptor(final Constructor<?> constructor) {     StringBuilder stringBuilder = new StringBuilder().     stringBuilder.append('(').     Class<?>[] parameters = constructor.getParameterTypes().     for (Class<?> parameter : parameters) {         appendDescriptor(parameter, stringBuilder).     }     return stringBuilder.append(")V").toString(). }
true;public,static;2;10;/**  * Returns the descriptor corresponding to the given argument and return types.  *  * @param returnType the return type of the method.  * @param argumentTypes the argument types of the method.  * @return the descriptor corresponding to the given argument and return types.  */ ;/**  * Returns the descriptor corresponding to the given argument and return types.  *  * @param returnType the return type of the method.  * @param argumentTypes the argument types of the method.  * @return the descriptor corresponding to the given argument and return types.  */ public static String getMethodDescriptor(final Type returnType, final Type... argumentTypes) {     StringBuilder stringBuilder = new StringBuilder().     stringBuilder.append('(').     for (Type argumentType : argumentTypes) {         argumentType.appendDescriptor(stringBuilder).     }     stringBuilder.append(')').     returnType.appendDescriptor(stringBuilder).     return stringBuilder.toString(). }
true;public,static;1;11;/**  * Returns the descriptor corresponding to the given method.  *  * @param method a {@link Method} object.  * @return the descriptor of the given method.  */ ;/**  * Returns the descriptor corresponding to the given method.  *  * @param method a {@link Method} object.  * @return the descriptor of the given method.  */ public static String getMethodDescriptor(final Method method) {     StringBuilder stringBuilder = new StringBuilder().     stringBuilder.append('(').     Class<?>[] parameters = method.getParameterTypes().     for (Class<?> parameter : parameters) {         appendDescriptor(parameter, stringBuilder).     }     stringBuilder.append(')').     appendDescriptor(method.getReturnType(), stringBuilder).     return stringBuilder.toString(). }
true;private;1;9;/**  * Appends the descriptor corresponding to this type to the given string buffer.  *  * @param stringBuilder the string builder to which the descriptor must be appended.  */ ;/**  * Appends the descriptor corresponding to this type to the given string buffer.  *  * @param stringBuilder the string builder to which the descriptor must be appended.  */ private void appendDescriptor(final StringBuilder stringBuilder) {     if (sort == OBJECT) {         stringBuilder.append(valueBuffer, valueBegin - 1, valueEnd + 1).     } else if (sort == INTERNAL) {         stringBuilder.append('L').append(valueBuffer, valueBegin, valueEnd).append('.').     } else {         stringBuilder.append(valueBuffer, valueBegin, valueEnd).     } }
true;private,static;2;41;/**  * Appends the descriptor of the given class to the given string builder.  *  * @param clazz the class whose descriptor must be computed.  * @param stringBuilder the string builder to which the descriptor must be appended.  */ ;/**  * Appends the descriptor of the given class to the given string builder.  *  * @param clazz the class whose descriptor must be computed.  * @param stringBuilder the string builder to which the descriptor must be appended.  */ private static void appendDescriptor(final Class<?> clazz, final StringBuilder stringBuilder) {     Class<?> currentClass = clazz.     while (currentClass.isArray()) {         stringBuilder.append('[').         currentClass = currentClass.getComponentType().     }     if (currentClass.isPrimitive()) {         char descriptor.         if (currentClass == Integer.TYPE) {             descriptor = 'I'.         } else if (currentClass == Void.TYPE) {             descriptor = 'V'.         } else if (currentClass == Boolean.TYPE) {             descriptor = 'Z'.         } else if (currentClass == Byte.TYPE) {             descriptor = 'B'.         } else if (currentClass == Character.TYPE) {             descriptor = 'C'.         } else if (currentClass == Short.TYPE) {             descriptor = 'S'.         } else if (currentClass == Double.TYPE) {             descriptor = 'D'.         } else if (currentClass == Float.TYPE) {             descriptor = 'F'.         } else if (currentClass == Long.TYPE) {             descriptor = 'J'.         } else {             throw new AssertionError().         }         stringBuilder.append(descriptor).     } else {         stringBuilder.append('L').         String name = currentClass.getName().         int nameLength = name.length().         for (int i = 0. i < nameLength. ++i) {             char car = name.charAt(i).             stringBuilder.append(car == '.' ? '/' : car).         }         stringBuilder.append('.').     } }
true;public;0;3;/**  * Returns the sort of this type.  *  * @return {@link #VOID}, {@link #BOOLEAN}, {@link #CHAR}, {@link #BYTE}, {@link #SHORT}, {@link  *     #INT}, {@link #FLOAT}, {@link #LONG}, {@link #DOUBLE}, {@link #ARRAY}, {@link #OBJECT} or  *     {@link #METHOD}.  */ ;// ----------------------------------------------------------------------------------------------- // Methods to get the sort, dimension, size, and opcodes corresponding to a Type or descriptor. // ----------------------------------------------------------------------------------------------- /**  * Returns the sort of this type.  *  * @return {@link #VOID}, {@link #BOOLEAN}, {@link #CHAR}, {@link #BYTE}, {@link #SHORT}, {@link  *     #INT}, {@link #FLOAT}, {@link #LONG}, {@link #DOUBLE}, {@link #ARRAY}, {@link #OBJECT} or  *     {@link #METHOD}.  */ public int getSort() {     return sort == INTERNAL ? OBJECT : sort. }
true;public;0;7;/**  * Returns the number of dimensions of this array type. This method should only be used for an  * array type.  *  * @return the number of dimensions of this array type.  */ ;/**  * Returns the number of dimensions of this array type. This method should only be used for an  * array type.  *  * @return the number of dimensions of this array type.  */ public int getDimensions() {     int numDimensions = 1.     while (valueBuffer.charAt(valueBegin + numDimensions) == '[') {         numDimensions++.     }     return numDimensions. }
true;public;0;21;/**  * Returns the size of values of this type. This method must not be used for method types.  *  * @return the size of values of this type, i.e., 2 for {@code long} and {@code double}, 0 for  *     {@code void} and 1 otherwise.  */ ;/**  * Returns the size of values of this type. This method must not be used for method types.  *  * @return the size of values of this type, i.e., 2 for {@code long} and {@code double}, 0 for  *     {@code void} and 1 otherwise.  */ public int getSize() {     switch(sort) {         case VOID:             return 0.         case BOOLEAN:         case CHAR:         case BYTE:         case SHORT:         case INT:         case FLOAT:         case ARRAY:         case OBJECT:         case INTERNAL:             return 1.         case LONG:         case DOUBLE:             return 2.         default:             throw new AssertionError().     } }
true;public;0;3;/**  * Returns the size of the arguments and of the return value of methods of this type. This method  * should only be used for method types.  *  * @return the size of the arguments of the method (plus one for the implicit this argument),  *     argumentsSize, and the size of its return value, returnSize, packed into a single int i =  *     {@code (argumentsSize &lt.&lt. 2) | returnSize} (argumentsSize is therefore equal to {@code  *     i &gt.&gt. 2}, and returnSize to {@code i &amp. 0x03}).  */ ;/**  * Returns the size of the arguments and of the return value of methods of this type. This method  * should only be used for method types.  *  * @return the size of the arguments of the method (plus one for the implicit this argument),  *     argumentsSize, and the size of its return value, returnSize, packed into a single int i =  *     {@code (argumentsSize &lt.&lt. 2) | returnSize} (argumentsSize is therefore equal to {@code  *     i &gt.&gt. 2}, and returnSize to {@code i &amp. 0x03}).  */ public int getArgumentsAndReturnSizes() {     return getArgumentsAndReturnSizes(getDescriptor()). }
true;public,static;1;30;/**  * Computes the size of the arguments and of the return value of a method.  *  * @param methodDescriptor a method descriptor.  * @return the size of the arguments of the method (plus one for the implicit this argument),  *     argumentsSize, and the size of its return value, returnSize, packed into a single int i =  *     {@code (argumentsSize &lt.&lt. 2) | returnSize} (argumentsSize is therefore equal to {@code  *     i &gt.&gt. 2}, and returnSize to {@code i &amp. 0x03}).  */ ;/**  * Computes the size of the arguments and of the return value of a method.  *  * @param methodDescriptor a method descriptor.  * @return the size of the arguments of the method (plus one for the implicit this argument),  *     argumentsSize, and the size of its return value, returnSize, packed into a single int i =  *     {@code (argumentsSize &lt.&lt. 2) | returnSize} (argumentsSize is therefore equal to {@code  *     i &gt.&gt. 2}, and returnSize to {@code i &amp. 0x03}).  */ public static int getArgumentsAndReturnSizes(final String methodDescriptor) {     int argumentsSize = 1.     // Skip the first character, which is always a '('.     int currentOffset = 1.     int currentChar = methodDescriptor.charAt(currentOffset).     // Parse the argument types and compute their size, one at a each loop iteration.     while (currentChar != ')') {         if (currentChar == 'J' || currentChar == 'D') {             currentOffset++.             argumentsSize += 2.         } else {             while (methodDescriptor.charAt(currentOffset) == '[') {                 currentOffset++.             }             if (methodDescriptor.charAt(currentOffset++) == 'L') {                 // Skip the argument descriptor content.                 currentOffset = methodDescriptor.indexOf('.', currentOffset) + 1.             }             argumentsSize += 1.         }         currentChar = methodDescriptor.charAt(currentOffset).     }     currentChar = methodDescriptor.charAt(currentOffset + 1).     if (currentChar == 'V') {         return argumentsSize << 2.     } else {         int returnSize = (currentChar == 'J' || currentChar == 'D') ? 2 : 1.         return argumentsSize << 2 | returnSize.     } }
true;public;1;61;/**  * Returns a JVM instruction opcode adapted to this {@link Type}. This method must not be used for  * method types.  *  * @param opcode a JVM instruction opcode. This opcode must be one of ILOAD, ISTORE, IALOAD,  *     IASTORE, IADD, ISUB, IMUL, IDIV, IREM, INEG, ISHL, ISHR, IUSHR, IAND, IOR, IXOR and  *     IRETURN.  * @return an opcode that is similar to the given opcode, but adapted to this {@link Type}. For  *     example, if this type is {@code float} and {@code opcode} is IRETURN, this method returns  *     FRETURN.  */ ;/**  * Returns a JVM instruction opcode adapted to this {@link Type}. This method must not be used for  * method types.  *  * @param opcode a JVM instruction opcode. This opcode must be one of ILOAD, ISTORE, IALOAD,  *     IASTORE, IADD, ISUB, IMUL, IDIV, IREM, INEG, ISHL, ISHR, IUSHR, IAND, IOR, IXOR and  *     IRETURN.  * @return an opcode that is similar to the given opcode, but adapted to this {@link Type}. For  *     example, if this type is {@code float} and {@code opcode} is IRETURN, this method returns  *     FRETURN.  */ public int getOpcode(final int opcode) {     if (opcode == Opcodes.IALOAD || opcode == Opcodes.IASTORE) {         switch(sort) {             case BOOLEAN:             case BYTE:                 return opcode + (Opcodes.BALOAD - Opcodes.IALOAD).             case CHAR:                 return opcode + (Opcodes.CALOAD - Opcodes.IALOAD).             case SHORT:                 return opcode + (Opcodes.SALOAD - Opcodes.IALOAD).             case INT:                 return opcode.             case FLOAT:                 return opcode + (Opcodes.FALOAD - Opcodes.IALOAD).             case LONG:                 return opcode + (Opcodes.LALOAD - Opcodes.IALOAD).             case DOUBLE:                 return opcode + (Opcodes.DALOAD - Opcodes.IALOAD).             case ARRAY:             case OBJECT:             case INTERNAL:                 return opcode + (Opcodes.AALOAD - Opcodes.IALOAD).             case METHOD:             case VOID:                 throw new UnsupportedOperationException().             default:                 throw new AssertionError().         }     } else {         switch(sort) {             case VOID:                 if (opcode != Opcodes.IRETURN) {                     throw new UnsupportedOperationException().                 }                 return Opcodes.RETURN.             case BOOLEAN:             case BYTE:             case CHAR:             case SHORT:             case INT:                 return opcode.             case FLOAT:                 return opcode + (Opcodes.FRETURN - Opcodes.IRETURN).             case LONG:                 return opcode + (Opcodes.LRETURN - Opcodes.IRETURN).             case DOUBLE:                 return opcode + (Opcodes.DRETURN - Opcodes.IRETURN).             case ARRAY:             case OBJECT:             case INTERNAL:                 if (opcode != Opcodes.ILOAD && opcode != Opcodes.ISTORE && opcode != Opcodes.IRETURN) {                     throw new UnsupportedOperationException().                 }                 return opcode + (Opcodes.ARETURN - Opcodes.IRETURN).             case METHOD:                 throw new UnsupportedOperationException().             default:                 throw new AssertionError().         }     } }
true;public;1;27;/**  * Tests if the given object is equal to this type.  *  * @param object the object to be compared to this type.  * @return {@literal true} if the given object is equal to this type.  */ ;// ----------------------------------------------------------------------------------------------- // Equals, hashCode and toString. // ----------------------------------------------------------------------------------------------- /**  * Tests if the given object is equal to this type.  *  * @param object the object to be compared to this type.  * @return {@literal true} if the given object is equal to this type.  */ @Override public boolean equals(final Object object) {     if (this == object) {         return true.     }     if (!(object instanceof Type)) {         return false.     }     Type other = (Type) object.     if ((sort == INTERNAL ? OBJECT : sort) != (other.sort == INTERNAL ? OBJECT : other.sort)) {         return false.     }     int begin = valueBegin.     int end = valueEnd.     int otherBegin = other.valueBegin.     int otherEnd = other.valueEnd.     // Compare the values.     if (end - begin != otherEnd - otherBegin) {         return false.     }     for (int i = begin, j = otherBegin. i < end. i++, j++) {         if (valueBuffer.charAt(i) != other.valueBuffer.charAt(j)) {             return false.         }     }     return true. }
true;public;0;10;/**  * Returns a hash code value for this type.  *  * @return a hash code value for this type.  */ ;/**  * Returns a hash code value for this type.  *  * @return a hash code value for this type.  */ @Override public int hashCode() {     int hashCode = 13 * (sort == INTERNAL ? OBJECT : sort).     if (sort >= ARRAY) {         for (int i = valueBegin, end = valueEnd. i < end. i++) {             hashCode = 17 * (hashCode + valueBuffer.charAt(i)).         }     }     return hashCode. }
true;public;0;4;/**  * Returns a string representation of this type.  *  * @return the descriptor of this type.  */ ;/**  * Returns a string representation of this type.  *  * @return the descriptor of this type.  */ @Override public String toString() {     return getDescriptor(). }
