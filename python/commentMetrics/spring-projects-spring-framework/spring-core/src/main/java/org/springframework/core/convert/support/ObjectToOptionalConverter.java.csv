commented;modifiers;parameterAmount;loc;comment;code
false;public;0;8;;@Override public Set<ConvertiblePair> getConvertibleTypes() {     Set<ConvertiblePair> convertibleTypes = new LinkedHashSet<>(4).     convertibleTypes.add(new ConvertiblePair(Collection.class, Optional.class)).     convertibleTypes.add(new ConvertiblePair(Object[].class, Optional.class)).     convertibleTypes.add(new ConvertiblePair(Object.class, Optional.class)).     return convertibleTypes. }
false;public;2;9;;@Override public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {     if (targetType.getResolvableType().hasGenerics()) {         return this.conversionService.canConvert(sourceType, new GenericTypeDescriptor(targetType)).     } else {         return true.     } }
false;public;3;20;;@Override public Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {     if (source == null) {         return Optional.empty().     } else if (source instanceof Optional) {         return source.     } else if (targetType.getResolvableType().hasGenerics()) {         Object target = this.conversionService.convert(source, sourceType, new GenericTypeDescriptor(targetType)).         if (target == null || (target.getClass().isArray() && Array.getLength(target) == 0) || (target instanceof Collection && ((Collection<?>) target).isEmpty())) {             return Optional.empty().         }         return Optional.of(target).     } else {         return Optional.of(source).     } }
