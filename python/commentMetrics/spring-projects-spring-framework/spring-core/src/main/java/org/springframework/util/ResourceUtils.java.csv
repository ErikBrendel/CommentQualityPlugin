commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;15;/**  * Return whether the given resource location is a URL:  * either a special "classpath" pseudo URL or a standard URL.  * @param resourceLocation the location String to check  * @return whether the location qualifies as a URL  * @see #CLASSPATH_URL_PREFIX  * @see java.net.URL  */ ;/**  * Return whether the given resource location is a URL:  * either a special "classpath" pseudo URL or a standard URL.  * @param resourceLocation the location String to check  * @return whether the location qualifies as a URL  * @see #CLASSPATH_URL_PREFIX  * @see java.net.URL  */ public static boolean isUrl(@Nullable String resourceLocation) {     if (resourceLocation == null) {         return false.     }     if (resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) {         return true.     }     try {         new URL(resourceLocation).         return true.     } catch (MalformedURLException ex) {         return false.     } }
true;public,static;1;28;/**  * Resolve the given resource location to a {@code java.net.URL}.  * <p>Does not check whether the URL actually exists. simply returns  * the URL that the given location would correspond to.  * @param resourceLocation the resource location to resolve: either a  * "classpath:" pseudo URL, a "file:" URL, or a plain file path  * @return a corresponding URL object  * @throws FileNotFoundException if the resource cannot be resolved to a URL  */ ;/**  * Resolve the given resource location to a {@code java.net.URL}.  * <p>Does not check whether the URL actually exists. simply returns  * the URL that the given location would correspond to.  * @param resourceLocation the resource location to resolve: either a  * "classpath:" pseudo URL, a "file:" URL, or a plain file path  * @return a corresponding URL object  * @throws FileNotFoundException if the resource cannot be resolved to a URL  */ public static URL getURL(String resourceLocation) throws FileNotFoundException {     Assert.notNull(resourceLocation, "Resource location must not be null").     if (resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) {         String path = resourceLocation.substring(CLASSPATH_URL_PREFIX.length()).         ClassLoader cl = ClassUtils.getDefaultClassLoader().         URL url = (cl != null ? cl.getResource(path) : ClassLoader.getSystemResource(path)).         if (url == null) {             String description = "class path resource [" + path + "]".             throw new FileNotFoundException(description + " cannot be resolved to URL because it does not exist").         }         return url.     }     try {         // try URL         return new URL(resourceLocation).     } catch (MalformedURLException ex) {         // no URL -> treat as file path         try {             return new File(resourceLocation).toURI().toURL().         } catch (MalformedURLException ex2) {             throw new FileNotFoundException("Resource location [" + resourceLocation + "] is neither a URL not a well-formed file path").         }     } }
true;public,static;1;22;/**  * Resolve the given resource location to a {@code java.io.File},  * i.e. to a file in the file system.  * <p>Does not check whether the file actually exists. simply returns  * the File that the given location would correspond to.  * @param resourceLocation the resource location to resolve: either a  * "classpath:" pseudo URL, a "file:" URL, or a plain file path  * @return a corresponding File object  * @throws FileNotFoundException if the resource cannot be resolved to  * a file in the file system  */ ;/**  * Resolve the given resource location to a {@code java.io.File},  * i.e. to a file in the file system.  * <p>Does not check whether the file actually exists. simply returns  * the File that the given location would correspond to.  * @param resourceLocation the resource location to resolve: either a  * "classpath:" pseudo URL, a "file:" URL, or a plain file path  * @return a corresponding File object  * @throws FileNotFoundException if the resource cannot be resolved to  * a file in the file system  */ public static File getFile(String resourceLocation) throws FileNotFoundException {     Assert.notNull(resourceLocation, "Resource location must not be null").     if (resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) {         String path = resourceLocation.substring(CLASSPATH_URL_PREFIX.length()).         String description = "class path resource [" + path + "]".         ClassLoader cl = ClassUtils.getDefaultClassLoader().         URL url = (cl != null ? cl.getResource(path) : ClassLoader.getSystemResource(path)).         if (url == null) {             throw new FileNotFoundException(description + " cannot be resolved to absolute file path because it does not exist").         }         return getFile(url, description).     }     try {         // try URL         return getFile(new URL(resourceLocation)).     } catch (MalformedURLException ex) {         // no URL -> treat as file path         return new File(resourceLocation).     } }
true;public,static;1;3;/**  * Resolve the given resource URL to a {@code java.io.File},  * i.e. to a file in the file system.  * @param resourceUrl the resource URL to resolve  * @return a corresponding File object  * @throws FileNotFoundException if the URL cannot be resolved to  * a file in the file system  */ ;/**  * Resolve the given resource URL to a {@code java.io.File},  * i.e. to a file in the file system.  * @param resourceUrl the resource URL to resolve  * @return a corresponding File object  * @throws FileNotFoundException if the URL cannot be resolved to  * a file in the file system  */ public static File getFile(URL resourceUrl) throws FileNotFoundException {     return getFile(resourceUrl, "URL"). }
true;public,static;2;15;/**  * Resolve the given resource URL to a {@code java.io.File},  * i.e. to a file in the file system.  * @param resourceUrl the resource URL to resolve  * @param description a description of the original resource that  * the URL was created for (for example, a class path location)  * @return a corresponding File object  * @throws FileNotFoundException if the URL cannot be resolved to  * a file in the file system  */ ;/**  * Resolve the given resource URL to a {@code java.io.File},  * i.e. to a file in the file system.  * @param resourceUrl the resource URL to resolve  * @param description a description of the original resource that  * the URL was created for (for example, a class path location)  * @return a corresponding File object  * @throws FileNotFoundException if the URL cannot be resolved to  * a file in the file system  */ public static File getFile(URL resourceUrl, String description) throws FileNotFoundException {     Assert.notNull(resourceUrl, "Resource URL must not be null").     if (!URL_PROTOCOL_FILE.equals(resourceUrl.getProtocol())) {         throw new FileNotFoundException(description + " cannot be resolved to absolute file path " + "because it does not reside in the file system: " + resourceUrl).     }     try {         return new File(toURI(resourceUrl).getSchemeSpecificPart()).     } catch (URISyntaxException ex) {         // Fallback for URLs that are not valid URIs (should hardly ever happen).         return new File(resourceUrl.getFile()).     } }
true;public,static;1;3;/**  * Resolve the given resource URI to a {@code java.io.File},  * i.e. to a file in the file system.  * @param resourceUri the resource URI to resolve  * @return a corresponding File object  * @throws FileNotFoundException if the URL cannot be resolved to  * a file in the file system  * @since 2.5  */ ;/**  * Resolve the given resource URI to a {@code java.io.File},  * i.e. to a file in the file system.  * @param resourceUri the resource URI to resolve  * @return a corresponding File object  * @throws FileNotFoundException if the URL cannot be resolved to  * a file in the file system  * @since 2.5  */ public static File getFile(URI resourceUri) throws FileNotFoundException {     return getFile(resourceUri, "URI"). }
true;public,static;2;9;/**  * Resolve the given resource URI to a {@code java.io.File},  * i.e. to a file in the file system.  * @param resourceUri the resource URI to resolve  * @param description a description of the original resource that  * the URI was created for (for example, a class path location)  * @return a corresponding File object  * @throws FileNotFoundException if the URL cannot be resolved to  * a file in the file system  * @since 2.5  */ ;/**  * Resolve the given resource URI to a {@code java.io.File},  * i.e. to a file in the file system.  * @param resourceUri the resource URI to resolve  * @param description a description of the original resource that  * the URI was created for (for example, a class path location)  * @return a corresponding File object  * @throws FileNotFoundException if the URL cannot be resolved to  * a file in the file system  * @since 2.5  */ public static File getFile(URI resourceUri, String description) throws FileNotFoundException {     Assert.notNull(resourceUri, "Resource URI must not be null").     if (!URL_PROTOCOL_FILE.equals(resourceUri.getScheme())) {         throw new FileNotFoundException(description + " cannot be resolved to absolute file path " + "because it does not reside in the file system: " + resourceUri).     }     return new File(resourceUri.getSchemeSpecificPart()). }
true;public,static;1;5;/**  * Determine whether the given URL points to a resource in the file system,  * i.e. has protocol "file", "vfsfile" or "vfs".  * @param url the URL to check  * @return whether the URL has been identified as a file system URL  */ ;/**  * Determine whether the given URL points to a resource in the file system,  * i.e. has protocol "file", "vfsfile" or "vfs".  * @param url the URL to check  * @return whether the URL has been identified as a file system URL  */ public static boolean isFileURL(URL url) {     String protocol = url.getProtocol().     return (URL_PROTOCOL_FILE.equals(protocol) || URL_PROTOCOL_VFSFILE.equals(protocol) || URL_PROTOCOL_VFS.equals(protocol)). }
true;public,static;1;6;/**  * Determine whether the given URL points to a resource in a jar file.  * i.e. has protocol "jar", "war, ""zip", "vfszip" or "wsjar".  * @param url the URL to check  * @return whether the URL has been identified as a JAR URL  */ ;/**  * Determine whether the given URL points to a resource in a jar file.  * i.e. has protocol "jar", "war, ""zip", "vfszip" or "wsjar".  * @param url the URL to check  * @return whether the URL has been identified as a JAR URL  */ public static boolean isJarURL(URL url) {     String protocol = url.getProtocol().     return (URL_PROTOCOL_JAR.equals(protocol) || URL_PROTOCOL_WAR.equals(protocol) || URL_PROTOCOL_ZIP.equals(protocol) || URL_PROTOCOL_VFSZIP.equals(protocol) || URL_PROTOCOL_WSJAR.equals(protocol)). }
true;public,static;1;4;/**  * Determine whether the given URL points to a jar file itself,  * that is, has protocol "file" and ends with the ".jar" extension.  * @param url the URL to check  * @return whether the URL has been identified as a JAR file URL  * @since 4.1  */ ;/**  * Determine whether the given URL points to a jar file itself,  * that is, has protocol "file" and ends with the ".jar" extension.  * @param url the URL to check  * @return whether the URL has been identified as a JAR file URL  * @since 4.1  */ public static boolean isJarFileURL(URL url) {     return (URL_PROTOCOL_FILE.equals(url.getProtocol()) && url.getPath().toLowerCase().endsWith(JAR_FILE_EXTENSION)). }
true;public,static;1;21;/**  * Extract the URL for the actual jar file from the given URL  * (which may point to a resource in a jar file or to a jar file itself).  * @param jarUrl the original URL  * @return the URL for the actual jar file  * @throws MalformedURLException if no valid jar file URL could be extracted  */ ;/**  * Extract the URL for the actual jar file from the given URL  * (which may point to a resource in a jar file or to a jar file itself).  * @param jarUrl the original URL  * @return the URL for the actual jar file  * @throws MalformedURLException if no valid jar file URL could be extracted  */ public static URL extractJarFileURL(URL jarUrl) throws MalformedURLException {     String urlFile = jarUrl.getFile().     int separatorIndex = urlFile.indexOf(JAR_URL_SEPARATOR).     if (separatorIndex != -1) {         String jarFile = urlFile.substring(0, separatorIndex).         try {             return new URL(jarFile).         } catch (MalformedURLException ex) {             // This usually indicates that the jar file resides in the file system.             if (!jarFile.startsWith("/")) {                 jarFile = "/" + jarFile.             }             return new URL(FILE_URL_PREFIX + jarFile).         }     } else {         return jarUrl.     } }
true;public,static;1;19;/**  * Extract the URL for the outermost archive from the given jar/war URL  * (which may point to a resource in a jar file or to a jar file itself).  * <p>In the case of a jar file nested within a war file, this will return  * a URL to the war file since that is the one resolvable in the file system.  * @param jarUrl the original URL  * @return the URL for the actual jar file  * @throws MalformedURLException if no valid jar file URL could be extracted  * @since 4.1.8  * @see #extractJarFileURL(URL)  */ ;/**  * Extract the URL for the outermost archive from the given jar/war URL  * (which may point to a resource in a jar file or to a jar file itself).  * <p>In the case of a jar file nested within a war file, this will return  * a URL to the war file since that is the one resolvable in the file system.  * @param jarUrl the original URL  * @return the URL for the actual jar file  * @throws MalformedURLException if no valid jar file URL could be extracted  * @since 4.1.8  * @see #extractJarFileURL(URL)  */ public static URL extractArchiveURL(URL jarUrl) throws MalformedURLException {     String urlFile = jarUrl.getFile().     int endIndex = urlFile.indexOf(WAR_URL_SEPARATOR).     if (endIndex != -1) {         // Tomcat's "war:file:...mywar.war*/WEB-INF/lib/myjar.jar!/myentry.txt"         String warFile = urlFile.substring(0, endIndex).         if (URL_PROTOCOL_WAR.equals(jarUrl.getProtocol())) {             return new URL(warFile).         }         int startIndex = warFile.indexOf(WAR_URL_PREFIX).         if (startIndex != -1) {             return new URL(warFile.substring(startIndex + WAR_URL_PREFIX.length())).         }     }     // Regular "jar:file:...myjar.jar!/myentry.txt"     return extractJarFileURL(jarUrl). }
true;public,static;1;3;/**  * Create a URI instance for the given URL,  * replacing spaces with "%20" URI encoding first.  * @param url the URL to convert into a URI instance  * @return the URI instance  * @throws URISyntaxException if the URL wasn't a valid URI  * @see java.net.URL#toURI()  */ ;/**  * Create a URI instance for the given URL,  * replacing spaces with "%20" URI encoding first.  * @param url the URL to convert into a URI instance  * @return the URI instance  * @throws URISyntaxException if the URL wasn't a valid URI  * @see java.net.URL#toURI()  */ public static URI toURI(URL url) throws URISyntaxException {     return toURI(url.toString()). }
true;public,static;1;3;/**  * Create a URI instance for the given location String,  * replacing spaces with "%20" URI encoding first.  * @param location the location String to convert into a URI instance  * @return the URI instance  * @throws URISyntaxException if the location wasn't a valid URI  */ ;/**  * Create a URI instance for the given location String,  * replacing spaces with "%20" URI encoding first.  * @param location the location String to convert into a URI instance  * @return the URI instance  * @throws URISyntaxException if the location wasn't a valid URI  */ public static URI toURI(String location) throws URISyntaxException {     return new URI(StringUtils.replace(location, " ", "%20")). }
true;public,static;1;3;/**  * Set the {@link URLConnection#setUseCaches "useCaches"} flag on the  * given connection, preferring {@code false} but leaving the  * flag at {@code true} for JNLP based resources.  * @param con the URLConnection to set the flag on  */ ;/**  * Set the {@link URLConnection#setUseCaches "useCaches"} flag on the  * given connection, preferring {@code false} but leaving the  * flag at {@code true} for JNLP based resources.  * @param con the URLConnection to set the flag on  */ public static void useCachesIfNecessary(URLConnection con) {     con.setUseCaches(con.getClass().getSimpleName().startsWith("JNLP")). }
