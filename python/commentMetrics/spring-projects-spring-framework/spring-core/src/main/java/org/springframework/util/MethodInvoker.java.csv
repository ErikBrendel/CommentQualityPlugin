# id;timestamp;commentText;codeText;commentWords;codeWords
MethodInvoker -> public void setTargetObject(@Nullable Object targetObject);1496837955;Set the target object on which to call the target method._Only necessary when the target method is not static__else, a target class is sufficient._@see #setTargetClass_@see #setTargetMethod;public void setTargetObject(@Nullable Object targetObject) {_		this.targetObject = targetObject__		if (targetObject != null) {_			this.targetClass = targetObject.getClass()__		}_	};set,the,target,object,on,which,to,call,the,target,method,only,necessary,when,the,target,method,is,not,static,else,a,target,class,is,sufficient,see,set,target,class,see,set,target,method;public,void,set,target,object,nullable,object,target,object,this,target,object,target,object,if,target,object,null,this,target,class,target,object,get,class
MethodInvoker -> public void setTargetObject(@Nullable Object targetObject);1498780456;Set the target object on which to call the target method._Only necessary when the target method is not static__else, a target class is sufficient._@see #setTargetClass_@see #setTargetMethod;public void setTargetObject(@Nullable Object targetObject) {_		this.targetObject = targetObject__		if (targetObject != null) {_			this.targetClass = targetObject.getClass()__		}_	};set,the,target,object,on,which,to,call,the,target,method,only,necessary,when,the,target,method,is,not,static,else,a,target,class,is,sufficient,see,set,target,class,see,set,target,method;public,void,set,target,object,nullable,object,target,object,this,target,object,target,object,if,target,object,null,this,target,class,target,object,get,class
MethodInvoker -> public void setTargetObject(@Nullable Object targetObject);1500448076;Set the target object on which to call the target method._Only necessary when the target method is not static__else, a target class is sufficient._@see #setTargetClass_@see #setTargetMethod;public void setTargetObject(@Nullable Object targetObject) {_		this.targetObject = targetObject__		if (targetObject != null) {_			this.targetClass = targetObject.getClass()__		}_	};set,the,target,object,on,which,to,call,the,target,method,only,necessary,when,the,target,method,is,not,static,else,a,target,class,is,sufficient,see,set,target,class,see,set,target,method;public,void,set,target,object,nullable,object,target,object,this,target,object,target,object,if,target,object,null,this,target,class,target,object,get,class
MethodInvoker -> public void setTargetObject(@Nullable Object targetObject);1508160858;Set the target object on which to call the target method._Only necessary when the target method is not static__else, a target class is sufficient._@see #setTargetClass_@see #setTargetMethod;public void setTargetObject(@Nullable Object targetObject) {_		this.targetObject = targetObject__		if (targetObject != null) {_			this.targetClass = targetObject.getClass()__		}_	};set,the,target,object,on,which,to,call,the,target,method,only,necessary,when,the,target,method,is,not,static,else,a,target,class,is,sufficient,see,set,target,class,see,set,target,method;public,void,set,target,object,nullable,object,target,object,this,target,object,target,object,if,target,object,null,this,target,class,target,object,get,class
MethodInvoker -> public void setTargetObject(@Nullable Object targetObject);1530174524;Set the target object on which to call the target method._Only necessary when the target method is not static__else, a target class is sufficient._@see #setTargetClass_@see #setTargetMethod;public void setTargetObject(@Nullable Object targetObject) {_		this.targetObject = targetObject__		if (targetObject != null) {_			this.targetClass = targetObject.getClass()__		}_	};set,the,target,object,on,which,to,call,the,target,method,only,necessary,when,the,target,method,is,not,static,else,a,target,class,is,sufficient,see,set,target,class,see,set,target,method;public,void,set,target,object,nullable,object,target,object,this,target,object,target,object,if,target,object,null,this,target,class,target,object,get,class
MethodInvoker -> public Object[] getArguments();1328020251;Return the arguments for the method invocation.;public Object[] getArguments() {_		return this.arguments__	};return,the,arguments,for,the,method,invocation;public,object,get,arguments,return,this,arguments
MethodInvoker -> public Object[] getArguments();1356735495;Return the arguments for the method invocation.;public Object[] getArguments() {_		return this.arguments__	};return,the,arguments,for,the,method,invocation;public,object,get,arguments,return,this,arguments
MethodInvoker -> public Object[] getArguments();1383520795;Return the arguments for the method invocation.;public Object[] getArguments() {_		return this.arguments__	};return,the,arguments,for,the,method,invocation;public,object,get,arguments,return,this,arguments
MethodInvoker -> public Object[] getArguments();1385412762;Return the arguments for the method invocation.;public Object[] getArguments() {_		return this.arguments__	};return,the,arguments,for,the,method,invocation;public,object,get,arguments,return,this,arguments
MethodInvoker -> public Object[] getArguments();1389789549;Return the arguments for the method invocation.;public Object[] getArguments() {_		return this.arguments__	};return,the,arguments,for,the,method,invocation;public,object,get,arguments,return,this,arguments
MethodInvoker -> public Object[] getArguments();1495868221;Return the arguments for the method invocation.;public Object[] getArguments() {_		return this.arguments__	};return,the,arguments,for,the,method,invocation;public,object,get,arguments,return,this,arguments
MethodInvoker -> public Object[] getArguments();1496837955;Return the arguments for the method invocation.;public Object[] getArguments() {_		return (this.arguments != null ? this.arguments : new Object[0])__	};return,the,arguments,for,the,method,invocation;public,object,get,arguments,return,this,arguments,null,this,arguments,new,object,0
MethodInvoker -> public Object[] getArguments();1498780456;Return the arguments for the method invocation.;public Object[] getArguments() {_		return (this.arguments != null ? this.arguments : new Object[0])__	};return,the,arguments,for,the,method,invocation;public,object,get,arguments,return,this,arguments,null,this,arguments,new,object,0
MethodInvoker -> public Object[] getArguments();1500448076;Return the arguments for the method invocation.;public Object[] getArguments() {_		return (this.arguments != null ? this.arguments : new Object[0])__	};return,the,arguments,for,the,method,invocation;public,object,get,arguments,return,this,arguments,null,this,arguments,new,object,0
MethodInvoker -> public Object[] getArguments();1508160858;Return the arguments for the method invocation.;public Object[] getArguments() {_		return (this.arguments != null ? this.arguments : new Object[0])__	};return,the,arguments,for,the,method,invocation;public,object,get,arguments,return,this,arguments,null,this,arguments,new,object,0
MethodInvoker -> public Object[] getArguments();1530174524;Return the arguments for the method invocation.;public Object[] getArguments() {_		return (this.arguments != null ? this.arguments : new Object[0])__	};return,the,arguments,for,the,method,invocation;public,object,get,arguments,return,this,arguments,null,this,arguments,new,object,0
MethodInvoker -> public static int getTypeDifferenceWeight(Class[] paramTypes, Object[] args);1328020251;Algorithm that judges the match between the declared parameter types of a candidate method_and a specific list of arguments that this method is supposed to be invoked with._<p>Determines a weight that represents the class hierarchy difference between types and_arguments. A direct match, i.e. type Integer -> arg of class Integer, does not increase_the result - all direct matches means weight 0. A match between type Object and arg of_class Integer would increase the weight by 2, due to the superclass 2 steps up in the_hierarchy (i.e. Object) being the last one that still matches the required type Object._Type Number and class Integer would increase the weight by 1 accordingly, due to the_superclass 1 step up the hierarchy (i.e. Number) still matching the required type Number._Therefore, with an arg of type Integer, a constructor (Integer) would be preferred to a_constructor (Number) which would in turn be preferred to a constructor (Object)._All argument weights get accumulated._@param paramTypes the parameter types to match_@param args the arguments to match_@return the accumulated weight for all arguments;public static int getTypeDifferenceWeight(Class[] paramTypes, Object[] args) {_		int result = 0__		for (int i = 0_ i < paramTypes.length_ i++) {_			if (!ClassUtils.isAssignableValue(paramTypes[i], args[i])) {_				return Integer.MAX_VALUE__			}_			if (args[i] != null) {_				Class paramType = paramTypes[i]__				Class superClass = args[i].getClass().getSuperclass()__				while (superClass != null) {_					if (paramType.equals(superClass)) {_						result = result + 2__						superClass = null__					}_					else if (ClassUtils.isAssignable(paramType, superClass)) {_						result = result + 2__						superClass = superClass.getSuperclass()__					}_					else {_						superClass = null__					}_				}_				if (paramType.isInterface()) {_					result = result + 1__				}_			}_		}_		return result__	};algorithm,that,judges,the,match,between,the,declared,parameter,types,of,a,candidate,method,and,a,specific,list,of,arguments,that,this,method,is,supposed,to,be,invoked,with,p,determines,a,weight,that,represents,the,class,hierarchy,difference,between,types,and,arguments,a,direct,match,i,e,type,integer,arg,of,class,integer,does,not,increase,the,result,all,direct,matches,means,weight,0,a,match,between,type,object,and,arg,of,class,integer,would,increase,the,weight,by,2,due,to,the,superclass,2,steps,up,in,the,hierarchy,i,e,object,being,the,last,one,that,still,matches,the,required,type,object,type,number,and,class,integer,would,increase,the,weight,by,1,accordingly,due,to,the,superclass,1,step,up,the,hierarchy,i,e,number,still,matching,the,required,type,number,therefore,with,an,arg,of,type,integer,a,constructor,integer,would,be,preferred,to,a,constructor,number,which,would,in,turn,be,preferred,to,a,constructor,object,all,argument,weights,get,accumulated,param,param,types,the,parameter,types,to,match,param,args,the,arguments,to,match,return,the,accumulated,weight,for,all,arguments;public,static,int,get,type,difference,weight,class,param,types,object,args,int,result,0,for,int,i,0,i,param,types,length,i,if,class,utils,is,assignable,value,param,types,i,args,i,return,integer,if,args,i,null,class,param,type,param,types,i,class,super,class,args,i,get,class,get,superclass,while,super,class,null,if,param,type,equals,super,class,result,result,2,super,class,null,else,if,class,utils,is,assignable,param,type,super,class,result,result,2,super,class,super,class,get,superclass,else,super,class,null,if,param,type,is,interface,result,result,1,return,result
MethodInvoker -> public static int getTypeDifferenceWeight(Class[] paramTypes, Object[] args);1356735495;Algorithm that judges the match between the declared parameter types of a candidate method_and a specific list of arguments that this method is supposed to be invoked with._<p>Determines a weight that represents the class hierarchy difference between types and_arguments. A direct match, i.e. type Integer -> arg of class Integer, does not increase_the result - all direct matches means weight 0. A match between type Object and arg of_class Integer would increase the weight by 2, due to the superclass 2 steps up in the_hierarchy (i.e. Object) being the last one that still matches the required type Object._Type Number and class Integer would increase the weight by 1 accordingly, due to the_superclass 1 step up the hierarchy (i.e. Number) still matching the required type Number._Therefore, with an arg of type Integer, a constructor (Integer) would be preferred to a_constructor (Number) which would in turn be preferred to a constructor (Object)._All argument weights get accumulated._@param paramTypes the parameter types to match_@param args the arguments to match_@return the accumulated weight for all arguments;public static int getTypeDifferenceWeight(Class[] paramTypes, Object[] args) {_		int result = 0__		for (int i = 0_ i < paramTypes.length_ i++) {_			if (!ClassUtils.isAssignableValue(paramTypes[i], args[i])) {_				return Integer.MAX_VALUE__			}_			if (args[i] != null) {_				Class paramType = paramTypes[i]__				Class superClass = args[i].getClass().getSuperclass()__				while (superClass != null) {_					if (paramType.equals(superClass)) {_						result = result + 2__						superClass = null__					}_					else if (ClassUtils.isAssignable(paramType, superClass)) {_						result = result + 2__						superClass = superClass.getSuperclass()__					}_					else {_						superClass = null__					}_				}_				if (paramType.isInterface()) {_					result = result + 1__				}_			}_		}_		return result__	};algorithm,that,judges,the,match,between,the,declared,parameter,types,of,a,candidate,method,and,a,specific,list,of,arguments,that,this,method,is,supposed,to,be,invoked,with,p,determines,a,weight,that,represents,the,class,hierarchy,difference,between,types,and,arguments,a,direct,match,i,e,type,integer,arg,of,class,integer,does,not,increase,the,result,all,direct,matches,means,weight,0,a,match,between,type,object,and,arg,of,class,integer,would,increase,the,weight,by,2,due,to,the,superclass,2,steps,up,in,the,hierarchy,i,e,object,being,the,last,one,that,still,matches,the,required,type,object,type,number,and,class,integer,would,increase,the,weight,by,1,accordingly,due,to,the,superclass,1,step,up,the,hierarchy,i,e,number,still,matching,the,required,type,number,therefore,with,an,arg,of,type,integer,a,constructor,integer,would,be,preferred,to,a,constructor,number,which,would,in,turn,be,preferred,to,a,constructor,object,all,argument,weights,get,accumulated,param,param,types,the,parameter,types,to,match,param,args,the,arguments,to,match,return,the,accumulated,weight,for,all,arguments;public,static,int,get,type,difference,weight,class,param,types,object,args,int,result,0,for,int,i,0,i,param,types,length,i,if,class,utils,is,assignable,value,param,types,i,args,i,return,integer,if,args,i,null,class,param,type,param,types,i,class,super,class,args,i,get,class,get,superclass,while,super,class,null,if,param,type,equals,super,class,result,result,2,super,class,null,else,if,class,utils,is,assignable,param,type,super,class,result,result,2,super,class,super,class,get,superclass,else,super,class,null,if,param,type,is,interface,result,result,1,return,result
MethodInvoker -> public Class getTargetClass();1328020251;Return the target class on which to call the target method.;public Class getTargetClass() {_		return this.targetClass__	};return,the,target,class,on,which,to,call,the,target,method;public,class,get,target,class,return,this,target,class
MethodInvoker -> public Class getTargetClass();1356735495;Return the target class on which to call the target method.;public Class getTargetClass() {_		return this.targetClass__	};return,the,target,class,on,which,to,call,the,target,method;public,class,get,target,class,return,this,target,class
MethodInvoker -> public Object getTargetObject();1328020251;Return the target object on which to call the target method.;public Object getTargetObject() {_		return this.targetObject__	};return,the,target,object,on,which,to,call,the,target,method;public,object,get,target,object,return,this,target,object
MethodInvoker -> public Object getTargetObject();1356735495;Return the target object on which to call the target method.;public Object getTargetObject() {_		return this.targetObject__	};return,the,target,object,on,which,to,call,the,target,method;public,object,get,target,object,return,this,target,object
MethodInvoker -> public Object getTargetObject();1383520795;Return the target object on which to call the target method.;public Object getTargetObject() {_		return this.targetObject__	};return,the,target,object,on,which,to,call,the,target,method;public,object,get,target,object,return,this,target,object
MethodInvoker -> public Object getTargetObject();1385412762;Return the target object on which to call the target method.;public Object getTargetObject() {_		return this.targetObject__	};return,the,target,object,on,which,to,call,the,target,method;public,object,get,target,object,return,this,target,object
MethodInvoker -> public Object getTargetObject();1389789549;Return the target object on which to call the target method.;public Object getTargetObject() {_		return this.targetObject__	};return,the,target,object,on,which,to,call,the,target,method;public,object,get,target,object,return,this,target,object
MethodInvoker -> public Object getTargetObject();1495868221;Return the target object on which to call the target method.;public Object getTargetObject() {_		return this.targetObject__	};return,the,target,object,on,which,to,call,the,target,method;public,object,get,target,object,return,this,target,object
MethodInvoker -> public Method getPreparedMethod() throws IllegalStateException;1328020251;Return the prepared Method object that will be invoked._<p>Can for example be used to determine the return type._@return the prepared Method object (never <code>null</code>)_@throws IllegalStateException if the invoker hasn't been prepared yet_@see #prepare_@see #invoke;public Method getPreparedMethod() throws IllegalStateException {_		if (this.methodObject == null) {_			throw new IllegalStateException("prepare() must be called prior to invoke() on MethodInvoker")__		}_		return this.methodObject__	};return,the,prepared,method,object,that,will,be,invoked,p,can,for,example,be,used,to,determine,the,return,type,return,the,prepared,method,object,never,code,null,code,throws,illegal,state,exception,if,the,invoker,hasn,t,been,prepared,yet,see,prepare,see,invoke;public,method,get,prepared,method,throws,illegal,state,exception,if,this,method,object,null,throw,new,illegal,state,exception,prepare,must,be,called,prior,to,invoke,on,method,invoker,return,this,method,object
MethodInvoker -> public Method getPreparedMethod() throws IllegalStateException;1356735495;Return the prepared Method object that will be invoked._<p>Can for example be used to determine the return type._@return the prepared Method object (never {@code null})_@throws IllegalStateException if the invoker hasn't been prepared yet_@see #prepare_@see #invoke;public Method getPreparedMethod() throws IllegalStateException {_		if (this.methodObject == null) {_			throw new IllegalStateException("prepare() must be called prior to invoke() on MethodInvoker")__		}_		return this.methodObject__	};return,the,prepared,method,object,that,will,be,invoked,p,can,for,example,be,used,to,determine,the,return,type,return,the,prepared,method,object,never,code,null,throws,illegal,state,exception,if,the,invoker,hasn,t,been,prepared,yet,see,prepare,see,invoke;public,method,get,prepared,method,throws,illegal,state,exception,if,this,method,object,null,throw,new,illegal,state,exception,prepare,must,be,called,prior,to,invoke,on,method,invoker,return,this,method,object
MethodInvoker -> public Method getPreparedMethod() throws IllegalStateException;1383520795;Return the prepared Method object that will be invoked._<p>Can for example be used to determine the return type._@return the prepared Method object (never {@code null})_@throws IllegalStateException if the invoker hasn't been prepared yet_@see #prepare_@see #invoke;public Method getPreparedMethod() throws IllegalStateException {_		if (this.methodObject == null) {_			throw new IllegalStateException("prepare() must be called prior to invoke() on MethodInvoker")__		}_		return this.methodObject__	};return,the,prepared,method,object,that,will,be,invoked,p,can,for,example,be,used,to,determine,the,return,type,return,the,prepared,method,object,never,code,null,throws,illegal,state,exception,if,the,invoker,hasn,t,been,prepared,yet,see,prepare,see,invoke;public,method,get,prepared,method,throws,illegal,state,exception,if,this,method,object,null,throw,new,illegal,state,exception,prepare,must,be,called,prior,to,invoke,on,method,invoker,return,this,method,object
MethodInvoker -> public Method getPreparedMethod() throws IllegalStateException;1385412762;Return the prepared Method object that will be invoked._<p>Can for example be used to determine the return type._@return the prepared Method object (never {@code null})_@throws IllegalStateException if the invoker hasn't been prepared yet_@see #prepare_@see #invoke;public Method getPreparedMethod() throws IllegalStateException {_		if (this.methodObject == null) {_			throw new IllegalStateException("prepare() must be called prior to invoke() on MethodInvoker")__		}_		return this.methodObject__	};return,the,prepared,method,object,that,will,be,invoked,p,can,for,example,be,used,to,determine,the,return,type,return,the,prepared,method,object,never,code,null,throws,illegal,state,exception,if,the,invoker,hasn,t,been,prepared,yet,see,prepare,see,invoke;public,method,get,prepared,method,throws,illegal,state,exception,if,this,method,object,null,throw,new,illegal,state,exception,prepare,must,be,called,prior,to,invoke,on,method,invoker,return,this,method,object
MethodInvoker -> public Method getPreparedMethod() throws IllegalStateException;1389789549;Return the prepared Method object that will be invoked._<p>Can for example be used to determine the return type._@return the prepared Method object (never {@code null})_@throws IllegalStateException if the invoker hasn't been prepared yet_@see #prepare_@see #invoke;public Method getPreparedMethod() throws IllegalStateException {_		if (this.methodObject == null) {_			throw new IllegalStateException("prepare() must be called prior to invoke() on MethodInvoker")__		}_		return this.methodObject__	};return,the,prepared,method,object,that,will,be,invoked,p,can,for,example,be,used,to,determine,the,return,type,return,the,prepared,method,object,never,code,null,throws,illegal,state,exception,if,the,invoker,hasn,t,been,prepared,yet,see,prepare,see,invoke;public,method,get,prepared,method,throws,illegal,state,exception,if,this,method,object,null,throw,new,illegal,state,exception,prepare,must,be,called,prior,to,invoke,on,method,invoker,return,this,method,object
MethodInvoker -> public Method getPreparedMethod() throws IllegalStateException;1495868221;Return the prepared Method object that will be invoked._<p>Can for example be used to determine the return type._@return the prepared Method object (never {@code null})_@throws IllegalStateException if the invoker hasn't been prepared yet_@see #prepare_@see #invoke;public Method getPreparedMethod() throws IllegalStateException {_		if (this.methodObject == null) {_			throw new IllegalStateException("prepare() must be called prior to invoke() on MethodInvoker")__		}_		return this.methodObject__	};return,the,prepared,method,object,that,will,be,invoked,p,can,for,example,be,used,to,determine,the,return,type,return,the,prepared,method,object,never,code,null,throws,illegal,state,exception,if,the,invoker,hasn,t,been,prepared,yet,see,prepare,see,invoke;public,method,get,prepared,method,throws,illegal,state,exception,if,this,method,object,null,throw,new,illegal,state,exception,prepare,must,be,called,prior,to,invoke,on,method,invoker,return,this,method,object
MethodInvoker -> public Method getPreparedMethod() throws IllegalStateException;1496837955;Return the prepared Method object that will be invoked._<p>Can for example be used to determine the return type._@return the prepared Method object (never {@code null})_@throws IllegalStateException if the invoker hasn't been prepared yet_@see #prepare_@see #invoke;public Method getPreparedMethod() throws IllegalStateException {_		if (this.methodObject == null) {_			throw new IllegalStateException("prepare() must be called prior to invoke() on MethodInvoker")__		}_		return this.methodObject__	};return,the,prepared,method,object,that,will,be,invoked,p,can,for,example,be,used,to,determine,the,return,type,return,the,prepared,method,object,never,code,null,throws,illegal,state,exception,if,the,invoker,hasn,t,been,prepared,yet,see,prepare,see,invoke;public,method,get,prepared,method,throws,illegal,state,exception,if,this,method,object,null,throw,new,illegal,state,exception,prepare,must,be,called,prior,to,invoke,on,method,invoker,return,this,method,object
MethodInvoker -> public Method getPreparedMethod() throws IllegalStateException;1498780456;Return the prepared Method object that will be invoked._<p>Can for example be used to determine the return type._@return the prepared Method object (never {@code null})_@throws IllegalStateException if the invoker hasn't been prepared yet_@see #prepare_@see #invoke;public Method getPreparedMethod() throws IllegalStateException {_		if (this.methodObject == null) {_			throw new IllegalStateException("prepare() must be called prior to invoke() on MethodInvoker")__		}_		return this.methodObject__	};return,the,prepared,method,object,that,will,be,invoked,p,can,for,example,be,used,to,determine,the,return,type,return,the,prepared,method,object,never,code,null,throws,illegal,state,exception,if,the,invoker,hasn,t,been,prepared,yet,see,prepare,see,invoke;public,method,get,prepared,method,throws,illegal,state,exception,if,this,method,object,null,throw,new,illegal,state,exception,prepare,must,be,called,prior,to,invoke,on,method,invoker,return,this,method,object
MethodInvoker -> public Method getPreparedMethod() throws IllegalStateException;1500448076;Return the prepared Method object that will be invoked._<p>Can for example be used to determine the return type._@return the prepared Method object (never {@code null})_@throws IllegalStateException if the invoker hasn't been prepared yet_@see #prepare_@see #invoke;public Method getPreparedMethod() throws IllegalStateException {_		if (this.methodObject == null) {_			throw new IllegalStateException("prepare() must be called prior to invoke() on MethodInvoker")__		}_		return this.methodObject__	};return,the,prepared,method,object,that,will,be,invoked,p,can,for,example,be,used,to,determine,the,return,type,return,the,prepared,method,object,never,code,null,throws,illegal,state,exception,if,the,invoker,hasn,t,been,prepared,yet,see,prepare,see,invoke;public,method,get,prepared,method,throws,illegal,state,exception,if,this,method,object,null,throw,new,illegal,state,exception,prepare,must,be,called,prior,to,invoke,on,method,invoker,return,this,method,object
MethodInvoker -> public Method getPreparedMethod() throws IllegalStateException;1508160858;Return the prepared Method object that will be invoked._<p>Can for example be used to determine the return type._@return the prepared Method object (never {@code null})_@throws IllegalStateException if the invoker hasn't been prepared yet_@see #prepare_@see #invoke;public Method getPreparedMethod() throws IllegalStateException {_		if (this.methodObject == null) {_			throw new IllegalStateException("prepare() must be called prior to invoke() on MethodInvoker")__		}_		return this.methodObject__	};return,the,prepared,method,object,that,will,be,invoked,p,can,for,example,be,used,to,determine,the,return,type,return,the,prepared,method,object,never,code,null,throws,illegal,state,exception,if,the,invoker,hasn,t,been,prepared,yet,see,prepare,see,invoke;public,method,get,prepared,method,throws,illegal,state,exception,if,this,method,object,null,throw,new,illegal,state,exception,prepare,must,be,called,prior,to,invoke,on,method,invoker,return,this,method,object
MethodInvoker -> public Method getPreparedMethod() throws IllegalStateException;1530174524;Return the prepared Method object that will be invoked._<p>Can for example be used to determine the return type._@return the prepared Method object (never {@code null})_@throws IllegalStateException if the invoker hasn't been prepared yet_@see #prepare_@see #invoke;public Method getPreparedMethod() throws IllegalStateException {_		if (this.methodObject == null) {_			throw new IllegalStateException("prepare() must be called prior to invoke() on MethodInvoker")__		}_		return this.methodObject__	};return,the,prepared,method,object,that,will,be,invoked,p,can,for,example,be,used,to,determine,the,return,type,return,the,prepared,method,object,never,code,null,throws,illegal,state,exception,if,the,invoker,hasn,t,been,prepared,yet,see,prepare,see,invoke;public,method,get,prepared,method,throws,illegal,state,exception,if,this,method,object,null,throw,new,illegal,state,exception,prepare,must,be,called,prior,to,invoke,on,method,invoker,return,this,method,object
MethodInvoker -> public void setTargetClass(@Nullable Class<?> targetClass);1500448076;Set the target class on which to call the target method._Only necessary when the target method is static_ else,_a target object needs to be specified anyway._@see #setTargetObject_@see #setTargetMethod;public void setTargetClass(@Nullable Class<?> targetClass) {_		this.targetClass = targetClass__	};set,the,target,class,on,which,to,call,the,target,method,only,necessary,when,the,target,method,is,static,else,a,target,object,needs,to,be,specified,anyway,see,set,target,object,see,set,target,method;public,void,set,target,class,nullable,class,target,class,this,target,class,target,class
MethodInvoker -> public void setTargetClass(@Nullable Class<?> targetClass);1508160858;Set the target class on which to call the target method._Only necessary when the target method is static_ else,_a target object needs to be specified anyway._@see #setTargetObject_@see #setTargetMethod;public void setTargetClass(@Nullable Class<?> targetClass) {_		this.targetClass = targetClass__	};set,the,target,class,on,which,to,call,the,target,method,only,necessary,when,the,target,method,is,static,else,a,target,object,needs,to,be,specified,anyway,see,set,target,object,see,set,target,method;public,void,set,target,class,nullable,class,target,class,this,target,class,target,class
MethodInvoker -> public void setTargetClass(@Nullable Class<?> targetClass);1530174524;Set the target class on which to call the target method._Only necessary when the target method is static_ else,_a target object needs to be specified anyway._@see #setTargetObject_@see #setTargetMethod;public void setTargetClass(@Nullable Class<?> targetClass) {_		this.targetClass = targetClass__	};set,the,target,class,on,which,to,call,the,target,method,only,necessary,when,the,target,method,is,static,else,a,target,object,needs,to,be,specified,anyway,see,set,target,object,see,set,target,method;public,void,set,target,class,nullable,class,target,class,this,target,class,target,class
MethodInvoker -> @Nullable 	public Object invoke() throws InvocationTargetException, IllegalAccessException;1495868221;Invoke the specified method._<p>The invoker needs to have been prepared before._@return the object (possibly null) returned by the method invocation,_or {@code null} if the method has a void return type_@throws InvocationTargetException if the target method threw an exception_@throws IllegalAccessException if the target method couldn't be accessed_@see #prepare;@Nullable_	public Object invoke() throws InvocationTargetException, IllegalAccessException {_		_		Object targetObject = getTargetObject()__		Method preparedMethod = getPreparedMethod()__		if (targetObject == null && !Modifier.isStatic(preparedMethod.getModifiers())) {_			throw new IllegalArgumentException("Target method must not be non-static without a target")__		}_		ReflectionUtils.makeAccessible(preparedMethod)__		return preparedMethod.invoke(targetObject, getArguments())__	};invoke,the,specified,method,p,the,invoker,needs,to,have,been,prepared,before,return,the,object,possibly,null,returned,by,the,method,invocation,or,code,null,if,the,method,has,a,void,return,type,throws,invocation,target,exception,if,the,target,method,threw,an,exception,throws,illegal,access,exception,if,the,target,method,couldn,t,be,accessed,see,prepare;nullable,public,object,invoke,throws,invocation,target,exception,illegal,access,exception,object,target,object,get,target,object,method,prepared,method,get,prepared,method,if,target,object,null,modifier,is,static,prepared,method,get,modifiers,throw,new,illegal,argument,exception,target,method,must,not,be,non,static,without,a,target,reflection,utils,make,accessible,prepared,method,return,prepared,method,invoke,target,object,get,arguments
MethodInvoker -> @Nullable 	public Object invoke() throws InvocationTargetException, IllegalAccessException;1496837955;Invoke the specified method._<p>The invoker needs to have been prepared before._@return the object (possibly null) returned by the method invocation,_or {@code null} if the method has a void return type_@throws InvocationTargetException if the target method threw an exception_@throws IllegalAccessException if the target method couldn't be accessed_@see #prepare;@Nullable_	public Object invoke() throws InvocationTargetException, IllegalAccessException {_		_		Object targetObject = getTargetObject()__		Method preparedMethod = getPreparedMethod()__		if (targetObject == null && !Modifier.isStatic(preparedMethod.getModifiers())) {_			throw new IllegalArgumentException("Target method must not be non-static without a target")__		}_		ReflectionUtils.makeAccessible(preparedMethod)__		return preparedMethod.invoke(targetObject, getArguments())__	};invoke,the,specified,method,p,the,invoker,needs,to,have,been,prepared,before,return,the,object,possibly,null,returned,by,the,method,invocation,or,code,null,if,the,method,has,a,void,return,type,throws,invocation,target,exception,if,the,target,method,threw,an,exception,throws,illegal,access,exception,if,the,target,method,couldn,t,be,accessed,see,prepare;nullable,public,object,invoke,throws,invocation,target,exception,illegal,access,exception,object,target,object,get,target,object,method,prepared,method,get,prepared,method,if,target,object,null,modifier,is,static,prepared,method,get,modifiers,throw,new,illegal,argument,exception,target,method,must,not,be,non,static,without,a,target,reflection,utils,make,accessible,prepared,method,return,prepared,method,invoke,target,object,get,arguments
MethodInvoker -> @Nullable 	public Object invoke() throws InvocationTargetException, IllegalAccessException;1498780456;Invoke the specified method._<p>The invoker needs to have been prepared before._@return the object (possibly null) returned by the method invocation,_or {@code null} if the method has a void return type_@throws InvocationTargetException if the target method threw an exception_@throws IllegalAccessException if the target method couldn't be accessed_@see #prepare;@Nullable_	public Object invoke() throws InvocationTargetException, IllegalAccessException {_		_		Object targetObject = getTargetObject()__		Method preparedMethod = getPreparedMethod()__		if (targetObject == null && !Modifier.isStatic(preparedMethod.getModifiers())) {_			throw new IllegalArgumentException("Target method must not be non-static without a target")__		}_		ReflectionUtils.makeAccessible(preparedMethod)__		return preparedMethod.invoke(targetObject, getArguments())__	};invoke,the,specified,method,p,the,invoker,needs,to,have,been,prepared,before,return,the,object,possibly,null,returned,by,the,method,invocation,or,code,null,if,the,method,has,a,void,return,type,throws,invocation,target,exception,if,the,target,method,threw,an,exception,throws,illegal,access,exception,if,the,target,method,couldn,t,be,accessed,see,prepare;nullable,public,object,invoke,throws,invocation,target,exception,illegal,access,exception,object,target,object,get,target,object,method,prepared,method,get,prepared,method,if,target,object,null,modifier,is,static,prepared,method,get,modifiers,throw,new,illegal,argument,exception,target,method,must,not,be,non,static,without,a,target,reflection,utils,make,accessible,prepared,method,return,prepared,method,invoke,target,object,get,arguments
MethodInvoker -> @Nullable 	public Object invoke() throws InvocationTargetException, IllegalAccessException;1500448076;Invoke the specified method._<p>The invoker needs to have been prepared before._@return the object (possibly null) returned by the method invocation,_or {@code null} if the method has a void return type_@throws InvocationTargetException if the target method threw an exception_@throws IllegalAccessException if the target method couldn't be accessed_@see #prepare;@Nullable_	public Object invoke() throws InvocationTargetException, IllegalAccessException {_		_		Object targetObject = getTargetObject()__		Method preparedMethod = getPreparedMethod()__		if (targetObject == null && !Modifier.isStatic(preparedMethod.getModifiers())) {_			throw new IllegalArgumentException("Target method must not be non-static without a target")__		}_		ReflectionUtils.makeAccessible(preparedMethod)__		return preparedMethod.invoke(targetObject, getArguments())__	};invoke,the,specified,method,p,the,invoker,needs,to,have,been,prepared,before,return,the,object,possibly,null,returned,by,the,method,invocation,or,code,null,if,the,method,has,a,void,return,type,throws,invocation,target,exception,if,the,target,method,threw,an,exception,throws,illegal,access,exception,if,the,target,method,couldn,t,be,accessed,see,prepare;nullable,public,object,invoke,throws,invocation,target,exception,illegal,access,exception,object,target,object,get,target,object,method,prepared,method,get,prepared,method,if,target,object,null,modifier,is,static,prepared,method,get,modifiers,throw,new,illegal,argument,exception,target,method,must,not,be,non,static,without,a,target,reflection,utils,make,accessible,prepared,method,return,prepared,method,invoke,target,object,get,arguments
MethodInvoker -> @Nullable 	public Object invoke() throws InvocationTargetException, IllegalAccessException;1508160858;Invoke the specified method._<p>The invoker needs to have been prepared before._@return the object (possibly null) returned by the method invocation,_or {@code null} if the method has a void return type_@throws InvocationTargetException if the target method threw an exception_@throws IllegalAccessException if the target method couldn't be accessed_@see #prepare;@Nullable_	public Object invoke() throws InvocationTargetException, IllegalAccessException {_		_		Object targetObject = getTargetObject()__		Method preparedMethod = getPreparedMethod()__		if (targetObject == null && !Modifier.isStatic(preparedMethod.getModifiers())) {_			throw new IllegalArgumentException("Target method must not be non-static without a target")__		}_		ReflectionUtils.makeAccessible(preparedMethod)__		return preparedMethod.invoke(targetObject, getArguments())__	};invoke,the,specified,method,p,the,invoker,needs,to,have,been,prepared,before,return,the,object,possibly,null,returned,by,the,method,invocation,or,code,null,if,the,method,has,a,void,return,type,throws,invocation,target,exception,if,the,target,method,threw,an,exception,throws,illegal,access,exception,if,the,target,method,couldn,t,be,accessed,see,prepare;nullable,public,object,invoke,throws,invocation,target,exception,illegal,access,exception,object,target,object,get,target,object,method,prepared,method,get,prepared,method,if,target,object,null,modifier,is,static,prepared,method,get,modifiers,throw,new,illegal,argument,exception,target,method,must,not,be,non,static,without,a,target,reflection,utils,make,accessible,prepared,method,return,prepared,method,invoke,target,object,get,arguments
MethodInvoker -> @Nullable 	public Object invoke() throws InvocationTargetException, IllegalAccessException;1530174524;Invoke the specified method._<p>The invoker needs to have been prepared before._@return the object (possibly null) returned by the method invocation,_or {@code null} if the method has a void return type_@throws InvocationTargetException if the target method threw an exception_@throws IllegalAccessException if the target method couldn't be accessed_@see #prepare;@Nullable_	public Object invoke() throws InvocationTargetException, IllegalAccessException {_		_		Object targetObject = getTargetObject()__		Method preparedMethod = getPreparedMethod()__		if (targetObject == null && !Modifier.isStatic(preparedMethod.getModifiers())) {_			throw new IllegalArgumentException("Target method must not be non-static without a target")__		}_		ReflectionUtils.makeAccessible(preparedMethod)__		return preparedMethod.invoke(targetObject, getArguments())__	};invoke,the,specified,method,p,the,invoker,needs,to,have,been,prepared,before,return,the,object,possibly,null,returned,by,the,method,invocation,or,code,null,if,the,method,has,a,void,return,type,throws,invocation,target,exception,if,the,target,method,threw,an,exception,throws,illegal,access,exception,if,the,target,method,couldn,t,be,accessed,see,prepare;nullable,public,object,invoke,throws,invocation,target,exception,illegal,access,exception,object,target,object,get,target,object,method,prepared,method,get,prepared,method,if,target,object,null,modifier,is,static,prepared,method,get,modifiers,throw,new,illegal,argument,exception,target,method,must,not,be,non,static,without,a,target,reflection,utils,make,accessible,prepared,method,return,prepared,method,invoke,target,object,get,arguments
MethodInvoker -> public void setTargetClass(Class targetClass);1328020251;Set the target class on which to call the target method._Only necessary when the target method is static_ else,_a target object needs to be specified anyway._@see #setTargetObject_@see #setTargetMethod;public void setTargetClass(Class targetClass) {_		this.targetClass = targetClass__	};set,the,target,class,on,which,to,call,the,target,method,only,necessary,when,the,target,method,is,static,else,a,target,object,needs,to,be,specified,anyway,see,set,target,object,see,set,target,method;public,void,set,target,class,class,target,class,this,target,class,target,class
MethodInvoker -> public void setTargetClass(Class targetClass);1356735495;Set the target class on which to call the target method._Only necessary when the target method is static_ else,_a target object needs to be specified anyway._@see #setTargetObject_@see #setTargetMethod;public void setTargetClass(Class targetClass) {_		this.targetClass = targetClass__	};set,the,target,class,on,which,to,call,the,target,method,only,necessary,when,the,target,method,is,static,else,a,target,object,needs,to,be,specified,anyway,see,set,target,object,see,set,target,method;public,void,set,target,class,class,target,class,this,target,class,target,class
MethodInvoker -> public static int getTypeDifferenceWeight(Class<?>[] paramTypes, Object[] args);1383520795;Algorithm that judges the match between the declared parameter types of a candidate method_and a specific list of arguments that this method is supposed to be invoked with._<p>Determines a weight that represents the class hierarchy difference between types and_arguments. A direct match, i.e. type Integer -> arg of class Integer, does not increase_the result - all direct matches means weight 0. A match between type Object and arg of_class Integer would increase the weight by 2, due to the superclass 2 steps up in the_hierarchy (i.e. Object) being the last one that still matches the required type Object._Type Number and class Integer would increase the weight by 1 accordingly, due to the_superclass 1 step up the hierarchy (i.e. Number) still matching the required type Number._Therefore, with an arg of type Integer, a constructor (Integer) would be preferred to a_constructor (Number) which would in turn be preferred to a constructor (Object)._All argument weights get accumulated._<p>Note: This is the algorithm used by MethodInvoker itself and also the algorithm_used for constructor and factory method selection in Spring's bean container (in case_of lenient constructor resolution which is the default for regular bean definitions)._@param paramTypes the parameter types to match_@param args the arguments to match_@return the accumulated weight for all arguments;public static int getTypeDifferenceWeight(Class<?>[] paramTypes, Object[] args) {_		int result = 0__		for (int i = 0_ i < paramTypes.length_ i++) {_			if (!ClassUtils.isAssignableValue(paramTypes[i], args[i])) {_				return Integer.MAX_VALUE__			}_			if (args[i] != null) {_				Class<?> paramType = paramTypes[i]__				Class<?> superClass = args[i].getClass().getSuperclass()__				while (superClass != null) {_					if (paramType.equals(superClass)) {_						result = result + 2__						superClass = null__					}_					else if (ClassUtils.isAssignable(paramType, superClass)) {_						result = result + 2__						superClass = superClass.getSuperclass()__					}_					else {_						superClass = null__					}_				}_				if (paramType.isInterface()) {_					result = result + 1__				}_			}_		}_		return result__	};algorithm,that,judges,the,match,between,the,declared,parameter,types,of,a,candidate,method,and,a,specific,list,of,arguments,that,this,method,is,supposed,to,be,invoked,with,p,determines,a,weight,that,represents,the,class,hierarchy,difference,between,types,and,arguments,a,direct,match,i,e,type,integer,arg,of,class,integer,does,not,increase,the,result,all,direct,matches,means,weight,0,a,match,between,type,object,and,arg,of,class,integer,would,increase,the,weight,by,2,due,to,the,superclass,2,steps,up,in,the,hierarchy,i,e,object,being,the,last,one,that,still,matches,the,required,type,object,type,number,and,class,integer,would,increase,the,weight,by,1,accordingly,due,to,the,superclass,1,step,up,the,hierarchy,i,e,number,still,matching,the,required,type,number,therefore,with,an,arg,of,type,integer,a,constructor,integer,would,be,preferred,to,a,constructor,number,which,would,in,turn,be,preferred,to,a,constructor,object,all,argument,weights,get,accumulated,p,note,this,is,the,algorithm,used,by,method,invoker,itself,and,also,the,algorithm,used,for,constructor,and,factory,method,selection,in,spring,s,bean,container,in,case,of,lenient,constructor,resolution,which,is,the,default,for,regular,bean,definitions,param,param,types,the,parameter,types,to,match,param,args,the,arguments,to,match,return,the,accumulated,weight,for,all,arguments;public,static,int,get,type,difference,weight,class,param,types,object,args,int,result,0,for,int,i,0,i,param,types,length,i,if,class,utils,is,assignable,value,param,types,i,args,i,return,integer,if,args,i,null,class,param,type,param,types,i,class,super,class,args,i,get,class,get,superclass,while,super,class,null,if,param,type,equals,super,class,result,result,2,super,class,null,else,if,class,utils,is,assignable,param,type,super,class,result,result,2,super,class,super,class,get,superclass,else,super,class,null,if,param,type,is,interface,result,result,1,return,result
MethodInvoker -> public static int getTypeDifferenceWeight(Class<?>[] paramTypes, Object[] args);1385412762;Algorithm that judges the match between the declared parameter types of a candidate method_and a specific list of arguments that this method is supposed to be invoked with._<p>Determines a weight that represents the class hierarchy difference between types and_arguments. A direct match, i.e. type Integer -> arg of class Integer, does not increase_the result - all direct matches means weight 0. A match between type Object and arg of_class Integer would increase the weight by 2, due to the superclass 2 steps up in the_hierarchy (i.e. Object) being the last one that still matches the required type Object._Type Number and class Integer would increase the weight by 1 accordingly, due to the_superclass 1 step up the hierarchy (i.e. Number) still matching the required type Number._Therefore, with an arg of type Integer, a constructor (Integer) would be preferred to a_constructor (Number) which would in turn be preferred to a constructor (Object)._All argument weights get accumulated._<p>Note: This is the algorithm used by MethodInvoker itself and also the algorithm_used for constructor and factory method selection in Spring's bean container (in case_of lenient constructor resolution which is the default for regular bean definitions)._@param paramTypes the parameter types to match_@param args the arguments to match_@return the accumulated weight for all arguments;public static int getTypeDifferenceWeight(Class<?>[] paramTypes, Object[] args) {_		int result = 0__		for (int i = 0_ i < paramTypes.length_ i++) {_			if (!ClassUtils.isAssignableValue(paramTypes[i], args[i])) {_				return Integer.MAX_VALUE__			}_			if (args[i] != null) {_				Class<?> paramType = paramTypes[i]__				Class<?> superClass = args[i].getClass().getSuperclass()__				while (superClass != null) {_					if (paramType.equals(superClass)) {_						result = result + 2__						superClass = null__					}_					else if (ClassUtils.isAssignable(paramType, superClass)) {_						result = result + 2__						superClass = superClass.getSuperclass()__					}_					else {_						superClass = null__					}_				}_				if (paramType.isInterface()) {_					result = result + 1__				}_			}_		}_		return result__	};algorithm,that,judges,the,match,between,the,declared,parameter,types,of,a,candidate,method,and,a,specific,list,of,arguments,that,this,method,is,supposed,to,be,invoked,with,p,determines,a,weight,that,represents,the,class,hierarchy,difference,between,types,and,arguments,a,direct,match,i,e,type,integer,arg,of,class,integer,does,not,increase,the,result,all,direct,matches,means,weight,0,a,match,between,type,object,and,arg,of,class,integer,would,increase,the,weight,by,2,due,to,the,superclass,2,steps,up,in,the,hierarchy,i,e,object,being,the,last,one,that,still,matches,the,required,type,object,type,number,and,class,integer,would,increase,the,weight,by,1,accordingly,due,to,the,superclass,1,step,up,the,hierarchy,i,e,number,still,matching,the,required,type,number,therefore,with,an,arg,of,type,integer,a,constructor,integer,would,be,preferred,to,a,constructor,number,which,would,in,turn,be,preferred,to,a,constructor,object,all,argument,weights,get,accumulated,p,note,this,is,the,algorithm,used,by,method,invoker,itself,and,also,the,algorithm,used,for,constructor,and,factory,method,selection,in,spring,s,bean,container,in,case,of,lenient,constructor,resolution,which,is,the,default,for,regular,bean,definitions,param,param,types,the,parameter,types,to,match,param,args,the,arguments,to,match,return,the,accumulated,weight,for,all,arguments;public,static,int,get,type,difference,weight,class,param,types,object,args,int,result,0,for,int,i,0,i,param,types,length,i,if,class,utils,is,assignable,value,param,types,i,args,i,return,integer,if,args,i,null,class,param,type,param,types,i,class,super,class,args,i,get,class,get,superclass,while,super,class,null,if,param,type,equals,super,class,result,result,2,super,class,null,else,if,class,utils,is,assignable,param,type,super,class,result,result,2,super,class,super,class,get,superclass,else,super,class,null,if,param,type,is,interface,result,result,1,return,result
MethodInvoker -> public static int getTypeDifferenceWeight(Class<?>[] paramTypes, Object[] args);1389789549;Algorithm that judges the match between the declared parameter types of a candidate method_and a specific list of arguments that this method is supposed to be invoked with._<p>Determines a weight that represents the class hierarchy difference between types and_arguments. A direct match, i.e. type Integer -> arg of class Integer, does not increase_the result - all direct matches means weight 0. A match between type Object and arg of_class Integer would increase the weight by 2, due to the superclass 2 steps up in the_hierarchy (i.e. Object) being the last one that still matches the required type Object._Type Number and class Integer would increase the weight by 1 accordingly, due to the_superclass 1 step up the hierarchy (i.e. Number) still matching the required type Number._Therefore, with an arg of type Integer, a constructor (Integer) would be preferred to a_constructor (Number) which would in turn be preferred to a constructor (Object)._All argument weights get accumulated._<p>Note: This is the algorithm used by MethodInvoker itself and also the algorithm_used for constructor and factory method selection in Spring's bean container (in case_of lenient constructor resolution which is the default for regular bean definitions)._@param paramTypes the parameter types to match_@param args the arguments to match_@return the accumulated weight for all arguments;public static int getTypeDifferenceWeight(Class<?>[] paramTypes, Object[] args) {_		int result = 0__		for (int i = 0_ i < paramTypes.length_ i++) {_			if (!ClassUtils.isAssignableValue(paramTypes[i], args[i])) {_				return Integer.MAX_VALUE__			}_			if (args[i] != null) {_				Class<?> paramType = paramTypes[i]__				Class<?> superClass = args[i].getClass().getSuperclass()__				while (superClass != null) {_					if (paramType.equals(superClass)) {_						result = result + 2__						superClass = null__					}_					else if (ClassUtils.isAssignable(paramType, superClass)) {_						result = result + 2__						superClass = superClass.getSuperclass()__					}_					else {_						superClass = null__					}_				}_				if (paramType.isInterface()) {_					result = result + 1__				}_			}_		}_		return result__	};algorithm,that,judges,the,match,between,the,declared,parameter,types,of,a,candidate,method,and,a,specific,list,of,arguments,that,this,method,is,supposed,to,be,invoked,with,p,determines,a,weight,that,represents,the,class,hierarchy,difference,between,types,and,arguments,a,direct,match,i,e,type,integer,arg,of,class,integer,does,not,increase,the,result,all,direct,matches,means,weight,0,a,match,between,type,object,and,arg,of,class,integer,would,increase,the,weight,by,2,due,to,the,superclass,2,steps,up,in,the,hierarchy,i,e,object,being,the,last,one,that,still,matches,the,required,type,object,type,number,and,class,integer,would,increase,the,weight,by,1,accordingly,due,to,the,superclass,1,step,up,the,hierarchy,i,e,number,still,matching,the,required,type,number,therefore,with,an,arg,of,type,integer,a,constructor,integer,would,be,preferred,to,a,constructor,number,which,would,in,turn,be,preferred,to,a,constructor,object,all,argument,weights,get,accumulated,p,note,this,is,the,algorithm,used,by,method,invoker,itself,and,also,the,algorithm,used,for,constructor,and,factory,method,selection,in,spring,s,bean,container,in,case,of,lenient,constructor,resolution,which,is,the,default,for,regular,bean,definitions,param,param,types,the,parameter,types,to,match,param,args,the,arguments,to,match,return,the,accumulated,weight,for,all,arguments;public,static,int,get,type,difference,weight,class,param,types,object,args,int,result,0,for,int,i,0,i,param,types,length,i,if,class,utils,is,assignable,value,param,types,i,args,i,return,integer,if,args,i,null,class,param,type,param,types,i,class,super,class,args,i,get,class,get,superclass,while,super,class,null,if,param,type,equals,super,class,result,result,2,super,class,null,else,if,class,utils,is,assignable,param,type,super,class,result,result,2,super,class,super,class,get,superclass,else,super,class,null,if,param,type,is,interface,result,result,1,return,result
MethodInvoker -> public static int getTypeDifferenceWeight(Class<?>[] paramTypes, Object[] args);1495868221;Algorithm that judges the match between the declared parameter types of a candidate method_and a specific list of arguments that this method is supposed to be invoked with._<p>Determines a weight that represents the class hierarchy difference between types and_arguments. A direct match, i.e. type Integer -> arg of class Integer, does not increase_the result - all direct matches means weight 0. A match between type Object and arg of_class Integer would increase the weight by 2, due to the superclass 2 steps up in the_hierarchy (i.e. Object) being the last one that still matches the required type Object._Type Number and class Integer would increase the weight by 1 accordingly, due to the_superclass 1 step up the hierarchy (i.e. Number) still matching the required type Number._Therefore, with an arg of type Integer, a constructor (Integer) would be preferred to a_constructor (Number) which would in turn be preferred to a constructor (Object)._All argument weights get accumulated._<p>Note: This is the algorithm used by MethodInvoker itself and also the algorithm_used for constructor and factory method selection in Spring's bean container (in case_of lenient constructor resolution which is the default for regular bean definitions)._@param paramTypes the parameter types to match_@param args the arguments to match_@return the accumulated weight for all arguments;public static int getTypeDifferenceWeight(Class<?>[] paramTypes, Object[] args) {_		int result = 0__		for (int i = 0_ i < paramTypes.length_ i++) {_			if (!ClassUtils.isAssignableValue(paramTypes[i], args[i])) {_				return Integer.MAX_VALUE__			}_			if (args[i] != null) {_				Class<?> paramType = paramTypes[i]__				Class<?> superClass = args[i].getClass().getSuperclass()__				while (superClass != null) {_					if (paramType.equals(superClass)) {_						result = result + 2__						superClass = null__					}_					else if (ClassUtils.isAssignable(paramType, superClass)) {_						result = result + 2__						superClass = superClass.getSuperclass()__					}_					else {_						superClass = null__					}_				}_				if (paramType.isInterface()) {_					result = result + 1__				}_			}_		}_		return result__	};algorithm,that,judges,the,match,between,the,declared,parameter,types,of,a,candidate,method,and,a,specific,list,of,arguments,that,this,method,is,supposed,to,be,invoked,with,p,determines,a,weight,that,represents,the,class,hierarchy,difference,between,types,and,arguments,a,direct,match,i,e,type,integer,arg,of,class,integer,does,not,increase,the,result,all,direct,matches,means,weight,0,a,match,between,type,object,and,arg,of,class,integer,would,increase,the,weight,by,2,due,to,the,superclass,2,steps,up,in,the,hierarchy,i,e,object,being,the,last,one,that,still,matches,the,required,type,object,type,number,and,class,integer,would,increase,the,weight,by,1,accordingly,due,to,the,superclass,1,step,up,the,hierarchy,i,e,number,still,matching,the,required,type,number,therefore,with,an,arg,of,type,integer,a,constructor,integer,would,be,preferred,to,a,constructor,number,which,would,in,turn,be,preferred,to,a,constructor,object,all,argument,weights,get,accumulated,p,note,this,is,the,algorithm,used,by,method,invoker,itself,and,also,the,algorithm,used,for,constructor,and,factory,method,selection,in,spring,s,bean,container,in,case,of,lenient,constructor,resolution,which,is,the,default,for,regular,bean,definitions,param,param,types,the,parameter,types,to,match,param,args,the,arguments,to,match,return,the,accumulated,weight,for,all,arguments;public,static,int,get,type,difference,weight,class,param,types,object,args,int,result,0,for,int,i,0,i,param,types,length,i,if,class,utils,is,assignable,value,param,types,i,args,i,return,integer,if,args,i,null,class,param,type,param,types,i,class,super,class,args,i,get,class,get,superclass,while,super,class,null,if,param,type,equals,super,class,result,result,2,super,class,null,else,if,class,utils,is,assignable,param,type,super,class,result,result,2,super,class,super,class,get,superclass,else,super,class,null,if,param,type,is,interface,result,result,1,return,result
MethodInvoker -> public static int getTypeDifferenceWeight(Class<?>[] paramTypes, Object[] args);1496837955;Algorithm that judges the match between the declared parameter types of a candidate method_and a specific list of arguments that this method is supposed to be invoked with._<p>Determines a weight that represents the class hierarchy difference between types and_arguments. A direct match, i.e. type Integer -> arg of class Integer, does not increase_the result - all direct matches means weight 0. A match between type Object and arg of_class Integer would increase the weight by 2, due to the superclass 2 steps up in the_hierarchy (i.e. Object) being the last one that still matches the required type Object._Type Number and class Integer would increase the weight by 1 accordingly, due to the_superclass 1 step up the hierarchy (i.e. Number) still matching the required type Number._Therefore, with an arg of type Integer, a constructor (Integer) would be preferred to a_constructor (Number) which would in turn be preferred to a constructor (Object)._All argument weights get accumulated._<p>Note: This is the algorithm used by MethodInvoker itself and also the algorithm_used for constructor and factory method selection in Spring's bean container (in case_of lenient constructor resolution which is the default for regular bean definitions)._@param paramTypes the parameter types to match_@param args the arguments to match_@return the accumulated weight for all arguments;public static int getTypeDifferenceWeight(Class<?>[] paramTypes, Object[] args) {_		int result = 0__		for (int i = 0_ i < paramTypes.length_ i++) {_			if (!ClassUtils.isAssignableValue(paramTypes[i], args[i])) {_				return Integer.MAX_VALUE__			}_			if (args[i] != null) {_				Class<?> paramType = paramTypes[i]__				Class<?> superClass = args[i].getClass().getSuperclass()__				while (superClass != null) {_					if (paramType.equals(superClass)) {_						result = result + 2__						superClass = null__					}_					else if (ClassUtils.isAssignable(paramType, superClass)) {_						result = result + 2__						superClass = superClass.getSuperclass()__					}_					else {_						superClass = null__					}_				}_				if (paramType.isInterface()) {_					result = result + 1__				}_			}_		}_		return result__	};algorithm,that,judges,the,match,between,the,declared,parameter,types,of,a,candidate,method,and,a,specific,list,of,arguments,that,this,method,is,supposed,to,be,invoked,with,p,determines,a,weight,that,represents,the,class,hierarchy,difference,between,types,and,arguments,a,direct,match,i,e,type,integer,arg,of,class,integer,does,not,increase,the,result,all,direct,matches,means,weight,0,a,match,between,type,object,and,arg,of,class,integer,would,increase,the,weight,by,2,due,to,the,superclass,2,steps,up,in,the,hierarchy,i,e,object,being,the,last,one,that,still,matches,the,required,type,object,type,number,and,class,integer,would,increase,the,weight,by,1,accordingly,due,to,the,superclass,1,step,up,the,hierarchy,i,e,number,still,matching,the,required,type,number,therefore,with,an,arg,of,type,integer,a,constructor,integer,would,be,preferred,to,a,constructor,number,which,would,in,turn,be,preferred,to,a,constructor,object,all,argument,weights,get,accumulated,p,note,this,is,the,algorithm,used,by,method,invoker,itself,and,also,the,algorithm,used,for,constructor,and,factory,method,selection,in,spring,s,bean,container,in,case,of,lenient,constructor,resolution,which,is,the,default,for,regular,bean,definitions,param,param,types,the,parameter,types,to,match,param,args,the,arguments,to,match,return,the,accumulated,weight,for,all,arguments;public,static,int,get,type,difference,weight,class,param,types,object,args,int,result,0,for,int,i,0,i,param,types,length,i,if,class,utils,is,assignable,value,param,types,i,args,i,return,integer,if,args,i,null,class,param,type,param,types,i,class,super,class,args,i,get,class,get,superclass,while,super,class,null,if,param,type,equals,super,class,result,result,2,super,class,null,else,if,class,utils,is,assignable,param,type,super,class,result,result,2,super,class,super,class,get,superclass,else,super,class,null,if,param,type,is,interface,result,result,1,return,result
MethodInvoker -> public static int getTypeDifferenceWeight(Class<?>[] paramTypes, Object[] args);1498780456;Algorithm that judges the match between the declared parameter types of a candidate method_and a specific list of arguments that this method is supposed to be invoked with._<p>Determines a weight that represents the class hierarchy difference between types and_arguments. A direct match, i.e. type Integer -> arg of class Integer, does not increase_the result - all direct matches means weight 0. A match between type Object and arg of_class Integer would increase the weight by 2, due to the superclass 2 steps up in the_hierarchy (i.e. Object) being the last one that still matches the required type Object._Type Number and class Integer would increase the weight by 1 accordingly, due to the_superclass 1 step up the hierarchy (i.e. Number) still matching the required type Number._Therefore, with an arg of type Integer, a constructor (Integer) would be preferred to a_constructor (Number) which would in turn be preferred to a constructor (Object)._All argument weights get accumulated._<p>Note: This is the algorithm used by MethodInvoker itself and also the algorithm_used for constructor and factory method selection in Spring's bean container (in case_of lenient constructor resolution which is the default for regular bean definitions)._@param paramTypes the parameter types to match_@param args the arguments to match_@return the accumulated weight for all arguments;public static int getTypeDifferenceWeight(Class<?>[] paramTypes, Object[] args) {_		int result = 0__		for (int i = 0_ i < paramTypes.length_ i++) {_			if (!ClassUtils.isAssignableValue(paramTypes[i], args[i])) {_				return Integer.MAX_VALUE__			}_			if (args[i] != null) {_				Class<?> paramType = paramTypes[i]__				Class<?> superClass = args[i].getClass().getSuperclass()__				while (superClass != null) {_					if (paramType.equals(superClass)) {_						result = result + 2__						superClass = null__					}_					else if (ClassUtils.isAssignable(paramType, superClass)) {_						result = result + 2__						superClass = superClass.getSuperclass()__					}_					else {_						superClass = null__					}_				}_				if (paramType.isInterface()) {_					result = result + 1__				}_			}_		}_		return result__	};algorithm,that,judges,the,match,between,the,declared,parameter,types,of,a,candidate,method,and,a,specific,list,of,arguments,that,this,method,is,supposed,to,be,invoked,with,p,determines,a,weight,that,represents,the,class,hierarchy,difference,between,types,and,arguments,a,direct,match,i,e,type,integer,arg,of,class,integer,does,not,increase,the,result,all,direct,matches,means,weight,0,a,match,between,type,object,and,arg,of,class,integer,would,increase,the,weight,by,2,due,to,the,superclass,2,steps,up,in,the,hierarchy,i,e,object,being,the,last,one,that,still,matches,the,required,type,object,type,number,and,class,integer,would,increase,the,weight,by,1,accordingly,due,to,the,superclass,1,step,up,the,hierarchy,i,e,number,still,matching,the,required,type,number,therefore,with,an,arg,of,type,integer,a,constructor,integer,would,be,preferred,to,a,constructor,number,which,would,in,turn,be,preferred,to,a,constructor,object,all,argument,weights,get,accumulated,p,note,this,is,the,algorithm,used,by,method,invoker,itself,and,also,the,algorithm,used,for,constructor,and,factory,method,selection,in,spring,s,bean,container,in,case,of,lenient,constructor,resolution,which,is,the,default,for,regular,bean,definitions,param,param,types,the,parameter,types,to,match,param,args,the,arguments,to,match,return,the,accumulated,weight,for,all,arguments;public,static,int,get,type,difference,weight,class,param,types,object,args,int,result,0,for,int,i,0,i,param,types,length,i,if,class,utils,is,assignable,value,param,types,i,args,i,return,integer,if,args,i,null,class,param,type,param,types,i,class,super,class,args,i,get,class,get,superclass,while,super,class,null,if,param,type,equals,super,class,result,result,2,super,class,null,else,if,class,utils,is,assignable,param,type,super,class,result,result,2,super,class,super,class,get,superclass,else,super,class,null,if,param,type,is,interface,result,result,1,return,result
MethodInvoker -> public static int getTypeDifferenceWeight(Class<?>[] paramTypes, Object[] args);1500448076;Algorithm that judges the match between the declared parameter types of a candidate method_and a specific list of arguments that this method is supposed to be invoked with._<p>Determines a weight that represents the class hierarchy difference between types and_arguments. A direct match, i.e. type Integer -> arg of class Integer, does not increase_the result - all direct matches means weight 0. A match between type Object and arg of_class Integer would increase the weight by 2, due to the superclass 2 steps up in the_hierarchy (i.e. Object) being the last one that still matches the required type Object._Type Number and class Integer would increase the weight by 1 accordingly, due to the_superclass 1 step up the hierarchy (i.e. Number) still matching the required type Number._Therefore, with an arg of type Integer, a constructor (Integer) would be preferred to a_constructor (Number) which would in turn be preferred to a constructor (Object)._All argument weights get accumulated._<p>Note: This is the algorithm used by MethodInvoker itself and also the algorithm_used for constructor and factory method selection in Spring's bean container (in case_of lenient constructor resolution which is the default for regular bean definitions)._@param paramTypes the parameter types to match_@param args the arguments to match_@return the accumulated weight for all arguments;public static int getTypeDifferenceWeight(Class<?>[] paramTypes, Object[] args) {_		int result = 0__		for (int i = 0_ i < paramTypes.length_ i++) {_			if (!ClassUtils.isAssignableValue(paramTypes[i], args[i])) {_				return Integer.MAX_VALUE__			}_			if (args[i] != null) {_				Class<?> paramType = paramTypes[i]__				Class<?> superClass = args[i].getClass().getSuperclass()__				while (superClass != null) {_					if (paramType.equals(superClass)) {_						result = result + 2__						superClass = null__					}_					else if (ClassUtils.isAssignable(paramType, superClass)) {_						result = result + 2__						superClass = superClass.getSuperclass()__					}_					else {_						superClass = null__					}_				}_				if (paramType.isInterface()) {_					result = result + 1__				}_			}_		}_		return result__	};algorithm,that,judges,the,match,between,the,declared,parameter,types,of,a,candidate,method,and,a,specific,list,of,arguments,that,this,method,is,supposed,to,be,invoked,with,p,determines,a,weight,that,represents,the,class,hierarchy,difference,between,types,and,arguments,a,direct,match,i,e,type,integer,arg,of,class,integer,does,not,increase,the,result,all,direct,matches,means,weight,0,a,match,between,type,object,and,arg,of,class,integer,would,increase,the,weight,by,2,due,to,the,superclass,2,steps,up,in,the,hierarchy,i,e,object,being,the,last,one,that,still,matches,the,required,type,object,type,number,and,class,integer,would,increase,the,weight,by,1,accordingly,due,to,the,superclass,1,step,up,the,hierarchy,i,e,number,still,matching,the,required,type,number,therefore,with,an,arg,of,type,integer,a,constructor,integer,would,be,preferred,to,a,constructor,number,which,would,in,turn,be,preferred,to,a,constructor,object,all,argument,weights,get,accumulated,p,note,this,is,the,algorithm,used,by,method,invoker,itself,and,also,the,algorithm,used,for,constructor,and,factory,method,selection,in,spring,s,bean,container,in,case,of,lenient,constructor,resolution,which,is,the,default,for,regular,bean,definitions,param,param,types,the,parameter,types,to,match,param,args,the,arguments,to,match,return,the,accumulated,weight,for,all,arguments;public,static,int,get,type,difference,weight,class,param,types,object,args,int,result,0,for,int,i,0,i,param,types,length,i,if,class,utils,is,assignable,value,param,types,i,args,i,return,integer,if,args,i,null,class,param,type,param,types,i,class,super,class,args,i,get,class,get,superclass,while,super,class,null,if,param,type,equals,super,class,result,result,2,super,class,null,else,if,class,utils,is,assignable,param,type,super,class,result,result,2,super,class,super,class,get,superclass,else,super,class,null,if,param,type,is,interface,result,result,1,return,result
MethodInvoker -> public static int getTypeDifferenceWeight(Class<?>[] paramTypes, Object[] args);1508160858;Algorithm that judges the match between the declared parameter types of a candidate method_and a specific list of arguments that this method is supposed to be invoked with._<p>Determines a weight that represents the class hierarchy difference between types and_arguments. A direct match, i.e. type Integer -> arg of class Integer, does not increase_the result - all direct matches means weight 0. A match between type Object and arg of_class Integer would increase the weight by 2, due to the superclass 2 steps up in the_hierarchy (i.e. Object) being the last one that still matches the required type Object._Type Number and class Integer would increase the weight by 1 accordingly, due to the_superclass 1 step up the hierarchy (i.e. Number) still matching the required type Number._Therefore, with an arg of type Integer, a constructor (Integer) would be preferred to a_constructor (Number) which would in turn be preferred to a constructor (Object)._All argument weights get accumulated._<p>Note: This is the algorithm used by MethodInvoker itself and also the algorithm_used for constructor and factory method selection in Spring's bean container (in case_of lenient constructor resolution which is the default for regular bean definitions)._@param paramTypes the parameter types to match_@param args the arguments to match_@return the accumulated weight for all arguments;public static int getTypeDifferenceWeight(Class<?>[] paramTypes, Object[] args) {_		int result = 0__		for (int i = 0_ i < paramTypes.length_ i++) {_			if (!ClassUtils.isAssignableValue(paramTypes[i], args[i])) {_				return Integer.MAX_VALUE__			}_			if (args[i] != null) {_				Class<?> paramType = paramTypes[i]__				Class<?> superClass = args[i].getClass().getSuperclass()__				while (superClass != null) {_					if (paramType.equals(superClass)) {_						result = result + 2__						superClass = null__					}_					else if (ClassUtils.isAssignable(paramType, superClass)) {_						result = result + 2__						superClass = superClass.getSuperclass()__					}_					else {_						superClass = null__					}_				}_				if (paramType.isInterface()) {_					result = result + 1__				}_			}_		}_		return result__	};algorithm,that,judges,the,match,between,the,declared,parameter,types,of,a,candidate,method,and,a,specific,list,of,arguments,that,this,method,is,supposed,to,be,invoked,with,p,determines,a,weight,that,represents,the,class,hierarchy,difference,between,types,and,arguments,a,direct,match,i,e,type,integer,arg,of,class,integer,does,not,increase,the,result,all,direct,matches,means,weight,0,a,match,between,type,object,and,arg,of,class,integer,would,increase,the,weight,by,2,due,to,the,superclass,2,steps,up,in,the,hierarchy,i,e,object,being,the,last,one,that,still,matches,the,required,type,object,type,number,and,class,integer,would,increase,the,weight,by,1,accordingly,due,to,the,superclass,1,step,up,the,hierarchy,i,e,number,still,matching,the,required,type,number,therefore,with,an,arg,of,type,integer,a,constructor,integer,would,be,preferred,to,a,constructor,number,which,would,in,turn,be,preferred,to,a,constructor,object,all,argument,weights,get,accumulated,p,note,this,is,the,algorithm,used,by,method,invoker,itself,and,also,the,algorithm,used,for,constructor,and,factory,method,selection,in,spring,s,bean,container,in,case,of,lenient,constructor,resolution,which,is,the,default,for,regular,bean,definitions,param,param,types,the,parameter,types,to,match,param,args,the,arguments,to,match,return,the,accumulated,weight,for,all,arguments;public,static,int,get,type,difference,weight,class,param,types,object,args,int,result,0,for,int,i,0,i,param,types,length,i,if,class,utils,is,assignable,value,param,types,i,args,i,return,integer,if,args,i,null,class,param,type,param,types,i,class,super,class,args,i,get,class,get,superclass,while,super,class,null,if,param,type,equals,super,class,result,result,2,super,class,null,else,if,class,utils,is,assignable,param,type,super,class,result,result,2,super,class,super,class,get,superclass,else,super,class,null,if,param,type,is,interface,result,result,1,return,result
MethodInvoker -> public static int getTypeDifferenceWeight(Class<?>[] paramTypes, Object[] args);1530174524;Algorithm that judges the match between the declared parameter types of a candidate method_and a specific list of arguments that this method is supposed to be invoked with._<p>Determines a weight that represents the class hierarchy difference between types and_arguments. A direct match, i.e. type Integer -> arg of class Integer, does not increase_the result - all direct matches means weight 0. A match between type Object and arg of_class Integer would increase the weight by 2, due to the superclass 2 steps up in the_hierarchy (i.e. Object) being the last one that still matches the required type Object._Type Number and class Integer would increase the weight by 1 accordingly, due to the_superclass 1 step up the hierarchy (i.e. Number) still matching the required type Number._Therefore, with an arg of type Integer, a constructor (Integer) would be preferred to a_constructor (Number) which would in turn be preferred to a constructor (Object)._All argument weights get accumulated._<p>Note: This is the algorithm used by MethodInvoker itself and also the algorithm_used for constructor and factory method selection in Spring's bean container (in case_of lenient constructor resolution which is the default for regular bean definitions)._@param paramTypes the parameter types to match_@param args the arguments to match_@return the accumulated weight for all arguments;public static int getTypeDifferenceWeight(Class<?>[] paramTypes, Object[] args) {_		int result = 0__		for (int i = 0_ i < paramTypes.length_ i++) {_			if (!ClassUtils.isAssignableValue(paramTypes[i], args[i])) {_				return Integer.MAX_VALUE__			}_			if (args[i] != null) {_				Class<?> paramType = paramTypes[i]__				Class<?> superClass = args[i].getClass().getSuperclass()__				while (superClass != null) {_					if (paramType.equals(superClass)) {_						result = result + 2__						superClass = null__					}_					else if (ClassUtils.isAssignable(paramType, superClass)) {_						result = result + 2__						superClass = superClass.getSuperclass()__					}_					else {_						superClass = null__					}_				}_				if (paramType.isInterface()) {_					result = result + 1__				}_			}_		}_		return result__	};algorithm,that,judges,the,match,between,the,declared,parameter,types,of,a,candidate,method,and,a,specific,list,of,arguments,that,this,method,is,supposed,to,be,invoked,with,p,determines,a,weight,that,represents,the,class,hierarchy,difference,between,types,and,arguments,a,direct,match,i,e,type,integer,arg,of,class,integer,does,not,increase,the,result,all,direct,matches,means,weight,0,a,match,between,type,object,and,arg,of,class,integer,would,increase,the,weight,by,2,due,to,the,superclass,2,steps,up,in,the,hierarchy,i,e,object,being,the,last,one,that,still,matches,the,required,type,object,type,number,and,class,integer,would,increase,the,weight,by,1,accordingly,due,to,the,superclass,1,step,up,the,hierarchy,i,e,number,still,matching,the,required,type,number,therefore,with,an,arg,of,type,integer,a,constructor,integer,would,be,preferred,to,a,constructor,number,which,would,in,turn,be,preferred,to,a,constructor,object,all,argument,weights,get,accumulated,p,note,this,is,the,algorithm,used,by,method,invoker,itself,and,also,the,algorithm,used,for,constructor,and,factory,method,selection,in,spring,s,bean,container,in,case,of,lenient,constructor,resolution,which,is,the,default,for,regular,bean,definitions,param,param,types,the,parameter,types,to,match,param,args,the,arguments,to,match,return,the,accumulated,weight,for,all,arguments;public,static,int,get,type,difference,weight,class,param,types,object,args,int,result,0,for,int,i,0,i,param,types,length,i,if,class,utils,is,assignable,value,param,types,i,args,i,return,integer,if,args,i,null,class,param,type,param,types,i,class,super,class,args,i,get,class,get,superclass,while,super,class,null,if,param,type,equals,super,class,result,result,2,super,class,null,else,if,class,utils,is,assignable,param,type,super,class,result,result,2,super,class,super,class,get,superclass,else,super,class,null,if,param,type,is,interface,result,result,1,return,result
MethodInvoker -> public void setTargetClass(Class<?> targetClass);1383520795;Set the target class on which to call the target method._Only necessary when the target method is static_ else,_a target object needs to be specified anyway._@see #setTargetObject_@see #setTargetMethod;public void setTargetClass(Class<?> targetClass) {_		this.targetClass = targetClass__	};set,the,target,class,on,which,to,call,the,target,method,only,necessary,when,the,target,method,is,static,else,a,target,object,needs,to,be,specified,anyway,see,set,target,object,see,set,target,method;public,void,set,target,class,class,target,class,this,target,class,target,class
MethodInvoker -> public void setTargetClass(Class<?> targetClass);1385412762;Set the target class on which to call the target method._Only necessary when the target method is static_ else,_a target object needs to be specified anyway._@see #setTargetObject_@see #setTargetMethod;public void setTargetClass(Class<?> targetClass) {_		this.targetClass = targetClass__	};set,the,target,class,on,which,to,call,the,target,method,only,necessary,when,the,target,method,is,static,else,a,target,object,needs,to,be,specified,anyway,see,set,target,object,see,set,target,method;public,void,set,target,class,class,target,class,this,target,class,target,class
MethodInvoker -> public void setTargetClass(Class<?> targetClass);1389789549;Set the target class on which to call the target method._Only necessary when the target method is static_ else,_a target object needs to be specified anyway._@see #setTargetObject_@see #setTargetMethod;public void setTargetClass(Class<?> targetClass) {_		this.targetClass = targetClass__	};set,the,target,class,on,which,to,call,the,target,method,only,necessary,when,the,target,method,is,static,else,a,target,object,needs,to,be,specified,anyway,see,set,target,object,see,set,target,method;public,void,set,target,class,class,target,class,this,target,class,target,class
MethodInvoker -> public void setTargetClass(Class<?> targetClass);1495868221;Set the target class on which to call the target method._Only necessary when the target method is static_ else,_a target object needs to be specified anyway._@see #setTargetObject_@see #setTargetMethod;public void setTargetClass(Class<?> targetClass) {_		this.targetClass = targetClass__	};set,the,target,class,on,which,to,call,the,target,method,only,necessary,when,the,target,method,is,static,else,a,target,object,needs,to,be,specified,anyway,see,set,target,object,see,set,target,method;public,void,set,target,class,class,target,class,this,target,class,target,class
MethodInvoker -> public void setTargetClass(Class<?> targetClass);1496837955;Set the target class on which to call the target method._Only necessary when the target method is static_ else,_a target object needs to be specified anyway._@see #setTargetObject_@see #setTargetMethod;public void setTargetClass(Class<?> targetClass) {_		this.targetClass = targetClass__	};set,the,target,class,on,which,to,call,the,target,method,only,necessary,when,the,target,method,is,static,else,a,target,object,needs,to,be,specified,anyway,see,set,target,object,see,set,target,method;public,void,set,target,class,class,target,class,this,target,class,target,class
MethodInvoker -> public void setTargetClass(Class<?> targetClass);1498780456;Set the target class on which to call the target method._Only necessary when the target method is static_ else,_a target object needs to be specified anyway._@see #setTargetObject_@see #setTargetMethod;public void setTargetClass(Class<?> targetClass) {_		this.targetClass = targetClass__	};set,the,target,class,on,which,to,call,the,target,method,only,necessary,when,the,target,method,is,static,else,a,target,object,needs,to,be,specified,anyway,see,set,target,object,see,set,target,method;public,void,set,target,class,class,target,class,this,target,class,target,class
MethodInvoker -> public void setTargetObject(Object targetObject);1328020251;Set the target object on which to call the target method._Only necessary when the target method is not static__else, a target class is sufficient._@see #setTargetClass_@see #setTargetMethod;public void setTargetObject(Object targetObject) {_		this.targetObject = targetObject__		if (targetObject != null) {_			this.targetClass = targetObject.getClass()__		}_	};set,the,target,object,on,which,to,call,the,target,method,only,necessary,when,the,target,method,is,not,static,else,a,target,class,is,sufficient,see,set,target,class,see,set,target,method;public,void,set,target,object,object,target,object,this,target,object,target,object,if,target,object,null,this,target,class,target,object,get,class
MethodInvoker -> public void setTargetObject(Object targetObject);1356735495;Set the target object on which to call the target method._Only necessary when the target method is not static__else, a target class is sufficient._@see #setTargetClass_@see #setTargetMethod;public void setTargetObject(Object targetObject) {_		this.targetObject = targetObject__		if (targetObject != null) {_			this.targetClass = targetObject.getClass()__		}_	};set,the,target,object,on,which,to,call,the,target,method,only,necessary,when,the,target,method,is,not,static,else,a,target,class,is,sufficient,see,set,target,class,see,set,target,method;public,void,set,target,object,object,target,object,this,target,object,target,object,if,target,object,null,this,target,class,target,object,get,class
MethodInvoker -> public void setTargetObject(Object targetObject);1383520795;Set the target object on which to call the target method._Only necessary when the target method is not static__else, a target class is sufficient._@see #setTargetClass_@see #setTargetMethod;public void setTargetObject(Object targetObject) {_		this.targetObject = targetObject__		if (targetObject != null) {_			this.targetClass = targetObject.getClass()__		}_	};set,the,target,object,on,which,to,call,the,target,method,only,necessary,when,the,target,method,is,not,static,else,a,target,class,is,sufficient,see,set,target,class,see,set,target,method;public,void,set,target,object,object,target,object,this,target,object,target,object,if,target,object,null,this,target,class,target,object,get,class
MethodInvoker -> public void setTargetObject(Object targetObject);1385412762;Set the target object on which to call the target method._Only necessary when the target method is not static__else, a target class is sufficient._@see #setTargetClass_@see #setTargetMethod;public void setTargetObject(Object targetObject) {_		this.targetObject = targetObject__		if (targetObject != null) {_			this.targetClass = targetObject.getClass()__		}_	};set,the,target,object,on,which,to,call,the,target,method,only,necessary,when,the,target,method,is,not,static,else,a,target,class,is,sufficient,see,set,target,class,see,set,target,method;public,void,set,target,object,object,target,object,this,target,object,target,object,if,target,object,null,this,target,class,target,object,get,class
MethodInvoker -> public void setTargetObject(Object targetObject);1389789549;Set the target object on which to call the target method._Only necessary when the target method is not static__else, a target class is sufficient._@see #setTargetClass_@see #setTargetMethod;public void setTargetObject(Object targetObject) {_		this.targetObject = targetObject__		if (targetObject != null) {_			this.targetClass = targetObject.getClass()__		}_	};set,the,target,object,on,which,to,call,the,target,method,only,necessary,when,the,target,method,is,not,static,else,a,target,class,is,sufficient,see,set,target,class,see,set,target,method;public,void,set,target,object,object,target,object,this,target,object,target,object,if,target,object,null,this,target,class,target,object,get,class
MethodInvoker -> public void setTargetObject(Object targetObject);1495868221;Set the target object on which to call the target method._Only necessary when the target method is not static__else, a target class is sufficient._@see #setTargetClass_@see #setTargetMethod;public void setTargetObject(Object targetObject) {_		this.targetObject = targetObject__		if (targetObject != null) {_			this.targetClass = targetObject.getClass()__		}_	};set,the,target,object,on,which,to,call,the,target,method,only,necessary,when,the,target,method,is,not,static,else,a,target,class,is,sufficient,see,set,target,class,see,set,target,method;public,void,set,target,object,object,target,object,this,target,object,target,object,if,target,object,null,this,target,class,target,object,get,class
MethodInvoker -> public String getTargetMethod();1328020251;Return the name of the method to be invoked.;public String getTargetMethod() {_		return this.targetMethod__	};return,the,name,of,the,method,to,be,invoked;public,string,get,target,method,return,this,target,method
MethodInvoker -> public String getTargetMethod();1356735495;Return the name of the method to be invoked.;public String getTargetMethod() {_		return this.targetMethod__	};return,the,name,of,the,method,to,be,invoked;public,string,get,target,method,return,this,target,method
MethodInvoker -> public String getTargetMethod();1383520795;Return the name of the method to be invoked.;public String getTargetMethod() {_		return this.targetMethod__	};return,the,name,of,the,method,to,be,invoked;public,string,get,target,method,return,this,target,method
MethodInvoker -> public String getTargetMethod();1385412762;Return the name of the method to be invoked.;public String getTargetMethod() {_		return this.targetMethod__	};return,the,name,of,the,method,to,be,invoked;public,string,get,target,method,return,this,target,method
MethodInvoker -> public String getTargetMethod();1389789549;Return the name of the method to be invoked.;public String getTargetMethod() {_		return this.targetMethod__	};return,the,name,of,the,method,to,be,invoked;public,string,get,target,method,return,this,target,method
MethodInvoker -> public String getTargetMethod();1495868221;Return the name of the method to be invoked.;public String getTargetMethod() {_		return this.targetMethod__	};return,the,name,of,the,method,to,be,invoked;public,string,get,target,method,return,this,target,method
MethodInvoker -> public Object invoke() throws InvocationTargetException, IllegalAccessException;1328020251;Invoke the specified method._<p>The invoker needs to have been prepared before._@return the object (possibly null) returned by the method invocation,_or <code>null</code> if the method has a void return type_@throws InvocationTargetException if the target method threw an exception_@throws IllegalAccessException if the target method couldn't be accessed_@see #prepare;public Object invoke() throws InvocationTargetException, IllegalAccessException {_		_		Object targetObject = getTargetObject()__		Method preparedMethod = getPreparedMethod()__		if (targetObject == null && !Modifier.isStatic(preparedMethod.getModifiers())) {_			throw new IllegalArgumentException("Target method must not be non-static without a target")__		}_		ReflectionUtils.makeAccessible(preparedMethod)__		return preparedMethod.invoke(targetObject, getArguments())__	};invoke,the,specified,method,p,the,invoker,needs,to,have,been,prepared,before,return,the,object,possibly,null,returned,by,the,method,invocation,or,code,null,code,if,the,method,has,a,void,return,type,throws,invocation,target,exception,if,the,target,method,threw,an,exception,throws,illegal,access,exception,if,the,target,method,couldn,t,be,accessed,see,prepare;public,object,invoke,throws,invocation,target,exception,illegal,access,exception,object,target,object,get,target,object,method,prepared,method,get,prepared,method,if,target,object,null,modifier,is,static,prepared,method,get,modifiers,throw,new,illegal,argument,exception,target,method,must,not,be,non,static,without,a,target,reflection,utils,make,accessible,prepared,method,return,prepared,method,invoke,target,object,get,arguments
MethodInvoker -> public Object invoke() throws InvocationTargetException, IllegalAccessException;1356735495;Invoke the specified method._<p>The invoker needs to have been prepared before._@return the object (possibly null) returned by the method invocation,_or {@code null} if the method has a void return type_@throws InvocationTargetException if the target method threw an exception_@throws IllegalAccessException if the target method couldn't be accessed_@see #prepare;public Object invoke() throws InvocationTargetException, IllegalAccessException {_		_		Object targetObject = getTargetObject()__		Method preparedMethod = getPreparedMethod()__		if (targetObject == null && !Modifier.isStatic(preparedMethod.getModifiers())) {_			throw new IllegalArgumentException("Target method must not be non-static without a target")__		}_		ReflectionUtils.makeAccessible(preparedMethod)__		return preparedMethod.invoke(targetObject, getArguments())__	};invoke,the,specified,method,p,the,invoker,needs,to,have,been,prepared,before,return,the,object,possibly,null,returned,by,the,method,invocation,or,code,null,if,the,method,has,a,void,return,type,throws,invocation,target,exception,if,the,target,method,threw,an,exception,throws,illegal,access,exception,if,the,target,method,couldn,t,be,accessed,see,prepare;public,object,invoke,throws,invocation,target,exception,illegal,access,exception,object,target,object,get,target,object,method,prepared,method,get,prepared,method,if,target,object,null,modifier,is,static,prepared,method,get,modifiers,throw,new,illegal,argument,exception,target,method,must,not,be,non,static,without,a,target,reflection,utils,make,accessible,prepared,method,return,prepared,method,invoke,target,object,get,arguments
MethodInvoker -> public Object invoke() throws InvocationTargetException, IllegalAccessException;1383520795;Invoke the specified method._<p>The invoker needs to have been prepared before._@return the object (possibly null) returned by the method invocation,_or {@code null} if the method has a void return type_@throws InvocationTargetException if the target method threw an exception_@throws IllegalAccessException if the target method couldn't be accessed_@see #prepare;public Object invoke() throws InvocationTargetException, IllegalAccessException {_		_		Object targetObject = getTargetObject()__		Method preparedMethod = getPreparedMethod()__		if (targetObject == null && !Modifier.isStatic(preparedMethod.getModifiers())) {_			throw new IllegalArgumentException("Target method must not be non-static without a target")__		}_		ReflectionUtils.makeAccessible(preparedMethod)__		return preparedMethod.invoke(targetObject, getArguments())__	};invoke,the,specified,method,p,the,invoker,needs,to,have,been,prepared,before,return,the,object,possibly,null,returned,by,the,method,invocation,or,code,null,if,the,method,has,a,void,return,type,throws,invocation,target,exception,if,the,target,method,threw,an,exception,throws,illegal,access,exception,if,the,target,method,couldn,t,be,accessed,see,prepare;public,object,invoke,throws,invocation,target,exception,illegal,access,exception,object,target,object,get,target,object,method,prepared,method,get,prepared,method,if,target,object,null,modifier,is,static,prepared,method,get,modifiers,throw,new,illegal,argument,exception,target,method,must,not,be,non,static,without,a,target,reflection,utils,make,accessible,prepared,method,return,prepared,method,invoke,target,object,get,arguments
MethodInvoker -> public Object invoke() throws InvocationTargetException, IllegalAccessException;1385412762;Invoke the specified method._<p>The invoker needs to have been prepared before._@return the object (possibly null) returned by the method invocation,_or {@code null} if the method has a void return type_@throws InvocationTargetException if the target method threw an exception_@throws IllegalAccessException if the target method couldn't be accessed_@see #prepare;public Object invoke() throws InvocationTargetException, IllegalAccessException {_		_		Object targetObject = getTargetObject()__		Method preparedMethod = getPreparedMethod()__		if (targetObject == null && !Modifier.isStatic(preparedMethod.getModifiers())) {_			throw new IllegalArgumentException("Target method must not be non-static without a target")__		}_		ReflectionUtils.makeAccessible(preparedMethod)__		return preparedMethod.invoke(targetObject, getArguments())__	};invoke,the,specified,method,p,the,invoker,needs,to,have,been,prepared,before,return,the,object,possibly,null,returned,by,the,method,invocation,or,code,null,if,the,method,has,a,void,return,type,throws,invocation,target,exception,if,the,target,method,threw,an,exception,throws,illegal,access,exception,if,the,target,method,couldn,t,be,accessed,see,prepare;public,object,invoke,throws,invocation,target,exception,illegal,access,exception,object,target,object,get,target,object,method,prepared,method,get,prepared,method,if,target,object,null,modifier,is,static,prepared,method,get,modifiers,throw,new,illegal,argument,exception,target,method,must,not,be,non,static,without,a,target,reflection,utils,make,accessible,prepared,method,return,prepared,method,invoke,target,object,get,arguments
MethodInvoker -> public Object invoke() throws InvocationTargetException, IllegalAccessException;1389789549;Invoke the specified method._<p>The invoker needs to have been prepared before._@return the object (possibly null) returned by the method invocation,_or {@code null} if the method has a void return type_@throws InvocationTargetException if the target method threw an exception_@throws IllegalAccessException if the target method couldn't be accessed_@see #prepare;public Object invoke() throws InvocationTargetException, IllegalAccessException {_		_		Object targetObject = getTargetObject()__		Method preparedMethod = getPreparedMethod()__		if (targetObject == null && !Modifier.isStatic(preparedMethod.getModifiers())) {_			throw new IllegalArgumentException("Target method must not be non-static without a target")__		}_		ReflectionUtils.makeAccessible(preparedMethod)__		return preparedMethod.invoke(targetObject, getArguments())__	};invoke,the,specified,method,p,the,invoker,needs,to,have,been,prepared,before,return,the,object,possibly,null,returned,by,the,method,invocation,or,code,null,if,the,method,has,a,void,return,type,throws,invocation,target,exception,if,the,target,method,threw,an,exception,throws,illegal,access,exception,if,the,target,method,couldn,t,be,accessed,see,prepare;public,object,invoke,throws,invocation,target,exception,illegal,access,exception,object,target,object,get,target,object,method,prepared,method,get,prepared,method,if,target,object,null,modifier,is,static,prepared,method,get,modifiers,throw,new,illegal,argument,exception,target,method,must,not,be,non,static,without,a,target,reflection,utils,make,accessible,prepared,method,return,prepared,method,invoke,target,object,get,arguments
MethodInvoker -> public void setArguments(Object[] arguments);1328020251;Set arguments for the method invocation. If this property is not set,_or the Object array is of length 0, a method with no arguments is assumed.;public void setArguments(Object[] arguments) {_		this.arguments = (arguments != null ? arguments : new Object[0])__	};set,arguments,for,the,method,invocation,if,this,property,is,not,set,or,the,object,array,is,of,length,0,a,method,with,no,arguments,is,assumed;public,void,set,arguments,object,arguments,this,arguments,arguments,null,arguments,new,object,0
MethodInvoker -> public void setArguments(Object[] arguments);1356735495;Set arguments for the method invocation. If this property is not set,_or the Object array is of length 0, a method with no arguments is assumed.;public void setArguments(Object[] arguments) {_		this.arguments = (arguments != null ? arguments : new Object[0])__	};set,arguments,for,the,method,invocation,if,this,property,is,not,set,or,the,object,array,is,of,length,0,a,method,with,no,arguments,is,assumed;public,void,set,arguments,object,arguments,this,arguments,arguments,null,arguments,new,object,0
MethodInvoker -> public void setArguments(Object[] arguments);1383520795;Set arguments for the method invocation. If this property is not set,_or the Object array is of length 0, a method with no arguments is assumed.;public void setArguments(Object[] arguments) {_		this.arguments = (arguments != null ? arguments : new Object[0])__	};set,arguments,for,the,method,invocation,if,this,property,is,not,set,or,the,object,array,is,of,length,0,a,method,with,no,arguments,is,assumed;public,void,set,arguments,object,arguments,this,arguments,arguments,null,arguments,new,object,0
MethodInvoker -> public void setArguments(Object[] arguments);1385412762;Set arguments for the method invocation. If this property is not set,_or the Object array is of length 0, a method with no arguments is assumed.;public void setArguments(Object[] arguments) {_		this.arguments = (arguments != null ? arguments : new Object[0])__	};set,arguments,for,the,method,invocation,if,this,property,is,not,set,or,the,object,array,is,of,length,0,a,method,with,no,arguments,is,assumed;public,void,set,arguments,object,arguments,this,arguments,arguments,null,arguments,new,object,0
MethodInvoker -> public void setArguments(Object[] arguments);1389789549;Set arguments for the method invocation. If this property is not set,_or the Object array is of length 0, a method with no arguments is assumed.;public void setArguments(Object[] arguments) {_		this.arguments = (arguments != null ? arguments : new Object[0])__	};set,arguments,for,the,method,invocation,if,this,property,is,not,set,or,the,object,array,is,of,length,0,a,method,with,no,arguments,is,assumed;public,void,set,arguments,object,arguments,this,arguments,arguments,null,arguments,new,object,0
MethodInvoker -> public void setArguments(Object[] arguments);1495868221;Set arguments for the method invocation. If this property is not set,_or the Object array is of length 0, a method with no arguments is assumed.;public void setArguments(Object[] arguments) {_		this.arguments = (arguments != null ? arguments : new Object[0])__	};set,arguments,for,the,method,invocation,if,this,property,is,not,set,or,the,object,array,is,of,length,0,a,method,with,no,arguments,is,assumed;public,void,set,arguments,object,arguments,this,arguments,arguments,null,arguments,new,object,0
MethodInvoker -> protected Class<?> resolveClassName(String className) throws ClassNotFoundException;1383520795;Resolve the given class name into a Class._<p>The default implementations uses {@code ClassUtils.forName},_using the thread context class loader._@param className the class name to resolve_@return the resolved Class_@throws ClassNotFoundException if the class name was invalid;protected Class<?> resolveClassName(String className) throws ClassNotFoundException {_		return ClassUtils.forName(className, ClassUtils.getDefaultClassLoader())__	};resolve,the,given,class,name,into,a,class,p,the,default,implementations,uses,code,class,utils,for,name,using,the,thread,context,class,loader,param,class,name,the,class,name,to,resolve,return,the,resolved,class,throws,class,not,found,exception,if,the,class,name,was,invalid;protected,class,resolve,class,name,string,class,name,throws,class,not,found,exception,return,class,utils,for,name,class,name,class,utils,get,default,class,loader
MethodInvoker -> protected Class<?> resolveClassName(String className) throws ClassNotFoundException;1385412762;Resolve the given class name into a Class._<p>The default implementations uses {@code ClassUtils.forName},_using the thread context class loader._@param className the class name to resolve_@return the resolved Class_@throws ClassNotFoundException if the class name was invalid;protected Class<?> resolveClassName(String className) throws ClassNotFoundException {_		return ClassUtils.forName(className, ClassUtils.getDefaultClassLoader())__	};resolve,the,given,class,name,into,a,class,p,the,default,implementations,uses,code,class,utils,for,name,using,the,thread,context,class,loader,param,class,name,the,class,name,to,resolve,return,the,resolved,class,throws,class,not,found,exception,if,the,class,name,was,invalid;protected,class,resolve,class,name,string,class,name,throws,class,not,found,exception,return,class,utils,for,name,class,name,class,utils,get,default,class,loader
MethodInvoker -> protected Class<?> resolveClassName(String className) throws ClassNotFoundException;1389789549;Resolve the given class name into a Class._<p>The default implementations uses {@code ClassUtils.forName},_using the thread context class loader._@param className the class name to resolve_@return the resolved Class_@throws ClassNotFoundException if the class name was invalid;protected Class<?> resolveClassName(String className) throws ClassNotFoundException {_		return ClassUtils.forName(className, ClassUtils.getDefaultClassLoader())__	};resolve,the,given,class,name,into,a,class,p,the,default,implementations,uses,code,class,utils,for,name,using,the,thread,context,class,loader,param,class,name,the,class,name,to,resolve,return,the,resolved,class,throws,class,not,found,exception,if,the,class,name,was,invalid;protected,class,resolve,class,name,string,class,name,throws,class,not,found,exception,return,class,utils,for,name,class,name,class,utils,get,default,class,loader
MethodInvoker -> protected Class<?> resolveClassName(String className) throws ClassNotFoundException;1495868221;Resolve the given class name into a Class._<p>The default implementations uses {@code ClassUtils.forName},_using the thread context class loader._@param className the class name to resolve_@return the resolved Class_@throws ClassNotFoundException if the class name was invalid;protected Class<?> resolveClassName(String className) throws ClassNotFoundException {_		return ClassUtils.forName(className, ClassUtils.getDefaultClassLoader())__	};resolve,the,given,class,name,into,a,class,p,the,default,implementations,uses,code,class,utils,for,name,using,the,thread,context,class,loader,param,class,name,the,class,name,to,resolve,return,the,resolved,class,throws,class,not,found,exception,if,the,class,name,was,invalid;protected,class,resolve,class,name,string,class,name,throws,class,not,found,exception,return,class,utils,for,name,class,name,class,utils,get,default,class,loader
MethodInvoker -> protected Class<?> resolveClassName(String className) throws ClassNotFoundException;1496837955;Resolve the given class name into a Class._<p>The default implementations uses {@code ClassUtils.forName},_using the thread context class loader._@param className the class name to resolve_@return the resolved Class_@throws ClassNotFoundException if the class name was invalid;protected Class<?> resolveClassName(String className) throws ClassNotFoundException {_		return ClassUtils.forName(className, ClassUtils.getDefaultClassLoader())__	};resolve,the,given,class,name,into,a,class,p,the,default,implementations,uses,code,class,utils,for,name,using,the,thread,context,class,loader,param,class,name,the,class,name,to,resolve,return,the,resolved,class,throws,class,not,found,exception,if,the,class,name,was,invalid;protected,class,resolve,class,name,string,class,name,throws,class,not,found,exception,return,class,utils,for,name,class,name,class,utils,get,default,class,loader
MethodInvoker -> protected Class<?> resolveClassName(String className) throws ClassNotFoundException;1498780456;Resolve the given class name into a Class._<p>The default implementations uses {@code ClassUtils.forName},_using the thread context class loader._@param className the class name to resolve_@return the resolved Class_@throws ClassNotFoundException if the class name was invalid;protected Class<?> resolveClassName(String className) throws ClassNotFoundException {_		return ClassUtils.forName(className, ClassUtils.getDefaultClassLoader())__	};resolve,the,given,class,name,into,a,class,p,the,default,implementations,uses,code,class,utils,for,name,using,the,thread,context,class,loader,param,class,name,the,class,name,to,resolve,return,the,resolved,class,throws,class,not,found,exception,if,the,class,name,was,invalid;protected,class,resolve,class,name,string,class,name,throws,class,not,found,exception,return,class,utils,for,name,class,name,class,utils,get,default,class,loader
MethodInvoker -> protected Class<?> resolveClassName(String className) throws ClassNotFoundException;1500448076;Resolve the given class name into a Class._<p>The default implementations uses {@code ClassUtils.forName},_using the thread context class loader._@param className the class name to resolve_@return the resolved Class_@throws ClassNotFoundException if the class name was invalid;protected Class<?> resolveClassName(String className) throws ClassNotFoundException {_		return ClassUtils.forName(className, ClassUtils.getDefaultClassLoader())__	};resolve,the,given,class,name,into,a,class,p,the,default,implementations,uses,code,class,utils,for,name,using,the,thread,context,class,loader,param,class,name,the,class,name,to,resolve,return,the,resolved,class,throws,class,not,found,exception,if,the,class,name,was,invalid;protected,class,resolve,class,name,string,class,name,throws,class,not,found,exception,return,class,utils,for,name,class,name,class,utils,get,default,class,loader
MethodInvoker -> protected Class<?> resolveClassName(String className) throws ClassNotFoundException;1508160858;Resolve the given class name into a Class._<p>The default implementations uses {@code ClassUtils.forName},_using the thread context class loader._@param className the class name to resolve_@return the resolved Class_@throws ClassNotFoundException if the class name was invalid;protected Class<?> resolveClassName(String className) throws ClassNotFoundException {_		return ClassUtils.forName(className, ClassUtils.getDefaultClassLoader())__	};resolve,the,given,class,name,into,a,class,p,the,default,implementations,uses,code,class,utils,for,name,using,the,thread,context,class,loader,param,class,name,the,class,name,to,resolve,return,the,resolved,class,throws,class,not,found,exception,if,the,class,name,was,invalid;protected,class,resolve,class,name,string,class,name,throws,class,not,found,exception,return,class,utils,for,name,class,name,class,utils,get,default,class,loader
MethodInvoker -> protected Class<?> resolveClassName(String className) throws ClassNotFoundException;1530174524;Resolve the given class name into a Class._<p>The default implementations uses {@code ClassUtils.forName},_using the thread context class loader._@param className the class name to resolve_@return the resolved Class_@throws ClassNotFoundException if the class name was invalid;protected Class<?> resolveClassName(String className) throws ClassNotFoundException {_		return ClassUtils.forName(className, ClassUtils.getDefaultClassLoader())__	};resolve,the,given,class,name,into,a,class,p,the,default,implementations,uses,code,class,utils,for,name,using,the,thread,context,class,loader,param,class,name,the,class,name,to,resolve,return,the,resolved,class,throws,class,not,found,exception,if,the,class,name,was,invalid;protected,class,resolve,class,name,string,class,name,throws,class,not,found,exception,return,class,utils,for,name,class,name,class,utils,get,default,class,loader
MethodInvoker -> @Nullable 	public Object getTargetObject();1496837955;Return the target object on which to call the target method.;@Nullable_	public Object getTargetObject() {_		return this.targetObject__	};return,the,target,object,on,which,to,call,the,target,method;nullable,public,object,get,target,object,return,this,target,object
MethodInvoker -> @Nullable 	public Object getTargetObject();1498780456;Return the target object on which to call the target method.;@Nullable_	public Object getTargetObject() {_		return this.targetObject__	};return,the,target,object,on,which,to,call,the,target,method;nullable,public,object,get,target,object,return,this,target,object
MethodInvoker -> @Nullable 	public Object getTargetObject();1500448076;Return the target object on which to call the target method.;@Nullable_	public Object getTargetObject() {_		return this.targetObject__	};return,the,target,object,on,which,to,call,the,target,method;nullable,public,object,get,target,object,return,this,target,object
MethodInvoker -> @Nullable 	public Object getTargetObject();1508160858;Return the target object on which to call the target method.;@Nullable_	public Object getTargetObject() {_		return this.targetObject__	};return,the,target,object,on,which,to,call,the,target,method;nullable,public,object,get,target,object,return,this,target,object
MethodInvoker -> @Nullable 	public Object getTargetObject();1530174524;Return the target object on which to call the target method.;@Nullable_	public Object getTargetObject() {_		return this.targetObject__	};return,the,target,object,on,which,to,call,the,target,method;nullable,public,object,get,target,object,return,this,target,object
MethodInvoker -> @Nullable 	protected Method findMatchingMethod();1495868221;Find a matching method with the specified name for the specified arguments._@return a matching method, or {@code null} if none_@see #getTargetClass()_@see #getTargetMethod()_@see #getArguments();@Nullable_	protected Method findMatchingMethod() {_		String targetMethod = getTargetMethod()__		Object[] arguments = getArguments()__		int argCount = arguments.length___		Method[] candidates = ReflectionUtils.getAllDeclaredMethods(getTargetClass())__		int minTypeDiffWeight = Integer.MAX_VALUE__		Method matchingMethod = null___		for (Method candidate : candidates) {_			if (candidate.getName().equals(targetMethod)) {_				Class<?>[] paramTypes = candidate.getParameterTypes()__				if (paramTypes.length == argCount) {_					int typeDiffWeight = getTypeDifferenceWeight(paramTypes, arguments)__					if (typeDiffWeight < minTypeDiffWeight) {_						minTypeDiffWeight = typeDiffWeight__						matchingMethod = candidate__					}_				}_			}_		}__		return matchingMethod__	};find,a,matching,method,with,the,specified,name,for,the,specified,arguments,return,a,matching,method,or,code,null,if,none,see,get,target,class,see,get,target,method,see,get,arguments;nullable,protected,method,find,matching,method,string,target,method,get,target,method,object,arguments,get,arguments,int,arg,count,arguments,length,method,candidates,reflection,utils,get,all,declared,methods,get,target,class,int,min,type,diff,weight,integer,method,matching,method,null,for,method,candidate,candidates,if,candidate,get,name,equals,target,method,class,param,types,candidate,get,parameter,types,if,param,types,length,arg,count,int,type,diff,weight,get,type,difference,weight,param,types,arguments,if,type,diff,weight,min,type,diff,weight,min,type,diff,weight,type,diff,weight,matching,method,candidate,return,matching,method
MethodInvoker -> @Nullable 	protected Method findMatchingMethod();1496837955;Find a matching method with the specified name for the specified arguments._@return a matching method, or {@code null} if none_@see #getTargetClass()_@see #getTargetMethod()_@see #getArguments();@Nullable_	protected Method findMatchingMethod() {_		String targetMethod = getTargetMethod()__		Object[] arguments = getArguments()__		int argCount = arguments.length___		Class<?> targetClass = getTargetClass()__		Assert.state(targetClass != null, "No target class set")__		Method[] candidates = ReflectionUtils.getAllDeclaredMethods(targetClass)__		int minTypeDiffWeight = Integer.MAX_VALUE__		Method matchingMethod = null___		for (Method candidate : candidates) {_			if (candidate.getName().equals(targetMethod)) {_				Class<?>[] paramTypes = candidate.getParameterTypes()__				if (paramTypes.length == argCount) {_					int typeDiffWeight = getTypeDifferenceWeight(paramTypes, arguments)__					if (typeDiffWeight < minTypeDiffWeight) {_						minTypeDiffWeight = typeDiffWeight__						matchingMethod = candidate__					}_				}_			}_		}__		return matchingMethod__	};find,a,matching,method,with,the,specified,name,for,the,specified,arguments,return,a,matching,method,or,code,null,if,none,see,get,target,class,see,get,target,method,see,get,arguments;nullable,protected,method,find,matching,method,string,target,method,get,target,method,object,arguments,get,arguments,int,arg,count,arguments,length,class,target,class,get,target,class,assert,state,target,class,null,no,target,class,set,method,candidates,reflection,utils,get,all,declared,methods,target,class,int,min,type,diff,weight,integer,method,matching,method,null,for,method,candidate,candidates,if,candidate,get,name,equals,target,method,class,param,types,candidate,get,parameter,types,if,param,types,length,arg,count,int,type,diff,weight,get,type,difference,weight,param,types,arguments,if,type,diff,weight,min,type,diff,weight,min,type,diff,weight,type,diff,weight,matching,method,candidate,return,matching,method
MethodInvoker -> @Nullable 	protected Method findMatchingMethod();1498780456;Find a matching method with the specified name for the specified arguments._@return a matching method, or {@code null} if none_@see #getTargetClass()_@see #getTargetMethod()_@see #getArguments();@Nullable_	protected Method findMatchingMethod() {_		String targetMethod = getTargetMethod()__		Object[] arguments = getArguments()__		int argCount = arguments.length___		Class<?> targetClass = getTargetClass()__		Assert.state(targetClass != null, "No target class set")__		Method[] candidates = ReflectionUtils.getAllDeclaredMethods(targetClass)__		int minTypeDiffWeight = Integer.MAX_VALUE__		Method matchingMethod = null___		for (Method candidate : candidates) {_			if (candidate.getName().equals(targetMethod)) {_				Class<?>[] paramTypes = candidate.getParameterTypes()__				if (paramTypes.length == argCount) {_					int typeDiffWeight = getTypeDifferenceWeight(paramTypes, arguments)__					if (typeDiffWeight < minTypeDiffWeight) {_						minTypeDiffWeight = typeDiffWeight__						matchingMethod = candidate__					}_				}_			}_		}__		return matchingMethod__	};find,a,matching,method,with,the,specified,name,for,the,specified,arguments,return,a,matching,method,or,code,null,if,none,see,get,target,class,see,get,target,method,see,get,arguments;nullable,protected,method,find,matching,method,string,target,method,get,target,method,object,arguments,get,arguments,int,arg,count,arguments,length,class,target,class,get,target,class,assert,state,target,class,null,no,target,class,set,method,candidates,reflection,utils,get,all,declared,methods,target,class,int,min,type,diff,weight,integer,method,matching,method,null,for,method,candidate,candidates,if,candidate,get,name,equals,target,method,class,param,types,candidate,get,parameter,types,if,param,types,length,arg,count,int,type,diff,weight,get,type,difference,weight,param,types,arguments,if,type,diff,weight,min,type,diff,weight,min,type,diff,weight,type,diff,weight,matching,method,candidate,return,matching,method
MethodInvoker -> @Nullable 	protected Method findMatchingMethod();1500448076;Find a matching method with the specified name for the specified arguments._@return a matching method, or {@code null} if none_@see #getTargetClass()_@see #getTargetMethod()_@see #getArguments();@Nullable_	protected Method findMatchingMethod() {_		String targetMethod = getTargetMethod()__		Object[] arguments = getArguments()__		int argCount = arguments.length___		Class<?> targetClass = getTargetClass()__		Assert.state(targetClass != null, "No target class set")__		Method[] candidates = ReflectionUtils.getAllDeclaredMethods(targetClass)__		int minTypeDiffWeight = Integer.MAX_VALUE__		Method matchingMethod = null___		for (Method candidate : candidates) {_			if (candidate.getName().equals(targetMethod)) {_				Class<?>[] paramTypes = candidate.getParameterTypes()__				if (paramTypes.length == argCount) {_					int typeDiffWeight = getTypeDifferenceWeight(paramTypes, arguments)__					if (typeDiffWeight < minTypeDiffWeight) {_						minTypeDiffWeight = typeDiffWeight__						matchingMethod = candidate__					}_				}_			}_		}__		return matchingMethod__	};find,a,matching,method,with,the,specified,name,for,the,specified,arguments,return,a,matching,method,or,code,null,if,none,see,get,target,class,see,get,target,method,see,get,arguments;nullable,protected,method,find,matching,method,string,target,method,get,target,method,object,arguments,get,arguments,int,arg,count,arguments,length,class,target,class,get,target,class,assert,state,target,class,null,no,target,class,set,method,candidates,reflection,utils,get,all,declared,methods,target,class,int,min,type,diff,weight,integer,method,matching,method,null,for,method,candidate,candidates,if,candidate,get,name,equals,target,method,class,param,types,candidate,get,parameter,types,if,param,types,length,arg,count,int,type,diff,weight,get,type,difference,weight,param,types,arguments,if,type,diff,weight,min,type,diff,weight,min,type,diff,weight,type,diff,weight,matching,method,candidate,return,matching,method
MethodInvoker -> @Nullable 	protected Method findMatchingMethod();1508160858;Find a matching method with the specified name for the specified arguments._@return a matching method, or {@code null} if none_@see #getTargetClass()_@see #getTargetMethod()_@see #getArguments();@Nullable_	protected Method findMatchingMethod() {_		String targetMethod = getTargetMethod()__		Object[] arguments = getArguments()__		int argCount = arguments.length___		Class<?> targetClass = getTargetClass()__		Assert.state(targetClass != null, "No target class set")__		Method[] candidates = ReflectionUtils.getAllDeclaredMethods(targetClass)__		int minTypeDiffWeight = Integer.MAX_VALUE__		Method matchingMethod = null___		for (Method candidate : candidates) {_			if (candidate.getName().equals(targetMethod)) {_				Class<?>[] paramTypes = candidate.getParameterTypes()__				if (paramTypes.length == argCount) {_					int typeDiffWeight = getTypeDifferenceWeight(paramTypes, arguments)__					if (typeDiffWeight < minTypeDiffWeight) {_						minTypeDiffWeight = typeDiffWeight__						matchingMethod = candidate__					}_				}_			}_		}__		return matchingMethod__	};find,a,matching,method,with,the,specified,name,for,the,specified,arguments,return,a,matching,method,or,code,null,if,none,see,get,target,class,see,get,target,method,see,get,arguments;nullable,protected,method,find,matching,method,string,target,method,get,target,method,object,arguments,get,arguments,int,arg,count,arguments,length,class,target,class,get,target,class,assert,state,target,class,null,no,target,class,set,method,candidates,reflection,utils,get,all,declared,methods,target,class,int,min,type,diff,weight,integer,method,matching,method,null,for,method,candidate,candidates,if,candidate,get,name,equals,target,method,class,param,types,candidate,get,parameter,types,if,param,types,length,arg,count,int,type,diff,weight,get,type,difference,weight,param,types,arguments,if,type,diff,weight,min,type,diff,weight,min,type,diff,weight,type,diff,weight,matching,method,candidate,return,matching,method
MethodInvoker -> @Nullable 	protected Method findMatchingMethod();1530174524;Find a matching method with the specified name for the specified arguments._@return a matching method, or {@code null} if none_@see #getTargetClass()_@see #getTargetMethod()_@see #getArguments();@Nullable_	protected Method findMatchingMethod() {_		String targetMethod = getTargetMethod()__		Object[] arguments = getArguments()__		int argCount = arguments.length___		Class<?> targetClass = getTargetClass()__		Assert.state(targetClass != null, "No target class set")__		Method[] candidates = ReflectionUtils.getAllDeclaredMethods(targetClass)__		int minTypeDiffWeight = Integer.MAX_VALUE__		Method matchingMethod = null___		for (Method candidate : candidates) {_			if (candidate.getName().equals(targetMethod)) {_				Class<?>[] paramTypes = candidate.getParameterTypes()__				if (paramTypes.length == argCount) {_					int typeDiffWeight = getTypeDifferenceWeight(paramTypes, arguments)__					if (typeDiffWeight < minTypeDiffWeight) {_						minTypeDiffWeight = typeDiffWeight__						matchingMethod = candidate__					}_				}_			}_		}__		return matchingMethod__	};find,a,matching,method,with,the,specified,name,for,the,specified,arguments,return,a,matching,method,or,code,null,if,none,see,get,target,class,see,get,target,method,see,get,arguments;nullable,protected,method,find,matching,method,string,target,method,get,target,method,object,arguments,get,arguments,int,arg,count,arguments,length,class,target,class,get,target,class,assert,state,target,class,null,no,target,class,set,method,candidates,reflection,utils,get,all,declared,methods,target,class,int,min,type,diff,weight,integer,method,matching,method,null,for,method,candidate,candidates,if,candidate,get,name,equals,target,method,class,param,types,candidate,get,parameter,types,if,param,types,length,arg,count,int,type,diff,weight,get,type,difference,weight,param,types,arguments,if,type,diff,weight,min,type,diff,weight,min,type,diff,weight,type,diff,weight,matching,method,candidate,return,matching,method
MethodInvoker -> @Nullable 	public String getTargetMethod();1496837955;Return the name of the method to be invoked.;@Nullable_	public String getTargetMethod() {_		return this.targetMethod__	};return,the,name,of,the,method,to,be,invoked;nullable,public,string,get,target,method,return,this,target,method
MethodInvoker -> @Nullable 	public String getTargetMethod();1498780456;Return the name of the method to be invoked.;@Nullable_	public String getTargetMethod() {_		return this.targetMethod__	};return,the,name,of,the,method,to,be,invoked;nullable,public,string,get,target,method,return,this,target,method
MethodInvoker -> @Nullable 	public String getTargetMethod();1500448076;Return the name of the method to be invoked.;@Nullable_	public String getTargetMethod() {_		return this.targetMethod__	};return,the,name,of,the,method,to,be,invoked;nullable,public,string,get,target,method,return,this,target,method
MethodInvoker -> @Nullable 	public String getTargetMethod();1508160858;Return the name of the method to be invoked.;@Nullable_	public String getTargetMethod() {_		return this.targetMethod__	};return,the,name,of,the,method,to,be,invoked;nullable,public,string,get,target,method,return,this,target,method
MethodInvoker -> @Nullable 	public String getTargetMethod();1530174524;Return the name of the method to be invoked.;@Nullable_	public String getTargetMethod() {_		return this.targetMethod__	};return,the,name,of,the,method,to,be,invoked;nullable,public,string,get,target,method,return,this,target,method
MethodInvoker -> public void setStaticMethod(String staticMethod);1328020251;Set a fully qualified static method name to invoke,_e.g. "example.MyExampleClass.myExampleMethod"._Convenient alternative to specifying targetClass and targetMethod._@see #setTargetClass_@see #setTargetMethod;public void setStaticMethod(String staticMethod) {_		this.staticMethod = staticMethod__	};set,a,fully,qualified,static,method,name,to,invoke,e,g,example,my,example,class,my,example,method,convenient,alternative,to,specifying,target,class,and,target,method,see,set,target,class,see,set,target,method;public,void,set,static,method,string,static,method,this,static,method,static,method
MethodInvoker -> public void setStaticMethod(String staticMethod);1356735495;Set a fully qualified static method name to invoke,_e.g. "example.MyExampleClass.myExampleMethod"._Convenient alternative to specifying targetClass and targetMethod._@see #setTargetClass_@see #setTargetMethod;public void setStaticMethod(String staticMethod) {_		this.staticMethod = staticMethod__	};set,a,fully,qualified,static,method,name,to,invoke,e,g,example,my,example,class,my,example,method,convenient,alternative,to,specifying,target,class,and,target,method,see,set,target,class,see,set,target,method;public,void,set,static,method,string,static,method,this,static,method,static,method
MethodInvoker -> public void setStaticMethod(String staticMethod);1383520795;Set a fully qualified static method name to invoke,_e.g. "example.MyExampleClass.myExampleMethod"._Convenient alternative to specifying targetClass and targetMethod._@see #setTargetClass_@see #setTargetMethod;public void setStaticMethod(String staticMethod) {_		this.staticMethod = staticMethod__	};set,a,fully,qualified,static,method,name,to,invoke,e,g,example,my,example,class,my,example,method,convenient,alternative,to,specifying,target,class,and,target,method,see,set,target,class,see,set,target,method;public,void,set,static,method,string,static,method,this,static,method,static,method
MethodInvoker -> public void setStaticMethod(String staticMethod);1385412762;Set a fully qualified static method name to invoke,_e.g. "example.MyExampleClass.myExampleMethod"._Convenient alternative to specifying targetClass and targetMethod._@see #setTargetClass_@see #setTargetMethod;public void setStaticMethod(String staticMethod) {_		this.staticMethod = staticMethod__	};set,a,fully,qualified,static,method,name,to,invoke,e,g,example,my,example,class,my,example,method,convenient,alternative,to,specifying,target,class,and,target,method,see,set,target,class,see,set,target,method;public,void,set,static,method,string,static,method,this,static,method,static,method
MethodInvoker -> public void setStaticMethod(String staticMethod);1389789549;Set a fully qualified static method name to invoke,_e.g. "example.MyExampleClass.myExampleMethod"._Convenient alternative to specifying targetClass and targetMethod._@see #setTargetClass_@see #setTargetMethod;public void setStaticMethod(String staticMethod) {_		this.staticMethod = staticMethod__	};set,a,fully,qualified,static,method,name,to,invoke,e,g,example,my,example,class,my,example,method,convenient,alternative,to,specifying,target,class,and,target,method,see,set,target,class,see,set,target,method;public,void,set,static,method,string,static,method,this,static,method,static,method
MethodInvoker -> public void setStaticMethod(String staticMethod);1495868221;Set a fully qualified static method name to invoke,_e.g. "example.MyExampleClass.myExampleMethod"._Convenient alternative to specifying targetClass and targetMethod._@see #setTargetClass_@see #setTargetMethod;public void setStaticMethod(String staticMethod) {_		this.staticMethod = staticMethod__	};set,a,fully,qualified,static,method,name,to,invoke,e,g,example,my,example,class,my,example,method,convenient,alternative,to,specifying,target,class,and,target,method,see,set,target,class,see,set,target,method;public,void,set,static,method,string,static,method,this,static,method,static,method
MethodInvoker -> public void setStaticMethod(String staticMethod);1496837955;Set a fully qualified static method name to invoke,_e.g. "example.MyExampleClass.myExampleMethod"._Convenient alternative to specifying targetClass and targetMethod._@see #setTargetClass_@see #setTargetMethod;public void setStaticMethod(String staticMethod) {_		this.staticMethod = staticMethod__	};set,a,fully,qualified,static,method,name,to,invoke,e,g,example,my,example,class,my,example,method,convenient,alternative,to,specifying,target,class,and,target,method,see,set,target,class,see,set,target,method;public,void,set,static,method,string,static,method,this,static,method,static,method
MethodInvoker -> public void setStaticMethod(String staticMethod);1498780456;Set a fully qualified static method name to invoke,_e.g. "example.MyExampleClass.myExampleMethod"._Convenient alternative to specifying targetClass and targetMethod._@see #setTargetClass_@see #setTargetMethod;public void setStaticMethod(String staticMethod) {_		this.staticMethod = staticMethod__	};set,a,fully,qualified,static,method,name,to,invoke,e,g,example,my,example,class,my,example,method,convenient,alternative,to,specifying,target,class,and,target,method,see,set,target,class,see,set,target,method;public,void,set,static,method,string,static,method,this,static,method,static,method
MethodInvoker -> public void setStaticMethod(String staticMethod);1500448076;Set a fully qualified static method name to invoke,_e.g. "example.MyExampleClass.myExampleMethod"._Convenient alternative to specifying targetClass and targetMethod._@see #setTargetClass_@see #setTargetMethod;public void setStaticMethod(String staticMethod) {_		this.staticMethod = staticMethod__	};set,a,fully,qualified,static,method,name,to,invoke,e,g,example,my,example,class,my,example,method,convenient,alternative,to,specifying,target,class,and,target,method,see,set,target,class,see,set,target,method;public,void,set,static,method,string,static,method,this,static,method,static,method
MethodInvoker -> public void setStaticMethod(String staticMethod);1508160858;Set a fully qualified static method name to invoke,_e.g. "example.MyExampleClass.myExampleMethod"._Convenient alternative to specifying targetClass and targetMethod._@see #setTargetClass_@see #setTargetMethod;public void setStaticMethod(String staticMethod) {_		this.staticMethod = staticMethod__	};set,a,fully,qualified,static,method,name,to,invoke,e,g,example,my,example,class,my,example,method,convenient,alternative,to,specifying,target,class,and,target,method,see,set,target,class,see,set,target,method;public,void,set,static,method,string,static,method,this,static,method,static,method
MethodInvoker -> public void setStaticMethod(String staticMethod);1530174524;Set a fully qualified static method name to invoke,_e.g. "example.MyExampleClass.myExampleMethod"._Convenient alternative to specifying targetClass and targetMethod._@see #setTargetClass_@see #setTargetMethod;public void setStaticMethod(String staticMethod) {_		this.staticMethod = staticMethod__	};set,a,fully,qualified,static,method,name,to,invoke,e,g,example,my,example,class,my,example,method,convenient,alternative,to,specifying,target,class,and,target,method,see,set,target,class,see,set,target,method;public,void,set,static,method,string,static,method,this,static,method,static,method
MethodInvoker -> public boolean isPrepared();1328020251;Return whether this invoker has been prepared already,_i.e. whether it allows access to {@link #getPreparedMethod()} already.;public boolean isPrepared() {_		return (this.methodObject != null)__	};return,whether,this,invoker,has,been,prepared,already,i,e,whether,it,allows,access,to,link,get,prepared,method,already;public,boolean,is,prepared,return,this,method,object,null
MethodInvoker -> public boolean isPrepared();1356735495;Return whether this invoker has been prepared already,_i.e. whether it allows access to {@link #getPreparedMethod()} already.;public boolean isPrepared() {_		return (this.methodObject != null)__	};return,whether,this,invoker,has,been,prepared,already,i,e,whether,it,allows,access,to,link,get,prepared,method,already;public,boolean,is,prepared,return,this,method,object,null
MethodInvoker -> public boolean isPrepared();1383520795;Return whether this invoker has been prepared already,_i.e. whether it allows access to {@link #getPreparedMethod()} already.;public boolean isPrepared() {_		return (this.methodObject != null)__	};return,whether,this,invoker,has,been,prepared,already,i,e,whether,it,allows,access,to,link,get,prepared,method,already;public,boolean,is,prepared,return,this,method,object,null
MethodInvoker -> public boolean isPrepared();1385412762;Return whether this invoker has been prepared already,_i.e. whether it allows access to {@link #getPreparedMethod()} already.;public boolean isPrepared() {_		return (this.methodObject != null)__	};return,whether,this,invoker,has,been,prepared,already,i,e,whether,it,allows,access,to,link,get,prepared,method,already;public,boolean,is,prepared,return,this,method,object,null
MethodInvoker -> public boolean isPrepared();1389789549;Return whether this invoker has been prepared already,_i.e. whether it allows access to {@link #getPreparedMethod()} already.;public boolean isPrepared() {_		return (this.methodObject != null)__	};return,whether,this,invoker,has,been,prepared,already,i,e,whether,it,allows,access,to,link,get,prepared,method,already;public,boolean,is,prepared,return,this,method,object,null
MethodInvoker -> public boolean isPrepared();1495868221;Return whether this invoker has been prepared already,_i.e. whether it allows access to {@link #getPreparedMethod()} already.;public boolean isPrepared() {_		return (this.methodObject != null)__	};return,whether,this,invoker,has,been,prepared,already,i,e,whether,it,allows,access,to,link,get,prepared,method,already;public,boolean,is,prepared,return,this,method,object,null
MethodInvoker -> public boolean isPrepared();1496837955;Return whether this invoker has been prepared already,_i.e. whether it allows access to {@link #getPreparedMethod()} already.;public boolean isPrepared() {_		return (this.methodObject != null)__	};return,whether,this,invoker,has,been,prepared,already,i,e,whether,it,allows,access,to,link,get,prepared,method,already;public,boolean,is,prepared,return,this,method,object,null
MethodInvoker -> public boolean isPrepared();1498780456;Return whether this invoker has been prepared already,_i.e. whether it allows access to {@link #getPreparedMethod()} already.;public boolean isPrepared() {_		return (this.methodObject != null)__	};return,whether,this,invoker,has,been,prepared,already,i,e,whether,it,allows,access,to,link,get,prepared,method,already;public,boolean,is,prepared,return,this,method,object,null
MethodInvoker -> public boolean isPrepared();1500448076;Return whether this invoker has been prepared already,_i.e. whether it allows access to {@link #getPreparedMethod()} already.;public boolean isPrepared() {_		return (this.methodObject != null)__	};return,whether,this,invoker,has,been,prepared,already,i,e,whether,it,allows,access,to,link,get,prepared,method,already;public,boolean,is,prepared,return,this,method,object,null
MethodInvoker -> public boolean isPrepared();1508160858;Return whether this invoker has been prepared already,_i.e. whether it allows access to {@link #getPreparedMethod()} already.;public boolean isPrepared() {_		return (this.methodObject != null)__	};return,whether,this,invoker,has,been,prepared,already,i,e,whether,it,allows,access,to,link,get,prepared,method,already;public,boolean,is,prepared,return,this,method,object,null
MethodInvoker -> public boolean isPrepared();1530174524;Return whether this invoker has been prepared already,_i.e. whether it allows access to {@link #getPreparedMethod()} already.;public boolean isPrepared() {_		return (this.methodObject != null)__	};return,whether,this,invoker,has,been,prepared,already,i,e,whether,it,allows,access,to,link,get,prepared,method,already;public,boolean,is,prepared,return,this,method,object,null
MethodInvoker -> public void setTargetMethod(String targetMethod);1328020251;Set the name of the method to be invoked._Refers to either a static method or a non-static method,_depending on a target object being set._@see #setTargetClass_@see #setTargetObject;public void setTargetMethod(String targetMethod) {_		this.targetMethod = targetMethod__	};set,the,name,of,the,method,to,be,invoked,refers,to,either,a,static,method,or,a,non,static,method,depending,on,a,target,object,being,set,see,set,target,class,see,set,target,object;public,void,set,target,method,string,target,method,this,target,method,target,method
MethodInvoker -> public void setTargetMethod(String targetMethod);1356735495;Set the name of the method to be invoked._Refers to either a static method or a non-static method,_depending on a target object being set._@see #setTargetClass_@see #setTargetObject;public void setTargetMethod(String targetMethod) {_		this.targetMethod = targetMethod__	};set,the,name,of,the,method,to,be,invoked,refers,to,either,a,static,method,or,a,non,static,method,depending,on,a,target,object,being,set,see,set,target,class,see,set,target,object;public,void,set,target,method,string,target,method,this,target,method,target,method
MethodInvoker -> public void setTargetMethod(String targetMethod);1383520795;Set the name of the method to be invoked._Refers to either a static method or a non-static method,_depending on a target object being set._@see #setTargetClass_@see #setTargetObject;public void setTargetMethod(String targetMethod) {_		this.targetMethod = targetMethod__	};set,the,name,of,the,method,to,be,invoked,refers,to,either,a,static,method,or,a,non,static,method,depending,on,a,target,object,being,set,see,set,target,class,see,set,target,object;public,void,set,target,method,string,target,method,this,target,method,target,method
MethodInvoker -> public void setTargetMethod(String targetMethod);1385412762;Set the name of the method to be invoked._Refers to either a static method or a non-static method,_depending on a target object being set._@see #setTargetClass_@see #setTargetObject;public void setTargetMethod(String targetMethod) {_		this.targetMethod = targetMethod__	};set,the,name,of,the,method,to,be,invoked,refers,to,either,a,static,method,or,a,non,static,method,depending,on,a,target,object,being,set,see,set,target,class,see,set,target,object;public,void,set,target,method,string,target,method,this,target,method,target,method
MethodInvoker -> public void setTargetMethod(String targetMethod);1389789549;Set the name of the method to be invoked._Refers to either a static method or a non-static method,_depending on a target object being set._@see #setTargetClass_@see #setTargetObject;public void setTargetMethod(String targetMethod) {_		this.targetMethod = targetMethod__	};set,the,name,of,the,method,to,be,invoked,refers,to,either,a,static,method,or,a,non,static,method,depending,on,a,target,object,being,set,see,set,target,class,see,set,target,object;public,void,set,target,method,string,target,method,this,target,method,target,method
MethodInvoker -> public void setTargetMethod(String targetMethod);1495868221;Set the name of the method to be invoked._Refers to either a static method or a non-static method,_depending on a target object being set._@see #setTargetClass_@see #setTargetObject;public void setTargetMethod(String targetMethod) {_		this.targetMethod = targetMethod__	};set,the,name,of,the,method,to,be,invoked,refers,to,either,a,static,method,or,a,non,static,method,depending,on,a,target,object,being,set,see,set,target,class,see,set,target,object;public,void,set,target,method,string,target,method,this,target,method,target,method
MethodInvoker -> public void setTargetMethod(String targetMethod);1496837955;Set the name of the method to be invoked._Refers to either a static method or a non-static method,_depending on a target object being set._@see #setTargetClass_@see #setTargetObject;public void setTargetMethod(String targetMethod) {_		this.targetMethod = targetMethod__	};set,the,name,of,the,method,to,be,invoked,refers,to,either,a,static,method,or,a,non,static,method,depending,on,a,target,object,being,set,see,set,target,class,see,set,target,object;public,void,set,target,method,string,target,method,this,target,method,target,method
MethodInvoker -> public void setTargetMethod(String targetMethod);1498780456;Set the name of the method to be invoked._Refers to either a static method or a non-static method,_depending on a target object being set._@see #setTargetClass_@see #setTargetObject;public void setTargetMethod(String targetMethod) {_		this.targetMethod = targetMethod__	};set,the,name,of,the,method,to,be,invoked,refers,to,either,a,static,method,or,a,non,static,method,depending,on,a,target,object,being,set,see,set,target,class,see,set,target,object;public,void,set,target,method,string,target,method,this,target,method,target,method
MethodInvoker -> public Class<?> getTargetClass();1383520795;Return the target class on which to call the target method.;public Class<?> getTargetClass() {_		return this.targetClass__	};return,the,target,class,on,which,to,call,the,target,method;public,class,get,target,class,return,this,target,class
MethodInvoker -> public Class<?> getTargetClass();1385412762;Return the target class on which to call the target method.;public Class<?> getTargetClass() {_		return this.targetClass__	};return,the,target,class,on,which,to,call,the,target,method;public,class,get,target,class,return,this,target,class
MethodInvoker -> public Class<?> getTargetClass();1389789549;Return the target class on which to call the target method.;public Class<?> getTargetClass() {_		return this.targetClass__	};return,the,target,class,on,which,to,call,the,target,method;public,class,get,target,class,return,this,target,class
MethodInvoker -> public Class<?> getTargetClass();1495868221;Return the target class on which to call the target method.;public Class<?> getTargetClass() {_		return this.targetClass__	};return,the,target,class,on,which,to,call,the,target,method;public,class,get,target,class,return,this,target,class
MethodInvoker -> public void prepare() throws ClassNotFoundException, NoSuchMethodException;1328020251;Prepare the specified method._The method can be invoked any number of times afterwards._@see #getPreparedMethod_@see #invoke;public void prepare() throws ClassNotFoundException, NoSuchMethodException {_		if (this.staticMethod != null) {_			int lastDotIndex = this.staticMethod.lastIndexOf('.')__			if (lastDotIndex == -1 || lastDotIndex == this.staticMethod.length()) {_				throw new IllegalArgumentException(_						"staticMethod must be a fully qualified class plus method name: " +_						"e.g. 'example.MyExampleClass.myExampleMethod'")__			}_			String className = this.staticMethod.substring(0, lastDotIndex)__			String methodName = this.staticMethod.substring(lastDotIndex + 1)__			this.targetClass = resolveClassName(className)__			this.targetMethod = methodName__		}__		Class targetClass = getTargetClass()__		String targetMethod = getTargetMethod()__		if (targetClass == null) {_			throw new IllegalArgumentException("Either 'targetClass' or 'targetObject' is required")__		}_		if (targetMethod == null) {_			throw new IllegalArgumentException("Property 'targetMethod' is required")__		}__		Object[] arguments = getArguments()__		Class[] argTypes = new Class[arguments.length]__		for (int i = 0_ i < arguments.length_ ++i) {_			argTypes[i] = (arguments[i] != null ? arguments[i].getClass() : Object.class)__		}__		_		try {_			this.methodObject = targetClass.getMethod(targetMethod, argTypes)__		}_		catch (NoSuchMethodException ex) {_			_			this.methodObject = findMatchingMethod()__			if (this.methodObject == null) {_				throw ex__			}_		}_	};prepare,the,specified,method,the,method,can,be,invoked,any,number,of,times,afterwards,see,get,prepared,method,see,invoke;public,void,prepare,throws,class,not,found,exception,no,such,method,exception,if,this,static,method,null,int,last,dot,index,this,static,method,last,index,of,if,last,dot,index,1,last,dot,index,this,static,method,length,throw,new,illegal,argument,exception,static,method,must,be,a,fully,qualified,class,plus,method,name,e,g,example,my,example,class,my,example,method,string,class,name,this,static,method,substring,0,last,dot,index,string,method,name,this,static,method,substring,last,dot,index,1,this,target,class,resolve,class,name,class,name,this,target,method,method,name,class,target,class,get,target,class,string,target,method,get,target,method,if,target,class,null,throw,new,illegal,argument,exception,either,target,class,or,target,object,is,required,if,target,method,null,throw,new,illegal,argument,exception,property,target,method,is,required,object,arguments,get,arguments,class,arg,types,new,class,arguments,length,for,int,i,0,i,arguments,length,i,arg,types,i,arguments,i,null,arguments,i,get,class,object,class,try,this,method,object,target,class,get,method,target,method,arg,types,catch,no,such,method,exception,ex,this,method,object,find,matching,method,if,this,method,object,null,throw,ex
MethodInvoker -> public void prepare() throws ClassNotFoundException, NoSuchMethodException;1356735495;Prepare the specified method._The method can be invoked any number of times afterwards._@see #getPreparedMethod_@see #invoke;public void prepare() throws ClassNotFoundException, NoSuchMethodException {_		if (this.staticMethod != null) {_			int lastDotIndex = this.staticMethod.lastIndexOf('.')__			if (lastDotIndex == -1 || lastDotIndex == this.staticMethod.length()) {_				throw new IllegalArgumentException(_						"staticMethod must be a fully qualified class plus method name: " +_						"e.g. 'example.MyExampleClass.myExampleMethod'")__			}_			String className = this.staticMethod.substring(0, lastDotIndex)__			String methodName = this.staticMethod.substring(lastDotIndex + 1)__			this.targetClass = resolveClassName(className)__			this.targetMethod = methodName__		}__		Class targetClass = getTargetClass()__		String targetMethod = getTargetMethod()__		if (targetClass == null) {_			throw new IllegalArgumentException("Either 'targetClass' or 'targetObject' is required")__		}_		if (targetMethod == null) {_			throw new IllegalArgumentException("Property 'targetMethod' is required")__		}__		Object[] arguments = getArguments()__		Class[] argTypes = new Class[arguments.length]__		for (int i = 0_ i < arguments.length_ ++i) {_			argTypes[i] = (arguments[i] != null ? arguments[i].getClass() : Object.class)__		}__		_		try {_			this.methodObject = targetClass.getMethod(targetMethod, argTypes)__		}_		catch (NoSuchMethodException ex) {_			_			this.methodObject = findMatchingMethod()__			if (this.methodObject == null) {_				throw ex__			}_		}_	};prepare,the,specified,method,the,method,can,be,invoked,any,number,of,times,afterwards,see,get,prepared,method,see,invoke;public,void,prepare,throws,class,not,found,exception,no,such,method,exception,if,this,static,method,null,int,last,dot,index,this,static,method,last,index,of,if,last,dot,index,1,last,dot,index,this,static,method,length,throw,new,illegal,argument,exception,static,method,must,be,a,fully,qualified,class,plus,method,name,e,g,example,my,example,class,my,example,method,string,class,name,this,static,method,substring,0,last,dot,index,string,method,name,this,static,method,substring,last,dot,index,1,this,target,class,resolve,class,name,class,name,this,target,method,method,name,class,target,class,get,target,class,string,target,method,get,target,method,if,target,class,null,throw,new,illegal,argument,exception,either,target,class,or,target,object,is,required,if,target,method,null,throw,new,illegal,argument,exception,property,target,method,is,required,object,arguments,get,arguments,class,arg,types,new,class,arguments,length,for,int,i,0,i,arguments,length,i,arg,types,i,arguments,i,null,arguments,i,get,class,object,class,try,this,method,object,target,class,get,method,target,method,arg,types,catch,no,such,method,exception,ex,this,method,object,find,matching,method,if,this,method,object,null,throw,ex
MethodInvoker -> public void prepare() throws ClassNotFoundException, NoSuchMethodException;1383520795;Prepare the specified method._The method can be invoked any number of times afterwards._@see #getPreparedMethod_@see #invoke;public void prepare() throws ClassNotFoundException, NoSuchMethodException {_		if (this.staticMethod != null) {_			int lastDotIndex = this.staticMethod.lastIndexOf('.')__			if (lastDotIndex == -1 || lastDotIndex == this.staticMethod.length()) {_				throw new IllegalArgumentException(_						"staticMethod must be a fully qualified class plus method name: " +_						"e.g. 'example.MyExampleClass.myExampleMethod'")__			}_			String className = this.staticMethod.substring(0, lastDotIndex)__			String methodName = this.staticMethod.substring(lastDotIndex + 1)__			this.targetClass = resolveClassName(className)__			this.targetMethod = methodName__		}__		Class<?> targetClass = getTargetClass()__		String targetMethod = getTargetMethod()__		if (targetClass == null) {_			throw new IllegalArgumentException("Either 'targetClass' or 'targetObject' is required")__		}_		if (targetMethod == null) {_			throw new IllegalArgumentException("Property 'targetMethod' is required")__		}__		Object[] arguments = getArguments()__		Class[] argTypes = new Class[arguments.length]__		for (int i = 0_ i < arguments.length_ ++i) {_			argTypes[i] = (arguments[i] != null ? arguments[i].getClass() : Object.class)__		}__		_		try {_			this.methodObject = targetClass.getMethod(targetMethod, argTypes)__		}_		catch (NoSuchMethodException ex) {_			_			this.methodObject = findMatchingMethod()__			if (this.methodObject == null) {_				throw ex__			}_		}_	};prepare,the,specified,method,the,method,can,be,invoked,any,number,of,times,afterwards,see,get,prepared,method,see,invoke;public,void,prepare,throws,class,not,found,exception,no,such,method,exception,if,this,static,method,null,int,last,dot,index,this,static,method,last,index,of,if,last,dot,index,1,last,dot,index,this,static,method,length,throw,new,illegal,argument,exception,static,method,must,be,a,fully,qualified,class,plus,method,name,e,g,example,my,example,class,my,example,method,string,class,name,this,static,method,substring,0,last,dot,index,string,method,name,this,static,method,substring,last,dot,index,1,this,target,class,resolve,class,name,class,name,this,target,method,method,name,class,target,class,get,target,class,string,target,method,get,target,method,if,target,class,null,throw,new,illegal,argument,exception,either,target,class,or,target,object,is,required,if,target,method,null,throw,new,illegal,argument,exception,property,target,method,is,required,object,arguments,get,arguments,class,arg,types,new,class,arguments,length,for,int,i,0,i,arguments,length,i,arg,types,i,arguments,i,null,arguments,i,get,class,object,class,try,this,method,object,target,class,get,method,target,method,arg,types,catch,no,such,method,exception,ex,this,method,object,find,matching,method,if,this,method,object,null,throw,ex
MethodInvoker -> public void prepare() throws ClassNotFoundException, NoSuchMethodException;1385412762;Prepare the specified method._The method can be invoked any number of times afterwards._@see #getPreparedMethod_@see #invoke;public void prepare() throws ClassNotFoundException, NoSuchMethodException {_		if (this.staticMethod != null) {_			int lastDotIndex = this.staticMethod.lastIndexOf('.')__			if (lastDotIndex == -1 || lastDotIndex == this.staticMethod.length()) {_				throw new IllegalArgumentException(_						"staticMethod must be a fully qualified class plus method name: " +_						"e.g. 'example.MyExampleClass.myExampleMethod'")__			}_			String className = this.staticMethod.substring(0, lastDotIndex)__			String methodName = this.staticMethod.substring(lastDotIndex + 1)__			this.targetClass = resolveClassName(className)__			this.targetMethod = methodName__		}__		Class<?> targetClass = getTargetClass()__		String targetMethod = getTargetMethod()__		if (targetClass == null) {_			throw new IllegalArgumentException("Either 'targetClass' or 'targetObject' is required")__		}_		if (targetMethod == null) {_			throw new IllegalArgumentException("Property 'targetMethod' is required")__		}__		Object[] arguments = getArguments()__		Class<?>[] argTypes = new Class<?>[arguments.length]__		for (int i = 0_ i < arguments.length_ ++i) {_			argTypes[i] = (arguments[i] != null ? arguments[i].getClass() : Object.class)__		}__		_		try {_			this.methodObject = targetClass.getMethod(targetMethod, argTypes)__		}_		catch (NoSuchMethodException ex) {_			_			this.methodObject = findMatchingMethod()__			if (this.methodObject == null) {_				throw ex__			}_		}_	};prepare,the,specified,method,the,method,can,be,invoked,any,number,of,times,afterwards,see,get,prepared,method,see,invoke;public,void,prepare,throws,class,not,found,exception,no,such,method,exception,if,this,static,method,null,int,last,dot,index,this,static,method,last,index,of,if,last,dot,index,1,last,dot,index,this,static,method,length,throw,new,illegal,argument,exception,static,method,must,be,a,fully,qualified,class,plus,method,name,e,g,example,my,example,class,my,example,method,string,class,name,this,static,method,substring,0,last,dot,index,string,method,name,this,static,method,substring,last,dot,index,1,this,target,class,resolve,class,name,class,name,this,target,method,method,name,class,target,class,get,target,class,string,target,method,get,target,method,if,target,class,null,throw,new,illegal,argument,exception,either,target,class,or,target,object,is,required,if,target,method,null,throw,new,illegal,argument,exception,property,target,method,is,required,object,arguments,get,arguments,class,arg,types,new,class,arguments,length,for,int,i,0,i,arguments,length,i,arg,types,i,arguments,i,null,arguments,i,get,class,object,class,try,this,method,object,target,class,get,method,target,method,arg,types,catch,no,such,method,exception,ex,this,method,object,find,matching,method,if,this,method,object,null,throw,ex
MethodInvoker -> public void prepare() throws ClassNotFoundException, NoSuchMethodException;1389789549;Prepare the specified method._The method can be invoked any number of times afterwards._@see #getPreparedMethod_@see #invoke;public void prepare() throws ClassNotFoundException, NoSuchMethodException {_		if (this.staticMethod != null) {_			int lastDotIndex = this.staticMethod.lastIndexOf('.')__			if (lastDotIndex == -1 || lastDotIndex == this.staticMethod.length()) {_				throw new IllegalArgumentException(_						"staticMethod must be a fully qualified class plus method name: " +_						"e.g. 'example.MyExampleClass.myExampleMethod'")__			}_			String className = this.staticMethod.substring(0, lastDotIndex)__			String methodName = this.staticMethod.substring(lastDotIndex + 1)__			this.targetClass = resolveClassName(className)__			this.targetMethod = methodName__		}__		Class<?> targetClass = getTargetClass()__		String targetMethod = getTargetMethod()__		if (targetClass == null) {_			throw new IllegalArgumentException("Either 'targetClass' or 'targetObject' is required")__		}_		if (targetMethod == null) {_			throw new IllegalArgumentException("Property 'targetMethod' is required")__		}__		Object[] arguments = getArguments()__		Class<?>[] argTypes = new Class<?>[arguments.length]__		for (int i = 0_ i < arguments.length_ ++i) {_			argTypes[i] = (arguments[i] != null ? arguments[i].getClass() : Object.class)__		}__		_		try {_			this.methodObject = targetClass.getMethod(targetMethod, argTypes)__		}_		catch (NoSuchMethodException ex) {_			_			this.methodObject = findMatchingMethod()__			if (this.methodObject == null) {_				throw ex__			}_		}_	};prepare,the,specified,method,the,method,can,be,invoked,any,number,of,times,afterwards,see,get,prepared,method,see,invoke;public,void,prepare,throws,class,not,found,exception,no,such,method,exception,if,this,static,method,null,int,last,dot,index,this,static,method,last,index,of,if,last,dot,index,1,last,dot,index,this,static,method,length,throw,new,illegal,argument,exception,static,method,must,be,a,fully,qualified,class,plus,method,name,e,g,example,my,example,class,my,example,method,string,class,name,this,static,method,substring,0,last,dot,index,string,method,name,this,static,method,substring,last,dot,index,1,this,target,class,resolve,class,name,class,name,this,target,method,method,name,class,target,class,get,target,class,string,target,method,get,target,method,if,target,class,null,throw,new,illegal,argument,exception,either,target,class,or,target,object,is,required,if,target,method,null,throw,new,illegal,argument,exception,property,target,method,is,required,object,arguments,get,arguments,class,arg,types,new,class,arguments,length,for,int,i,0,i,arguments,length,i,arg,types,i,arguments,i,null,arguments,i,get,class,object,class,try,this,method,object,target,class,get,method,target,method,arg,types,catch,no,such,method,exception,ex,this,method,object,find,matching,method,if,this,method,object,null,throw,ex
MethodInvoker -> public void prepare() throws ClassNotFoundException, NoSuchMethodException;1495868221;Prepare the specified method._The method can be invoked any number of times afterwards._@see #getPreparedMethod_@see #invoke;public void prepare() throws ClassNotFoundException, NoSuchMethodException {_		if (this.staticMethod != null) {_			int lastDotIndex = this.staticMethod.lastIndexOf('.')__			if (lastDotIndex == -1 || lastDotIndex == this.staticMethod.length()) {_				throw new IllegalArgumentException(_						"staticMethod must be a fully qualified class plus method name: " +_						"e.g. 'example.MyExampleClass.myExampleMethod'")__			}_			String className = this.staticMethod.substring(0, lastDotIndex)__			String methodName = this.staticMethod.substring(lastDotIndex + 1)__			this.targetClass = resolveClassName(className)__			this.targetMethod = methodName__		}__		Class<?> targetClass = getTargetClass()__		String targetMethod = getTargetMethod()__		if (targetClass == null) {_			throw new IllegalArgumentException("Either 'targetClass' or 'targetObject' is required")__		}_		if (targetMethod == null) {_			throw new IllegalArgumentException("Property 'targetMethod' is required")__		}__		Object[] arguments = getArguments()__		Class<?>[] argTypes = new Class<?>[arguments.length]__		for (int i = 0_ i < arguments.length_ ++i) {_			argTypes[i] = (arguments[i] != null ? arguments[i].getClass() : Object.class)__		}__		_		try {_			this.methodObject = targetClass.getMethod(targetMethod, argTypes)__		}_		catch (NoSuchMethodException ex) {_			_			this.methodObject = findMatchingMethod()__			if (this.methodObject == null) {_				throw ex__			}_		}_	};prepare,the,specified,method,the,method,can,be,invoked,any,number,of,times,afterwards,see,get,prepared,method,see,invoke;public,void,prepare,throws,class,not,found,exception,no,such,method,exception,if,this,static,method,null,int,last,dot,index,this,static,method,last,index,of,if,last,dot,index,1,last,dot,index,this,static,method,length,throw,new,illegal,argument,exception,static,method,must,be,a,fully,qualified,class,plus,method,name,e,g,example,my,example,class,my,example,method,string,class,name,this,static,method,substring,0,last,dot,index,string,method,name,this,static,method,substring,last,dot,index,1,this,target,class,resolve,class,name,class,name,this,target,method,method,name,class,target,class,get,target,class,string,target,method,get,target,method,if,target,class,null,throw,new,illegal,argument,exception,either,target,class,or,target,object,is,required,if,target,method,null,throw,new,illegal,argument,exception,property,target,method,is,required,object,arguments,get,arguments,class,arg,types,new,class,arguments,length,for,int,i,0,i,arguments,length,i,arg,types,i,arguments,i,null,arguments,i,get,class,object,class,try,this,method,object,target,class,get,method,target,method,arg,types,catch,no,such,method,exception,ex,this,method,object,find,matching,method,if,this,method,object,null,throw,ex
MethodInvoker -> public void prepare() throws ClassNotFoundException, NoSuchMethodException;1496837955;Prepare the specified method._The method can be invoked any number of times afterwards._@see #getPreparedMethod_@see #invoke;public void prepare() throws ClassNotFoundException, NoSuchMethodException {_		if (this.staticMethod != null) {_			int lastDotIndex = this.staticMethod.lastIndexOf('.')__			if (lastDotIndex == -1 || lastDotIndex == this.staticMethod.length()) {_				throw new IllegalArgumentException(_						"staticMethod must be a fully qualified class plus method name: " +_						"e.g. 'example.MyExampleClass.myExampleMethod'")__			}_			String className = this.staticMethod.substring(0, lastDotIndex)__			String methodName = this.staticMethod.substring(lastDotIndex + 1)__			this.targetClass = resolveClassName(className)__			this.targetMethod = methodName__		}__		Class<?> targetClass = getTargetClass()__		String targetMethod = getTargetMethod()__		Assert.notNull(targetClass, "Either 'targetClass' or 'targetObject' is required")__		Assert.notNull(targetMethod, "Property 'targetMethod' is required")___		Object[] arguments = getArguments()__		Class<?>[] argTypes = new Class<?>[arguments.length]__		for (int i = 0_ i < arguments.length_ ++i) {_			argTypes[i] = (arguments[i] != null ? arguments[i].getClass() : Object.class)__		}__		_		try {_			this.methodObject = targetClass.getMethod(targetMethod, argTypes)__		}_		catch (NoSuchMethodException ex) {_			_			this.methodObject = findMatchingMethod()__			if (this.methodObject == null) {_				throw ex__			}_		}_	};prepare,the,specified,method,the,method,can,be,invoked,any,number,of,times,afterwards,see,get,prepared,method,see,invoke;public,void,prepare,throws,class,not,found,exception,no,such,method,exception,if,this,static,method,null,int,last,dot,index,this,static,method,last,index,of,if,last,dot,index,1,last,dot,index,this,static,method,length,throw,new,illegal,argument,exception,static,method,must,be,a,fully,qualified,class,plus,method,name,e,g,example,my,example,class,my,example,method,string,class,name,this,static,method,substring,0,last,dot,index,string,method,name,this,static,method,substring,last,dot,index,1,this,target,class,resolve,class,name,class,name,this,target,method,method,name,class,target,class,get,target,class,string,target,method,get,target,method,assert,not,null,target,class,either,target,class,or,target,object,is,required,assert,not,null,target,method,property,target,method,is,required,object,arguments,get,arguments,class,arg,types,new,class,arguments,length,for,int,i,0,i,arguments,length,i,arg,types,i,arguments,i,null,arguments,i,get,class,object,class,try,this,method,object,target,class,get,method,target,method,arg,types,catch,no,such,method,exception,ex,this,method,object,find,matching,method,if,this,method,object,null,throw,ex
MethodInvoker -> public void prepare() throws ClassNotFoundException, NoSuchMethodException;1498780456;Prepare the specified method._The method can be invoked any number of times afterwards._@see #getPreparedMethod_@see #invoke;public void prepare() throws ClassNotFoundException, NoSuchMethodException {_		if (this.staticMethod != null) {_			int lastDotIndex = this.staticMethod.lastIndexOf('.')__			if (lastDotIndex == -1 || lastDotIndex == this.staticMethod.length()) {_				throw new IllegalArgumentException(_						"staticMethod must be a fully qualified class plus method name: " +_						"e.g. 'example.MyExampleClass.myExampleMethod'")__			}_			String className = this.staticMethod.substring(0, lastDotIndex)__			String methodName = this.staticMethod.substring(lastDotIndex + 1)__			this.targetClass = resolveClassName(className)__			this.targetMethod = methodName__		}__		Class<?> targetClass = getTargetClass()__		String targetMethod = getTargetMethod()__		Assert.notNull(targetClass, "Either 'targetClass' or 'targetObject' is required")__		Assert.notNull(targetMethod, "Property 'targetMethod' is required")___		Object[] arguments = getArguments()__		Class<?>[] argTypes = new Class<?>[arguments.length]__		for (int i = 0_ i < arguments.length_ ++i) {_			argTypes[i] = (arguments[i] != null ? arguments[i].getClass() : Object.class)__		}__		_		try {_			this.methodObject = targetClass.getMethod(targetMethod, argTypes)__		}_		catch (NoSuchMethodException ex) {_			_			this.methodObject = findMatchingMethod()__			if (this.methodObject == null) {_				throw ex__			}_		}_	};prepare,the,specified,method,the,method,can,be,invoked,any,number,of,times,afterwards,see,get,prepared,method,see,invoke;public,void,prepare,throws,class,not,found,exception,no,such,method,exception,if,this,static,method,null,int,last,dot,index,this,static,method,last,index,of,if,last,dot,index,1,last,dot,index,this,static,method,length,throw,new,illegal,argument,exception,static,method,must,be,a,fully,qualified,class,plus,method,name,e,g,example,my,example,class,my,example,method,string,class,name,this,static,method,substring,0,last,dot,index,string,method,name,this,static,method,substring,last,dot,index,1,this,target,class,resolve,class,name,class,name,this,target,method,method,name,class,target,class,get,target,class,string,target,method,get,target,method,assert,not,null,target,class,either,target,class,or,target,object,is,required,assert,not,null,target,method,property,target,method,is,required,object,arguments,get,arguments,class,arg,types,new,class,arguments,length,for,int,i,0,i,arguments,length,i,arg,types,i,arguments,i,null,arguments,i,get,class,object,class,try,this,method,object,target,class,get,method,target,method,arg,types,catch,no,such,method,exception,ex,this,method,object,find,matching,method,if,this,method,object,null,throw,ex
MethodInvoker -> public void prepare() throws ClassNotFoundException, NoSuchMethodException;1500448076;Prepare the specified method._The method can be invoked any number of times afterwards._@see #getPreparedMethod_@see #invoke;public void prepare() throws ClassNotFoundException, NoSuchMethodException {_		if (this.staticMethod != null) {_			int lastDotIndex = this.staticMethod.lastIndexOf('.')__			if (lastDotIndex == -1 || lastDotIndex == this.staticMethod.length()) {_				throw new IllegalArgumentException(_						"staticMethod must be a fully qualified class plus method name: " +_						"e.g. 'example.MyExampleClass.myExampleMethod'")__			}_			String className = this.staticMethod.substring(0, lastDotIndex)__			String methodName = this.staticMethod.substring(lastDotIndex + 1)__			this.targetClass = resolveClassName(className)__			this.targetMethod = methodName__		}__		Class<?> targetClass = getTargetClass()__		String targetMethod = getTargetMethod()__		Assert.notNull(targetClass, "Either 'targetClass' or 'targetObject' is required")__		Assert.notNull(targetMethod, "Property 'targetMethod' is required")___		Object[] arguments = getArguments()__		Class<?>[] argTypes = new Class<?>[arguments.length]__		for (int i = 0_ i < arguments.length_ ++i) {_			argTypes[i] = (arguments[i] != null ? arguments[i].getClass() : Object.class)__		}__		_		try {_			this.methodObject = targetClass.getMethod(targetMethod, argTypes)__		}_		catch (NoSuchMethodException ex) {_			_			this.methodObject = findMatchingMethod()__			if (this.methodObject == null) {_				throw ex__			}_		}_	};prepare,the,specified,method,the,method,can,be,invoked,any,number,of,times,afterwards,see,get,prepared,method,see,invoke;public,void,prepare,throws,class,not,found,exception,no,such,method,exception,if,this,static,method,null,int,last,dot,index,this,static,method,last,index,of,if,last,dot,index,1,last,dot,index,this,static,method,length,throw,new,illegal,argument,exception,static,method,must,be,a,fully,qualified,class,plus,method,name,e,g,example,my,example,class,my,example,method,string,class,name,this,static,method,substring,0,last,dot,index,string,method,name,this,static,method,substring,last,dot,index,1,this,target,class,resolve,class,name,class,name,this,target,method,method,name,class,target,class,get,target,class,string,target,method,get,target,method,assert,not,null,target,class,either,target,class,or,target,object,is,required,assert,not,null,target,method,property,target,method,is,required,object,arguments,get,arguments,class,arg,types,new,class,arguments,length,for,int,i,0,i,arguments,length,i,arg,types,i,arguments,i,null,arguments,i,get,class,object,class,try,this,method,object,target,class,get,method,target,method,arg,types,catch,no,such,method,exception,ex,this,method,object,find,matching,method,if,this,method,object,null,throw,ex
MethodInvoker -> public void prepare() throws ClassNotFoundException, NoSuchMethodException;1508160858;Prepare the specified method._The method can be invoked any number of times afterwards._@see #getPreparedMethod_@see #invoke;public void prepare() throws ClassNotFoundException, NoSuchMethodException {_		if (this.staticMethod != null) {_			int lastDotIndex = this.staticMethod.lastIndexOf('.')__			if (lastDotIndex == -1 || lastDotIndex == this.staticMethod.length()) {_				throw new IllegalArgumentException(_						"staticMethod must be a fully qualified class plus method name: " +_						"e.g. 'example.MyExampleClass.myExampleMethod'")__			}_			String className = this.staticMethod.substring(0, lastDotIndex)__			String methodName = this.staticMethod.substring(lastDotIndex + 1)__			this.targetClass = resolveClassName(className)__			this.targetMethod = methodName__		}__		Class<?> targetClass = getTargetClass()__		String targetMethod = getTargetMethod()__		Assert.notNull(targetClass, "Either 'targetClass' or 'targetObject' is required")__		Assert.notNull(targetMethod, "Property 'targetMethod' is required")___		Object[] arguments = getArguments()__		Class<?>[] argTypes = new Class<?>[arguments.length]__		for (int i = 0_ i < arguments.length_ ++i) {_			argTypes[i] = (arguments[i] != null ? arguments[i].getClass() : Object.class)__		}__		_		try {_			this.methodObject = targetClass.getMethod(targetMethod, argTypes)__		}_		catch (NoSuchMethodException ex) {_			_			this.methodObject = findMatchingMethod()__			if (this.methodObject == null) {_				throw ex__			}_		}_	};prepare,the,specified,method,the,method,can,be,invoked,any,number,of,times,afterwards,see,get,prepared,method,see,invoke;public,void,prepare,throws,class,not,found,exception,no,such,method,exception,if,this,static,method,null,int,last,dot,index,this,static,method,last,index,of,if,last,dot,index,1,last,dot,index,this,static,method,length,throw,new,illegal,argument,exception,static,method,must,be,a,fully,qualified,class,plus,method,name,e,g,example,my,example,class,my,example,method,string,class,name,this,static,method,substring,0,last,dot,index,string,method,name,this,static,method,substring,last,dot,index,1,this,target,class,resolve,class,name,class,name,this,target,method,method,name,class,target,class,get,target,class,string,target,method,get,target,method,assert,not,null,target,class,either,target,class,or,target,object,is,required,assert,not,null,target,method,property,target,method,is,required,object,arguments,get,arguments,class,arg,types,new,class,arguments,length,for,int,i,0,i,arguments,length,i,arg,types,i,arguments,i,null,arguments,i,get,class,object,class,try,this,method,object,target,class,get,method,target,method,arg,types,catch,no,such,method,exception,ex,this,method,object,find,matching,method,if,this,method,object,null,throw,ex
MethodInvoker -> public void prepare() throws ClassNotFoundException, NoSuchMethodException;1530174524;Prepare the specified method._The method can be invoked any number of times afterwards._@see #getPreparedMethod_@see #invoke;public void prepare() throws ClassNotFoundException, NoSuchMethodException {_		if (this.staticMethod != null) {_			int lastDotIndex = this.staticMethod.lastIndexOf('.')__			if (lastDotIndex == -1 || lastDotIndex == this.staticMethod.length()) {_				throw new IllegalArgumentException(_						"staticMethod must be a fully qualified class plus method name: " +_						"e.g. 'example.MyExampleClass.myExampleMethod'")__			}_			String className = this.staticMethod.substring(0, lastDotIndex)__			String methodName = this.staticMethod.substring(lastDotIndex + 1)__			this.targetClass = resolveClassName(className)__			this.targetMethod = methodName__		}__		Class<?> targetClass = getTargetClass()__		String targetMethod = getTargetMethod()__		Assert.notNull(targetClass, "Either 'targetClass' or 'targetObject' is required")__		Assert.notNull(targetMethod, "Property 'targetMethod' is required")___		Object[] arguments = getArguments()__		Class<?>[] argTypes = new Class<?>[arguments.length]__		for (int i = 0_ i < arguments.length_ ++i) {_			argTypes[i] = (arguments[i] != null ? arguments[i].getClass() : Object.class)__		}__		_		try {_			this.methodObject = targetClass.getMethod(targetMethod, argTypes)__		}_		catch (NoSuchMethodException ex) {_			_			this.methodObject = findMatchingMethod()__			if (this.methodObject == null) {_				throw ex__			}_		}_	};prepare,the,specified,method,the,method,can,be,invoked,any,number,of,times,afterwards,see,get,prepared,method,see,invoke;public,void,prepare,throws,class,not,found,exception,no,such,method,exception,if,this,static,method,null,int,last,dot,index,this,static,method,last,index,of,if,last,dot,index,1,last,dot,index,this,static,method,length,throw,new,illegal,argument,exception,static,method,must,be,a,fully,qualified,class,plus,method,name,e,g,example,my,example,class,my,example,method,string,class,name,this,static,method,substring,0,last,dot,index,string,method,name,this,static,method,substring,last,dot,index,1,this,target,class,resolve,class,name,class,name,this,target,method,method,name,class,target,class,get,target,class,string,target,method,get,target,method,assert,not,null,target,class,either,target,class,or,target,object,is,required,assert,not,null,target,method,property,target,method,is,required,object,arguments,get,arguments,class,arg,types,new,class,arguments,length,for,int,i,0,i,arguments,length,i,arg,types,i,arguments,i,null,arguments,i,get,class,object,class,try,this,method,object,target,class,get,method,target,method,arg,types,catch,no,such,method,exception,ex,this,method,object,find,matching,method,if,this,method,object,null,throw,ex
MethodInvoker -> protected Method findMatchingMethod();1328020251;Find a matching method with the specified name for the specified arguments._@return a matching method, or <code>null</code> if none_@see #getTargetClass()_@see #getTargetMethod()_@see #getArguments();protected Method findMatchingMethod() {_		String targetMethod = getTargetMethod()__		Object[] arguments = getArguments()__		int argCount = arguments.length___		Method[] candidates = ReflectionUtils.getAllDeclaredMethods(getTargetClass())__		int minTypeDiffWeight = Integer.MAX_VALUE__		Method matchingMethod = null___		for (Method candidate : candidates) {_			if (candidate.getName().equals(targetMethod)) {_				Class[] paramTypes = candidate.getParameterTypes()__				if (paramTypes.length == argCount) {_					int typeDiffWeight = getTypeDifferenceWeight(paramTypes, arguments)__					if (typeDiffWeight < minTypeDiffWeight) {_						minTypeDiffWeight = typeDiffWeight__						matchingMethod = candidate__					}_				}_			}_		}__		return matchingMethod__	};find,a,matching,method,with,the,specified,name,for,the,specified,arguments,return,a,matching,method,or,code,null,code,if,none,see,get,target,class,see,get,target,method,see,get,arguments;protected,method,find,matching,method,string,target,method,get,target,method,object,arguments,get,arguments,int,arg,count,arguments,length,method,candidates,reflection,utils,get,all,declared,methods,get,target,class,int,min,type,diff,weight,integer,method,matching,method,null,for,method,candidate,candidates,if,candidate,get,name,equals,target,method,class,param,types,candidate,get,parameter,types,if,param,types,length,arg,count,int,type,diff,weight,get,type,difference,weight,param,types,arguments,if,type,diff,weight,min,type,diff,weight,min,type,diff,weight,type,diff,weight,matching,method,candidate,return,matching,method
MethodInvoker -> protected Method findMatchingMethod();1356735495;Find a matching method with the specified name for the specified arguments._@return a matching method, or {@code null} if none_@see #getTargetClass()_@see #getTargetMethod()_@see #getArguments();protected Method findMatchingMethod() {_		String targetMethod = getTargetMethod()__		Object[] arguments = getArguments()__		int argCount = arguments.length___		Method[] candidates = ReflectionUtils.getAllDeclaredMethods(getTargetClass())__		int minTypeDiffWeight = Integer.MAX_VALUE__		Method matchingMethod = null___		for (Method candidate : candidates) {_			if (candidate.getName().equals(targetMethod)) {_				Class[] paramTypes = candidate.getParameterTypes()__				if (paramTypes.length == argCount) {_					int typeDiffWeight = getTypeDifferenceWeight(paramTypes, arguments)__					if (typeDiffWeight < minTypeDiffWeight) {_						minTypeDiffWeight = typeDiffWeight__						matchingMethod = candidate__					}_				}_			}_		}__		return matchingMethod__	};find,a,matching,method,with,the,specified,name,for,the,specified,arguments,return,a,matching,method,or,code,null,if,none,see,get,target,class,see,get,target,method,see,get,arguments;protected,method,find,matching,method,string,target,method,get,target,method,object,arguments,get,arguments,int,arg,count,arguments,length,method,candidates,reflection,utils,get,all,declared,methods,get,target,class,int,min,type,diff,weight,integer,method,matching,method,null,for,method,candidate,candidates,if,candidate,get,name,equals,target,method,class,param,types,candidate,get,parameter,types,if,param,types,length,arg,count,int,type,diff,weight,get,type,difference,weight,param,types,arguments,if,type,diff,weight,min,type,diff,weight,min,type,diff,weight,type,diff,weight,matching,method,candidate,return,matching,method
MethodInvoker -> protected Method findMatchingMethod();1383520795;Find a matching method with the specified name for the specified arguments._@return a matching method, or {@code null} if none_@see #getTargetClass()_@see #getTargetMethod()_@see #getArguments();protected Method findMatchingMethod() {_		String targetMethod = getTargetMethod()__		Object[] arguments = getArguments()__		int argCount = arguments.length___		Method[] candidates = ReflectionUtils.getAllDeclaredMethods(getTargetClass())__		int minTypeDiffWeight = Integer.MAX_VALUE__		Method matchingMethod = null___		for (Method candidate : candidates) {_			if (candidate.getName().equals(targetMethod)) {_				Class[] paramTypes = candidate.getParameterTypes()__				if (paramTypes.length == argCount) {_					int typeDiffWeight = getTypeDifferenceWeight(paramTypes, arguments)__					if (typeDiffWeight < minTypeDiffWeight) {_						minTypeDiffWeight = typeDiffWeight__						matchingMethod = candidate__					}_				}_			}_		}__		return matchingMethod__	};find,a,matching,method,with,the,specified,name,for,the,specified,arguments,return,a,matching,method,or,code,null,if,none,see,get,target,class,see,get,target,method,see,get,arguments;protected,method,find,matching,method,string,target,method,get,target,method,object,arguments,get,arguments,int,arg,count,arguments,length,method,candidates,reflection,utils,get,all,declared,methods,get,target,class,int,min,type,diff,weight,integer,method,matching,method,null,for,method,candidate,candidates,if,candidate,get,name,equals,target,method,class,param,types,candidate,get,parameter,types,if,param,types,length,arg,count,int,type,diff,weight,get,type,difference,weight,param,types,arguments,if,type,diff,weight,min,type,diff,weight,min,type,diff,weight,type,diff,weight,matching,method,candidate,return,matching,method
MethodInvoker -> protected Method findMatchingMethod();1385412762;Find a matching method with the specified name for the specified arguments._@return a matching method, or {@code null} if none_@see #getTargetClass()_@see #getTargetMethod()_@see #getArguments();protected Method findMatchingMethod() {_		String targetMethod = getTargetMethod()__		Object[] arguments = getArguments()__		int argCount = arguments.length___		Method[] candidates = ReflectionUtils.getAllDeclaredMethods(getTargetClass())__		int minTypeDiffWeight = Integer.MAX_VALUE__		Method matchingMethod = null___		for (Method candidate : candidates) {_			if (candidate.getName().equals(targetMethod)) {_				Class<?>[] paramTypes = candidate.getParameterTypes()__				if (paramTypes.length == argCount) {_					int typeDiffWeight = getTypeDifferenceWeight(paramTypes, arguments)__					if (typeDiffWeight < minTypeDiffWeight) {_						minTypeDiffWeight = typeDiffWeight__						matchingMethod = candidate__					}_				}_			}_		}__		return matchingMethod__	};find,a,matching,method,with,the,specified,name,for,the,specified,arguments,return,a,matching,method,or,code,null,if,none,see,get,target,class,see,get,target,method,see,get,arguments;protected,method,find,matching,method,string,target,method,get,target,method,object,arguments,get,arguments,int,arg,count,arguments,length,method,candidates,reflection,utils,get,all,declared,methods,get,target,class,int,min,type,diff,weight,integer,method,matching,method,null,for,method,candidate,candidates,if,candidate,get,name,equals,target,method,class,param,types,candidate,get,parameter,types,if,param,types,length,arg,count,int,type,diff,weight,get,type,difference,weight,param,types,arguments,if,type,diff,weight,min,type,diff,weight,min,type,diff,weight,type,diff,weight,matching,method,candidate,return,matching,method
MethodInvoker -> protected Method findMatchingMethod();1389789549;Find a matching method with the specified name for the specified arguments._@return a matching method, or {@code null} if none_@see #getTargetClass()_@see #getTargetMethod()_@see #getArguments();protected Method findMatchingMethod() {_		String targetMethod = getTargetMethod()__		Object[] arguments = getArguments()__		int argCount = arguments.length___		Method[] candidates = ReflectionUtils.getAllDeclaredMethods(getTargetClass())__		int minTypeDiffWeight = Integer.MAX_VALUE__		Method matchingMethod = null___		for (Method candidate : candidates) {_			if (candidate.getName().equals(targetMethod)) {_				Class<?>[] paramTypes = candidate.getParameterTypes()__				if (paramTypes.length == argCount) {_					int typeDiffWeight = getTypeDifferenceWeight(paramTypes, arguments)__					if (typeDiffWeight < minTypeDiffWeight) {_						minTypeDiffWeight = typeDiffWeight__						matchingMethod = candidate__					}_				}_			}_		}__		return matchingMethod__	};find,a,matching,method,with,the,specified,name,for,the,specified,arguments,return,a,matching,method,or,code,null,if,none,see,get,target,class,see,get,target,method,see,get,arguments;protected,method,find,matching,method,string,target,method,get,target,method,object,arguments,get,arguments,int,arg,count,arguments,length,method,candidates,reflection,utils,get,all,declared,methods,get,target,class,int,min,type,diff,weight,integer,method,matching,method,null,for,method,candidate,candidates,if,candidate,get,name,equals,target,method,class,param,types,candidate,get,parameter,types,if,param,types,length,arg,count,int,type,diff,weight,get,type,difference,weight,param,types,arguments,if,type,diff,weight,min,type,diff,weight,min,type,diff,weight,type,diff,weight,matching,method,candidate,return,matching,method
MethodInvoker -> @Nullable 	public Class<?> getTargetClass();1496837955;Return the target class on which to call the target method.;@Nullable_	public Class<?> getTargetClass() {_		return this.targetClass__	};return,the,target,class,on,which,to,call,the,target,method;nullable,public,class,get,target,class,return,this,target,class
MethodInvoker -> @Nullable 	public Class<?> getTargetClass();1498780456;Return the target class on which to call the target method.;@Nullable_	public Class<?> getTargetClass() {_		return this.targetClass__	};return,the,target,class,on,which,to,call,the,target,method;nullable,public,class,get,target,class,return,this,target,class
MethodInvoker -> @Nullable 	public Class<?> getTargetClass();1500448076;Return the target class on which to call the target method.;@Nullable_	public Class<?> getTargetClass() {_		return this.targetClass__	};return,the,target,class,on,which,to,call,the,target,method;nullable,public,class,get,target,class,return,this,target,class
MethodInvoker -> @Nullable 	public Class<?> getTargetClass();1508160858;Return the target class on which to call the target method.;@Nullable_	public Class<?> getTargetClass() {_		return this.targetClass__	};return,the,target,class,on,which,to,call,the,target,method;nullable,public,class,get,target,class,return,this,target,class
MethodInvoker -> @Nullable 	public Class<?> getTargetClass();1530174524;Return the target class on which to call the target method.;@Nullable_	public Class<?> getTargetClass() {_		return this.targetClass__	};return,the,target,class,on,which,to,call,the,target,method;nullable,public,class,get,target,class,return,this,target,class
MethodInvoker -> public void setTargetMethod(@Nullable String targetMethod);1500448076;Set the name of the method to be invoked._Refers to either a static method or a non-static method,_depending on a target object being set._@see #setTargetClass_@see #setTargetObject;public void setTargetMethod(@Nullable String targetMethod) {_		this.targetMethod = targetMethod__	};set,the,name,of,the,method,to,be,invoked,refers,to,either,a,static,method,or,a,non,static,method,depending,on,a,target,object,being,set,see,set,target,class,see,set,target,object;public,void,set,target,method,nullable,string,target,method,this,target,method,target,method
MethodInvoker -> public void setTargetMethod(@Nullable String targetMethod);1508160858;Set the name of the method to be invoked._Refers to either a static method or a non-static method,_depending on a target object being set._@see #setTargetClass_@see #setTargetObject;public void setTargetMethod(@Nullable String targetMethod) {_		this.targetMethod = targetMethod__	};set,the,name,of,the,method,to,be,invoked,refers,to,either,a,static,method,or,a,non,static,method,depending,on,a,target,object,being,set,see,set,target,class,see,set,target,object;public,void,set,target,method,nullable,string,target,method,this,target,method,target,method
MethodInvoker -> public void setTargetMethod(@Nullable String targetMethod);1530174524;Set the name of the method to be invoked._Refers to either a static method or a non-static method,_depending on a target object being set._@see #setTargetClass_@see #setTargetObject;public void setTargetMethod(@Nullable String targetMethod) {_		this.targetMethod = targetMethod__	};set,the,name,of,the,method,to,be,invoked,refers,to,either,a,static,method,or,a,non,static,method,depending,on,a,target,object,being,set,see,set,target,class,see,set,target,object;public,void,set,target,method,nullable,string,target,method,this,target,method,target,method
MethodInvoker -> protected Class resolveClassName(String className) throws ClassNotFoundException;1328020251;Resolve the given class name into a Class._<p>The default implementations uses <code>ClassUtils.forName</code>,_using the thread context class loader._@param className the class name to resolve_@return the resolved Class_@throws ClassNotFoundException if the class name was invalid;protected Class resolveClassName(String className) throws ClassNotFoundException {_		return ClassUtils.forName(className, ClassUtils.getDefaultClassLoader())__	};resolve,the,given,class,name,into,a,class,p,the,default,implementations,uses,code,class,utils,for,name,code,using,the,thread,context,class,loader,param,class,name,the,class,name,to,resolve,return,the,resolved,class,throws,class,not,found,exception,if,the,class,name,was,invalid;protected,class,resolve,class,name,string,class,name,throws,class,not,found,exception,return,class,utils,for,name,class,name,class,utils,get,default,class,loader
MethodInvoker -> protected Class resolveClassName(String className) throws ClassNotFoundException;1356735495;Resolve the given class name into a Class._<p>The default implementations uses {@code ClassUtils.forName},_using the thread context class loader._@param className the class name to resolve_@return the resolved Class_@throws ClassNotFoundException if the class name was invalid;protected Class resolveClassName(String className) throws ClassNotFoundException {_		return ClassUtils.forName(className, ClassUtils.getDefaultClassLoader())__	};resolve,the,given,class,name,into,a,class,p,the,default,implementations,uses,code,class,utils,for,name,using,the,thread,context,class,loader,param,class,name,the,class,name,to,resolve,return,the,resolved,class,throws,class,not,found,exception,if,the,class,name,was,invalid;protected,class,resolve,class,name,string,class,name,throws,class,not,found,exception,return,class,utils,for,name,class,name,class,utils,get,default,class,loader
MethodInvoker -> public void setArguments(Object... arguments);1496837955;Set arguments for the method invocation. If this property is not set,_or the Object array is of length 0, a method with no arguments is assumed.;public void setArguments(Object... arguments) {_		this.arguments = arguments__	};set,arguments,for,the,method,invocation,if,this,property,is,not,set,or,the,object,array,is,of,length,0,a,method,with,no,arguments,is,assumed;public,void,set,arguments,object,arguments,this,arguments,arguments
MethodInvoker -> public void setArguments(Object... arguments);1498780456;Set arguments for the method invocation. If this property is not set,_or the Object array is of length 0, a method with no arguments is assumed.;public void setArguments(Object... arguments) {_		this.arguments = arguments__	};set,arguments,for,the,method,invocation,if,this,property,is,not,set,or,the,object,array,is,of,length,0,a,method,with,no,arguments,is,assumed;public,void,set,arguments,object,arguments,this,arguments,arguments
MethodInvoker -> public void setArguments(Object... arguments);1500448076;Set arguments for the method invocation. If this property is not set,_or the Object array is of length 0, a method with no arguments is assumed.;public void setArguments(Object... arguments) {_		this.arguments = arguments__	};set,arguments,for,the,method,invocation,if,this,property,is,not,set,or,the,object,array,is,of,length,0,a,method,with,no,arguments,is,assumed;public,void,set,arguments,object,arguments,this,arguments,arguments
MethodInvoker -> public void setArguments(Object... arguments);1508160858;Set arguments for the method invocation. If this property is not set,_or the Object array is of length 0, a method with no arguments is assumed.;public void setArguments(Object... arguments) {_		this.arguments = arguments__	};set,arguments,for,the,method,invocation,if,this,property,is,not,set,or,the,object,array,is,of,length,0,a,method,with,no,arguments,is,assumed;public,void,set,arguments,object,arguments,this,arguments,arguments
MethodInvoker -> public void setArguments(Object... arguments);1530174524;Set arguments for the method invocation. If this property is not set,_or the Object array is of length 0, a method with no arguments is assumed.;public void setArguments(Object... arguments) {_		this.arguments = arguments__	};set,arguments,for,the,method,invocation,if,this,property,is,not,set,or,the,object,array,is,of,length,0,a,method,with,no,arguments,is,assumed;public,void,set,arguments,object,arguments,this,arguments,arguments
