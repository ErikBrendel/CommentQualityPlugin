commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * The object declaring this property, either directly or in a superclass the object extends.  */ ;/**  * The object declaring this property, either directly or in a superclass the object extends.  */ public Class<?> getObjectType() {     return this.objectType. }
true;public;0;3;/**  * The name of the property: e.g. 'foo'  */ ;/**  * The name of the property: e.g. 'foo'  */ public String getName() {     return this.name. }
true;public;0;3;/**  * The property type: e.g. {@code java.lang.String}  */ ;/**  * The property type: e.g. {@code java.lang.String}  */ public Class<?> getType() {     return this.methodParameter.getParameterType(). }
true;public;0;4;/**  * The property getter method: e.g. {@code getFoo()}  */ ;/**  * The property getter method: e.g. {@code getFoo()}  */ @Nullable public Method getReadMethod() {     return this.readMethod. }
true;public;0;4;/**  * The property setter method: e.g. {@code setFoo(String)}  */ ;/**  * The property setter method: e.g. {@code setFoo(String)}  */ @Nullable public Method getWriteMethod() {     return this.writeMethod. }
false;;0;3;;// package private MethodParameter getMethodParameter() {     return this.methodParameter. }
false;;0;6;;Annotation[] getAnnotations() {     if (this.annotations == null) {         this.annotations = resolveAnnotations().     }     return this.annotations. }
false;private;0;27;;// internal helpers private String resolveName() {     if (this.readMethod != null) {         int index = this.readMethod.getName().indexOf("get").         if (index != -1) {             index += 3.         } else {             index = this.readMethod.getName().indexOf("is").             if (index == -1) {                 throw new IllegalArgumentException("Not a getter method").             }             index += 2.         }         return StringUtils.uncapitalize(this.readMethod.getName().substring(index)).     } else if (this.writeMethod != null) {         int index = this.writeMethod.getName().indexOf("set").         if (index == -1) {             throw new IllegalArgumentException("Not a setter method").         }         index += 3.         return StringUtils.uncapitalize(this.writeMethod.getName().substring(index)).     } else {         throw new IllegalStateException("Property is neither readable nor writeable").     } }
false;private;0;18;;private MethodParameter resolveMethodParameter() {     MethodParameter read = resolveReadMethodParameter().     MethodParameter write = resolveWriteMethodParameter().     if (write == null) {         if (read == null) {             throw new IllegalStateException("Property is neither readable nor writeable").         }         return read.     }     if (read != null) {         Class<?> readType = read.getParameterType().         Class<?> writeType = write.getParameterType().         if (!writeType.equals(readType) && writeType.isAssignableFrom(readType)) {             return read.         }     }     return write. }
false;private;0;7;;@Nullable private MethodParameter resolveReadMethodParameter() {     if (getReadMethod() == null) {         return null.     }     return resolveParameterType(new MethodParameter(getReadMethod(), -1)). }
false;private;0;7;;@Nullable private MethodParameter resolveWriteMethodParameter() {     if (getWriteMethod() == null) {         return null.     }     return resolveParameterType(new MethodParameter(getWriteMethod(), 0)). }
false;private;1;5;;private MethodParameter resolveParameterType(MethodParameter parameter) {     // needed to resolve generic property types that parameterized by sub-classes e.g. T getFoo().     GenericTypeResolver.resolveParameterType(parameter, getObjectType()).     return parameter. }
false;private;0;12;;private Annotation[] resolveAnnotations() {     Annotation[] annotations = annotationCache.get(this).     if (annotations == null) {         Map<Class<? extends Annotation>, Annotation> annotationMap = new LinkedHashMap<>().         addAnnotationsToMap(annotationMap, getReadMethod()).         addAnnotationsToMap(annotationMap, getWriteMethod()).         addAnnotationsToMap(annotationMap, getField()).         annotations = annotationMap.values().toArray(new Annotation[0]).         annotationCache.put(this, annotations).     }     return annotations. }
false;private;2;9;;private void addAnnotationsToMap(Map<Class<? extends Annotation>, Annotation> annotationMap, @Nullable AnnotatedElement object) {     if (object != null) {         for (Annotation annotation : object.getAnnotations()) {             annotationMap.put(annotation.annotationType(), annotation).         }     } }
false;private;0;20;;@Nullable private Field getField() {     String name = getName().     if (!StringUtils.hasLength(name)) {         return null.     }     Field field = null.     Class<?> declaringClass = declaringClass().     if (declaringClass != null) {         field = ReflectionUtils.findField(declaringClass, name).         if (field == null) {             // Same lenient fallback checking as in CachedIntrospectionResults...             field = ReflectionUtils.findField(declaringClass, StringUtils.uncapitalize(name)).             if (field == null) {                 field = ReflectionUtils.findField(declaringClass, StringUtils.capitalize(name)).             }         }     }     return field. }
false;private;0;12;;@Nullable private Class<?> declaringClass() {     if (getReadMethod() != null) {         return getReadMethod().getDeclaringClass().     } else if (getWriteMethod() != null) {         return getWriteMethod().getDeclaringClass().     } else {         return null.     } }
false;public;1;14;;@Override public boolean equals(Object other) {     if (this == other) {         return true.     }     if (!(other instanceof Property)) {         return false.     }     Property otherProperty = (Property) other.     return (ObjectUtils.nullSafeEquals(this.objectType, otherProperty.objectType) && ObjectUtils.nullSafeEquals(this.name, otherProperty.name) && ObjectUtils.nullSafeEquals(this.readMethod, otherProperty.readMethod) && ObjectUtils.nullSafeEquals(this.writeMethod, otherProperty.writeMethod)). }
false;public;0;4;;@Override public int hashCode() {     return (ObjectUtils.nullSafeHashCode(this.objectType) * 31 + ObjectUtils.nullSafeHashCode(this.name)). }
