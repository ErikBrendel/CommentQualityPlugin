commented;modifiers;parameterAmount;loc;comment;code
true;public,final;1;3;/**  * Specify a custom {@link TaskDecorator} to be applied to any {@link Runnable}  * about to be executed.  * <p>Note that such a decorator is not necessarily being applied to the  * user-supplied {@code Runnable}/{@code Callable} but rather to the actual  * execution callback (which may be a wrapper around the user-supplied task).  * <p>The primary use case is to set some execution context around the task's  * invocation, or to provide some monitoring/statistics for task execution.  * @since 4.3  */ ;/**  * Specify a custom {@link TaskDecorator} to be applied to any {@link Runnable}  * about to be executed.  * <p>Note that such a decorator is not necessarily being applied to the  * user-supplied {@code Runnable}/{@code Callable} but rather to the actual  * execution callback (which may be a wrapper around the user-supplied task).  * <p>The primary use case is to set some execution context around the task's  * invocation, or to provide some monitoring/statistics for task execution.  * @since 4.3  */ public final void setTaskDecorator(TaskDecorator taskDecorator) {     this.taskDecorator = taskDecorator. }
true;public;1;10;/**  * Delegates to the specified JDK concurrent executor.  * @see java.util.concurrent.Executor#execute(Runnable)  */ ;/**  * Delegates to the specified JDK concurrent executor.  * @see java.util.concurrent.Executor#execute(Runnable)  */ @Override public void execute(Runnable task) {     try {         doExecute(this.concurrentExecutor, this.taskDecorator, task).     } catch (RejectedExecutionException ex) {         throw new TaskRejectedException("Executor [" + this.concurrentExecutor + "] did not accept task: " + task, ex).     } }
false;public;2;4;;@Override public void execute(Runnable task, long startTimeout) {     execute(task). }
false;public;1;17;;@Override public Future<?> submit(Runnable task) {     try {         if (this.taskDecorator == null && this.concurrentExecutor instanceof ExecutorService) {             return ((ExecutorService) this.concurrentExecutor).submit(task).         } else {             FutureTask<Object> future = new FutureTask<>(task, null).             doExecute(this.concurrentExecutor, this.taskDecorator, future).             return future.         }     } catch (RejectedExecutionException ex) {         throw new TaskRejectedException("Executor [" + this.concurrentExecutor + "] did not accept task: " + task, ex).     } }
false;public;1;17;;@Override public <T> Future<T> submit(Callable<T> task) {     try {         if (this.taskDecorator == null && this.concurrentExecutor instanceof ExecutorService) {             return ((ExecutorService) this.concurrentExecutor).submit(task).         } else {             FutureTask<T> future = new FutureTask<>(task).             doExecute(this.concurrentExecutor, this.taskDecorator, future).             return future.         }     } catch (RejectedExecutionException ex) {         throw new TaskRejectedException("Executor [" + this.concurrentExecutor + "] did not accept task: " + task, ex).     } }
false;public;1;12;;@Override public ListenableFuture<?> submitListenable(Runnable task) {     try {         ListenableFutureTask<Object> future = new ListenableFutureTask<>(task, null).         doExecute(this.concurrentExecutor, this.taskDecorator, future).         return future.     } catch (RejectedExecutionException ex) {         throw new TaskRejectedException("Executor [" + this.concurrentExecutor + "] did not accept task: " + task, ex).     } }
false;public;1;12;;@Override public <T> ListenableFuture<T> submitListenable(Callable<T> task) {     try {         ListenableFutureTask<T> future = new ListenableFutureTask<>(task).         doExecute(this.concurrentExecutor, this.taskDecorator, future).         return future.     } catch (RejectedExecutionException ex) {         throw new TaskRejectedException("Executor [" + this.concurrentExecutor + "] did not accept task: " + task, ex).     } }
true;protected;3;5;/**  * Actually execute the given {@code Runnable} (which may be a user-supplied task  * or a wrapper around a user-supplied task) with the given executor.  * @param concurrentExecutor the underlying JDK concurrent executor to delegate to  * @param taskDecorator the specified decorator to be applied, if any  * @param runnable the runnable to execute  * @throws RejectedExecutionException if the given runnable cannot be accepted  * @since 4.3  */ ;/**  * Actually execute the given {@code Runnable} (which may be a user-supplied task  * or a wrapper around a user-supplied task) with the given executor.  * @param concurrentExecutor the underlying JDK concurrent executor to delegate to  * @param taskDecorator the specified decorator to be applied, if any  * @param runnable the runnable to execute  * @throws RejectedExecutionException if the given runnable cannot be accepted  * @since 4.3  */ protected void doExecute(Executor concurrentExecutor, @Nullable TaskDecorator taskDecorator, Runnable runnable) throws RejectedExecutionException {     concurrentExecutor.execute(taskDecorator != null ? taskDecorator.decorate(runnable) : runnable). }
