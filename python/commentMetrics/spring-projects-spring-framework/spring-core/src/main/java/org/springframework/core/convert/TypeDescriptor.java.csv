# id;timestamp;commentText;codeText;commentWords;codeWords
TypeDescriptor -> public boolean isPrimitive();1328020251;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1329142650;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1335774711;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1349907422;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1351584957;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1351648403;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1356735495;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1362408075;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1368482696;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1374614239;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1382042882;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1382119085;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1382750081;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1387307647;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1387490898;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1389985540;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1390565795;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1390925810;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1391081201;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1391248381;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1394055372;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1395846555;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1403636229;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1405430015;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1406196817;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1412611699;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1414925289;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1417290561;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1419966315;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1424769447;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1424887506;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1425763631;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1431093918;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1432125256;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1441035153;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1448383050;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1450473050;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1467288171;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1467677340;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1467730834;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1477690406;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1478094883;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1479823020;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1479900301;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1480540964;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1481578128;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1482961889;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1495868221;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1496259743;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1496837955;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1498780456;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1508084888;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1522332300;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1532520919;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1546963887;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> public boolean isPrimitive();1547033218;Is this type a primitive type?;public boolean isPrimitive() {_		return getType().isPrimitive()__	};is,this,type,a,primitive,type;public,boolean,is,primitive,return,get,type,is,primitive
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1349907422;Obtain the annotation associated with this type descriptor of the specified type._@param annotationType the annotation type_@return the annotation, or null if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		for (Annotation annotation : getAnnotations()) {_			if (annotation.annotationType().equals(annotationType)) {_				return (T) annotation__			}_		}_		return null__	};obtain,the,annotation,associated,with,this,type,descriptor,of,the,specified,type,param,annotation,type,the,annotation,type,return,the,annotation,or,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,for,annotation,annotation,get,annotations,if,annotation,annotation,type,equals,annotation,type,return,t,annotation,return,null
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1351584957;Obtain the annotation associated with this type descriptor of the specified type._@param annotationType the annotation type_@return the annotation, or null if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		for (Annotation annotation : getAnnotations()) {_			if (annotation.annotationType().equals(annotationType)) {_				return (T) annotation__			}_		}_		return null__	};obtain,the,annotation,associated,with,this,type,descriptor,of,the,specified,type,param,annotation,type,the,annotation,type,return,the,annotation,or,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,for,annotation,annotation,get,annotations,if,annotation,annotation,type,equals,annotation,type,return,t,annotation,return,null
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1351648403;Obtain the annotation associated with this type descriptor of the specified type._@param annotationType the annotation type_@return the annotation, or <code>null</code> if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		for (Annotation annotation : this.annotations) {_			if (annotation.annotationType().equals(annotationType)) {_				return (T) annotation__			}_		}_		for (Annotation metaAnn : this.annotations) {_			T ann = metaAnn.annotationType().getAnnotation(annotationType)__			if (ann != null) {_				return ann__			}_		}_		return null__	};obtain,the,annotation,associated,with,this,type,descriptor,of,the,specified,type,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,code,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,for,annotation,annotation,this,annotations,if,annotation,annotation,type,equals,annotation,type,return,t,annotation,for,annotation,meta,ann,this,annotations,t,ann,meta,ann,annotation,type,get,annotation,annotation,type,if,ann,null,return,ann,return,null
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1356735495;Obtain the annotation associated with this type descriptor of the specified type._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		for (Annotation annotation : this.annotations) {_			if (annotation.annotationType().equals(annotationType)) {_				return (T) annotation__			}_		}_		for (Annotation metaAnn : this.annotations) {_			T ann = metaAnn.annotationType().getAnnotation(annotationType)__			if (ann != null) {_				return ann__			}_		}_		return null__	};obtain,the,annotation,associated,with,this,type,descriptor,of,the,specified,type,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,for,annotation,annotation,this,annotations,if,annotation,annotation,type,equals,annotation,type,return,t,annotation,for,annotation,meta,ann,this,annotations,t,ann,meta,ann,annotation,type,get,annotation,annotation,type,if,ann,null,return,ann,return,null
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1362408075;Obtain the annotation associated with this type descriptor of the specified type._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		for (Annotation annotation : this.annotations) {_			if (annotation.annotationType().equals(annotationType)) {_				return (T) annotation__			}_		}_		for (Annotation metaAnn : this.annotations) {_			T ann = metaAnn.annotationType().getAnnotation(annotationType)__			if (ann != null) {_				return ann__			}_		}_		return null__	};obtain,the,annotation,associated,with,this,type,descriptor,of,the,specified,type,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,for,annotation,annotation,this,annotations,if,annotation,annotation,type,equals,annotation,type,return,t,annotation,for,annotation,meta,ann,this,annotations,t,ann,meta,ann,annotation,type,get,annotation,annotation,type,if,ann,null,return,ann,return,null
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1368482696;Obtain the annotation associated with this type descriptor of the specified type._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		for (Annotation annotation : this.annotations) {_			if (annotation.annotationType().equals(annotationType)) {_				return (T) annotation__			}_		}_		for (Annotation metaAnn : this.annotations) {_			T ann = metaAnn.annotationType().getAnnotation(annotationType)__			if (ann != null) {_				return ann__			}_		}_		return null__	};obtain,the,annotation,associated,with,this,type,descriptor,of,the,specified,type,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,for,annotation,annotation,this,annotations,if,annotation,annotation,type,equals,annotation,type,return,t,annotation,for,annotation,meta,ann,this,annotations,t,ann,meta,ann,annotation,type,get,annotation,annotation,type,if,ann,null,return,ann,return,null
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1374614239;Obtain the annotation associated with this type descriptor of the specified type._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		for (Annotation annotation : this.annotations) {_			if (annotation.annotationType().equals(annotationType)) {_				return (T) annotation__			}_		}_		for (Annotation metaAnn : this.annotations) {_			T ann = metaAnn.annotationType().getAnnotation(annotationType)__			if (ann != null) {_				return ann__			}_		}_		return null__	};obtain,the,annotation,associated,with,this,type,descriptor,of,the,specified,type,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,for,annotation,annotation,this,annotations,if,annotation,annotation,type,equals,annotation,type,return,t,annotation,for,annotation,meta,ann,this,annotations,t,ann,meta,ann,annotation,type,get,annotation,annotation,type,if,ann,null,return,ann,return,null
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1382042882;Obtain the annotation associated with this type descriptor of the specified type._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		for (Annotation annotation : getAnnotations()) {_			if (annotation.annotationType().equals(annotationType)) {_				return (T) annotation__			}_		}_		for (Annotation metaAnn : getAnnotations()) {_			T ann = metaAnn.annotationType().getAnnotation(annotationType)__			if (ann != null) {_				return ann__			}_		}_		return null__	};obtain,the,annotation,associated,with,this,type,descriptor,of,the,specified,type,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,for,annotation,annotation,get,annotations,if,annotation,annotation,type,equals,annotation,type,return,t,annotation,for,annotation,meta,ann,get,annotations,t,ann,meta,ann,annotation,type,get,annotation,annotation,type,if,ann,null,return,ann,return,null
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1382119085;Obtain the annotation associated with this type descriptor of the specified type._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		for (Annotation annotation : getAnnotations()) {_			if (annotation.annotationType().equals(annotationType)) {_				return (T) annotation__			}_		}_		for (Annotation metaAnn : getAnnotations()) {_			T ann = metaAnn.annotationType().getAnnotation(annotationType)__			if (ann != null) {_				return ann__			}_		}_		return null__	};obtain,the,annotation,associated,with,this,type,descriptor,of,the,specified,type,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,for,annotation,annotation,get,annotations,if,annotation,annotation,type,equals,annotation,type,return,t,annotation,for,annotation,meta,ann,get,annotations,t,ann,meta,ann,annotation,type,get,annotation,annotation,type,if,ann,null,return,ann,return,null
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1382750081;Obtain the annotation associated with this type descriptor of the specified type._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		for (Annotation annotation : getAnnotations()) {_			if (annotation.annotationType().equals(annotationType)) {_				return (T) annotation__			}_		}_		for (Annotation metaAnn : getAnnotations()) {_			T ann = metaAnn.annotationType().getAnnotation(annotationType)__			if (ann != null) {_				return ann__			}_		}_		return null__	};obtain,the,annotation,associated,with,this,type,descriptor,of,the,specified,type,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,for,annotation,annotation,get,annotations,if,annotation,annotation,type,equals,annotation,type,return,t,annotation,for,annotation,meta,ann,get,annotations,t,ann,meta,ann,annotation,type,get,annotation,annotation,type,if,ann,null,return,ann,return,null
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1387307647;Obtain the annotation associated with this type descriptor of the specified type._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		for (Annotation annotation : getAnnotations()) {_			if (annotation.annotationType().equals(annotationType)) {_				return (T) annotation__			}_		}_		for (Annotation metaAnn : getAnnotations()) {_			T ann = metaAnn.annotationType().getAnnotation(annotationType)__			if (ann != null) {_				return ann__			}_		}_		return null__	};obtain,the,annotation,associated,with,this,type,descriptor,of,the,specified,type,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,for,annotation,annotation,get,annotations,if,annotation,annotation,type,equals,annotation,type,return,t,annotation,for,annotation,meta,ann,get,annotations,t,ann,meta,ann,annotation,type,get,annotation,annotation,type,if,ann,null,return,ann,return,null
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1387490898;Obtain the annotation associated with this type descriptor of the specified type._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		for (Annotation annotation : getAnnotations()) {_			if (annotation.annotationType().equals(annotationType)) {_				return (T) annotation__			}_		}_		for (Annotation metaAnn : getAnnotations()) {_			T ann = metaAnn.annotationType().getAnnotation(annotationType)__			if (ann != null) {_				return ann__			}_		}_		return null__	};obtain,the,annotation,associated,with,this,type,descriptor,of,the,specified,type,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,for,annotation,annotation,get,annotations,if,annotation,annotation,type,equals,annotation,type,return,t,annotation,for,annotation,meta,ann,get,annotations,t,ann,meta,ann,annotation,type,get,annotation,annotation,type,if,ann,null,return,ann,return,null
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1389985540;Obtain the annotation associated with this type descriptor of the specified type._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		for (Annotation annotation : getAnnotations()) {_			if (annotation.annotationType().equals(annotationType)) {_				return (T) annotation__			}_		}_		for (Annotation metaAnn : getAnnotations()) {_			T ann = metaAnn.annotationType().getAnnotation(annotationType)__			if (ann != null) {_				return ann__			}_		}_		return null__	};obtain,the,annotation,associated,with,this,type,descriptor,of,the,specified,type,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,for,annotation,annotation,get,annotations,if,annotation,annotation,type,equals,annotation,type,return,t,annotation,for,annotation,meta,ann,get,annotations,t,ann,meta,ann,annotation,type,get,annotation,annotation,type,if,ann,null,return,ann,return,null
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1390565795;Obtain the annotation associated with this type descriptor of the specified type._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		for (Annotation annotation : getAnnotations()) {_			if (annotation.annotationType().equals(annotationType)) {_				return (T) annotation__			}_		}_		for (Annotation metaAnn : getAnnotations()) {_			T ann = metaAnn.annotationType().getAnnotation(annotationType)__			if (ann != null) {_				return ann__			}_		}_		return null__	};obtain,the,annotation,associated,with,this,type,descriptor,of,the,specified,type,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,for,annotation,annotation,get,annotations,if,annotation,annotation,type,equals,annotation,type,return,t,annotation,for,annotation,meta,ann,get,annotations,t,ann,meta,ann,annotation,type,get,annotation,annotation,type,if,ann,null,return,ann,return,null
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1390925810;Obtain the annotation associated with this type descriptor of the specified type._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		for (Annotation annotation : getAnnotations()) {_			if (annotation.annotationType().equals(annotationType)) {_				return (T) annotation__			}_		}_		for (Annotation metaAnn : getAnnotations()) {_			T ann = metaAnn.annotationType().getAnnotation(annotationType)__			if (ann != null) {_				return ann__			}_		}_		return null__	};obtain,the,annotation,associated,with,this,type,descriptor,of,the,specified,type,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,for,annotation,annotation,get,annotations,if,annotation,annotation,type,equals,annotation,type,return,t,annotation,for,annotation,meta,ann,get,annotations,t,ann,meta,ann,annotation,type,get,annotation,annotation,type,if,ann,null,return,ann,return,null
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1391081201;Obtain the annotation associated with this type descriptor of the specified type._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		for (Annotation annotation : getAnnotations()) {_			if (annotation.annotationType().equals(annotationType)) {_				return (T) annotation__			}_		}_		for (Annotation metaAnn : getAnnotations()) {_			T ann = metaAnn.annotationType().getAnnotation(annotationType)__			if (ann != null) {_				return ann__			}_		}_		return null__	};obtain,the,annotation,associated,with,this,type,descriptor,of,the,specified,type,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,for,annotation,annotation,get,annotations,if,annotation,annotation,type,equals,annotation,type,return,t,annotation,for,annotation,meta,ann,get,annotations,t,ann,meta,ann,annotation,type,get,annotation,annotation,type,if,ann,null,return,ann,return,null
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1391248381;Obtain the annotation associated with this type descriptor of the specified type._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		for (Annotation annotation : getAnnotations()) {_			if (annotation.annotationType().equals(annotationType)) {_				return (T) annotation__			}_		}_		for (Annotation metaAnn : getAnnotations()) {_			T ann = metaAnn.annotationType().getAnnotation(annotationType)__			if (ann != null) {_				return ann__			}_		}_		return null__	};obtain,the,annotation,associated,with,this,type,descriptor,of,the,specified,type,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,for,annotation,annotation,get,annotations,if,annotation,annotation,type,equals,annotation,type,return,t,annotation,for,annotation,meta,ann,get,annotations,t,ann,meta,ann,annotation,type,get,annotation,annotation,type,if,ann,null,return,ann,return,null
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1394055372;Obtain the annotation associated with this type descriptor of the specified type._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		for (Annotation annotation : getAnnotations()) {_			if (annotation.annotationType().equals(annotationType)) {_				return (T) annotation__			}_		}_		for (Annotation metaAnn : getAnnotations()) {_			T ann = metaAnn.annotationType().getAnnotation(annotationType)__			if (ann != null) {_				return ann__			}_		}_		return null__	};obtain,the,annotation,associated,with,this,type,descriptor,of,the,specified,type,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,for,annotation,annotation,get,annotations,if,annotation,annotation,type,equals,annotation,type,return,t,annotation,for,annotation,meta,ann,get,annotations,t,ann,meta,ann,annotation,type,get,annotation,annotation,type,if,ann,null,return,ann,return,null
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1395846555;Obtain the annotation associated with this type descriptor of the specified type._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		for (Annotation annotation : getAnnotations()) {_			if (annotation.annotationType().equals(annotationType)) {_				return (T) annotation__			}_		}_		for (Annotation metaAnn : getAnnotations()) {_			T ann = metaAnn.annotationType().getAnnotation(annotationType)__			if (ann != null) {_				return ann__			}_		}_		return null__	};obtain,the,annotation,associated,with,this,type,descriptor,of,the,specified,type,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,for,annotation,annotation,get,annotations,if,annotation,annotation,type,equals,annotation,type,return,t,annotation,for,annotation,meta,ann,get,annotations,t,ann,meta,ann,annotation,type,get,annotation,annotation,type,if,ann,null,return,ann,return,null
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1403636229;Obtain the annotation associated with this type descriptor of the specified type._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		for (Annotation annotation : getAnnotations()) {_			if (annotation.annotationType().equals(annotationType)) {_				return (T) annotation__			}_		}_		for (Annotation metaAnn : getAnnotations()) {_			T ann = metaAnn.annotationType().getAnnotation(annotationType)__			if (ann != null) {_				return ann__			}_		}_		return null__	};obtain,the,annotation,associated,with,this,type,descriptor,of,the,specified,type,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,for,annotation,annotation,get,annotations,if,annotation,annotation,type,equals,annotation,type,return,t,annotation,for,annotation,meta,ann,get,annotations,t,ann,meta,ann,annotation,type,get,annotation,annotation,type,if,ann,null,return,ann,return,null
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1405430015;Obtain the annotation associated with this type descriptor of the specified type._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		for (Annotation annotation : getAnnotations()) {_			if (annotation.annotationType().equals(annotationType)) {_				return (T) annotation__			}_		}_		for (Annotation metaAnn : getAnnotations()) {_			T ann = metaAnn.annotationType().getAnnotation(annotationType)__			if (ann != null) {_				return ann__			}_		}_		return null__	};obtain,the,annotation,associated,with,this,type,descriptor,of,the,specified,type,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,for,annotation,annotation,get,annotations,if,annotation,annotation,type,equals,annotation,type,return,t,annotation,for,annotation,meta,ann,get,annotations,t,ann,meta,ann,annotation,type,get,annotation,annotation,type,if,ann,null,return,ann,return,null
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1406196817;Obtain the annotation associated with this type descriptor of the specified type._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		for (Annotation annotation : getAnnotations()) {_			if (annotation.annotationType().equals(annotationType)) {_				return (T) annotation__			}_		}_		for (Annotation metaAnn : getAnnotations()) {_			T ann = metaAnn.annotationType().getAnnotation(annotationType)__			if (ann != null) {_				return ann__			}_		}_		return null__	};obtain,the,annotation,associated,with,this,type,descriptor,of,the,specified,type,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,for,annotation,annotation,get,annotations,if,annotation,annotation,type,equals,annotation,type,return,t,annotation,for,annotation,meta,ann,get,annotations,t,ann,meta,ann,annotation,type,get,annotation,annotation,type,if,ann,null,return,ann,return,null
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1412611699;Obtain the annotation associated with this type descriptor of the specified type._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		for (Annotation annotation : getAnnotations()) {_			if (annotation.annotationType().equals(annotationType)) {_				return (T) annotation__			}_		}_		for (Annotation metaAnn : getAnnotations()) {_			T ann = metaAnn.annotationType().getAnnotation(annotationType)__			if (ann != null) {_				return ann__			}_		}_		return null__	};obtain,the,annotation,associated,with,this,type,descriptor,of,the,specified,type,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,for,annotation,annotation,get,annotations,if,annotation,annotation,type,equals,annotation,type,return,t,annotation,for,annotation,meta,ann,get,annotations,t,ann,meta,ann,annotation,type,get,annotation,annotation,type,if,ann,null,return,ann,return,null
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1414925289;Obtain the annotation associated with this type descriptor of the specified type._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		for (Annotation annotation : getAnnotations()) {_			if (annotation.annotationType().equals(annotationType)) {_				return (T) annotation__			}_		}_		for (Annotation metaAnn : getAnnotations()) {_			T ann = metaAnn.annotationType().getAnnotation(annotationType)__			if (ann != null) {_				return ann__			}_		}_		return null__	};obtain,the,annotation,associated,with,this,type,descriptor,of,the,specified,type,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,for,annotation,annotation,get,annotations,if,annotation,annotation,type,equals,annotation,type,return,t,annotation,for,annotation,meta,ann,get,annotations,t,ann,meta,ann,annotation,type,get,annotation,annotation,type,if,ann,null,return,ann,return,null
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1417290561;Obtain the annotation associated with this type descriptor of the specified type._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		for (Annotation annotation : getAnnotations()) {_			if (annotation.annotationType().equals(annotationType)) {_				return (T) annotation__			}_		}_		for (Annotation metaAnn : getAnnotations()) {_			T ann = metaAnn.annotationType().getAnnotation(annotationType)__			if (ann != null) {_				return ann__			}_		}_		return null__	};obtain,the,annotation,associated,with,this,type,descriptor,of,the,specified,type,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,for,annotation,annotation,get,annotations,if,annotation,annotation,type,equals,annotation,type,return,t,annotation,for,annotation,meta,ann,get,annotations,t,ann,meta,ann,annotation,type,get,annotation,annotation,type,if,ann,null,return,ann,return,null
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1419966315;Obtain the annotation associated with this type descriptor of the specified type._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		for (Annotation annotation : getAnnotations()) {_			if (annotation.annotationType().equals(annotationType)) {_				return (T) annotation__			}_		}_		for (Annotation metaAnn : getAnnotations()) {_			T ann = metaAnn.annotationType().getAnnotation(annotationType)__			if (ann != null) {_				return ann__			}_		}_		return null__	};obtain,the,annotation,associated,with,this,type,descriptor,of,the,specified,type,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,for,annotation,annotation,get,annotations,if,annotation,annotation,type,equals,annotation,type,return,t,annotation,for,annotation,meta,ann,get,annotations,t,ann,meta,ann,annotation,type,get,annotation,annotation,type,if,ann,null,return,ann,return,null
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1424769447;Obtain the annotation associated with this type descriptor of the specified type._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		for (Annotation annotation : getAnnotations()) {_			if (annotation.annotationType().equals(annotationType)) {_				return (T) annotation__			}_		}_		for (Annotation metaAnn : getAnnotations()) {_			T ann = metaAnn.annotationType().getAnnotation(annotationType)__			if (ann != null) {_				return ann__			}_		}_		return null__	};obtain,the,annotation,associated,with,this,type,descriptor,of,the,specified,type,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,for,annotation,annotation,get,annotations,if,annotation,annotation,type,equals,annotation,type,return,t,annotation,for,annotation,meta,ann,get,annotations,t,ann,meta,ann,annotation,type,get,annotation,annotation,type,if,ann,null,return,ann,return,null
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1424887506;Obtain the annotation associated with this type descriptor of the specified type._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		for (Annotation annotation : getAnnotations()) {_			if (annotation.annotationType().equals(annotationType)) {_				return (T) annotation__			}_		}_		for (Annotation metaAnn : getAnnotations()) {_			T ann = metaAnn.annotationType().getAnnotation(annotationType)__			if (ann != null) {_				return ann__			}_		}_		return null__	};obtain,the,annotation,associated,with,this,type,descriptor,of,the,specified,type,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,for,annotation,annotation,get,annotations,if,annotation,annotation,type,equals,annotation,type,return,t,annotation,for,annotation,meta,ann,get,annotations,t,ann,meta,ann,annotation,type,get,annotation,annotation,type,if,ann,null,return,ann,return,null
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1425763631;Obtain the annotation associated with this type descriptor of the specified type._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		for (Annotation annotation : getAnnotations()) {_			if (annotation.annotationType().equals(annotationType)) {_				return (T) annotation__			}_		}_		for (Annotation metaAnn : getAnnotations()) {_			T ann = metaAnn.annotationType().getAnnotation(annotationType)__			if (ann != null) {_				return ann__			}_		}_		return null__	};obtain,the,annotation,associated,with,this,type,descriptor,of,the,specified,type,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,for,annotation,annotation,get,annotations,if,annotation,annotation,type,equals,annotation,type,return,t,annotation,for,annotation,meta,ann,get,annotations,t,ann,meta,ann,annotation,type,get,annotation,annotation,type,if,ann,null,return,ann,return,null
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1431093918;Obtain the annotation of the specified {@code annotationType} that is_on this type descriptor._<p>As of Spring Framework 4.2, this method supports arbitrary levels_of meta-annotations._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		_		_		_		for (Annotation annotation : getAnnotations()) {_			if (annotation.annotationType().equals(annotationType)) {_				return (T) annotation__			}_		}__		_		for (Annotation composedAnnotation : getAnnotations()) {_			T ann = AnnotationUtils.findAnnotation(composedAnnotation.annotationType(), annotationType)__			if (ann != null) {_				return ann__			}_		}_		return null__	};obtain,the,annotation,of,the,specified,code,annotation,type,that,is,on,this,type,descriptor,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,for,annotation,annotation,get,annotations,if,annotation,annotation,type,equals,annotation,type,return,t,annotation,for,annotation,composed,annotation,get,annotations,t,ann,annotation,utils,find,annotation,composed,annotation,annotation,type,annotation,type,if,ann,null,return,ann,return,null
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1432125256;Obtain the annotation of the specified {@code annotationType} that is_on this type descriptor._<p>As of Spring Framework 4.2, this method supports arbitrary levels_of meta-annotations._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		_		_		_		for (Annotation annotation : getAnnotations()) {_			if (annotation.annotationType().equals(annotationType)) {_				return (T) annotation__			}_		}__		_		for (Annotation composedAnnotation : getAnnotations()) {_			T ann = AnnotationUtils.findAnnotation(composedAnnotation.annotationType(), annotationType)__			if (ann != null) {_				return ann__			}_		}_		return null__	};obtain,the,annotation,of,the,specified,code,annotation,type,that,is,on,this,type,descriptor,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,for,annotation,annotation,get,annotations,if,annotation,annotation,type,equals,annotation,type,return,t,annotation,for,annotation,composed,annotation,get,annotations,t,ann,annotation,utils,find,annotation,composed,annotation,annotation,type,annotation,type,if,ann,null,return,ann,return,null
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1441035153;Obtain the annotation of the specified {@code annotationType} that is_on this type descriptor._<p>As of Spring Framework 4.2, this method supports arbitrary levels_of meta-annotations._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		_		_		_		for (Annotation annotation : getAnnotations()) {_			if (annotation.annotationType().equals(annotationType)) {_				return (T) annotation__			}_		}__		_		for (Annotation composedAnnotation : getAnnotations()) {_			T ann = AnnotationUtils.findAnnotation(composedAnnotation.annotationType(), annotationType)__			if (ann != null) {_				return ann__			}_		}_		return null__	};obtain,the,annotation,of,the,specified,code,annotation,type,that,is,on,this,type,descriptor,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,for,annotation,annotation,get,annotations,if,annotation,annotation,type,equals,annotation,type,return,t,annotation,for,annotation,composed,annotation,get,annotations,t,ann,annotation,utils,find,annotation,composed,annotation,annotation,type,annotation,type,if,ann,null,return,ann,return,null
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1448383050;Obtain the annotation of the specified {@code annotationType} that is on this type descriptor._<p>As of Spring Framework 4.2, this method supports arbitrary levels of meta-annotations._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		_		_		for (Annotation annotation : getAnnotations()) {_			if (annotation.annotationType() == annotationType) {_				return (T) annotation__			}_		}__		_		for (Annotation composedAnnotation : getAnnotations()) {_			T ann = AnnotationUtils.findAnnotation(composedAnnotation.annotationType(), annotationType)__			if (ann != null) {_				return ann__			}_		}_		return null__	};obtain,the,annotation,of,the,specified,code,annotation,type,that,is,on,this,type,descriptor,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,for,annotation,annotation,get,annotations,if,annotation,annotation,type,annotation,type,return,t,annotation,for,annotation,composed,annotation,get,annotations,t,ann,annotation,utils,find,annotation,composed,annotation,annotation,type,annotation,type,if,ann,null,return,ann,return,null
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1450473050;Obtain the annotation of the specified {@code annotationType} that is on this type descriptor._<p>As of Spring Framework 4.2, this method supports arbitrary levels of meta-annotations._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		_		_		for (Annotation annotation : getAnnotations()) {_			if (annotation.annotationType() == annotationType) {_				return (T) annotation__			}_		}__		_		for (Annotation composedAnnotation : getAnnotations()) {_			T ann = AnnotationUtils.findAnnotation(composedAnnotation.annotationType(), annotationType)__			if (ann != null) {_				return ann__			}_		}_		return null__	};obtain,the,annotation,of,the,specified,code,annotation,type,that,is,on,this,type,descriptor,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,for,annotation,annotation,get,annotations,if,annotation,annotation,type,annotation,type,return,t,annotation,for,annotation,composed,annotation,get,annotations,t,ann,annotation,utils,find,annotation,composed,annotation,annotation,type,annotation,type,if,ann,null,return,ann,return,null
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1467288171;Obtain the annotation of the specified {@code annotationType} that is on this type descriptor._<p>As of Spring Framework 4.2, this method supports arbitrary levels of meta-annotations._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		_		_		for (Annotation annotation : getAnnotations()) {_			if (annotation.annotationType() == annotationType) {_				return (T) annotation__			}_		}__		_		for (Annotation composedAnnotation : getAnnotations()) {_			T ann = AnnotationUtils.findAnnotation(composedAnnotation.annotationType(), annotationType)__			if (ann != null) {_				return ann__			}_		}_		return null__	};obtain,the,annotation,of,the,specified,code,annotation,type,that,is,on,this,type,descriptor,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,for,annotation,annotation,get,annotations,if,annotation,annotation,type,annotation,type,return,t,annotation,for,annotation,composed,annotation,get,annotations,t,ann,annotation,utils,find,annotation,composed,annotation,annotation,type,annotation,type,if,ann,null,return,ann,return,null
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1467677340;Obtain the annotation of the specified {@code annotationType} that is on this type descriptor._<p>As of Spring Framework 4.2, this method supports arbitrary levels of meta-annotations._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		_		_		for (Annotation annotation : getAnnotations()) {_			if (annotation.annotationType() == annotationType) {_				return (T) annotation__			}_		}__		_		for (Annotation composedAnnotation : getAnnotations()) {_			T ann = AnnotationUtils.findAnnotation(composedAnnotation.annotationType(), annotationType)__			if (ann != null) {_				return ann__			}_		}_		return null__	};obtain,the,annotation,of,the,specified,code,annotation,type,that,is,on,this,type,descriptor,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,for,annotation,annotation,get,annotations,if,annotation,annotation,type,annotation,type,return,t,annotation,for,annotation,composed,annotation,get,annotations,t,ann,annotation,utils,find,annotation,composed,annotation,annotation,type,annotation,type,if,ann,null,return,ann,return,null
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1467730834;Obtain the annotation of the specified {@code annotationType} that is on this type descriptor._<p>As of Spring Framework 4.2, this method supports arbitrary levels of meta-annotations._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		_		_		for (Annotation annotation : getAnnotations()) {_			if (annotation.annotationType() == annotationType) {_				return (T) annotation__			}_		}__		_		for (Annotation composedAnnotation : getAnnotations()) {_			T ann = AnnotationUtils.findAnnotation(composedAnnotation.annotationType(), annotationType)__			if (ann != null) {_				return ann__			}_		}_		return null__	};obtain,the,annotation,of,the,specified,code,annotation,type,that,is,on,this,type,descriptor,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,for,annotation,annotation,get,annotations,if,annotation,annotation,type,annotation,type,return,t,annotation,for,annotation,composed,annotation,get,annotations,t,ann,annotation,utils,find,annotation,composed,annotation,annotation,type,annotation,type,if,ann,null,return,ann,return,null
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1477690406;Obtain the annotation of the specified {@code annotationType} that is on this type descriptor._<p>As of Spring Framework 4.2, this method supports arbitrary levels of meta-annotations._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		return AnnotatedElementUtils.getMergedAnnotation(this.annotatedElement, annotationType)__	};obtain,the,annotation,of,the,specified,code,annotation,type,that,is,on,this,type,descriptor,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,return,annotated,element,utils,get,merged,annotation,this,annotated,element,annotation,type
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1478094883;Obtain the annotation of the specified {@code annotationType} that is on this type descriptor._<p>As of Spring Framework 4.2, this method supports arbitrary levels of meta-annotations._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		return AnnotatedElementUtils.getMergedAnnotation(this.annotatedElement, annotationType)__	};obtain,the,annotation,of,the,specified,code,annotation,type,that,is,on,this,type,descriptor,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,return,annotated,element,utils,get,merged,annotation,this,annotated,element,annotation,type
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1479823020;Obtain the annotation of the specified {@code annotationType} that is on this type descriptor._<p>As of Spring Framework 4.2, this method supports arbitrary levels of meta-annotations._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		return AnnotatedElementUtils.getMergedAnnotation(this.annotatedElement, annotationType)__	};obtain,the,annotation,of,the,specified,code,annotation,type,that,is,on,this,type,descriptor,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,return,annotated,element,utils,get,merged,annotation,this,annotated,element,annotation,type
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1479900301;Obtain the annotation of the specified {@code annotationType} that is on this type descriptor._<p>As of Spring Framework 4.2, this method supports arbitrary levels of meta-annotations._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		return AnnotatedElementUtils.getMergedAnnotation(this.annotatedElement, annotationType)__	};obtain,the,annotation,of,the,specified,code,annotation,type,that,is,on,this,type,descriptor,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,return,annotated,element,utils,get,merged,annotation,this,annotated,element,annotation,type
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1480540964;Obtain the annotation of the specified {@code annotationType} that is on this type descriptor._<p>As of Spring Framework 4.2, this method supports arbitrary levels of meta-annotations._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		if (this.annotatedElement.isEmpty()) {_			_			_			return null__		}_		return AnnotatedElementUtils.getMergedAnnotation(this.annotatedElement, annotationType)__	};obtain,the,annotation,of,the,specified,code,annotation,type,that,is,on,this,type,descriptor,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,if,this,annotated,element,is,empty,return,null,return,annotated,element,utils,get,merged,annotation,this,annotated,element,annotation,type
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1481578128;Obtain the annotation of the specified {@code annotationType} that is on this type descriptor._<p>As of Spring Framework 4.2, this method supports arbitrary levels of meta-annotations._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		if (this.annotatedElement.isEmpty()) {_			_			_			return null__		}_		return AnnotatedElementUtils.getMergedAnnotation(this.annotatedElement, annotationType)__	};obtain,the,annotation,of,the,specified,code,annotation,type,that,is,on,this,type,descriptor,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,if,this,annotated,element,is,empty,return,null,return,annotated,element,utils,get,merged,annotation,this,annotated,element,annotation,type
TypeDescriptor -> @SuppressWarnings("unchecked") 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1482961889;Obtain the annotation of the specified {@code annotationType} that is on this type descriptor._<p>As of Spring Framework 4.2, this method supports arbitrary levels of meta-annotations._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		if (this.annotatedElement.isEmpty()) {_			_			_			return null__		}_		return AnnotatedElementUtils.getMergedAnnotation(this.annotatedElement, annotationType)__	};obtain,the,annotation,of,the,specified,code,annotation,type,that,is,on,this,type,descriptor,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,if,this,annotated,element,is,empty,return,null,return,annotated,element,utils,get,merged,annotation,this,annotated,element,annotation,type
TypeDescriptor -> @Nullable 	public TypeDescriptor elementTypeDescriptor(Object element);1496837955;If this type is a {@link Collection} or an array, creates a element TypeDescriptor_from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class_of the provided collection or array element. For example, if this describes a_{@code java.util.List&lt_java.lang.Number&lt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}._If this describes a {@code java.util.List&lt_?&gt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}_as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a {@code java.util.Collection}_or array type_@see #narrow(Object);@Nullable_	public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,code,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,list,lt,gt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type,see,narrow,object;nullable,public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> @Nullable 	public TypeDescriptor elementTypeDescriptor(Object element);1498780456;If this type is a {@link Collection} or an array, creates a element TypeDescriptor_from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class_of the provided collection or array element. For example, if this describes a_{@code java.util.List&lt_java.lang.Number&lt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}._If this describes a {@code java.util.List&lt_?&gt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}_as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a {@code java.util.Collection}_or array type_@see #narrow(Object);@Nullable_	public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,code,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,list,lt,gt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type,see,narrow,object;nullable,public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> @Nullable 	public TypeDescriptor elementTypeDescriptor(Object element);1508084888;If this type is a {@link Collection} or an array, creates a element TypeDescriptor_from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class_of the provided collection or array element. For example, if this describes a_{@code java.util.List&lt_java.lang.Number&lt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}._If this describes a {@code java.util.List&lt_?&gt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}_as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a {@code java.util.Collection}_or array type_@see #narrow(Object);@Nullable_	public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,code,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,list,lt,gt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type,see,narrow,object;nullable,public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> @Nullable 	public TypeDescriptor elementTypeDescriptor(Object element);1522332300;If this type is a {@link Collection} or an array, creates a element TypeDescriptor_from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class_of the provided collection or array element. For example, if this describes a_{@code java.util.List&lt_java.lang.Number&lt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}._If this describes a {@code java.util.List&lt_?&gt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}_as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a {@code java.util.Collection}_or array type_@see #narrow(Object);@Nullable_	public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,code,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,list,lt,gt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type,see,narrow,object;nullable,public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> @Nullable 	public TypeDescriptor elementTypeDescriptor(Object element);1532520919;If this type is a {@link Collection} or an array, creates a element TypeDescriptor_from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class_of the provided collection or array element. For example, if this describes a_{@code java.util.List&lt_java.lang.Number&lt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}._If this describes a {@code java.util.List&lt_?&gt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}_as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a {@code java.util.Collection}_or array type_@see #narrow(Object);@Nullable_	public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,code,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,list,lt,gt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type,see,narrow,object;nullable,public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> @Nullable 	public TypeDescriptor elementTypeDescriptor(Object element);1546963887;If this type is a {@link Collection} or an array, creates a element TypeDescriptor_from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class_of the provided collection or array element. For example, if this describes a_{@code java.util.List&lt_java.lang.Number&lt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}._If this describes a {@code java.util.List&lt_?&gt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}_as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a {@code java.util.Collection}_or array type_@see #narrow(Object);@Nullable_	public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,code,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,list,lt,gt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type,see,narrow,object;nullable,public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> @Nullable 	public TypeDescriptor elementTypeDescriptor(Object element);1547033218;If this type is a {@link Collection} or an array, creates a element TypeDescriptor_from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class_of the provided collection or array element. For example, if this describes a_{@code java.util.List&lt_java.lang.Number&lt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}._If this describes a {@code java.util.List&lt_?&gt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}_as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a {@code java.util.Collection}_or array type_@see #narrow(Object);@Nullable_	public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,code,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,list,lt,gt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type,see,narrow,object;nullable,public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> @Nullable 	public TypeDescriptor getElementTypeDescriptor();1495868221;If this type is an array, returns the array's component type._If this type is a {@code Stream}, returns the stream's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns {@code null} indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a_Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;@Nullable_	public TypeDescriptor getElementTypeDescriptor() {_		if (getResolvableType().isArray()) {_			return new TypeDescriptor(getResolvableType().getComponentType(), null, getAnnotations())__		}_		if (Stream.class.isAssignableFrom(getType())) {_			return getRelatedIfResolvable(this, getResolvableType().as(Stream.class).getGeneric(0))__		}_		return getRelatedIfResolvable(this, getResolvableType().asCollection().getGeneric(0))__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,code,stream,returns,the,stream,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,code,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;nullable,public,type,descriptor,get,element,type,descriptor,if,get,resolvable,type,is,array,return,new,type,descriptor,get,resolvable,type,get,component,type,null,get,annotations,if,stream,class,is,assignable,from,get,type,return,get,related,if,resolvable,this,get,resolvable,type,as,stream,class,get,generic,0,return,get,related,if,resolvable,this,get,resolvable,type,as,collection,get,generic,0
TypeDescriptor -> @Nullable 	public TypeDescriptor getElementTypeDescriptor();1496259743;If this type is an array, returns the array's component type._If this type is a {@code Stream}, returns the stream's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns {@code null} indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a_Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;@Nullable_	public TypeDescriptor getElementTypeDescriptor() {_		if (getResolvableType().isArray()) {_			return new TypeDescriptor(getResolvableType().getComponentType(), null, getAnnotations())__		}_		if (Stream.class.isAssignableFrom(getType())) {_			return getRelatedIfResolvable(this, getResolvableType().as(Stream.class).getGeneric(0))__		}_		return getRelatedIfResolvable(this, getResolvableType().asCollection().getGeneric(0))__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,code,stream,returns,the,stream,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,code,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;nullable,public,type,descriptor,get,element,type,descriptor,if,get,resolvable,type,is,array,return,new,type,descriptor,get,resolvable,type,get,component,type,null,get,annotations,if,stream,class,is,assignable,from,get,type,return,get,related,if,resolvable,this,get,resolvable,type,as,stream,class,get,generic,0,return,get,related,if,resolvable,this,get,resolvable,type,as,collection,get,generic,0
TypeDescriptor -> @Nullable 	public TypeDescriptor getElementTypeDescriptor();1496837955;If this type is an array, returns the array's component type._If this type is a {@code Stream}, returns the stream's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns {@code null} indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a_Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;@Nullable_	public TypeDescriptor getElementTypeDescriptor() {_		if (getResolvableType().isArray()) {_			return new TypeDescriptor(getResolvableType().getComponentType(), null, getAnnotations())__		}_		if (Stream.class.isAssignableFrom(getType())) {_			return getRelatedIfResolvable(this, getResolvableType().as(Stream.class).getGeneric(0))__		}_		return getRelatedIfResolvable(this, getResolvableType().asCollection().getGeneric(0))__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,code,stream,returns,the,stream,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,code,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;nullable,public,type,descriptor,get,element,type,descriptor,if,get,resolvable,type,is,array,return,new,type,descriptor,get,resolvable,type,get,component,type,null,get,annotations,if,stream,class,is,assignable,from,get,type,return,get,related,if,resolvable,this,get,resolvable,type,as,stream,class,get,generic,0,return,get,related,if,resolvable,this,get,resolvable,type,as,collection,get,generic,0
TypeDescriptor -> @Nullable 	public TypeDescriptor getElementTypeDescriptor();1498780456;If this type is an array, returns the array's component type._If this type is a {@code Stream}, returns the stream's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns {@code null} indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a_Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;@Nullable_	public TypeDescriptor getElementTypeDescriptor() {_		if (getResolvableType().isArray()) {_			return new TypeDescriptor(getResolvableType().getComponentType(), null, getAnnotations())__		}_		if (Stream.class.isAssignableFrom(getType())) {_			return getRelatedIfResolvable(this, getResolvableType().as(Stream.class).getGeneric(0))__		}_		return getRelatedIfResolvable(this, getResolvableType().asCollection().getGeneric(0))__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,code,stream,returns,the,stream,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,code,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;nullable,public,type,descriptor,get,element,type,descriptor,if,get,resolvable,type,is,array,return,new,type,descriptor,get,resolvable,type,get,component,type,null,get,annotations,if,stream,class,is,assignable,from,get,type,return,get,related,if,resolvable,this,get,resolvable,type,as,stream,class,get,generic,0,return,get,related,if,resolvable,this,get,resolvable,type,as,collection,get,generic,0
TypeDescriptor -> @Nullable 	public TypeDescriptor getElementTypeDescriptor();1508084888;If this type is an array, returns the array's component type._If this type is a {@code Stream}, returns the stream's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns {@code null} indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a_Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;@Nullable_	public TypeDescriptor getElementTypeDescriptor() {_		if (getResolvableType().isArray()) {_			return new TypeDescriptor(getResolvableType().getComponentType(), null, getAnnotations())__		}_		if (Stream.class.isAssignableFrom(getType())) {_			return getRelatedIfResolvable(this, getResolvableType().as(Stream.class).getGeneric(0))__		}_		return getRelatedIfResolvable(this, getResolvableType().asCollection().getGeneric(0))__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,code,stream,returns,the,stream,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,code,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;nullable,public,type,descriptor,get,element,type,descriptor,if,get,resolvable,type,is,array,return,new,type,descriptor,get,resolvable,type,get,component,type,null,get,annotations,if,stream,class,is,assignable,from,get,type,return,get,related,if,resolvable,this,get,resolvable,type,as,stream,class,get,generic,0,return,get,related,if,resolvable,this,get,resolvable,type,as,collection,get,generic,0
TypeDescriptor -> @Nullable 	public TypeDescriptor getElementTypeDescriptor();1522332300;If this type is an array, returns the array's component type._If this type is a {@code Stream}, returns the stream's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns {@code null} indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a_Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;@Nullable_	public TypeDescriptor getElementTypeDescriptor() {_		if (getResolvableType().isArray()) {_			return new TypeDescriptor(getResolvableType().getComponentType(), null, getAnnotations())__		}_		if (Stream.class.isAssignableFrom(getType())) {_			return getRelatedIfResolvable(this, getResolvableType().as(Stream.class).getGeneric(0))__		}_		return getRelatedIfResolvable(this, getResolvableType().asCollection().getGeneric(0))__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,code,stream,returns,the,stream,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,code,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;nullable,public,type,descriptor,get,element,type,descriptor,if,get,resolvable,type,is,array,return,new,type,descriptor,get,resolvable,type,get,component,type,null,get,annotations,if,stream,class,is,assignable,from,get,type,return,get,related,if,resolvable,this,get,resolvable,type,as,stream,class,get,generic,0,return,get,related,if,resolvable,this,get,resolvable,type,as,collection,get,generic,0
TypeDescriptor -> @Nullable 	public TypeDescriptor getElementTypeDescriptor();1532520919;If this type is an array, returns the array's component type._If this type is a {@code Stream}, returns the stream's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns {@code null} indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a_Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;@Nullable_	public TypeDescriptor getElementTypeDescriptor() {_		if (getResolvableType().isArray()) {_			return new TypeDescriptor(getResolvableType().getComponentType(), null, getAnnotations())__		}_		if (Stream.class.isAssignableFrom(getType())) {_			return getRelatedIfResolvable(this, getResolvableType().as(Stream.class).getGeneric(0))__		}_		return getRelatedIfResolvable(this, getResolvableType().asCollection().getGeneric(0))__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,code,stream,returns,the,stream,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,code,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;nullable,public,type,descriptor,get,element,type,descriptor,if,get,resolvable,type,is,array,return,new,type,descriptor,get,resolvable,type,get,component,type,null,get,annotations,if,stream,class,is,assignable,from,get,type,return,get,related,if,resolvable,this,get,resolvable,type,as,stream,class,get,generic,0,return,get,related,if,resolvable,this,get,resolvable,type,as,collection,get,generic,0
TypeDescriptor -> @Nullable 	public TypeDescriptor getElementTypeDescriptor();1546963887;If this type is an array, returns the array's component type._If this type is a {@code Stream}, returns the stream's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns {@code null} indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a_Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;@Nullable_	public TypeDescriptor getElementTypeDescriptor() {_		if (getResolvableType().isArray()) {_			return new TypeDescriptor(getResolvableType().getComponentType(), null, getAnnotations())__		}_		if (Stream.class.isAssignableFrom(getType())) {_			return getRelatedIfResolvable(this, getResolvableType().as(Stream.class).getGeneric(0))__		}_		return getRelatedIfResolvable(this, getResolvableType().asCollection().getGeneric(0))__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,code,stream,returns,the,stream,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,code,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;nullable,public,type,descriptor,get,element,type,descriptor,if,get,resolvable,type,is,array,return,new,type,descriptor,get,resolvable,type,get,component,type,null,get,annotations,if,stream,class,is,assignable,from,get,type,return,get,related,if,resolvable,this,get,resolvable,type,as,stream,class,get,generic,0,return,get,related,if,resolvable,this,get,resolvable,type,as,collection,get,generic,0
TypeDescriptor -> @Nullable 	public TypeDescriptor getElementTypeDescriptor();1547033218;If this type is an array, returns the array's component type._If this type is a {@code Stream}, returns the stream's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns {@code null} indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a_Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;@Nullable_	public TypeDescriptor getElementTypeDescriptor() {_		if (getResolvableType().isArray()) {_			return new TypeDescriptor(getResolvableType().getComponentType(), null, getAnnotations())__		}_		if (Stream.class.isAssignableFrom(getType())) {_			return getRelatedIfResolvable(this, getResolvableType().as(Stream.class).getGeneric(0))__		}_		return getRelatedIfResolvable(this, getResolvableType().asCollection().getGeneric(0))__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,code,stream,returns,the,stream,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,code,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;nullable,public,type,descriptor,get,element,type,descriptor,if,get,resolvable,type,is,array,return,new,type,descriptor,get,resolvable,type,get,component,type,null,get,annotations,if,stream,class,is,assignable,from,get,type,return,get,related,if,resolvable,this,get,resolvable,type,as,stream,class,get,generic,0,return,get,related,if,resolvable,this,get,resolvable,type,as,collection,get,generic,0
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1328020251;Returns true if an object of this type descriptor can be assigned to the location described by the given type descriptor._For example, valueOf(String.class).isAssignableTo(valueOf(CharSequence.class)) returns true because a String value can be assigned to a CharSequence variable._On the other hand, valueOf(Number.class).isAssignableTo(valueOf(Integer.class)) returns false because, while all Integers are Numbers, not all Numbers are Integers._<p>_For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt_ field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return true if this type is assignable to the type represented by the provided type descriptor._@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,for,example,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,value,of,number,class,is,assignable,to,value,of,integer,class,returns,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1329142650;Returns true if an object of this type descriptor can be assigned to the location described by the given type descriptor._For example, valueOf(String.class).isAssignableTo(valueOf(CharSequence.class)) returns true because a String value can be assigned to a CharSequence variable._On the other hand, valueOf(Number.class).isAssignableTo(valueOf(Integer.class)) returns false because, while all Integers are Numbers, not all Numbers are Integers._<p>_For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt_ field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return true if this type is assignable to the type represented by the provided type descriptor._@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,for,example,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,value,of,number,class,is,assignable,to,value,of,integer,class,returns,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1335774711;Returns true if an object of this type descriptor can be assigned to the location described by the given type descriptor._For example, valueOf(String.class).isAssignableTo(valueOf(CharSequence.class)) returns true because a String value can be assigned to a CharSequence variable._On the other hand, valueOf(Number.class).isAssignableTo(valueOf(Integer.class)) returns false because, while all Integers are Numbers, not all Numbers are Integers._<p>_For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt_ field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return true if this type is assignable to the type represented by the provided type descriptor._@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,for,example,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,value,of,number,class,is,assignable,to,value,of,integer,class,returns,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1349907422;Returns true if an object of this type descriptor can be assigned to the location described by the given type descriptor._For example, valueOf(String.class).isAssignableTo(valueOf(CharSequence.class)) returns true because a String value can be assigned to a CharSequence variable._On the other hand, valueOf(Number.class).isAssignableTo(valueOf(Integer.class)) returns false because, while all Integers are Numbers, not all Numbers are Integers._<p>_For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt_ field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return true if this type is assignable to the type represented by the provided type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,for,example,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,value,of,number,class,is,assignable,to,value,of,integer,class,returns,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1351584957;Returns true if an object of this type descriptor can be assigned to the location described by the given type descriptor._For example, valueOf(String.class).isAssignableTo(valueOf(CharSequence.class)) returns true because a String value can be assigned to a CharSequence variable._On the other hand, valueOf(Number.class).isAssignableTo(valueOf(Integer.class)) returns false because, while all Integers are Numbers, not all Numbers are Integers._<p>_For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt_ field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return true if this type is assignable to the type represented by the provided type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,for,example,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,value,of,number,class,is,assignable,to,value,of,integer,class,returns,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1351648403;Returns true if an object of this type descriptor can be assigned to the location described by the given type descriptor._For example, valueOf(String.class).isAssignableTo(valueOf(CharSequence.class)) returns true because a String value can be assigned to a CharSequence variable._On the other hand, valueOf(Number.class).isAssignableTo(valueOf(Integer.class)) returns false because, while all Integers are Numbers, not all Numbers are Integers._<p>_For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt_ field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return true if this type is assignable to the type represented by the provided type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,for,example,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,value,of,number,class,is,assignable,to,value,of,integer,class,returns,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1356735495;Returns true if an object of this type descriptor can be assigned to the location described by the given type descriptor._For example, valueOf(String.class).isAssignableTo(valueOf(CharSequence.class)) returns true because a String value can be assigned to a CharSequence variable._On the other hand, valueOf(Number.class).isAssignableTo(valueOf(Integer.class)) returns false because, while all Integers are Numbers, not all Numbers are Integers._<p>_For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt_ field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return true if this type is assignable to the type represented by the provided type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,for,example,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,value,of,number,class,is,assignable,to,value,of,integer,class,returns,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1362408075;Returns true if an object of this type descriptor can be assigned to the location described by the given type descriptor._<p>For example, valueOf(String.class).isAssignableTo(valueOf(CharSequence.class)) returns true because a String value can be assigned to a CharSequence variable._On the other hand, valueOf(Number.class).isAssignableTo(valueOf(Integer.class)) returns false because, while all Integers are Numbers, not all Numbers are Integers._<p>_For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt_ field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return true if this type is assignable to the type represented by the provided type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,value,of,number,class,is,assignable,to,value,of,integer,class,returns,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1368482696;Returns true if an object of this type descriptor can be assigned to the location described by the given type descriptor._<p>For example, valueOf(String.class).isAssignableTo(valueOf(CharSequence.class)) returns true because a String value can be assigned to a CharSequence variable._On the other hand, valueOf(Number.class).isAssignableTo(valueOf(Integer.class)) returns false because, while all Integers are Numbers, not all Numbers are Integers._<p>_For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt_ field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return true if this type is assignable to the type represented by the provided type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,value,of,number,class,is,assignable,to,value,of,integer,class,returns,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1374614239;Returns true if an object of this type descriptor can be assigned to the location described by the given type descriptor._<p>For example, valueOf(String.class).isAssignableTo(valueOf(CharSequence.class)) returns true because a String value can be assigned to a CharSequence variable._On the other hand, valueOf(Number.class).isAssignableTo(valueOf(Integer.class)) returns false because, while all Integers are Numbers, not all Numbers are Integers._<p>_For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt_ field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return true if this type is assignable to the type represented by the provided type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,value,of,number,class,is,assignable,to,value,of,integer,class,returns,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1382042882;Returns true if an object of this type descriptor can be assigned to the location described by the given type descriptor._<p>For example, valueOf(String.class).isAssignableTo(valueOf(CharSequence.class)) returns true because a String value can be assigned to a CharSequence variable._On the other hand, valueOf(Number.class).isAssignableTo(valueOf(Integer.class)) returns false because, while all Integers are Numbers, not all Numbers are Integers._<p>_For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt_ field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return true if this type is assignable to the type represented by the provided type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,value,of,number,class,is,assignable,to,value,of,integer,class,returns,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1382119085;Returns true if an object of this type descriptor can be assigned to the location described by the given type descriptor._<p>For example, valueOf(String.class).isAssignableTo(valueOf(CharSequence.class)) returns true because a String value can be assigned to a CharSequence variable._On the other hand, valueOf(Number.class).isAssignableTo(valueOf(Integer.class)) returns false because, while all Integers are Numbers, not all Numbers are Integers._<p>_For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt_ field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return true if this type is assignable to the type represented by the provided type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,value,of,number,class,is,assignable,to,value,of,integer,class,returns,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1382750081;Returns true if an object of this type descriptor can be assigned to the location described by the given type descriptor._<p>For example, valueOf(String.class).isAssignableTo(valueOf(CharSequence.class)) returns true because a String value can be assigned to a CharSequence variable._On the other hand, valueOf(Number.class).isAssignableTo(valueOf(Integer.class)) returns false because, while all Integers are Numbers, not all Numbers are Integers._<p>_For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt_ field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return true if this type is assignable to the type represented by the provided type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,value,of,number,class,is,assignable,to,value,of,integer,class,returns,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1387307647;Returns true if an object of this type descriptor can be assigned to the location described by the given type descriptor._<p>For example, valueOf(String.class).isAssignableTo(valueOf(CharSequence.class)) returns true because a String value can be assigned to a CharSequence variable._On the other hand, valueOf(Number.class).isAssignableTo(valueOf(Integer.class)) returns false because, while all Integers are Numbers, not all Numbers are Integers._<p>_For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt_ field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return true if this type is assignable to the type represented by the provided type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,value,of,number,class,is,assignable,to,value,of,integer,class,returns,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1387490898;Returns true if an object of this type descriptor can be assigned to the location described by the given type descriptor._<p>For example, valueOf(String.class).isAssignableTo(valueOf(CharSequence.class)) returns true because a String value can be assigned to a CharSequence variable._On the other hand, valueOf(Number.class).isAssignableTo(valueOf(Integer.class)) returns false because, while all Integers are Numbers, not all Numbers are Integers._<p>_For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt_ field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return true if this type is assignable to the type represented by the provided type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,value,of,number,class,is,assignable,to,value,of,integer,class,returns,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1389985540;Returns true if an object of this type descriptor can be assigned to the location described by the given type descriptor._<p>For example, valueOf(String.class).isAssignableTo(valueOf(CharSequence.class)) returns true because a String value can be assigned to a CharSequence variable._On the other hand, valueOf(Number.class).isAssignableTo(valueOf(Integer.class)) returns false because, while all Integers are Numbers, not all Numbers are Integers._<p>_For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt_ field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return true if this type is assignable to the type represented by the provided type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,value,of,number,class,is,assignable,to,value,of,integer,class,returns,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1390565795;Returns true if an object of this type descriptor can be assigned to the location described by the given type descriptor._<p>For example, valueOf(String.class).isAssignableTo(valueOf(CharSequence.class)) returns true because a String value can be assigned to a CharSequence variable._On the other hand, valueOf(Number.class).isAssignableTo(valueOf(Integer.class)) returns false because, while all Integers are Numbers, not all Numbers are Integers._<p>_For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt_ field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return true if this type is assignable to the type represented by the provided type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,value,of,number,class,is,assignable,to,value,of,integer,class,returns,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1390925810;Returns true if an object of this type descriptor can be assigned to the location described by the given type descriptor._<p>For example, valueOf(String.class).isAssignableTo(valueOf(CharSequence.class)) returns true because a String value can be assigned to a CharSequence variable._On the other hand, valueOf(Number.class).isAssignableTo(valueOf(Integer.class)) returns false because, while all Integers are Numbers, not all Numbers are Integers._<p>_For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt_ field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return true if this type is assignable to the type represented by the provided type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,value,of,number,class,is,assignable,to,value,of,integer,class,returns,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1391081201;Returns true if an object of this type descriptor can be assigned to the location described by the given type descriptor._<p>For example, valueOf(String.class).isAssignableTo(valueOf(CharSequence.class)) returns true because a String value can be assigned to a CharSequence variable._On the other hand, valueOf(Number.class).isAssignableTo(valueOf(Integer.class)) returns false because, while all Integers are Numbers, not all Numbers are Integers._<p>_For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt_ field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return true if this type is assignable to the type represented by the provided type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,value,of,number,class,is,assignable,to,value,of,integer,class,returns,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1391248381;Returns true if an object of this type descriptor can be assigned to the location described by the given type descriptor._<p>For example, valueOf(String.class).isAssignableTo(valueOf(CharSequence.class)) returns true because a String value can be assigned to a CharSequence variable._On the other hand, valueOf(Number.class).isAssignableTo(valueOf(Integer.class)) returns false because, while all Integers are Numbers, not all Numbers are Integers._<p>_For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt_ field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return true if this type is assignable to the type represented by the provided type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,value,of,number,class,is,assignable,to,value,of,integer,class,returns,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1394055372;Returns true if an object of this type descriptor can be assigned to the location_described by the given type descriptor._<p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}_returns {@code true} because a String value can be assigned to a CharSequence variable._On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}_returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers._<p>For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt__field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return {@code true} if this type is assignable to the type represented by the provided_type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,code,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,code,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,code,value,of,number,class,is,assignable,to,value,of,integer,class,returns,code,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,code,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1395846555;Returns true if an object of this type descriptor can be assigned to the location_described by the given type descriptor._<p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}_returns {@code true} because a String value can be assigned to a CharSequence variable._On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}_returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers._<p>For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt__field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return {@code true} if this type is assignable to the type represented by the provided_type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,code,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,code,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,code,value,of,number,class,is,assignable,to,value,of,integer,class,returns,code,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,code,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1403636229;Returns true if an object of this type descriptor can be assigned to the location_described by the given type descriptor._<p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}_returns {@code true} because a String value can be assigned to a CharSequence variable._On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}_returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers._<p>For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt__field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return {@code true} if this type is assignable to the type represented by the provided_type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,code,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,code,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,code,value,of,number,class,is,assignable,to,value,of,integer,class,returns,code,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,code,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1405430015;Returns true if an object of this type descriptor can be assigned to the location_described by the given type descriptor._<p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}_returns {@code true} because a String value can be assigned to a CharSequence variable._On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}_returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers._<p>For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt__field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return {@code true} if this type is assignable to the type represented by the provided_type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,code,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,code,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,code,value,of,number,class,is,assignable,to,value,of,integer,class,returns,code,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,code,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1406196817;Returns true if an object of this type descriptor can be assigned to the location_described by the given type descriptor._<p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}_returns {@code true} because a String value can be assigned to a CharSequence variable._On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}_returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers._<p>For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt__field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return {@code true} if this type is assignable to the type represented by the provided_type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,code,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,code,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,code,value,of,number,class,is,assignable,to,value,of,integer,class,returns,code,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,code,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1412611699;Returns true if an object of this type descriptor can be assigned to the location_described by the given type descriptor._<p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}_returns {@code true} because a String value can be assigned to a CharSequence variable._On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}_returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers._<p>For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt__field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return {@code true} if this type is assignable to the type represented by the provided_type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,code,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,code,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,code,value,of,number,class,is,assignable,to,value,of,integer,class,returns,code,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,code,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1414925289;Returns true if an object of this type descriptor can be assigned to the location_described by the given type descriptor._<p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}_returns {@code true} because a String value can be assigned to a CharSequence variable._On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}_returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers._<p>For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt__field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return {@code true} if this type is assignable to the type represented by the provided_type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,code,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,code,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,code,value,of,number,class,is,assignable,to,value,of,integer,class,returns,code,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,code,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1417290561;Returns true if an object of this type descriptor can be assigned to the location_described by the given type descriptor._<p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}_returns {@code true} because a String value can be assigned to a CharSequence variable._On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}_returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers._<p>For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt__field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return {@code true} if this type is assignable to the type represented by the provided_type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,code,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,code,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,code,value,of,number,class,is,assignable,to,value,of,integer,class,returns,code,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,code,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1419966315;Returns true if an object of this type descriptor can be assigned to the location_described by the given type descriptor._<p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}_returns {@code true} because a String value can be assigned to a CharSequence variable._On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}_returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers._<p>For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt__field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return {@code true} if this type is assignable to the type represented by the provided_type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,code,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,code,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,code,value,of,number,class,is,assignable,to,value,of,integer,class,returns,code,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,code,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1424769447;Returns true if an object of this type descriptor can be assigned to the location_described by the given type descriptor._<p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}_returns {@code true} because a String value can be assigned to a CharSequence variable._On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}_returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers._<p>For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt__field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return {@code true} if this type is assignable to the type represented by the provided_type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,code,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,code,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,code,value,of,number,class,is,assignable,to,value,of,integer,class,returns,code,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,code,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1424887506;Returns true if an object of this type descriptor can be assigned to the location_described by the given type descriptor._<p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}_returns {@code true} because a String value can be assigned to a CharSequence variable._On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}_returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers._<p>For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt__field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return {@code true} if this type is assignable to the type represented by the provided_type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,code,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,code,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,code,value,of,number,class,is,assignable,to,value,of,integer,class,returns,code,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,code,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1425763631;Returns true if an object of this type descriptor can be assigned to the location_described by the given type descriptor._<p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}_returns {@code true} because a String value can be assigned to a CharSequence variable._On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}_returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers._<p>For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt__field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return {@code true} if this type is assignable to the type represented by the provided_type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,code,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,code,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,code,value,of,number,class,is,assignable,to,value,of,integer,class,returns,code,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,code,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1431093918;Returns true if an object of this type descriptor can be assigned to the location_described by the given type descriptor._<p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}_returns {@code true} because a String value can be assigned to a CharSequence variable._On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}_returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers._<p>For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt__field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return {@code true} if this type is assignable to the type represented by the provided_type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,code,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,code,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,code,value,of,number,class,is,assignable,to,value,of,integer,class,returns,code,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,code,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1432125256;Returns true if an object of this type descriptor can be assigned to the location_described by the given type descriptor._<p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}_returns {@code true} because a String value can be assigned to a CharSequence variable._On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}_returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers._<p>For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt__field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return {@code true} if this type is assignable to the type represented by the provided_type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,code,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,code,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,code,value,of,number,class,is,assignable,to,value,of,integer,class,returns,code,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,code,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1441035153;Returns true if an object of this type descriptor can be assigned to the location_described by the given type descriptor._<p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}_returns {@code true} because a String value can be assigned to a CharSequence variable._On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}_returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers._<p>For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt__field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return {@code true} if this type is assignable to the type represented by the provided_type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,code,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,code,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,code,value,of,number,class,is,assignable,to,value,of,integer,class,returns,code,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,code,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1448383050;Returns true if an object of this type descriptor can be assigned to the location_described by the given type descriptor._<p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}_returns {@code true} because a String value can be assigned to a CharSequence variable._On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}_returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers._<p>For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt__field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return {@code true} if this type is assignable to the type represented by the provided_type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,code,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,code,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,code,value,of,number,class,is,assignable,to,value,of,integer,class,returns,code,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,code,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1450473050;Returns true if an object of this type descriptor can be assigned to the location_described by the given type descriptor._<p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}_returns {@code true} because a String value can be assigned to a CharSequence variable._On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}_returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers._<p>For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt__field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return {@code true} if this type is assignable to the type represented by the provided_type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,code,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,code,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,code,value,of,number,class,is,assignable,to,value,of,integer,class,returns,code,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,code,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1467288171;Returns true if an object of this type descriptor can be assigned to the location_described by the given type descriptor._<p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}_returns {@code true} because a String value can be assigned to a CharSequence variable._On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}_returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers._<p>For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt__field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return {@code true} if this type is assignable to the type represented by the provided_type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,code,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,code,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,code,value,of,number,class,is,assignable,to,value,of,integer,class,returns,code,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,code,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1467677340;Returns true if an object of this type descriptor can be assigned to the location_described by the given type descriptor._<p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}_returns {@code true} because a String value can be assigned to a CharSequence variable._On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}_returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers._<p>For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt__field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return {@code true} if this type is assignable to the type represented by the provided_type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,code,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,code,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,code,value,of,number,class,is,assignable,to,value,of,integer,class,returns,code,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,code,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1467730834;Returns true if an object of this type descriptor can be assigned to the location_described by the given type descriptor._<p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}_returns {@code true} because a String value can be assigned to a CharSequence variable._On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}_returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers._<p>For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt__field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return {@code true} if this type is assignable to the type represented by the provided_type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,code,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,code,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,code,value,of,number,class,is,assignable,to,value,of,integer,class,returns,code,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,code,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1477690406;Returns true if an object of this type descriptor can be assigned to the location_described by the given type descriptor._<p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}_returns {@code true} because a String value can be assigned to a CharSequence variable._On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}_returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers._<p>For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt__field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return {@code true} if this type is assignable to the type represented by the provided_type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,code,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,code,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,code,value,of,number,class,is,assignable,to,value,of,integer,class,returns,code,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,code,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1478094883;Returns true if an object of this type descriptor can be assigned to the location_described by the given type descriptor._<p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}_returns {@code true} because a String value can be assigned to a CharSequence variable._On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}_returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers._<p>For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt__field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return {@code true} if this type is assignable to the type represented by the provided_type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,code,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,code,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,code,value,of,number,class,is,assignable,to,value,of,integer,class,returns,code,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,code,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1479823020;Returns true if an object of this type descriptor can be assigned to the location_described by the given type descriptor._<p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}_returns {@code true} because a String value can be assigned to a CharSequence variable._On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}_returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers._<p>For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt__field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return {@code true} if this type is assignable to the type represented by the provided_type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,code,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,code,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,code,value,of,number,class,is,assignable,to,value,of,integer,class,returns,code,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,code,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1479900301;Returns true if an object of this type descriptor can be assigned to the location_described by the given type descriptor._<p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}_returns {@code true} because a String value can be assigned to a CharSequence variable._On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}_returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers._<p>For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt__field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return {@code true} if this type is assignable to the type represented by the provided_type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,code,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,code,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,code,value,of,number,class,is,assignable,to,value,of,integer,class,returns,code,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,code,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1480540964;Returns true if an object of this type descriptor can be assigned to the location_described by the given type descriptor._<p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}_returns {@code true} because a String value can be assigned to a CharSequence variable._On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}_returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers._<p>For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt__field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return {@code true} if this type is assignable to the type represented by the provided_type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,code,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,code,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,code,value,of,number,class,is,assignable,to,value,of,integer,class,returns,code,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,code,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1481578128;Returns true if an object of this type descriptor can be assigned to the location_described by the given type descriptor._<p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}_returns {@code true} because a String value can be assigned to a CharSequence variable._On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}_returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers._<p>For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt__field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return {@code true} if this type is assignable to the type represented by the provided_type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,code,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,code,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,code,value,of,number,class,is,assignable,to,value,of,integer,class,returns,code,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,code,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1482961889;Returns true if an object of this type descriptor can be assigned to the location_described by the given type descriptor._<p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}_returns {@code true} because a String value can be assigned to a CharSequence variable._On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}_returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers._<p>For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt__field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return {@code true} if this type is assignable to the type represented by the provided_type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,code,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,code,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,code,value,of,number,class,is,assignable,to,value,of,integer,class,returns,code,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,code,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1495868221;Returns true if an object of this type descriptor can be assigned to the location_described by the given type descriptor._<p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}_returns {@code true} because a String value can be assigned to a CharSequence variable._On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}_returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers._<p>For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt__field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return {@code true} if this type is assignable to the type represented by the provided_type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,code,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,code,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,code,value,of,number,class,is,assignable,to,value,of,integer,class,returns,code,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,code,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1496259743;Returns true if an object of this type descriptor can be assigned to the location_described by the given type descriptor._<p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}_returns {@code true} because a String value can be assigned to a CharSequence variable._On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}_returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers._<p>For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt__field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return {@code true} if this type is assignable to the type represented by the provided_type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return getElementTypeDescriptor().isAssignableTo(typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,code,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,code,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,code,value,of,number,class,is,assignable,to,value,of,integer,class,returns,code,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,code,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,get,element,type,descriptor,is,assignable,to,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1496837955;Returns true if an object of this type descriptor can be assigned to the location_described by the given type descriptor._<p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}_returns {@code true} because a String value can be assigned to a CharSequence variable._On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}_returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers._<p>For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt__field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return {@code true} if this type is assignable to the type represented by the provided_type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,code,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,code,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,code,value,of,number,class,is,assignable,to,value,of,integer,class,returns,code,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,code,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1498780456;Returns true if an object of this type descriptor can be assigned to the location_described by the given type descriptor._<p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}_returns {@code true} because a String value can be assigned to a CharSequence variable._On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}_returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers._<p>For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt__field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return {@code true} if this type is assignable to the type represented by the provided_type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,code,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,code,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,code,value,of,number,class,is,assignable,to,value,of,integer,class,returns,code,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,code,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1508084888;Returns true if an object of this type descriptor can be assigned to the location_described by the given type descriptor._<p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}_returns {@code true} because a String value can be assigned to a CharSequence variable._On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}_returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers._<p>For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt__field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return {@code true} if this type is assignable to the type represented by the provided_type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,code,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,code,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,code,value,of,number,class,is,assignable,to,value,of,integer,class,returns,code,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,code,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1522332300;Returns true if an object of this type descriptor can be assigned to the location_described by the given type descriptor._<p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}_returns {@code true} because a String value can be assigned to a CharSequence variable._On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}_returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers._<p>For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt__field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return {@code true} if this type is assignable to the type represented by the provided_type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,code,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,code,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,code,value,of,number,class,is,assignable,to,value,of,integer,class,returns,code,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,code,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1532520919;Returns true if an object of this type descriptor can be assigned to the location_described by the given type descriptor._<p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}_returns {@code true} because a String value can be assigned to a CharSequence variable._On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}_returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers._<p>For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt__field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return {@code true} if this type is assignable to the type represented by the provided_type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,code,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,code,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,code,value,of,number,class,is,assignable,to,value,of,integer,class,returns,code,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,code,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1546963887;Returns true if an object of this type descriptor can be assigned to the location_described by the given type descriptor._<p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}_returns {@code true} because a String value can be assigned to a CharSequence variable._On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}_returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers._<p>For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt__field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return {@code true} if this type is assignable to the type represented by the provided_type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,code,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,code,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,code,value,of,number,class,is,assignable,to,value,of,integer,class,returns,code,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,code,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public boolean isAssignableTo(TypeDescriptor typeDescriptor);1547033218;Returns true if an object of this type descriptor can be assigned to the location_described by the given type descriptor._<p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}_returns {@code true} because a String value can be assigned to a CharSequence variable._On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}_returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers._<p>For arrays, collections, and maps, element and key/value types are checked if declared._For example, a List&lt_String&gt_ field value is assignable to a Collection&lt_CharSequence&gt__field, but List&lt_Number&gt_ is not assignable to List&lt_Integer&gt_._@return {@code true} if this type is assignable to the type represented by the provided_type descriptor_@see #getObjectType();public boolean isAssignableTo(TypeDescriptor typeDescriptor) {_		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType())__		if (!typesAssignable) {_			return false__		}_		if (isArray() && typeDescriptor.isArray()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isCollection() && typeDescriptor.isCollection()) {_			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor())__		}_		else if (isMap() && typeDescriptor.isMap()) {_			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&_				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor())__		}_		else {_			return true__		}_	};returns,true,if,an,object,of,this,type,descriptor,can,be,assigned,to,the,location,described,by,the,given,type,descriptor,p,for,example,code,value,of,string,class,is,assignable,to,value,of,char,sequence,class,returns,code,true,because,a,string,value,can,be,assigned,to,a,char,sequence,variable,on,the,other,hand,code,value,of,number,class,is,assignable,to,value,of,integer,class,returns,code,false,because,while,all,integers,are,numbers,not,all,numbers,are,integers,p,for,arrays,collections,and,maps,element,and,key,value,types,are,checked,if,declared,for,example,a,list,lt,string,gt,field,value,is,assignable,to,a,collection,lt,char,sequence,gt,field,but,list,lt,number,gt,is,not,assignable,to,list,lt,integer,gt,return,code,true,if,this,type,is,assignable,to,the,type,represented,by,the,provided,type,descriptor,see,get,object,type;public,boolean,is,assignable,to,type,descriptor,type,descriptor,boolean,types,assignable,type,descriptor,get,object,type,is,assignable,from,get,object,type,if,types,assignable,return,false,if,is,array,type,descriptor,is,array,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,collection,type,descriptor,is,collection,return,is,nested,assignable,get,element,type,descriptor,type,descriptor,get,element,type,descriptor,else,if,is,map,type,descriptor,is,map,return,is,nested,assignable,get,map,key,type,descriptor,type,descriptor,get,map,key,type,descriptor,is,nested,assignable,get,map,value,type,descriptor,type,descriptor,get,map,value,type,descriptor,else,return,true
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1328020251;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor} from the provided map key._Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property to the class of the provided map key._For example, if this describes a java.util.Map&lt_java.lang.Number, java.lang.String&lt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.Map&lt_?, ?&gt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a java.util.Map._@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,map,lt,gt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1329142650;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor} from the provided map key._Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property to the class of the provided map key._For example, if this describes a java.util.Map&lt_java.lang.Number, java.lang.String&lt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.Map&lt_?, ?&gt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a java.util.Map._@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,map,lt,gt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1335774711;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor} from the provided map key._Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property to the class of the provided map key._For example, if this describes a java.util.Map&lt_java.lang.Number, java.lang.String&lt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.Map&lt_?, ?&gt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a java.util.Map._@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,map,lt,gt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1349907422;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor} from the provided map key._Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property to the class of the provided map key._For example, if this describes a java.util.Map&lt_java.lang.Number, java.lang.String&lt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.Map&lt_?, ?&gt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a java.util.Map_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,map,lt,gt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1351584957;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor} from the provided map key._Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property to the class of the provided map key._For example, if this describes a java.util.Map&lt_java.lang.Number, java.lang.String&lt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.Map&lt_?, ?&gt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a java.util.Map_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,map,lt,gt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1351648403;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor} from the provided map key._Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property to the class of the provided map key._For example, if this describes a java.util.Map&lt_java.lang.Number, java.lang.String&lt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.Map&lt_?, ?&gt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a java.util.Map_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,map,lt,gt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1356735495;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor} from the provided map key._Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property to the class of the provided map key._For example, if this describes a java.util.Map&lt_java.lang.Number, java.lang.String&lt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.Map&lt_?, ?&gt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a java.util.Map_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,map,lt,gt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1362408075;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor} from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property to the class of the provided map key._For example, if this describes a java.util.Map&lt_java.lang.Number, java.lang.String&lt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._<p>If this describes a java.util.Map&lt_?, ?&gt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a java.util.Map_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,p,if,this,describes,a,java,util,map,lt,gt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1368482696;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor} from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property to the class of the provided map key._For example, if this describes a java.util.Map&lt_java.lang.Number, java.lang.String&lt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._<p>If this describes a java.util.Map&lt_?, ?&gt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a java.util.Map_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,p,if,this,describes,a,java,util,map,lt,gt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1374614239;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor} from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property to the class of the provided map key._For example, if this describes a java.util.Map&lt_java.lang.Number, java.lang.String&lt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._<p>If this describes a java.util.Map&lt_?, ?&gt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a java.util.Map_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,p,if,this,describes,a,java,util,map,lt,gt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1382042882;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor} from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property to the class of the provided map key._For example, if this describes a java.util.Map&lt_java.lang.Number, java.lang.String&lt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._<p>If this describes a java.util.Map&lt_?, ?&gt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a java.util.Map_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,p,if,this,describes,a,java,util,map,lt,gt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1382119085;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor} from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property to the class of the provided map key._For example, if this describes a java.util.Map&lt_java.lang.Number, java.lang.String&lt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._<p>If this describes a java.util.Map&lt_?, ?&gt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a java.util.Map_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,p,if,this,describes,a,java,util,map,lt,gt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1382750081;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor} from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property to the class of the provided map key._For example, if this describes a java.util.Map&lt_java.lang.Number, java.lang.String&lt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._<p>If this describes a java.util.Map&lt_?, ?&gt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a java.util.Map_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,p,if,this,describes,a,java,util,map,lt,gt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1387307647;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor} from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property to the class of the provided map key._For example, if this describes a java.util.Map&lt_java.lang.Number, java.lang.String&lt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._<p>If this describes a java.util.Map&lt_?, ?&gt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a java.util.Map_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,p,if,this,describes,a,java,util,map,lt,gt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1387490898;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor} from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property to the class of the provided map key._For example, if this describes a java.util.Map&lt_java.lang.Number, java.lang.String&lt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._<p>If this describes a java.util.Map&lt_?, ?&gt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a java.util.Map_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,p,if,this,describes,a,java,util,map,lt,gt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1389985540;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor} from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property to the class of the provided map key._For example, if this describes a java.util.Map&lt_java.lang.Number, java.lang.String&lt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._<p>If this describes a java.util.Map&lt_?, ?&gt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a java.util.Map_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,p,if,this,describes,a,java,util,map,lt,gt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1390565795;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor} from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property to the class of the provided map key._For example, if this describes a java.util.Map&lt_java.lang.Number, java.lang.String&lt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._<p>If this describes a java.util.Map&lt_?, ?&gt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a java.util.Map_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,p,if,this,describes,a,java,util,map,lt,gt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1390925810;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor} from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property to the class of the provided map key._For example, if this describes a java.util.Map&lt_java.lang.Number, java.lang.String&lt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._<p>If this describes a java.util.Map&lt_?, ?&gt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a java.util.Map_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,p,if,this,describes,a,java,util,map,lt,gt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1391081201;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor} from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property to the class of the provided map key._For example, if this describes a java.util.Map&lt_java.lang.Number, java.lang.String&lt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._<p>If this describes a java.util.Map&lt_?, ?&gt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a java.util.Map_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,p,if,this,describes,a,java,util,map,lt,gt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1391248381;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor} from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property to the class of the provided map key._For example, if this describes a java.util.Map&lt_java.lang.Number, java.lang.String&lt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._<p>If this describes a java.util.Map&lt_?, ?&gt_ and the key argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a java.util.Map_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,p,if,this,describes,a,java,util,map,lt,gt,and,the,key,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1394055372;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}_from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property_to the class of the provided map key. For example, if this describes a_{@code java.util.Map&lt_java.lang.Number, java.lang.String&lt_} and the key_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the key argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1395846555;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}_from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property_to the class of the provided map key. For example, if this describes a_{@code java.util.Map&lt_java.lang.Number, java.lang.String&lt_} and the key_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the key argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1403636229;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}_from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property_to the class of the provided map key. For example, if this describes a_{@code java.util.Map&lt_java.lang.Number, java.lang.String&lt_} and the key_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the key argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1405430015;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}_from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property_to the class of the provided map key. For example, if this describes a_{@code java.util.Map&lt_java.lang.Number, java.lang.String&lt_} and the key_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the key argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1406196817;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}_from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property_to the class of the provided map key. For example, if this describes a_{@code java.util.Map&lt_java.lang.Number, java.lang.String&lt_} and the key_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the key argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1412611699;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}_from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property_to the class of the provided map key. For example, if this describes a_{@code java.util.Map&lt_java.lang.Number, java.lang.String&lt_} and the key_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the key argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1414925289;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}_from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property_to the class of the provided map key. For example, if this describes a_{@code java.util.Map&lt_java.lang.Number, java.lang.String&lt_} and the key_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the key argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1417290561;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}_from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property_to the class of the provided map key. For example, if this describes a_{@code java.util.Map&lt_java.lang.Number, java.lang.String&lt_} and the key_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the key argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1419966315;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}_from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property_to the class of the provided map key. For example, if this describes a_{@code java.util.Map&lt_java.lang.Number, java.lang.String&lt_} and the key_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the key argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1424769447;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}_from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property_to the class of the provided map key. For example, if this describes a_{@code java.util.Map&lt_java.lang.Number, java.lang.String&lt_} and the key_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the key argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1424887506;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}_from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property_to the class of the provided map key. For example, if this describes a_{@code java.util.Map&lt_java.lang.Number, java.lang.String&lt_} and the key_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the key argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1425763631;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}_from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property_to the class of the provided map key. For example, if this describes a_{@code java.util.Map&lt_java.lang.Number, java.lang.String&lt_} and the key_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the key argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1431093918;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}_from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property_to the class of the provided map key. For example, if this describes a_{@code java.util.Map&lt_java.lang.Number, java.lang.String&lt_} and the key_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the key argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1432125256;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}_from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property_to the class of the provided map key. For example, if this describes a_{@code java.util.Map&lt_java.lang.Number, java.lang.String&lt_} and the key_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the key argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1441035153;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}_from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property_to the class of the provided map key. For example, if this describes a_{@code java.util.Map&lt_java.lang.Number, java.lang.String&lt_} and the key_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the key argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1448383050;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}_from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property_to the class of the provided map key. For example, if this describes a_{@code java.util.Map&lt_java.lang.Number, java.lang.String&lt_} and the key_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the key argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1450473050;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}_from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property_to the class of the provided map key. For example, if this describes a_{@code java.util.Map&lt_java.lang.Number, java.lang.String&lt_} and the key_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the key argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1467288171;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}_from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property_to the class of the provided map key. For example, if this describes a_{@code java.util.Map&lt_java.lang.Number, java.lang.String&lt_} and the key_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the key argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1467677340;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}_from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property_to the class of the provided map key. For example, if this describes a_{@code java.util.Map&lt_java.lang.Number, java.lang.String&lt_} and the key_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the key argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1467730834;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}_from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property_to the class of the provided map key. For example, if this describes a_{@code java.util.Map&lt_java.lang.Number, java.lang.String&lt_} and the key_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the key argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1477690406;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}_from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property_to the class of the provided map key. For example, if this describes a_{@code java.util.Map&lt_java.lang.Number, java.lang.String&lt_} and the key_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the key argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1478094883;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}_from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property_to the class of the provided map key. For example, if this describes a_{@code java.util.Map&lt_java.lang.Number, java.lang.String&lt_} and the key_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the key argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1479823020;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}_from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property_to the class of the provided map key. For example, if this describes a_{@code java.util.Map&lt_java.lang.Number, java.lang.String&lt_} and the key_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the key argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1479900301;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}_from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property_to the class of the provided map key. For example, if this describes a_{@code java.util.Map&lt_java.lang.Number, java.lang.String&lt_} and the key_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the key argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1480540964;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}_from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property_to the class of the provided map key. For example, if this describes a_{@code java.util.Map&lt_java.lang.Number, java.lang.String&lt_} and the key_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the key argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1481578128;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}_from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property_to the class of the provided map key. For example, if this describes a_{@code java.util.Map&lt_java.lang.Number, java.lang.String&lt_} and the key_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the key argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1482961889;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}_from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property_to the class of the provided map key. For example, if this describes a_{@code java.util.Map&lt_java.lang.Number, java.lang.String&lt_} and the key_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the key argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1495868221;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}_from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property_to the class of the provided map key. For example, if this describes a_{@code java.util.Map&lt_java.lang.Number, java.lang.String&lt_} and the key_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the key argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1496259743;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}_from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property_to the class of the provided map key. For example, if this describes a_{@code java.util.Map&lt_java.lang.Number, java.lang.String&lt_} and the key_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the key argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public boolean isMap();1328020251;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1329142650;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1335774711;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1349907422;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1351584957;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1351648403;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1356735495;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1362408075;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1368482696;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1374614239;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1382042882;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1382119085;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1382750081;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1387307647;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1387490898;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1389985540;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1390565795;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1390925810;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1391081201;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1391248381;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1394055372;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1395846555;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1403636229;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1405430015;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1406196817;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1412611699;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1414925289;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1417290561;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1419966315;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1424769447;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1424887506;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1425763631;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1431093918;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1432125256;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1441035153;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1448383050;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1450473050;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1467288171;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1467677340;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1467730834;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1477690406;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1478094883;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1479823020;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1479900301;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1480540964;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1481578128;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1482961889;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1495868221;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1496259743;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1496837955;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1498780456;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1508084888;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1522332300;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1532520919;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1546963887;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isMap();1547033218;Is this type a {@link Map} type?;public boolean isMap() {_		return Map.class.isAssignableFrom(getType())__	};is,this,type,a,link,map,type;public,boolean,is,map,return,map,class,is,assignable,from,get,type
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1349907422;Determine if this type descriptor has the specified annotation._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return getAnnotation(annotationType) != null__	};determine,if,this,type,descriptor,has,the,specified,annotation,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,get,annotation,annotation,type,null
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1351584957;Determine if this type descriptor has the specified annotation._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return getAnnotation(annotationType) != null__	};determine,if,this,type,descriptor,has,the,specified,annotation,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,get,annotation,annotation,type,null
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1351648403;Determine if this type descriptor has the specified annotation._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return getAnnotation(annotationType) != null__	};determine,if,this,type,descriptor,has,the,specified,annotation,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,get,annotation,annotation,type,null
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1356735495;Determine if this type descriptor has the specified annotation._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return getAnnotation(annotationType) != null__	};determine,if,this,type,descriptor,has,the,specified,annotation,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,get,annotation,annotation,type,null
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1362408075;Determine if this type descriptor has the specified annotation._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return getAnnotation(annotationType) != null__	};determine,if,this,type,descriptor,has,the,specified,annotation,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,get,annotation,annotation,type,null
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1368482696;Determine if this type descriptor has the specified annotation._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return getAnnotation(annotationType) != null__	};determine,if,this,type,descriptor,has,the,specified,annotation,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,get,annotation,annotation,type,null
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1374614239;Determine if this type descriptor has the specified annotation._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return getAnnotation(annotationType) != null__	};determine,if,this,type,descriptor,has,the,specified,annotation,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,get,annotation,annotation,type,null
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1382042882;Determine if this type descriptor has the specified annotation._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return getAnnotation(annotationType) != null__	};determine,if,this,type,descriptor,has,the,specified,annotation,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,get,annotation,annotation,type,null
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1382119085;Determine if this type descriptor has the specified annotation._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return getAnnotation(annotationType) != null__	};determine,if,this,type,descriptor,has,the,specified,annotation,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,get,annotation,annotation,type,null
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1382750081;Determine if this type descriptor has the specified annotation._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return getAnnotation(annotationType) != null__	};determine,if,this,type,descriptor,has,the,specified,annotation,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,get,annotation,annotation,type,null
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1387307647;Determine if this type descriptor has the specified annotation._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return getAnnotation(annotationType) != null__	};determine,if,this,type,descriptor,has,the,specified,annotation,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,get,annotation,annotation,type,null
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1387490898;Determine if this type descriptor has the specified annotation._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return getAnnotation(annotationType) != null__	};determine,if,this,type,descriptor,has,the,specified,annotation,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,get,annotation,annotation,type,null
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1389985540;Determine if this type descriptor has the specified annotation._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return getAnnotation(annotationType) != null__	};determine,if,this,type,descriptor,has,the,specified,annotation,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,get,annotation,annotation,type,null
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1390565795;Determine if this type descriptor has the specified annotation._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return getAnnotation(annotationType) != null__	};determine,if,this,type,descriptor,has,the,specified,annotation,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,get,annotation,annotation,type,null
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1390925810;Determine if this type descriptor has the specified annotation._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return getAnnotation(annotationType) != null__	};determine,if,this,type,descriptor,has,the,specified,annotation,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,get,annotation,annotation,type,null
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1391081201;Determine if this type descriptor has the specified annotation._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return getAnnotation(annotationType) != null__	};determine,if,this,type,descriptor,has,the,specified,annotation,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,get,annotation,annotation,type,null
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1391248381;Determine if this type descriptor has the specified annotation._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return getAnnotation(annotationType) != null__	};determine,if,this,type,descriptor,has,the,specified,annotation,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,get,annotation,annotation,type,null
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1394055372;Determine if this type descriptor has the specified annotation._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return getAnnotation(annotationType) != null__	};determine,if,this,type,descriptor,has,the,specified,annotation,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,get,annotation,annotation,type,null
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1395846555;Determine if this type descriptor has the specified annotation._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return getAnnotation(annotationType) != null__	};determine,if,this,type,descriptor,has,the,specified,annotation,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,get,annotation,annotation,type,null
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1403636229;Determine if this type descriptor has the specified annotation._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return getAnnotation(annotationType) != null__	};determine,if,this,type,descriptor,has,the,specified,annotation,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,get,annotation,annotation,type,null
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1405430015;Determine if this type descriptor has the specified annotation._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return (getAnnotation(annotationType) != null)__	};determine,if,this,type,descriptor,has,the,specified,annotation,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,get,annotation,annotation,type,null
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1406196817;Determine if this type descriptor has the specified annotation._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return (getAnnotation(annotationType) != null)__	};determine,if,this,type,descriptor,has,the,specified,annotation,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,get,annotation,annotation,type,null
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1412611699;Determine if this type descriptor has the specified annotation._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return (getAnnotation(annotationType) != null)__	};determine,if,this,type,descriptor,has,the,specified,annotation,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,get,annotation,annotation,type,null
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1414925289;Determine if this type descriptor has the specified annotation._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return (getAnnotation(annotationType) != null)__	};determine,if,this,type,descriptor,has,the,specified,annotation,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,get,annotation,annotation,type,null
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1417290561;Determine if this type descriptor has the specified annotation._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return (getAnnotation(annotationType) != null)__	};determine,if,this,type,descriptor,has,the,specified,annotation,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,get,annotation,annotation,type,null
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1419966315;Determine if this type descriptor has the specified annotation._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return (getAnnotation(annotationType) != null)__	};determine,if,this,type,descriptor,has,the,specified,annotation,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,get,annotation,annotation,type,null
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1424769447;Determine if this type descriptor has the specified annotation._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return (getAnnotation(annotationType) != null)__	};determine,if,this,type,descriptor,has,the,specified,annotation,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,get,annotation,annotation,type,null
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1424887506;Determine if this type descriptor has the specified annotation._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return (getAnnotation(annotationType) != null)__	};determine,if,this,type,descriptor,has,the,specified,annotation,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,get,annotation,annotation,type,null
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1425763631;Determine if this type descriptor has the specified annotation._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return (getAnnotation(annotationType) != null)__	};determine,if,this,type,descriptor,has,the,specified,annotation,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,get,annotation,annotation,type,null
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1431093918;Determine if this type descriptor has the specified annotation._<p>As of Spring Framework 4.2, this method supports arbitrary levels_of meta-annotations._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return (getAnnotation(annotationType) != null)__	};determine,if,this,type,descriptor,has,the,specified,annotation,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,get,annotation,annotation,type,null
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1432125256;Determine if this type descriptor has the specified annotation._<p>As of Spring Framework 4.2, this method supports arbitrary levels_of meta-annotations._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return (getAnnotation(annotationType) != null)__	};determine,if,this,type,descriptor,has,the,specified,annotation,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,get,annotation,annotation,type,null
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1441035153;Determine if this type descriptor has the specified annotation._<p>As of Spring Framework 4.2, this method supports arbitrary levels_of meta-annotations._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return (getAnnotation(annotationType) != null)__	};determine,if,this,type,descriptor,has,the,specified,annotation,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,get,annotation,annotation,type,null
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1448383050;Determine if this type descriptor has the specified annotation._<p>As of Spring Framework 4.2, this method supports arbitrary levels_of meta-annotations._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return (getAnnotation(annotationType) != null)__	};determine,if,this,type,descriptor,has,the,specified,annotation,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,get,annotation,annotation,type,null
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1450473050;Determine if this type descriptor has the specified annotation._<p>As of Spring Framework 4.2, this method supports arbitrary levels_of meta-annotations._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return (getAnnotation(annotationType) != null)__	};determine,if,this,type,descriptor,has,the,specified,annotation,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,get,annotation,annotation,type,null
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1467288171;Determine if this type descriptor has the specified annotation._<p>As of Spring Framework 4.2, this method supports arbitrary levels_of meta-annotations._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return (getAnnotation(annotationType) != null)__	};determine,if,this,type,descriptor,has,the,specified,annotation,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,get,annotation,annotation,type,null
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1467677340;Determine if this type descriptor has the specified annotation._<p>As of Spring Framework 4.2, this method supports arbitrary levels_of meta-annotations._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return (getAnnotation(annotationType) != null)__	};determine,if,this,type,descriptor,has,the,specified,annotation,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,get,annotation,annotation,type,null
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1467730834;Determine if this type descriptor has the specified annotation._<p>As of Spring Framework 4.2, this method supports arbitrary levels_of meta-annotations._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return (getAnnotation(annotationType) != null)__	};determine,if,this,type,descriptor,has,the,specified,annotation,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,get,annotation,annotation,type,null
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1477690406;Determine if this type descriptor has the specified annotation._<p>As of Spring Framework 4.2, this method supports arbitrary levels_of meta-annotations._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return AnnotatedElementUtils.isAnnotated(this.annotatedElement, annotationType)__	};determine,if,this,type,descriptor,has,the,specified,annotation,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,annotated,element,utils,is,annotated,this,annotated,element,annotation,type
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1478094883;Determine if this type descriptor has the specified annotation._<p>As of Spring Framework 4.2, this method supports arbitrary levels_of meta-annotations._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return AnnotatedElementUtils.isAnnotated(this.annotatedElement, annotationType)__	};determine,if,this,type,descriptor,has,the,specified,annotation,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,annotated,element,utils,is,annotated,this,annotated,element,annotation,type
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1479823020;Determine if this type descriptor has the specified annotation._<p>As of Spring Framework 4.2, this method supports arbitrary levels_of meta-annotations._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return AnnotatedElementUtils.isAnnotated(this.annotatedElement, annotationType)__	};determine,if,this,type,descriptor,has,the,specified,annotation,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,annotated,element,utils,is,annotated,this,annotated,element,annotation,type
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1479900301;Determine if this type descriptor has the specified annotation._<p>As of Spring Framework 4.2, this method supports arbitrary levels_of meta-annotations._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		return AnnotatedElementUtils.isAnnotated(this.annotatedElement, annotationType)__	};determine,if,this,type,descriptor,has,the,specified,annotation,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,return,annotated,element,utils,is,annotated,this,annotated,element,annotation,type
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1480540964;Determine if this type descriptor has the specified annotation._<p>As of Spring Framework 4.2, this method supports arbitrary levels_of meta-annotations._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		if (this.annotatedElement.isEmpty()) {_			_			_			return false__		}_		return AnnotatedElementUtils.isAnnotated(this.annotatedElement, annotationType)__	};determine,if,this,type,descriptor,has,the,specified,annotation,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,if,this,annotated,element,is,empty,return,false,return,annotated,element,utils,is,annotated,this,annotated,element,annotation,type
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1481578128;Determine if this type descriptor has the specified annotation._<p>As of Spring Framework 4.2, this method supports arbitrary levels_of meta-annotations._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		if (this.annotatedElement.isEmpty()) {_			_			_			return false__		}_		return AnnotatedElementUtils.isAnnotated(this.annotatedElement, annotationType)__	};determine,if,this,type,descriptor,has,the,specified,annotation,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,if,this,annotated,element,is,empty,return,false,return,annotated,element,utils,is,annotated,this,annotated,element,annotation,type
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1482961889;Determine if this type descriptor has the specified annotation._<p>As of Spring Framework 4.2, this method supports arbitrary levels_of meta-annotations._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		if (this.annotatedElement.isEmpty()) {_			_			_			return false__		}_		return AnnotatedElementUtils.isAnnotated(this.annotatedElement, annotationType)__	};determine,if,this,type,descriptor,has,the,specified,annotation,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,if,this,annotated,element,is,empty,return,false,return,annotated,element,utils,is,annotated,this,annotated,element,annotation,type
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1495868221;Determine if this type descriptor has the specified annotation._<p>As of Spring Framework 4.2, this method supports arbitrary levels_of meta-annotations._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		if (this.annotatedElement.isEmpty()) {_			_			_			return false__		}_		return AnnotatedElementUtils.isAnnotated(this.annotatedElement, annotationType)__	};determine,if,this,type,descriptor,has,the,specified,annotation,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,if,this,annotated,element,is,empty,return,false,return,annotated,element,utils,is,annotated,this,annotated,element,annotation,type
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1496259743;Determine if this type descriptor has the specified annotation._<p>As of Spring Framework 4.2, this method supports arbitrary levels_of meta-annotations._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		if (this.annotatedElement.isEmpty()) {_			_			_			return false__		}_		return AnnotatedElementUtils.isAnnotated(this.annotatedElement, annotationType)__	};determine,if,this,type,descriptor,has,the,specified,annotation,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,if,this,annotated,element,is,empty,return,false,return,annotated,element,utils,is,annotated,this,annotated,element,annotation,type
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1496837955;Determine if this type descriptor has the specified annotation._<p>As of Spring Framework 4.2, this method supports arbitrary levels_of meta-annotations._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		if (this.annotatedElement.isEmpty()) {_			_			_			return false__		}_		return AnnotatedElementUtils.isAnnotated(this.annotatedElement, annotationType)__	};determine,if,this,type,descriptor,has,the,specified,annotation,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,if,this,annotated,element,is,empty,return,false,return,annotated,element,utils,is,annotated,this,annotated,element,annotation,type
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1498780456;Determine if this type descriptor has the specified annotation._<p>As of Spring Framework 4.2, this method supports arbitrary levels_of meta-annotations._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		if (this.annotatedElement.isEmpty()) {_			_			_			return false__		}_		return AnnotatedElementUtils.isAnnotated(this.annotatedElement, annotationType)__	};determine,if,this,type,descriptor,has,the,specified,annotation,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,if,this,annotated,element,is,empty,return,false,return,annotated,element,utils,is,annotated,this,annotated,element,annotation,type
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1508084888;Determine if this type descriptor has the specified annotation._<p>As of Spring Framework 4.2, this method supports arbitrary levels_of meta-annotations._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		if (this.annotatedElement.isEmpty()) {_			_			_			return false__		}_		return AnnotatedElementUtils.isAnnotated(this.annotatedElement, annotationType)__	};determine,if,this,type,descriptor,has,the,specified,annotation,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,if,this,annotated,element,is,empty,return,false,return,annotated,element,utils,is,annotated,this,annotated,element,annotation,type
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1522332300;Determine if this type descriptor has the specified annotation._<p>As of Spring Framework 4.2, this method supports arbitrary levels_of meta-annotations._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		if (this.annotatedElement.isEmpty()) {_			_			_			return false__		}_		return AnnotatedElementUtils.isAnnotated(this.annotatedElement, annotationType)__	};determine,if,this,type,descriptor,has,the,specified,annotation,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,if,this,annotated,element,is,empty,return,false,return,annotated,element,utils,is,annotated,this,annotated,element,annotation,type
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1532520919;Determine if this type descriptor has the specified annotation._<p>As of Spring Framework 4.2, this method supports arbitrary levels_of meta-annotations._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		if (this.annotatedElement.isEmpty()) {_			_			_			return false__		}_		return AnnotatedElementUtils.isAnnotated(this.annotatedElement, annotationType)__	};determine,if,this,type,descriptor,has,the,specified,annotation,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,if,this,annotated,element,is,empty,return,false,return,annotated,element,utils,is,annotated,this,annotated,element,annotation,type
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1546963887;Determine if this type descriptor has the specified annotation._<p>As of Spring Framework 4.2, this method supports arbitrary levels_of meta-annotations._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		if (this.annotatedElement.isEmpty()) {_			_			_			return false__		}_		return AnnotatedElementUtils.isAnnotated(this.annotatedElement, annotationType)__	};determine,if,this,type,descriptor,has,the,specified,annotation,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,if,this,annotated,element,is,empty,return,false,return,annotated,element,utils,is,annotated,this,annotated,element,annotation,type
TypeDescriptor -> public boolean hasAnnotation(Class<? extends Annotation> annotationType);1547033218;Determine if this type descriptor has the specified annotation._<p>As of Spring Framework 4.2, this method supports arbitrary levels_of meta-annotations._@param annotationType the annotation type_@return <tt>true</tt> if the annotation is present;public boolean hasAnnotation(Class<? extends Annotation> annotationType) {_		if (this.annotatedElement.isEmpty()) {_			_			_			return false__		}_		return AnnotatedElementUtils.isAnnotated(this.annotatedElement, annotationType)__	};determine,if,this,type,descriptor,has,the,specified,annotation,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,tt,true,tt,if,the,annotation,is,present;public,boolean,has,annotation,class,extends,annotation,annotation,type,if,this,annotated,element,is,empty,return,false,return,annotated,element,utils,is,annotated,this,annotated,element,annotation,type
TypeDescriptor -> public Class<?> getObjectType();1328020251;Variation of {@link #getType()} that accounts for a primitive type by returning its object wrapper type._This is useful for conversion service implementations that wish to normalize to object-based types and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1329142650;Variation of {@link #getType()} that accounts for a primitive type by returning its object wrapper type._This is useful for conversion service implementations that wish to normalize to object-based types and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1335774711;Variation of {@link #getType()} that accounts for a primitive type by returning its object wrapper type._This is useful for conversion service implementations that wish to normalize to object-based types and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1349907422;Variation of {@link #getType()} that accounts for a primitive type by returning its object wrapper type._This is useful for conversion service implementations that wish to normalize to object-based types and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1351584957;Variation of {@link #getType()} that accounts for a primitive type by returning its object wrapper type._This is useful for conversion service implementations that wish to normalize to object-based types and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1351648403;Variation of {@link #getType()} that accounts for a primitive type by returning its object wrapper type._<p>This is useful for conversion service implementations that wish to normalize to object-based types_and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1356735495;Variation of {@link #getType()} that accounts for a primitive type by returning its object wrapper type._<p>This is useful for conversion service implementations that wish to normalize to object-based types_and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1362408075;Variation of {@link #getType()} that accounts for a primitive type by returning its object wrapper type._<p>This is useful for conversion service implementations that wish to normalize to object-based types_and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1368482696;Variation of {@link #getType()} that accounts for a primitive type by returning its object wrapper type._<p>This is useful for conversion service implementations that wish to normalize to object-based types_and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1374614239;Variation of {@link #getType()} that accounts for a primitive type by returning its object wrapper type._<p>This is useful for conversion service implementations that wish to normalize to object-based types_and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1382042882;Variation of {@link #getType()} that accounts for a primitive type by returning its object wrapper type._<p>This is useful for conversion service implementations that wish to normalize to object-based types_and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1382119085;Variation of {@link #getType()} that accounts for a primitive type by returning its object wrapper type._<p>This is useful for conversion service implementations that wish to normalize to object-based types_and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1382750081;Variation of {@link #getType()} that accounts for a primitive type by returning its object wrapper type._<p>This is useful for conversion service implementations that wish to normalize to object-based types_and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1387307647;Variation of {@link #getType()} that accounts for a primitive type by returning its object wrapper type._<p>This is useful for conversion service implementations that wish to normalize to object-based types_and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1387490898;Variation of {@link #getType()} that accounts for a primitive type by returning its object wrapper type._<p>This is useful for conversion service implementations that wish to normalize to object-based types_and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1389985540;Variation of {@link #getType()} that accounts for a primitive type by returning its object wrapper type._<p>This is useful for conversion service implementations that wish to normalize to object-based types_and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1390565795;Variation of {@link #getType()} that accounts for a primitive type by returning its object wrapper type._<p>This is useful for conversion service implementations that wish to normalize to object-based types_and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1390925810;Variation of {@link #getType()} that accounts for a primitive type by returning its object wrapper type._<p>This is useful for conversion service implementations that wish to normalize to object-based types_and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1391081201;Variation of {@link #getType()} that accounts for a primitive type by returning its object wrapper type._<p>This is useful for conversion service implementations that wish to normalize to object-based types_and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1391248381;Variation of {@link #getType()} that accounts for a primitive type by returning its object wrapper type._<p>This is useful for conversion service implementations that wish to normalize to object-based types_and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1394055372;Variation of {@link #getType()} that accounts for a primitive type by returning its object wrapper type._<p>This is useful for conversion service implementations that wish to normalize to object-based types_and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1395846555;Variation of {@link #getType()} that accounts for a primitive type by returning its object wrapper type._<p>This is useful for conversion service implementations that wish to normalize to object-based types_and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1403636229;Variation of {@link #getType()} that accounts for a primitive type by returning its object wrapper type._<p>This is useful for conversion service implementations that wish to normalize to object-based types_and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1405430015;Variation of {@link #getType()} that accounts for a primitive type by_returning its object wrapper type._<p>This is useful for conversion service implementations that wish to_normalize to object-based types and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1406196817;Variation of {@link #getType()} that accounts for a primitive type by_returning its object wrapper type._<p>This is useful for conversion service implementations that wish to_normalize to object-based types and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1412611699;Variation of {@link #getType()} that accounts for a primitive type by_returning its object wrapper type._<p>This is useful for conversion service implementations that wish to_normalize to object-based types and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1414925289;Variation of {@link #getType()} that accounts for a primitive type by_returning its object wrapper type._<p>This is useful for conversion service implementations that wish to_normalize to object-based types and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1417290561;Variation of {@link #getType()} that accounts for a primitive type by_returning its object wrapper type._<p>This is useful for conversion service implementations that wish to_normalize to object-based types and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1419966315;Variation of {@link #getType()} that accounts for a primitive type by_returning its object wrapper type._<p>This is useful for conversion service implementations that wish to_normalize to object-based types and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1424769447;Variation of {@link #getType()} that accounts for a primitive type by_returning its object wrapper type._<p>This is useful for conversion service implementations that wish to_normalize to object-based types and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1424887506;Variation of {@link #getType()} that accounts for a primitive type by_returning its object wrapper type._<p>This is useful for conversion service implementations that wish to_normalize to object-based types and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1425763631;Variation of {@link #getType()} that accounts for a primitive type by_returning its object wrapper type._<p>This is useful for conversion service implementations that wish to_normalize to object-based types and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1431093918;Variation of {@link #getType()} that accounts for a primitive type by_returning its object wrapper type._<p>This is useful for conversion service implementations that wish to_normalize to object-based types and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1432125256;Variation of {@link #getType()} that accounts for a primitive type by_returning its object wrapper type._<p>This is useful for conversion service implementations that wish to_normalize to object-based types and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1441035153;Variation of {@link #getType()} that accounts for a primitive type by_returning its object wrapper type._<p>This is useful for conversion service implementations that wish to_normalize to object-based types and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1448383050;Variation of {@link #getType()} that accounts for a primitive type by_returning its object wrapper type._<p>This is useful for conversion service implementations that wish to_normalize to object-based types and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1450473050;Variation of {@link #getType()} that accounts for a primitive type by_returning its object wrapper type._<p>This is useful for conversion service implementations that wish to_normalize to object-based types and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1467288171;Variation of {@link #getType()} that accounts for a primitive type by_returning its object wrapper type._<p>This is useful for conversion service implementations that wish to_normalize to object-based types and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1467677340;Variation of {@link #getType()} that accounts for a primitive type by_returning its object wrapper type._<p>This is useful for conversion service implementations that wish to_normalize to object-based types and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1467730834;Variation of {@link #getType()} that accounts for a primitive type by_returning its object wrapper type._<p>This is useful for conversion service implementations that wish to_normalize to object-based types and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1477690406;Variation of {@link #getType()} that accounts for a primitive type by_returning its object wrapper type._<p>This is useful for conversion service implementations that wish to_normalize to object-based types and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1478094883;Variation of {@link #getType()} that accounts for a primitive type by_returning its object wrapper type._<p>This is useful for conversion service implementations that wish to_normalize to object-based types and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1479823020;Variation of {@link #getType()} that accounts for a primitive type by_returning its object wrapper type._<p>This is useful for conversion service implementations that wish to_normalize to object-based types and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1479900301;Variation of {@link #getType()} that accounts for a primitive type by_returning its object wrapper type._<p>This is useful for conversion service implementations that wish to_normalize to object-based types and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1480540964;Variation of {@link #getType()} that accounts for a primitive type by_returning its object wrapper type._<p>This is useful for conversion service implementations that wish to_normalize to object-based types and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1481578128;Variation of {@link #getType()} that accounts for a primitive type by_returning its object wrapper type._<p>This is useful for conversion service implementations that wish to_normalize to object-based types and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1482961889;Variation of {@link #getType()} that accounts for a primitive type by_returning its object wrapper type._<p>This is useful for conversion service implementations that wish to_normalize to object-based types and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1495868221;Variation of {@link #getType()} that accounts for a primitive type by_returning its object wrapper type._<p>This is useful for conversion service implementations that wish to_normalize to object-based types and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1496259743;Variation of {@link #getType()} that accounts for a primitive type by_returning its object wrapper type._<p>This is useful for conversion service implementations that wish to_normalize to object-based types and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1496837955;Variation of {@link #getType()} that accounts for a primitive type by_returning its object wrapper type._<p>This is useful for conversion service implementations that wish to_normalize to object-based types and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1498780456;Variation of {@link #getType()} that accounts for a primitive type by_returning its object wrapper type._<p>This is useful for conversion service implementations that wish to_normalize to object-based types and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1508084888;Variation of {@link #getType()} that accounts for a primitive type by_returning its object wrapper type._<p>This is useful for conversion service implementations that wish to_normalize to object-based types and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1522332300;Variation of {@link #getType()} that accounts for a primitive type by_returning its object wrapper type._<p>This is useful for conversion service implementations that wish to_normalize to object-based types and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1532520919;Variation of {@link #getType()} that accounts for a primitive type by_returning its object wrapper type._<p>This is useful for conversion service implementations that wish to_normalize to object-based types and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1546963887;Variation of {@link #getType()} that accounts for a primitive type by_returning its object wrapper type._<p>This is useful for conversion service implementations that wish to_normalize to object-based types and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public Class<?> getObjectType();1547033218;Variation of {@link #getType()} that accounts for a primitive type by_returning its object wrapper type._<p>This is useful for conversion service implementations that wish to_normalize to object-based types and not work with primitive types directly.;public Class<?> getObjectType() {_		return ClassUtils.resolvePrimitiveIfNecessary(getType())__	};variation,of,link,get,type,that,accounts,for,a,primitive,type,by,returning,its,object,wrapper,type,p,this,is,useful,for,conversion,service,implementations,that,wish,to,normalize,to,object,based,types,and,not,work,with,primitive,types,directly;public,class,get,object,type,return,class,utils,resolve,primitive,if,necessary,get,type
TypeDescriptor -> public String getName();1328020251;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1329142650;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1335774711;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1349907422;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1351584957;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1351648403;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1356735495;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1362408075;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1368482696;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1374614239;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1382042882;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1382119085;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1382750081;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1387307647;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1387490898;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1389985540;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1390565795;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1390925810;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1391081201;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1391248381;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1394055372;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1395846555;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1403636229;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1405430015;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1406196817;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1412611699;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1414925289;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1417290561;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1419966315;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1424769447;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1424887506;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1425763631;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1431093918;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1432125256;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1441035153;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1448383050;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1450473050;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1467288171;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1467677340;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1467730834;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1477690406;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1478094883;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1479823020;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1479900301;Returns the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};returns,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1480540964;Return the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};return,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1481578128;Return the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};return,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1482961889;Return the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};return,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1495868221;Return the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};return,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1496259743;Return the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};return,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1496837955;Return the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};return,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1498780456;Return the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};return,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1508084888;Return the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};return,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1522332300;Return the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};return,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1532520919;Return the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};return,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1546963887;Return the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};return,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public String getName();1547033218;Return the name of this type: the fully qualified class name.;public String getName() {_		return ClassUtils.getQualifiedName(getType())__	};return,the,name,of,this,type,the,fully,qualified,class,name;public,string,get,name,return,class,utils,get,qualified,name,get,type
TypeDescriptor -> public static TypeDescriptor valueOf(@Nullable Class<?> type);1495868221;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(@Nullable Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,nullable,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(@Nullable Class<?> type);1496259743;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(@Nullable Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,nullable,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(@Nullable Class<?> type);1496837955;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(@Nullable Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,nullable,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(@Nullable Class<?> type);1498780456;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(@Nullable Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,nullable,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(@Nullable Class<?> type);1508084888;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(@Nullable Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,nullable,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(@Nullable Class<?> type);1522332300;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(@Nullable Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,nullable,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(@Nullable Class<?> type);1532520919;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(@Nullable Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,nullable,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(@Nullable Class<?> type);1546963887;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(@Nullable Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,nullable,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(@Nullable Class<?> type);1547033218;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(@Nullable Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,nullable,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> @Deprecated 	public Class<?> getMapValueType();1328020251;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}._@throws IllegalStateException if this type is not a java.util.Map.;@Deprecated_	public Class<?> getMapValueType() {_		return getMapValueTypeDescriptor().getType()__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,value,type,descriptor,get,map,value,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,value,type,return,get,map,value,type,descriptor,get,type
TypeDescriptor -> @Deprecated 	public Class<?> getMapValueType();1329142650;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}._@throws IllegalStateException if this type is not a java.util.Map.;@Deprecated_	public Class<?> getMapValueType() {_		return getMapValueTypeDescriptor().getType()__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,value,type,descriptor,get,map,value,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,value,type,return,get,map,value,type,descriptor,get,type
TypeDescriptor -> @Deprecated 	public Class<?> getMapValueType();1335774711;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}._@throws IllegalStateException if this type is not a java.util.Map.;@Deprecated_	public Class<?> getMapValueType() {_		return getMapValueTypeDescriptor().getType()__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,value,type,descriptor,get,map,value,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,value,type,return,get,map,value,type,descriptor,get,type
TypeDescriptor -> @Deprecated 	public Class<?> getMapValueType();1349907422;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Map;@Deprecated_	public Class<?> getMapValueType() {_		return getMapValueTypeDescriptor().getType()__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,value,type,descriptor,get,map,value,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,value,type,return,get,map,value,type,descriptor,get,type
TypeDescriptor -> @Deprecated 	public Class<?> getMapValueType();1351584957;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Map;@Deprecated_	public Class<?> getMapValueType() {_		return getMapValueTypeDescriptor().getType()__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,value,type,descriptor,get,map,value,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,value,type,return,get,map,value,type,descriptor,get,type
TypeDescriptor -> @Deprecated 	public Class<?> getMapValueType();1351648403;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Map;@Deprecated_	public Class<?> getMapValueType() {_		return getMapValueTypeDescriptor().getType()__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,value,type,descriptor,get,map,value,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,value,type,return,get,map,value,type,descriptor,get,type
TypeDescriptor -> @Deprecated 	public Class<?> getMapValueType();1356735495;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Map;@Deprecated_	public Class<?> getMapValueType() {_		return getMapValueTypeDescriptor().getType()__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,value,type,descriptor,get,map,value,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,value,type,return,get,map,value,type,descriptor,get,type
TypeDescriptor -> @Deprecated 	public Class<?> getMapValueType();1362408075;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Map;@Deprecated_	public Class<?> getMapValueType() {_		return getMapValueTypeDescriptor().getType()__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,value,type,descriptor,get,map,value,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,value,type,return,get,map,value,type,descriptor,get,type
TypeDescriptor -> @Deprecated 	public Class<?> getMapValueType();1368482696;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Map;@Deprecated_	public Class<?> getMapValueType() {_		return getMapValueTypeDescriptor().getType()__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,value,type,descriptor,get,map,value,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,value,type,return,get,map,value,type,descriptor,get,type
TypeDescriptor -> @Deprecated 	public Class<?> getMapValueType();1374614239;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Map;@Deprecated_	public Class<?> getMapValueType() {_		return getMapValueTypeDescriptor().getType()__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,value,type,descriptor,get,map,value,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,value,type,return,get,map,value,type,descriptor,get,type
TypeDescriptor -> @Deprecated 	public Class<?> getMapValueType();1382042882;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Map;@Deprecated_	public Class<?> getMapValueType() {_		return getType(getMapValueTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,value,type,descriptor,get,map,value,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,value,type,return,get,type,get,map,value,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getMapValueType();1382119085;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Map;@Deprecated_	public Class<?> getMapValueType() {_		return getType(getMapValueTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,value,type,descriptor,get,map,value,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,value,type,return,get,type,get,map,value,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getMapValueType();1382750081;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Map;@Deprecated_	public Class<?> getMapValueType() {_		return getType(getMapValueTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,value,type,descriptor,get,map,value,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,value,type,return,get,type,get,map,value,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getMapValueType();1387307647;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Map;@Deprecated_	public Class<?> getMapValueType() {_		return getType(getMapValueTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,value,type,descriptor,get,map,value,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,value,type,return,get,type,get,map,value,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getMapValueType();1387490898;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Map;@Deprecated_	public Class<?> getMapValueType() {_		return getType(getMapValueTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,value,type,descriptor,get,map,value,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,value,type,return,get,type,get,map,value,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getMapValueType();1389985540;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Map;@Deprecated_	public Class<?> getMapValueType() {_		return getType(getMapValueTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,value,type,descriptor,get,map,value,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,value,type,return,get,type,get,map,value,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getMapValueType();1390565795;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Map;@Deprecated_	public Class<?> getMapValueType() {_		return getType(getMapValueTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,value,type,descriptor,get,map,value,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,value,type,return,get,type,get,map,value,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getMapValueType();1390925810;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Map;@Deprecated_	public Class<?> getMapValueType() {_		return getType(getMapValueTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,value,type,descriptor,get,map,value,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,value,type,return,get,type,get,map,value,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getMapValueType();1391081201;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Map;@Deprecated_	public Class<?> getMapValueType() {_		return getType(getMapValueTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,value,type,descriptor,get,map,value,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,value,type,return,get,type,get,map,value,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getMapValueType();1391248381;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Map;@Deprecated_	public Class<?> getMapValueType() {_		return getType(getMapValueTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,value,type,descriptor,get,map,value,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,value,type,return,get,type,get,map,value,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getMapValueType();1394055372;Returns the value of {@link TypeDescriptor#getType() getType()} for the_{@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}_@throws IllegalStateException if this type is not a {@code java.util.Map};@Deprecated_	public Class<?> getMapValueType() {_		return getType(getMapValueTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,value,type,descriptor,get,map,value,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;deprecated,public,class,get,map,value,type,return,get,type,get,map,value,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getMapValueType();1395846555;Returns the value of {@link TypeDescriptor#getType() getType()} for the_{@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}_@throws IllegalStateException if this type is not a {@code java.util.Map};@Deprecated_	public Class<?> getMapValueType() {_		return getType(getMapValueTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,value,type,descriptor,get,map,value,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;deprecated,public,class,get,map,value,type,return,get,type,get,map,value,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getMapValueType();1403636229;Returns the value of {@link TypeDescriptor#getType() getType()} for the_{@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}_@throws IllegalStateException if this type is not a {@code java.util.Map};@Deprecated_	public Class<?> getMapValueType() {_		return getType(getMapValueTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,value,type,descriptor,get,map,value,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;deprecated,public,class,get,map,value,type,return,get,type,get,map,value,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getMapValueType();1405430015;Returns the value of {@link TypeDescriptor#getType() getType()} for the_{@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}_@throws IllegalStateException if this type is not a {@code java.util.Map};@Deprecated_	public Class<?> getMapValueType() {_		return getType(getMapValueTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,value,type,descriptor,get,map,value,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;deprecated,public,class,get,map,value,type,return,get,type,get,map,value,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getMapValueType();1406196817;Returns the value of {@link TypeDescriptor#getType() getType()} for the_{@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}_@throws IllegalStateException if this type is not a {@code java.util.Map};@Deprecated_	public Class<?> getMapValueType() {_		return getType(getMapValueTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,value,type,descriptor,get,map,value,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;deprecated,public,class,get,map,value,type,return,get,type,get,map,value,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getMapValueType();1412611699;Returns the value of {@link TypeDescriptor#getType() getType()} for the_{@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}_@throws IllegalStateException if this type is not a {@code java.util.Map};@Deprecated_	public Class<?> getMapValueType() {_		return getType(getMapValueTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,value,type,descriptor,get,map,value,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;deprecated,public,class,get,map,value,type,return,get,type,get,map,value,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getMapValueType();1414925289;Returns the value of {@link TypeDescriptor#getType() getType()} for the_{@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}_@throws IllegalStateException if this type is not a {@code java.util.Map};@Deprecated_	public Class<?> getMapValueType() {_		return getType(getMapValueTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,value,type,descriptor,get,map,value,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;deprecated,public,class,get,map,value,type,return,get,type,get,map,value,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getMapValueType();1417290561;Returns the value of {@link TypeDescriptor#getType() getType()} for the_{@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}_@throws IllegalStateException if this type is not a {@code java.util.Map};@Deprecated_	public Class<?> getMapValueType() {_		return getType(getMapValueTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,value,type,descriptor,get,map,value,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;deprecated,public,class,get,map,value,type,return,get,type,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1328020251;If this type is a {@link Collection} or an Array, creates a element TypeDescriptor from the provided collection or array element._Narrows the {@link #getElementTypeDescriptor() elementType} property to the class of the provided collection or array element._For example, if this describes a java.util.List&lt_java.lang.Number&lt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.List&lt_?&gt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a java.util.Collection or Array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,list,lt,gt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1329142650;If this type is a {@link Collection} or an Array, creates a element TypeDescriptor from the provided collection or array element._Narrows the {@link #getElementTypeDescriptor() elementType} property to the class of the provided collection or array element._For example, if this describes a java.util.List&lt_java.lang.Number&lt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.List&lt_?&gt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a java.util.Collection or Array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,list,lt,gt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1335774711;If this type is a {@link Collection} or an Array, creates a element TypeDescriptor from the provided collection or array element._Narrows the {@link #getElementTypeDescriptor() elementType} property to the class of the provided collection or array element._For example, if this describes a java.util.List&lt_java.lang.Number&lt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.List&lt_?&gt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a java.util.Collection or Array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,list,lt,gt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1349907422;If this type is a {@link Collection} or an Array, creates a element TypeDescriptor from the provided collection or array element._Narrows the {@link #getElementTypeDescriptor() elementType} property to the class of the provided collection or array element._For example, if this describes a java.util.List&lt_java.lang.Number&lt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.List&lt_?&gt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a java.util.Collection or Array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,list,lt,gt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1351584957;If this type is a {@link Collection} or an Array, creates a element TypeDescriptor from the provided collection or array element._Narrows the {@link #getElementTypeDescriptor() elementType} property to the class of the provided collection or array element._For example, if this describes a java.util.List&lt_java.lang.Number&lt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.List&lt_?&gt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a java.util.Collection or Array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,list,lt,gt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1351648403;If this type is a {@link Collection} or an Array, creates a element TypeDescriptor from the provided collection or array element._Narrows the {@link #getElementTypeDescriptor() elementType} property to the class of the provided collection or array element._For example, if this describes a java.util.List&lt_java.lang.Number&lt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.List&lt_?&gt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a java.util.Collection or Array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,list,lt,gt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1356735495;If this type is a {@link Collection} or an Array, creates a element TypeDescriptor from the provided collection or array element._Narrows the {@link #getElementTypeDescriptor() elementType} property to the class of the provided collection or array element._For example, if this describes a java.util.List&lt_java.lang.Number&lt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.List&lt_?&gt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a java.util.Collection or Array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,list,lt,gt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1362408075;If this type is a {@link Collection} or an Array, creates a element TypeDescriptor from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class of the provided collection or array element._For example, if this describes a java.util.List&lt_java.lang.Number&lt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.List&lt_?&gt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a java.util.Collection or Array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,list,lt,gt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1368482696;If this type is a {@link Collection} or an Array, creates a element TypeDescriptor from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class of the provided collection or array element._For example, if this describes a java.util.List&lt_java.lang.Number&lt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.List&lt_?&gt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a java.util.Collection or Array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,list,lt,gt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1374614239;If this type is a {@link Collection} or an Array, creates a element TypeDescriptor from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class of the provided collection or array element._For example, if this describes a java.util.List&lt_java.lang.Number&lt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.List&lt_?&gt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a java.util.Collection or Array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,list,lt,gt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1382042882;If this type is a {@link Collection} or an Array, creates a element TypeDescriptor from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class of the provided collection or array element._For example, if this describes a java.util.List&lt_java.lang.Number&lt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.List&lt_?&gt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a java.util.Collection or Array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,list,lt,gt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1382119085;If this type is a {@link Collection} or an Array, creates a element TypeDescriptor from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class of the provided collection or array element._For example, if this describes a java.util.List&lt_java.lang.Number&lt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.List&lt_?&gt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a java.util.Collection or Array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,list,lt,gt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1382750081;If this type is a {@link Collection} or an Array, creates a element TypeDescriptor from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class of the provided collection or array element._For example, if this describes a java.util.List&lt_java.lang.Number&lt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.List&lt_?&gt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a java.util.Collection or Array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,list,lt,gt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1387307647;If this type is a {@link Collection} or an Array, creates a element TypeDescriptor from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class of the provided collection or array element._For example, if this describes a java.util.List&lt_java.lang.Number&lt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.List&lt_?&gt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a java.util.Collection or Array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,list,lt,gt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1387490898;If this type is a {@link Collection} or an Array, creates a element TypeDescriptor from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class of the provided collection or array element._For example, if this describes a java.util.List&lt_java.lang.Number&lt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.List&lt_?&gt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a java.util.Collection or Array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,list,lt,gt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1389985540;If this type is a {@link Collection} or an Array, creates a element TypeDescriptor from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class of the provided collection or array element._For example, if this describes a java.util.List&lt_java.lang.Number&lt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.List&lt_?&gt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a java.util.Collection or Array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,list,lt,gt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1390565795;If this type is a {@link Collection} or an Array, creates a element TypeDescriptor from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class of the provided collection or array element._For example, if this describes a java.util.List&lt_java.lang.Number&lt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.List&lt_?&gt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a java.util.Collection or Array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,list,lt,gt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1390925810;If this type is a {@link Collection} or an Array, creates a element TypeDescriptor from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class of the provided collection or array element._For example, if this describes a java.util.List&lt_java.lang.Number&lt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.List&lt_?&gt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a java.util.Collection or Array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,list,lt,gt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1391081201;If this type is a {@link Collection} or an Array, creates a element TypeDescriptor from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class of the provided collection or array element._For example, if this describes a java.util.List&lt_java.lang.Number&lt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.List&lt_?&gt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a java.util.Collection or Array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,list,lt,gt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1391248381;If this type is a {@link Collection} or an Array, creates a element TypeDescriptor from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class of the provided collection or array element._For example, if this describes a java.util.List&lt_java.lang.Number&lt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.List&lt_?&gt_ and the element argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a java.util.Collection or Array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,list,lt,gt,and,the,element,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1394055372;If this type is a {@link Collection} or an array, creates a element TypeDescriptor_from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class_of the provided collection or array element. For example, if this describes a_{@code java.util.List&lt_java.lang.Number&lt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}._If this describes a {@code java.util.List&lt_?&gt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}_as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a {@code java.util.Collection}_or array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,code,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,list,lt,gt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1395846555;If this type is a {@link Collection} or an array, creates a element TypeDescriptor_from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class_of the provided collection or array element. For example, if this describes a_{@code java.util.List&lt_java.lang.Number&lt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}._If this describes a {@code java.util.List&lt_?&gt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}_as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a {@code java.util.Collection}_or array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,code,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,list,lt,gt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1403636229;If this type is a {@link Collection} or an array, creates a element TypeDescriptor_from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class_of the provided collection or array element. For example, if this describes a_{@code java.util.List&lt_java.lang.Number&lt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}._If this describes a {@code java.util.List&lt_?&gt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}_as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a {@code java.util.Collection}_or array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,code,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,list,lt,gt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1405430015;If this type is a {@link Collection} or an array, creates a element TypeDescriptor_from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class_of the provided collection or array element. For example, if this describes a_{@code java.util.List&lt_java.lang.Number&lt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}._If this describes a {@code java.util.List&lt_?&gt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}_as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a {@code java.util.Collection}_or array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,code,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,list,lt,gt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1406196817;If this type is a {@link Collection} or an array, creates a element TypeDescriptor_from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class_of the provided collection or array element. For example, if this describes a_{@code java.util.List&lt_java.lang.Number&lt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}._If this describes a {@code java.util.List&lt_?&gt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}_as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a {@code java.util.Collection}_or array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,code,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,list,lt,gt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1412611699;If this type is a {@link Collection} or an array, creates a element TypeDescriptor_from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class_of the provided collection or array element. For example, if this describes a_{@code java.util.List&lt_java.lang.Number&lt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}._If this describes a {@code java.util.List&lt_?&gt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}_as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a {@code java.util.Collection}_or array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,code,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,list,lt,gt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1414925289;If this type is a {@link Collection} or an array, creates a element TypeDescriptor_from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class_of the provided collection or array element. For example, if this describes a_{@code java.util.List&lt_java.lang.Number&lt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}._If this describes a {@code java.util.List&lt_?&gt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}_as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a {@code java.util.Collection}_or array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,code,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,list,lt,gt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1417290561;If this type is a {@link Collection} or an array, creates a element TypeDescriptor_from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class_of the provided collection or array element. For example, if this describes a_{@code java.util.List&lt_java.lang.Number&lt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}._If this describes a {@code java.util.List&lt_?&gt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}_as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a {@code java.util.Collection}_or array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,code,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,list,lt,gt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1419966315;If this type is a {@link Collection} or an array, creates a element TypeDescriptor_from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class_of the provided collection or array element. For example, if this describes a_{@code java.util.List&lt_java.lang.Number&lt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}._If this describes a {@code java.util.List&lt_?&gt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}_as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a {@code java.util.Collection}_or array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,code,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,list,lt,gt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1424769447;If this type is a {@link Collection} or an array, creates a element TypeDescriptor_from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class_of the provided collection or array element. For example, if this describes a_{@code java.util.List&lt_java.lang.Number&lt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}._If this describes a {@code java.util.List&lt_?&gt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}_as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a {@code java.util.Collection}_or array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,code,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,list,lt,gt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1424887506;If this type is a {@link Collection} or an array, creates a element TypeDescriptor_from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class_of the provided collection or array element. For example, if this describes a_{@code java.util.List&lt_java.lang.Number&lt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}._If this describes a {@code java.util.List&lt_?&gt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}_as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a {@code java.util.Collection}_or array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,code,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,list,lt,gt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1425763631;If this type is a {@link Collection} or an array, creates a element TypeDescriptor_from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class_of the provided collection or array element. For example, if this describes a_{@code java.util.List&lt_java.lang.Number&lt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}._If this describes a {@code java.util.List&lt_?&gt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}_as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a {@code java.util.Collection}_or array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,code,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,list,lt,gt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1431093918;If this type is a {@link Collection} or an array, creates a element TypeDescriptor_from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class_of the provided collection or array element. For example, if this describes a_{@code java.util.List&lt_java.lang.Number&lt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}._If this describes a {@code java.util.List&lt_?&gt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}_as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a {@code java.util.Collection}_or array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,code,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,list,lt,gt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1432125256;If this type is a {@link Collection} or an array, creates a element TypeDescriptor_from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class_of the provided collection or array element. For example, if this describes a_{@code java.util.List&lt_java.lang.Number&lt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}._If this describes a {@code java.util.List&lt_?&gt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}_as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a {@code java.util.Collection}_or array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,code,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,list,lt,gt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1441035153;If this type is a {@link Collection} or an array, creates a element TypeDescriptor_from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class_of the provided collection or array element. For example, if this describes a_{@code java.util.List&lt_java.lang.Number&lt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}._If this describes a {@code java.util.List&lt_?&gt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}_as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a {@code java.util.Collection}_or array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,code,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,list,lt,gt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1448383050;If this type is a {@link Collection} or an array, creates a element TypeDescriptor_from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class_of the provided collection or array element. For example, if this describes a_{@code java.util.List&lt_java.lang.Number&lt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}._If this describes a {@code java.util.List&lt_?&gt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}_as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a {@code java.util.Collection}_or array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,code,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,list,lt,gt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1450473050;If this type is a {@link Collection} or an array, creates a element TypeDescriptor_from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class_of the provided collection or array element. For example, if this describes a_{@code java.util.List&lt_java.lang.Number&lt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}._If this describes a {@code java.util.List&lt_?&gt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}_as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a {@code java.util.Collection}_or array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,code,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,list,lt,gt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1467288171;If this type is a {@link Collection} or an array, creates a element TypeDescriptor_from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class_of the provided collection or array element. For example, if this describes a_{@code java.util.List&lt_java.lang.Number&lt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}._If this describes a {@code java.util.List&lt_?&gt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}_as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a {@code java.util.Collection}_or array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,code,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,list,lt,gt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1467677340;If this type is a {@link Collection} or an array, creates a element TypeDescriptor_from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class_of the provided collection or array element. For example, if this describes a_{@code java.util.List&lt_java.lang.Number&lt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}._If this describes a {@code java.util.List&lt_?&gt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}_as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a {@code java.util.Collection}_or array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,code,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,list,lt,gt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1467730834;If this type is a {@link Collection} or an array, creates a element TypeDescriptor_from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class_of the provided collection or array element. For example, if this describes a_{@code java.util.List&lt_java.lang.Number&lt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}._If this describes a {@code java.util.List&lt_?&gt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}_as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a {@code java.util.Collection}_or array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,code,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,list,lt,gt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1477690406;If this type is a {@link Collection} or an array, creates a element TypeDescriptor_from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class_of the provided collection or array element. For example, if this describes a_{@code java.util.List&lt_java.lang.Number&lt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}._If this describes a {@code java.util.List&lt_?&gt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}_as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a {@code java.util.Collection}_or array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,code,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,list,lt,gt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1478094883;If this type is a {@link Collection} or an array, creates a element TypeDescriptor_from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class_of the provided collection or array element. For example, if this describes a_{@code java.util.List&lt_java.lang.Number&lt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}._If this describes a {@code java.util.List&lt_?&gt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}_as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a {@code java.util.Collection}_or array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,code,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,list,lt,gt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1479823020;If this type is a {@link Collection} or an array, creates a element TypeDescriptor_from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class_of the provided collection or array element. For example, if this describes a_{@code java.util.List&lt_java.lang.Number&lt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}._If this describes a {@code java.util.List&lt_?&gt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}_as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a {@code java.util.Collection}_or array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,code,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,list,lt,gt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1479900301;If this type is a {@link Collection} or an array, creates a element TypeDescriptor_from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class_of the provided collection or array element. For example, if this describes a_{@code java.util.List&lt_java.lang.Number&lt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}._If this describes a {@code java.util.List&lt_?&gt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}_as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a {@code java.util.Collection}_or array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,code,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,list,lt,gt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1480540964;If this type is a {@link Collection} or an array, creates a element TypeDescriptor_from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class_of the provided collection or array element. For example, if this describes a_{@code java.util.List&lt_java.lang.Number&lt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}._If this describes a {@code java.util.List&lt_?&gt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}_as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a {@code java.util.Collection}_or array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,code,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,list,lt,gt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1481578128;If this type is a {@link Collection} or an array, creates a element TypeDescriptor_from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class_of the provided collection or array element. For example, if this describes a_{@code java.util.List&lt_java.lang.Number&lt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}._If this describes a {@code java.util.List&lt_?&gt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}_as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a {@code java.util.Collection}_or array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,code,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,list,lt,gt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1482961889;If this type is a {@link Collection} or an array, creates a element TypeDescriptor_from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class_of the provided collection or array element. For example, if this describes a_{@code java.util.List&lt_java.lang.Number&lt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}._If this describes a {@code java.util.List&lt_?&gt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}_as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a {@code java.util.Collection}_or array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,code,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,list,lt,gt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1495868221;If this type is a {@link Collection} or an array, creates a element TypeDescriptor_from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class_of the provided collection or array element. For example, if this describes a_{@code java.util.List&lt_java.lang.Number&lt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}._If this describes a {@code java.util.List&lt_?&gt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}_as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a {@code java.util.Collection}_or array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,code,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,list,lt,gt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> public TypeDescriptor elementTypeDescriptor(Object element);1496259743;If this type is a {@link Collection} or an array, creates a element TypeDescriptor_from the provided collection or array element._<p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class_of the provided collection or array element. For example, if this describes a_{@code java.util.List&lt_java.lang.Number&lt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}._If this describes a {@code java.util.List&lt_?&gt_} and the element argument is an_{@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}_as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param element the collection or array element_@return a element type descriptor, narrowed to the type of the provided element_@throws IllegalStateException if this type is not a {@code java.util.Collection}_or array type_@see #narrow(Object);public TypeDescriptor elementTypeDescriptor(Object element) {_		return narrow(element, getElementTypeDescriptor())__	};if,this,type,is,a,link,collection,or,an,array,creates,a,element,type,descriptor,from,the,provided,collection,or,array,element,p,narrows,the,link,get,element,type,descriptor,element,type,property,to,the,class,of,the,provided,collection,or,array,element,for,example,if,this,describes,a,code,java,util,list,lt,java,lang,number,lt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,list,lt,gt,and,the,element,argument,is,an,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,element,the,collection,or,array,element,return,a,element,type,descriptor,narrowed,to,the,type,of,the,provided,element,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type,see,narrow,object;public,type,descriptor,element,type,descriptor,object,element,return,narrow,element,get,element,type,descriptor
TypeDescriptor -> @Nullable 	public static TypeDescriptor array(@Nullable TypeDescriptor elementTypeDescriptor);1495868221;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;@Nullable_	public static TypeDescriptor array(@Nullable TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;nullable,public,static,type,descriptor,array,nullable,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> @Nullable 	public static TypeDescriptor array(@Nullable TypeDescriptor elementTypeDescriptor);1496259743;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;@Nullable_	public static TypeDescriptor array(@Nullable TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;nullable,public,static,type,descriptor,array,nullable,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> @Nullable 	public static TypeDescriptor array(@Nullable TypeDescriptor elementTypeDescriptor);1496837955;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;@Nullable_	public static TypeDescriptor array(@Nullable TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;nullable,public,static,type,descriptor,array,nullable,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> @Nullable 	public static TypeDescriptor array(@Nullable TypeDescriptor elementTypeDescriptor);1498780456;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;@Nullable_	public static TypeDescriptor array(@Nullable TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;nullable,public,static,type,descriptor,array,nullable,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> @Nullable 	public static TypeDescriptor array(@Nullable TypeDescriptor elementTypeDescriptor);1508084888;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;@Nullable_	public static TypeDescriptor array(@Nullable TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;nullable,public,static,type,descriptor,array,nullable,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> @Nullable 	public static TypeDescriptor array(@Nullable TypeDescriptor elementTypeDescriptor);1522332300;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;@Nullable_	public static TypeDescriptor array(@Nullable TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;nullable,public,static,type,descriptor,array,nullable,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> @Nullable 	public static TypeDescriptor array(@Nullable TypeDescriptor elementTypeDescriptor);1532520919;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;@Nullable_	public static TypeDescriptor array(@Nullable TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;nullable,public,static,type,descriptor,array,nullable,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> @Nullable 	public static TypeDescriptor array(@Nullable TypeDescriptor elementTypeDescriptor);1546963887;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;@Nullable_	public static TypeDescriptor array(@Nullable TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;nullable,public,static,type,descriptor,array,nullable,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> @Nullable 	public static TypeDescriptor array(@Nullable TypeDescriptor elementTypeDescriptor);1547033218;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;@Nullable_	public static TypeDescriptor array(@Nullable TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;nullable,public,static,type,descriptor,array,nullable,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1328020251;If this type is a {@link Map} and its value type is parameterized, returns the map's value type._If the Map's value type is not parameterized, returns null indicating the value type is not declared._@return the Map value type, or <code>null</code> if this type is a Map but its value type is not parameterized._@throws IllegalStateException if this type is not a java.util.Map.;public TypeDescriptor getMapValueTypeDescriptor() {_		assertMap()__		return this.mapValueTypeDescriptor__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,if,the,map,s,value,type,is,not,parameterized,returns,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,code,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,map,return,this,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1329142650;If this type is a {@link Map} and its value type is parameterized, returns the map's value type._If the Map's value type is not parameterized, returns null indicating the value type is not declared._@return the Map value type, or <code>null</code> if this type is a Map but its value type is not parameterized._@throws IllegalStateException if this type is not a java.util.Map.;public TypeDescriptor getMapValueTypeDescriptor() {_		assertMap()__		return this.mapValueTypeDescriptor__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,if,the,map,s,value,type,is,not,parameterized,returns,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,code,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,map,return,this,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1335774711;If this type is a {@link Map} and its value type is parameterized, returns the map's value type._If the Map's value type is not parameterized, returns null indicating the value type is not declared._@return the Map value type, or <code>null</code> if this type is a Map but its value type is not parameterized._@throws IllegalStateException if this type is not a java.util.Map.;public TypeDescriptor getMapValueTypeDescriptor() {_		assertMap()__		return this.mapValueTypeDescriptor__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,if,the,map,s,value,type,is,not,parameterized,returns,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,code,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,map,return,this,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1349907422;If this type is a {@link Map} and its value type is parameterized, returns the map's value type._If the Map's value type is not parameterized, returns null indicating the value type is not declared._@return the Map value type, or <code>null</code> if this type is a Map but its value type is not parameterized_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapValueTypeDescriptor() {_		assertMap()__		return this.mapValueTypeDescriptor__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,if,the,map,s,value,type,is,not,parameterized,returns,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,code,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,map,return,this,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1351584957;If this type is a {@link Map} and its value type is parameterized, returns the map's value type._If the Map's value type is not parameterized, returns null indicating the value type is not declared._@return the Map value type, or <code>null</code> if this type is a Map but its value type is not parameterized_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapValueTypeDescriptor() {_		assertMap()__		return this.mapValueTypeDescriptor__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,if,the,map,s,value,type,is,not,parameterized,returns,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,code,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,map,return,this,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1351648403;If this type is a {@link Map} and its value type is parameterized, returns the map's value type._If the Map's value type is not parameterized, returns null indicating the value type is not declared._@return the Map value type, or <code>null</code> if this type is a Map but its value type is not parameterized_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapValueTypeDescriptor() {_		assertMap()__		return this.mapValueTypeDescriptor__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,if,the,map,s,value,type,is,not,parameterized,returns,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,code,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,map,return,this,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1356735495;If this type is a {@link Map} and its value type is parameterized, returns the map's value type._If the Map's value type is not parameterized, returns null indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map but its value type is not parameterized_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapValueTypeDescriptor() {_		assertMap()__		return this.mapValueTypeDescriptor__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,if,the,map,s,value,type,is,not,parameterized,returns,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,map,return,this,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1362408075;If this type is a {@link Map} and its value type is parameterized, returns the map's value type._<p>If the Map's value type is not parameterized, returns null indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map but its value type is not parameterized_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapValueTypeDescriptor() {_		assertMap()__		return this.mapValueTypeDescriptor__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,map,return,this,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1368482696;If this type is a {@link Map} and its value type is parameterized, returns the map's value type._<p>If the Map's value type is not parameterized, returns null indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map but its value type is not parameterized_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapValueTypeDescriptor() {_		assertMap()__		return this.mapValueTypeDescriptor__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,map,return,this,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1374614239;If this type is a {@link Map} and its value type is parameterized, returns the map's value type._<p>If the Map's value type is not parameterized, returns null indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map but its value type is not parameterized_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapValueTypeDescriptor() {_		assertMap()__		return this.mapValueTypeDescriptor__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,map,return,this,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1382042882;If this type is a {@link Map} and its value type is parameterized, returns the map's value type._<p>If the Map's value type is not parameterized, returns null indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map but its value type is not parameterized_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapValueTypeDescriptor() {_		assertMap()__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,1
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1382119085;If this type is a {@link Map} and its value type is parameterized, returns the map's value type._<p>If the Map's value type is not parameterized, returns null indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map but its value type is not parameterized_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapValueTypeDescriptor() {_		assertMap()__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,1
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1382750081;If this type is a {@link Map} and its value type is parameterized, returns the map's value type._<p>If the Map's value type is not parameterized, returns null indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map but its value type is not parameterized_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapValueTypeDescriptor() {_		assertMap()__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,1
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1387307647;If this type is a {@link Map} and its value type is parameterized, returns the map's value type._<p>If the Map's value type is not parameterized, returns null indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map but its value type is not parameterized_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapValueTypeDescriptor() {_		assertMap()__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,1
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1387490898;If this type is a {@link Map} and its value type is parameterized, returns the map's value type._<p>If the Map's value type is not parameterized, returns null indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map but its value type is not parameterized_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapValueTypeDescriptor() {_		assertMap()__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,1
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1389985540;If this type is a {@link Map} and its value type is parameterized, returns the map's value type._<p>If the Map's value type is not parameterized, returns null indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map but its value type is not parameterized_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapValueTypeDescriptor() {_		assertMap()__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,1
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1390565795;If this type is a {@link Map} and its value type is parameterized, returns the map's value type._<p>If the Map's value type is not parameterized, returns null indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map but its value type is not parameterized_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapValueTypeDescriptor() {_		assertMap()__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,1
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1390925810;If this type is a {@link Map} and its value type is parameterized, returns the map's value type._<p>If the Map's value type is not parameterized, returns null indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map but its value type is not parameterized_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapValueTypeDescriptor() {_		assertMap()__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,1
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1391081201;If this type is a {@link Map} and its value type is parameterized, returns the map's value type._<p>If the Map's value type is not parameterized, returns null indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map but its value type is not parameterized_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapValueTypeDescriptor() {_		assertMap()__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,1
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1391248381;If this type is a {@link Map} and its value type is parameterized, returns the map's value type._<p>If the Map's value type is not parameterized, returns null indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map but its value type is not parameterized_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapValueTypeDescriptor() {_		assertMap()__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,1
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1394055372;If this type is a {@link Map} and its value type is parameterized,_returns the map's value type._<p>If the Map's value type is not parameterized, returns {@code null}_indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map_but its value type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapValueTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,code,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,1
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1395846555;If this type is a {@link Map} and its value type is parameterized,_returns the map's value type._<p>If the Map's value type is not parameterized, returns {@code null}_indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map_but its value type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapValueTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,code,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,1
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1403636229;If this type is a {@link Map} and its value type is parameterized,_returns the map's value type._<p>If the Map's value type is not parameterized, returns {@code null}_indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map_but its value type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapValueTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,code,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,1
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1405430015;If this type is a {@link Map} and its value type is parameterized,_returns the map's value type._<p>If the Map's value type is not parameterized, returns {@code null}_indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map_but its value type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapValueTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,code,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,1
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1406196817;If this type is a {@link Map} and its value type is parameterized,_returns the map's value type._<p>If the Map's value type is not parameterized, returns {@code null}_indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map_but its value type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapValueTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,code,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,1
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1412611699;If this type is a {@link Map} and its value type is parameterized,_returns the map's value type._<p>If the Map's value type is not parameterized, returns {@code null}_indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map_but its value type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapValueTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,code,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,1
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1414925289;If this type is a {@link Map} and its value type is parameterized,_returns the map's value type._<p>If the Map's value type is not parameterized, returns {@code null}_indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map_but its value type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapValueTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,code,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,1
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1417290561;If this type is a {@link Map} and its value type is parameterized,_returns the map's value type._<p>If the Map's value type is not parameterized, returns {@code null}_indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map_but its value type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapValueTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,code,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,1
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1419966315;If this type is a {@link Map} and its value type is parameterized,_returns the map's value type._<p>If the Map's value type is not parameterized, returns {@code null}_indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map_but its value type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapValueTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,code,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,1
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1424769447;If this type is a {@link Map} and its value type is parameterized,_returns the map's value type._<p>If the Map's value type is not parameterized, returns {@code null}_indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map_but its value type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapValueTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,code,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,1
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1424887506;If this type is a {@link Map} and its value type is parameterized,_returns the map's value type._<p>If the Map's value type is not parameterized, returns {@code null}_indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map_but its value type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapValueTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,code,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,1
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1425763631;If this type is a {@link Map} and its value type is parameterized,_returns the map's value type._<p>If the Map's value type is not parameterized, returns {@code null}_indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map_but its value type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapValueTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,code,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,1
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1431093918;If this type is a {@link Map} and its value type is parameterized,_returns the map's value type._<p>If the Map's value type is not parameterized, returns {@code null}_indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map_but its value type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapValueTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,code,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,1
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1432125256;If this type is a {@link Map} and its value type is parameterized,_returns the map's value type._<p>If the Map's value type is not parameterized, returns {@code null}_indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map_but its value type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapValueTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,code,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,1
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1441035153;If this type is a {@link Map} and its value type is parameterized,_returns the map's value type._<p>If the Map's value type is not parameterized, returns {@code null}_indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map_but its value type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapValueTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,code,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,1
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1448383050;If this type is a {@link Map} and its value type is parameterized,_returns the map's value type._<p>If the Map's value type is not parameterized, returns {@code null}_indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map_but its value type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapValueTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,code,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,1
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1450473050;If this type is a {@link Map} and its value type is parameterized,_returns the map's value type._<p>If the Map's value type is not parameterized, returns {@code null}_indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map_but its value type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapValueTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,code,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,1
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1467288171;If this type is a {@link Map} and its value type is parameterized,_returns the map's value type._<p>If the Map's value type is not parameterized, returns {@code null}_indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map_but its value type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapValueTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,code,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,1
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1467677340;If this type is a {@link Map} and its value type is parameterized,_returns the map's value type._<p>If the Map's value type is not parameterized, returns {@code null}_indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map_but its value type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapValueTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,code,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,1
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1467730834;If this type is a {@link Map} and its value type is parameterized,_returns the map's value type._<p>If the Map's value type is not parameterized, returns {@code null}_indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map_but its value type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapValueTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,code,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,1
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1477690406;If this type is a {@link Map} and its value type is parameterized,_returns the map's value type._<p>If the Map's value type is not parameterized, returns {@code null}_indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map_but its value type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapValueTypeDescriptor() {_		Assert.state(isMap(), "Not a [java.util.Map]")__		return getRelatedIfResolvable(this, getResolvableType().asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,code,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,get,resolvable,type,as,map,get,generic,1
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1478094883;If this type is a {@link Map} and its value type is parameterized,_returns the map's value type._<p>If the Map's value type is not parameterized, returns {@code null}_indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map_but its value type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapValueTypeDescriptor() {_		Assert.state(isMap(), "Not a [java.util.Map]")__		return getRelatedIfResolvable(this, getResolvableType().asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,code,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,get,resolvable,type,as,map,get,generic,1
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1479823020;If this type is a {@link Map} and its value type is parameterized,_returns the map's value type._<p>If the Map's value type is not parameterized, returns {@code null}_indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map_but its value type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapValueTypeDescriptor() {_		Assert.state(isMap(), "Not a [java.util.Map]")__		return getRelatedIfResolvable(this, getResolvableType().asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,code,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,get,resolvable,type,as,map,get,generic,1
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1479900301;If this type is a {@link Map} and its value type is parameterized,_returns the map's value type._<p>If the Map's value type is not parameterized, returns {@code null}_indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map_but its value type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapValueTypeDescriptor() {_		Assert.state(isMap(), "Not a [java.util.Map]")__		return getRelatedIfResolvable(this, getResolvableType().asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,code,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,get,resolvable,type,as,map,get,generic,1
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1480540964;If this type is a {@link Map} and its value type is parameterized,_returns the map's value type._<p>If the Map's value type is not parameterized, returns {@code null}_indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map_but its value type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapValueTypeDescriptor() {_		Assert.state(isMap(), "Not a [java.util.Map]")__		return getRelatedIfResolvable(this, getResolvableType().asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,code,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,get,resolvable,type,as,map,get,generic,1
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1481578128;If this type is a {@link Map} and its value type is parameterized,_returns the map's value type._<p>If the Map's value type is not parameterized, returns {@code null}_indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map_but its value type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapValueTypeDescriptor() {_		Assert.state(isMap(), "Not a [java.util.Map]")__		return getRelatedIfResolvable(this, getResolvableType().asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,code,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,get,resolvable,type,as,map,get,generic,1
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor();1482961889;If this type is a {@link Map} and its value type is parameterized,_returns the map's value type._<p>If the Map's value type is not parameterized, returns {@code null}_indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map_but its value type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapValueTypeDescriptor() {_		Assert.state(isMap(), "Not a [java.util.Map]")__		return getRelatedIfResolvable(this, getResolvableType().asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,code,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,value,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,get,resolvable,type,as,map,get,generic,1
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1328020251;Create a new type descriptor from a {@link MethodParameter}._Use this constructor when a source or target conversion point is a constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		this(new ParameterDescriptor(methodParameter))__	};create,a,new,type,descriptor,from,a,link,method,parameter,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,this,new,parameter,descriptor,method,parameter
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1329142650;Create a new type descriptor from a {@link MethodParameter}._Use this constructor when a source or target conversion point is a constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		this(new ParameterDescriptor(methodParameter))__	};create,a,new,type,descriptor,from,a,link,method,parameter,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,this,new,parameter,descriptor,method,parameter
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1335774711;Create a new type descriptor from a {@link MethodParameter}._Use this constructor when a source or target conversion point is a constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		this(new ParameterDescriptor(methodParameter))__	};create,a,new,type,descriptor,from,a,link,method,parameter,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,this,new,parameter,descriptor,method,parameter
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1349907422;Create a new type descriptor from a {@link MethodParameter}._Use this constructor when a source or target conversion point is a constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		this(new ParameterDescriptor(methodParameter))__	};create,a,new,type,descriptor,from,a,link,method,parameter,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,this,new,parameter,descriptor,method,parameter
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1351584957;Create a new type descriptor from a {@link MethodParameter}._Use this constructor when a source or target conversion point is a constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		this(new ParameterDescriptor(methodParameter))__	};create,a,new,type,descriptor,from,a,link,method,parameter,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,this,new,parameter,descriptor,method,parameter
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1351648403;Create a new type descriptor from a {@link MethodParameter}._Use this constructor when a source or target conversion point is a constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		this(new ParameterDescriptor(methodParameter))__	};create,a,new,type,descriptor,from,a,link,method,parameter,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,this,new,parameter,descriptor,method,parameter
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1356735495;Create a new type descriptor from a {@link MethodParameter}._Use this constructor when a source or target conversion point is a constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		this(new ParameterDescriptor(methodParameter))__	};create,a,new,type,descriptor,from,a,link,method,parameter,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,this,new,parameter,descriptor,method,parameter
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1362408075;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		this(new ParameterDescriptor(methodParameter))__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,this,new,parameter,descriptor,method,parameter
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1368482696;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		this(new ParameterDescriptor(methodParameter))__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,this,new,parameter,descriptor,method,parameter
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1374614239;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		this(new ParameterDescriptor(methodParameter))__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,this,new,parameter,descriptor,method,parameter
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1382042882;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter argument must have its nestingLevel set to 1")__		}_		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(Object.class)__		this.annotations = (methodParameter.getParameterIndex() == -1 ?_				nullSafeAnnotations(methodParameter.getMethodAnnotations()) :_				nullSafeAnnotations(methodParameter.getParameterAnnotations()))__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,assert,not,null,method,parameter,method,parameter,must,not,be,null,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,argument,must,have,its,nesting,level,set,to,1,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,object,class,this,annotations,method,parameter,get,parameter,index,1,null,safe,annotations,method,parameter,get,method,annotations,null,safe,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1382119085;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter argument must have its nestingLevel set to 1")__		}_		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(Object.class)__		this.annotations = (methodParameter.getParameterIndex() == -1 ?_				nullSafeAnnotations(methodParameter.getMethodAnnotations()) :_				nullSafeAnnotations(methodParameter.getParameterAnnotations()))__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,assert,not,null,method,parameter,method,parameter,must,not,be,null,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,argument,must,have,its,nesting,level,set,to,1,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,object,class,this,annotations,method,parameter,get,parameter,index,1,null,safe,annotations,method,parameter,get,method,annotations,null,safe,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1382750081;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter argument must have its nestingLevel set to 1")__		}_		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(Object.class)__		this.annotations = (methodParameter.getParameterIndex() == -1 ?_				nullSafeAnnotations(methodParameter.getMethodAnnotations()) :_				nullSafeAnnotations(methodParameter.getParameterAnnotations()))__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,assert,not,null,method,parameter,method,parameter,must,not,be,null,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,argument,must,have,its,nesting,level,set,to,1,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,object,class,this,annotations,method,parameter,get,parameter,index,1,null,safe,annotations,method,parameter,get,method,annotations,null,safe,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1387307647;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter argument must have its nestingLevel set to 1")__		}_		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(Object.class)__		this.annotations = (methodParameter.getParameterIndex() == -1 ?_				nullSafeAnnotations(methodParameter.getMethodAnnotations()) :_				nullSafeAnnotations(methodParameter.getParameterAnnotations()))__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,assert,not,null,method,parameter,method,parameter,must,not,be,null,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,argument,must,have,its,nesting,level,set,to,1,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,object,class,this,annotations,method,parameter,get,parameter,index,1,null,safe,annotations,method,parameter,get,method,annotations,null,safe,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1387490898;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter argument must have its nestingLevel set to 1")__		}_		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(Object.class)__		this.annotations = (methodParameter.getParameterIndex() == -1 ?_				nullSafeAnnotations(methodParameter.getMethodAnnotations()) :_				nullSafeAnnotations(methodParameter.getParameterAnnotations()))__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,assert,not,null,method,parameter,method,parameter,must,not,be,null,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,argument,must,have,its,nesting,level,set,to,1,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,object,class,this,annotations,method,parameter,get,parameter,index,1,null,safe,annotations,method,parameter,get,method,annotations,null,safe,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1389985540;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter argument must have its nestingLevel set to 1")__		}_		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(Object.class)__		this.annotations = (methodParameter.getParameterIndex() == -1 ?_				nullSafeAnnotations(methodParameter.getMethodAnnotations()) :_				nullSafeAnnotations(methodParameter.getParameterAnnotations()))__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,assert,not,null,method,parameter,method,parameter,must,not,be,null,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,argument,must,have,its,nesting,level,set,to,1,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,object,class,this,annotations,method,parameter,get,parameter,index,1,null,safe,annotations,method,parameter,get,method,annotations,null,safe,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1390565795;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter argument must have its nestingLevel set to 1")__		}_		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(Object.class)__		this.annotations = (methodParameter.getParameterIndex() == -1 ?_				nullSafeAnnotations(methodParameter.getMethodAnnotations()) :_				nullSafeAnnotations(methodParameter.getParameterAnnotations()))__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,assert,not,null,method,parameter,method,parameter,must,not,be,null,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,argument,must,have,its,nesting,level,set,to,1,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,object,class,this,annotations,method,parameter,get,parameter,index,1,null,safe,annotations,method,parameter,get,method,annotations,null,safe,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1390925810;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter argument must have its nestingLevel set to 1")__		}_		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(Object.class)__		this.annotations = (methodParameter.getParameterIndex() == -1 ?_				nullSafeAnnotations(methodParameter.getMethodAnnotations()) :_				nullSafeAnnotations(methodParameter.getParameterAnnotations()))__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,assert,not,null,method,parameter,method,parameter,must,not,be,null,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,argument,must,have,its,nesting,level,set,to,1,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,object,class,this,annotations,method,parameter,get,parameter,index,1,null,safe,annotations,method,parameter,get,method,annotations,null,safe,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1391081201;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter argument must have its nestingLevel set to 1")__		}_		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(Object.class)__		this.annotations = (methodParameter.getParameterIndex() == -1 ?_				nullSafeAnnotations(methodParameter.getMethodAnnotations()) :_				nullSafeAnnotations(methodParameter.getParameterAnnotations()))__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,assert,not,null,method,parameter,method,parameter,must,not,be,null,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,argument,must,have,its,nesting,level,set,to,1,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,object,class,this,annotations,method,parameter,get,parameter,index,1,null,safe,annotations,method,parameter,get,method,annotations,null,safe,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1391248381;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter argument must have its nestingLevel set to 1")__		}_		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(Object.class)__		this.annotations = (methodParameter.getParameterIndex() == -1 ?_				nullSafeAnnotations(methodParameter.getMethodAnnotations()) :_				nullSafeAnnotations(methodParameter.getParameterAnnotations()))__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,assert,not,null,method,parameter,method,parameter,must,not,be,null,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,argument,must,have,its,nesting,level,set,to,1,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,object,class,this,annotations,method,parameter,get,parameter,index,1,null,safe,annotations,method,parameter,get,method,annotations,null,safe,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1394055372;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter argument must have its nestingLevel set to 1")__		}_		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(methodParameter.getParameterType())__		this.annotations = (methodParameter.getParameterIndex() == -1 ?_				nullSafeAnnotations(methodParameter.getMethodAnnotations()) :_				nullSafeAnnotations(methodParameter.getParameterAnnotations()))__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,assert,not,null,method,parameter,method,parameter,must,not,be,null,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,argument,must,have,its,nesting,level,set,to,1,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,method,parameter,get,parameter,type,this,annotations,method,parameter,get,parameter,index,1,null,safe,annotations,method,parameter,get,method,annotations,null,safe,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1395846555;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter argument must have its nestingLevel set to 1")__		}_		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(methodParameter.getParameterType())__		this.annotations = (methodParameter.getParameterIndex() == -1 ?_				nullSafeAnnotations(methodParameter.getMethodAnnotations()) :_				nullSafeAnnotations(methodParameter.getParameterAnnotations()))__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,assert,not,null,method,parameter,method,parameter,must,not,be,null,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,argument,must,have,its,nesting,level,set,to,1,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,method,parameter,get,parameter,type,this,annotations,method,parameter,get,parameter,index,1,null,safe,annotations,method,parameter,get,method,annotations,null,safe,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1403636229;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter argument must have its nestingLevel set to 1")__		}_		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(methodParameter.getParameterType())__		this.annotations = (methodParameter.getParameterIndex() == -1 ?_				nullSafeAnnotations(methodParameter.getMethodAnnotations()) :_				nullSafeAnnotations(methodParameter.getParameterAnnotations()))__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,assert,not,null,method,parameter,method,parameter,must,not,be,null,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,argument,must,have,its,nesting,level,set,to,1,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,method,parameter,get,parameter,type,this,annotations,method,parameter,get,parameter,index,1,null,safe,annotations,method,parameter,get,method,annotations,null,safe,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1405430015;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter argument must have its nestingLevel set to 1")__		}_		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(methodParameter.getParameterType())__		this.annotations = (methodParameter.getParameterIndex() == -1 ?_				nullSafeAnnotations(methodParameter.getMethodAnnotations()) :_				nullSafeAnnotations(methodParameter.getParameterAnnotations()))__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,assert,not,null,method,parameter,method,parameter,must,not,be,null,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,argument,must,have,its,nesting,level,set,to,1,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,method,parameter,get,parameter,type,this,annotations,method,parameter,get,parameter,index,1,null,safe,annotations,method,parameter,get,method,annotations,null,safe,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1406196817;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter argument must have its nestingLevel set to 1")__		}_		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(methodParameter.getParameterType())__		this.annotations = (methodParameter.getParameterIndex() == -1 ?_				nullSafeAnnotations(methodParameter.getMethodAnnotations()) :_				nullSafeAnnotations(methodParameter.getParameterAnnotations()))__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,assert,not,null,method,parameter,method,parameter,must,not,be,null,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,argument,must,have,its,nesting,level,set,to,1,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,method,parameter,get,parameter,type,this,annotations,method,parameter,get,parameter,index,1,null,safe,annotations,method,parameter,get,method,annotations,null,safe,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1412611699;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(methodParameter.getParameterType())__		this.annotations = (methodParameter.getParameterIndex() == -1 ?_				nullSafeAnnotations(methodParameter.getMethodAnnotations()) :_				nullSafeAnnotations(methodParameter.getParameterAnnotations()))__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,assert,not,null,method,parameter,method,parameter,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,method,parameter,get,parameter,type,this,annotations,method,parameter,get,parameter,index,1,null,safe,annotations,method,parameter,get,method,annotations,null,safe,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1414925289;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(methodParameter.getParameterType())__		this.annotations = (methodParameter.getParameterIndex() == -1 ?_				nullSafeAnnotations(methodParameter.getMethodAnnotations()) :_				nullSafeAnnotations(methodParameter.getParameterAnnotations()))__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,assert,not,null,method,parameter,method,parameter,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,method,parameter,get,parameter,type,this,annotations,method,parameter,get,parameter,index,1,null,safe,annotations,method,parameter,get,method,annotations,null,safe,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1417290561;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(methodParameter.getParameterType())__		this.annotations = (methodParameter.getParameterIndex() == -1 ?_				nullSafeAnnotations(methodParameter.getMethodAnnotations()) :_				nullSafeAnnotations(methodParameter.getParameterAnnotations()))__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,assert,not,null,method,parameter,method,parameter,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,method,parameter,get,parameter,type,this,annotations,method,parameter,get,parameter,index,1,null,safe,annotations,method,parameter,get,method,annotations,null,safe,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1419966315;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(methodParameter.getParameterType())__		this.annotations = (methodParameter.getParameterIndex() == -1 ?_				nullSafeAnnotations(methodParameter.getMethodAnnotations()) :_				nullSafeAnnotations(methodParameter.getParameterAnnotations()))__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,assert,not,null,method,parameter,method,parameter,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,method,parameter,get,parameter,type,this,annotations,method,parameter,get,parameter,index,1,null,safe,annotations,method,parameter,get,method,annotations,null,safe,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1424769447;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(methodParameter.getParameterType())__		this.annotations = (methodParameter.getParameterIndex() == -1 ?_				nullSafeAnnotations(methodParameter.getMethodAnnotations()) :_				nullSafeAnnotations(methodParameter.getParameterAnnotations()))__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,assert,not,null,method,parameter,method,parameter,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,method,parameter,get,parameter,type,this,annotations,method,parameter,get,parameter,index,1,null,safe,annotations,method,parameter,get,method,annotations,null,safe,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1424887506;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(methodParameter.getParameterType())__		this.annotations = (methodParameter.getParameterIndex() == -1 ?_				nullSafeAnnotations(methodParameter.getMethodAnnotations()) :_				nullSafeAnnotations(methodParameter.getParameterAnnotations()))__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,assert,not,null,method,parameter,method,parameter,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,method,parameter,get,parameter,type,this,annotations,method,parameter,get,parameter,index,1,null,safe,annotations,method,parameter,get,method,annotations,null,safe,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1425763631;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(methodParameter.getParameterType())__		this.annotations = (methodParameter.getParameterIndex() == -1 ?_				nullSafeAnnotations(methodParameter.getMethodAnnotations()) :_				nullSafeAnnotations(methodParameter.getParameterAnnotations()))__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,assert,not,null,method,parameter,method,parameter,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,method,parameter,get,parameter,type,this,annotations,method,parameter,get,parameter,index,1,null,safe,annotations,method,parameter,get,method,annotations,null,safe,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1431093918;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(methodParameter.getParameterType())__		this.annotations = (methodParameter.getParameterIndex() == -1 ?_				nullSafeAnnotations(methodParameter.getMethodAnnotations()) :_				nullSafeAnnotations(methodParameter.getParameterAnnotations()))__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,assert,not,null,method,parameter,method,parameter,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,method,parameter,get,parameter,type,this,annotations,method,parameter,get,parameter,index,1,null,safe,annotations,method,parameter,get,method,annotations,null,safe,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1432125256;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(methodParameter.getParameterType())__		this.annotations = (methodParameter.getParameterIndex() == -1 ?_				nullSafeAnnotations(methodParameter.getMethodAnnotations()) :_				nullSafeAnnotations(methodParameter.getParameterAnnotations()))__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,assert,not,null,method,parameter,method,parameter,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,method,parameter,get,parameter,type,this,annotations,method,parameter,get,parameter,index,1,null,safe,annotations,method,parameter,get,method,annotations,null,safe,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1441035153;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(methodParameter.getParameterType())__		this.annotations = (methodParameter.getParameterIndex() == -1 ?_				nullSafeAnnotations(methodParameter.getMethodAnnotations()) :_				nullSafeAnnotations(methodParameter.getParameterAnnotations()))__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,assert,not,null,method,parameter,method,parameter,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,method,parameter,get,parameter,type,this,annotations,method,parameter,get,parameter,index,1,null,safe,annotations,method,parameter,get,method,annotations,null,safe,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1448383050;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(methodParameter.getParameterType())__		this.annotations = (methodParameter.getParameterIndex() == -1 ?_				nullSafeAnnotations(methodParameter.getMethodAnnotations()) :_				nullSafeAnnotations(methodParameter.getParameterAnnotations()))__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,assert,not,null,method,parameter,method,parameter,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,method,parameter,get,parameter,type,this,annotations,method,parameter,get,parameter,index,1,null,safe,annotations,method,parameter,get,method,annotations,null,safe,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1450473050;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(methodParameter.getParameterType())__		this.annotations = (methodParameter.getParameterIndex() == -1 ?_				nullSafeAnnotations(methodParameter.getMethodAnnotations()) :_				nullSafeAnnotations(methodParameter.getParameterAnnotations()))__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,assert,not,null,method,parameter,method,parameter,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,method,parameter,get,parameter,type,this,annotations,method,parameter,get,parameter,index,1,null,safe,annotations,method,parameter,get,method,annotations,null,safe,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1467288171;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(methodParameter.getParameterType())__		this.annotations = (methodParameter.getParameterIndex() == -1 ?_				nullSafeAnnotations(methodParameter.getMethodAnnotations()) :_				nullSafeAnnotations(methodParameter.getParameterAnnotations()))__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,assert,not,null,method,parameter,method,parameter,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,method,parameter,get,parameter,type,this,annotations,method,parameter,get,parameter,index,1,null,safe,annotations,method,parameter,get,method,annotations,null,safe,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1467677340;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(methodParameter.getParameterType())__		this.annotations = (methodParameter.getParameterIndex() == -1 ?_				nullSafeAnnotations(methodParameter.getMethodAnnotations()) :_				nullSafeAnnotations(methodParameter.getParameterAnnotations()))__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,assert,not,null,method,parameter,method,parameter,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,method,parameter,get,parameter,type,this,annotations,method,parameter,get,parameter,index,1,null,safe,annotations,method,parameter,get,method,annotations,null,safe,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1467730834;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(methodParameter.getParameterType())__		this.annotations = (methodParameter.getParameterIndex() == -1 ?_				nullSafeAnnotations(methodParameter.getMethodAnnotations()) :_				nullSafeAnnotations(methodParameter.getParameterAnnotations()))__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,assert,not,null,method,parameter,method,parameter,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,method,parameter,get,parameter,type,this,annotations,method,parameter,get,parameter,index,1,null,safe,annotations,method,parameter,get,method,annotations,null,safe,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1477690406;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(methodParameter.getParameterType())__		this.annotatedElement = new AnnotatedElementAdapter(methodParameter.getParameterIndex() == -1 ?_				methodParameter.getMethodAnnotations() : methodParameter.getParameterAnnotations())__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,assert,not,null,method,parameter,method,parameter,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,method,parameter,get,parameter,type,this,annotated,element,new,annotated,element,adapter,method,parameter,get,parameter,index,1,method,parameter,get,method,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1478094883;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(methodParameter.getParameterType())__		this.annotatedElement = new AnnotatedElementAdapter(methodParameter.getParameterIndex() == -1 ?_				methodParameter.getMethodAnnotations() : methodParameter.getParameterAnnotations())__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,assert,not,null,method,parameter,method,parameter,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,method,parameter,get,parameter,type,this,annotated,element,new,annotated,element,adapter,method,parameter,get,parameter,index,1,method,parameter,get,method,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1479823020;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(methodParameter.getParameterType())__		this.annotatedElement = new AnnotatedElementAdapter(methodParameter.getParameterIndex() == -1 ?_				methodParameter.getMethodAnnotations() : methodParameter.getParameterAnnotations())__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,assert,not,null,method,parameter,method,parameter,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,method,parameter,get,parameter,type,this,annotated,element,new,annotated,element,adapter,method,parameter,get,parameter,index,1,method,parameter,get,method,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1479900301;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		Assert.notNull(methodParameter, "MethodParameter must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(methodParameter.getParameterType())__		this.annotatedElement = new AnnotatedElementAdapter(methodParameter.getParameterIndex() == -1 ?_				methodParameter.getMethodAnnotations() : methodParameter.getParameterAnnotations())__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,assert,not,null,method,parameter,method,parameter,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,method,parameter,get,parameter,type,this,annotated,element,new,annotated,element,adapter,method,parameter,get,parameter,index,1,method,parameter,get,method,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1480540964;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(methodParameter.getParameterType())__		this.annotatedElement = new AnnotatedElementAdapter(methodParameter.getParameterIndex() == -1 ?_				methodParameter.getMethodAnnotations() : methodParameter.getParameterAnnotations())__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,method,parameter,get,parameter,type,this,annotated,element,new,annotated,element,adapter,method,parameter,get,parameter,index,1,method,parameter,get,method,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1481578128;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(methodParameter.getParameterType())__		this.annotatedElement = new AnnotatedElementAdapter(methodParameter.getParameterIndex() == -1 ?_				methodParameter.getMethodAnnotations() : methodParameter.getParameterAnnotations())__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,method,parameter,get,parameter,type,this,annotated,element,new,annotated,element,adapter,method,parameter,get,parameter,index,1,method,parameter,get,method,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1482961889;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(methodParameter.getParameterType())__		this.annotatedElement = new AnnotatedElementAdapter(methodParameter.getParameterIndex() == -1 ?_				methodParameter.getMethodAnnotations() : methodParameter.getParameterAnnotations())__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,method,parameter,get,parameter,type,this,annotated,element,new,annotated,element,adapter,method,parameter,get,parameter,index,1,method,parameter,get,method,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1495868221;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(methodParameter.getParameterType())__		this.annotatedElement = new AnnotatedElementAdapter(methodParameter.getParameterIndex() == -1 ?_				methodParameter.getMethodAnnotations() : methodParameter.getParameterAnnotations())__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,method,parameter,get,parameter,type,this,annotated,element,new,annotated,element,adapter,method,parameter,get,parameter,index,1,method,parameter,get,method,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1496259743;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(methodParameter.getParameterType())__		this.annotatedElement = new AnnotatedElementAdapter(methodParameter.getParameterIndex() == -1 ?_				methodParameter.getMethodAnnotations() : methodParameter.getParameterAnnotations())__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,method,parameter,get,parameter,type,this,annotated,element,new,annotated,element,adapter,method,parameter,get,parameter,index,1,method,parameter,get,method,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1496837955;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(methodParameter.getParameterType())__		this.annotatedElement = new AnnotatedElementAdapter(methodParameter.getParameterIndex() == -1 ?_				methodParameter.getMethodAnnotations() : methodParameter.getParameterAnnotations())__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,method,parameter,get,parameter,type,this,annotated,element,new,annotated,element,adapter,method,parameter,get,parameter,index,1,method,parameter,get,method,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1498780456;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(methodParameter.getParameterType())__		this.annotatedElement = new AnnotatedElementAdapter(methodParameter.getParameterIndex() == -1 ?_				methodParameter.getMethodAnnotations() : methodParameter.getParameterAnnotations())__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,method,parameter,get,parameter,type,this,annotated,element,new,annotated,element,adapter,method,parameter,get,parameter,index,1,method,parameter,get,method,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1508084888;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(methodParameter.getParameterType())__		this.annotatedElement = new AnnotatedElementAdapter(methodParameter.getParameterIndex() == -1 ?_				methodParameter.getMethodAnnotations() : methodParameter.getParameterAnnotations())__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,method,parameter,get,parameter,type,this,annotated,element,new,annotated,element,adapter,method,parameter,get,parameter,index,1,method,parameter,get,method,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1522332300;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(methodParameter.getParameterType())__		this.annotatedElement = new AnnotatedElementAdapter(methodParameter.getParameterIndex() == -1 ?_				methodParameter.getMethodAnnotations() : methodParameter.getParameterAnnotations())__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,method,parameter,get,parameter,type,this,annotated,element,new,annotated,element,adapter,method,parameter,get,parameter,index,1,method,parameter,get,method,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1532520919;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(methodParameter.getParameterType())__		this.annotatedElement = new AnnotatedElementAdapter(methodParameter.getParameterIndex() == -1 ?_				methodParameter.getMethodAnnotations() : methodParameter.getParameterAnnotations())__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,method,parameter,get,parameter,type,this,annotated,element,new,annotated,element,adapter,method,parameter,get,parameter,index,1,method,parameter,get,method,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1546963887;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(methodParameter.getNestedParameterType())__		this.annotatedElement = new AnnotatedElementAdapter(methodParameter.getParameterIndex() == -1 ?_				methodParameter.getMethodAnnotations() : methodParameter.getParameterAnnotations())__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,method,parameter,get,nested,parameter,type,this,annotated,element,new,annotated,element,adapter,method,parameter,get,parameter,index,1,method,parameter,get,method,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> public TypeDescriptor(MethodParameter methodParameter);1547033218;Create a new type descriptor from a {@link MethodParameter}._<p>Use this constructor when a source or target conversion point is a_constructor parameter, method parameter, or method return value._@param methodParameter the method parameter;public TypeDescriptor(MethodParameter methodParameter) {_		this.resolvableType = ResolvableType.forMethodParameter(methodParameter)__		this.type = this.resolvableType.resolve(methodParameter.getNestedParameterType())__		this.annotatedElement = new AnnotatedElementAdapter(methodParameter.getParameterIndex() == -1 ?_				methodParameter.getMethodAnnotations() : methodParameter.getParameterAnnotations())__	};create,a,new,type,descriptor,from,a,link,method,parameter,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,constructor,parameter,method,parameter,or,method,return,value,param,method,parameter,the,method,parameter;public,type,descriptor,method,parameter,method,parameter,this,resolvable,type,resolvable,type,for,method,parameter,method,parameter,this,type,this,resolvable,type,resolve,method,parameter,get,nested,parameter,type,this,annotated,element,new,annotated,element,adapter,method,parameter,get,parameter,index,1,method,parameter,get,method,annotations,method,parameter,get,parameter,annotations
TypeDescriptor -> @Nullable 	public static TypeDescriptor forObject(@Nullable Object source);1495868221;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;@Nullable_	public static TypeDescriptor forObject(@Nullable Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;nullable,public,static,type,descriptor,for,object,nullable,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> @Nullable 	public static TypeDescriptor forObject(@Nullable Object source);1496259743;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;@Nullable_	public static TypeDescriptor forObject(@Nullable Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;nullable,public,static,type,descriptor,for,object,nullable,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> @Nullable 	public static TypeDescriptor forObject(@Nullable Object source);1496837955;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;@Nullable_	public static TypeDescriptor forObject(@Nullable Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;nullable,public,static,type,descriptor,for,object,nullable,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> @Nullable 	public static TypeDescriptor forObject(@Nullable Object source);1498780456;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;@Nullable_	public static TypeDescriptor forObject(@Nullable Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;nullable,public,static,type,descriptor,for,object,nullable,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> @Nullable 	public static TypeDescriptor forObject(@Nullable Object source);1508084888;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;@Nullable_	public static TypeDescriptor forObject(@Nullable Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;nullable,public,static,type,descriptor,for,object,nullable,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> @Nullable 	public static TypeDescriptor forObject(@Nullable Object source);1522332300;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;@Nullable_	public static TypeDescriptor forObject(@Nullable Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;nullable,public,static,type,descriptor,for,object,nullable,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> @Nullable 	public static TypeDescriptor forObject(@Nullable Object source);1532520919;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;@Nullable_	public static TypeDescriptor forObject(@Nullable Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;nullable,public,static,type,descriptor,for,object,nullable,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> @Nullable 	public static TypeDescriptor forObject(@Nullable Object source);1546963887;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;@Nullable_	public static TypeDescriptor forObject(@Nullable Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;nullable,public,static,type,descriptor,for,object,nullable,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> @Nullable 	public static TypeDescriptor forObject(@Nullable Object source);1547033218;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;@Nullable_	public static TypeDescriptor forObject(@Nullable Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;nullable,public,static,type,descriptor,for,object,nullable,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1362408075;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use_{@code TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))}._@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if(elementTypeDescriptor == null) {_			return null__		}_		Class<?> type = Array.newInstance(elementTypeDescriptor.getType(), 0).getClass()__		return new TypeDescriptor(type, elementTypeDescriptor, null, null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,class,type,array,new,instance,element,type,descriptor,get,type,0,get,class,return,new,type,descriptor,type,element,type,descriptor,null,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1368482696;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use_{@code TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))}._@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if(elementTypeDescriptor == null) {_			return null__		}_		Class<?> type = Array.newInstance(elementTypeDescriptor.getType(), 0).getClass()__		return new TypeDescriptor(type, elementTypeDescriptor, null, null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,class,type,array,new,instance,element,type,descriptor,get,type,0,get,class,return,new,type,descriptor,type,element,type,descriptor,null,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1374614239;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use_{@code TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))}._@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if(elementTypeDescriptor == null) {_			return null__		}_		Class<?> type = Array.newInstance(elementTypeDescriptor.getType(), 0).getClass()__		return new TypeDescriptor(type, elementTypeDescriptor, null, null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,class,type,array,new,instance,element,type,descriptor,get,type,0,get,class,return,new,type,descriptor,type,element,type,descriptor,null,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1382042882;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use_{@code TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))}._@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if(elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(_				ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1382119085;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use_{@code TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))}._@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if(elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(_				ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1382750081;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use_{@code TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))}._@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if(elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(_				ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1387307647;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use_{@code TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))}._@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if(elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(_				ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1387490898;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1389985540;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1390565795;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1390925810;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1391081201;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1391248381;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1394055372;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1395846555;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1403636229;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1405430015;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1406196817;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1412611699;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1414925289;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1417290561;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1419966315;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1424769447;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1424887506;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1425763631;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1431093918;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1432125256;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1441035153;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1448383050;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1450473050;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1467288171;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1467677340;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1467730834;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1477690406;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1478094883;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1479823020;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1479900301;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1480540964;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1481578128;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor);1482961889;Create a new type descriptor as an array of the specified type._<p>For example to create a {@code Map<String,String>[]} use:_<pre class="code">_TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)))__</pre>_@param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}_@return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}_@since 3.2.1;public static TypeDescriptor array(TypeDescriptor elementTypeDescriptor) {_		if (elementTypeDescriptor == null) {_			return null__		}_		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),_				null, elementTypeDescriptor.getAnnotations())__	};create,a,new,type,descriptor,as,an,array,of,the,specified,type,p,for,example,to,create,a,code,map,string,string,use,pre,class,code,type,descriptor,array,type,descriptor,map,map,class,type,descriptor,value,string,class,type,descriptor,value,string,class,pre,param,element,type,descriptor,the,link,type,descriptor,of,the,array,element,or,code,null,return,an,array,link,type,descriptor,or,code,null,if,code,element,type,descriptor,is,code,null,since,3,2,1;public,static,type,descriptor,array,type,descriptor,element,type,descriptor,if,element,type,descriptor,null,return,null,return,new,type,descriptor,resolvable,type,for,array,component,element,type,descriptor,resolvable,type,null,element,type,descriptor,get,annotations
TypeDescriptor -> public TypeDescriptor narrow(@Nullable Object value);1495868221;Narrows this {@link TypeDescriptor} by setting its type to the class of the_provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor_is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field,_or method return values. Allows such frameworks to narrow a TypeDescriptor built_from a declared property, field, or method return value type. For example, a field_declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor_can then be used to convert the HashMap to some other type. Annotation and nested_type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the_class of the provided value);public TypeDescriptor narrow(@Nullable Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), getResolvableType())__		return new TypeDescriptor(narrowed, value.getClass(), getAnnotations())__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,nullable,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,get,resolvable,type,return,new,type,descriptor,narrowed,value,get,class,get,annotations
TypeDescriptor -> public TypeDescriptor narrow(@Nullable Object value);1496259743;Narrows this {@link TypeDescriptor} by setting its type to the class of the_provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor_is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field,_or method return values. Allows such frameworks to narrow a TypeDescriptor built_from a declared property, field, or method return value type. For example, a field_declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor_can then be used to convert the HashMap to some other type. Annotation and nested_type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the_class of the provided value);public TypeDescriptor narrow(@Nullable Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), getResolvableType())__		return new TypeDescriptor(narrowed, value.getClass(), getAnnotations())__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,nullable,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,get,resolvable,type,return,new,type,descriptor,narrowed,value,get,class,get,annotations
TypeDescriptor -> public TypeDescriptor narrow(@Nullable Object value);1496837955;Narrows this {@link TypeDescriptor} by setting its type to the class of the_provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor_is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field,_or method return values. Allows such frameworks to narrow a TypeDescriptor built_from a declared property, field, or method return value type. For example, a field_declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor_can then be used to convert the HashMap to some other type. Annotation and nested_type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the_class of the provided value);public TypeDescriptor narrow(@Nullable Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), getResolvableType())__		return new TypeDescriptor(narrowed, value.getClass(), getAnnotations())__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,nullable,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,get,resolvable,type,return,new,type,descriptor,narrowed,value,get,class,get,annotations
TypeDescriptor -> public TypeDescriptor narrow(@Nullable Object value);1498780456;Narrows this {@link TypeDescriptor} by setting its type to the class of the_provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor_is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field,_or method return values. Allows such frameworks to narrow a TypeDescriptor built_from a declared property, field, or method return value type. For example, a field_declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor_can then be used to convert the HashMap to some other type. Annotation and nested_type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the_class of the provided value);public TypeDescriptor narrow(@Nullable Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), getResolvableType())__		return new TypeDescriptor(narrowed, value.getClass(), getAnnotations())__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,nullable,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,get,resolvable,type,return,new,type,descriptor,narrowed,value,get,class,get,annotations
TypeDescriptor -> public TypeDescriptor narrow(@Nullable Object value);1508084888;Narrows this {@link TypeDescriptor} by setting its type to the class of the_provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor_is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field,_or method return values. Allows such frameworks to narrow a TypeDescriptor built_from a declared property, field, or method return value type. For example, a field_declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor_can then be used to convert the HashMap to some other type. Annotation and nested_type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the_class of the provided value);public TypeDescriptor narrow(@Nullable Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), getResolvableType())__		return new TypeDescriptor(narrowed, value.getClass(), getAnnotations())__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,nullable,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,get,resolvable,type,return,new,type,descriptor,narrowed,value,get,class,get,annotations
TypeDescriptor -> public TypeDescriptor narrow(@Nullable Object value);1522332300;Narrows this {@link TypeDescriptor} by setting its type to the class of the_provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor_is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field,_or method return values. Allows such frameworks to narrow a TypeDescriptor built_from a declared property, field, or method return value type. For example, a field_declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor_can then be used to convert the HashMap to some other type. Annotation and nested_type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the_class of the provided value);public TypeDescriptor narrow(@Nullable Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), getResolvableType())__		return new TypeDescriptor(narrowed, value.getClass(), getAnnotations())__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,nullable,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,get,resolvable,type,return,new,type,descriptor,narrowed,value,get,class,get,annotations
TypeDescriptor -> public TypeDescriptor narrow(@Nullable Object value);1532520919;Narrows this {@link TypeDescriptor} by setting its type to the class of the_provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor_is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field,_or method return values. Allows such frameworks to narrow a TypeDescriptor built_from a declared property, field, or method return value type. For example, a field_declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor_can then be used to convert the HashMap to some other type. Annotation and nested_type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the_class of the provided value);public TypeDescriptor narrow(@Nullable Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), getResolvableType())__		return new TypeDescriptor(narrowed, value.getClass(), getAnnotations())__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,nullable,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,get,resolvable,type,return,new,type,descriptor,narrowed,value,get,class,get,annotations
TypeDescriptor -> public TypeDescriptor narrow(@Nullable Object value);1546963887;Narrows this {@link TypeDescriptor} by setting its type to the class of the_provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor_is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field,_or method return values. Allows such frameworks to narrow a TypeDescriptor built_from a declared property, field, or method return value type. For example, a field_declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor_can then be used to convert the HashMap to some other type. Annotation and nested_type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the_class of the provided value);public TypeDescriptor narrow(@Nullable Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), getResolvableType())__		return new TypeDescriptor(narrowed, value.getClass(), getAnnotations())__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,nullable,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,get,resolvable,type,return,new,type,descriptor,narrowed,value,get,class,get,annotations
TypeDescriptor -> public TypeDescriptor narrow(@Nullable Object value);1547033218;Narrows this {@link TypeDescriptor} by setting its type to the class of the_provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor_is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field,_or method return values. Allows such frameworks to narrow a TypeDescriptor built_from a declared property, field, or method return value type. For example, a field_declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor_can then be used to convert the HashMap to some other type. Annotation and nested_type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the_class of the provided value);public TypeDescriptor narrow(@Nullable Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), getResolvableType())__		return new TypeDescriptor(narrowed, value.getClass(), getAnnotations())__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,nullable,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,get,resolvable,type,return,new,type,descriptor,narrowed,value,get,class,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1328020251;Create a new type descriptor from a {@link Property}._Use this constructor when a source or target conversion point is a property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		this(new BeanPropertyDescriptor(property))__	};create,a,new,type,descriptor,from,a,link,property,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,this,new,bean,property,descriptor,property
TypeDescriptor -> public TypeDescriptor(Property property);1329142650;Create a new type descriptor from a {@link Property}._Use this constructor when a source or target conversion point is a property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		this(new BeanPropertyDescriptor(property))__	};create,a,new,type,descriptor,from,a,link,property,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,this,new,bean,property,descriptor,property
TypeDescriptor -> public TypeDescriptor(Property property);1335774711;Create a new type descriptor from a {@link Property}._Use this constructor when a source or target conversion point is a property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		this(new BeanPropertyDescriptor(property))__	};create,a,new,type,descriptor,from,a,link,property,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,this,new,bean,property,descriptor,property
TypeDescriptor -> public TypeDescriptor(Property property);1349907422;Create a new type descriptor from a {@link Property}._Use this constructor when a source or target conversion point is a property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		this(new BeanPropertyDescriptor(property))__	};create,a,new,type,descriptor,from,a,link,property,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,this,new,bean,property,descriptor,property
TypeDescriptor -> public TypeDescriptor(Property property);1351584957;Create a new type descriptor from a {@link Property}._Use this constructor when a source or target conversion point is a property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		this(new BeanPropertyDescriptor(property))__	};create,a,new,type,descriptor,from,a,link,property,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,this,new,bean,property,descriptor,property
TypeDescriptor -> public TypeDescriptor(Property property);1351648403;Create a new type descriptor from a {@link Property}._Use this constructor when a source or target conversion point is a property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		this(new BeanPropertyDescriptor(property))__	};create,a,new,type,descriptor,from,a,link,property,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,this,new,bean,property,descriptor,property
TypeDescriptor -> public TypeDescriptor(Property property);1356735495;Create a new type descriptor from a {@link Property}._Use this constructor when a source or target conversion point is a property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		this(new BeanPropertyDescriptor(property))__	};create,a,new,type,descriptor,from,a,link,property,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,this,new,bean,property,descriptor,property
TypeDescriptor -> public TypeDescriptor(Property property);1362408075;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		this(new BeanPropertyDescriptor(property))__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,this,new,bean,property,descriptor,property
TypeDescriptor -> public TypeDescriptor(Property property);1368482696;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		this(new BeanPropertyDescriptor(property))__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,this,new,bean,property,descriptor,property
TypeDescriptor -> public TypeDescriptor(Property property);1374614239;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		this(new BeanPropertyDescriptor(property))__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,this,new,bean,property,descriptor,property
TypeDescriptor -> public TypeDescriptor(Property property);1382042882;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(Object.class)__		this.annotations = nullSafeAnnotations(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1382119085;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(Object.class)__		this.annotations = nullSafeAnnotations(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1382750081;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(Object.class)__		this.annotations = nullSafeAnnotations(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1387307647;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(Object.class)__		this.annotations = nullSafeAnnotations(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1387490898;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(Object.class)__		this.annotations = nullSafeAnnotations(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1389985540;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(Object.class)__		this.annotations = nullSafeAnnotations(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1390565795;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(Object.class)__		this.annotations = nullSafeAnnotations(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1390925810;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotations = nullSafeAnnotations(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotations,null,safe,annotations,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1391081201;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotations = nullSafeAnnotations(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotations,null,safe,annotations,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1391248381;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotations = nullSafeAnnotations(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotations,null,safe,annotations,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1394055372;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotations = nullSafeAnnotations(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotations,null,safe,annotations,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1395846555;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotations = nullSafeAnnotations(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotations,null,safe,annotations,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1403636229;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotations = nullSafeAnnotations(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotations,null,safe,annotations,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1405430015;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotations = nullSafeAnnotations(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotations,null,safe,annotations,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1406196817;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotations = nullSafeAnnotations(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotations,null,safe,annotations,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1412611699;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotations = nullSafeAnnotations(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotations,null,safe,annotations,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1414925289;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotations = nullSafeAnnotations(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotations,null,safe,annotations,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1417290561;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotations = nullSafeAnnotations(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotations,null,safe,annotations,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1419966315;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotations = nullSafeAnnotations(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotations,null,safe,annotations,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1424769447;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotations = nullSafeAnnotations(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotations,null,safe,annotations,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1424887506;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotations = nullSafeAnnotations(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotations,null,safe,annotations,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1425763631;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotations = nullSafeAnnotations(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotations,null,safe,annotations,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1431093918;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotations = nullSafeAnnotations(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotations,null,safe,annotations,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1432125256;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotations = nullSafeAnnotations(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotations,null,safe,annotations,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1441035153;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotations = nullSafeAnnotations(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotations,null,safe,annotations,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1448383050;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotations = nullSafeAnnotations(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotations,null,safe,annotations,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1450473050;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotations = nullSafeAnnotations(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotations,null,safe,annotations,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1467288171;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotations = nullSafeAnnotations(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotations,null,safe,annotations,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1467677340;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotations = nullSafeAnnotations(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotations,null,safe,annotations,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1467730834;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotations = nullSafeAnnotations(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotations,null,safe,annotations,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1477690406;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotatedElement = new AnnotatedElementAdapter(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotated,element,new,annotated,element,adapter,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1478094883;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotatedElement = new AnnotatedElementAdapter(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotated,element,new,annotated,element,adapter,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1479823020;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotatedElement = new AnnotatedElementAdapter(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotated,element,new,annotated,element,adapter,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1479900301;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotatedElement = new AnnotatedElementAdapter(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotated,element,new,annotated,element,adapter,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1480540964;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotatedElement = new AnnotatedElementAdapter(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotated,element,new,annotated,element,adapter,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1481578128;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotatedElement = new AnnotatedElementAdapter(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotated,element,new,annotated,element,adapter,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1482961889;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotatedElement = new AnnotatedElementAdapter(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotated,element,new,annotated,element,adapter,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1495868221;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotatedElement = new AnnotatedElementAdapter(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotated,element,new,annotated,element,adapter,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1496259743;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotatedElement = new AnnotatedElementAdapter(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotated,element,new,annotated,element,adapter,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1496837955;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotatedElement = new AnnotatedElementAdapter(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotated,element,new,annotated,element,adapter,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1498780456;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotatedElement = new AnnotatedElementAdapter(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotated,element,new,annotated,element,adapter,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1508084888;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotatedElement = new AnnotatedElementAdapter(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotated,element,new,annotated,element,adapter,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1522332300;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotatedElement = new AnnotatedElementAdapter(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotated,element,new,annotated,element,adapter,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1532520919;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotatedElement = new AnnotatedElementAdapter(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotated,element,new,annotated,element,adapter,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1546963887;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotatedElement = new AnnotatedElementAdapter(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotated,element,new,annotated,element,adapter,property,get,annotations
TypeDescriptor -> public TypeDescriptor(Property property);1547033218;Create a new type descriptor from a {@link Property}._<p>Use this constructor when a source or target conversion point is a_property on a Java class._@param property the property;public TypeDescriptor(Property property) {_		Assert.notNull(property, "Property must not be null")__		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter())__		this.type = this.resolvableType.resolve(property.getType())__		this.annotatedElement = new AnnotatedElementAdapter(property.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,property,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,property,on,a,java,class,param,property,the,property;public,type,descriptor,property,property,assert,not,null,property,property,must,not,be,null,this,resolvable,type,resolvable,type,for,method,parameter,property,get,method,parameter,this,type,this,resolvable,type,resolve,property,get,type,this,annotated,element,new,annotated,element,adapter,property,get,annotations
TypeDescriptor -> public TypeDescriptor(ResolvableType resolvableType, @Nullable Class<?> type, @Nullable Annotation[] annotations);1546963887;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type (or {@code null} if it should get resolved)_@param annotations the type annotations_@since 4.0;public TypeDescriptor(ResolvableType resolvableType, @Nullable Class<?> type, @Nullable Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.toClass())__		this.annotatedElement = new AnnotatedElementAdapter(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,it,should,get,resolved,param,annotations,the,type,annotations,since,4,0;public,type,descriptor,resolvable,type,resolvable,type,nullable,class,type,nullable,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,to,class,this,annotated,element,new,annotated,element,adapter,annotations
TypeDescriptor -> public TypeDescriptor(ResolvableType resolvableType, @Nullable Class<?> type, @Nullable Annotation[] annotations);1547033218;Create a new type descriptor from a {@link ResolvableType}._<p>This constructor is used internally and may also be used by subclasses_that support non-Java languages with extended type systems. It is public_as of 5.1.4 whereas it was protected before._@param resolvableType the resolvable type_@param type the backing type (or {@code null} if it should get resolved)_@param annotations the type annotations_@since 4.0;public TypeDescriptor(ResolvableType resolvableType, @Nullable Class<?> type, @Nullable Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.toClass())__		this.annotatedElement = new AnnotatedElementAdapter(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,p,this,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,it,is,public,as,of,5,1,4,whereas,it,was,protected,before,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,it,should,get,resolved,param,annotations,the,type,annotations,since,4,0;public,type,descriptor,resolvable,type,resolvable,type,nullable,class,type,nullable,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,to,class,this,annotated,element,new,annotated,element,adapter,annotations
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1328020251;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a <code>List&lt_String&gt_</code> and the nestingLevel is 1, the nested type descriptor will be <code>String.class</code>._If the field is a <code>List&lt_List&lt_String&gt_&gt_</code> and the nestingLevel is 2, the nested type descriptor will also be a <code>String.class</code>._If the field is a <code>Map&lt_Integer, String&gt_</code> and the nestingLevel is 1, the nested type descriptor will be String, derived from the map value._If the field is a <code>List&lt_Map&lt_Integer, String&gt_&gt_</code> and the nestingLevel is 2, the nested type descriptor will be String, derived from the map value._Returns <code>null</code> if a nested type cannot be obtained because it was not declared._For example, if the field is a <code>List&lt_?&gt_</code>, the nested type descriptor returned will be <code>null</code>._@param field the field_@param nestingLevel the nesting level of the collection/array element or map key/value declaration within the field._@return the nested type descriptor at the specified nestingLevel, or null if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting level are not of collection, array, or map types.;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new FieldDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,lt,string,gt,code,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,code,if,the,field,is,a,code,list,lt,list,lt,string,gt,gt,code,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,code,if,the,field,is,a,code,map,lt,integer,string,gt,code,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,if,the,field,is,a,code,list,lt,map,lt,integer,string,gt,gt,code,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,returns,code,null,code,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,lt,gt,code,the,nested,type,descriptor,returned,will,be,code,null,code,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,field,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1329142650;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a <code>List&lt_String&gt_</code> and the nestingLevel is 1, the nested type descriptor will be <code>String.class</code>._If the field is a <code>List&lt_List&lt_String&gt_&gt_</code> and the nestingLevel is 2, the nested type descriptor will also be a <code>String.class</code>._If the field is a <code>Map&lt_Integer, String&gt_</code> and the nestingLevel is 1, the nested type descriptor will be String, derived from the map value._If the field is a <code>List&lt_Map&lt_Integer, String&gt_&gt_</code> and the nestingLevel is 2, the nested type descriptor will be String, derived from the map value._Returns <code>null</code> if a nested type cannot be obtained because it was not declared._For example, if the field is a <code>List&lt_?&gt_</code>, the nested type descriptor returned will be <code>null</code>._@param field the field_@param nestingLevel the nesting level of the collection/array element or map key/value declaration within the field._@return the nested type descriptor at the specified nestingLevel, or null if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting level are not of collection, array, or map types.;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new FieldDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,lt,string,gt,code,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,code,if,the,field,is,a,code,list,lt,list,lt,string,gt,gt,code,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,code,if,the,field,is,a,code,map,lt,integer,string,gt,code,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,if,the,field,is,a,code,list,lt,map,lt,integer,string,gt,gt,code,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,returns,code,null,code,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,lt,gt,code,the,nested,type,descriptor,returned,will,be,code,null,code,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,field,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1335774711;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a <code>List&lt_String&gt_</code> and the nestingLevel is 1, the nested type descriptor will be <code>String.class</code>._If the field is a <code>List&lt_List&lt_String&gt_&gt_</code> and the nestingLevel is 2, the nested type descriptor will also be a <code>String.class</code>._If the field is a <code>Map&lt_Integer, String&gt_</code> and the nestingLevel is 1, the nested type descriptor will be String, derived from the map value._If the field is a <code>List&lt_Map&lt_Integer, String&gt_&gt_</code> and the nestingLevel is 2, the nested type descriptor will be String, derived from the map value._Returns <code>null</code> if a nested type cannot be obtained because it was not declared._For example, if the field is a <code>List&lt_?&gt_</code>, the nested type descriptor returned will be <code>null</code>._@param field the field_@param nestingLevel the nesting level of the collection/array element or map key/value declaration within the field._@return the nested type descriptor at the specified nestingLevel, or null if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting level are not of collection, array, or map types.;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new FieldDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,lt,string,gt,code,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,code,if,the,field,is,a,code,list,lt,list,lt,string,gt,gt,code,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,code,if,the,field,is,a,code,map,lt,integer,string,gt,code,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,if,the,field,is,a,code,list,lt,map,lt,integer,string,gt,gt,code,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,returns,code,null,code,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,lt,gt,code,the,nested,type,descriptor,returned,will,be,code,null,code,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,field,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1349907422;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a <code>List&lt_String&gt_</code> and the nestingLevel is 1, the nested type descriptor will be <code>String.class</code>._If the field is a <code>List&lt_List&lt_String&gt_&gt_</code> and the nestingLevel is 2, the nested type descriptor will also be a <code>String.class</code>._If the field is a <code>Map&lt_Integer, String&gt_</code> and the nestingLevel is 1, the nested type descriptor will be String, derived from the map value._If the field is a <code>List&lt_Map&lt_Integer, String&gt_&gt_</code> and the nestingLevel is 2, the nested type descriptor will be String, derived from the map value._Returns <code>null</code> if a nested type cannot be obtained because it was not declared._For example, if the field is a <code>List&lt_?&gt_</code>, the nested type descriptor returned will be <code>null</code>._@param field the field_@param nestingLevel the nesting level of the collection/array element or map key/value declaration within the field_@return the nested type descriptor at the specified nestingLevel, or null if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new FieldDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,lt,string,gt,code,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,code,if,the,field,is,a,code,list,lt,list,lt,string,gt,gt,code,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,code,if,the,field,is,a,code,map,lt,integer,string,gt,code,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,if,the,field,is,a,code,list,lt,map,lt,integer,string,gt,gt,code,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,returns,code,null,code,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,lt,gt,code,the,nested,type,descriptor,returned,will,be,code,null,code,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,field,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1351584957;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a <code>List&lt_String&gt_</code> and the nestingLevel is 1, the nested type descriptor will be <code>String.class</code>._If the field is a <code>List&lt_List&lt_String&gt_&gt_</code> and the nestingLevel is 2, the nested type descriptor will also be a <code>String.class</code>._If the field is a <code>Map&lt_Integer, String&gt_</code> and the nestingLevel is 1, the nested type descriptor will be String, derived from the map value._If the field is a <code>List&lt_Map&lt_Integer, String&gt_&gt_</code> and the nestingLevel is 2, the nested type descriptor will be String, derived from the map value._Returns <code>null</code> if a nested type cannot be obtained because it was not declared._For example, if the field is a <code>List&lt_?&gt_</code>, the nested type descriptor returned will be <code>null</code>._@param field the field_@param nestingLevel the nesting level of the collection/array element or map key/value declaration within the field_@return the nested type descriptor at the specified nestingLevel, or null if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new FieldDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,lt,string,gt,code,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,code,if,the,field,is,a,code,list,lt,list,lt,string,gt,gt,code,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,code,if,the,field,is,a,code,map,lt,integer,string,gt,code,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,if,the,field,is,a,code,list,lt,map,lt,integer,string,gt,gt,code,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,returns,code,null,code,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,lt,gt,code,the,nested,type,descriptor,returned,will,be,code,null,code,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,field,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1351648403;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a <code>List&lt_String&gt_</code> and the nestingLevel is 1, the nested type descriptor will be <code>String.class</code>._If the field is a <code>List&lt_List&lt_String&gt_&gt_</code> and the nestingLevel is 2, the nested type descriptor will also be a <code>String.class</code>._If the field is a <code>Map&lt_Integer, String&gt_</code> and the nestingLevel is 1, the nested type descriptor will be String, derived from the map value._If the field is a <code>List&lt_Map&lt_Integer, String&gt_&gt_</code> and the nestingLevel is 2, the nested type descriptor will be String, derived from the map value._Returns <code>null</code> if a nested type cannot be obtained because it was not declared._For example, if the field is a <code>List&lt_?&gt_</code>, the nested type descriptor returned will be <code>null</code>._@param field the field_@param nestingLevel the nesting level of the collection/array element or map key/value declaration within the field_@return the nested type descriptor at the specified nestingLevel, or null if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new FieldDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,lt,string,gt,code,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,code,if,the,field,is,a,code,list,lt,list,lt,string,gt,gt,code,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,code,if,the,field,is,a,code,map,lt,integer,string,gt,code,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,if,the,field,is,a,code,list,lt,map,lt,integer,string,gt,gt,code,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,returns,code,null,code,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,lt,gt,code,the,nested,type,descriptor,returned,will,be,code,null,code,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,field,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1356735495;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List&lt_String&gt_} and the nestingLevel is 1, the nested type descriptor will be {@code String.class}._If the field is a {@code List&lt_List&lt_String&gt_&gt_} and the nestingLevel is 2, the nested type descriptor will also be a {@code String.class}._If the field is a {@code Map&lt_Integer, String&gt_} and the nestingLevel is 1, the nested type descriptor will be String, derived from the map value._If the field is a {@code List&lt_Map&lt_Integer, String&gt_&gt_} and the nestingLevel is 2, the nested type descriptor will be String, derived from the map value._Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List&lt_?&gt_}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or map key/value declaration within the field_@return the nested type descriptor at the specified nestingLevel, or null if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new FieldDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,lt,string,gt,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,if,the,field,is,a,code,list,lt,list,lt,string,gt,gt,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,if,the,field,is,a,code,map,lt,integer,string,gt,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,if,the,field,is,a,code,list,lt,map,lt,integer,string,gt,gt,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,lt,gt,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,field,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1362408075;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level, or null_if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new FieldDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,field,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1368482696;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level, or null_if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new FieldDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,field,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1374614239;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level, or null_if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new FieldDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,field,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1382042882;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level, or null_if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1382119085;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level, or null_if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1382750081;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level, or null_if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1387307647;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level, or null_if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1387490898;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level, or null_if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1389985540;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level, or null_if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1390565795;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level, or null_if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1390925810;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level, or null_if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1391081201;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level, or null_if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1391248381;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level, or null_if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1394055372;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1395846555;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1403636229;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1405430015;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1406196817;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1412611699;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1414925289;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1417290561;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1419966315;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1424769447;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1424887506;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1425763631;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1431093918;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1432125256;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1441035153;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1448383050;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1450473050;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1467288171;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1467677340;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1467730834;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1477690406;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1478094883;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1479823020;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1479900301;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1480540964;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1481578128;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Field field, int nestingLevel);1482961889;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> @Nullable 	public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1495868221;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;@Nullable_	public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;nullable,public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> @Nullable 	public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1496259743;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;@Nullable_	public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;nullable,public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> @Nullable 	public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1496837955;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;@Nullable_	public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;nullable,public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> @Nullable 	public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1498780456;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;@Nullable_	public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;nullable,public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> @Nullable 	public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1508084888;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;@Nullable_	public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;nullable,public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> @Nullable 	public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1522332300;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;@Nullable_	public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;nullable,public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> @Nullable 	public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1532520919;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;@Nullable_	public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;nullable,public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> @Nullable 	public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1546963887;Create a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;@Nullable_	public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};create,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;nullable,public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> @Nullable 	public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1547033218;Create a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;@Nullable_	public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};create,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;nullable,public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1328020251;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a <code>List&lt_String&gt_</code> and the nestingLevel is 1, the nested type descriptor will be <code>String.class</code>._If the property is a <code>List&lt_List&lt_String&gt_&gt_</code> and the nestingLevel is 2, the nested type descriptor will also be a <code>String.class</code>._If the property is a <code>Map&lt_Integer, String&gt_</code> and the nestingLevel is 1, the nested type descriptor will be String, derived from the map value._If the property is a <code>List&lt_Map&lt_Integer, String&gt_&gt_</code> and the nestingLevel is 2, the nested type descriptor will be String, derived from the map value._Returns <code>null</code> if a nested type cannot be obtained because it was not declared._For example, if the property is a <code>List&lt_?&gt_</code>, the nested type descriptor returned will be <code>null</code>._@param property the property_@param nestingLevel the nesting level of the collection/array element or map key/value declaration within the property._@return the nested type descriptor at the specified nestingLevel, or <code>null</code> if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting level are not of collection, array, or map types.;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new BeanPropertyDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,lt,string,gt,code,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,code,if,the,property,is,a,code,list,lt,list,lt,string,gt,gt,code,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,code,if,the,property,is,a,code,map,lt,integer,string,gt,code,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,if,the,property,is,a,code,list,lt,map,lt,integer,string,gt,gt,code,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,returns,code,null,code,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,lt,gt,code,the,nested,type,descriptor,returned,will,be,code,null,code,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,code,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,bean,property,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1329142650;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a <code>List&lt_String&gt_</code> and the nestingLevel is 1, the nested type descriptor will be <code>String.class</code>._If the property is a <code>List&lt_List&lt_String&gt_&gt_</code> and the nestingLevel is 2, the nested type descriptor will also be a <code>String.class</code>._If the property is a <code>Map&lt_Integer, String&gt_</code> and the nestingLevel is 1, the nested type descriptor will be String, derived from the map value._If the property is a <code>List&lt_Map&lt_Integer, String&gt_&gt_</code> and the nestingLevel is 2, the nested type descriptor will be String, derived from the map value._Returns <code>null</code> if a nested type cannot be obtained because it was not declared._For example, if the property is a <code>List&lt_?&gt_</code>, the nested type descriptor returned will be <code>null</code>._@param property the property_@param nestingLevel the nesting level of the collection/array element or map key/value declaration within the property._@return the nested type descriptor at the specified nestingLevel, or <code>null</code> if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting level are not of collection, array, or map types.;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new BeanPropertyDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,lt,string,gt,code,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,code,if,the,property,is,a,code,list,lt,list,lt,string,gt,gt,code,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,code,if,the,property,is,a,code,map,lt,integer,string,gt,code,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,if,the,property,is,a,code,list,lt,map,lt,integer,string,gt,gt,code,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,returns,code,null,code,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,lt,gt,code,the,nested,type,descriptor,returned,will,be,code,null,code,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,code,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,bean,property,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1335774711;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a <code>List&lt_String&gt_</code> and the nestingLevel is 1, the nested type descriptor will be <code>String.class</code>._If the property is a <code>List&lt_List&lt_String&gt_&gt_</code> and the nestingLevel is 2, the nested type descriptor will also be a <code>String.class</code>._If the property is a <code>Map&lt_Integer, String&gt_</code> and the nestingLevel is 1, the nested type descriptor will be String, derived from the map value._If the property is a <code>List&lt_Map&lt_Integer, String&gt_&gt_</code> and the nestingLevel is 2, the nested type descriptor will be String, derived from the map value._Returns <code>null</code> if a nested type cannot be obtained because it was not declared._For example, if the property is a <code>List&lt_?&gt_</code>, the nested type descriptor returned will be <code>null</code>._@param property the property_@param nestingLevel the nesting level of the collection/array element or map key/value declaration within the property._@return the nested type descriptor at the specified nestingLevel, or <code>null</code> if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting level are not of collection, array, or map types.;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new BeanPropertyDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,lt,string,gt,code,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,code,if,the,property,is,a,code,list,lt,list,lt,string,gt,gt,code,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,code,if,the,property,is,a,code,map,lt,integer,string,gt,code,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,if,the,property,is,a,code,list,lt,map,lt,integer,string,gt,gt,code,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,returns,code,null,code,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,lt,gt,code,the,nested,type,descriptor,returned,will,be,code,null,code,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,code,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,bean,property,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1349907422;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a <code>List&lt_String&gt_</code> and the nestingLevel is 1, the nested type descriptor will be <code>String.class</code>._If the property is a <code>List&lt_List&lt_String&gt_&gt_</code> and the nestingLevel is 2, the nested type descriptor will also be a <code>String.class</code>._If the property is a <code>Map&lt_Integer, String&gt_</code> and the nestingLevel is 1, the nested type descriptor will be String, derived from the map value._If the property is a <code>List&lt_Map&lt_Integer, String&gt_&gt_</code> and the nestingLevel is 2, the nested type descriptor will be String, derived from the map value._Returns <code>null</code> if a nested type cannot be obtained because it was not declared._For example, if the property is a <code>List&lt_?&gt_</code>, the nested type descriptor returned will be <code>null</code>._@param property the property_@param nestingLevel the nesting level of the collection/array element or map key/value declaration within the property_@return the nested type descriptor at the specified nestingLevel, or <code>null</code> if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new BeanPropertyDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,lt,string,gt,code,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,code,if,the,property,is,a,code,list,lt,list,lt,string,gt,gt,code,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,code,if,the,property,is,a,code,map,lt,integer,string,gt,code,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,if,the,property,is,a,code,list,lt,map,lt,integer,string,gt,gt,code,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,returns,code,null,code,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,lt,gt,code,the,nested,type,descriptor,returned,will,be,code,null,code,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,code,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,bean,property,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1351584957;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a <code>List&lt_String&gt_</code> and the nestingLevel is 1, the nested type descriptor will be <code>String.class</code>._If the property is a <code>List&lt_List&lt_String&gt_&gt_</code> and the nestingLevel is 2, the nested type descriptor will also be a <code>String.class</code>._If the property is a <code>Map&lt_Integer, String&gt_</code> and the nestingLevel is 1, the nested type descriptor will be String, derived from the map value._If the property is a <code>List&lt_Map&lt_Integer, String&gt_&gt_</code> and the nestingLevel is 2, the nested type descriptor will be String, derived from the map value._Returns <code>null</code> if a nested type cannot be obtained because it was not declared._For example, if the property is a <code>List&lt_?&gt_</code>, the nested type descriptor returned will be <code>null</code>._@param property the property_@param nestingLevel the nesting level of the collection/array element or map key/value declaration within the property_@return the nested type descriptor at the specified nestingLevel, or <code>null</code> if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new BeanPropertyDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,lt,string,gt,code,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,code,if,the,property,is,a,code,list,lt,list,lt,string,gt,gt,code,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,code,if,the,property,is,a,code,map,lt,integer,string,gt,code,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,if,the,property,is,a,code,list,lt,map,lt,integer,string,gt,gt,code,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,returns,code,null,code,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,lt,gt,code,the,nested,type,descriptor,returned,will,be,code,null,code,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,code,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,bean,property,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1351648403;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a <code>List&lt_String&gt_</code> and the nestingLevel is 1, the nested type descriptor will be <code>String.class</code>._If the property is a <code>List&lt_List&lt_String&gt_&gt_</code> and the nestingLevel is 2, the nested type descriptor will also be a <code>String.class</code>._If the property is a <code>Map&lt_Integer, String&gt_</code> and the nestingLevel is 1, the nested type descriptor will be String, derived from the map value._If the property is a <code>List&lt_Map&lt_Integer, String&gt_&gt_</code> and the nestingLevel is 2, the nested type descriptor will be String, derived from the map value._Returns <code>null</code> if a nested type cannot be obtained because it was not declared._For example, if the property is a <code>List&lt_?&gt_</code>, the nested type descriptor returned will be <code>null</code>._@param property the property_@param nestingLevel the nesting level of the collection/array element or map key/value declaration within the property_@return the nested type descriptor at the specified nestingLevel, or <code>null</code> if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new BeanPropertyDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,lt,string,gt,code,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,code,if,the,property,is,a,code,list,lt,list,lt,string,gt,gt,code,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,code,if,the,property,is,a,code,map,lt,integer,string,gt,code,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,if,the,property,is,a,code,list,lt,map,lt,integer,string,gt,gt,code,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,returns,code,null,code,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,lt,gt,code,the,nested,type,descriptor,returned,will,be,code,null,code,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,code,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,bean,property,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1356735495;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List&lt_String&gt_} and the nestingLevel is 1, the nested type descriptor will be {@code String.class}._If the property is a {@code List&lt_List&lt_String&gt_&gt_} and the nestingLevel is 2, the nested type descriptor will also be a {@code String.class}._If the property is a {@code Map&lt_Integer, String&gt_} and the nestingLevel is 1, the nested type descriptor will be String, derived from the map value._If the property is a {@code List&lt_Map&lt_Integer, String&gt_&gt_} and the nestingLevel is 2, the nested type descriptor will be String, derived from the map value._Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List&lt_?&gt_}, the nested type descriptor returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or map key/value declaration within the property_@return the nested type descriptor at the specified nestingLevel, or {@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new BeanPropertyDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,lt,string,gt,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,if,the,property,is,a,code,list,lt,list,lt,string,gt,gt,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,if,the,property,is,a,code,map,lt,integer,string,gt,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,if,the,property,is,a,code,list,lt,map,lt,integer,string,gt,gt,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,lt,gt,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,bean,property,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1362408075;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new BeanPropertyDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,bean,property,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1368482696;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new BeanPropertyDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,bean,property,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1374614239;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new BeanPropertyDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,bean,property,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1382042882;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1382119085;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1382750081;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1387307647;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1387490898;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1389985540;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1390565795;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1390925810;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1391081201;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1391248381;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1394055372;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1395846555;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1403636229;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1405430015;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1406196817;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1412611699;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1414925289;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1417290561;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1419966315;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1424769447;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1424887506;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1425763631;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1431093918;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1432125256;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1441035153;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1448383050;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1450473050;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1467288171;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1467677340;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1467730834;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1477690406;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1478094883;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1479823020;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1479900301;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1480540964;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1481578128;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(Property property, int nestingLevel);1482961889;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> protected TypeDescriptor(ResolvableType resolvableType, @Nullable Class<?> type, @Nullable Annotation[] annotations);1496259743;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type (or {@code null} if it should get resolved)_@param annotations the type annotations_@since 4.0;protected TypeDescriptor(ResolvableType resolvableType, @Nullable Class<?> type, @Nullable Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.resolve(Object.class))__		this.annotatedElement = new AnnotatedElementAdapter(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,it,should,get,resolved,param,annotations,the,type,annotations,since,4,0;protected,type,descriptor,resolvable,type,resolvable,type,nullable,class,type,nullable,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,resolve,object,class,this,annotated,element,new,annotated,element,adapter,annotations
TypeDescriptor -> protected TypeDescriptor(ResolvableType resolvableType, @Nullable Class<?> type, @Nullable Annotation[] annotations);1496837955;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type (or {@code null} if it should get resolved)_@param annotations the type annotations_@since 4.0;protected TypeDescriptor(ResolvableType resolvableType, @Nullable Class<?> type, @Nullable Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.resolve(Object.class))__		this.annotatedElement = new AnnotatedElementAdapter(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,it,should,get,resolved,param,annotations,the,type,annotations,since,4,0;protected,type,descriptor,resolvable,type,resolvable,type,nullable,class,type,nullable,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,resolve,object,class,this,annotated,element,new,annotated,element,adapter,annotations
TypeDescriptor -> protected TypeDescriptor(ResolvableType resolvableType, @Nullable Class<?> type, @Nullable Annotation[] annotations);1498780456;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type (or {@code null} if it should get resolved)_@param annotations the type annotations_@since 4.0;protected TypeDescriptor(ResolvableType resolvableType, @Nullable Class<?> type, @Nullable Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.resolve(Object.class))__		this.annotatedElement = new AnnotatedElementAdapter(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,it,should,get,resolved,param,annotations,the,type,annotations,since,4,0;protected,type,descriptor,resolvable,type,resolvable,type,nullable,class,type,nullable,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,resolve,object,class,this,annotated,element,new,annotated,element,adapter,annotations
TypeDescriptor -> protected TypeDescriptor(ResolvableType resolvableType, @Nullable Class<?> type, @Nullable Annotation[] annotations);1508084888;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type (or {@code null} if it should get resolved)_@param annotations the type annotations_@since 4.0;protected TypeDescriptor(ResolvableType resolvableType, @Nullable Class<?> type, @Nullable Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.resolve(Object.class))__		this.annotatedElement = new AnnotatedElementAdapter(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,it,should,get,resolved,param,annotations,the,type,annotations,since,4,0;protected,type,descriptor,resolvable,type,resolvable,type,nullable,class,type,nullable,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,resolve,object,class,this,annotated,element,new,annotated,element,adapter,annotations
TypeDescriptor -> protected TypeDescriptor(ResolvableType resolvableType, @Nullable Class<?> type, @Nullable Annotation[] annotations);1522332300;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type (or {@code null} if it should get resolved)_@param annotations the type annotations_@since 4.0;protected TypeDescriptor(ResolvableType resolvableType, @Nullable Class<?> type, @Nullable Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.resolve(Object.class))__		this.annotatedElement = new AnnotatedElementAdapter(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,it,should,get,resolved,param,annotations,the,type,annotations,since,4,0;protected,type,descriptor,resolvable,type,resolvable,type,nullable,class,type,nullable,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,resolve,object,class,this,annotated,element,new,annotated,element,adapter,annotations
TypeDescriptor -> protected TypeDescriptor(ResolvableType resolvableType, @Nullable Class<?> type, @Nullable Annotation[] annotations);1532520919;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type (or {@code null} if it should get resolved)_@param annotations the type annotations_@since 4.0;protected TypeDescriptor(ResolvableType resolvableType, @Nullable Class<?> type, @Nullable Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.toClass())__		this.annotatedElement = new AnnotatedElementAdapter(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,it,should,get,resolved,param,annotations,the,type,annotations,since,4,0;protected,type,descriptor,resolvable,type,resolvable,type,nullable,class,type,nullable,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,to,class,this,annotated,element,new,annotated,element,adapter,annotations
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, @Nullable TypeDescriptor keyTypeDescriptor, 			@Nullable TypeDescriptor valueTypeDescriptor);1496837955;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, @Nullable TypeDescriptor keyTypeDescriptor,_			@Nullable TypeDescriptor valueTypeDescriptor) {__		Assert.notNull(mapType, "Map type must not be null")__		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("Map type must be a [java.util.Map]")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,nullable,type,descriptor,key,type,descriptor,nullable,type,descriptor,value,type,descriptor,assert,not,null,map,type,map,type,must,not,be,null,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, @Nullable TypeDescriptor keyTypeDescriptor, 			@Nullable TypeDescriptor valueTypeDescriptor);1498780456;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, @Nullable TypeDescriptor keyTypeDescriptor,_			@Nullable TypeDescriptor valueTypeDescriptor) {__		Assert.notNull(mapType, "Map type must not be null")__		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("Map type must be a [java.util.Map]")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,nullable,type,descriptor,key,type,descriptor,nullable,type,descriptor,value,type,descriptor,assert,not,null,map,type,map,type,must,not,be,null,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, @Nullable TypeDescriptor keyTypeDescriptor, 			@Nullable TypeDescriptor valueTypeDescriptor);1508084888;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, @Nullable TypeDescriptor keyTypeDescriptor,_			@Nullable TypeDescriptor valueTypeDescriptor) {__		Assert.notNull(mapType, "Map type must not be null")__		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("Map type must be a [java.util.Map]")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,nullable,type,descriptor,key,type,descriptor,nullable,type,descriptor,value,type,descriptor,assert,not,null,map,type,map,type,must,not,be,null,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, @Nullable TypeDescriptor keyTypeDescriptor, 			@Nullable TypeDescriptor valueTypeDescriptor);1522332300;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, @Nullable TypeDescriptor keyTypeDescriptor,_			@Nullable TypeDescriptor valueTypeDescriptor) {__		Assert.notNull(mapType, "Map type must not be null")__		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("Map type must be a [java.util.Map]")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,nullable,type,descriptor,key,type,descriptor,nullable,type,descriptor,value,type,descriptor,assert,not,null,map,type,map,type,must,not,be,null,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, @Nullable TypeDescriptor keyTypeDescriptor, 			@Nullable TypeDescriptor valueTypeDescriptor);1532520919;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, @Nullable TypeDescriptor keyTypeDescriptor,_			@Nullable TypeDescriptor valueTypeDescriptor) {__		Assert.notNull(mapType, "Map type must not be null")__		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("Map type must be a [java.util.Map]")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,nullable,type,descriptor,key,type,descriptor,nullable,type,descriptor,value,type,descriptor,assert,not,null,map,type,map,type,must,not,be,null,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, @Nullable TypeDescriptor keyTypeDescriptor, 			@Nullable TypeDescriptor valueTypeDescriptor);1546963887;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, @Nullable TypeDescriptor keyTypeDescriptor,_			@Nullable TypeDescriptor valueTypeDescriptor) {__		Assert.notNull(mapType, "Map type must not be null")__		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("Map type must be a [java.util.Map]")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,nullable,type,descriptor,key,type,descriptor,nullable,type,descriptor,value,type,descriptor,assert,not,null,map,type,map,type,must,not,be,null,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, @Nullable TypeDescriptor keyTypeDescriptor, 			@Nullable TypeDescriptor valueTypeDescriptor);1547033218;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, @Nullable TypeDescriptor keyTypeDescriptor,_			@Nullable TypeDescriptor valueTypeDescriptor) {__		Assert.notNull(mapType, "Map type must not be null")__		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("Map type must be a [java.util.Map]")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,nullable,type,descriptor,key,type,descriptor,nullable,type,descriptor,value,type,descriptor,assert,not,null,map,type,map,type,must,not,be,null,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1328020251;Create a new type descriptor from a java.util.Collection type._Useful for converting to typed Collections._For example, a List&lt_String&gt_ could be converted to a List&lt_EmailAddress&gt_ by converting to a targetType built with this method._The method call to construct such a TypeDescriptor would look something like: collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))__@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type, used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		return new TypeDescriptor(collectionType, elementTypeDescriptor)__	};create,a,new,type,descriptor,from,a,java,util,collection,type,useful,for,converting,to,typed,collections,for,example,a,list,lt,string,gt,could,be,converted,to,a,list,lt,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,return,new,type,descriptor,collection,type,element,type,descriptor
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1329142650;Create a new type descriptor from a java.util.Collection type._Useful for converting to typed Collections._For example, a List&lt_String&gt_ could be converted to a List&lt_EmailAddress&gt_ by converting to a targetType built with this method._The method call to construct such a TypeDescriptor would look something like: collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))__@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type, used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		return new TypeDescriptor(collectionType, elementTypeDescriptor)__	};create,a,new,type,descriptor,from,a,java,util,collection,type,useful,for,converting,to,typed,collections,for,example,a,list,lt,string,gt,could,be,converted,to,a,list,lt,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,return,new,type,descriptor,collection,type,element,type,descriptor
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1335774711;Create a new type descriptor from a java.util.Collection type._Useful for converting to typed Collections._For example, a List&lt_String&gt_ could be converted to a List&lt_EmailAddress&gt_ by converting to a targetType built with this method._The method call to construct such a TypeDescriptor would look something like: collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))__@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type, used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		return new TypeDescriptor(collectionType, elementTypeDescriptor)__	};create,a,new,type,descriptor,from,a,java,util,collection,type,useful,for,converting,to,typed,collections,for,example,a,list,lt,string,gt,could,be,converted,to,a,list,lt,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,return,new,type,descriptor,collection,type,element,type,descriptor
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1349907422;Create a new type descriptor from a java.util.Collection type._Useful for converting to typed Collections._For example, a List&lt_String&gt_ could be converted to a List&lt_EmailAddress&gt_ by converting to a targetType built with this method._The method call to construct such a TypeDescriptor would look something like: collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))__@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type, used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		return new TypeDescriptor(collectionType, elementTypeDescriptor)__	};create,a,new,type,descriptor,from,a,java,util,collection,type,useful,for,converting,to,typed,collections,for,example,a,list,lt,string,gt,could,be,converted,to,a,list,lt,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,return,new,type,descriptor,collection,type,element,type,descriptor
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1351584957;Create a new type descriptor from a java.util.Collection type._Useful for converting to typed Collections._For example, a List&lt_String&gt_ could be converted to a List&lt_EmailAddress&gt_ by converting to a targetType built with this method._The method call to construct such a TypeDescriptor would look something like: collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))__@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type, used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		return new TypeDescriptor(collectionType, elementTypeDescriptor)__	};create,a,new,type,descriptor,from,a,java,util,collection,type,useful,for,converting,to,typed,collections,for,example,a,list,lt,string,gt,could,be,converted,to,a,list,lt,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,return,new,type,descriptor,collection,type,element,type,descriptor
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1351648403;Create a new type descriptor from a java.util.Collection type._Useful for converting to typed Collections._For example, a List&lt_String&gt_ could be converted to a List&lt_EmailAddress&gt_ by converting to a targetType built with this method._The method call to construct such a TypeDescriptor would look something like: collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))__@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type, used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		return new TypeDescriptor(collectionType, elementTypeDescriptor)__	};create,a,new,type,descriptor,from,a,java,util,collection,type,useful,for,converting,to,typed,collections,for,example,a,list,lt,string,gt,could,be,converted,to,a,list,lt,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,return,new,type,descriptor,collection,type,element,type,descriptor
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1356735495;Create a new type descriptor from a java.util.Collection type._Useful for converting to typed Collections._For example, a List&lt_String&gt_ could be converted to a List&lt_EmailAddress&gt_ by converting to a targetType built with this method._The method call to construct such a TypeDescriptor would look something like: collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))__@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type, used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		return new TypeDescriptor(collectionType, elementTypeDescriptor)__	};create,a,new,type,descriptor,from,a,java,util,collection,type,useful,for,converting,to,typed,collections,for,example,a,list,lt,string,gt,could,be,converted,to,a,list,lt,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,return,new,type,descriptor,collection,type,element,type,descriptor
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1362408075;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		return new TypeDescriptor(collectionType, elementTypeDescriptor)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,return,new,type,descriptor,collection,type,element,type,descriptor
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1368482696;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		return new TypeDescriptor(collectionType, elementTypeDescriptor)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,return,new,type,descriptor,collection,type,element,type,descriptor
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1374614239;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		return new TypeDescriptor(collectionType, elementTypeDescriptor)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,return,new,type,descriptor,collection,type,element,type,descriptor
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1382042882;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "CollectionType must not be null")__		Assert.notNull(elementTypeDescriptor, "ElementTypeDesciptor must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType,_				elementTypeDescriptor.resolvableType), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,assert,not,null,element,type,descriptor,element,type,desciptor,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,type,descriptor,resolvable,type,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1382119085;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "CollectionType must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		ResolvableType element = (elementTypeDescriptor == null ? null_				: elementTypeDescriptor.resolvableType)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType,_				element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,null,element,type,descriptor,resolvable,type,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1382750081;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "CollectionType must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		ResolvableType element = (elementTypeDescriptor == null ? null_				: elementTypeDescriptor.resolvableType)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType,_				element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,null,element,type,descriptor,resolvable,type,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1387307647;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "CollectionType must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		ResolvableType element = (elementTypeDescriptor == null ? null_				: elementTypeDescriptor.resolvableType)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType,_				element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,null,element,type,descriptor,resolvable,type,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1387490898;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "CollectionType must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		ResolvableType element = (elementTypeDescriptor == null ? null_				: elementTypeDescriptor.resolvableType)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,null,element,type,descriptor,resolvable,type,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1389985540;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "CollectionType must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		ResolvableType element = (elementTypeDescriptor == null ? null_				: elementTypeDescriptor.resolvableType)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,null,element,type,descriptor,resolvable,type,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1390565795;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "collectionType must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1390925810;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "collectionType must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1391081201;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "collectionType must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1391248381;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "collectionType must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1394055372;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "collectionType must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1395846555;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "collectionType must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1403636229;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "collectionType must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1405430015;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "collectionType must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1406196817;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "collectionType must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1412611699;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "collectionType must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1414925289;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "collectionType must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1417290561;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "collectionType must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1419966315;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "collectionType must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1424769447;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "collectionType must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1424887506;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "collectionType must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1425763631;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "collectionType must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1431093918;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "collectionType must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1432125256;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "collectionType must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1441035153;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "collectionType must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1448383050;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "collectionType must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1450473050;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "collectionType must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1467288171;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "collectionType must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1467677340;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "collectionType must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1467730834;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "collectionType must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("collectionType must be a java.util.Collection")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1477690406;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "Collection type must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("Collection type must be a [java.util.Collection]")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1478094883;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "Collection type must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("Collection type must be a [java.util.Collection]")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1479823020;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "Collection type must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("Collection type must be a [java.util.Collection]")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1479900301;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "Collection type must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("Collection type must be a [java.util.Collection]")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1480540964;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "Collection type must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("Collection type must be a [java.util.Collection]")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1481578128;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "Collection type must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("Collection type must be a [java.util.Collection]")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1482961889;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "Collection type must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("Collection type must be a [java.util.Collection]")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1495868221;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "Collection type must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("Collection type must be a [java.util.Collection]")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor);1496259743;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "Collection type must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("Collection type must be a [java.util.Collection]")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public Class<?> getType();1328020251;The type of the backing class, method parameter, field, or property described by this TypeDescriptor._Returns primitive types as-is._See {@link #getObjectType()} for a variation of this operation that resolves primitive types to their corresponding Object types if necessary._@return the type, or <code>null</code> if this is {@link TypeDescriptor#NULL}_@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,returns,primitive,types,as,is,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,return,the,type,or,code,null,code,if,this,is,link,type,descriptor,null,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1329142650;The type of the backing class, method parameter, field, or property described by this TypeDescriptor._Returns primitive types as-is._See {@link #getObjectType()} for a variation of this operation that resolves primitive types to their corresponding Object types if necessary._@return the type, or <code>null</code> if this is {@link TypeDescriptor#NULL}_@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,returns,primitive,types,as,is,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,return,the,type,or,code,null,code,if,this,is,link,type,descriptor,null,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1335774711;The type of the backing class, method parameter, field, or property described by this TypeDescriptor._Returns primitive types as-is._See {@link #getObjectType()} for a variation of this operation that resolves primitive types to their corresponding Object types if necessary._@return the type, or <code>null</code> if this is {@link TypeDescriptor#NULL}_@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,returns,primitive,types,as,is,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,return,the,type,or,code,null,code,if,this,is,link,type,descriptor,null,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1349907422;The type of the backing class, method parameter, field, or property described by this TypeDescriptor._Returns primitive types as-is._See {@link #getObjectType()} for a variation of this operation that resolves primitive types to their corresponding Object types if necessary._@return the type, or <code>null</code> if this is {@link TypeDescriptor#NULL}_@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,returns,primitive,types,as,is,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,return,the,type,or,code,null,code,if,this,is,link,type,descriptor,null,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1351584957;The type of the backing class, method parameter, field, or property described by this TypeDescriptor._Returns primitive types as-is._See {@link #getObjectType()} for a variation of this operation that resolves primitive types to their corresponding Object types if necessary._@return the type, or <code>null</code> if this is {@link TypeDescriptor#NULL}_@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,returns,primitive,types,as,is,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,return,the,type,or,code,null,code,if,this,is,link,type,descriptor,null,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1351648403;The type of the backing class, method parameter, field, or property described by this TypeDescriptor._Returns primitive types as-is._<p>See {@link #getObjectType()} for a variation of this operation that resolves primitive types_to their corresponding Object types if necessary._@return the type, or <code>null</code>_@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,returns,primitive,types,as,is,p,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,return,the,type,or,code,null,code,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1356735495;The type of the backing class, method parameter, field, or property described by this TypeDescriptor._Returns primitive types as-is._<p>See {@link #getObjectType()} for a variation of this operation that resolves primitive types_to their corresponding Object types if necessary._@return the type, or {@code null}_@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,returns,primitive,types,as,is,p,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,return,the,type,or,code,null,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1362408075;The type of the backing class, method parameter, field, or property described by this TypeDescriptor._<p>Returns primitive types as-is._<p>See {@link #getObjectType()} for a variation of this operation that resolves primitive types_to their corresponding Object types if necessary._@return the type, or {@code null}_@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,p,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,return,the,type,or,code,null,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1368482696;The type of the backing class, method parameter, field, or property described by this TypeDescriptor._<p>Returns primitive types as-is._<p>See {@link #getObjectType()} for a variation of this operation that resolves primitive types_to their corresponding Object types if necessary._@return the type, or {@code null}_@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,p,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,return,the,type,or,code,null,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1374614239;The type of the backing class, method parameter, field, or property described by this TypeDescriptor._<p>Returns primitive types as-is._<p>See {@link #getObjectType()} for a variation of this operation that resolves primitive types_to their corresponding Object types if necessary._@return the type, or {@code null}_@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,p,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,return,the,type,or,code,null,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1382042882;The type of the backing class, method parameter, field, or property described by this TypeDescriptor._<p>Returns primitive types as-is._<p>See {@link #getObjectType()} for a variation of this operation that resolves primitive types_to their corresponding Object types if necessary._@return the type, or {@code null}_@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,p,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,return,the,type,or,code,null,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1382119085;The type of the backing class, method parameter, field, or property described by this TypeDescriptor._<p>Returns primitive types as-is._<p>See {@link #getObjectType()} for a variation of this operation that resolves primitive types_to their corresponding Object types if necessary._@return the type, or {@code null}_@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,p,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,return,the,type,or,code,null,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1382750081;The type of the backing class, method parameter, field, or property described by this TypeDescriptor._<p>Returns primitive types as-is._<p>See {@link #getObjectType()} for a variation of this operation that resolves primitive types_to their corresponding Object types if necessary._@return the type, or {@code null}_@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,p,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,return,the,type,or,code,null,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1387307647;The type of the backing class, method parameter, field, or property described by this TypeDescriptor._<p>Returns primitive types as-is._<p>See {@link #getObjectType()} for a variation of this operation that resolves primitive types_to their corresponding Object types if necessary._@return the type, or {@code null}_@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,p,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,return,the,type,or,code,null,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1387490898;The type of the backing class, method parameter, field, or property described by this TypeDescriptor._<p>Returns primitive types as-is._<p>See {@link #getObjectType()} for a variation of this operation that resolves primitive types_to their corresponding Object types if necessary._@return the type, or {@code null}_@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,p,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,return,the,type,or,code,null,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1389985540;The type of the backing class, method parameter, field, or property described by this TypeDescriptor._<p>Returns primitive types as-is._<p>See {@link #getObjectType()} for a variation of this operation that resolves primitive types_to their corresponding Object types if necessary._@return the type, or {@code null}_@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,p,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,return,the,type,or,code,null,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1390565795;The type of the backing class, method parameter, field, or property described by this TypeDescriptor._<p>Returns primitive types as-is._<p>See {@link #getObjectType()} for a variation of this operation that resolves primitive types_to their corresponding Object types if necessary._@return the type, or {@code null}_@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,p,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,return,the,type,or,code,null,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1390925810;The type of the backing class, method parameter, field, or property described by this TypeDescriptor._<p>Returns primitive types as-is._<p>See {@link #getObjectType()} for a variation of this operation that resolves primitive types_to their corresponding Object types if necessary._@return the type, or {@code null}_@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,p,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,return,the,type,or,code,null,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1391081201;The type of the backing class, method parameter, field, or property described by this TypeDescriptor._<p>Returns primitive types as-is._<p>See {@link #getObjectType()} for a variation of this operation that resolves primitive types_to their corresponding Object types if necessary._@return the type, or {@code null}_@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,p,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,return,the,type,or,code,null,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1391248381;The type of the backing class, method parameter, field, or property described by this TypeDescriptor._<p>Returns primitive types as-is._<p>See {@link #getObjectType()} for a variation of this operation that resolves primitive types_to their corresponding Object types if necessary._@return the type, or {@code null}_@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,p,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,return,the,type,or,code,null,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1394055372;The type of the backing class, method parameter, field, or property described by this TypeDescriptor._<p>Returns primitive types as-is._<p>See {@link #getObjectType()} for a variation of this operation that resolves primitive types_to their corresponding Object types if necessary._@return the type, or {@code null}_@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,p,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,return,the,type,or,code,null,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1395846555;The type of the backing class, method parameter, field, or property described by this TypeDescriptor._<p>Returns primitive types as-is._<p>See {@link #getObjectType()} for a variation of this operation that resolves primitive types_to their corresponding Object types if necessary._@return the type, or {@code null}_@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,p,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,return,the,type,or,code,null,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1403636229;The type of the backing class, method parameter, field, or property described by this TypeDescriptor._<p>Returns primitive types as-is._<p>See {@link #getObjectType()} for a variation of this operation that resolves primitive types_to their corresponding Object types if necessary._@return the type, or {@code null}_@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,p,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,return,the,type,or,code,null,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1405430015;The type of the backing class, method parameter, field, or property_described by this TypeDescriptor._<p>Returns primitive types as-is._<p>See {@link #getObjectType()} for a variation of this operation that_resolves primitive types to their corresponding Object types if necessary._@return the type, or {@code null}_@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,p,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,return,the,type,or,code,null,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1406196817;The type of the backing class, method parameter, field, or property_described by this TypeDescriptor._<p>Returns primitive types as-is._<p>See {@link #getObjectType()} for a variation of this operation that_resolves primitive types to their corresponding Object types if necessary._@return the type, or {@code null}_@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,p,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,return,the,type,or,code,null,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1412611699;The type of the backing class, method parameter, field, or property_described by this TypeDescriptor._<p>Returns primitive types as-is._<p>See {@link #getObjectType()} for a variation of this operation that_resolves primitive types to their corresponding Object types if necessary._@return the type, or {@code null}_@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,p,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,return,the,type,or,code,null,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1414925289;The type of the backing class, method parameter, field, or property_described by this TypeDescriptor._<p>Returns primitive types as-is._<p>See {@link #getObjectType()} for a variation of this operation that_resolves primitive types to their corresponding Object types if necessary._@return the type, or {@code null}_@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,p,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,return,the,type,or,code,null,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1417290561;The type of the backing class, method parameter, field, or property_described by this TypeDescriptor._<p>Returns primitive types as-is._<p>See {@link #getObjectType()} for a variation of this operation that_resolves primitive types to their corresponding Object types if necessary._@return the type, or {@code null} if it cannot be determined_@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,p,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,return,the,type,or,code,null,if,it,cannot,be,determined,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1419966315;The type of the backing class, method parameter, field, or property_described by this TypeDescriptor._<p>Returns primitive types as-is._<p>See {@link #getObjectType()} for a variation of this operation that_resolves primitive types to their corresponding Object types if necessary._@return the type, or {@code null} if it cannot be determined_@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,p,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,return,the,type,or,code,null,if,it,cannot,be,determined,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1424769447;The type of the backing class, method parameter, field, or property_described by this TypeDescriptor._<p>Returns primitive types as-is._<p>See {@link #getObjectType()} for a variation of this operation that_resolves primitive types to their corresponding Object types if necessary._@return the type, or {@code null} if it cannot be determined_@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,p,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,return,the,type,or,code,null,if,it,cannot,be,determined,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1424887506;The type of the backing class, method parameter, field, or property_described by this TypeDescriptor._<p>Returns primitive types as-is._<p>See {@link #getObjectType()} for a variation of this operation that_resolves primitive types to their corresponding Object types if necessary._@return the type, or {@code null} if it cannot be determined_@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,p,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,return,the,type,or,code,null,if,it,cannot,be,determined,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1425763631;The type of the backing class, method parameter, field, or property_described by this TypeDescriptor._<p>Returns primitive types as-is._<p>See {@link #getObjectType()} for a variation of this operation that_resolves primitive types to their corresponding Object types if necessary._@return the type, or {@code null} if it cannot be determined_@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,p,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,return,the,type,or,code,null,if,it,cannot,be,determined,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1431093918;The type of the backing class, method parameter, field, or property_described by this TypeDescriptor._<p>Returns primitive types as-is._<p>See {@link #getObjectType()} for a variation of this operation that_resolves primitive types to their corresponding Object types if necessary._@return the type, or {@code null} if it cannot be determined_@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,p,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,return,the,type,or,code,null,if,it,cannot,be,determined,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1432125256;The type of the backing class, method parameter, field, or property_described by this TypeDescriptor._<p>Returns primitive types as-is._<p>See {@link #getObjectType()} for a variation of this operation that_resolves primitive types to their corresponding Object types if necessary._@return the type, or {@code null} if it cannot be determined_@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,p,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,return,the,type,or,code,null,if,it,cannot,be,determined,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1441035153;The type of the backing class, method parameter, field, or property_described by this TypeDescriptor._<p>Returns primitive types as-is._<p>See {@link #getObjectType()} for a variation of this operation that_resolves primitive types to their corresponding Object types if necessary._@return the type, or {@code null} if it cannot be determined_@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,p,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,return,the,type,or,code,null,if,it,cannot,be,determined,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1448383050;The type of the backing class, method parameter, field, or property_described by this TypeDescriptor._<p>Returns primitive types as-is._<p>See {@link #getObjectType()} for a variation of this operation that_resolves primitive types to their corresponding Object types if necessary._@return the type, or {@code null} if it cannot be determined_@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,p,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,return,the,type,or,code,null,if,it,cannot,be,determined,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1450473050;The type of the backing class, method parameter, field, or property_described by this TypeDescriptor._<p>Returns primitive types as-is._<p>See {@link #getObjectType()} for a variation of this operation that_resolves primitive types to their corresponding Object types if necessary._@return the type, or {@code null} if it cannot be determined_@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,p,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,return,the,type,or,code,null,if,it,cannot,be,determined,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1467288171;The type of the backing class, method parameter, field, or property_described by this TypeDescriptor._<p>Returns primitive types as-is. See {@link #getObjectType()} for a_variation of this operation that resolves primitive types to their_corresponding Object types if necessary._@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1467677340;The type of the backing class, method parameter, field, or property_described by this TypeDescriptor._<p>Returns primitive types as-is. See {@link #getObjectType()} for a_variation of this operation that resolves primitive types to their_corresponding Object types if necessary._@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1467730834;The type of the backing class, method parameter, field, or property_described by this TypeDescriptor._<p>Returns primitive types as-is. See {@link #getObjectType()} for a_variation of this operation that resolves primitive types to their_corresponding Object types if necessary._@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1477690406;The type of the backing class, method parameter, field, or property_described by this TypeDescriptor._<p>Returns primitive types as-is. See {@link #getObjectType()} for a_variation of this operation that resolves primitive types to their_corresponding Object types if necessary._@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1478094883;The type of the backing class, method parameter, field, or property_described by this TypeDescriptor._<p>Returns primitive types as-is. See {@link #getObjectType()} for a_variation of this operation that resolves primitive types to their_corresponding Object types if necessary._@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1479823020;The type of the backing class, method parameter, field, or property_described by this TypeDescriptor._<p>Returns primitive types as-is. See {@link #getObjectType()} for a_variation of this operation that resolves primitive types to their_corresponding Object types if necessary._@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1479900301;The type of the backing class, method parameter, field, or property_described by this TypeDescriptor._<p>Returns primitive types as-is. See {@link #getObjectType()} for a_variation of this operation that resolves primitive types to their_corresponding Object types if necessary._@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1480540964;The type of the backing class, method parameter, field, or property_described by this TypeDescriptor._<p>Returns primitive types as-is. See {@link #getObjectType()} for a_variation of this operation that resolves primitive types to their_corresponding Object types if necessary._@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1481578128;The type of the backing class, method parameter, field, or property_described by this TypeDescriptor._<p>Returns primitive types as-is. See {@link #getObjectType()} for a_variation of this operation that resolves primitive types to their_corresponding Object types if necessary._@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1482961889;The type of the backing class, method parameter, field, or property_described by this TypeDescriptor._<p>Returns primitive types as-is. See {@link #getObjectType()} for a_variation of this operation that resolves primitive types to their_corresponding Object types if necessary._@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1495868221;The type of the backing class, method parameter, field, or property_described by this TypeDescriptor._<p>Returns primitive types as-is. See {@link #getObjectType()} for a_variation of this operation that resolves primitive types to their_corresponding Object types if necessary._@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1496259743;The type of the backing class, method parameter, field, or property_described by this TypeDescriptor._<p>Returns primitive types as-is. See {@link #getObjectType()} for a_variation of this operation that resolves primitive types to their_corresponding Object types if necessary._@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1496837955;The type of the backing class, method parameter, field, or property_described by this TypeDescriptor._<p>Returns primitive types as-is. See {@link #getObjectType()} for a_variation of this operation that resolves primitive types to their_corresponding Object types if necessary._@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1498780456;The type of the backing class, method parameter, field, or property_described by this TypeDescriptor._<p>Returns primitive types as-is. See {@link #getObjectType()} for a_variation of this operation that resolves primitive types to their_corresponding Object types if necessary._@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1508084888;The type of the backing class, method parameter, field, or property_described by this TypeDescriptor._<p>Returns primitive types as-is. See {@link #getObjectType()} for a_variation of this operation that resolves primitive types to their_corresponding Object types if necessary._@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1522332300;The type of the backing class, method parameter, field, or property_described by this TypeDescriptor._<p>Returns primitive types as-is. See {@link #getObjectType()} for a_variation of this operation that resolves primitive types to their_corresponding Object types if necessary._@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1532520919;The type of the backing class, method parameter, field, or property_described by this TypeDescriptor._<p>Returns primitive types as-is. See {@link #getObjectType()} for a_variation of this operation that resolves primitive types to their_corresponding Object types if necessary._@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1546963887;The type of the backing class, method parameter, field, or property_described by this TypeDescriptor._<p>Returns primitive types as-is. See {@link #getObjectType()} for a_variation of this operation that resolves primitive types to their_corresponding Object types if necessary._@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public Class<?> getType();1547033218;The type of the backing class, method parameter, field, or property_described by this TypeDescriptor._<p>Returns primitive types as-is. See {@link #getObjectType()} for a_variation of this operation that resolves primitive types to their_corresponding Object types if necessary._@see #getObjectType();public Class<?> getType() {_		return this.type__	};the,type,of,the,backing,class,method,parameter,field,or,property,described,by,this,type,descriptor,p,returns,primitive,types,as,is,see,link,get,object,type,for,a,variation,of,this,operation,that,resolves,primitive,types,to,their,corresponding,object,types,if,necessary,see,get,object,type;public,class,get,type,return,this,type
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1328020251;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor} from the provided map value._Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property to the class of the provided map value._For example, if this describes a java.util.Map&lt_java.lang.String, java.lang.Number&lt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.Map&lt_?, ?&gt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a java.util.Map.;public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())_		_	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,map,lt,gt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1329142650;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor} from the provided map value._Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property to the class of the provided map value._For example, if this describes a java.util.Map&lt_java.lang.String, java.lang.Number&lt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.Map&lt_?, ?&gt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a java.util.Map.;public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())_		_	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,map,lt,gt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1335774711;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor} from the provided map value._Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property to the class of the provided map value._For example, if this describes a java.util.Map&lt_java.lang.String, java.lang.Number&lt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.Map&lt_?, ?&gt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a java.util.Map.;public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())_		_	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,map,lt,gt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1349907422;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor} from the provided map value._Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property to the class of the provided map value._For example, if this describes a java.util.Map&lt_java.lang.String, java.lang.Number&lt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.Map&lt_?, ?&gt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,map,lt,gt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1351584957;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor} from the provided map value._Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property to the class of the provided map value._For example, if this describes a java.util.Map&lt_java.lang.String, java.lang.Number&lt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.Map&lt_?, ?&gt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,map,lt,gt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1351648403;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor} from the provided map value._Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property to the class of the provided map value._For example, if this describes a java.util.Map&lt_java.lang.String, java.lang.Number&lt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.Map&lt_?, ?&gt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,map,lt,gt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1356735495;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor} from the provided map value._Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property to the class of the provided map value._For example, if this describes a java.util.Map&lt_java.lang.String, java.lang.Number&lt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.Map&lt_?, ?&gt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,map,lt,gt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1362408075;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor} from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property to the class of the provided map value._For example, if this describes a java.util.Map&lt_java.lang.String, java.lang.Number&lt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.Map&lt_?, ?&gt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,map,lt,gt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1368482696;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor} from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property to the class of the provided map value._For example, if this describes a java.util.Map&lt_java.lang.String, java.lang.Number&lt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.Map&lt_?, ?&gt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,map,lt,gt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1374614239;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor} from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property to the class of the provided map value._For example, if this describes a java.util.Map&lt_java.lang.String, java.lang.Number&lt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.Map&lt_?, ?&gt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,map,lt,gt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1382042882;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor} from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property to the class of the provided map value._For example, if this describes a java.util.Map&lt_java.lang.String, java.lang.Number&lt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.Map&lt_?, ?&gt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,map,lt,gt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1382119085;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor} from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property to the class of the provided map value._For example, if this describes a java.util.Map&lt_java.lang.String, java.lang.Number&lt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.Map&lt_?, ?&gt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,map,lt,gt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1382750081;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor} from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property to the class of the provided map value._For example, if this describes a java.util.Map&lt_java.lang.String, java.lang.Number&lt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.Map&lt_?, ?&gt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,map,lt,gt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1387307647;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor} from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property to the class of the provided map value._For example, if this describes a java.util.Map&lt_java.lang.String, java.lang.Number&lt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.Map&lt_?, ?&gt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,map,lt,gt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1387490898;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor} from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property to the class of the provided map value._For example, if this describes a java.util.Map&lt_java.lang.String, java.lang.Number&lt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.Map&lt_?, ?&gt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,map,lt,gt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1389985540;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor} from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property to the class of the provided map value._For example, if this describes a java.util.Map&lt_java.lang.String, java.lang.Number&lt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.Map&lt_?, ?&gt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,map,lt,gt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1390565795;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor} from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property to the class of the provided map value._For example, if this describes a java.util.Map&lt_java.lang.String, java.lang.Number&lt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.Map&lt_?, ?&gt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,map,lt,gt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1390925810;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor} from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property to the class of the provided map value._For example, if this describes a java.util.Map&lt_java.lang.String, java.lang.Number&lt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.Map&lt_?, ?&gt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,map,lt,gt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1391081201;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor} from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property to the class of the provided map value._For example, if this describes a java.util.Map&lt_java.lang.String, java.lang.Number&lt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.Map&lt_?, ?&gt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,map,lt,gt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1391248381;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor} from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property to the class of the provided map value._For example, if this describes a java.util.Map&lt_java.lang.String, java.lang.Number&lt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer._If this describes a java.util.Map&lt_?, ?&gt_ and the value argument is a java.lang.Integer, the returned TypeDescriptor will be java.lang.Integer as well._<p>Annotation and nested type context will be preserved in the narrowed TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,if,this,describes,a,java,util,map,lt,gt,and,the,value,argument,is,a,java,lang,integer,the,returned,type,descriptor,will,be,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1394055372;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}_from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property_to the class of the provided map value. For example, if this describes a_{@code java.util.Map&lt_java.lang.String, java.lang.Number&lt_} and the value_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the value argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1395846555;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}_from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property_to the class of the provided map value. For example, if this describes a_{@code java.util.Map&lt_java.lang.String, java.lang.Number&lt_} and the value_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the value argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1403636229;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}_from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property_to the class of the provided map value. For example, if this describes a_{@code java.util.Map&lt_java.lang.String, java.lang.Number&lt_} and the value_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the value argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1405430015;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}_from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property_to the class of the provided map value. For example, if this describes a_{@code java.util.Map&lt_java.lang.String, java.lang.Number&lt_} and the value_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the value argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1406196817;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}_from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property_to the class of the provided map value. For example, if this describes a_{@code java.util.Map&lt_java.lang.String, java.lang.Number&lt_} and the value_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the value argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1412611699;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}_from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property_to the class of the provided map value. For example, if this describes a_{@code java.util.Map&lt_java.lang.String, java.lang.Number&lt_} and the value_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the value argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1414925289;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}_from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property_to the class of the provided map value. For example, if this describes a_{@code java.util.Map&lt_java.lang.String, java.lang.Number&lt_} and the value_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the value argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1417290561;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}_from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property_to the class of the provided map value. For example, if this describes a_{@code java.util.Map&lt_java.lang.String, java.lang.Number&lt_} and the value_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the value argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1419966315;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}_from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property_to the class of the provided map value. For example, if this describes a_{@code java.util.Map&lt_java.lang.String, java.lang.Number&lt_} and the value_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the value argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1424769447;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}_from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property_to the class of the provided map value. For example, if this describes a_{@code java.util.Map&lt_java.lang.String, java.lang.Number&lt_} and the value_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the value argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1424887506;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}_from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property_to the class of the provided map value. For example, if this describes a_{@code java.util.Map&lt_java.lang.String, java.lang.Number&lt_} and the value_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the value argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1425763631;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}_from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property_to the class of the provided map value. For example, if this describes a_{@code java.util.Map&lt_java.lang.String, java.lang.Number&lt_} and the value_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the value argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1431093918;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}_from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property_to the class of the provided map value. For example, if this describes a_{@code java.util.Map&lt_java.lang.String, java.lang.Number&lt_} and the value_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the value argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1432125256;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}_from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property_to the class of the provided map value. For example, if this describes a_{@code java.util.Map&lt_java.lang.String, java.lang.Number&lt_} and the value_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the value argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1441035153;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}_from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property_to the class of the provided map value. For example, if this describes a_{@code java.util.Map&lt_java.lang.String, java.lang.Number&lt_} and the value_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the value argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1448383050;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}_from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property_to the class of the provided map value. For example, if this describes a_{@code java.util.Map&lt_java.lang.String, java.lang.Number&lt_} and the value_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the value argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1450473050;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}_from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property_to the class of the provided map value. For example, if this describes a_{@code java.util.Map&lt_java.lang.String, java.lang.Number&lt_} and the value_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the value argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1467288171;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}_from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property_to the class of the provided map value. For example, if this describes a_{@code java.util.Map&lt_java.lang.String, java.lang.Number&lt_} and the value_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the value argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1467677340;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}_from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property_to the class of the provided map value. For example, if this describes a_{@code java.util.Map&lt_java.lang.String, java.lang.Number&lt_} and the value_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the value argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1467730834;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}_from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property_to the class of the provided map value. For example, if this describes a_{@code java.util.Map&lt_java.lang.String, java.lang.Number&lt_} and the value_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the value argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1477690406;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}_from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property_to the class of the provided map value. For example, if this describes a_{@code java.util.Map&lt_java.lang.String, java.lang.Number&lt_} and the value_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the value argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1478094883;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}_from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property_to the class of the provided map value. For example, if this describes a_{@code java.util.Map&lt_java.lang.String, java.lang.Number&lt_} and the value_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the value argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1479823020;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}_from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property_to the class of the provided map value. For example, if this describes a_{@code java.util.Map&lt_java.lang.String, java.lang.Number&lt_} and the value_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the value argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1479900301;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}_from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property_to the class of the provided map value. For example, if this describes a_{@code java.util.Map&lt_java.lang.String, java.lang.Number&lt_} and the value_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the value argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1480540964;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}_from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property_to the class of the provided map value. For example, if this describes a_{@code java.util.Map&lt_java.lang.String, java.lang.Number&lt_} and the value_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the value argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1481578128;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}_from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property_to the class of the provided map value. For example, if this describes a_{@code java.util.Map&lt_java.lang.String, java.lang.Number&lt_} and the value_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the value argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1482961889;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}_from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property_to the class of the provided map value. For example, if this describes a_{@code java.util.Map&lt_java.lang.String, java.lang.Number&lt_} and the value_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the value argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1495868221;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}_from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property_to the class of the provided map value. For example, if this describes a_{@code java.util.Map&lt_java.lang.String, java.lang.Number&lt_} and the value_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the value argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1496259743;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}_from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property_to the class of the provided map value. For example, if this describes a_{@code java.util.Map&lt_java.lang.String, java.lang.Number&lt_} and the value_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the value argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> @Nullable 	public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1496837955;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}_from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property_to the class of the provided map value. For example, if this describes a_{@code java.util.Map&lt_java.lang.String, java.lang.Number&lt_} and the value_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the value argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);@Nullable_	public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;nullable,public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> @Nullable 	public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1498780456;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}_from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property_to the class of the provided map value. For example, if this describes a_{@code java.util.Map&lt_java.lang.String, java.lang.Number&lt_} and the value_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the value argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);@Nullable_	public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;nullable,public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> @Nullable 	public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1508084888;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}_from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property_to the class of the provided map value. For example, if this describes a_{@code java.util.Map&lt_java.lang.String, java.lang.Number&lt_} and the value_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the value argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);@Nullable_	public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;nullable,public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> @Nullable 	public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1522332300;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}_from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property_to the class of the provided map value. For example, if this describes a_{@code java.util.Map&lt_java.lang.String, java.lang.Number&lt_} and the value_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the value argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);@Nullable_	public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;nullable,public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> @Nullable 	public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1532520919;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}_from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property_to the class of the provided map value. For example, if this describes a_{@code java.util.Map&lt_java.lang.String, java.lang.Number&lt_} and the value_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the value argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);@Nullable_	public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;nullable,public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> @Nullable 	public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1546963887;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}_from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property_to the class of the provided map value. For example, if this describes a_{@code java.util.Map&lt_java.lang.String, java.lang.Number&lt_} and the value_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the value argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);@Nullable_	public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;nullable,public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> @Nullable 	public TypeDescriptor getMapValueTypeDescriptor(Object mapValue);1547033218;If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}_from the provided map value._<p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property_to the class of the provided map value. For example, if this describes a_{@code java.util.Map&lt_java.lang.String, java.lang.Number&lt_} and the value_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the value argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapValue the map value_@return the map value type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);@Nullable_	public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {_		return narrow(mapValue, getMapValueTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,value,link,type,descriptor,from,the,provided,map,value,p,narrows,the,link,get,map,value,type,descriptor,map,value,type,property,to,the,class,of,the,provided,map,value,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,string,java,lang,number,lt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,value,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,value,the,map,value,return,the,map,value,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;nullable,public,type,descriptor,get,map,value,type,descriptor,object,map,value,return,narrow,map,value,get,map,value,type,descriptor
TypeDescriptor -> public ResolvableType getResolvableType();1391248381;Return the underlying {@link ResolvableType}.;public ResolvableType getResolvableType() {_		return this.resolvableType__	};return,the,underlying,link,resolvable,type;public,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> public ResolvableType getResolvableType();1394055372;Return the underlying {@link ResolvableType}.;public ResolvableType getResolvableType() {_		return this.resolvableType__	};return,the,underlying,link,resolvable,type;public,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> public ResolvableType getResolvableType();1395846555;Return the underlying {@link ResolvableType}.;public ResolvableType getResolvableType() {_		return this.resolvableType__	};return,the,underlying,link,resolvable,type;public,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> public ResolvableType getResolvableType();1403636229;Return the underlying {@link ResolvableType}.;public ResolvableType getResolvableType() {_		return this.resolvableType__	};return,the,underlying,link,resolvable,type;public,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> public ResolvableType getResolvableType();1405430015;Return the underlying {@link ResolvableType}.;public ResolvableType getResolvableType() {_		return this.resolvableType__	};return,the,underlying,link,resolvable,type;public,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> public ResolvableType getResolvableType();1406196817;Return the underlying {@link ResolvableType}._@since 4.0;public ResolvableType getResolvableType() {_		return this.resolvableType__	};return,the,underlying,link,resolvable,type,since,4,0;public,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> public ResolvableType getResolvableType();1412611699;Return the underlying {@link ResolvableType}._@since 4.0;public ResolvableType getResolvableType() {_		return this.resolvableType__	};return,the,underlying,link,resolvable,type,since,4,0;public,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> public ResolvableType getResolvableType();1414925289;Return the underlying {@link ResolvableType}._@since 4.0;public ResolvableType getResolvableType() {_		return this.resolvableType__	};return,the,underlying,link,resolvable,type,since,4,0;public,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> public ResolvableType getResolvableType();1417290561;Return the underlying {@link ResolvableType}._@since 4.0;public ResolvableType getResolvableType() {_		return this.resolvableType__	};return,the,underlying,link,resolvable,type,since,4,0;public,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> public ResolvableType getResolvableType();1419966315;Return the underlying {@link ResolvableType}._@since 4.0;public ResolvableType getResolvableType() {_		return this.resolvableType__	};return,the,underlying,link,resolvable,type,since,4,0;public,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> public ResolvableType getResolvableType();1424769447;Return the underlying {@link ResolvableType}._@since 4.0;public ResolvableType getResolvableType() {_		return this.resolvableType__	};return,the,underlying,link,resolvable,type,since,4,0;public,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> public ResolvableType getResolvableType();1424887506;Return the underlying {@link ResolvableType}._@since 4.0;public ResolvableType getResolvableType() {_		return this.resolvableType__	};return,the,underlying,link,resolvable,type,since,4,0;public,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> public ResolvableType getResolvableType();1425763631;Return the underlying {@link ResolvableType}._@since 4.0;public ResolvableType getResolvableType() {_		return this.resolvableType__	};return,the,underlying,link,resolvable,type,since,4,0;public,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> public ResolvableType getResolvableType();1431093918;Return the underlying {@link ResolvableType}._@since 4.0;public ResolvableType getResolvableType() {_		return this.resolvableType__	};return,the,underlying,link,resolvable,type,since,4,0;public,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> public ResolvableType getResolvableType();1432125256;Return the underlying {@link ResolvableType}._@since 4.0;public ResolvableType getResolvableType() {_		return this.resolvableType__	};return,the,underlying,link,resolvable,type,since,4,0;public,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> public ResolvableType getResolvableType();1441035153;Return the underlying {@link ResolvableType}._@since 4.0;public ResolvableType getResolvableType() {_		return this.resolvableType__	};return,the,underlying,link,resolvable,type,since,4,0;public,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> public ResolvableType getResolvableType();1448383050;Return the underlying {@link ResolvableType}._@since 4.0;public ResolvableType getResolvableType() {_		return this.resolvableType__	};return,the,underlying,link,resolvable,type,since,4,0;public,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> public ResolvableType getResolvableType();1450473050;Return the underlying {@link ResolvableType}._@since 4.0;public ResolvableType getResolvableType() {_		return this.resolvableType__	};return,the,underlying,link,resolvable,type,since,4,0;public,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> public ResolvableType getResolvableType();1467288171;Return the underlying {@link ResolvableType}._@since 4.0;public ResolvableType getResolvableType() {_		return this.resolvableType__	};return,the,underlying,link,resolvable,type,since,4,0;public,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> public ResolvableType getResolvableType();1467677340;Return the underlying {@link ResolvableType}._@since 4.0;public ResolvableType getResolvableType() {_		return this.resolvableType__	};return,the,underlying,link,resolvable,type,since,4,0;public,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> public ResolvableType getResolvableType();1467730834;Return the underlying {@link ResolvableType}._@since 4.0;public ResolvableType getResolvableType() {_		return this.resolvableType__	};return,the,underlying,link,resolvable,type,since,4,0;public,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> public ResolvableType getResolvableType();1477690406;Return the underlying {@link ResolvableType}._@since 4.0;public ResolvableType getResolvableType() {_		return this.resolvableType__	};return,the,underlying,link,resolvable,type,since,4,0;public,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> public ResolvableType getResolvableType();1478094883;Return the underlying {@link ResolvableType}._@since 4.0;public ResolvableType getResolvableType() {_		return this.resolvableType__	};return,the,underlying,link,resolvable,type,since,4,0;public,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> public ResolvableType getResolvableType();1479823020;Return the underlying {@link ResolvableType}._@since 4.0;public ResolvableType getResolvableType() {_		return this.resolvableType__	};return,the,underlying,link,resolvable,type,since,4,0;public,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> public ResolvableType getResolvableType();1479900301;Return the underlying {@link ResolvableType}._@since 4.0;public ResolvableType getResolvableType() {_		return this.resolvableType__	};return,the,underlying,link,resolvable,type,since,4,0;public,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> public ResolvableType getResolvableType();1480540964;Return the underlying {@link ResolvableType}._@since 4.0;public ResolvableType getResolvableType() {_		return this.resolvableType__	};return,the,underlying,link,resolvable,type,since,4,0;public,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> public ResolvableType getResolvableType();1481578128;Return the underlying {@link ResolvableType}._@since 4.0;public ResolvableType getResolvableType() {_		return this.resolvableType__	};return,the,underlying,link,resolvable,type,since,4,0;public,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> public ResolvableType getResolvableType();1482961889;Return the underlying {@link ResolvableType}._@since 4.0;public ResolvableType getResolvableType() {_		return this.resolvableType__	};return,the,underlying,link,resolvable,type,since,4,0;public,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> public ResolvableType getResolvableType();1495868221;Return the underlying {@link ResolvableType}._@since 4.0;public ResolvableType getResolvableType() {_		return this.resolvableType__	};return,the,underlying,link,resolvable,type,since,4,0;public,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> public ResolvableType getResolvableType();1496259743;Return the underlying {@link ResolvableType}._@since 4.0;public ResolvableType getResolvableType() {_		return this.resolvableType__	};return,the,underlying,link,resolvable,type,since,4,0;public,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> public ResolvableType getResolvableType();1496837955;Return the underlying {@link ResolvableType}._@since 4.0;public ResolvableType getResolvableType() {_		return this.resolvableType__	};return,the,underlying,link,resolvable,type,since,4,0;public,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> public ResolvableType getResolvableType();1498780456;Return the underlying {@link ResolvableType}._@since 4.0;public ResolvableType getResolvableType() {_		return this.resolvableType__	};return,the,underlying,link,resolvable,type,since,4,0;public,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> public ResolvableType getResolvableType();1508084888;Return the underlying {@link ResolvableType}._@since 4.0;public ResolvableType getResolvableType() {_		return this.resolvableType__	};return,the,underlying,link,resolvable,type,since,4,0;public,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> public ResolvableType getResolvableType();1522332300;Return the underlying {@link ResolvableType}._@since 4.0;public ResolvableType getResolvableType() {_		return this.resolvableType__	};return,the,underlying,link,resolvable,type,since,4,0;public,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> public ResolvableType getResolvableType();1532520919;Return the underlying {@link ResolvableType}._@since 4.0;public ResolvableType getResolvableType() {_		return this.resolvableType__	};return,the,underlying,link,resolvable,type,since,4,0;public,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> public ResolvableType getResolvableType();1546963887;Return the underlying {@link ResolvableType}._@since 4.0;public ResolvableType getResolvableType() {_		return this.resolvableType__	};return,the,underlying,link,resolvable,type,since,4,0;public,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> public ResolvableType getResolvableType();1547033218;Return the underlying {@link ResolvableType}._@since 4.0;public ResolvableType getResolvableType() {_		return this.resolvableType__	};return,the,underlying,link,resolvable,type,since,4,0;public,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> @Nullable 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1508084888;Obtain the annotation of the specified {@code annotationType} that is on this type descriptor._<p>As of Spring Framework 4.2, this method supports arbitrary levels of meta-annotations._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@Nullable_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		if (this.annotatedElement.isEmpty()) {_			_			_			return null__		}_		return AnnotatedElementUtils.getMergedAnnotation(this.annotatedElement, annotationType)__	};obtain,the,annotation,of,the,specified,code,annotation,type,that,is,on,this,type,descriptor,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;nullable,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,if,this,annotated,element,is,empty,return,null,return,annotated,element,utils,get,merged,annotation,this,annotated,element,annotation,type
TypeDescriptor -> @Nullable 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1522332300;Obtain the annotation of the specified {@code annotationType} that is on this type descriptor._<p>As of Spring Framework 4.2, this method supports arbitrary levels of meta-annotations._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@Nullable_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		if (this.annotatedElement.isEmpty()) {_			_			_			return null__		}_		return AnnotatedElementUtils.getMergedAnnotation(this.annotatedElement, annotationType)__	};obtain,the,annotation,of,the,specified,code,annotation,type,that,is,on,this,type,descriptor,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;nullable,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,if,this,annotated,element,is,empty,return,null,return,annotated,element,utils,get,merged,annotation,this,annotated,element,annotation,type
TypeDescriptor -> @Nullable 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1532520919;Obtain the annotation of the specified {@code annotationType} that is on this type descriptor._<p>As of Spring Framework 4.2, this method supports arbitrary levels of meta-annotations._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@Nullable_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		if (this.annotatedElement.isEmpty()) {_			_			_			return null__		}_		return AnnotatedElementUtils.getMergedAnnotation(this.annotatedElement, annotationType)__	};obtain,the,annotation,of,the,specified,code,annotation,type,that,is,on,this,type,descriptor,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;nullable,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,if,this,annotated,element,is,empty,return,null,return,annotated,element,utils,get,merged,annotation,this,annotated,element,annotation,type
TypeDescriptor -> @Nullable 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1546963887;Obtain the annotation of the specified {@code annotationType} that is on this type descriptor._<p>As of Spring Framework 4.2, this method supports arbitrary levels of meta-annotations._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@Nullable_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		if (this.annotatedElement.isEmpty()) {_			_			_			return null__		}_		return AnnotatedElementUtils.getMergedAnnotation(this.annotatedElement, annotationType)__	};obtain,the,annotation,of,the,specified,code,annotation,type,that,is,on,this,type,descriptor,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;nullable,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,if,this,annotated,element,is,empty,return,null,return,annotated,element,utils,get,merged,annotation,this,annotated,element,annotation,type
TypeDescriptor -> @Nullable 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1547033218;Obtain the annotation of the specified {@code annotationType} that is on this type descriptor._<p>As of Spring Framework 4.2, this method supports arbitrary levels of meta-annotations._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@Nullable_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		if (this.annotatedElement.isEmpty()) {_			_			_			return null__		}_		return AnnotatedElementUtils.getMergedAnnotation(this.annotatedElement, annotationType)__	};obtain,the,annotation,of,the,specified,code,annotation,type,that,is,on,this,type,descriptor,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;nullable,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,if,this,annotated,element,is,empty,return,null,return,annotated,element,utils,get,merged,annotation,this,annotated,element,annotation,type
TypeDescriptor -> @Deprecated 	public Class<?> getElementType();1328020251;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}._@throws IllegalStateException if this type is not a java.util.Collection or Array type;@Deprecated_	public Class<?> getElementType() {_		return getElementTypeDescriptor().getType()__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,element,type,descriptor,element,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,element,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;deprecated,public,class,get,element,type,return,get,element,type,descriptor,get,type
TypeDescriptor -> @Deprecated 	public Class<?> getElementType();1329142650;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}._@throws IllegalStateException if this type is not a java.util.Collection or Array type;@Deprecated_	public Class<?> getElementType() {_		return getElementTypeDescriptor().getType()__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,element,type,descriptor,element,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,element,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;deprecated,public,class,get,element,type,return,get,element,type,descriptor,get,type
TypeDescriptor -> @Deprecated 	public Class<?> getElementType();1335774711;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}._@throws IllegalStateException if this type is not a java.util.Collection or Array type;@Deprecated_	public Class<?> getElementType() {_		return getElementTypeDescriptor().getType()__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,element,type,descriptor,element,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,element,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;deprecated,public,class,get,element,type,return,get,element,type,descriptor,get,type
TypeDescriptor -> @Deprecated 	public Class<?> getElementType();1349907422;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Collection or Array type;@Deprecated_	public Class<?> getElementType() {_		return getElementTypeDescriptor().getType()__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,element,type,descriptor,element,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,element,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;deprecated,public,class,get,element,type,return,get,element,type,descriptor,get,type
TypeDescriptor -> @Deprecated 	public Class<?> getElementType();1351584957;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Collection or Array type;@Deprecated_	public Class<?> getElementType() {_		return getElementTypeDescriptor().getType()__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,element,type,descriptor,element,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,element,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;deprecated,public,class,get,element,type,return,get,element,type,descriptor,get,type
TypeDescriptor -> @Deprecated 	public Class<?> getElementType();1351648403;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Collection or Array type;@Deprecated_	public Class<?> getElementType() {_		return getElementTypeDescriptor().getType()__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,element,type,descriptor,element,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,element,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;deprecated,public,class,get,element,type,return,get,element,type,descriptor,get,type
TypeDescriptor -> @Deprecated 	public Class<?> getElementType();1356735495;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Collection or Array type;@Deprecated_	public Class<?> getElementType() {_		return getElementTypeDescriptor().getType()__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,element,type,descriptor,element,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,element,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;deprecated,public,class,get,element,type,return,get,element,type,descriptor,get,type
TypeDescriptor -> @Deprecated 	public Class<?> getElementType();1362408075;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Collection or Array type;@Deprecated_	public Class<?> getElementType() {_		return getElementTypeDescriptor().getType()__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,element,type,descriptor,element,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,element,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;deprecated,public,class,get,element,type,return,get,element,type,descriptor,get,type
TypeDescriptor -> @Deprecated 	public Class<?> getElementType();1368482696;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Collection or Array type;@Deprecated_	public Class<?> getElementType() {_		return getElementTypeDescriptor().getType()__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,element,type,descriptor,element,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,element,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;deprecated,public,class,get,element,type,return,get,element,type,descriptor,get,type
TypeDescriptor -> @Deprecated 	public Class<?> getElementType();1374614239;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Collection or Array type;@Deprecated_	public Class<?> getElementType() {_		return getElementTypeDescriptor().getType()__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,element,type,descriptor,element,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,element,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;deprecated,public,class,get,element,type,return,get,element,type,descriptor,get,type
TypeDescriptor -> @Deprecated 	public Class<?> getElementType();1382042882;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Collection or Array type;@Deprecated_	public Class<?> getElementType() {_		return getType(getElementTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,element,type,descriptor,element,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,element,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;deprecated,public,class,get,element,type,return,get,type,get,element,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getElementType();1382119085;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Collection or Array type;@Deprecated_	public Class<?> getElementType() {_		return getType(getElementTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,element,type,descriptor,element,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,element,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;deprecated,public,class,get,element,type,return,get,type,get,element,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getElementType();1382750081;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Collection or Array type;@Deprecated_	public Class<?> getElementType() {_		return getType(getElementTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,element,type,descriptor,element,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,element,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;deprecated,public,class,get,element,type,return,get,type,get,element,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getElementType();1387307647;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Collection or Array type;@Deprecated_	public Class<?> getElementType() {_		return getType(getElementTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,element,type,descriptor,element,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,element,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;deprecated,public,class,get,element,type,return,get,type,get,element,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getElementType();1387490898;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Collection or Array type;@Deprecated_	public Class<?> getElementType() {_		return getType(getElementTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,element,type,descriptor,element,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,element,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;deprecated,public,class,get,element,type,return,get,type,get,element,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getElementType();1389985540;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Collection or Array type;@Deprecated_	public Class<?> getElementType() {_		return getType(getElementTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,element,type,descriptor,element,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,element,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;deprecated,public,class,get,element,type,return,get,type,get,element,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getElementType();1390565795;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Collection or Array type;@Deprecated_	public Class<?> getElementType() {_		return getType(getElementTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,element,type,descriptor,element,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,element,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;deprecated,public,class,get,element,type,return,get,type,get,element,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getElementType();1390925810;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Collection or Array type;@Deprecated_	public Class<?> getElementType() {_		return getType(getElementTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,element,type,descriptor,element,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,element,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;deprecated,public,class,get,element,type,return,get,type,get,element,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getElementType();1391081201;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Collection or Array type;@Deprecated_	public Class<?> getElementType() {_		return getType(getElementTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,element,type,descriptor,element,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,element,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;deprecated,public,class,get,element,type,return,get,type,get,element,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getElementType();1391248381;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Collection or Array type;@Deprecated_	public Class<?> getElementType() {_		return getType(getElementTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,element,type,descriptor,element,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,element,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;deprecated,public,class,get,element,type,return,get,type,get,element,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getElementType();1394055372;Returns the value of {@link TypeDescriptor#getType() getType()} for the_{@link #getElementTypeDescriptor() elementTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;@Deprecated_	public Class<?> getElementType() {_		return getType(getElementTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,element,type,descriptor,element,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,element,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;deprecated,public,class,get,element,type,return,get,type,get,element,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getElementType();1395846555;Returns the value of {@link TypeDescriptor#getType() getType()} for the_{@link #getElementTypeDescriptor() elementTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;@Deprecated_	public Class<?> getElementType() {_		return getType(getElementTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,element,type,descriptor,element,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,element,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;deprecated,public,class,get,element,type,return,get,type,get,element,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getElementType();1403636229;Returns the value of {@link TypeDescriptor#getType() getType()} for the_{@link #getElementTypeDescriptor() elementTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;@Deprecated_	public Class<?> getElementType() {_		return getType(getElementTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,element,type,descriptor,element,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,element,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;deprecated,public,class,get,element,type,return,get,type,get,element,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getElementType();1405430015;Returns the value of {@link TypeDescriptor#getType() getType()} for the_{@link #getElementTypeDescriptor() elementTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;@Deprecated_	public Class<?> getElementType() {_		return getType(getElementTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,element,type,descriptor,element,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,element,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;deprecated,public,class,get,element,type,return,get,type,get,element,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getElementType();1406196817;Returns the value of {@link TypeDescriptor#getType() getType()} for the_{@link #getElementTypeDescriptor() elementTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;@Deprecated_	public Class<?> getElementType() {_		return getType(getElementTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,element,type,descriptor,element,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,element,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;deprecated,public,class,get,element,type,return,get,type,get,element,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getElementType();1412611699;Returns the value of {@link TypeDescriptor#getType() getType()} for the_{@link #getElementTypeDescriptor() elementTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;@Deprecated_	public Class<?> getElementType() {_		return getType(getElementTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,element,type,descriptor,element,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,element,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;deprecated,public,class,get,element,type,return,get,type,get,element,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getElementType();1414925289;Returns the value of {@link TypeDescriptor#getType() getType()} for the_{@link #getElementTypeDescriptor() elementTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;@Deprecated_	public Class<?> getElementType() {_		return getType(getElementTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,element,type,descriptor,element,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,element,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;deprecated,public,class,get,element,type,return,get,type,get,element,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getElementType();1417290561;Returns the value of {@link TypeDescriptor#getType() getType()} for the_{@link #getElementTypeDescriptor() elementTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;@Deprecated_	public Class<?> getElementType() {_		return getType(getElementTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,element,type,descriptor,element,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,element,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;deprecated,public,class,get,element,type,return,get,type,get,element,type,descriptor
TypeDescriptor -> @Nullable 	public static TypeDescriptor nested(Field field, int nestingLevel);1495868221;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;@Nullable_	public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;nullable,public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> @Nullable 	public static TypeDescriptor nested(Field field, int nestingLevel);1496259743;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;@Nullable_	public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;nullable,public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> @Nullable 	public static TypeDescriptor nested(Field field, int nestingLevel);1496837955;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;@Nullable_	public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;nullable,public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> @Nullable 	public static TypeDescriptor nested(Field field, int nestingLevel);1498780456;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;@Nullable_	public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;nullable,public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> @Nullable 	public static TypeDescriptor nested(Field field, int nestingLevel);1508084888;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;@Nullable_	public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;nullable,public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> @Nullable 	public static TypeDescriptor nested(Field field, int nestingLevel);1522332300;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;@Nullable_	public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;nullable,public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> @Nullable 	public static TypeDescriptor nested(Field field, int nestingLevel);1532520919;Creates a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the field is a {@code List<?>}, the nested type descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;@Nullable_	public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;nullable,public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> @Nullable 	public static TypeDescriptor nested(Field field, int nestingLevel);1546963887;Create a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not_declared. For example, if the field is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;@Nullable_	public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};create,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;nullable,public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> @Nullable 	public static TypeDescriptor nested(Field field, int nestingLevel);1547033218;Create a type descriptor for a nested type declared within the field._<p>For example, if the field is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the field is a {@code List<List<String>>} and the nesting level is_2, the nested type descriptor will also be a {@code String.class}._<p>If the field is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the field is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not_declared. For example, if the field is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param field the field_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the field_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;@Nullable_	public static TypeDescriptor nested(Field field, int nestingLevel) {_		return nested(new TypeDescriptor(field), nestingLevel)__	};create,a,type,descriptor,for,a,nested,type,declared,within,the,field,p,for,example,if,the,field,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,field,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,field,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,field,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,field,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,field,the,field,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,field,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;nullable,public,static,type,descriptor,nested,field,field,int,nesting,level,return,nested,new,type,descriptor,field,nesting,level
TypeDescriptor -> public boolean isArray();1328020251;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1329142650;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1335774711;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1349907422;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1351584957;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1351648403;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1356735495;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1362408075;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1368482696;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1374614239;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1382042882;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1382119085;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1382750081;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1387307647;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1387490898;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1389985540;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1390565795;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1390925810;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1391081201;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1391248381;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1394055372;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1395846555;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1403636229;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1405430015;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1406196817;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1412611699;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1414925289;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1417290561;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1419966315;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1424769447;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1424887506;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1425763631;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1431093918;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1432125256;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1441035153;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1448383050;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1450473050;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1467288171;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1467677340;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1467730834;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1477690406;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1478094883;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1479823020;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1479900301;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1480540964;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1481578128;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1482961889;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1495868221;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1496259743;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1496837955;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1498780456;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1508084888;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1522332300;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1532520919;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1546963887;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> public boolean isArray();1547033218;Is this type an array type?;public boolean isArray() {_		return getType().isArray()__	};is,this,type,an,array,type;public,boolean,is,array,return,get,type,is,array
TypeDescriptor -> @Nullable 	public static TypeDescriptor nested(Property property, int nestingLevel);1495868221;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;@Nullable_	public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;nullable,public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> @Nullable 	public static TypeDescriptor nested(Property property, int nestingLevel);1496259743;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;@Nullable_	public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;nullable,public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> @Nullable 	public static TypeDescriptor nested(Property property, int nestingLevel);1496837955;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;@Nullable_	public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;nullable,public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> @Nullable 	public static TypeDescriptor nested(Property property, int nestingLevel);1498780456;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;@Nullable_	public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;nullable,public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> @Nullable 	public static TypeDescriptor nested(Property property, int nestingLevel);1508084888;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;@Nullable_	public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;nullable,public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> @Nullable 	public static TypeDescriptor nested(Property property, int nestingLevel);1522332300;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;@Nullable_	public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;nullable,public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> @Nullable 	public static TypeDescriptor nested(Property property, int nestingLevel);1532520919;Creates a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the property is a {@code List<?>}, the nested type descriptor_returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;@Nullable_	public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;nullable,public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> @Nullable 	public static TypeDescriptor nested(Property property, int nestingLevel);1546963887;Create a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not_declared. For example, if the property is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;@Nullable_	public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};create,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;nullable,public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> @Nullable 	public static TypeDescriptor nested(Property property, int nestingLevel);1547033218;Create a type descriptor for a nested type declared within the property._<p>For example, if the property is a {@code List<String>} and the nesting_level is 1, the nested type descriptor will be {@code String.class}._<p>If the property is a {@code List<List<String>>} and the nesting level_is 2, the nested type descriptor will also be a {@code String.class}._<p>If the property is a {@code Map<Integer, String>} and the nesting level_is 1, the nested type descriptor will be String, derived from the map value._<p>If the property is a {@code List<Map<Integer, String>>} and the nesting_level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not_declared. For example, if the property is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param property the property_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the property_@return the nested type descriptor at the specified nesting level, or_{@code null} if it could not be obtained_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;@Nullable_	public static TypeDescriptor nested(Property property, int nestingLevel) {_		return nested(new TypeDescriptor(property), nestingLevel)__	};create,a,type,descriptor,for,a,nested,type,declared,within,the,property,p,for,example,if,the,property,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,code,string,class,p,if,the,property,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,code,string,class,p,if,the,property,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,property,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,property,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,property,the,property,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,property,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;nullable,public,static,type,descriptor,nested,property,property,int,nesting,level,return,nested,new,type,descriptor,property,nesting,level
TypeDescriptor -> public TypeDescriptor narrow(Object value);1328020251;Narrows this {@link TypeDescriptor} by setting its type to the class of the provided value._If the value is null, no narrowing is performed and this TypeDescriptor is returned unchanged._Designed to be called by binding frameworks when they read property, field, or method return values._Allows such frameworks to narrow a TypeDescriptor built from a declared property, field, or method return value type._For example, a field declared as java.lang.Object would be narrowed to java.util.HashMap if it was set to a java.util.HashMap value._The narrowed TypeDescriptor can then be used to convert the HashMap to some other type._Annotation and nested type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		return new TypeDescriptor(value.getClass(), this.elementTypeDescriptor,_				this.mapKeyTypeDescriptor, this.mapValueTypeDescriptor, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,if,the,value,is,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,java,lang,object,would,be,narrowed,to,java,util,hash,map,if,it,was,set,to,a,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,return,new,type,descriptor,value,get,class,this,element,type,descriptor,this,map,key,type,descriptor,this,map,value,type,descriptor,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1329142650;Narrows this {@link TypeDescriptor} by setting its type to the class of the provided value._If the value is null, no narrowing is performed and this TypeDescriptor is returned unchanged._Designed to be called by binding frameworks when they read property, field, or method return values._Allows such frameworks to narrow a TypeDescriptor built from a declared property, field, or method return value type._For example, a field declared as java.lang.Object would be narrowed to java.util.HashMap if it was set to a java.util.HashMap value._The narrowed TypeDescriptor can then be used to convert the HashMap to some other type._Annotation and nested type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		return new TypeDescriptor(value.getClass(), this.elementTypeDescriptor,_				this.mapKeyTypeDescriptor, this.mapValueTypeDescriptor, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,if,the,value,is,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,java,lang,object,would,be,narrowed,to,java,util,hash,map,if,it,was,set,to,a,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,return,new,type,descriptor,value,get,class,this,element,type,descriptor,this,map,key,type,descriptor,this,map,value,type,descriptor,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1335774711;Narrows this {@link TypeDescriptor} by setting its type to the class of the provided value._If the value is null, no narrowing is performed and this TypeDescriptor is returned unchanged._Designed to be called by binding frameworks when they read property, field, or method return values._Allows such frameworks to narrow a TypeDescriptor built from a declared property, field, or method return value type._For example, a field declared as java.lang.Object would be narrowed to java.util.HashMap if it was set to a java.util.HashMap value._The narrowed TypeDescriptor can then be used to convert the HashMap to some other type._Annotation and nested type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		return new TypeDescriptor(value.getClass(), this.elementTypeDescriptor,_				this.mapKeyTypeDescriptor, this.mapValueTypeDescriptor, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,if,the,value,is,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,java,lang,object,would,be,narrowed,to,java,util,hash,map,if,it,was,set,to,a,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,return,new,type,descriptor,value,get,class,this,element,type,descriptor,this,map,key,type,descriptor,this,map,value,type,descriptor,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1349907422;Narrows this {@link TypeDescriptor} by setting its type to the class of the provided value._If the value is null, no narrowing is performed and this TypeDescriptor is returned unchanged._Designed to be called by binding frameworks when they read property, field, or method return values._Allows such frameworks to narrow a TypeDescriptor built from a declared property, field, or method return value type._For example, a field declared as java.lang.Object would be narrowed to java.util.HashMap if it was set to a java.util.HashMap value._The narrowed TypeDescriptor can then be used to convert the HashMap to some other type._Annotation and nested type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		return new TypeDescriptor(value.getClass(), this.elementTypeDescriptor,_				this.mapKeyTypeDescriptor, this.mapValueTypeDescriptor, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,if,the,value,is,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,java,lang,object,would,be,narrowed,to,java,util,hash,map,if,it,was,set,to,a,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,return,new,type,descriptor,value,get,class,this,element,type,descriptor,this,map,key,type,descriptor,this,map,value,type,descriptor,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1351584957;Narrows this {@link TypeDescriptor} by setting its type to the class of the provided value._If the value is null, no narrowing is performed and this TypeDescriptor is returned unchanged._Designed to be called by binding frameworks when they read property, field, or method return values._Allows such frameworks to narrow a TypeDescriptor built from a declared property, field, or method return value type._For example, a field declared as java.lang.Object would be narrowed to java.util.HashMap if it was set to a java.util.HashMap value._The narrowed TypeDescriptor can then be used to convert the HashMap to some other type._Annotation and nested type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		return new TypeDescriptor(value.getClass(), this.elementTypeDescriptor,_				this.mapKeyTypeDescriptor, this.mapValueTypeDescriptor, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,if,the,value,is,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,java,lang,object,would,be,narrowed,to,java,util,hash,map,if,it,was,set,to,a,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,return,new,type,descriptor,value,get,class,this,element,type,descriptor,this,map,key,type,descriptor,this,map,value,type,descriptor,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1351648403;Narrows this {@link TypeDescriptor} by setting its type to the class of the provided value._If the value is <code>null</code>, no narrowing is performed and this TypeDescriptor is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field, or method return values._Allows such frameworks to narrow a TypeDescriptor built from a declared property, field, or method return value type._For example, a field declared as <code>java.lang.Object</code> would be narrowed to <code>java.util.HashMap</code>_if it was set to a <code>java.util.HashMap</code> value. The narrowed TypeDescriptor can then be used to convert_the HashMap to some other type. Annotation and nested type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		return new TypeDescriptor(value.getClass(), this.elementTypeDescriptor,_				this.mapKeyTypeDescriptor, this.mapValueTypeDescriptor, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,if,the,value,is,code,null,code,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,code,would,be,narrowed,to,code,java,util,hash,map,code,if,it,was,set,to,a,code,java,util,hash,map,code,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,return,new,type,descriptor,value,get,class,this,element,type,descriptor,this,map,key,type,descriptor,this,map,value,type,descriptor,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1356735495;Narrows this {@link TypeDescriptor} by setting its type to the class of the provided value._If the value is {@code null}, no narrowing is performed and this TypeDescriptor is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field, or method return values._Allows such frameworks to narrow a TypeDescriptor built from a declared property, field, or method return value type._For example, a field declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor can then be used to convert_the HashMap to some other type. Annotation and nested type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		return new TypeDescriptor(value.getClass(), this.elementTypeDescriptor,_				this.mapKeyTypeDescriptor, this.mapValueTypeDescriptor, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,return,new,type,descriptor,value,get,class,this,element,type,descriptor,this,map,key,type,descriptor,this,map,value,type,descriptor,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1362408075;Narrows this {@link TypeDescriptor} by setting its type to the class of the provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field, or method return values._Allows such frameworks to narrow a TypeDescriptor built from a declared property, field, or method return value type._For example, a field declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor can then be used to convert_the HashMap to some other type. Annotation and nested type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		return new TypeDescriptor(value.getClass(), this.elementTypeDescriptor,_				this.mapKeyTypeDescriptor, this.mapValueTypeDescriptor, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,return,new,type,descriptor,value,get,class,this,element,type,descriptor,this,map,key,type,descriptor,this,map,value,type,descriptor,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1368482696;Narrows this {@link TypeDescriptor} by setting its type to the class of the provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field, or method return values._Allows such frameworks to narrow a TypeDescriptor built from a declared property, field, or method return value type._For example, a field declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor can then be used to convert_the HashMap to some other type. Annotation and nested type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		return new TypeDescriptor(value.getClass(), this.elementTypeDescriptor,_				this.mapKeyTypeDescriptor, this.mapValueTypeDescriptor, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,return,new,type,descriptor,value,get,class,this,element,type,descriptor,this,map,key,type,descriptor,this,map,value,type,descriptor,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1374614239;Narrows this {@link TypeDescriptor} by setting its type to the class of the provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field, or method return values._Allows such frameworks to narrow a TypeDescriptor built from a declared property, field, or method return value type._For example, a field declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor can then be used to convert_the HashMap to some other type. Annotation and nested type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		return new TypeDescriptor(value.getClass(), this.elementTypeDescriptor,_				this.mapKeyTypeDescriptor, this.mapValueTypeDescriptor, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,return,new,type,descriptor,value,get,class,this,element,type,descriptor,this,map,key,type,descriptor,this,map,value,type,descriptor,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1382042882;Narrows this {@link TypeDescriptor} by setting its type to the class of the provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field, or method return values._Allows such frameworks to narrow a TypeDescriptor built from a declared property, field, or method return value type._For example, a field declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor can then be used to convert_the HashMap to some other type. Annotation and nested type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), this.resolvableType)__		return new TypeDescriptor(narrowed, null, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,this,resolvable,type,return,new,type,descriptor,narrowed,null,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1382119085;Narrows this {@link TypeDescriptor} by setting its type to the class of the provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field, or method return values._Allows such frameworks to narrow a TypeDescriptor built from a declared property, field, or method return value type._For example, a field declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor can then be used to convert_the HashMap to some other type. Annotation and nested type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), this.resolvableType)__		return new TypeDescriptor(narrowed, null, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,this,resolvable,type,return,new,type,descriptor,narrowed,null,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1382750081;Narrows this {@link TypeDescriptor} by setting its type to the class of the provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field, or method return values._Allows such frameworks to narrow a TypeDescriptor built from a declared property, field, or method return value type._For example, a field declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor can then be used to convert_the HashMap to some other type. Annotation and nested type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), this.resolvableType)__		return new TypeDescriptor(narrowed, null, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,this,resolvable,type,return,new,type,descriptor,narrowed,null,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1387307647;Narrows this {@link TypeDescriptor} by setting its type to the class of the provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field, or method return values._Allows such frameworks to narrow a TypeDescriptor built from a declared property, field, or method return value type._For example, a field declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor can then be used to convert_the HashMap to some other type. Annotation and nested type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), this.resolvableType)__		return new TypeDescriptor(narrowed, null, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,this,resolvable,type,return,new,type,descriptor,narrowed,null,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1387490898;Narrows this {@link TypeDescriptor} by setting its type to the class of the provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field, or method return values._Allows such frameworks to narrow a TypeDescriptor built from a declared property, field, or method return value type._For example, a field declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor can then be used to convert_the HashMap to some other type. Annotation and nested type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), this.resolvableType)__		return new TypeDescriptor(narrowed, null, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,this,resolvable,type,return,new,type,descriptor,narrowed,null,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1389985540;Narrows this {@link TypeDescriptor} by setting its type to the class of the provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field, or method return values._Allows such frameworks to narrow a TypeDescriptor built from a declared property, field, or method return value type._For example, a field declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor can then be used to convert_the HashMap to some other type. Annotation and nested type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), this.resolvableType)__		return new TypeDescriptor(narrowed, null, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,this,resolvable,type,return,new,type,descriptor,narrowed,null,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1390565795;Narrows this {@link TypeDescriptor} by setting its type to the class of the provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field, or method return values._Allows such frameworks to narrow a TypeDescriptor built from a declared property, field, or method return value type._For example, a field declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor can then be used to convert_the HashMap to some other type. Annotation and nested type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), this.resolvableType)__		return new TypeDescriptor(narrowed, null, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,this,resolvable,type,return,new,type,descriptor,narrowed,null,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1390925810;Narrows this {@link TypeDescriptor} by setting its type to the class of the provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field, or method return values._Allows such frameworks to narrow a TypeDescriptor built from a declared property, field, or method return value type._For example, a field declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor can then be used to convert_the HashMap to some other type. Annotation and nested type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), this.resolvableType)__		return new TypeDescriptor(narrowed, null, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,this,resolvable,type,return,new,type,descriptor,narrowed,null,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1391081201;Narrows this {@link TypeDescriptor} by setting its type to the class of the provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field, or method return values._Allows such frameworks to narrow a TypeDescriptor built from a declared property, field, or method return value type._For example, a field declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor can then be used to convert_the HashMap to some other type. Annotation and nested type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), this.resolvableType)__		return new TypeDescriptor(narrowed, null, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,this,resolvable,type,return,new,type,descriptor,narrowed,null,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1391248381;Narrows this {@link TypeDescriptor} by setting its type to the class of the provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field, or method return values._Allows such frameworks to narrow a TypeDescriptor built from a declared property, field, or method return value type._For example, a field declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor can then be used to convert_the HashMap to some other type. Annotation and nested type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), this.resolvableType)__		return new TypeDescriptor(narrowed, null, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,this,resolvable,type,return,new,type,descriptor,narrowed,null,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1394055372;Narrows this {@link TypeDescriptor} by setting its type to the class of the_provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor_is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field,_or method return values. Allows such frameworks to narrow a TypeDescriptor built_from a declared property, field, or method return value type. For example, a field_declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor_can then be used to convert the HashMap to some other type. Annotation and nested_type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the_class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), this.resolvableType)__		return new TypeDescriptor(narrowed, null, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,this,resolvable,type,return,new,type,descriptor,narrowed,null,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1395846555;Narrows this {@link TypeDescriptor} by setting its type to the class of the_provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor_is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field,_or method return values. Allows such frameworks to narrow a TypeDescriptor built_from a declared property, field, or method return value type. For example, a field_declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor_can then be used to convert the HashMap to some other type. Annotation and nested_type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the_class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), this.resolvableType)__		return new TypeDescriptor(narrowed, null, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,this,resolvable,type,return,new,type,descriptor,narrowed,null,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1403636229;Narrows this {@link TypeDescriptor} by setting its type to the class of the_provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor_is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field,_or method return values. Allows such frameworks to narrow a TypeDescriptor built_from a declared property, field, or method return value type. For example, a field_declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor_can then be used to convert the HashMap to some other type. Annotation and nested_type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the_class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), this.resolvableType)__		return new TypeDescriptor(narrowed, null, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,this,resolvable,type,return,new,type,descriptor,narrowed,null,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1405430015;Narrows this {@link TypeDescriptor} by setting its type to the class of the_provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor_is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field,_or method return values. Allows such frameworks to narrow a TypeDescriptor built_from a declared property, field, or method return value type. For example, a field_declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor_can then be used to convert the HashMap to some other type. Annotation and nested_type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the_class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), this.resolvableType)__		return new TypeDescriptor(narrowed, null, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,this,resolvable,type,return,new,type,descriptor,narrowed,null,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1406196817;Narrows this {@link TypeDescriptor} by setting its type to the class of the_provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor_is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field,_or method return values. Allows such frameworks to narrow a TypeDescriptor built_from a declared property, field, or method return value type. For example, a field_declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor_can then be used to convert the HashMap to some other type. Annotation and nested_type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the_class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), this.resolvableType)__		return new TypeDescriptor(narrowed, null, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,this,resolvable,type,return,new,type,descriptor,narrowed,null,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1412611699;Narrows this {@link TypeDescriptor} by setting its type to the class of the_provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor_is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field,_or method return values. Allows such frameworks to narrow a TypeDescriptor built_from a declared property, field, or method return value type. For example, a field_declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor_can then be used to convert the HashMap to some other type. Annotation and nested_type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the_class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), this.resolvableType)__		return new TypeDescriptor(narrowed, null, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,this,resolvable,type,return,new,type,descriptor,narrowed,null,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1414925289;Narrows this {@link TypeDescriptor} by setting its type to the class of the_provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor_is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field,_or method return values. Allows such frameworks to narrow a TypeDescriptor built_from a declared property, field, or method return value type. For example, a field_declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor_can then be used to convert the HashMap to some other type. Annotation and nested_type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the_class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), this.resolvableType)__		return new TypeDescriptor(narrowed, null, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,this,resolvable,type,return,new,type,descriptor,narrowed,null,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1417290561;Narrows this {@link TypeDescriptor} by setting its type to the class of the_provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor_is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field,_or method return values. Allows such frameworks to narrow a TypeDescriptor built_from a declared property, field, or method return value type. For example, a field_declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor_can then be used to convert the HashMap to some other type. Annotation and nested_type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the_class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), this.resolvableType)__		return new TypeDescriptor(narrowed, null, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,this,resolvable,type,return,new,type,descriptor,narrowed,null,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1419966315;Narrows this {@link TypeDescriptor} by setting its type to the class of the_provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor_is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field,_or method return values. Allows such frameworks to narrow a TypeDescriptor built_from a declared property, field, or method return value type. For example, a field_declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor_can then be used to convert the HashMap to some other type. Annotation and nested_type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the_class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), this.resolvableType)__		return new TypeDescriptor(narrowed, null, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,this,resolvable,type,return,new,type,descriptor,narrowed,null,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1424769447;Narrows this {@link TypeDescriptor} by setting its type to the class of the_provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor_is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field,_or method return values. Allows such frameworks to narrow a TypeDescriptor built_from a declared property, field, or method return value type. For example, a field_declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor_can then be used to convert the HashMap to some other type. Annotation and nested_type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the_class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), this.resolvableType)__		return new TypeDescriptor(narrowed, null, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,this,resolvable,type,return,new,type,descriptor,narrowed,null,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1424887506;Narrows this {@link TypeDescriptor} by setting its type to the class of the_provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor_is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field,_or method return values. Allows such frameworks to narrow a TypeDescriptor built_from a declared property, field, or method return value type. For example, a field_declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor_can then be used to convert the HashMap to some other type. Annotation and nested_type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the_class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), this.resolvableType)__		return new TypeDescriptor(narrowed, null, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,this,resolvable,type,return,new,type,descriptor,narrowed,null,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1425763631;Narrows this {@link TypeDescriptor} by setting its type to the class of the_provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor_is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field,_or method return values. Allows such frameworks to narrow a TypeDescriptor built_from a declared property, field, or method return value type. For example, a field_declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor_can then be used to convert the HashMap to some other type. Annotation and nested_type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the_class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), this.resolvableType)__		return new TypeDescriptor(narrowed, null, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,this,resolvable,type,return,new,type,descriptor,narrowed,null,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1431093918;Narrows this {@link TypeDescriptor} by setting its type to the class of the_provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor_is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field,_or method return values. Allows such frameworks to narrow a TypeDescriptor built_from a declared property, field, or method return value type. For example, a field_declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor_can then be used to convert the HashMap to some other type. Annotation and nested_type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the_class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), this.resolvableType)__		return new TypeDescriptor(narrowed, null, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,this,resolvable,type,return,new,type,descriptor,narrowed,null,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1432125256;Narrows this {@link TypeDescriptor} by setting its type to the class of the_provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor_is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field,_or method return values. Allows such frameworks to narrow a TypeDescriptor built_from a declared property, field, or method return value type. For example, a field_declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor_can then be used to convert the HashMap to some other type. Annotation and nested_type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the_class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), this.resolvableType)__		return new TypeDescriptor(narrowed, null, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,this,resolvable,type,return,new,type,descriptor,narrowed,null,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1441035153;Narrows this {@link TypeDescriptor} by setting its type to the class of the_provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor_is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field,_or method return values. Allows such frameworks to narrow a TypeDescriptor built_from a declared property, field, or method return value type. For example, a field_declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor_can then be used to convert the HashMap to some other type. Annotation and nested_type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the_class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), this.resolvableType)__		return new TypeDescriptor(narrowed, null, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,this,resolvable,type,return,new,type,descriptor,narrowed,null,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1448383050;Narrows this {@link TypeDescriptor} by setting its type to the class of the_provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor_is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field,_or method return values. Allows such frameworks to narrow a TypeDescriptor built_from a declared property, field, or method return value type. For example, a field_declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor_can then be used to convert the HashMap to some other type. Annotation and nested_type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the_class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), this.resolvableType)__		return new TypeDescriptor(narrowed, null, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,this,resolvable,type,return,new,type,descriptor,narrowed,null,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1450473050;Narrows this {@link TypeDescriptor} by setting its type to the class of the_provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor_is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field,_or method return values. Allows such frameworks to narrow a TypeDescriptor built_from a declared property, field, or method return value type. For example, a field_declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor_can then be used to convert the HashMap to some other type. Annotation and nested_type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the_class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), this.resolvableType)__		return new TypeDescriptor(narrowed, null, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,this,resolvable,type,return,new,type,descriptor,narrowed,null,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1467288171;Narrows this {@link TypeDescriptor} by setting its type to the class of the_provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor_is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field,_or method return values. Allows such frameworks to narrow a TypeDescriptor built_from a declared property, field, or method return value type. For example, a field_declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor_can then be used to convert the HashMap to some other type. Annotation and nested_type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the_class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), this.resolvableType)__		return new TypeDescriptor(narrowed, null, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,this,resolvable,type,return,new,type,descriptor,narrowed,null,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1467677340;Narrows this {@link TypeDescriptor} by setting its type to the class of the_provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor_is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field,_or method return values. Allows such frameworks to narrow a TypeDescriptor built_from a declared property, field, or method return value type. For example, a field_declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor_can then be used to convert the HashMap to some other type. Annotation and nested_type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the_class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), this.resolvableType)__		return new TypeDescriptor(narrowed, null, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,this,resolvable,type,return,new,type,descriptor,narrowed,null,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1467730834;Narrows this {@link TypeDescriptor} by setting its type to the class of the_provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor_is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field,_or method return values. Allows such frameworks to narrow a TypeDescriptor built_from a declared property, field, or method return value type. For example, a field_declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor_can then be used to convert the HashMap to some other type. Annotation and nested_type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the_class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), this.resolvableType)__		return new TypeDescriptor(narrowed, null, this.annotations)__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,this,resolvable,type,return,new,type,descriptor,narrowed,null,this,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1477690406;Narrows this {@link TypeDescriptor} by setting its type to the class of the_provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor_is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field,_or method return values. Allows such frameworks to narrow a TypeDescriptor built_from a declared property, field, or method return value type. For example, a field_declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor_can then be used to convert the HashMap to some other type. Annotation and nested_type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the_class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), getResolvableType())__		return new TypeDescriptor(narrowed, null, getAnnotations())__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,get,resolvable,type,return,new,type,descriptor,narrowed,null,get,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1478094883;Narrows this {@link TypeDescriptor} by setting its type to the class of the_provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor_is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field,_or method return values. Allows such frameworks to narrow a TypeDescriptor built_from a declared property, field, or method return value type. For example, a field_declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor_can then be used to convert the HashMap to some other type. Annotation and nested_type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the_class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), getResolvableType())__		return new TypeDescriptor(narrowed, null, getAnnotations())__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,get,resolvable,type,return,new,type,descriptor,narrowed,null,get,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1479823020;Narrows this {@link TypeDescriptor} by setting its type to the class of the_provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor_is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field,_or method return values. Allows such frameworks to narrow a TypeDescriptor built_from a declared property, field, or method return value type. For example, a field_declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor_can then be used to convert the HashMap to some other type. Annotation and nested_type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the_class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), getResolvableType())__		return new TypeDescriptor(narrowed, null, getAnnotations())__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,get,resolvable,type,return,new,type,descriptor,narrowed,null,get,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1479900301;Narrows this {@link TypeDescriptor} by setting its type to the class of the_provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor_is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field,_or method return values. Allows such frameworks to narrow a TypeDescriptor built_from a declared property, field, or method return value type. For example, a field_declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor_can then be used to convert the HashMap to some other type. Annotation and nested_type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the_class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), getResolvableType())__		return new TypeDescriptor(narrowed, null, getAnnotations())__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,get,resolvable,type,return,new,type,descriptor,narrowed,null,get,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1480540964;Narrows this {@link TypeDescriptor} by setting its type to the class of the_provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor_is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field,_or method return values. Allows such frameworks to narrow a TypeDescriptor built_from a declared property, field, or method return value type. For example, a field_declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor_can then be used to convert the HashMap to some other type. Annotation and nested_type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the_class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), getResolvableType())__		return new TypeDescriptor(narrowed, null, getAnnotations())__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,get,resolvable,type,return,new,type,descriptor,narrowed,null,get,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1481578128;Narrows this {@link TypeDescriptor} by setting its type to the class of the_provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor_is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field,_or method return values. Allows such frameworks to narrow a TypeDescriptor built_from a declared property, field, or method return value type. For example, a field_declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor_can then be used to convert the HashMap to some other type. Annotation and nested_type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the_class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), getResolvableType())__		return new TypeDescriptor(narrowed, value.getClass(), getAnnotations())__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,get,resolvable,type,return,new,type,descriptor,narrowed,value,get,class,get,annotations
TypeDescriptor -> public TypeDescriptor narrow(Object value);1482961889;Narrows this {@link TypeDescriptor} by setting its type to the class of the_provided value._<p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor_is returned unchanged._<p>Designed to be called by binding frameworks when they read property, field,_or method return values. Allows such frameworks to narrow a TypeDescriptor built_from a declared property, field, or method return value type. For example, a field_declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}_if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor_can then be used to convert the HashMap to some other type. Annotation and nested_type context is preserved by the narrowed copy._@param value the value to use for narrowing this type descriptor_@return this TypeDescriptor narrowed (returns a copy with its type updated to the_class of the provided value);public TypeDescriptor narrow(Object value) {_		if (value == null) {_			return this__		}_		ResolvableType narrowed = ResolvableType.forType(value.getClass(), getResolvableType())__		return new TypeDescriptor(narrowed, value.getClass(), getAnnotations())__	};narrows,this,link,type,descriptor,by,setting,its,type,to,the,class,of,the,provided,value,p,if,the,value,is,code,null,no,narrowing,is,performed,and,this,type,descriptor,is,returned,unchanged,p,designed,to,be,called,by,binding,frameworks,when,they,read,property,field,or,method,return,values,allows,such,frameworks,to,narrow,a,type,descriptor,built,from,a,declared,property,field,or,method,return,value,type,for,example,a,field,declared,as,code,java,lang,object,would,be,narrowed,to,code,java,util,hash,map,if,it,was,set,to,a,code,java,util,hash,map,value,the,narrowed,type,descriptor,can,then,be,used,to,convert,the,hash,map,to,some,other,type,annotation,and,nested,type,context,is,preserved,by,the,narrowed,copy,param,value,the,value,to,use,for,narrowing,this,type,descriptor,return,this,type,descriptor,narrowed,returns,a,copy,with,its,type,updated,to,the,class,of,the,provided,value;public,type,descriptor,narrow,object,value,if,value,null,return,this,resolvable,type,narrowed,resolvable,type,for,type,value,get,class,get,resolvable,type,return,new,type,descriptor,narrowed,value,get,class,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1328020251;Create a new type descriptor from a {@link Field}._Use this constructor when source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		this(new FieldDescriptor(field))__	};create,a,new,type,descriptor,from,a,link,field,use,this,constructor,when,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,this,new,field,descriptor,field
TypeDescriptor -> public TypeDescriptor(Field field);1329142650;Create a new type descriptor from a {@link Field}._Use this constructor when source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		this(new FieldDescriptor(field))__	};create,a,new,type,descriptor,from,a,link,field,use,this,constructor,when,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,this,new,field,descriptor,field
TypeDescriptor -> public TypeDescriptor(Field field);1335774711;Create a new type descriptor from a {@link Field}._Use this constructor when source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		this(new FieldDescriptor(field))__	};create,a,new,type,descriptor,from,a,link,field,use,this,constructor,when,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,this,new,field,descriptor,field
TypeDescriptor -> public TypeDescriptor(Field field);1349907422;Create a new type descriptor from a {@link Field}._Use this constructor when source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		this(new FieldDescriptor(field))__	};create,a,new,type,descriptor,from,a,link,field,use,this,constructor,when,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,this,new,field,descriptor,field
TypeDescriptor -> public TypeDescriptor(Field field);1351584957;Create a new type descriptor from a {@link Field}._Use this constructor when source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		this(new FieldDescriptor(field))__	};create,a,new,type,descriptor,from,a,link,field,use,this,constructor,when,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,this,new,field,descriptor,field
TypeDescriptor -> public TypeDescriptor(Field field);1351648403;Create a new type descriptor from a {@link Field}._Use this constructor when source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		this(new FieldDescriptor(field))__	};create,a,new,type,descriptor,from,a,link,field,use,this,constructor,when,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,this,new,field,descriptor,field
TypeDescriptor -> public TypeDescriptor(Field field);1356735495;Create a new type descriptor from a {@link Field}._Use this constructor when source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		this(new FieldDescriptor(field))__	};create,a,new,type,descriptor,from,a,link,field,use,this,constructor,when,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,this,new,field,descriptor,field
TypeDescriptor -> public TypeDescriptor(Field field);1362408075;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		this(new FieldDescriptor(field))__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,this,new,field,descriptor,field
TypeDescriptor -> public TypeDescriptor(Field field);1368482696;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		this(new FieldDescriptor(field))__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,this,new,field,descriptor,field
TypeDescriptor -> public TypeDescriptor(Field field);1374614239;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		this(new FieldDescriptor(field))__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,this,new,field,descriptor,field
TypeDescriptor -> public TypeDescriptor(Field field);1382042882;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		Assert.notNull(field, "Field must not be null")__		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(Object.class)__		this.annotations = nullSafeAnnotations(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,assert,not,null,field,field,must,not,be,null,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1382119085;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		Assert.notNull(field, "Field must not be null")__		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(Object.class)__		this.annotations = nullSafeAnnotations(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,assert,not,null,field,field,must,not,be,null,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1382750081;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		Assert.notNull(field, "Field must not be null")__		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(Object.class)__		this.annotations = nullSafeAnnotations(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,assert,not,null,field,field,must,not,be,null,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1387307647;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		Assert.notNull(field, "Field must not be null")__		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(Object.class)__		this.annotations = nullSafeAnnotations(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,assert,not,null,field,field,must,not,be,null,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1387490898;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		Assert.notNull(field, "Field must not be null")__		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(Object.class)__		this.annotations = nullSafeAnnotations(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,assert,not,null,field,field,must,not,be,null,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1389985540;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		Assert.notNull(field, "Field must not be null")__		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(Object.class)__		this.annotations = nullSafeAnnotations(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,assert,not,null,field,field,must,not,be,null,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1390565795;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		Assert.notNull(field, "Field must not be null")__		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(Object.class)__		this.annotations = nullSafeAnnotations(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,assert,not,null,field,field,must,not,be,null,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1390925810;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		Assert.notNull(field, "Field must not be null")__		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(Object.class)__		this.annotations = nullSafeAnnotations(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,assert,not,null,field,field,must,not,be,null,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1391081201;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		Assert.notNull(field, "Field must not be null")__		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(Object.class)__		this.annotations = nullSafeAnnotations(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,assert,not,null,field,field,must,not,be,null,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1391248381;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		Assert.notNull(field, "Field must not be null")__		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(Object.class)__		this.annotations = nullSafeAnnotations(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,assert,not,null,field,field,must,not,be,null,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1394055372;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		Assert.notNull(field, "Field must not be null")__		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(field.getType())__		this.annotations = nullSafeAnnotations(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,assert,not,null,field,field,must,not,be,null,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,field,get,type,this,annotations,null,safe,annotations,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1395846555;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		Assert.notNull(field, "Field must not be null")__		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(field.getType())__		this.annotations = nullSafeAnnotations(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,assert,not,null,field,field,must,not,be,null,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,field,get,type,this,annotations,null,safe,annotations,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1403636229;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		Assert.notNull(field, "Field must not be null")__		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(field.getType())__		this.annotations = nullSafeAnnotations(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,assert,not,null,field,field,must,not,be,null,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,field,get,type,this,annotations,null,safe,annotations,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1405430015;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		Assert.notNull(field, "Field must not be null")__		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(field.getType())__		this.annotations = nullSafeAnnotations(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,assert,not,null,field,field,must,not,be,null,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,field,get,type,this,annotations,null,safe,annotations,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1406196817;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		Assert.notNull(field, "Field must not be null")__		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(field.getType())__		this.annotations = nullSafeAnnotations(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,assert,not,null,field,field,must,not,be,null,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,field,get,type,this,annotations,null,safe,annotations,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1412611699;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		Assert.notNull(field, "Field must not be null")__		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(field.getType())__		this.annotations = nullSafeAnnotations(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,assert,not,null,field,field,must,not,be,null,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,field,get,type,this,annotations,null,safe,annotations,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1414925289;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		Assert.notNull(field, "Field must not be null")__		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(field.getType())__		this.annotations = nullSafeAnnotations(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,assert,not,null,field,field,must,not,be,null,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,field,get,type,this,annotations,null,safe,annotations,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1417290561;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		Assert.notNull(field, "Field must not be null")__		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(field.getType())__		this.annotations = nullSafeAnnotations(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,assert,not,null,field,field,must,not,be,null,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,field,get,type,this,annotations,null,safe,annotations,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1419966315;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		Assert.notNull(field, "Field must not be null")__		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(field.getType())__		this.annotations = nullSafeAnnotations(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,assert,not,null,field,field,must,not,be,null,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,field,get,type,this,annotations,null,safe,annotations,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1424769447;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		Assert.notNull(field, "Field must not be null")__		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(field.getType())__		this.annotations = nullSafeAnnotations(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,assert,not,null,field,field,must,not,be,null,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,field,get,type,this,annotations,null,safe,annotations,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1424887506;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		Assert.notNull(field, "Field must not be null")__		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(field.getType())__		this.annotations = nullSafeAnnotations(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,assert,not,null,field,field,must,not,be,null,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,field,get,type,this,annotations,null,safe,annotations,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1425763631;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		Assert.notNull(field, "Field must not be null")__		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(field.getType())__		this.annotations = nullSafeAnnotations(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,assert,not,null,field,field,must,not,be,null,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,field,get,type,this,annotations,null,safe,annotations,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1431093918;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		Assert.notNull(field, "Field must not be null")__		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(field.getType())__		this.annotations = nullSafeAnnotations(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,assert,not,null,field,field,must,not,be,null,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,field,get,type,this,annotations,null,safe,annotations,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1432125256;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		Assert.notNull(field, "Field must not be null")__		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(field.getType())__		this.annotations = nullSafeAnnotations(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,assert,not,null,field,field,must,not,be,null,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,field,get,type,this,annotations,null,safe,annotations,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1441035153;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		Assert.notNull(field, "Field must not be null")__		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(field.getType())__		this.annotations = nullSafeAnnotations(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,assert,not,null,field,field,must,not,be,null,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,field,get,type,this,annotations,null,safe,annotations,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1448383050;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		Assert.notNull(field, "Field must not be null")__		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(field.getType())__		this.annotations = nullSafeAnnotations(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,assert,not,null,field,field,must,not,be,null,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,field,get,type,this,annotations,null,safe,annotations,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1450473050;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		Assert.notNull(field, "Field must not be null")__		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(field.getType())__		this.annotations = nullSafeAnnotations(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,assert,not,null,field,field,must,not,be,null,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,field,get,type,this,annotations,null,safe,annotations,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1467288171;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		Assert.notNull(field, "Field must not be null")__		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(field.getType())__		this.annotations = nullSafeAnnotations(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,assert,not,null,field,field,must,not,be,null,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,field,get,type,this,annotations,null,safe,annotations,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1467677340;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		Assert.notNull(field, "Field must not be null")__		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(field.getType())__		this.annotations = nullSafeAnnotations(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,assert,not,null,field,field,must,not,be,null,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,field,get,type,this,annotations,null,safe,annotations,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1467730834;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		Assert.notNull(field, "Field must not be null")__		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(field.getType())__		this.annotations = nullSafeAnnotations(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,assert,not,null,field,field,must,not,be,null,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,field,get,type,this,annotations,null,safe,annotations,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1477690406;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		Assert.notNull(field, "Field must not be null")__		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(field.getType())__		this.annotatedElement = new AnnotatedElementAdapter(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,assert,not,null,field,field,must,not,be,null,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,field,get,type,this,annotated,element,new,annotated,element,adapter,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1478094883;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		Assert.notNull(field, "Field must not be null")__		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(field.getType())__		this.annotatedElement = new AnnotatedElementAdapter(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,assert,not,null,field,field,must,not,be,null,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,field,get,type,this,annotated,element,new,annotated,element,adapter,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1479823020;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		Assert.notNull(field, "Field must not be null")__		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(field.getType())__		this.annotatedElement = new AnnotatedElementAdapter(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,assert,not,null,field,field,must,not,be,null,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,field,get,type,this,annotated,element,new,annotated,element,adapter,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1479900301;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		Assert.notNull(field, "Field must not be null")__		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(field.getType())__		this.annotatedElement = new AnnotatedElementAdapter(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,assert,not,null,field,field,must,not,be,null,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,field,get,type,this,annotated,element,new,annotated,element,adapter,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1480540964;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(field.getType())__		this.annotatedElement = new AnnotatedElementAdapter(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,field,get,type,this,annotated,element,new,annotated,element,adapter,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1481578128;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(field.getType())__		this.annotatedElement = new AnnotatedElementAdapter(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,field,get,type,this,annotated,element,new,annotated,element,adapter,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1482961889;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(field.getType())__		this.annotatedElement = new AnnotatedElementAdapter(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,field,get,type,this,annotated,element,new,annotated,element,adapter,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1495868221;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(field.getType())__		this.annotatedElement = new AnnotatedElementAdapter(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,field,get,type,this,annotated,element,new,annotated,element,adapter,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1496259743;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(field.getType())__		this.annotatedElement = new AnnotatedElementAdapter(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,field,get,type,this,annotated,element,new,annotated,element,adapter,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1496837955;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(field.getType())__		this.annotatedElement = new AnnotatedElementAdapter(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,field,get,type,this,annotated,element,new,annotated,element,adapter,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1498780456;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(field.getType())__		this.annotatedElement = new AnnotatedElementAdapter(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,field,get,type,this,annotated,element,new,annotated,element,adapter,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1508084888;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(field.getType())__		this.annotatedElement = new AnnotatedElementAdapter(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,field,get,type,this,annotated,element,new,annotated,element,adapter,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1522332300;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(field.getType())__		this.annotatedElement = new AnnotatedElementAdapter(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,field,get,type,this,annotated,element,new,annotated,element,adapter,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1532520919;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(field.getType())__		this.annotatedElement = new AnnotatedElementAdapter(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,field,get,type,this,annotated,element,new,annotated,element,adapter,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1546963887;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(field.getType())__		this.annotatedElement = new AnnotatedElementAdapter(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,field,get,type,this,annotated,element,new,annotated,element,adapter,field,get,annotations
TypeDescriptor -> public TypeDescriptor(Field field);1547033218;Create a new type descriptor from a {@link Field}._<p>Use this constructor when a source or target conversion point is a field._@param field the field;public TypeDescriptor(Field field) {_		this.resolvableType = ResolvableType.forField(field)__		this.type = this.resolvableType.resolve(field.getType())__		this.annotatedElement = new AnnotatedElementAdapter(field.getAnnotations())__	};create,a,new,type,descriptor,from,a,link,field,p,use,this,constructor,when,a,source,or,target,conversion,point,is,a,field,param,field,the,field;public,type,descriptor,field,field,this,resolvable,type,resolvable,type,for,field,field,this,type,this,resolvable,type,resolve,field,get,type,this,annotated,element,new,annotated,element,adapter,field,get,annotations
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1328020251;If this type is an array, returns the array's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns null indicating the element type is not declared._@return the array component type or Collection element type, or <code>null</code> if this type is a Collection but its element type is not parameterized._@throws IllegalStateException if this type is not a java.util.Collection or Array type;public TypeDescriptor getElementTypeDescriptor() {_		assertCollectionOrArray()__		return this.elementTypeDescriptor__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,code,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,assert,collection,or,array,return,this,element,type,descriptor
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1329142650;If this type is an array, returns the array's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns null indicating the element type is not declared._@return the array component type or Collection element type, or <code>null</code> if this type is a Collection but its element type is not parameterized._@throws IllegalStateException if this type is not a java.util.Collection or Array type;public TypeDescriptor getElementTypeDescriptor() {_		assertCollectionOrArray()__		return this.elementTypeDescriptor__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,code,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,assert,collection,or,array,return,this,element,type,descriptor
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1335774711;If this type is an array, returns the array's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns null indicating the element type is not declared._@return the array component type or Collection element type, or <code>null</code> if this type is a Collection but its element type is not parameterized._@throws IllegalStateException if this type is not a java.util.Collection or Array type;public TypeDescriptor getElementTypeDescriptor() {_		assertCollectionOrArray()__		return this.elementTypeDescriptor__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,code,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,assert,collection,or,array,return,this,element,type,descriptor
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1349907422;If this type is an array, returns the array's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns null indicating the element type is not declared._@return the array component type or Collection element type, or <code>null</code> if this type is a Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a java.util.Collection or Array type;public TypeDescriptor getElementTypeDescriptor() {_		assertCollectionOrArray()__		return this.elementTypeDescriptor__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,code,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,assert,collection,or,array,return,this,element,type,descriptor
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1351584957;If this type is an array, returns the array's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns null indicating the element type is not declared._@return the array component type or Collection element type, or <code>null</code> if this type is a Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a java.util.Collection or Array type;public TypeDescriptor getElementTypeDescriptor() {_		assertCollectionOrArray()__		return this.elementTypeDescriptor__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,code,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,assert,collection,or,array,return,this,element,type,descriptor
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1351648403;If this type is an array, returns the array's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns null indicating the element type is not declared._@return the array component type or Collection element type, or <code>null</code> if this type is a Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a java.util.Collection or Array type;public TypeDescriptor getElementTypeDescriptor() {_		assertCollectionOrArray()__		return this.elementTypeDescriptor__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,code,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,assert,collection,or,array,return,this,element,type,descriptor
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1356735495;If this type is an array, returns the array's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns null indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a java.util.Collection or Array type;public TypeDescriptor getElementTypeDescriptor() {_		assertCollectionOrArray()__		return this.elementTypeDescriptor__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,assert,collection,or,array,return,this,element,type,descriptor
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1362408075;If this type is an array, returns the array's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns null indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a java.util.Collection or Array type;public TypeDescriptor getElementTypeDescriptor() {_		assertCollectionOrArray()__		return this.elementTypeDescriptor__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,assert,collection,or,array,return,this,element,type,descriptor
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1368482696;If this type is an array, returns the array's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns null indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a java.util.Collection or Array type;public TypeDescriptor getElementTypeDescriptor() {_		assertCollectionOrArray()__		return this.elementTypeDescriptor__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,assert,collection,or,array,return,this,element,type,descriptor
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1374614239;If this type is an array, returns the array's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns null indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a java.util.Collection or Array type;public TypeDescriptor getElementTypeDescriptor() {_		assertCollectionOrArray()__		return this.elementTypeDescriptor__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,assert,collection,or,array,return,this,element,type,descriptor
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1382042882;If this type is an array, returns the array's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns null indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a java.util.Collection or Array type;public TypeDescriptor getElementTypeDescriptor() {_		assertCollectionOrArray()__		if (this.resolvableType.isArray()) {_			return getRelatedIfResolvable(this, this.resolvableType.getComponentType())__		}_		return getRelatedIfResolvable(this, this.resolvableType.asCollection().getGeneric())___	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,assert,collection,or,array,if,this,resolvable,type,is,array,return,get,related,if,resolvable,this,this,resolvable,type,get,component,type,return,get,related,if,resolvable,this,this,resolvable,type,as,collection,get,generic
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1382119085;If this type is an array, returns the array's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns null indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a java.util.Collection or Array type;public TypeDescriptor getElementTypeDescriptor() {_		assertCollectionOrArray()__		if (this.resolvableType.isArray()) {_			return getRelatedIfResolvable(this, this.resolvableType.getComponentType())__		}_		return getRelatedIfResolvable(this, this.resolvableType.asCollection().getGeneric())___	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,assert,collection,or,array,if,this,resolvable,type,is,array,return,get,related,if,resolvable,this,this,resolvable,type,get,component,type,return,get,related,if,resolvable,this,this,resolvable,type,as,collection,get,generic
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1382750081;If this type is an array, returns the array's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns null indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a java.util.Collection or Array type;public TypeDescriptor getElementTypeDescriptor() {_		assertCollectionOrArray()__		if (this.resolvableType.isArray()) {_			return getRelatedIfResolvable(this, this.resolvableType.getComponentType())__		}_		return getRelatedIfResolvable(this, this.resolvableType.asCollection().getGeneric())___	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,assert,collection,or,array,if,this,resolvable,type,is,array,return,get,related,if,resolvable,this,this,resolvable,type,get,component,type,return,get,related,if,resolvable,this,this,resolvable,type,as,collection,get,generic
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1387307647;If this type is an array, returns the array's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns null indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a java.util.Collection or Array type;public TypeDescriptor getElementTypeDescriptor() {_		assertCollectionOrArray()__		if (this.resolvableType.isArray()) {_			return getRelatedIfResolvable(this, this.resolvableType.getComponentType())__		}_		return getRelatedIfResolvable(this, this.resolvableType.asCollection().getGeneric())___	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,assert,collection,or,array,if,this,resolvable,type,is,array,return,get,related,if,resolvable,this,this,resolvable,type,get,component,type,return,get,related,if,resolvable,this,this,resolvable,type,as,collection,get,generic
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1387490898;If this type is an array, returns the array's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns null indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a java.util.Collection or Array type;public TypeDescriptor getElementTypeDescriptor() {_		assertCollectionOrArray()__		if (this.resolvableType.isArray()) {_			return getRelatedIfResolvable(this, this.resolvableType.getComponentType())__		}_		return getRelatedIfResolvable(this, this.resolvableType.asCollection().getGeneric())___	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,assert,collection,or,array,if,this,resolvable,type,is,array,return,get,related,if,resolvable,this,this,resolvable,type,get,component,type,return,get,related,if,resolvable,this,this,resolvable,type,as,collection,get,generic
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1389985540;If this type is an array, returns the array's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns null indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a java.util.Collection or Array type;public TypeDescriptor getElementTypeDescriptor() {_		assertCollectionOrArray()__		if (this.resolvableType.isArray()) {_			return getRelatedIfResolvable(this, this.resolvableType.getComponentType())__		}_		return getRelatedIfResolvable(this, this.resolvableType.asCollection().getGeneric())___	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,assert,collection,or,array,if,this,resolvable,type,is,array,return,get,related,if,resolvable,this,this,resolvable,type,get,component,type,return,get,related,if,resolvable,this,this,resolvable,type,as,collection,get,generic
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1390565795;If this type is an array, returns the array's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns null indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a java.util.Collection or Array type;public TypeDescriptor getElementTypeDescriptor() {_		assertCollectionOrArray()__		if (this.resolvableType.isArray()) {_			return getRelatedIfResolvable(this, this.resolvableType.getComponentType())__		}_		return getRelatedIfResolvable(this, this.resolvableType.asCollection().getGeneric())___	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,assert,collection,or,array,if,this,resolvable,type,is,array,return,get,related,if,resolvable,this,this,resolvable,type,get,component,type,return,get,related,if,resolvable,this,this,resolvable,type,as,collection,get,generic
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1390925810;If this type is an array, returns the array's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns null indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a java.util.Collection or Array type;public TypeDescriptor getElementTypeDescriptor() {_		assertCollectionOrArray()__		if (this.resolvableType.isArray()) {_			return getRelatedIfResolvable(this, this.resolvableType.getComponentType())__		}_		return getRelatedIfResolvable(this, this.resolvableType.asCollection().getGeneric())___	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,assert,collection,or,array,if,this,resolvable,type,is,array,return,get,related,if,resolvable,this,this,resolvable,type,get,component,type,return,get,related,if,resolvable,this,this,resolvable,type,as,collection,get,generic
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1391081201;If this type is an array, returns the array's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns null indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a java.util.Collection or Array type;public TypeDescriptor getElementTypeDescriptor() {_		assertCollectionOrArray()__		if (this.resolvableType.isArray()) {_			return getRelatedIfResolvable(this, this.resolvableType.getComponentType())__		}_		return getRelatedIfResolvable(this, this.resolvableType.asCollection().getGeneric())___	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,assert,collection,or,array,if,this,resolvable,type,is,array,return,get,related,if,resolvable,this,this,resolvable,type,get,component,type,return,get,related,if,resolvable,this,this,resolvable,type,as,collection,get,generic
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1391248381;If this type is an array, returns the array's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns null indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a java.util.Collection or Array type;public TypeDescriptor getElementTypeDescriptor() {_		assertCollectionOrArray()__		if (this.resolvableType.isArray()) {_			return getRelatedIfResolvable(this, this.resolvableType.getComponentType())__		}_		return getRelatedIfResolvable(this, this.resolvableType.asCollection().getGeneric())___	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,assert,collection,or,array,if,this,resolvable,type,is,array,return,get,related,if,resolvable,this,this,resolvable,type,get,component,type,return,get,related,if,resolvable,this,this,resolvable,type,as,collection,get,generic
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1394055372;If this type is an array, returns the array's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns {@code null} indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a_Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;public TypeDescriptor getElementTypeDescriptor() {_		if (this.resolvableType.isArray()) {_			return new TypeDescriptor(this.resolvableType.getComponentType(), null, this.annotations)__		}_		Assert.state(isCollection(), "Not an array or java.util.Collection")__		return getRelatedIfResolvable(this, this.resolvableType.asCollection().getGeneric())___	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,code,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,if,this,resolvable,type,is,array,return,new,type,descriptor,this,resolvable,type,get,component,type,null,this,annotations,assert,state,is,collection,not,an,array,or,java,util,collection,return,get,related,if,resolvable,this,this,resolvable,type,as,collection,get,generic
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1395846555;If this type is an array, returns the array's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns {@code null} indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a_Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;public TypeDescriptor getElementTypeDescriptor() {_		if (this.resolvableType.isArray()) {_			return new TypeDescriptor(this.resolvableType.getComponentType(), null, this.annotations)__		}_		return getRelatedIfResolvable(this, this.resolvableType.asCollection().getGeneric())__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,code,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,if,this,resolvable,type,is,array,return,new,type,descriptor,this,resolvable,type,get,component,type,null,this,annotations,return,get,related,if,resolvable,this,this,resolvable,type,as,collection,get,generic
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1403636229;If this type is an array, returns the array's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns {@code null} indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a_Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;public TypeDescriptor getElementTypeDescriptor() {_		if (this.resolvableType.isArray()) {_			return new TypeDescriptor(this.resolvableType.getComponentType(), null, this.annotations)__		}_		return getRelatedIfResolvable(this, this.resolvableType.asCollection().getGeneric())__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,code,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,if,this,resolvable,type,is,array,return,new,type,descriptor,this,resolvable,type,get,component,type,null,this,annotations,return,get,related,if,resolvable,this,this,resolvable,type,as,collection,get,generic
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1405430015;If this type is an array, returns the array's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns {@code null} indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a_Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;public TypeDescriptor getElementTypeDescriptor() {_		if (this.resolvableType.isArray()) {_			return new TypeDescriptor(this.resolvableType.getComponentType(), null, this.annotations)__		}_		return getRelatedIfResolvable(this, this.resolvableType.asCollection().getGeneric())__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,code,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,if,this,resolvable,type,is,array,return,new,type,descriptor,this,resolvable,type,get,component,type,null,this,annotations,return,get,related,if,resolvable,this,this,resolvable,type,as,collection,get,generic
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1406196817;If this type is an array, returns the array's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns {@code null} indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a_Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;public TypeDescriptor getElementTypeDescriptor() {_		if (this.resolvableType.isArray()) {_			return new TypeDescriptor(this.resolvableType.getComponentType(), null, this.annotations)__		}_		return getRelatedIfResolvable(this, this.resolvableType.asCollection().getGeneric())__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,code,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,if,this,resolvable,type,is,array,return,new,type,descriptor,this,resolvable,type,get,component,type,null,this,annotations,return,get,related,if,resolvable,this,this,resolvable,type,as,collection,get,generic
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1412611699;If this type is an array, returns the array's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns {@code null} indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a_Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;public TypeDescriptor getElementTypeDescriptor() {_		if (this.resolvableType.isArray()) {_			return new TypeDescriptor(this.resolvableType.getComponentType(), null, this.annotations)__		}_		return getRelatedIfResolvable(this, this.resolvableType.asCollection().getGeneric())__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,code,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,if,this,resolvable,type,is,array,return,new,type,descriptor,this,resolvable,type,get,component,type,null,this,annotations,return,get,related,if,resolvable,this,this,resolvable,type,as,collection,get,generic
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1414925289;If this type is an array, returns the array's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns {@code null} indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a_Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;public TypeDescriptor getElementTypeDescriptor() {_		if (this.resolvableType.isArray()) {_			return new TypeDescriptor(this.resolvableType.getComponentType(), null, this.annotations)__		}_		return getRelatedIfResolvable(this, this.resolvableType.asCollection().getGeneric())__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,code,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,if,this,resolvable,type,is,array,return,new,type,descriptor,this,resolvable,type,get,component,type,null,this,annotations,return,get,related,if,resolvable,this,this,resolvable,type,as,collection,get,generic
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1417290561;If this type is an array, returns the array's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns {@code null} indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a_Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;public TypeDescriptor getElementTypeDescriptor() {_		if (this.resolvableType.isArray()) {_			return new TypeDescriptor(this.resolvableType.getComponentType(), null, this.annotations)__		}_		return getRelatedIfResolvable(this, this.resolvableType.asCollection().getGeneric())__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,code,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,if,this,resolvable,type,is,array,return,new,type,descriptor,this,resolvable,type,get,component,type,null,this,annotations,return,get,related,if,resolvable,this,this,resolvable,type,as,collection,get,generic
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1419966315;If this type is an array, returns the array's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns {@code null} indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a_Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;public TypeDescriptor getElementTypeDescriptor() {_		if (this.resolvableType.isArray()) {_			return new TypeDescriptor(this.resolvableType.getComponentType(), null, this.annotations)__		}_		return getRelatedIfResolvable(this, this.resolvableType.asCollection().getGeneric())__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,code,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,if,this,resolvable,type,is,array,return,new,type,descriptor,this,resolvable,type,get,component,type,null,this,annotations,return,get,related,if,resolvable,this,this,resolvable,type,as,collection,get,generic
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1424769447;If this type is an array, returns the array's component type._If this type is a {@code Stream}, returns the stream's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns {@code null} indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a_Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;public TypeDescriptor getElementTypeDescriptor() {_		if (this.resolvableType.isArray()) {_			return new TypeDescriptor(this.resolvableType.getComponentType(), null, this.annotations)__		}_		if (streamAvailable && StreamHelper.isStream(this.type)) {_			return StreamHelper.getStreamElementType(this)__		}_		return getRelatedIfResolvable(this, this.resolvableType.asCollection().getGeneric())__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,code,stream,returns,the,stream,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,code,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,if,this,resolvable,type,is,array,return,new,type,descriptor,this,resolvable,type,get,component,type,null,this,annotations,if,stream,available,stream,helper,is,stream,this,type,return,stream,helper,get,stream,element,type,this,return,get,related,if,resolvable,this,this,resolvable,type,as,collection,get,generic
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1424887506;If this type is an array, returns the array's component type._If this type is a {@code Stream}, returns the stream's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns {@code null} indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a_Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;public TypeDescriptor getElementTypeDescriptor() {_		if (this.resolvableType.isArray()) {_			return new TypeDescriptor(this.resolvableType.getComponentType(), null, this.annotations)__		}_		if (streamAvailable && StreamDelegate.isStream(this.type)) {_			return StreamDelegate.getStreamElementType(this)__		}_		return getRelatedIfResolvable(this, this.resolvableType.asCollection().getGeneric())__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,code,stream,returns,the,stream,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,code,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,if,this,resolvable,type,is,array,return,new,type,descriptor,this,resolvable,type,get,component,type,null,this,annotations,if,stream,available,stream,delegate,is,stream,this,type,return,stream,delegate,get,stream,element,type,this,return,get,related,if,resolvable,this,this,resolvable,type,as,collection,get,generic
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1425763631;If this type is an array, returns the array's component type._If this type is a {@code Stream}, returns the stream's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns {@code null} indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a_Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;public TypeDescriptor getElementTypeDescriptor() {_		if (this.resolvableType.isArray()) {_			return new TypeDescriptor(this.resolvableType.getComponentType(), null, this.annotations)__		}_		if (streamAvailable && StreamDelegate.isStream(this.type)) {_			return StreamDelegate.getStreamElementType(this)__		}_		return getRelatedIfResolvable(this, this.resolvableType.asCollection().getGeneric())__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,code,stream,returns,the,stream,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,code,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,if,this,resolvable,type,is,array,return,new,type,descriptor,this,resolvable,type,get,component,type,null,this,annotations,if,stream,available,stream,delegate,is,stream,this,type,return,stream,delegate,get,stream,element,type,this,return,get,related,if,resolvable,this,this,resolvable,type,as,collection,get,generic
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1431093918;If this type is an array, returns the array's component type._If this type is a {@code Stream}, returns the stream's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns {@code null} indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a_Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;public TypeDescriptor getElementTypeDescriptor() {_		if (this.resolvableType.isArray()) {_			return new TypeDescriptor(this.resolvableType.getComponentType(), null, this.annotations)__		}_		if (streamAvailable && StreamDelegate.isStream(this.type)) {_			return StreamDelegate.getStreamElementType(this)__		}_		return getRelatedIfResolvable(this, this.resolvableType.asCollection().getGeneric())__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,code,stream,returns,the,stream,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,code,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,if,this,resolvable,type,is,array,return,new,type,descriptor,this,resolvable,type,get,component,type,null,this,annotations,if,stream,available,stream,delegate,is,stream,this,type,return,stream,delegate,get,stream,element,type,this,return,get,related,if,resolvable,this,this,resolvable,type,as,collection,get,generic
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1432125256;If this type is an array, returns the array's component type._If this type is a {@code Stream}, returns the stream's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns {@code null} indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a_Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;public TypeDescriptor getElementTypeDescriptor() {_		if (this.resolvableType.isArray()) {_			return new TypeDescriptor(this.resolvableType.getComponentType(), null, this.annotations)__		}_		if (streamAvailable && StreamDelegate.isStream(this.type)) {_			return StreamDelegate.getStreamElementType(this)__		}_		return getRelatedIfResolvable(this, this.resolvableType.asCollection().getGeneric())__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,code,stream,returns,the,stream,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,code,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,if,this,resolvable,type,is,array,return,new,type,descriptor,this,resolvable,type,get,component,type,null,this,annotations,if,stream,available,stream,delegate,is,stream,this,type,return,stream,delegate,get,stream,element,type,this,return,get,related,if,resolvable,this,this,resolvable,type,as,collection,get,generic
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1441035153;If this type is an array, returns the array's component type._If this type is a {@code Stream}, returns the stream's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns {@code null} indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a_Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;public TypeDescriptor getElementTypeDescriptor() {_		if (this.resolvableType.isArray()) {_			return new TypeDescriptor(this.resolvableType.getComponentType(), null, this.annotations)__		}_		if (streamAvailable && StreamDelegate.isStream(this.type)) {_			return StreamDelegate.getStreamElementType(this)__		}_		return getRelatedIfResolvable(this, this.resolvableType.asCollection().getGeneric())__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,code,stream,returns,the,stream,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,code,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,if,this,resolvable,type,is,array,return,new,type,descriptor,this,resolvable,type,get,component,type,null,this,annotations,if,stream,available,stream,delegate,is,stream,this,type,return,stream,delegate,get,stream,element,type,this,return,get,related,if,resolvable,this,this,resolvable,type,as,collection,get,generic
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1448383050;If this type is an array, returns the array's component type._If this type is a {@code Stream}, returns the stream's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns {@code null} indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a_Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;public TypeDescriptor getElementTypeDescriptor() {_		if (this.resolvableType.isArray()) {_			return new TypeDescriptor(this.resolvableType.getComponentType(), null, this.annotations)__		}_		if (streamAvailable && StreamDelegate.isStream(this.type)) {_			return StreamDelegate.getStreamElementType(this)__		}_		return getRelatedIfResolvable(this, this.resolvableType.asCollection().getGeneric())__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,code,stream,returns,the,stream,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,code,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,if,this,resolvable,type,is,array,return,new,type,descriptor,this,resolvable,type,get,component,type,null,this,annotations,if,stream,available,stream,delegate,is,stream,this,type,return,stream,delegate,get,stream,element,type,this,return,get,related,if,resolvable,this,this,resolvable,type,as,collection,get,generic
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1450473050;If this type is an array, returns the array's component type._If this type is a {@code Stream}, returns the stream's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns {@code null} indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a_Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;public TypeDescriptor getElementTypeDescriptor() {_		if (this.resolvableType.isArray()) {_			return new TypeDescriptor(this.resolvableType.getComponentType(), null, this.annotations)__		}_		if (streamAvailable && StreamDelegate.isStream(this.type)) {_			return StreamDelegate.getStreamElementType(this)__		}_		return getRelatedIfResolvable(this, this.resolvableType.asCollection().getGeneric())__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,code,stream,returns,the,stream,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,code,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,if,this,resolvable,type,is,array,return,new,type,descriptor,this,resolvable,type,get,component,type,null,this,annotations,if,stream,available,stream,delegate,is,stream,this,type,return,stream,delegate,get,stream,element,type,this,return,get,related,if,resolvable,this,this,resolvable,type,as,collection,get,generic
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1467288171;If this type is an array, returns the array's component type._If this type is a {@code Stream}, returns the stream's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns {@code null} indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a_Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;public TypeDescriptor getElementTypeDescriptor() {_		if (this.resolvableType.isArray()) {_			return new TypeDescriptor(this.resolvableType.getComponentType(), null, this.annotations)__		}_		if (streamAvailable && StreamDelegate.isStream(this.type)) {_			return StreamDelegate.getStreamElementType(this)__		}_		return getRelatedIfResolvable(this, this.resolvableType.asCollection().getGeneric())__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,code,stream,returns,the,stream,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,code,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,if,this,resolvable,type,is,array,return,new,type,descriptor,this,resolvable,type,get,component,type,null,this,annotations,if,stream,available,stream,delegate,is,stream,this,type,return,stream,delegate,get,stream,element,type,this,return,get,related,if,resolvable,this,this,resolvable,type,as,collection,get,generic
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1467677340;If this type is an array, returns the array's component type._If this type is a {@code Stream}, returns the stream's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns {@code null} indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a_Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;public TypeDescriptor getElementTypeDescriptor() {_		if (this.resolvableType.isArray()) {_			return new TypeDescriptor(this.resolvableType.getComponentType(), null, this.annotations)__		}_		if (Stream.class.isAssignableFrom(this.type)) {_			return getRelatedIfResolvable(this, this.resolvableType.as(Stream.class).getGeneric(0))__		}_		return getRelatedIfResolvable(this, this.resolvableType.asCollection().getGeneric(0))__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,code,stream,returns,the,stream,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,code,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,if,this,resolvable,type,is,array,return,new,type,descriptor,this,resolvable,type,get,component,type,null,this,annotations,if,stream,class,is,assignable,from,this,type,return,get,related,if,resolvable,this,this,resolvable,type,as,stream,class,get,generic,0,return,get,related,if,resolvable,this,this,resolvable,type,as,collection,get,generic,0
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1467730834;If this type is an array, returns the array's component type._If this type is a {@code Stream}, returns the stream's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns {@code null} indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a_Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;public TypeDescriptor getElementTypeDescriptor() {_		if (this.resolvableType.isArray()) {_			return new TypeDescriptor(this.resolvableType.getComponentType(), null, this.annotations)__		}_		if (Stream.class.isAssignableFrom(this.type)) {_			return getRelatedIfResolvable(this, this.resolvableType.as(Stream.class).getGeneric(0))__		}_		return getRelatedIfResolvable(this, this.resolvableType.asCollection().getGeneric(0))__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,code,stream,returns,the,stream,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,code,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,if,this,resolvable,type,is,array,return,new,type,descriptor,this,resolvable,type,get,component,type,null,this,annotations,if,stream,class,is,assignable,from,this,type,return,get,related,if,resolvable,this,this,resolvable,type,as,stream,class,get,generic,0,return,get,related,if,resolvable,this,this,resolvable,type,as,collection,get,generic,0
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1477690406;If this type is an array, returns the array's component type._If this type is a {@code Stream}, returns the stream's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns {@code null} indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a_Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;public TypeDescriptor getElementTypeDescriptor() {_		if (getResolvableType().isArray()) {_			return new TypeDescriptor(getResolvableType().getComponentType(), null, getAnnotations())__		}_		if (Stream.class.isAssignableFrom(getType())) {_			return getRelatedIfResolvable(this, getResolvableType().as(Stream.class).getGeneric(0))__		}_		return getRelatedIfResolvable(this, getResolvableType().asCollection().getGeneric(0))__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,code,stream,returns,the,stream,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,code,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,if,get,resolvable,type,is,array,return,new,type,descriptor,get,resolvable,type,get,component,type,null,get,annotations,if,stream,class,is,assignable,from,get,type,return,get,related,if,resolvable,this,get,resolvable,type,as,stream,class,get,generic,0,return,get,related,if,resolvable,this,get,resolvable,type,as,collection,get,generic,0
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1478094883;If this type is an array, returns the array's component type._If this type is a {@code Stream}, returns the stream's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns {@code null} indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a_Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;public TypeDescriptor getElementTypeDescriptor() {_		if (getResolvableType().isArray()) {_			return new TypeDescriptor(getResolvableType().getComponentType(), null, getAnnotations())__		}_		if (Stream.class.isAssignableFrom(getType())) {_			return getRelatedIfResolvable(this, getResolvableType().as(Stream.class).getGeneric(0))__		}_		return getRelatedIfResolvable(this, getResolvableType().asCollection().getGeneric(0))__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,code,stream,returns,the,stream,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,code,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,if,get,resolvable,type,is,array,return,new,type,descriptor,get,resolvable,type,get,component,type,null,get,annotations,if,stream,class,is,assignable,from,get,type,return,get,related,if,resolvable,this,get,resolvable,type,as,stream,class,get,generic,0,return,get,related,if,resolvable,this,get,resolvable,type,as,collection,get,generic,0
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1479823020;If this type is an array, returns the array's component type._If this type is a {@code Stream}, returns the stream's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns {@code null} indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a_Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;public TypeDescriptor getElementTypeDescriptor() {_		if (getResolvableType().isArray()) {_			return new TypeDescriptor(getResolvableType().getComponentType(), null, getAnnotations())__		}_		if (Stream.class.isAssignableFrom(getType())) {_			return getRelatedIfResolvable(this, getResolvableType().as(Stream.class).getGeneric(0))__		}_		return getRelatedIfResolvable(this, getResolvableType().asCollection().getGeneric(0))__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,code,stream,returns,the,stream,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,code,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,if,get,resolvable,type,is,array,return,new,type,descriptor,get,resolvable,type,get,component,type,null,get,annotations,if,stream,class,is,assignable,from,get,type,return,get,related,if,resolvable,this,get,resolvable,type,as,stream,class,get,generic,0,return,get,related,if,resolvable,this,get,resolvable,type,as,collection,get,generic,0
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1479900301;If this type is an array, returns the array's component type._If this type is a {@code Stream}, returns the stream's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns {@code null} indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a_Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;public TypeDescriptor getElementTypeDescriptor() {_		if (getResolvableType().isArray()) {_			return new TypeDescriptor(getResolvableType().getComponentType(), null, getAnnotations())__		}_		if (Stream.class.isAssignableFrom(getType())) {_			return getRelatedIfResolvable(this, getResolvableType().as(Stream.class).getGeneric(0))__		}_		return getRelatedIfResolvable(this, getResolvableType().asCollection().getGeneric(0))__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,code,stream,returns,the,stream,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,code,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,if,get,resolvable,type,is,array,return,new,type,descriptor,get,resolvable,type,get,component,type,null,get,annotations,if,stream,class,is,assignable,from,get,type,return,get,related,if,resolvable,this,get,resolvable,type,as,stream,class,get,generic,0,return,get,related,if,resolvable,this,get,resolvable,type,as,collection,get,generic,0
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1480540964;If this type is an array, returns the array's component type._If this type is a {@code Stream}, returns the stream's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns {@code null} indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a_Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;public TypeDescriptor getElementTypeDescriptor() {_		if (getResolvableType().isArray()) {_			return new TypeDescriptor(getResolvableType().getComponentType(), null, getAnnotations())__		}_		if (Stream.class.isAssignableFrom(getType())) {_			return getRelatedIfResolvable(this, getResolvableType().as(Stream.class).getGeneric(0))__		}_		return getRelatedIfResolvable(this, getResolvableType().asCollection().getGeneric(0))__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,code,stream,returns,the,stream,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,code,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,if,get,resolvable,type,is,array,return,new,type,descriptor,get,resolvable,type,get,component,type,null,get,annotations,if,stream,class,is,assignable,from,get,type,return,get,related,if,resolvable,this,get,resolvable,type,as,stream,class,get,generic,0,return,get,related,if,resolvable,this,get,resolvable,type,as,collection,get,generic,0
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1481578128;If this type is an array, returns the array's component type._If this type is a {@code Stream}, returns the stream's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns {@code null} indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a_Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;public TypeDescriptor getElementTypeDescriptor() {_		if (getResolvableType().isArray()) {_			return new TypeDescriptor(getResolvableType().getComponentType(), null, getAnnotations())__		}_		if (Stream.class.isAssignableFrom(getType())) {_			return getRelatedIfResolvable(this, getResolvableType().as(Stream.class).getGeneric(0))__		}_		return getRelatedIfResolvable(this, getResolvableType().asCollection().getGeneric(0))__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,code,stream,returns,the,stream,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,code,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,if,get,resolvable,type,is,array,return,new,type,descriptor,get,resolvable,type,get,component,type,null,get,annotations,if,stream,class,is,assignable,from,get,type,return,get,related,if,resolvable,this,get,resolvable,type,as,stream,class,get,generic,0,return,get,related,if,resolvable,this,get,resolvable,type,as,collection,get,generic,0
TypeDescriptor -> public TypeDescriptor getElementTypeDescriptor();1482961889;If this type is an array, returns the array's component type._If this type is a {@code Stream}, returns the stream's component type._If this type is a {@link Collection} and it is parameterized, returns the Collection's element type._If the Collection is not parameterized, returns {@code null} indicating the element type is not declared._@return the array component type or Collection element type, or {@code null} if this type is a_Collection but its element type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Collection} or array type;public TypeDescriptor getElementTypeDescriptor() {_		if (getResolvableType().isArray()) {_			return new TypeDescriptor(getResolvableType().getComponentType(), null, getAnnotations())__		}_		if (Stream.class.isAssignableFrom(getType())) {_			return getRelatedIfResolvable(this, getResolvableType().as(Stream.class).getGeneric(0))__		}_		return getRelatedIfResolvable(this, getResolvableType().asCollection().getGeneric(0))__	};if,this,type,is,an,array,returns,the,array,s,component,type,if,this,type,is,a,code,stream,returns,the,stream,s,component,type,if,this,type,is,a,link,collection,and,it,is,parameterized,returns,the,collection,s,element,type,if,the,collection,is,not,parameterized,returns,code,null,indicating,the,element,type,is,not,declared,return,the,array,component,type,or,collection,element,type,or,code,null,if,this,type,is,a,collection,but,its,element,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,collection,or,array,type;public,type,descriptor,get,element,type,descriptor,if,get,resolvable,type,is,array,return,new,type,descriptor,get,resolvable,type,get,component,type,null,get,annotations,if,stream,class,is,assignable,from,get,type,return,get,related,if,resolvable,this,get,resolvable,type,as,stream,class,get,generic,0,return,get,related,if,resolvable,this,get,resolvable,type,as,collection,get,generic,0
TypeDescriptor -> public boolean isCollection();1328020251;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1329142650;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1335774711;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1349907422;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1351584957;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1351648403;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1356735495;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1362408075;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1368482696;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1374614239;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1382042882;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1382119085;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1382750081;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1387307647;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1387490898;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1389985540;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1390565795;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1390925810;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1391081201;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1391248381;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1394055372;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1395846555;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1403636229;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1405430015;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1406196817;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1412611699;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1414925289;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1417290561;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1419966315;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1424769447;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1424887506;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1425763631;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1431093918;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1432125256;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1441035153;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1448383050;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1450473050;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1467288171;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1467677340;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1467730834;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1477690406;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1478094883;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1479823020;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1479900301;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1480540964;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1481578128;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1482961889;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1495868221;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1496259743;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1496837955;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1498780456;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1508084888;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1522332300;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1532520919;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1546963887;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> public boolean isCollection();1547033218;Is this type a {@link Collection} type?;public boolean isCollection() {_		return Collection.class.isAssignableFrom(getType())__	};is,this,type,a,link,collection,type;public,boolean,is,collection,return,collection,class,is,assignable,from,get,type
TypeDescriptor -> @SuppressWarnings("unchecked") 	@Nullable 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1495868221;Obtain the annotation of the specified {@code annotationType} that is on this type descriptor._<p>As of Spring Framework 4.2, this method supports arbitrary levels of meta-annotations._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	@Nullable_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		if (this.annotatedElement.isEmpty()) {_			_			_			return null__		}_		return AnnotatedElementUtils.getMergedAnnotation(this.annotatedElement, annotationType)__	};obtain,the,annotation,of,the,specified,code,annotation,type,that,is,on,this,type,descriptor,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,nullable,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,if,this,annotated,element,is,empty,return,null,return,annotated,element,utils,get,merged,annotation,this,annotated,element,annotation,type
TypeDescriptor -> @SuppressWarnings("unchecked") 	@Nullable 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1496259743;Obtain the annotation of the specified {@code annotationType} that is on this type descriptor._<p>As of Spring Framework 4.2, this method supports arbitrary levels of meta-annotations._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	@Nullable_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		if (this.annotatedElement.isEmpty()) {_			_			_			return null__		}_		return AnnotatedElementUtils.getMergedAnnotation(this.annotatedElement, annotationType)__	};obtain,the,annotation,of,the,specified,code,annotation,type,that,is,on,this,type,descriptor,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,nullable,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,if,this,annotated,element,is,empty,return,null,return,annotated,element,utils,get,merged,annotation,this,annotated,element,annotation,type
TypeDescriptor -> @SuppressWarnings("unchecked") 	@Nullable 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1496837955;Obtain the annotation of the specified {@code annotationType} that is on this type descriptor._<p>As of Spring Framework 4.2, this method supports arbitrary levels of meta-annotations._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	@Nullable_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		if (this.annotatedElement.isEmpty()) {_			_			_			return null__		}_		return AnnotatedElementUtils.getMergedAnnotation(this.annotatedElement, annotationType)__	};obtain,the,annotation,of,the,specified,code,annotation,type,that,is,on,this,type,descriptor,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,nullable,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,if,this,annotated,element,is,empty,return,null,return,annotated,element,utils,get,merged,annotation,this,annotated,element,annotation,type
TypeDescriptor -> @SuppressWarnings("unchecked") 	@Nullable 	public <T extends Annotation> T getAnnotation(Class<T> annotationType);1498780456;Obtain the annotation of the specified {@code annotationType} that is on this type descriptor._<p>As of Spring Framework 4.2, this method supports arbitrary levels of meta-annotations._@param annotationType the annotation type_@return the annotation, or {@code null} if no such annotation exists on this type descriptor;@SuppressWarnings("unchecked")_	@Nullable_	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {_		if (this.annotatedElement.isEmpty()) {_			_			_			return null__		}_		return AnnotatedElementUtils.getMergedAnnotation(this.annotatedElement, annotationType)__	};obtain,the,annotation,of,the,specified,code,annotation,type,that,is,on,this,type,descriptor,p,as,of,spring,framework,4,2,this,method,supports,arbitrary,levels,of,meta,annotations,param,annotation,type,the,annotation,type,return,the,annotation,or,code,null,if,no,such,annotation,exists,on,this,type,descriptor;suppress,warnings,unchecked,nullable,public,t,extends,annotation,t,get,annotation,class,t,annotation,type,if,this,annotated,element,is,empty,return,null,return,annotated,element,utils,get,merged,annotation,this,annotated,element,annotation,type
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1328020251;Create a new type descriptor from the given type._Use this to instruct the conversion system to convert an object to a specific target type, when no type location such as a method parameter or field is available to provide additional conversion context._Generally prefer use of {@link #forObject(Object)} for constructing type descriptors from source objects, as it handles the null object case._@param type the class_@return the type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		TypeDescriptor desc = typeDescriptorCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(type))__	};create,a,new,type,descriptor,from,the,given,type,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,null,object,case,param,type,the,class,return,the,type,descriptor;public,static,type,descriptor,value,of,class,type,type,descriptor,desc,type,descriptor,cache,get,type,return,desc,null,desc,new,type,descriptor,type
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1329142650;Create a new type descriptor from the given type._Use this to instruct the conversion system to convert an object to a specific target type, when no type location such as a method parameter or field is available to provide additional conversion context._Generally prefer use of {@link #forObject(Object)} for constructing type descriptors from source objects, as it handles the null object case._@param type the class_@return the type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		TypeDescriptor desc = typeDescriptorCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(type))__	};create,a,new,type,descriptor,from,the,given,type,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,null,object,case,param,type,the,class,return,the,type,descriptor;public,static,type,descriptor,value,of,class,type,type,descriptor,desc,type,descriptor,cache,get,type,return,desc,null,desc,new,type,descriptor,type
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1335774711;Create a new type descriptor from the given type._Use this to instruct the conversion system to convert an object to a specific target type, when no type location such as a method parameter or field is available to provide additional conversion context._Generally prefer use of {@link #forObject(Object)} for constructing type descriptors from source objects, as it handles the null object case._@param type the class_@return the type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		TypeDescriptor desc = typeDescriptorCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(type))__	};create,a,new,type,descriptor,from,the,given,type,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,null,object,case,param,type,the,class,return,the,type,descriptor;public,static,type,descriptor,value,of,class,type,type,descriptor,desc,type,descriptor,cache,get,type,return,desc,null,desc,new,type,descriptor,type
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1349907422;Create a new type descriptor from the given type._Use this to instruct the conversion system to convert an object to a specific target type, when no type location such as a method parameter or field is available to provide additional conversion context._Generally prefer use of {@link #forObject(Object)} for constructing type descriptors from source objects, as it handles the null object case._@param type the class_@return the type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		TypeDescriptor desc = typeDescriptorCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(type))__	};create,a,new,type,descriptor,from,the,given,type,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,null,object,case,param,type,the,class,return,the,type,descriptor;public,static,type,descriptor,value,of,class,type,type,descriptor,desc,type,descriptor,cache,get,type,return,desc,null,desc,new,type,descriptor,type
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1351584957;Create a new type descriptor from the given type._Use this to instruct the conversion system to convert an object to a specific target type, when no type location such as a method parameter or field is available to provide additional conversion context._Generally prefer use of {@link #forObject(Object)} for constructing type descriptors from source objects, as it handles the null object case._@param type the class_@return the type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		TypeDescriptor desc = typeDescriptorCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(type))__	};create,a,new,type,descriptor,from,the,given,type,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,null,object,case,param,type,the,class,return,the,type,descriptor;public,static,type,descriptor,value,of,class,type,type,descriptor,desc,type,descriptor,cache,get,type,return,desc,null,desc,new,type,descriptor,type
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1351648403;Create a new type descriptor from the given type._Use this to instruct the conversion system to convert an object to a specific target type, when no type location such as a method parameter or field is available to provide additional conversion context._Generally prefer use of {@link #forObject(Object)} for constructing type descriptors from source objects, as it handles the null object case._@param type the class_@return the type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		TypeDescriptor desc = typeDescriptorCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(type))__	};create,a,new,type,descriptor,from,the,given,type,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,null,object,case,param,type,the,class,return,the,type,descriptor;public,static,type,descriptor,value,of,class,type,type,descriptor,desc,type,descriptor,cache,get,type,return,desc,null,desc,new,type,descriptor,type
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1356735495;Create a new type descriptor from the given type._Use this to instruct the conversion system to convert an object to a specific target type, when no type location such as a method parameter or field is available to provide additional conversion context._Generally prefer use of {@link #forObject(Object)} for constructing type descriptors from source objects, as it handles the null object case._@param type the class_@return the type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		TypeDescriptor desc = typeDescriptorCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(type))__	};create,a,new,type,descriptor,from,the,given,type,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,null,object,case,param,type,the,class,return,the,type,descriptor;public,static,type,descriptor,value,of,class,type,type,descriptor,desc,type,descriptor,cache,get,type,return,desc,null,desc,new,type,descriptor,type
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1362408075;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class_@return the type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		TypeDescriptor desc = typeDescriptorCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(type))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,return,the,type,descriptor;public,static,type,descriptor,value,of,class,type,type,descriptor,desc,type,descriptor,cache,get,type,return,desc,null,desc,new,type,descriptor,type
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1368482696;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class_@return the type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		TypeDescriptor desc = typeDescriptorCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(type))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,return,the,type,descriptor;public,static,type,descriptor,value,of,class,type,type,descriptor,desc,type,descriptor,cache,get,type,return,desc,null,desc,new,type,descriptor,type
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1374614239;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class_@return the type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		TypeDescriptor desc = typeDescriptorCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(type))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,return,the,type,descriptor;public,static,type,descriptor,value,of,class,type,type,descriptor,desc,type,descriptor,cache,get,type,return,desc,null,desc,new,type,descriptor,type
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1382042882;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class_@return the type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		Assert.notNull(type, "Type must not be null")__		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,return,the,type,descriptor;public,static,type,descriptor,value,of,class,type,assert,not,null,type,type,must,not,be,null,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1382119085;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class_@return the type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		Assert.notNull(type, "Type must not be null")__		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,return,the,type,descriptor;public,static,type,descriptor,value,of,class,type,assert,not,null,type,type,must,not,be,null,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1382750081;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class_@return the type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		Assert.notNull(type, "Type must not be null")__		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,return,the,type,descriptor;public,static,type,descriptor,value,of,class,type,assert,not,null,type,type,must,not,be,null,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1387307647;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class_@return the type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		Assert.notNull(type, "Type must not be null")__		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,return,the,type,descriptor;public,static,type,descriptor,value,of,class,type,assert,not,null,type,type,must,not,be,null,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1387490898;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class_@return the type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		Assert.notNull(type, "Type must not be null")__		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,return,the,type,descriptor;public,static,type,descriptor,value,of,class,type,assert,not,null,type,type,must,not,be,null,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1389985540;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class_@return the type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		Assert.notNull(type, "Type must not be null")__		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,return,the,type,descriptor;public,static,type,descriptor,value,of,class,type,assert,not,null,type,type,must,not,be,null,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1390565795;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1390925810;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1391081201;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1391248381;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1394055372;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1395846555;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1403636229;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1405430015;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1406196817;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1412611699;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1414925289;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1417290561;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1419966315;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1424769447;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1424887506;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1425763631;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1431093918;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1432125256;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1441035153;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1448383050;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1450473050;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1467288171;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1467677340;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1467730834;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1477690406;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1478094883;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1479823020;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1479900301;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1480540964;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1481578128;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public static TypeDescriptor valueOf(Class<?> type);1482961889;Create a new type descriptor from the given type._<p>Use this to instruct the conversion system to convert an object to a_specific target type, when no type location such as a method parameter or_field is available to provide additional conversion context._<p>Generally prefer use of {@link #forObject(Object)} for constructing type_descriptors from source objects, as it handles the {@code null} object case._@param type the class (may be {@code null} to indicate {@code Object.class})_@return the corresponding type descriptor;public static TypeDescriptor valueOf(Class<?> type) {_		if (type == null) {_			type = Object.class__		}_		TypeDescriptor desc = commonTypesCache.get(type)__		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null))__	};create,a,new,type,descriptor,from,the,given,type,p,use,this,to,instruct,the,conversion,system,to,convert,an,object,to,a,specific,target,type,when,no,type,location,such,as,a,method,parameter,or,field,is,available,to,provide,additional,conversion,context,p,generally,prefer,use,of,link,for,object,object,for,constructing,type,descriptors,from,source,objects,as,it,handles,the,code,null,object,case,param,type,the,class,may,be,code,null,to,indicate,code,object,class,return,the,corresponding,type,descriptor;public,static,type,descriptor,value,of,class,type,if,type,null,type,object,class,type,descriptor,desc,common,types,cache,get,type,return,desc,null,desc,new,type,descriptor,resolvable,type,for,class,type,null,null
TypeDescriptor -> public Object getSource();1382750081;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide.;public Object getSource() {_		return (this.resolvableType == null ? null : this.resolvableType.getSource())__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide;public,object,get,source,return,this,resolvable,type,null,null,this,resolvable,type,get,source
TypeDescriptor -> public Object getSource();1387307647;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide.;public Object getSource() {_		return (this.resolvableType == null ? null : this.resolvableType.getSource())__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide;public,object,get,source,return,this,resolvable,type,null,null,this,resolvable,type,get,source
TypeDescriptor -> public Object getSource();1387490898;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide.;public Object getSource() {_		return (this.resolvableType == null ? null : this.resolvableType.getSource())__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide;public,object,get,source,return,this,resolvable,type,null,null,this,resolvable,type,get,source
TypeDescriptor -> public Object getSource();1389985540;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide.;public Object getSource() {_		return (this.resolvableType == null ? null : this.resolvableType.getSource())__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide;public,object,get,source,return,this,resolvable,type,null,null,this,resolvable,type,get,source
TypeDescriptor -> public Object getSource();1390565795;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide.;public Object getSource() {_		return (this.resolvableType == null ? null : this.resolvableType.getSource())__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide;public,object,get,source,return,this,resolvable,type,null,null,this,resolvable,type,get,source
TypeDescriptor -> public Object getSource();1390925810;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide.;public Object getSource() {_		return (this.resolvableType == null ? null : this.resolvableType.getSource())__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide;public,object,get,source,return,this,resolvable,type,null,null,this,resolvable,type,get,source
TypeDescriptor -> public Object getSource();1391081201;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide.;public Object getSource() {_		return (this.resolvableType == null ? null : this.resolvableType.getSource())__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide;public,object,get,source,return,this,resolvable,type,null,null,this,resolvable,type,get,source
TypeDescriptor -> public Object getSource();1391248381;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide.;public Object getSource() {_		return (this.resolvableType == null ? null : this.resolvableType.getSource())__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide;public,object,get,source,return,this,resolvable,type,null,null,this,resolvable,type,get,source
TypeDescriptor -> public Object getSource();1394055372;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide.;public Object getSource() {_		return (this.resolvableType == null ? null : this.resolvableType.getSource())__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide;public,object,get,source,return,this,resolvable,type,null,null,this,resolvable,type,get,source
TypeDescriptor -> public Object getSource();1395846555;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide.;public Object getSource() {_		return (this.resolvableType == null ? null : this.resolvableType.getSource())__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide;public,object,get,source,return,this,resolvable,type,null,null,this,resolvable,type,get,source
TypeDescriptor -> public Object getSource();1403636229;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide.;public Object getSource() {_		return (this.resolvableType == null ? null : this.resolvableType.getSource())__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide;public,object,get,source,return,this,resolvable,type,null,null,this,resolvable,type,get,source
TypeDescriptor -> public Object getSource();1405430015;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide.;public Object getSource() {_		return (this.resolvableType == null ? null : this.resolvableType.getSource())__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide;public,object,get,source,return,this,resolvable,type,null,null,this,resolvable,type,get,source
TypeDescriptor -> public Object getSource();1406196817;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide._@since 4.0;public Object getSource() {_		return (this.resolvableType != null ? this.resolvableType.getSource() : null)__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide,since,4,0;public,object,get,source,return,this,resolvable,type,null,this,resolvable,type,get,source,null
TypeDescriptor -> public Object getSource();1412611699;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide._@since 4.0;public Object getSource() {_		return (this.resolvableType != null ? this.resolvableType.getSource() : null)__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide,since,4,0;public,object,get,source,return,this,resolvable,type,null,this,resolvable,type,get,source,null
TypeDescriptor -> public Object getSource();1414925289;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide._@since 4.0;public Object getSource() {_		return (this.resolvableType != null ? this.resolvableType.getSource() : null)__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide,since,4,0;public,object,get,source,return,this,resolvable,type,null,this,resolvable,type,get,source,null
TypeDescriptor -> public Object getSource();1417290561;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide._@since 4.0;public Object getSource() {_		return (this.resolvableType != null ? this.resolvableType.getSource() : null)__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide,since,4,0;public,object,get,source,return,this,resolvable,type,null,this,resolvable,type,get,source,null
TypeDescriptor -> public Object getSource();1419966315;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide._@since 4.0;public Object getSource() {_		return (this.resolvableType != null ? this.resolvableType.getSource() : null)__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide,since,4,0;public,object,get,source,return,this,resolvable,type,null,this,resolvable,type,get,source,null
TypeDescriptor -> public Object getSource();1424769447;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide._@since 4.0;public Object getSource() {_		return (this.resolvableType != null ? this.resolvableType.getSource() : null)__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide,since,4,0;public,object,get,source,return,this,resolvable,type,null,this,resolvable,type,get,source,null
TypeDescriptor -> public Object getSource();1424887506;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide._@since 4.0;public Object getSource() {_		return (this.resolvableType != null ? this.resolvableType.getSource() : null)__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide,since,4,0;public,object,get,source,return,this,resolvable,type,null,this,resolvable,type,get,source,null
TypeDescriptor -> public Object getSource();1425763631;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide._@since 4.0;public Object getSource() {_		return (this.resolvableType != null ? this.resolvableType.getSource() : null)__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide,since,4,0;public,object,get,source,return,this,resolvable,type,null,this,resolvable,type,get,source,null
TypeDescriptor -> public Object getSource();1431093918;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide._@since 4.0;public Object getSource() {_		return (this.resolvableType != null ? this.resolvableType.getSource() : null)__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide,since,4,0;public,object,get,source,return,this,resolvable,type,null,this,resolvable,type,get,source,null
TypeDescriptor -> public Object getSource();1432125256;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide._@since 4.0;public Object getSource() {_		return (this.resolvableType != null ? this.resolvableType.getSource() : null)__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide,since,4,0;public,object,get,source,return,this,resolvable,type,null,this,resolvable,type,get,source,null
TypeDescriptor -> public Object getSource();1441035153;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide._@since 4.0;public Object getSource() {_		return (this.resolvableType != null ? this.resolvableType.getSource() : null)__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide,since,4,0;public,object,get,source,return,this,resolvable,type,null,this,resolvable,type,get,source,null
TypeDescriptor -> public Object getSource();1448383050;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide._@since 4.0;public Object getSource() {_		return (this.resolvableType != null ? this.resolvableType.getSource() : null)__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide,since,4,0;public,object,get,source,return,this,resolvable,type,null,this,resolvable,type,get,source,null
TypeDescriptor -> public Object getSource();1450473050;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide._@since 4.0;public Object getSource() {_		return (this.resolvableType != null ? this.resolvableType.getSource() : null)__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide,since,4,0;public,object,get,source,return,this,resolvable,type,null,this,resolvable,type,get,source,null
TypeDescriptor -> public Object getSource();1467288171;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide._@since 4.0;public Object getSource() {_		return (this.resolvableType != null ? this.resolvableType.getSource() : null)__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide,since,4,0;public,object,get,source,return,this,resolvable,type,null,this,resolvable,type,get,source,null
TypeDescriptor -> public Object getSource();1467677340;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide._@since 4.0;public Object getSource() {_		return (this.resolvableType != null ? this.resolvableType.getSource() : null)__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide,since,4,0;public,object,get,source,return,this,resolvable,type,null,this,resolvable,type,get,source,null
TypeDescriptor -> public Object getSource();1467730834;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide._@since 4.0;public Object getSource() {_		return (this.resolvableType != null ? this.resolvableType.getSource() : null)__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide,since,4,0;public,object,get,source,return,this,resolvable,type,null,this,resolvable,type,get,source,null
TypeDescriptor -> public Object getSource();1477690406;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide._@since 4.0;public Object getSource() {_		return (this.resolvableType != null ? this.resolvableType.getSource() : null)__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide,since,4,0;public,object,get,source,return,this,resolvable,type,null,this,resolvable,type,get,source,null
TypeDescriptor -> public Object getSource();1478094883;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide._@since 4.0;public Object getSource() {_		return (this.resolvableType != null ? this.resolvableType.getSource() : null)__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide,since,4,0;public,object,get,source,return,this,resolvable,type,null,this,resolvable,type,get,source,null
TypeDescriptor -> public Object getSource();1479823020;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide._@since 4.0;public Object getSource() {_		return (this.resolvableType != null ? this.resolvableType.getSource() : null)__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide,since,4,0;public,object,get,source,return,this,resolvable,type,null,this,resolvable,type,get,source,null
TypeDescriptor -> public Object getSource();1479900301;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide._@since 4.0;public Object getSource() {_		return (this.resolvableType != null ? this.resolvableType.getSource() : null)__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide,since,4,0;public,object,get,source,return,this,resolvable,type,null,this,resolvable,type,get,source,null
TypeDescriptor -> public Object getSource();1480540964;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide._@since 4.0;public Object getSource() {_		return (this.resolvableType != null ? this.resolvableType.getSource() : null)__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide,since,4,0;public,object,get,source,return,this,resolvable,type,null,this,resolvable,type,get,source,null
TypeDescriptor -> public Object getSource();1481578128;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide._@since 4.0;public Object getSource() {_		return (this.resolvableType != null ? this.resolvableType.getSource() : null)__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide,since,4,0;public,object,get,source,return,this,resolvable,type,null,this,resolvable,type,get,source,null
TypeDescriptor -> public Object getSource();1482961889;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide._@since 4.0;public Object getSource() {_		return (this.resolvableType != null ? this.resolvableType.getSource() : null)__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide,since,4,0;public,object,get,source,return,this,resolvable,type,null,this,resolvable,type,get,source,null
TypeDescriptor -> public Object getSource();1495868221;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide._@since 4.0;public Object getSource() {_		return (this.resolvableType != null ? this.resolvableType.getSource() : null)__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide,since,4,0;public,object,get,source,return,this,resolvable,type,null,this,resolvable,type,get,source,null
TypeDescriptor -> public Object getSource();1496259743;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide._@since 4.0;public Object getSource() {_		return (this.resolvableType != null ? this.resolvableType.getSource() : null)__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide,since,4,0;public,object,get,source,return,this,resolvable,type,null,this,resolvable,type,get,source,null
TypeDescriptor -> public Object getSource();1496837955;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide._@since 4.0;public Object getSource() {_		return this.resolvableType.getSource()__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide,since,4,0;public,object,get,source,return,this,resolvable,type,get,source
TypeDescriptor -> public Object getSource();1498780456;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide._@since 4.0;public Object getSource() {_		return this.resolvableType.getSource()__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide,since,4,0;public,object,get,source,return,this,resolvable,type,get,source
TypeDescriptor -> public Object getSource();1508084888;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide._@since 4.0;public Object getSource() {_		return this.resolvableType.getSource()__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide,since,4,0;public,object,get,source,return,this,resolvable,type,get,source
TypeDescriptor -> public Object getSource();1522332300;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide._@since 4.0;public Object getSource() {_		return this.resolvableType.getSource()__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide,since,4,0;public,object,get,source,return,this,resolvable,type,get,source
TypeDescriptor -> public Object getSource();1532520919;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide._@since 4.0;public Object getSource() {_		return this.resolvableType.getSource()__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide,since,4,0;public,object,get,source,return,this,resolvable,type,get,source
TypeDescriptor -> public Object getSource();1546963887;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide._@since 4.0;public Object getSource() {_		return this.resolvableType.getSource()__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide,since,4,0;public,object,get,source,return,this,resolvable,type,get,source
TypeDescriptor -> public Object getSource();1547033218;Return the underlying source of the descriptor. Will return a {@link Field},_{@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}_was constructed. This method is primarily to provide access to additional_type information or meta-data that alternative JVM languages may provide._@since 4.0;public Object getSource() {_		return this.resolvableType.getSource()__	};return,the,underlying,source,of,the,descriptor,will,return,a,link,field,link,method,parameter,or,link,type,depending,on,how,the,link,type,descriptor,was,constructed,this,method,is,primarily,to,provide,access,to,additional,type,information,or,meta,data,that,alternative,jvm,languages,may,provide,since,4,0;public,object,get,source,return,this,resolvable,type,get,source
TypeDescriptor -> @Nullable 	public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1496837955;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}_from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property_to the class of the provided map key. For example, if this describes a_{@code java.util.Map&lt_java.lang.Number, java.lang.String&lt_} and the key_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the key argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);@Nullable_	public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;nullable,public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> @Nullable 	public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1498780456;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}_from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property_to the class of the provided map key. For example, if this describes a_{@code java.util.Map&lt_java.lang.Number, java.lang.String&lt_} and the key_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the key argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);@Nullable_	public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;nullable,public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> @Nullable 	public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1508084888;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}_from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property_to the class of the provided map key. For example, if this describes a_{@code java.util.Map&lt_java.lang.Number, java.lang.String&lt_} and the key_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the key argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);@Nullable_	public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;nullable,public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> @Nullable 	public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1522332300;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}_from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property_to the class of the provided map key. For example, if this describes a_{@code java.util.Map&lt_java.lang.Number, java.lang.String&lt_} and the key_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the key argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);@Nullable_	public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;nullable,public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> @Nullable 	public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1532520919;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}_from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property_to the class of the provided map key. For example, if this describes a_{@code java.util.Map&lt_java.lang.Number, java.lang.String&lt_} and the key_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the key argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);@Nullable_	public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;nullable,public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> @Nullable 	public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1546963887;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}_from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property_to the class of the provided map key. For example, if this describes a_{@code java.util.Map&lt_java.lang.Number, java.lang.String&lt_} and the key_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the key argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);@Nullable_	public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;nullable,public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> @Nullable 	public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey);1547033218;If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}_from the provided map key._<p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property_to the class of the provided map key. For example, if this describes a_{@code java.util.Map&lt_java.lang.Number, java.lang.String&lt_} and the key_argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be_{@code java.lang.Integer}. If this describes a {@code java.util.Map&lt_?, ?&gt_}_and the key argument is a {@code java.lang.Integer}, the returned_TypeDescriptor will be {@code java.lang.Integer} as well._<p>Annotation and nested type context will be preserved in the narrowed_TypeDescriptor that is returned._@param mapKey the map key_@return the map key type descriptor_@throws IllegalStateException if this type is not a {@code java.util.Map}_@see #narrow(Object);@Nullable_	public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {_		return narrow(mapKey, getMapKeyTypeDescriptor())__	};if,this,type,is,a,link,map,creates,a,map,key,link,type,descriptor,from,the,provided,map,key,p,narrows,the,link,get,map,key,type,descriptor,map,key,type,property,to,the,class,of,the,provided,map,key,for,example,if,this,describes,a,code,java,util,map,lt,java,lang,number,java,lang,string,lt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,if,this,describes,a,code,java,util,map,lt,gt,and,the,key,argument,is,a,code,java,lang,integer,the,returned,type,descriptor,will,be,code,java,lang,integer,as,well,p,annotation,and,nested,type,context,will,be,preserved,in,the,narrowed,type,descriptor,that,is,returned,param,map,key,the,map,key,return,the,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map,see,narrow,object;nullable,public,type,descriptor,get,map,key,type,descriptor,object,map,key,return,narrow,map,key,get,map,key,type,descriptor
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1328020251;Creates a type descriptor for a nested type declared within the method parameter._For example, if the methodParameter is a List&lt_String&gt_ and the nestingLevel is 1, the nested type descriptor will be String.class._If the methodParameter is a List<List<String>> and the nestingLevel is 2, the nested type descriptor will also be a String.class._If the methodParameter is a Map<Integer, String> and the nesting level is 1, the nested type descriptor will be String, derived from the map value._If the methodParameter is a List<Map<Integer, String>> and the nesting level is 2, the nested type descriptor will be String, derived from the map value._Returns null if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a List&lt_?&gt_, the nested type descriptor returned will be null._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or map key/value declaration within the method parameter._@return the nested type descriptor at the specified nesting level, or null if it could not be obtained._@throws IllegalArgumentException if the nesting level of the input {@link MethodParameter} argument is not 1._@throws IllegalArgumentException if the types up to the specified nesting level are not of collection, array, or map types.;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("methodParameter nesting level must be 1: use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new ParameterDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,for,example,if,the,method,parameter,is,a,list,lt,string,gt,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,if,the,method,parameter,is,a,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,if,the,method,parameter,is,a,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,if,the,method,parameter,is,a,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,returns,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,list,lt,gt,the,nested,type,descriptor,returned,will,be,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,parameter,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1329142650;Creates a type descriptor for a nested type declared within the method parameter._For example, if the methodParameter is a List&lt_String&gt_ and the nestingLevel is 1, the nested type descriptor will be String.class._If the methodParameter is a List<List<String>> and the nestingLevel is 2, the nested type descriptor will also be a String.class._If the methodParameter is a Map<Integer, String> and the nesting level is 1, the nested type descriptor will be String, derived from the map value._If the methodParameter is a List<Map<Integer, String>> and the nesting level is 2, the nested type descriptor will be String, derived from the map value._Returns null if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a List&lt_?&gt_, the nested type descriptor returned will be null._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or map key/value declaration within the method parameter._@return the nested type descriptor at the specified nesting level, or null if it could not be obtained._@throws IllegalArgumentException if the nesting level of the input {@link MethodParameter} argument is not 1._@throws IllegalArgumentException if the types up to the specified nesting level are not of collection, array, or map types.;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("methodParameter nesting level must be 1: use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new ParameterDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,for,example,if,the,method,parameter,is,a,list,lt,string,gt,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,if,the,method,parameter,is,a,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,if,the,method,parameter,is,a,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,if,the,method,parameter,is,a,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,returns,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,list,lt,gt,the,nested,type,descriptor,returned,will,be,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,parameter,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1335774711;Creates a type descriptor for a nested type declared within the method parameter._For example, if the methodParameter is a List&lt_String&gt_ and the nestingLevel is 1, the nested type descriptor will be String.class._If the methodParameter is a List<List<String>> and the nestingLevel is 2, the nested type descriptor will also be a String.class._If the methodParameter is a Map<Integer, String> and the nesting level is 1, the nested type descriptor will be String, derived from the map value._If the methodParameter is a List<Map<Integer, String>> and the nesting level is 2, the nested type descriptor will be String, derived from the map value._Returns null if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a List&lt_?&gt_, the nested type descriptor returned will be null._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or map key/value declaration within the method parameter._@return the nested type descriptor at the specified nesting level, or null if it could not be obtained._@throws IllegalArgumentException if the nesting level of the input {@link MethodParameter} argument is not 1._@throws IllegalArgumentException if the types up to the specified nesting level are not of collection, array, or map types.;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("methodParameter nesting level must be 1: use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new ParameterDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,for,example,if,the,method,parameter,is,a,list,lt,string,gt,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,if,the,method,parameter,is,a,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,if,the,method,parameter,is,a,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,if,the,method,parameter,is,a,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,returns,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,list,lt,gt,the,nested,type,descriptor,returned,will,be,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,parameter,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1349907422;Creates a type descriptor for a nested type declared within the method parameter._For example, if the methodParameter is a List&lt_String&gt_ and the nestingLevel is 1, the nested type descriptor will be String.class._If the methodParameter is a List<List<String>> and the nestingLevel is 2, the nested type descriptor will also be a String.class._If the methodParameter is a Map<Integer, String> and the nesting level is 1, the nested type descriptor will be String, derived from the map value._If the methodParameter is a List<Map<Integer, String>> and the nesting level is 2, the nested type descriptor will be String, derived from the map value._Returns null if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a List&lt_?&gt_, the nested type descriptor returned will be <tt>null</tt>._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level, or null if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input {@link MethodParameter} argument is not 1_@throws IllegalArgumentException if the types up to the specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("methodParameter nesting level must be 1: use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new ParameterDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,for,example,if,the,method,parameter,is,a,list,lt,string,gt,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,if,the,method,parameter,is,a,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,if,the,method,parameter,is,a,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,if,the,method,parameter,is,a,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,returns,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,list,lt,gt,the,nested,type,descriptor,returned,will,be,tt,null,tt,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,parameter,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1351584957;Creates a type descriptor for a nested type declared within the method parameter._For example, if the methodParameter is a List&lt_String&gt_ and the nestingLevel is 1, the nested type descriptor will be String.class._If the methodParameter is a List<List<String>> and the nestingLevel is 2, the nested type descriptor will also be a String.class._If the methodParameter is a Map<Integer, String> and the nesting level is 1, the nested type descriptor will be String, derived from the map value._If the methodParameter is a List<Map<Integer, String>> and the nesting level is 2, the nested type descriptor will be String, derived from the map value._Returns null if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a List&lt_?&gt_, the nested type descriptor returned will be <tt>null</tt>._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level, or null if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input {@link MethodParameter} argument is not 1_@throws IllegalArgumentException if the types up to the specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("methodParameter nesting level must be 1: use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new ParameterDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,for,example,if,the,method,parameter,is,a,list,lt,string,gt,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,if,the,method,parameter,is,a,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,if,the,method,parameter,is,a,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,if,the,method,parameter,is,a,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,returns,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,list,lt,gt,the,nested,type,descriptor,returned,will,be,tt,null,tt,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,parameter,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1351648403;Creates a type descriptor for a nested type declared within the method parameter._For example, if the methodParameter is a List&lt_String&gt_ and the nestingLevel is 1, the nested type descriptor will be String.class._If the methodParameter is a List<List<String>> and the nestingLevel is 2, the nested type descriptor will also be a String.class._If the methodParameter is a Map<Integer, String> and the nesting level is 1, the nested type descriptor will be String, derived from the map value._If the methodParameter is a List<Map<Integer, String>> and the nesting level is 2, the nested type descriptor will be String, derived from the map value._Returns null if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a List&lt_?&gt_, the nested type descriptor returned will be <tt>null</tt>._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level, or null if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input {@link MethodParameter} argument is not 1_@throws IllegalArgumentException if the types up to the specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("methodParameter nesting level must be 1: use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new ParameterDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,for,example,if,the,method,parameter,is,a,list,lt,string,gt,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,if,the,method,parameter,is,a,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,if,the,method,parameter,is,a,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,if,the,method,parameter,is,a,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,returns,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,list,lt,gt,the,nested,type,descriptor,returned,will,be,tt,null,tt,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,parameter,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1356735495;Creates a type descriptor for a nested type declared within the method parameter._For example, if the methodParameter is a List&lt_String&gt_ and the nestingLevel is 1, the nested type descriptor will be String.class._If the methodParameter is a List<List<String>> and the nestingLevel is 2, the nested type descriptor will also be a String.class._If the methodParameter is a Map<Integer, String> and the nesting level is 1, the nested type descriptor will be String, derived from the map value._If the methodParameter is a List<Map<Integer, String>> and the nesting level is 2, the nested type descriptor will be String, derived from the map value._Returns null if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a List&lt_?&gt_, the nested type descriptor returned will be <tt>null</tt>._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level, or null if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input {@link MethodParameter} argument is not 1_@throws IllegalArgumentException if the types up to the specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("methodParameter nesting level must be 1: use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new ParameterDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,for,example,if,the,method,parameter,is,a,list,lt,string,gt,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,if,the,method,parameter,is,a,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,if,the,method,parameter,is,a,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,if,the,method,parameter,is,a,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,returns,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,list,lt,gt,the,nested,type,descriptor,returned,will,be,tt,null,tt,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,parameter,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1362408075;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level, or null_if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("methodParameter nesting level must be 1: use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new ParameterDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,parameter,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1368482696;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level, or null_if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("methodParameter nesting level must be 1: use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new ParameterDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,parameter,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1374614239;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level, or null_if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("methodParameter nesting level must be 1: use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new ParameterDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,parameter,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1382042882;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level, or null_if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("methodParameter nesting level must be 1: use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1382119085;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level, or null_if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("methodParameter nesting level must be 1: use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1382750081;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level, or null_if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("methodParameter nesting level must be 1: use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1387307647;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level, or null_if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1_@throws IllegalArgumentException if the types up to the specified nesting_level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("methodParameter nesting level must be 1: use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,throws,illegal,argument,exception,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1387490898;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level, or null_if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("methodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1389985540;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level, or null_if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("methodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1390565795;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level, or null_if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("methodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1390925810;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level, or null_if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("methodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1391081201;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level, or null_if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("methodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1391248381;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level, or null_if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("methodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1394055372;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1395846555;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1403636229;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1405430015;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1406196817;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1412611699;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1414925289;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1417290561;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1419966315;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1424769447;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1424887506;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1425763631;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1431093918;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1432125256;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1441035153;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1448383050;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1450473050;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1467288171;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1467677340;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1467730834;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1477690406;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1478094883;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1479823020;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1479900301;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1480540964;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1481578128;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel);1482961889;Creates a type descriptor for a nested type declared within the method parameter._<p>For example, if the methodParameter is a {@code List<String>} and the_nesting level is 1, the nested type descriptor will be String.class._<p>If the methodParameter is a {@code List<List<String>>} and the nesting_level is 2, the nested type descriptor will also be a String.class._<p>If the methodParameter is a {@code Map<Integer, String>} and the nesting_level is 1, the nested type descriptor will be String, derived from the map value._<p>If the methodParameter is a {@code List<Map<Integer, String>>} and the_nesting level is 2, the nested type descriptor will be String, derived from the map value._<p>Returns {@code null} if a nested type cannot be obtained because it was not declared._For example, if the method parameter is a {@code List<?>}, the nested type_descriptor returned will be {@code null}._@param methodParameter the method parameter with a nestingLevel of 1_@param nestingLevel the nesting level of the collection/array element or_map key/value declaration within the method parameter_@return the nested type descriptor at the specified nesting level,_or {@code null} if it could not be obtained_@throws IllegalArgumentException if the nesting level of the input_{@link MethodParameter} argument is not 1, or if the types up to the_specified nesting level are not of collection, array, or map types;public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {_		if (methodParameter.getNestingLevel() != 1) {_			throw new IllegalArgumentException("MethodParameter nesting level must be 1: " +_					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal")__		}_		return nested(new TypeDescriptor(methodParameter), nestingLevel)__	};creates,a,type,descriptor,for,a,nested,type,declared,within,the,method,parameter,p,for,example,if,the,method,parameter,is,a,code,list,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,class,p,if,the,method,parameter,is,a,code,list,list,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,also,be,a,string,class,p,if,the,method,parameter,is,a,code,map,integer,string,and,the,nesting,level,is,1,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,if,the,method,parameter,is,a,code,list,map,integer,string,and,the,nesting,level,is,2,the,nested,type,descriptor,will,be,string,derived,from,the,map,value,p,returns,code,null,if,a,nested,type,cannot,be,obtained,because,it,was,not,declared,for,example,if,the,method,parameter,is,a,code,list,the,nested,type,descriptor,returned,will,be,code,null,param,method,parameter,the,method,parameter,with,a,nesting,level,of,1,param,nesting,level,the,nesting,level,of,the,collection,array,element,or,map,key,value,declaration,within,the,method,parameter,return,the,nested,type,descriptor,at,the,specified,nesting,level,or,code,null,if,it,could,not,be,obtained,throws,illegal,argument,exception,if,the,nesting,level,of,the,input,link,method,parameter,argument,is,not,1,or,if,the,types,up,to,the,specified,nesting,level,are,not,of,collection,array,or,map,types;public,static,type,descriptor,nested,method,parameter,method,parameter,int,nesting,level,if,method,parameter,get,nesting,level,1,throw,new,illegal,argument,exception,method,parameter,nesting,level,must,be,1,use,the,nesting,level,parameter,to,specify,the,desired,nesting,level,for,nested,type,traversal,return,nested,new,type,descriptor,method,parameter,nesting,level
TypeDescriptor -> public Annotation getAnnotation(Class<? extends Annotation> annotationType);1328020251;Obtain the annotation associated with this type descriptor of the specified type._@return the annotation, or null if no such annotation exists on this type descriptor.;public Annotation getAnnotation(Class<? extends Annotation> annotationType) {_		for (Annotation annotation : getAnnotations()) {_			if (annotation.annotationType().equals(annotationType)) {_				return annotation__			}_		}_		return null__	};obtain,the,annotation,associated,with,this,type,descriptor,of,the,specified,type,return,the,annotation,or,null,if,no,such,annotation,exists,on,this,type,descriptor;public,annotation,get,annotation,class,extends,annotation,annotation,type,for,annotation,annotation,get,annotations,if,annotation,annotation,type,equals,annotation,type,return,annotation,return,null
TypeDescriptor -> public Annotation getAnnotation(Class<? extends Annotation> annotationType);1329142650;Obtain the annotation associated with this type descriptor of the specified type._@return the annotation, or null if no such annotation exists on this type descriptor.;public Annotation getAnnotation(Class<? extends Annotation> annotationType) {_		for (Annotation annotation : getAnnotations()) {_			if (annotation.annotationType().equals(annotationType)) {_				return annotation__			}_		}_		return null__	};obtain,the,annotation,associated,with,this,type,descriptor,of,the,specified,type,return,the,annotation,or,null,if,no,such,annotation,exists,on,this,type,descriptor;public,annotation,get,annotation,class,extends,annotation,annotation,type,for,annotation,annotation,get,annotations,if,annotation,annotation,type,equals,annotation,type,return,annotation,return,null
TypeDescriptor -> public Annotation getAnnotation(Class<? extends Annotation> annotationType);1335774711;Obtain the annotation associated with this type descriptor of the specified type._@return the annotation, or null if no such annotation exists on this type descriptor.;public Annotation getAnnotation(Class<? extends Annotation> annotationType) {_		for (Annotation annotation : getAnnotations()) {_			if (annotation.annotationType().equals(annotationType)) {_				return annotation__			}_		}_		return null__	};obtain,the,annotation,associated,with,this,type,descriptor,of,the,specified,type,return,the,annotation,or,null,if,no,such,annotation,exists,on,this,type,descriptor;public,annotation,get,annotation,class,extends,annotation,annotation,type,for,annotation,annotation,get,annotations,if,annotation,annotation,type,equals,annotation,type,return,annotation,return,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, @Nullable TypeDescriptor elementTypeDescriptor);1496837955;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, @Nullable TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "Collection type must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("Collection type must be a [java.util.Collection]")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,nullable,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, @Nullable TypeDescriptor elementTypeDescriptor);1498780456;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, @Nullable TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "Collection type must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("Collection type must be a [java.util.Collection]")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,nullable,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, @Nullable TypeDescriptor elementTypeDescriptor);1508084888;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, @Nullable TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "Collection type must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("Collection type must be a [java.util.Collection]")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,nullable,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, @Nullable TypeDescriptor elementTypeDescriptor);1522332300;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, @Nullable TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "Collection type must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("Collection type must be a [java.util.Collection]")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,nullable,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, @Nullable TypeDescriptor elementTypeDescriptor);1532520919;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, @Nullable TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "Collection type must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("Collection type must be a [java.util.Collection]")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,nullable,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, @Nullable TypeDescriptor elementTypeDescriptor);1546963887;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, @Nullable TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "Collection type must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("Collection type must be a [java.util.Collection]")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,nullable,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public static TypeDescriptor collection(Class<?> collectionType, @Nullable TypeDescriptor elementTypeDescriptor);1547033218;Create a new type descriptor from a {@link java.util.Collection} type._<p>Useful for converting to typed Collections._<p>For example, a {@code List<String>} could be converted to a_{@code List<EmailAddress>} by converting to a targetType built with this method._The method call to construct such a {@code TypeDescriptor} would look something_like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class))_}_@param collectionType the collection type, which must implement {@link Collection}._@param elementTypeDescriptor a descriptor for the collection's element type,_used to convert collection elements_@return the collection type descriptor;public static TypeDescriptor collection(Class<?> collectionType, @Nullable TypeDescriptor elementTypeDescriptor) {_		Assert.notNull(collectionType, "Collection type must not be null")__		if (!Collection.class.isAssignableFrom(collectionType)) {_			throw new IllegalArgumentException("Collection type must be a [java.util.Collection]")__		}_		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,collection,type,p,useful,for,converting,to,typed,collections,p,for,example,a,code,list,string,could,be,converted,to,a,code,list,email,address,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,code,type,descriptor,would,look,something,like,code,collection,list,class,type,descriptor,value,of,email,address,class,param,collection,type,the,collection,type,which,must,implement,link,collection,param,element,type,descriptor,a,descriptor,for,the,collection,s,element,type,used,to,convert,collection,elements,return,the,collection,type,descriptor;public,static,type,descriptor,collection,class,collection,type,nullable,type,descriptor,element,type,descriptor,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,collection,type,must,be,a,java,util,collection,resolvable,type,element,element,type,descriptor,null,element,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,collection,type,element,null,null
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1351584957;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context.__@param superType the super type to cast to (can be {@code null}_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(superType, this.elementTypeDescriptor,_				this.mapKeyTypeDescriptor, this.mapValueTypeDescriptor, this.annotations)__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,super,type,this,element,type,descriptor,this,map,key,type,descriptor,this,map,value,type,descriptor,this,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1351648403;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context.__@param superType the super type to cast to (can be {@code null}_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(superType, this.elementTypeDescriptor,_				this.mapKeyTypeDescriptor, this.mapValueTypeDescriptor, this.annotations)__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,super,type,this,element,type,descriptor,this,map,key,type,descriptor,this,map,value,type,descriptor,this,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1356735495;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context.__@param superType the super type to cast to (can be {@code null}_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(superType, this.elementTypeDescriptor,_				this.mapKeyTypeDescriptor, this.mapValueTypeDescriptor, this.annotations)__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,super,type,this,element,type,descriptor,this,map,key,type,descriptor,this,map,value,type,descriptor,this,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1362408075;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null}_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(superType, this.elementTypeDescriptor,_				this.mapKeyTypeDescriptor, this.mapValueTypeDescriptor, this.annotations)__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,super,type,this,element,type,descriptor,this,map,key,type,descriptor,this,map,value,type,descriptor,this,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1368482696;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null}_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(superType, this.elementTypeDescriptor,_				this.mapKeyTypeDescriptor, this.mapValueTypeDescriptor, this.annotations)__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,super,type,this,element,type,descriptor,this,map,key,type,descriptor,this,map,value,type,descriptor,this,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1374614239;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null}_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(superType, this.elementTypeDescriptor,_				this.mapKeyTypeDescriptor, this.mapValueTypeDescriptor, this.annotations)__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,super,type,this,element,type,descriptor,this,map,key,type,descriptor,this,map,value,type,descriptor,this,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1382042882;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null}_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(this.resolvableType.as(superType), superType, this.annotations)__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,this,resolvable,type,as,super,type,super,type,this,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1382119085;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null}_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(this.resolvableType.as(superType), superType, this.annotations)__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,this,resolvable,type,as,super,type,super,type,this,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1382750081;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null}_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(this.resolvableType.as(superType), superType, this.annotations)__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,this,resolvable,type,as,super,type,super,type,this,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1387307647;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null}_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(this.resolvableType.as(superType), superType, this.annotations)__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,this,resolvable,type,as,super,type,super,type,this,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1387490898;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null}_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(this.resolvableType.as(superType), superType, this.annotations)__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,this,resolvable,type,as,super,type,super,type,this,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1389985540;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null}_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(this.resolvableType.as(superType), superType, this.annotations)__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,this,resolvable,type,as,super,type,super,type,this,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1390565795;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null}_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(this.resolvableType.as(superType), superType, this.annotations)__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,this,resolvable,type,as,super,type,super,type,this,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1390925810;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null}_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(this.resolvableType.as(superType), superType, this.annotations)__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,this,resolvable,type,as,super,type,super,type,this,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1391081201;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null}_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(this.resolvableType.as(superType), superType, this.annotations)__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,this,resolvable,type,as,super,type,super,type,this,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1391248381;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null}_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(this.resolvableType.as(superType), superType, this.annotations)__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,this,resolvable,type,as,super,type,super,type,this,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1394055372;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null}_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(this.resolvableType.as(superType), superType, this.annotations)__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,this,resolvable,type,as,super,type,super,type,this,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1395846555;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null}_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(this.resolvableType.as(superType), superType, this.annotations)__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,this,resolvable,type,as,super,type,super,type,this,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1403636229;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null}_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(this.resolvableType.as(superType), superType, this.annotations)__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,this,resolvable,type,as,super,type,super,type,this,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1405430015;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null}_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(this.resolvableType.as(superType), superType, this.annotations)__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,this,resolvable,type,as,super,type,super,type,this,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1406196817;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null}_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(this.resolvableType.as(superType), superType, this.annotations)__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,this,resolvable,type,as,super,type,super,type,this,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1412611699;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null}_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(this.resolvableType.as(superType), superType, this.annotations)__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,this,resolvable,type,as,super,type,super,type,this,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1414925289;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null}_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(this.resolvableType.as(superType), superType, this.annotations)__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,this,resolvable,type,as,super,type,super,type,this,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1417290561;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null}_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(this.resolvableType.as(superType), superType, this.annotations)__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,this,resolvable,type,as,super,type,super,type,this,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1419966315;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null}_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(this.resolvableType.as(superType), superType, this.annotations)__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,this,resolvable,type,as,super,type,super,type,this,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1424769447;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null}_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(this.resolvableType.as(superType), superType, this.annotations)__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,this,resolvable,type,as,super,type,super,type,this,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1424887506;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null}_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(this.resolvableType.as(superType), superType, this.annotations)__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,this,resolvable,type,as,super,type,super,type,this,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1425763631;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null}_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(this.resolvableType.as(superType), superType, this.annotations)__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,this,resolvable,type,as,super,type,super,type,this,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1431093918;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null}_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(this.resolvableType.as(superType), superType, this.annotations)__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,this,resolvable,type,as,super,type,super,type,this,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1432125256;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null}_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(this.resolvableType.as(superType), superType, this.annotations)__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,this,resolvable,type,as,super,type,super,type,this,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1441035153;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null})_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(this.resolvableType.as(superType), superType, this.annotations)__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,this,resolvable,type,as,super,type,super,type,this,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1448383050;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null})_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(this.resolvableType.as(superType), superType, this.annotations)__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,this,resolvable,type,as,super,type,super,type,this,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1450473050;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null})_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(this.resolvableType.as(superType), superType, this.annotations)__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,this,resolvable,type,as,super,type,super,type,this,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1467288171;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null})_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(this.resolvableType.as(superType), superType, this.annotations)__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,this,resolvable,type,as,super,type,super,type,this,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1467677340;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null})_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(this.resolvableType.as(superType), superType, this.annotations)__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,this,resolvable,type,as,super,type,super,type,this,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1467730834;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null})_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(this.resolvableType.as(superType), superType, this.annotations)__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,this,resolvable,type,as,super,type,super,type,this,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1477690406;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null})_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(getResolvableType().as(superType), superType, getAnnotations())__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,get,resolvable,type,as,super,type,super,type,get,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1478094883;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null})_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(getResolvableType().as(superType), superType, getAnnotations())__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,get,resolvable,type,as,super,type,super,type,get,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1479823020;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null})_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(getResolvableType().as(superType), superType, getAnnotations())__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,get,resolvable,type,as,super,type,super,type,get,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1479900301;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null})_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(getResolvableType().as(superType), superType, getAnnotations())__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,get,resolvable,type,as,super,type,super,type,get,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1480540964;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null})_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(getResolvableType().as(superType), superType, getAnnotations())__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,get,resolvable,type,as,super,type,super,type,get,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1481578128;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null})_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(getResolvableType().as(superType), superType, getAnnotations())__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,get,resolvable,type,as,super,type,super,type,get,annotations
TypeDescriptor -> public TypeDescriptor upcast(Class<?> superType);1482961889;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null})_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;public TypeDescriptor upcast(Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(getResolvableType().as(superType), superType, getAnnotations())__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;public,type,descriptor,upcast,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,get,resolvable,type,as,super,type,super,type,get,annotations
TypeDescriptor -> @Deprecated 	public Class<?> getMapKeyType();1328020251;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}._@throws IllegalStateException if this type is not a java.util.Map.;@Deprecated_	public Class<?> getMapKeyType() {_		return getMapKeyTypeDescriptor().getType()__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,key,type,descriptor,get,map,key,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,key,type,return,get,map,key,type,descriptor,get,type
TypeDescriptor -> @Deprecated 	public Class<?> getMapKeyType();1329142650;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}._@throws IllegalStateException if this type is not a java.util.Map.;@Deprecated_	public Class<?> getMapKeyType() {_		return getMapKeyTypeDescriptor().getType()__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,key,type,descriptor,get,map,key,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,key,type,return,get,map,key,type,descriptor,get,type
TypeDescriptor -> @Deprecated 	public Class<?> getMapKeyType();1335774711;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}._@throws IllegalStateException if this type is not a java.util.Map.;@Deprecated_	public Class<?> getMapKeyType() {_		return getMapKeyTypeDescriptor().getType()__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,key,type,descriptor,get,map,key,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,key,type,return,get,map,key,type,descriptor,get,type
TypeDescriptor -> @Deprecated 	public Class<?> getMapKeyType();1349907422;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Map;@Deprecated_	public Class<?> getMapKeyType() {_		return getMapKeyTypeDescriptor().getType()__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,key,type,descriptor,get,map,key,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,key,type,return,get,map,key,type,descriptor,get,type
TypeDescriptor -> @Deprecated 	public Class<?> getMapKeyType();1351584957;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Map;@Deprecated_	public Class<?> getMapKeyType() {_		return getMapKeyTypeDescriptor().getType()__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,key,type,descriptor,get,map,key,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,key,type,return,get,map,key,type,descriptor,get,type
TypeDescriptor -> @Deprecated 	public Class<?> getMapKeyType();1351648403;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Map;@Deprecated_	public Class<?> getMapKeyType() {_		return getMapKeyTypeDescriptor().getType()__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,key,type,descriptor,get,map,key,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,key,type,return,get,map,key,type,descriptor,get,type
TypeDescriptor -> @Deprecated 	public Class<?> getMapKeyType();1356735495;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Map;@Deprecated_	public Class<?> getMapKeyType() {_		return getMapKeyTypeDescriptor().getType()__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,key,type,descriptor,get,map,key,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,key,type,return,get,map,key,type,descriptor,get,type
TypeDescriptor -> @Deprecated 	public Class<?> getMapKeyType();1362408075;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Map;@Deprecated_	public Class<?> getMapKeyType() {_		return getMapKeyTypeDescriptor().getType()__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,key,type,descriptor,get,map,key,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,key,type,return,get,map,key,type,descriptor,get,type
TypeDescriptor -> @Deprecated 	public Class<?> getMapKeyType();1368482696;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Map;@Deprecated_	public Class<?> getMapKeyType() {_		return getMapKeyTypeDescriptor().getType()__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,key,type,descriptor,get,map,key,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,key,type,return,get,map,key,type,descriptor,get,type
TypeDescriptor -> @Deprecated 	public Class<?> getMapKeyType();1374614239;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Map;@Deprecated_	public Class<?> getMapKeyType() {_		return getMapKeyTypeDescriptor().getType()__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,key,type,descriptor,get,map,key,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,key,type,return,get,map,key,type,descriptor,get,type
TypeDescriptor -> @Deprecated 	public Class<?> getMapKeyType();1382042882;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Map;@Deprecated_	public Class<?> getMapKeyType() {_		return getType(getMapKeyTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,key,type,descriptor,get,map,key,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,key,type,return,get,type,get,map,key,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getMapKeyType();1382119085;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Map;@Deprecated_	public Class<?> getMapKeyType() {_		return getType(getMapKeyTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,key,type,descriptor,get,map,key,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,key,type,return,get,type,get,map,key,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getMapKeyType();1382750081;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Map;@Deprecated_	public Class<?> getMapKeyType() {_		return getType(getMapKeyTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,key,type,descriptor,get,map,key,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,key,type,return,get,type,get,map,key,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getMapKeyType();1387307647;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Map;@Deprecated_	public Class<?> getMapKeyType() {_		return getType(getMapKeyTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,key,type,descriptor,get,map,key,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,key,type,return,get,type,get,map,key,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getMapKeyType();1387490898;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Map;@Deprecated_	public Class<?> getMapKeyType() {_		return getType(getMapKeyTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,key,type,descriptor,get,map,key,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,key,type,return,get,type,get,map,key,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getMapKeyType();1389985540;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Map;@Deprecated_	public Class<?> getMapKeyType() {_		return getType(getMapKeyTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,key,type,descriptor,get,map,key,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,key,type,return,get,type,get,map,key,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getMapKeyType();1390565795;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Map;@Deprecated_	public Class<?> getMapKeyType() {_		return getType(getMapKeyTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,key,type,descriptor,get,map,key,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,key,type,return,get,type,get,map,key,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getMapKeyType();1390925810;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Map;@Deprecated_	public Class<?> getMapKeyType() {_		return getType(getMapKeyTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,key,type,descriptor,get,map,key,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,key,type,return,get,type,get,map,key,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getMapKeyType();1391081201;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Map;@Deprecated_	public Class<?> getMapKeyType() {_		return getType(getMapKeyTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,key,type,descriptor,get,map,key,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,key,type,return,get,type,get,map,key,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getMapKeyType();1391248381;Returns the value of {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}_@throws IllegalStateException if this type is not a java.util.Map;@Deprecated_	public Class<?> getMapKeyType() {_		return getType(getMapKeyTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,key,type,descriptor,get,map,key,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;deprecated,public,class,get,map,key,type,return,get,type,get,map,key,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getMapKeyType();1394055372;Returns the value of {@link TypeDescriptor#getType() getType()} for the_{@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}_@throws IllegalStateException if this type is not a {@code java.util.Map};@Deprecated_	public Class<?> getMapKeyType() {_		return getType(getMapKeyTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,key,type,descriptor,get,map,key,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;deprecated,public,class,get,map,key,type,return,get,type,get,map,key,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getMapKeyType();1395846555;Returns the value of {@link TypeDescriptor#getType() getType()} for the_{@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}_@throws IllegalStateException if this type is not a {@code java.util.Map};@Deprecated_	public Class<?> getMapKeyType() {_		return getType(getMapKeyTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,key,type,descriptor,get,map,key,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;deprecated,public,class,get,map,key,type,return,get,type,get,map,key,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getMapKeyType();1403636229;Returns the value of {@link TypeDescriptor#getType() getType()} for the_{@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}_@throws IllegalStateException if this type is not a {@code java.util.Map};@Deprecated_	public Class<?> getMapKeyType() {_		return getType(getMapKeyTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,key,type,descriptor,get,map,key,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;deprecated,public,class,get,map,key,type,return,get,type,get,map,key,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getMapKeyType();1405430015;Returns the value of {@link TypeDescriptor#getType() getType()} for the_{@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}_@throws IllegalStateException if this type is not a {@code java.util.Map};@Deprecated_	public Class<?> getMapKeyType() {_		return getType(getMapKeyTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,key,type,descriptor,get,map,key,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;deprecated,public,class,get,map,key,type,return,get,type,get,map,key,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getMapKeyType();1406196817;Returns the value of {@link TypeDescriptor#getType() getType()} for the_{@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}_@throws IllegalStateException if this type is not a {@code java.util.Map};@Deprecated_	public Class<?> getMapKeyType() {_		return getType(getMapKeyTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,key,type,descriptor,get,map,key,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;deprecated,public,class,get,map,key,type,return,get,type,get,map,key,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getMapKeyType();1412611699;Returns the value of {@link TypeDescriptor#getType() getType()} for the_{@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}_@throws IllegalStateException if this type is not a {@code java.util.Map};@Deprecated_	public Class<?> getMapKeyType() {_		return getType(getMapKeyTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,key,type,descriptor,get,map,key,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;deprecated,public,class,get,map,key,type,return,get,type,get,map,key,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getMapKeyType();1414925289;Returns the value of {@link TypeDescriptor#getType() getType()} for the_{@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}_@throws IllegalStateException if this type is not a {@code java.util.Map};@Deprecated_	public Class<?> getMapKeyType() {_		return getType(getMapKeyTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,key,type,descriptor,get,map,key,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;deprecated,public,class,get,map,key,type,return,get,type,get,map,key,type,descriptor
TypeDescriptor -> @Deprecated 	public Class<?> getMapKeyType();1417290561;Returns the value of {@link TypeDescriptor#getType() getType()} for the_{@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}._@deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}_@throws IllegalStateException if this type is not a {@code java.util.Map};@Deprecated_	public Class<?> getMapKeyType() {_		return getType(getMapKeyTypeDescriptor())__	};returns,the,value,of,link,type,descriptor,get,type,get,type,for,the,link,get,map,key,type,descriptor,get,map,key,type,descriptor,deprecated,in,spring,3,1,in,favor,of,link,get,map,key,type,descriptor,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;deprecated,public,class,get,map,key,type,return,get,type,get,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1328020251;If this type is a {@link Map} and its key type is parameterized, returns the map's key type._If the Map's key type is not parameterized, returns null indicating the key type is not declared._@return the Map key type, or <code>null</code> if this type is a Map but its key type is not parameterized._@throws IllegalStateException if this type is not a java.util.Map.;public TypeDescriptor getMapKeyTypeDescriptor() {_		assertMap()__		return this.mapKeyTypeDescriptor__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,code,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,map,return,this,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1329142650;If this type is a {@link Map} and its key type is parameterized, returns the map's key type._If the Map's key type is not parameterized, returns null indicating the key type is not declared._@return the Map key type, or <code>null</code> if this type is a Map but its key type is not parameterized._@throws IllegalStateException if this type is not a java.util.Map.;public TypeDescriptor getMapKeyTypeDescriptor() {_		assertMap()__		return this.mapKeyTypeDescriptor__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,code,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,map,return,this,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1335774711;If this type is a {@link Map} and its key type is parameterized, returns the map's key type._If the Map's key type is not parameterized, returns null indicating the key type is not declared._@return the Map key type, or <code>null</code> if this type is a Map but its key type is not parameterized._@throws IllegalStateException if this type is not a java.util.Map.;public TypeDescriptor getMapKeyTypeDescriptor() {_		assertMap()__		return this.mapKeyTypeDescriptor__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,code,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,map,return,this,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1349907422;If this type is a {@link Map} and its key type is parameterized, returns the map's key type._If the Map's key type is not parameterized, returns null indicating the key type is not declared._@return the Map key type, or <code>null</code> if this type is a Map but its key type is not parameterized_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapKeyTypeDescriptor() {_		assertMap()__		return this.mapKeyTypeDescriptor__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,code,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,map,return,this,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1351584957;If this type is a {@link Map} and its key type is parameterized, returns the map's key type._If the Map's key type is not parameterized, returns null indicating the key type is not declared._@return the Map key type, or <code>null</code> if this type is a Map but its key type is not parameterized_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapKeyTypeDescriptor() {_		assertMap()__		return this.mapKeyTypeDescriptor__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,code,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,map,return,this,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1351648403;If this type is a {@link Map} and its key type is parameterized, returns the map's key type._If the Map's key type is not parameterized, returns null indicating the key type is not declared._@return the Map key type, or <code>null</code> if this type is a Map but its key type is not parameterized_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapKeyTypeDescriptor() {_		assertMap()__		return this.mapKeyTypeDescriptor__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,code,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,map,return,this,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1356735495;If this type is a {@link Map} and its key type is parameterized, returns the map's key type._If the Map's key type is not parameterized, returns null indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map but its key type is not parameterized_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapKeyTypeDescriptor() {_		assertMap()__		return this.mapKeyTypeDescriptor__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,map,return,this,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1362408075;If this type is a {@link Map} and its key type is parameterized, returns the map's key type._If the Map's key type is not parameterized, returns null indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map but its key type is not parameterized_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapKeyTypeDescriptor() {_		assertMap()__		return this.mapKeyTypeDescriptor__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,map,return,this,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1368482696;If this type is a {@link Map} and its key type is parameterized, returns the map's key type._If the Map's key type is not parameterized, returns null indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map but its key type is not parameterized_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapKeyTypeDescriptor() {_		assertMap()__		return this.mapKeyTypeDescriptor__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,map,return,this,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1374614239;If this type is a {@link Map} and its key type is parameterized, returns the map's key type._If the Map's key type is not parameterized, returns null indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map but its key type is not parameterized_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapKeyTypeDescriptor() {_		assertMap()__		return this.mapKeyTypeDescriptor__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,map,return,this,map,key,type,descriptor
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1382042882;If this type is a {@link Map} and its key type is parameterized, returns the map's key type._If the Map's key type is not parameterized, returns null indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map but its key type is not parameterized_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapKeyTypeDescriptor() {_		assertMap()__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,0
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1382119085;If this type is a {@link Map} and its key type is parameterized, returns the map's key type._If the Map's key type is not parameterized, returns null indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map but its key type is not parameterized_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapKeyTypeDescriptor() {_		assertMap()__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,0
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1382750081;If this type is a {@link Map} and its key type is parameterized, returns the map's key type._If the Map's key type is not parameterized, returns null indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map but its key type is not parameterized_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapKeyTypeDescriptor() {_		assertMap()__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,0
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1387307647;If this type is a {@link Map} and its key type is parameterized, returns the map's key type._If the Map's key type is not parameterized, returns null indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map but its key type is not parameterized_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapKeyTypeDescriptor() {_		assertMap()__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,0
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1387490898;If this type is a {@link Map} and its key type is parameterized, returns the map's key type._If the Map's key type is not parameterized, returns null indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map but its key type is not parameterized_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapKeyTypeDescriptor() {_		assertMap()__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,0
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1389985540;If this type is a {@link Map} and its key type is parameterized, returns the map's key type._If the Map's key type is not parameterized, returns null indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map but its key type is not parameterized_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapKeyTypeDescriptor() {_		assertMap()__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,0
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1390565795;If this type is a {@link Map} and its key type is parameterized, returns the map's key type._If the Map's key type is not parameterized, returns null indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map but its key type is not parameterized_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapKeyTypeDescriptor() {_		assertMap()__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,0
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1390925810;If this type is a {@link Map} and its key type is parameterized, returns the map's key type._If the Map's key type is not parameterized, returns null indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map but its key type is not parameterized_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapKeyTypeDescriptor() {_		assertMap()__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,0
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1391081201;If this type is a {@link Map} and its key type is parameterized, returns the map's key type._If the Map's key type is not parameterized, returns null indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map but its key type is not parameterized_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapKeyTypeDescriptor() {_		assertMap()__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,0
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1391248381;If this type is a {@link Map} and its key type is parameterized, returns the map's key type._If the Map's key type is not parameterized, returns null indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map but its key type is not parameterized_@throws IllegalStateException if this type is not a java.util.Map;public TypeDescriptor getMapKeyTypeDescriptor() {_		assertMap()__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,0
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1394055372;If this type is a {@link Map} and its key type is parameterized,_returns the map's key type. If the Map's key type is not parameterized,_returns {@code null} indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map_but its key type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapKeyTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,code,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,0
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1395846555;If this type is a {@link Map} and its key type is parameterized,_returns the map's key type. If the Map's key type is not parameterized,_returns {@code null} indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map_but its key type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapKeyTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,code,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,0
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1403636229;If this type is a {@link Map} and its key type is parameterized,_returns the map's key type. If the Map's key type is not parameterized,_returns {@code null} indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map_but its key type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapKeyTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,code,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,0
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1405430015;If this type is a {@link Map} and its key type is parameterized,_returns the map's key type. If the Map's key type is not parameterized,_returns {@code null} indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map_but its key type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapKeyTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,code,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,0
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1406196817;If this type is a {@link Map} and its key type is parameterized,_returns the map's key type. If the Map's key type is not parameterized,_returns {@code null} indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map_but its key type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapKeyTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,code,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,0
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1412611699;If this type is a {@link Map} and its key type is parameterized,_returns the map's key type. If the Map's key type is not parameterized,_returns {@code null} indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map_but its key type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapKeyTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,code,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,0
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1414925289;If this type is a {@link Map} and its key type is parameterized,_returns the map's key type. If the Map's key type is not parameterized,_returns {@code null} indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map_but its key type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapKeyTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,code,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,0
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1417290561;If this type is a {@link Map} and its key type is parameterized,_returns the map's key type. If the Map's key type is not parameterized,_returns {@code null} indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map_but its key type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapKeyTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,code,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,0
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1419966315;If this type is a {@link Map} and its key type is parameterized,_returns the map's key type. If the Map's key type is not parameterized,_returns {@code null} indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map_but its key type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapKeyTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,code,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,0
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1424769447;If this type is a {@link Map} and its key type is parameterized,_returns the map's key type. If the Map's key type is not parameterized,_returns {@code null} indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map_but its key type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapKeyTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,code,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,0
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1424887506;If this type is a {@link Map} and its key type is parameterized,_returns the map's key type. If the Map's key type is not parameterized,_returns {@code null} indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map_but its key type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapKeyTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,code,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,0
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1425763631;If this type is a {@link Map} and its key type is parameterized,_returns the map's key type. If the Map's key type is not parameterized,_returns {@code null} indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map_but its key type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapKeyTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,code,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,0
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1431093918;If this type is a {@link Map} and its key type is parameterized,_returns the map's key type. If the Map's key type is not parameterized,_returns {@code null} indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map_but its key type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapKeyTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,code,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,0
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1432125256;If this type is a {@link Map} and its key type is parameterized,_returns the map's key type. If the Map's key type is not parameterized,_returns {@code null} indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map_but its key type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapKeyTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,code,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,0
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1441035153;If this type is a {@link Map} and its key type is parameterized,_returns the map's key type. If the Map's key type is not parameterized,_returns {@code null} indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map_but its key type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapKeyTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,code,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,0
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1448383050;If this type is a {@link Map} and its key type is parameterized,_returns the map's key type. If the Map's key type is not parameterized,_returns {@code null} indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map_but its key type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapKeyTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,code,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,0
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1450473050;If this type is a {@link Map} and its key type is parameterized,_returns the map's key type. If the Map's key type is not parameterized,_returns {@code null} indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map_but its key type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapKeyTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,code,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,0
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1467288171;If this type is a {@link Map} and its key type is parameterized,_returns the map's key type. If the Map's key type is not parameterized,_returns {@code null} indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map_but its key type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapKeyTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,code,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,0
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1467677340;If this type is a {@link Map} and its key type is parameterized,_returns the map's key type. If the Map's key type is not parameterized,_returns {@code null} indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map_but its key type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapKeyTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,code,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,0
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1467730834;If this type is a {@link Map} and its key type is parameterized,_returns the map's key type. If the Map's key type is not parameterized,_returns {@code null} indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map_but its key type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapKeyTypeDescriptor() {_		Assert.state(isMap(), "Not a java.util.Map")__		return getRelatedIfResolvable(this, this.resolvableType.asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,code,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,this,resolvable,type,as,map,get,generic,0
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1477690406;If this type is a {@link Map} and its key type is parameterized,_returns the map's key type. If the Map's key type is not parameterized,_returns {@code null} indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map_but its key type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapKeyTypeDescriptor() {_		Assert.state(isMap(), "Not a [java.util.Map]")__		return getRelatedIfResolvable(this, getResolvableType().asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,code,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,get,resolvable,type,as,map,get,generic,0
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1478094883;If this type is a {@link Map} and its key type is parameterized,_returns the map's key type. If the Map's key type is not parameterized,_returns {@code null} indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map_but its key type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapKeyTypeDescriptor() {_		Assert.state(isMap(), "Not a [java.util.Map]")__		return getRelatedIfResolvable(this, getResolvableType().asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,code,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,get,resolvable,type,as,map,get,generic,0
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1479823020;If this type is a {@link Map} and its key type is parameterized,_returns the map's key type. If the Map's key type is not parameterized,_returns {@code null} indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map_but its key type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapKeyTypeDescriptor() {_		Assert.state(isMap(), "Not a [java.util.Map]")__		return getRelatedIfResolvable(this, getResolvableType().asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,code,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,get,resolvable,type,as,map,get,generic,0
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1479900301;If this type is a {@link Map} and its key type is parameterized,_returns the map's key type. If the Map's key type is not parameterized,_returns {@code null} indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map_but its key type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapKeyTypeDescriptor() {_		Assert.state(isMap(), "Not a [java.util.Map]")__		return getRelatedIfResolvable(this, getResolvableType().asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,code,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,get,resolvable,type,as,map,get,generic,0
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1480540964;If this type is a {@link Map} and its key type is parameterized,_returns the map's key type. If the Map's key type is not parameterized,_returns {@code null} indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map_but its key type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapKeyTypeDescriptor() {_		Assert.state(isMap(), "Not a [java.util.Map]")__		return getRelatedIfResolvable(this, getResolvableType().asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,code,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,get,resolvable,type,as,map,get,generic,0
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1481578128;If this type is a {@link Map} and its key type is parameterized,_returns the map's key type. If the Map's key type is not parameterized,_returns {@code null} indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map_but its key type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapKeyTypeDescriptor() {_		Assert.state(isMap(), "Not a [java.util.Map]")__		return getRelatedIfResolvable(this, getResolvableType().asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,code,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,get,resolvable,type,as,map,get,generic,0
TypeDescriptor -> public TypeDescriptor getMapKeyTypeDescriptor();1482961889;If this type is a {@link Map} and its key type is parameterized,_returns the map's key type. If the Map's key type is not parameterized,_returns {@code null} indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map_but its key type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};public TypeDescriptor getMapKeyTypeDescriptor() {_		Assert.state(isMap(), "Not a [java.util.Map]")__		return getRelatedIfResolvable(this, getResolvableType().asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,code,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;public,type,descriptor,get,map,key,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,get,resolvable,type,as,map,get,generic,0
TypeDescriptor -> protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations);1389985540;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type or {@code null} if should be resolved_@param annotations the type annotations;protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.resolve(Object.class))__		this.annotations = nullSafeAnnotations(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,should,be,resolved,param,annotations,the,type,annotations;protected,type,descriptor,resolvable,type,resolvable,type,class,type,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,annotations
TypeDescriptor -> protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations);1390565795;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type or {@code null} if should be resolved_@param annotations the type annotations;protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.resolve(Object.class))__		this.annotations = nullSafeAnnotations(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,should,be,resolved,param,annotations,the,type,annotations;protected,type,descriptor,resolvable,type,resolvable,type,class,type,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,annotations
TypeDescriptor -> protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations);1390925810;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type or {@code null} if should be resolved_@param annotations the type annotations;protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.resolve(Object.class))__		this.annotations = nullSafeAnnotations(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,should,be,resolved,param,annotations,the,type,annotations;protected,type,descriptor,resolvable,type,resolvable,type,class,type,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,annotations
TypeDescriptor -> protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations);1391081201;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type or {@code null} if should be resolved_@param annotations the type annotations;protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.resolve(Object.class))__		this.annotations = nullSafeAnnotations(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,should,be,resolved,param,annotations,the,type,annotations;protected,type,descriptor,resolvable,type,resolvable,type,class,type,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,annotations
TypeDescriptor -> protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations);1391248381;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type or {@code null} if should be resolved_@param annotations the type annotations;protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.resolve(Object.class))__		this.annotations = nullSafeAnnotations(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,should,be,resolved,param,annotations,the,type,annotations;protected,type,descriptor,resolvable,type,resolvable,type,class,type,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,annotations
TypeDescriptor -> protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations);1394055372;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type or {@code null} if should be resolved_@param annotations the type annotations;protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.resolve(Object.class))__		this.annotations = nullSafeAnnotations(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,should,be,resolved,param,annotations,the,type,annotations;protected,type,descriptor,resolvable,type,resolvable,type,class,type,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,annotations
TypeDescriptor -> protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations);1395846555;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type or {@code null} if should be resolved_@param annotations the type annotations;protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.resolve(Object.class))__		this.annotations = nullSafeAnnotations(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,should,be,resolved,param,annotations,the,type,annotations;protected,type,descriptor,resolvable,type,resolvable,type,class,type,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,annotations
TypeDescriptor -> protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations);1403636229;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type or {@code null} if should be resolved_@param annotations the type annotations;protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.resolve(Object.class))__		this.annotations = nullSafeAnnotations(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,should,be,resolved,param,annotations,the,type,annotations;protected,type,descriptor,resolvable,type,resolvable,type,class,type,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,annotations
TypeDescriptor -> protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations);1405430015;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type or {@code null} if should be resolved_@param annotations the type annotations;protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.resolve(Object.class))__		this.annotations = nullSafeAnnotations(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,should,be,resolved,param,annotations,the,type,annotations;protected,type,descriptor,resolvable,type,resolvable,type,class,type,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,annotations
TypeDescriptor -> protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations);1406196817;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type or {@code null} if should be resolved_@param annotations the type annotations;protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.resolve(Object.class))__		this.annotations = nullSafeAnnotations(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,should,be,resolved,param,annotations,the,type,annotations;protected,type,descriptor,resolvable,type,resolvable,type,class,type,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,annotations
TypeDescriptor -> protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations);1412611699;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type or {@code null} if should be resolved_@param annotations the type annotations;protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.resolve(Object.class))__		this.annotations = nullSafeAnnotations(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,should,be,resolved,param,annotations,the,type,annotations;protected,type,descriptor,resolvable,type,resolvable,type,class,type,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,annotations
TypeDescriptor -> protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations);1414925289;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type or {@code null} if should be resolved_@param annotations the type annotations;protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.resolve(Object.class))__		this.annotations = nullSafeAnnotations(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,should,be,resolved,param,annotations,the,type,annotations;protected,type,descriptor,resolvable,type,resolvable,type,class,type,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,annotations
TypeDescriptor -> protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations);1417290561;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type or {@code null} if should be resolved_@param annotations the type annotations;protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.resolve(Object.class))__		this.annotations = nullSafeAnnotations(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,should,be,resolved,param,annotations,the,type,annotations;protected,type,descriptor,resolvable,type,resolvable,type,class,type,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,annotations
TypeDescriptor -> protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations);1419966315;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type or {@code null} if should be resolved_@param annotations the type annotations;protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.resolve(Object.class))__		this.annotations = nullSafeAnnotations(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,should,be,resolved,param,annotations,the,type,annotations;protected,type,descriptor,resolvable,type,resolvable,type,class,type,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,annotations
TypeDescriptor -> protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations);1424769447;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type or {@code null} if should be resolved_@param annotations the type annotations;protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.resolve(Object.class))__		this.annotations = nullSafeAnnotations(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,should,be,resolved,param,annotations,the,type,annotations;protected,type,descriptor,resolvable,type,resolvable,type,class,type,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,annotations
TypeDescriptor -> protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations);1424887506;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type (or {@code null} if it should get resolved)_@param annotations the type annotations;protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.resolve(Object.class))__		this.annotations = nullSafeAnnotations(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,it,should,get,resolved,param,annotations,the,type,annotations;protected,type,descriptor,resolvable,type,resolvable,type,class,type,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,annotations
TypeDescriptor -> protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations);1425763631;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type (or {@code null} if it should get resolved)_@param annotations the type annotations;protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.resolve(Object.class))__		this.annotations = nullSafeAnnotations(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,it,should,get,resolved,param,annotations,the,type,annotations;protected,type,descriptor,resolvable,type,resolvable,type,class,type,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,annotations
TypeDescriptor -> protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations);1431093918;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type (or {@code null} if it should get resolved)_@param annotations the type annotations;protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.resolve(Object.class))__		this.annotations = nullSafeAnnotations(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,it,should,get,resolved,param,annotations,the,type,annotations;protected,type,descriptor,resolvable,type,resolvable,type,class,type,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,annotations
TypeDescriptor -> protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations);1432125256;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type (or {@code null} if it should get resolved)_@param annotations the type annotations;protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.resolve(Object.class))__		this.annotations = nullSafeAnnotations(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,it,should,get,resolved,param,annotations,the,type,annotations;protected,type,descriptor,resolvable,type,resolvable,type,class,type,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,annotations
TypeDescriptor -> protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations);1441035153;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type (or {@code null} if it should get resolved)_@param annotations the type annotations;protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.resolve(Object.class))__		this.annotations = nullSafeAnnotations(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,it,should,get,resolved,param,annotations,the,type,annotations;protected,type,descriptor,resolvable,type,resolvable,type,class,type,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,annotations
TypeDescriptor -> protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations);1448383050;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type (or {@code null} if it should get resolved)_@param annotations the type annotations;protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.resolve(Object.class))__		this.annotations = nullSafeAnnotations(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,it,should,get,resolved,param,annotations,the,type,annotations;protected,type,descriptor,resolvable,type,resolvable,type,class,type,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,annotations
TypeDescriptor -> protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations);1450473050;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type (or {@code null} if it should get resolved)_@param annotations the type annotations;protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.resolve(Object.class))__		this.annotations = nullSafeAnnotations(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,it,should,get,resolved,param,annotations,the,type,annotations;protected,type,descriptor,resolvable,type,resolvable,type,class,type,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,annotations
TypeDescriptor -> protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations);1467288171;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type (or {@code null} if it should get resolved)_@param annotations the type annotations;protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.resolve(Object.class))__		this.annotations = nullSafeAnnotations(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,it,should,get,resolved,param,annotations,the,type,annotations;protected,type,descriptor,resolvable,type,resolvable,type,class,type,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,annotations
TypeDescriptor -> protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations);1467677340;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type (or {@code null} if it should get resolved)_@param annotations the type annotations;protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.resolve(Object.class))__		this.annotations = nullSafeAnnotations(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,it,should,get,resolved,param,annotations,the,type,annotations;protected,type,descriptor,resolvable,type,resolvable,type,class,type,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,annotations
TypeDescriptor -> protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations);1467730834;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type (or {@code null} if it should get resolved)_@param annotations the type annotations;protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.resolve(Object.class))__		this.annotations = nullSafeAnnotations(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,it,should,get,resolved,param,annotations,the,type,annotations;protected,type,descriptor,resolvable,type,resolvable,type,class,type,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,resolve,object,class,this,annotations,null,safe,annotations,annotations
TypeDescriptor -> protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations);1477690406;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type (or {@code null} if it should get resolved)_@param annotations the type annotations;protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.resolve(Object.class))__		this.annotatedElement = new AnnotatedElementAdapter(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,it,should,get,resolved,param,annotations,the,type,annotations;protected,type,descriptor,resolvable,type,resolvable,type,class,type,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,resolve,object,class,this,annotated,element,new,annotated,element,adapter,annotations
TypeDescriptor -> protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations);1478094883;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type (or {@code null} if it should get resolved)_@param annotations the type annotations;protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.resolve(Object.class))__		this.annotatedElement = new AnnotatedElementAdapter(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,it,should,get,resolved,param,annotations,the,type,annotations;protected,type,descriptor,resolvable,type,resolvable,type,class,type,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,resolve,object,class,this,annotated,element,new,annotated,element,adapter,annotations
TypeDescriptor -> protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations);1479823020;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type (or {@code null} if it should get resolved)_@param annotations the type annotations;protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.resolve(Object.class))__		this.annotatedElement = new AnnotatedElementAdapter(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,it,should,get,resolved,param,annotations,the,type,annotations;protected,type,descriptor,resolvable,type,resolvable,type,class,type,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,resolve,object,class,this,annotated,element,new,annotated,element,adapter,annotations
TypeDescriptor -> protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations);1479900301;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type (or {@code null} if it should get resolved)_@param annotations the type annotations;protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.resolve(Object.class))__		this.annotatedElement = new AnnotatedElementAdapter(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,it,should,get,resolved,param,annotations,the,type,annotations;protected,type,descriptor,resolvable,type,resolvable,type,class,type,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,resolve,object,class,this,annotated,element,new,annotated,element,adapter,annotations
TypeDescriptor -> protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations);1480540964;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type (or {@code null} if it should get resolved)_@param annotations the type annotations_@since 4.0;protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.resolve(Object.class))__		this.annotatedElement = new AnnotatedElementAdapter(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,it,should,get,resolved,param,annotations,the,type,annotations,since,4,0;protected,type,descriptor,resolvable,type,resolvable,type,class,type,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,resolve,object,class,this,annotated,element,new,annotated,element,adapter,annotations
TypeDescriptor -> protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations);1481578128;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type (or {@code null} if it should get resolved)_@param annotations the type annotations_@since 4.0;protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.resolve(Object.class))__		this.annotatedElement = new AnnotatedElementAdapter(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,it,should,get,resolved,param,annotations,the,type,annotations,since,4,0;protected,type,descriptor,resolvable,type,resolvable,type,class,type,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,resolve,object,class,this,annotated,element,new,annotated,element,adapter,annotations
TypeDescriptor -> protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations);1482961889;Create a new type descriptor from a {@link ResolvableType}. This protected_constructor is used internally and may also be used by subclasses that support_non-Java languages with extended type systems._@param resolvableType the resolvable type_@param type the backing type (or {@code null} if it should get resolved)_@param annotations the type annotations_@since 4.0;protected TypeDescriptor(ResolvableType resolvableType, Class<?> type, Annotation[] annotations) {_		this.resolvableType = resolvableType__		this.type = (type != null ? type : resolvableType.resolve(Object.class))__		this.annotatedElement = new AnnotatedElementAdapter(annotations)__	};create,a,new,type,descriptor,from,a,link,resolvable,type,this,protected,constructor,is,used,internally,and,may,also,be,used,by,subclasses,that,support,non,java,languages,with,extended,type,systems,param,resolvable,type,the,resolvable,type,param,type,the,backing,type,or,code,null,if,it,should,get,resolved,param,annotations,the,type,annotations,since,4,0;protected,type,descriptor,resolvable,type,resolvable,type,class,type,annotation,annotations,this,resolvable,type,resolvable,type,this,type,type,null,type,resolvable,type,resolve,object,class,this,annotated,element,new,annotated,element,adapter,annotations
TypeDescriptor -> @Nullable 	public TypeDescriptor getMapKeyTypeDescriptor();1495868221;If this type is a {@link Map} and its key type is parameterized,_returns the map's key type. If the Map's key type is not parameterized,_returns {@code null} indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map_but its key type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};@Nullable_	public TypeDescriptor getMapKeyTypeDescriptor() {_		Assert.state(isMap(), "Not a [java.util.Map]")__		return getRelatedIfResolvable(this, getResolvableType().asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,code,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;nullable,public,type,descriptor,get,map,key,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,get,resolvable,type,as,map,get,generic,0
TypeDescriptor -> @Nullable 	public TypeDescriptor getMapKeyTypeDescriptor();1496259743;If this type is a {@link Map} and its key type is parameterized,_returns the map's key type. If the Map's key type is not parameterized,_returns {@code null} indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map_but its key type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};@Nullable_	public TypeDescriptor getMapKeyTypeDescriptor() {_		Assert.state(isMap(), "Not a [java.util.Map]")__		return getRelatedIfResolvable(this, getResolvableType().asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,code,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;nullable,public,type,descriptor,get,map,key,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,get,resolvable,type,as,map,get,generic,0
TypeDescriptor -> @Nullable 	public TypeDescriptor getMapKeyTypeDescriptor();1496837955;If this type is a {@link Map} and its key type is parameterized,_returns the map's key type. If the Map's key type is not parameterized,_returns {@code null} indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map_but its key type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};@Nullable_	public TypeDescriptor getMapKeyTypeDescriptor() {_		Assert.state(isMap(), "Not a [java.util.Map]")__		return getRelatedIfResolvable(this, getResolvableType().asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,code,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;nullable,public,type,descriptor,get,map,key,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,get,resolvable,type,as,map,get,generic,0
TypeDescriptor -> @Nullable 	public TypeDescriptor getMapKeyTypeDescriptor();1498780456;If this type is a {@link Map} and its key type is parameterized,_returns the map's key type. If the Map's key type is not parameterized,_returns {@code null} indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map_but its key type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};@Nullable_	public TypeDescriptor getMapKeyTypeDescriptor() {_		Assert.state(isMap(), "Not a [java.util.Map]")__		return getRelatedIfResolvable(this, getResolvableType().asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,code,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;nullable,public,type,descriptor,get,map,key,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,get,resolvable,type,as,map,get,generic,0
TypeDescriptor -> @Nullable 	public TypeDescriptor getMapKeyTypeDescriptor();1508084888;If this type is a {@link Map} and its key type is parameterized,_returns the map's key type. If the Map's key type is not parameterized,_returns {@code null} indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map_but its key type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};@Nullable_	public TypeDescriptor getMapKeyTypeDescriptor() {_		Assert.state(isMap(), "Not a [java.util.Map]")__		return getRelatedIfResolvable(this, getResolvableType().asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,code,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;nullable,public,type,descriptor,get,map,key,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,get,resolvable,type,as,map,get,generic,0
TypeDescriptor -> @Nullable 	public TypeDescriptor getMapKeyTypeDescriptor();1522332300;If this type is a {@link Map} and its key type is parameterized,_returns the map's key type. If the Map's key type is not parameterized,_returns {@code null} indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map_but its key type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};@Nullable_	public TypeDescriptor getMapKeyTypeDescriptor() {_		Assert.state(isMap(), "Not a [java.util.Map]")__		return getRelatedIfResolvable(this, getResolvableType().asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,code,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;nullable,public,type,descriptor,get,map,key,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,get,resolvable,type,as,map,get,generic,0
TypeDescriptor -> @Nullable 	public TypeDescriptor getMapKeyTypeDescriptor();1532520919;If this type is a {@link Map} and its key type is parameterized,_returns the map's key type. If the Map's key type is not parameterized,_returns {@code null} indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map_but its key type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};@Nullable_	public TypeDescriptor getMapKeyTypeDescriptor() {_		Assert.state(isMap(), "Not a [java.util.Map]")__		return getRelatedIfResolvable(this, getResolvableType().asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,code,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;nullable,public,type,descriptor,get,map,key,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,get,resolvable,type,as,map,get,generic,0
TypeDescriptor -> @Nullable 	public TypeDescriptor getMapKeyTypeDescriptor();1546963887;If this type is a {@link Map} and its key type is parameterized,_returns the map's key type. If the Map's key type is not parameterized,_returns {@code null} indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map_but its key type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};@Nullable_	public TypeDescriptor getMapKeyTypeDescriptor() {_		Assert.state(isMap(), "Not a [java.util.Map]")__		return getRelatedIfResolvable(this, getResolvableType().asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,code,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;nullable,public,type,descriptor,get,map,key,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,get,resolvable,type,as,map,get,generic,0
TypeDescriptor -> @Nullable 	public TypeDescriptor getMapKeyTypeDescriptor();1547033218;If this type is a {@link Map} and its key type is parameterized,_returns the map's key type. If the Map's key type is not parameterized,_returns {@code null} indicating the key type is not declared._@return the Map key type, or {@code null} if this type is a Map_but its key type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};@Nullable_	public TypeDescriptor getMapKeyTypeDescriptor() {_		Assert.state(isMap(), "Not a [java.util.Map]")__		return getRelatedIfResolvable(this, getResolvableType().asMap().getGeneric(0))__	};if,this,type,is,a,link,map,and,its,key,type,is,parameterized,returns,the,map,s,key,type,if,the,map,s,key,type,is,not,parameterized,returns,code,null,indicating,the,key,type,is,not,declared,return,the,map,key,type,or,code,null,if,this,type,is,a,map,but,its,key,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;nullable,public,type,descriptor,get,map,key,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,get,resolvable,type,as,map,get,generic,0
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1328020251;Create a new type descriptor from a java.util.Map type._Useful for Converting to typed Maps._For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt_ by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like: map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__@param mapType the map type, which must implement {@link Map}._@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		return new TypeDescriptor(mapType, keyTypeDescriptor, valueTypeDescriptor)__	};create,a,new,type,descriptor,from,a,java,util,map,type,useful,for,converting,to,typed,maps,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,return,new,type,descriptor,map,type,key,type,descriptor,value,type,descriptor
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1329142650;Create a new type descriptor from a java.util.Map type._Useful for Converting to typed Maps._For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt_ by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like: map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__@param mapType the map type, which must implement {@link Map}._@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		return new TypeDescriptor(mapType, keyTypeDescriptor, valueTypeDescriptor)__	};create,a,new,type,descriptor,from,a,java,util,map,type,useful,for,converting,to,typed,maps,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,return,new,type,descriptor,map,type,key,type,descriptor,value,type,descriptor
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1335774711;Create a new type descriptor from a java.util.Map type._Useful for Converting to typed Maps._For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt_ by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like: map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__@param mapType the map type, which must implement {@link Map}._@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		return new TypeDescriptor(mapType, keyTypeDescriptor, valueTypeDescriptor)__	};create,a,new,type,descriptor,from,a,java,util,map,type,useful,for,converting,to,typed,maps,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,return,new,type,descriptor,map,type,key,type,descriptor,value,type,descriptor
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1349907422;Create a new type descriptor from a java.util.Map type._Useful for Converting to typed Maps._For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt_ by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like: map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		return new TypeDescriptor(mapType, keyTypeDescriptor, valueTypeDescriptor)__	};create,a,new,type,descriptor,from,a,java,util,map,type,useful,for,converting,to,typed,maps,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,return,new,type,descriptor,map,type,key,type,descriptor,value,type,descriptor
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1351584957;Create a new type descriptor from a java.util.Map type._Useful for Converting to typed Maps._For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt_ by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like: map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		return new TypeDescriptor(mapType, keyTypeDescriptor, valueTypeDescriptor)__	};create,a,new,type,descriptor,from,a,java,util,map,type,useful,for,converting,to,typed,maps,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,return,new,type,descriptor,map,type,key,type,descriptor,value,type,descriptor
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1351648403;Create a new type descriptor from a java.util.Map type._Useful for Converting to typed Maps._For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt_ by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like: map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		return new TypeDescriptor(mapType, keyTypeDescriptor, valueTypeDescriptor)__	};create,a,new,type,descriptor,from,a,java,util,map,type,useful,for,converting,to,typed,maps,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,return,new,type,descriptor,map,type,key,type,descriptor,value,type,descriptor
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1356735495;Create a new type descriptor from a java.util.Map type._Useful for Converting to typed Maps._For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt_ by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like: map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		return new TypeDescriptor(mapType, keyTypeDescriptor, valueTypeDescriptor)__	};create,a,new,type,descriptor,from,a,java,util,map,type,useful,for,converting,to,typed,maps,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,return,new,type,descriptor,map,type,key,type,descriptor,value,type,descriptor
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1362408075;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt_ by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like: map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		return new TypeDescriptor(mapType, keyTypeDescriptor, valueTypeDescriptor)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,return,new,type,descriptor,map,type,key,type,descriptor,value,type,descriptor
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1368482696;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt_ by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like: map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		return new TypeDescriptor(mapType, keyTypeDescriptor, valueTypeDescriptor)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,return,new,type,descriptor,map,type,key,type,descriptor,value,type,descriptor
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1374614239;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt_ by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like: map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		return new TypeDescriptor(mapType, keyTypeDescriptor, valueTypeDescriptor)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,return,new,type,descriptor,map,type,key,type,descriptor,value,type,descriptor
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1382042882;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt_ by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like: map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType,_				keyTypeDescriptor.resolvableType, valueTypeDescriptor.resolvableType), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,type,descriptor,resolvable,type,value,type,descriptor,resolvable,type,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1382119085;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt_ by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like: map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		ResolvableType key = (keyTypeDescriptor == null ? null : keyTypeDescriptor.resolvableType)__		ResolvableType value = (valueTypeDescriptor == null ? null : valueTypeDescriptor.resolvableType)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,null,key,type,descriptor,resolvable,type,resolvable,type,value,value,type,descriptor,null,null,value,type,descriptor,resolvable,type,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1382750081;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt_ by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like: map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		ResolvableType key = (keyTypeDescriptor == null ? null : keyTypeDescriptor.resolvableType)__		ResolvableType value = (valueTypeDescriptor == null ? null : valueTypeDescriptor.resolvableType)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,null,key,type,descriptor,resolvable,type,resolvable,type,value,value,type,descriptor,null,null,value,type,descriptor,resolvable,type,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1387307647;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt_ by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like: map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		ResolvableType key = (keyTypeDescriptor == null ? null : keyTypeDescriptor.resolvableType)__		ResolvableType value = (valueTypeDescriptor == null ? null : valueTypeDescriptor.resolvableType)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,null,key,type,descriptor,resolvable,type,resolvable,type,value,value,type,descriptor,null,null,value,type,descriptor,resolvable,type,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1387490898;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		ResolvableType key = (keyTypeDescriptor == null ? null : keyTypeDescriptor.resolvableType)__		ResolvableType value = (valueTypeDescriptor == null ? null : valueTypeDescriptor.resolvableType)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,null,key,type,descriptor,resolvable,type,resolvable,type,value,value,type,descriptor,null,null,value,type,descriptor,resolvable,type,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1389985540;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		ResolvableType key = (keyTypeDescriptor == null ? null : keyTypeDescriptor.resolvableType)__		ResolvableType value = (valueTypeDescriptor == null ? null : valueTypeDescriptor.resolvableType)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,null,key,type,descriptor,resolvable,type,resolvable,type,value,value,type,descriptor,null,null,value,type,descriptor,resolvable,type,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1390565795;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1390925810;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1391081201;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1391248381;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1394055372;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1395846555;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1403636229;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1405430015;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1406196817;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1412611699;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1414925289;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1417290561;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1419966315;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1424769447;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1424887506;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1425763631;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1431093918;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1432125256;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1441035153;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1448383050;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1450473050;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1467288171;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1467677340;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1467730834;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("mapType must be a java.util.Map")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1477690406;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		Assert.notNull(mapType, "Map type must not be null")__		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("Map type must be a [java.util.Map]")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,assert,not,null,map,type,map,type,must,not,be,null,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1478094883;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		Assert.notNull(mapType, "Map type must not be null")__		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("Map type must be a [java.util.Map]")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,assert,not,null,map,type,map,type,must,not,be,null,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1479823020;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		Assert.notNull(mapType, "Map type must not be null")__		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("Map type must be a [java.util.Map]")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,assert,not,null,map,type,map,type,must,not,be,null,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1479900301;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		Assert.notNull(mapType, "Map type must not be null")__		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("Map type must be a [java.util.Map]")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,assert,not,null,map,type,map,type,must,not,be,null,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1480540964;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		Assert.notNull(mapType, "Map type must not be null")__		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("Map type must be a [java.util.Map]")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,assert,not,null,map,type,map,type,must,not,be,null,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1481578128;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		Assert.notNull(mapType, "Map type must not be null")__		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("Map type must be a [java.util.Map]")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,assert,not,null,map,type,map,type,must,not,be,null,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1482961889;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		Assert.notNull(mapType, "Map type must not be null")__		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("Map type must be a [java.util.Map]")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,assert,not,null,map,type,map,type,must,not,be,null,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1495868221;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		Assert.notNull(mapType, "Map type must not be null")__		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("Map type must be a [java.util.Map]")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,assert,not,null,map,type,map,type,must,not,be,null,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor);1496259743;Create a new type descriptor from a {@link java.util.Map} type._<p>Useful for converting to typed Maps._<p>For example, a Map&lt_String, String&gt_ could be converted to a Map&lt_Id, EmailAddress&gt__by converting to a targetType built with this method:_The method call to construct such a TypeDescriptor would look something like:_<pre class="code">_map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class))__</pre>_@param mapType the map type, which must implement {@link Map}_@param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys_@param valueTypeDescriptor the map's value type, used to convert map values_@return the map type descriptor;public static TypeDescriptor map(Class<?> mapType, TypeDescriptor keyTypeDescriptor, TypeDescriptor valueTypeDescriptor) {_		Assert.notNull(mapType, "Map type must not be null")__		if (!Map.class.isAssignableFrom(mapType)) {_			throw new IllegalArgumentException("Map type must be a [java.util.Map]")__		}_		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null)__		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null)__		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null)__	};create,a,new,type,descriptor,from,a,link,java,util,map,type,p,useful,for,converting,to,typed,maps,p,for,example,a,map,lt,string,string,gt,could,be,converted,to,a,map,lt,id,email,address,gt,by,converting,to,a,target,type,built,with,this,method,the,method,call,to,construct,such,a,type,descriptor,would,look,something,like,pre,class,code,map,map,class,type,descriptor,value,of,id,class,type,descriptor,value,of,email,address,class,pre,param,map,type,the,map,type,which,must,implement,link,map,param,key,type,descriptor,a,descriptor,for,the,map,s,key,type,used,to,convert,map,keys,param,value,type,descriptor,the,map,s,value,type,used,to,convert,map,values,return,the,map,type,descriptor;public,static,type,descriptor,map,class,map,type,type,descriptor,key,type,descriptor,type,descriptor,value,type,descriptor,assert,not,null,map,type,map,type,must,not,be,null,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,map,type,must,be,a,java,util,map,resolvable,type,key,key,type,descriptor,null,key,type,descriptor,resolvable,type,null,resolvable,type,value,value,type,descriptor,null,value,type,descriptor,resolvable,type,null,return,new,type,descriptor,resolvable,type,for,class,with,generics,map,type,key,value,null,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1328020251;Create a new type descriptor for an object._Use this factory method to introspect a source object before asking the conversion system to convert it to some another type._If the provided object is null, returns null, else calls {@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param object the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,if,the,provided,object,is,null,returns,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,object,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1329142650;Create a new type descriptor for an object._Use this factory method to introspect a source object before asking the conversion system to convert it to some another type._If the provided object is null, returns null, else calls {@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param object the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,if,the,provided,object,is,null,returns,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,object,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1335774711;Create a new type descriptor for an object._Use this factory method to introspect a source object before asking the conversion system to convert it to some another type._If the provided object is null, returns null, else calls {@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,if,the,provided,object,is,null,returns,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1349907422;Create a new type descriptor for an object._Use this factory method to introspect a source object before asking the conversion system to convert it to some another type._If the provided object is null, returns null, else calls {@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,if,the,provided,object,is,null,returns,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1351584957;Create a new type descriptor for an object._Use this factory method to introspect a source object before asking the conversion system to convert it to some another type._If the provided object is null, returns null, else calls {@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,if,the,provided,object,is,null,returns,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1351648403;Create a new type descriptor for an object._Use this factory method to introspect a source object before asking the conversion system to convert it to some another type._If the provided object is null, returns null, else calls {@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,if,the,provided,object,is,null,returns,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1356735495;Create a new type descriptor for an object._Use this factory method to introspect a source object before asking the conversion system to convert it to some another type._If the provided object is null, returns null, else calls {@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,if,the,provided,object,is,null,returns,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1362408075;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the conversion system to convert it to some another type._<p>If the provided object is null, returns null, else calls {@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,null,returns,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1368482696;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the conversion system to convert it to some another type._<p>If the provided object is null, returns null, else calls {@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,null,returns,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1374614239;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the conversion system to convert it to some another type._<p>If the provided object is null, returns null, else calls {@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,null,returns,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1382042882;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the conversion system to convert it to some another type._<p>If the provided object is null, returns null, else calls {@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,null,returns,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1382119085;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the conversion system to convert it to some another type._<p>If the provided object is null, returns null, else calls {@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,null,returns,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1382750081;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the conversion system to convert it to some another type._<p>If the provided object is null, returns null, else calls {@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,null,returns,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1387307647;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the conversion system to convert it to some another type._<p>If the provided object is null, returns null, else calls {@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,null,returns,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1387490898;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is null, returns null, else calls {@link #valueOf(Class)}_to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,null,returns,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1389985540;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is null, returns null, else calls {@link #valueOf(Class)}_to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,null,returns,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1390565795;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1390925810;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1391081201;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1391248381;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1394055372;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1395846555;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1403636229;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1405430015;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1406196817;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1412611699;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1414925289;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1417290561;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1419966315;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1424769447;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1424887506;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1425763631;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1431093918;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1432125256;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1441035153;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1448383050;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1450473050;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1467288171;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1467677340;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1467730834;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1477690406;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1478094883;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1479823020;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1479900301;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1480540964;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1481578128;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public static TypeDescriptor forObject(Object source);1482961889;Create a new type descriptor for an object._<p>Use this factory method to introspect a source object before asking the_conversion system to convert it to some another type._<p>If the provided object is {@code null}, returns {@code null}, else calls_{@link #valueOf(Class)} to build a TypeDescriptor from the object's class._@param source the source object_@return the type descriptor;public static TypeDescriptor forObject(Object source) {_		return (source != null ? valueOf(source.getClass()) : null)__	};create,a,new,type,descriptor,for,an,object,p,use,this,factory,method,to,introspect,a,source,object,before,asking,the,conversion,system,to,convert,it,to,some,another,type,p,if,the,provided,object,is,code,null,returns,code,null,else,calls,link,value,of,class,to,build,a,type,descriptor,from,the,object,s,class,param,source,the,source,object,return,the,type,descriptor;public,static,type,descriptor,for,object,object,source,return,source,null,value,of,source,get,class,null
TypeDescriptor -> public Annotation[] getAnnotations();1328020251;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none.;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1329142650;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none.;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1335774711;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none.;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1349907422;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1351584957;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1351648403;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1356735495;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1362408075;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1368482696;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1374614239;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1382042882;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1382119085;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1382750081;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1387307647;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1387490898;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1389985540;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1390565795;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1390925810;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1391081201;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1391248381;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1394055372;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1395846555;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1403636229;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1405430015;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1406196817;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1412611699;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1414925289;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1417290561;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1419966315;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1424769447;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1424887506;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1425763631;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1431093918;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1432125256;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1441035153;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1448383050;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1450473050;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1467288171;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1467677340;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1467730834;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotations__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1477690406;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotatedElement.getAnnotations()__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotated,element,get,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1478094883;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotatedElement.getAnnotations()__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotated,element,get,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1479823020;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotatedElement.getAnnotations()__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotated,element,get,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1479900301;The annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotatedElement.getAnnotations()__	};the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotated,element,get,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1480540964;Return the annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotatedElement.getAnnotations()__	};return,the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotated,element,get,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1481578128;Return the annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotatedElement.getAnnotations()__	};return,the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotated,element,get,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1482961889;Return the annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotatedElement.getAnnotations()__	};return,the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotated,element,get,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1495868221;Return the annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotatedElement.getAnnotations()__	};return,the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotated,element,get,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1496259743;Return the annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotatedElement.getAnnotations()__	};return,the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotated,element,get,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1496837955;Return the annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotatedElement.getAnnotations()__	};return,the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotated,element,get,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1498780456;Return the annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotatedElement.getAnnotations()__	};return,the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotated,element,get,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1508084888;Return the annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotatedElement.getAnnotations()__	};return,the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotated,element,get,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1522332300;Return the annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotatedElement.getAnnotations()__	};return,the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotated,element,get,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1532520919;Return the annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotatedElement.getAnnotations()__	};return,the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotated,element,get,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1546963887;Return the annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotatedElement.getAnnotations()__	};return,the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotated,element,get,annotations
TypeDescriptor -> public Annotation[] getAnnotations();1547033218;Return the annotations associated with this type descriptor, if any._@return the annotations, or an empty array if none;public Annotation[] getAnnotations() {_		return this.annotatedElement.getAnnotations()__	};return,the,annotations,associated,with,this,type,descriptor,if,any,return,the,annotations,or,an,empty,array,if,none;public,annotation,get,annotations,return,this,annotated,element,get,annotations
TypeDescriptor -> @Nullable 	public TypeDescriptor upcast(@Nullable Class<?> superType);1495868221;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null})_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;@Nullable_	public TypeDescriptor upcast(@Nullable Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(getResolvableType().as(superType), superType, getAnnotations())__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;nullable,public,type,descriptor,upcast,nullable,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,get,resolvable,type,as,super,type,super,type,get,annotations
TypeDescriptor -> @Nullable 	public TypeDescriptor upcast(@Nullable Class<?> superType);1496259743;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null})_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;@Nullable_	public TypeDescriptor upcast(@Nullable Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(getResolvableType().as(superType), superType, getAnnotations())__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;nullable,public,type,descriptor,upcast,nullable,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,get,resolvable,type,as,super,type,super,type,get,annotations
TypeDescriptor -> @Nullable 	public TypeDescriptor upcast(@Nullable Class<?> superType);1496837955;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null})_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;@Nullable_	public TypeDescriptor upcast(@Nullable Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(getResolvableType().as(superType), superType, getAnnotations())__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;nullable,public,type,descriptor,upcast,nullable,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,get,resolvable,type,as,super,type,super,type,get,annotations
TypeDescriptor -> @Nullable 	public TypeDescriptor upcast(@Nullable Class<?> superType);1498780456;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null})_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;@Nullable_	public TypeDescriptor upcast(@Nullable Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(getResolvableType().as(superType), superType, getAnnotations())__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;nullable,public,type,descriptor,upcast,nullable,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,get,resolvable,type,as,super,type,super,type,get,annotations
TypeDescriptor -> @Nullable 	public TypeDescriptor upcast(@Nullable Class<?> superType);1508084888;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null})_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;@Nullable_	public TypeDescriptor upcast(@Nullable Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(getResolvableType().as(superType), superType, getAnnotations())__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;nullable,public,type,descriptor,upcast,nullable,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,get,resolvable,type,as,super,type,super,type,get,annotations
TypeDescriptor -> @Nullable 	public TypeDescriptor upcast(@Nullable Class<?> superType);1522332300;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null})_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;@Nullable_	public TypeDescriptor upcast(@Nullable Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(getResolvableType().as(superType), superType, getAnnotations())__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;nullable,public,type,descriptor,upcast,nullable,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,get,resolvable,type,as,super,type,super,type,get,annotations
TypeDescriptor -> @Nullable 	public TypeDescriptor upcast(@Nullable Class<?> superType);1532520919;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null})_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;@Nullable_	public TypeDescriptor upcast(@Nullable Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(getResolvableType().as(superType), superType, getAnnotations())__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;nullable,public,type,descriptor,upcast,nullable,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,get,resolvable,type,as,super,type,super,type,get,annotations
TypeDescriptor -> @Nullable 	public TypeDescriptor upcast(@Nullable Class<?> superType);1546963887;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null})_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;@Nullable_	public TypeDescriptor upcast(@Nullable Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(getResolvableType().as(superType), superType, getAnnotations())__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;nullable,public,type,descriptor,upcast,nullable,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,get,resolvable,type,as,super,type,super,type,get,annotations
TypeDescriptor -> @Nullable 	public TypeDescriptor upcast(@Nullable Class<?> superType);1547033218;Cast this {@link TypeDescriptor} to a superclass or implemented interface_preserving annotations and nested type context._@param superType the super type to cast to (can be {@code null})_@return a new TypeDescriptor for the up-cast type_@throws IllegalArgumentException if this type is not assignable to the super-type_@since 3.2;@Nullable_	public TypeDescriptor upcast(@Nullable Class<?> superType) {_		if (superType == null) {_			return null__		}_		Assert.isAssignable(superType, getType())__		return new TypeDescriptor(getResolvableType().as(superType), superType, getAnnotations())__	};cast,this,link,type,descriptor,to,a,superclass,or,implemented,interface,preserving,annotations,and,nested,type,context,param,super,type,the,super,type,to,cast,to,can,be,code,null,return,a,new,type,descriptor,for,the,up,cast,type,throws,illegal,argument,exception,if,this,type,is,not,assignable,to,the,super,type,since,3,2;nullable,public,type,descriptor,upcast,nullable,class,super,type,if,super,type,null,return,null,assert,is,assignable,super,type,get,type,return,new,type,descriptor,get,resolvable,type,as,super,type,super,type,get,annotations
TypeDescriptor -> protected ResolvableType getResolvableType();1389985540;Returns the underlying {@link ResolvableType}.;protected ResolvableType getResolvableType() {_		return this.resolvableType__	};returns,the,underlying,link,resolvable,type;protected,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> protected ResolvableType getResolvableType();1390565795;Returns the underlying {@link ResolvableType}.;protected ResolvableType getResolvableType() {_		return this.resolvableType__	};returns,the,underlying,link,resolvable,type;protected,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> protected ResolvableType getResolvableType();1390925810;Returns the underlying {@link ResolvableType}.;protected ResolvableType getResolvableType() {_		return this.resolvableType__	};returns,the,underlying,link,resolvable,type;protected,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> protected ResolvableType getResolvableType();1391081201;Returns the underlying {@link ResolvableType}.;protected ResolvableType getResolvableType() {_		return this.resolvableType__	};returns,the,underlying,link,resolvable,type;protected,resolvable,type,get,resolvable,type,return,this,resolvable,type
TypeDescriptor -> @Nullable 	public TypeDescriptor getMapValueTypeDescriptor();1495868221;If this type is a {@link Map} and its value type is parameterized,_returns the map's value type._<p>If the Map's value type is not parameterized, returns {@code null}_indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map_but its value type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};@Nullable_	public TypeDescriptor getMapValueTypeDescriptor() {_		Assert.state(isMap(), "Not a [java.util.Map]")__		return getRelatedIfResolvable(this, getResolvableType().asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,code,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;nullable,public,type,descriptor,get,map,value,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,get,resolvable,type,as,map,get,generic,1
TypeDescriptor -> @Nullable 	public TypeDescriptor getMapValueTypeDescriptor();1496259743;If this type is a {@link Map} and its value type is parameterized,_returns the map's value type._<p>If the Map's value type is not parameterized, returns {@code null}_indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map_but its value type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};@Nullable_	public TypeDescriptor getMapValueTypeDescriptor() {_		Assert.state(isMap(), "Not a [java.util.Map]")__		return getRelatedIfResolvable(this, getResolvableType().asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,code,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;nullable,public,type,descriptor,get,map,value,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,get,resolvable,type,as,map,get,generic,1
TypeDescriptor -> @Nullable 	public TypeDescriptor getMapValueTypeDescriptor();1496837955;If this type is a {@link Map} and its value type is parameterized,_returns the map's value type._<p>If the Map's value type is not parameterized, returns {@code null}_indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map_but its value type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};@Nullable_	public TypeDescriptor getMapValueTypeDescriptor() {_		Assert.state(isMap(), "Not a [java.util.Map]")__		return getRelatedIfResolvable(this, getResolvableType().asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,code,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;nullable,public,type,descriptor,get,map,value,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,get,resolvable,type,as,map,get,generic,1
TypeDescriptor -> @Nullable 	public TypeDescriptor getMapValueTypeDescriptor();1498780456;If this type is a {@link Map} and its value type is parameterized,_returns the map's value type._<p>If the Map's value type is not parameterized, returns {@code null}_indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map_but its value type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};@Nullable_	public TypeDescriptor getMapValueTypeDescriptor() {_		Assert.state(isMap(), "Not a [java.util.Map]")__		return getRelatedIfResolvable(this, getResolvableType().asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,code,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;nullable,public,type,descriptor,get,map,value,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,get,resolvable,type,as,map,get,generic,1
TypeDescriptor -> @Nullable 	public TypeDescriptor getMapValueTypeDescriptor();1508084888;If this type is a {@link Map} and its value type is parameterized,_returns the map's value type._<p>If the Map's value type is not parameterized, returns {@code null}_indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map_but its value type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};@Nullable_	public TypeDescriptor getMapValueTypeDescriptor() {_		Assert.state(isMap(), "Not a [java.util.Map]")__		return getRelatedIfResolvable(this, getResolvableType().asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,code,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;nullable,public,type,descriptor,get,map,value,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,get,resolvable,type,as,map,get,generic,1
TypeDescriptor -> @Nullable 	public TypeDescriptor getMapValueTypeDescriptor();1522332300;If this type is a {@link Map} and its value type is parameterized,_returns the map's value type._<p>If the Map's value type is not parameterized, returns {@code null}_indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map_but its value type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};@Nullable_	public TypeDescriptor getMapValueTypeDescriptor() {_		Assert.state(isMap(), "Not a [java.util.Map]")__		return getRelatedIfResolvable(this, getResolvableType().asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,code,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;nullable,public,type,descriptor,get,map,value,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,get,resolvable,type,as,map,get,generic,1
TypeDescriptor -> @Nullable 	public TypeDescriptor getMapValueTypeDescriptor();1532520919;If this type is a {@link Map} and its value type is parameterized,_returns the map's value type._<p>If the Map's value type is not parameterized, returns {@code null}_indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map_but its value type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};@Nullable_	public TypeDescriptor getMapValueTypeDescriptor() {_		Assert.state(isMap(), "Not a [java.util.Map]")__		return getRelatedIfResolvable(this, getResolvableType().asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,code,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;nullable,public,type,descriptor,get,map,value,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,get,resolvable,type,as,map,get,generic,1
TypeDescriptor -> @Nullable 	public TypeDescriptor getMapValueTypeDescriptor();1546963887;If this type is a {@link Map} and its value type is parameterized,_returns the map's value type._<p>If the Map's value type is not parameterized, returns {@code null}_indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map_but its value type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};@Nullable_	public TypeDescriptor getMapValueTypeDescriptor() {_		Assert.state(isMap(), "Not a [java.util.Map]")__		return getRelatedIfResolvable(this, getResolvableType().asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,code,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;nullable,public,type,descriptor,get,map,value,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,get,resolvable,type,as,map,get,generic,1
TypeDescriptor -> @Nullable 	public TypeDescriptor getMapValueTypeDescriptor();1547033218;If this type is a {@link Map} and its value type is parameterized,_returns the map's value type._<p>If the Map's value type is not parameterized, returns {@code null}_indicating the value type is not declared._@return the Map value type, or {@code null} if this type is a Map_but its value type is not parameterized_@throws IllegalStateException if this type is not a {@code java.util.Map};@Nullable_	public TypeDescriptor getMapValueTypeDescriptor() {_		Assert.state(isMap(), "Not a [java.util.Map]")__		return getRelatedIfResolvable(this, getResolvableType().asMap().getGeneric(1))__	};if,this,type,is,a,link,map,and,its,value,type,is,parameterized,returns,the,map,s,value,type,p,if,the,map,s,value,type,is,not,parameterized,returns,code,null,indicating,the,value,type,is,not,declared,return,the,map,value,type,or,code,null,if,this,type,is,a,map,but,its,value,type,is,not,parameterized,throws,illegal,state,exception,if,this,type,is,not,a,code,java,util,map;nullable,public,type,descriptor,get,map,value,type,descriptor,assert,state,is,map,not,a,java,util,map,return,get,related,if,resolvable,this,get,resolvable,type,as,map,get,generic,1
