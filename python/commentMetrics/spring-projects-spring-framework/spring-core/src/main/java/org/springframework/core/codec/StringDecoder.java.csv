commented;modifiers;parameterAmount;loc;comment;code
false;public;2;4;;@Override public boolean canDecode(ResolvableType elementType, @Nullable MimeType mimeType) {     return (elementType.resolve() == String.class && super.canDecode(elementType, mimeType)). }
false;public;4;14;;@Override public Flux<String> decode(Publisher<DataBuffer> inputStream, ResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {     List<byte[]> delimiterBytes = getDelimiterBytes(mimeType).     Flux<DataBuffer> inputFlux = Flux.from(inputStream).flatMapIterable(dataBuffer -> splitOnDelimiter(dataBuffer, delimiterBytes)).bufferUntil(StringDecoder::isEndFrame).map(StringDecoder::joinUntilEndFrame).doOnDiscard(PooledDataBuffer.class, DataBufferUtils::release).     return super.decode(inputFlux, elementType, mimeType, hints). }
false;private;1;6;;private List<byte[]> getDelimiterBytes(@Nullable MimeType mimeType) {     return this.delimitersCache.computeIfAbsent(getCharset(mimeType), charset -> this.delimiters.stream().map(s -> s.getBytes(charset)).collect(Collectors.toList())). }
true;private;2;37;/**  * Split the given data buffer on delimiter boundaries.  * The returned Flux contains an {@link #END_FRAME} buffer after each delimiter.  */ ;/**  * Split the given data buffer on delimiter boundaries.  * The returned Flux contains an {@link #END_FRAME} buffer after each delimiter.  */ private List<DataBuffer> splitOnDelimiter(DataBuffer dataBuffer, List<byte[]> delimiterBytes) {     List<DataBuffer> frames = new ArrayList<>().     do {         int length = Integer.MAX_VALUE.         byte[] matchingDelimiter = null.         for (byte[] delimiter : delimiterBytes) {             int index = indexOf(dataBuffer, delimiter).             if (index >= 0 && index < length) {                 length = index.                 matchingDelimiter = delimiter.             }         }         DataBuffer frame.         int readPosition = dataBuffer.readPosition().         if (matchingDelimiter != null) {             if (this.stripDelimiter) {                 frame = dataBuffer.slice(readPosition, length).             } else {                 frame = dataBuffer.slice(readPosition, length + matchingDelimiter.length).             }             dataBuffer.readPosition(readPosition + length + matchingDelimiter.length).             frames.add(DataBufferUtils.retain(frame)).             frames.add(END_FRAME).         } else {             frame = dataBuffer.slice(readPosition, dataBuffer.readableByteCount()).             dataBuffer.readPosition(readPosition + dataBuffer.readableByteCount()).             frames.add(DataBufferUtils.retain(frame)).         }     } while (dataBuffer.readableByteCount() > 0).     DataBufferUtils.release(dataBuffer).     return frames. }
true;private,static;2;23;/**  * Find the given delimiter in the given data buffer.  * @return the index of the delimiter, or -1 if not found.  */ ;/**  * Find the given delimiter in the given data buffer.  * @return the index of the delimiter, or -1 if not found.  */ private static int indexOf(DataBuffer dataBuffer, byte[] delimiter) {     for (int i = dataBuffer.readPosition(). i < dataBuffer.writePosition(). i++) {         int dataBufferPos = i.         int delimiterPos = 0.         while (delimiterPos < delimiter.length) {             if (dataBuffer.getByte(dataBufferPos) != delimiter[delimiterPos]) {                 break.             } else {                 dataBufferPos++.                 if (dataBufferPos == dataBuffer.writePosition() && delimiterPos != delimiter.length - 1) {                     return -1.                 }             }             delimiterPos++.         }         if (delimiterPos == delimiter.length) {             return i - dataBuffer.readPosition().         }     }     return -1. }
true;private,static;1;3;/**  * Check whether the given buffer is {@link #END_FRAME}.  */ ;/**  * Check whether the given buffer is {@link #END_FRAME}.  */ private static boolean isEndFrame(DataBuffer dataBuffer) {     return dataBuffer == END_FRAME. }
true;private,static;1;9;/**  * Join the given list of buffers into a single buffer.  */ ;/**  * Join the given list of buffers into a single buffer.  */ private static DataBuffer joinUntilEndFrame(List<DataBuffer> dataBuffers) {     if (!dataBuffers.isEmpty()) {         int lastIdx = dataBuffers.size() - 1.         if (isEndFrame(dataBuffers.get(lastIdx))) {             dataBuffers.remove(lastIdx).         }     }     return dataBuffers.get(0).factory().join(dataBuffers). }
false;protected;4;14;;@Override protected String decodeDataBuffer(DataBuffer dataBuffer, ResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {     Charset charset = getCharset(mimeType).     CharBuffer charBuffer = charset.decode(dataBuffer.asByteBuffer()).     DataBufferUtils.release(dataBuffer).     String value = charBuffer.toString().     LogFormatUtils.traceDebug(logger, traceOn -> {         String formatted = LogFormatUtils.formatValue(value, !traceOn).         return Hints.getLogPrefix(hints) + "Decoded " + formatted.     }).     return value. }
false;private,static;1;8;;private static Charset getCharset(@Nullable MimeType mimeType) {     if (mimeType != null && mimeType.getCharset() != null) {         return mimeType.getCharset().     } else {         return DEFAULT_CHARSET.     } }
true;public,static;1;4;/**  * Create a {@code StringDecoder} for {@code "text/plain"}.  * @param ignored ignored  * @deprecated as of Spring 5.0.4, in favor of {@link #textPlainOnly()} or  * {@link #textPlainOnly(List, boolean)}  */ ;/**  * Create a {@code StringDecoder} for {@code "text/plain"}.  * @param ignored ignored  * @deprecated as of Spring 5.0.4, in favor of {@link #textPlainOnly()} or  * {@link #textPlainOnly(List, boolean)}  */ @Deprecated public static StringDecoder textPlainOnly(boolean ignored) {     return textPlainOnly(). }
true;public,static;0;3;/**  * Create a {@code StringDecoder} for {@code "text/plain"}.  */ ;/**  * Create a {@code StringDecoder} for {@code "text/plain"}.  */ public static StringDecoder textPlainOnly() {     return textPlainOnly(DEFAULT_DELIMITERS, true). }
true;public,static;2;3;/**  * Create a {@code StringDecoder} for {@code "text/plain"}.  * @param delimiters delimiter strings to use to split the input stream  * @param stripDelimiter whether to remove delimiters from the resulting  * input strings  */ ;/**  * Create a {@code StringDecoder} for {@code "text/plain"}.  * @param delimiters delimiter strings to use to split the input stream  * @param stripDelimiter whether to remove delimiters from the resulting  * input strings  */ public static StringDecoder textPlainOnly(List<String> delimiters, boolean stripDelimiter) {     return new StringDecoder(delimiters, stripDelimiter, new MimeType("text", "plain", DEFAULT_CHARSET)). }
true;public,static;1;4;/**  * Create a {@code StringDecoder} that supports all MIME types.  * @param ignored ignored  * @deprecated as of Spring 5.0.4, in favor of {@link #allMimeTypes()} or  * {@link #allMimeTypes(List, boolean)}  */ ;/**  * Create a {@code StringDecoder} that supports all MIME types.  * @param ignored ignored  * @deprecated as of Spring 5.0.4, in favor of {@link #allMimeTypes()} or  * {@link #allMimeTypes(List, boolean)}  */ @Deprecated public static StringDecoder allMimeTypes(boolean ignored) {     return allMimeTypes(). }
true;public,static;0;3;/**  * Create a {@code StringDecoder} that supports all MIME types.  */ ;/**  * Create a {@code StringDecoder} that supports all MIME types.  */ public static StringDecoder allMimeTypes() {     return allMimeTypes(DEFAULT_DELIMITERS, true). }
true;public,static;2;4;/**  * Create a {@code StringDecoder} that supports all MIME types.  * @param delimiters delimiter strings to use to split the input stream  * @param stripDelimiter whether to remove delimiters from the resulting  * input strings  */ ;/**  * Create a {@code StringDecoder} that supports all MIME types.  * @param delimiters delimiter strings to use to split the input stream  * @param stripDelimiter whether to remove delimiters from the resulting  * input strings  */ public static StringDecoder allMimeTypes(List<String> delimiters, boolean stripDelimiter) {     return new StringDecoder(delimiters, stripDelimiter, new MimeType("text", "plain", DEFAULT_CHARSET), MimeTypeUtils.ALL). }
