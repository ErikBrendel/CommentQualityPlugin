# id;timestamp;commentText;codeText;commentWords;codeWords
MethodIntrospector -> public static Method selectInvocableMethod(Method method, Class<?> targetType);1447077465;Select an invocable method on the target type: either the given method itself_if actually exposed on the target type, or otherwise a corresponding method_on one of the target type's interfaces or on the target type itself._<p>Matches on user-declared interfaces will be preferred since they are likely_to contain relevant metadata that corresponds to the method on the target class._@param method the method to check_@param targetType the target type to search methods on_(typically an interface-based JDK proxy)_@return a corresponding invocable method on the target type;public static Method selectInvocableMethod(Method method, Class<?> targetType) {_		if (method.getDeclaringClass().isAssignableFrom(targetType)) {_			return method__		}_		try {_			for (Class<?> ifc : targetType.getInterfaces()) {_				try {_					return ifc.getMethod(method.getName(), method.getParameterTypes())__				}_				catch (NoSuchMethodException ex) {_					_				}_			}_			_			return targetType.getMethod(method.getName(), method.getParameterTypes())__		}_		catch (NoSuchMethodException ex) {_			throw new IllegalStateException(String.format(_					"Need to invoke method '%s' declared on target class '%s', " +_					"but not found in any interface(s) of the exposed proxy type. " +_					"Either pull the method up to an interface or switch to CGLIB " +_					"proxies by enforcing proxy-target-class mode in your configuration.",_					method.getName(), method.getDeclaringClass().getSimpleName()))__		}_	};select,an,invocable,method,on,the,target,type,either,the,given,method,itself,if,actually,exposed,on,the,target,type,or,otherwise,a,corresponding,method,on,one,of,the,target,type,s,interfaces,or,on,the,target,type,itself,p,matches,on,user,declared,interfaces,will,be,preferred,since,they,are,likely,to,contain,relevant,metadata,that,corresponds,to,the,method,on,the,target,class,param,method,the,method,to,check,param,target,type,the,target,type,to,search,methods,on,typically,an,interface,based,jdk,proxy,return,a,corresponding,invocable,method,on,the,target,type;public,static,method,select,invocable,method,method,method,class,target,type,if,method,get,declaring,class,is,assignable,from,target,type,return,method,try,for,class,ifc,target,type,get,interfaces,try,return,ifc,get,method,method,get,name,method,get,parameter,types,catch,no,such,method,exception,ex,return,target,type,get,method,method,get,name,method,get,parameter,types,catch,no,such,method,exception,ex,throw,new,illegal,state,exception,string,format,need,to,invoke,method,s,declared,on,target,class,s,but,not,found,in,any,interface,s,of,the,exposed,proxy,type,either,pull,the,method,up,to,an,interface,or,switch,to,cglib,proxies,by,enforcing,proxy,target,class,mode,in,your,configuration,method,get,name,method,get,declaring,class,get,simple,name
MethodIntrospector -> public static Method selectInvocableMethod(Method method, Class<?> targetType);1450900048;Select an invocable method on the target type: either the given method itself_if actually exposed on the target type, or otherwise a corresponding method_on one of the target type's interfaces or on the target type itself._<p>Matches on user-declared interfaces will be preferred since they are likely_to contain relevant metadata that corresponds to the method on the target class._@param method the method to check_@param targetType the target type to search methods on_(typically an interface-based JDK proxy)_@return a corresponding invocable method on the target type_@throws IllegalStateException if the given method is not invocable on the given_target type (typically due to a proxy mismatch);public static Method selectInvocableMethod(Method method, Class<?> targetType) {_		if (method.getDeclaringClass().isAssignableFrom(targetType)) {_			return method__		}_		try {_			String methodName = method.getName()__			Class<?>[] parameterTypes = method.getParameterTypes()__			for (Class<?> ifc : targetType.getInterfaces()) {_				try {_					return ifc.getMethod(methodName, parameterTypes)__				}_				catch (NoSuchMethodException ex) {_					_				}_			}_			_			return targetType.getMethod(methodName, parameterTypes)__		}_		catch (NoSuchMethodException ex) {_			throw new IllegalStateException(String.format(_					"Need to invoke method '%s' declared on target class '%s', " +_					"but not found in any interface(s) of the exposed proxy type. " +_					"Either pull the method up to an interface or switch to CGLIB " +_					"proxies by enforcing proxy-target-class mode in your configuration.",_					method.getName(), method.getDeclaringClass().getSimpleName()))__		}_	};select,an,invocable,method,on,the,target,type,either,the,given,method,itself,if,actually,exposed,on,the,target,type,or,otherwise,a,corresponding,method,on,one,of,the,target,type,s,interfaces,or,on,the,target,type,itself,p,matches,on,user,declared,interfaces,will,be,preferred,since,they,are,likely,to,contain,relevant,metadata,that,corresponds,to,the,method,on,the,target,class,param,method,the,method,to,check,param,target,type,the,target,type,to,search,methods,on,typically,an,interface,based,jdk,proxy,return,a,corresponding,invocable,method,on,the,target,type,throws,illegal,state,exception,if,the,given,method,is,not,invocable,on,the,given,target,type,typically,due,to,a,proxy,mismatch;public,static,method,select,invocable,method,method,method,class,target,type,if,method,get,declaring,class,is,assignable,from,target,type,return,method,try,string,method,name,method,get,name,class,parameter,types,method,get,parameter,types,for,class,ifc,target,type,get,interfaces,try,return,ifc,get,method,method,name,parameter,types,catch,no,such,method,exception,ex,return,target,type,get,method,method,name,parameter,types,catch,no,such,method,exception,ex,throw,new,illegal,state,exception,string,format,need,to,invoke,method,s,declared,on,target,class,s,but,not,found,in,any,interface,s,of,the,exposed,proxy,type,either,pull,the,method,up,to,an,interface,or,switch,to,cglib,proxies,by,enforcing,proxy,target,class,mode,in,your,configuration,method,get,name,method,get,declaring,class,get,simple,name
MethodIntrospector -> public static Method selectInvocableMethod(Method method, Class<?> targetType);1467677340;Select an invocable method on the target type: either the given method itself_if actually exposed on the target type, or otherwise a corresponding method_on one of the target type's interfaces or on the target type itself._<p>Matches on user-declared interfaces will be preferred since they are likely_to contain relevant metadata that corresponds to the method on the target class._@param method the method to check_@param targetType the target type to search methods on_(typically an interface-based JDK proxy)_@return a corresponding invocable method on the target type_@throws IllegalStateException if the given method is not invocable on the given_target type (typically due to a proxy mismatch);public static Method selectInvocableMethod(Method method, Class<?> targetType) {_		if (method.getDeclaringClass().isAssignableFrom(targetType)) {_			return method__		}_		try {_			String methodName = method.getName()__			Class<?>[] parameterTypes = method.getParameterTypes()__			for (Class<?> ifc : targetType.getInterfaces()) {_				try {_					return ifc.getMethod(methodName, parameterTypes)__				}_				catch (NoSuchMethodException ex) {_					_				}_			}_			_			return targetType.getMethod(methodName, parameterTypes)__		}_		catch (NoSuchMethodException ex) {_			throw new IllegalStateException(String.format(_					"Need to invoke method '%s' declared on target class '%s', " +_					"but not found in any interface(s) of the exposed proxy type. " +_					"Either pull the method up to an interface or switch to CGLIB " +_					"proxies by enforcing proxy-target-class mode in your configuration.",_					method.getName(), method.getDeclaringClass().getSimpleName()))__		}_	};select,an,invocable,method,on,the,target,type,either,the,given,method,itself,if,actually,exposed,on,the,target,type,or,otherwise,a,corresponding,method,on,one,of,the,target,type,s,interfaces,or,on,the,target,type,itself,p,matches,on,user,declared,interfaces,will,be,preferred,since,they,are,likely,to,contain,relevant,metadata,that,corresponds,to,the,method,on,the,target,class,param,method,the,method,to,check,param,target,type,the,target,type,to,search,methods,on,typically,an,interface,based,jdk,proxy,return,a,corresponding,invocable,method,on,the,target,type,throws,illegal,state,exception,if,the,given,method,is,not,invocable,on,the,given,target,type,typically,due,to,a,proxy,mismatch;public,static,method,select,invocable,method,method,method,class,target,type,if,method,get,declaring,class,is,assignable,from,target,type,return,method,try,string,method,name,method,get,name,class,parameter,types,method,get,parameter,types,for,class,ifc,target,type,get,interfaces,try,return,ifc,get,method,method,name,parameter,types,catch,no,such,method,exception,ex,return,target,type,get,method,method,name,parameter,types,catch,no,such,method,exception,ex,throw,new,illegal,state,exception,string,format,need,to,invoke,method,s,declared,on,target,class,s,but,not,found,in,any,interface,s,of,the,exposed,proxy,type,either,pull,the,method,up,to,an,interface,or,switch,to,cglib,proxies,by,enforcing,proxy,target,class,mode,in,your,configuration,method,get,name,method,get,declaring,class,get,simple,name
MethodIntrospector -> public static Method selectInvocableMethod(Method method, Class<?> targetType);1467730834;Select an invocable method on the target type: either the given method itself_if actually exposed on the target type, or otherwise a corresponding method_on one of the target type's interfaces or on the target type itself._<p>Matches on user-declared interfaces will be preferred since they are likely_to contain relevant metadata that corresponds to the method on the target class._@param method the method to check_@param targetType the target type to search methods on_(typically an interface-based JDK proxy)_@return a corresponding invocable method on the target type_@throws IllegalStateException if the given method is not invocable on the given_target type (typically due to a proxy mismatch);public static Method selectInvocableMethod(Method method, Class<?> targetType) {_		if (method.getDeclaringClass().isAssignableFrom(targetType)) {_			return method__		}_		try {_			String methodName = method.getName()__			Class<?>[] parameterTypes = method.getParameterTypes()__			for (Class<?> ifc : targetType.getInterfaces()) {_				try {_					return ifc.getMethod(methodName, parameterTypes)__				}_				catch (NoSuchMethodException ex) {_					_				}_			}_			_			return targetType.getMethod(methodName, parameterTypes)__		}_		catch (NoSuchMethodException ex) {_			throw new IllegalStateException(String.format(_					"Need to invoke method '%s' declared on target class '%s', " +_					"but not found in any interface(s) of the exposed proxy type. " +_					"Either pull the method up to an interface or switch to CGLIB " +_					"proxies by enforcing proxy-target-class mode in your configuration.",_					method.getName(), method.getDeclaringClass().getSimpleName()))__		}_	};select,an,invocable,method,on,the,target,type,either,the,given,method,itself,if,actually,exposed,on,the,target,type,or,otherwise,a,corresponding,method,on,one,of,the,target,type,s,interfaces,or,on,the,target,type,itself,p,matches,on,user,declared,interfaces,will,be,preferred,since,they,are,likely,to,contain,relevant,metadata,that,corresponds,to,the,method,on,the,target,class,param,method,the,method,to,check,param,target,type,the,target,type,to,search,methods,on,typically,an,interface,based,jdk,proxy,return,a,corresponding,invocable,method,on,the,target,type,throws,illegal,state,exception,if,the,given,method,is,not,invocable,on,the,given,target,type,typically,due,to,a,proxy,mismatch;public,static,method,select,invocable,method,method,method,class,target,type,if,method,get,declaring,class,is,assignable,from,target,type,return,method,try,string,method,name,method,get,name,class,parameter,types,method,get,parameter,types,for,class,ifc,target,type,get,interfaces,try,return,ifc,get,method,method,name,parameter,types,catch,no,such,method,exception,ex,return,target,type,get,method,method,name,parameter,types,catch,no,such,method,exception,ex,throw,new,illegal,state,exception,string,format,need,to,invoke,method,s,declared,on,target,class,s,but,not,found,in,any,interface,s,of,the,exposed,proxy,type,either,pull,the,method,up,to,an,interface,or,switch,to,cglib,proxies,by,enforcing,proxy,target,class,mode,in,your,configuration,method,get,name,method,get,declaring,class,get,simple,name
MethodIntrospector -> public static Method selectInvocableMethod(Method method, Class<?> targetType);1467808333;Select an invocable method on the target type: either the given method itself_if actually exposed on the target type, or otherwise a corresponding method_on one of the target type's interfaces or on the target type itself._<p>Matches on user-declared interfaces will be preferred since they are likely_to contain relevant metadata that corresponds to the method on the target class._@param method the method to check_@param targetType the target type to search methods on_(typically an interface-based JDK proxy)_@return a corresponding invocable method on the target type_@throws IllegalStateException if the given method is not invocable on the given_target type (typically due to a proxy mismatch);public static Method selectInvocableMethod(Method method, Class<?> targetType) {_		if (method.getDeclaringClass().isAssignableFrom(targetType)) {_			return method__		}_		try {_			String methodName = method.getName()__			Class<?>[] parameterTypes = method.getParameterTypes()__			for (Class<?> ifc : targetType.getInterfaces()) {_				try {_					return ifc.getMethod(methodName, parameterTypes)__				}_				catch (NoSuchMethodException ex) {_					_				}_			}_			_			return targetType.getMethod(methodName, parameterTypes)__		}_		catch (NoSuchMethodException ex) {_			throw new IllegalStateException(String.format(_					"Need to invoke method '%s' declared on target class '%s', " +_					"but not found in any interface(s) of the exposed proxy type. " +_					"Either pull the method up to an interface or switch to CGLIB " +_					"proxies by enforcing proxy-target-class mode in your configuration.",_					method.getName(), method.getDeclaringClass().getSimpleName()))__		}_	};select,an,invocable,method,on,the,target,type,either,the,given,method,itself,if,actually,exposed,on,the,target,type,or,otherwise,a,corresponding,method,on,one,of,the,target,type,s,interfaces,or,on,the,target,type,itself,p,matches,on,user,declared,interfaces,will,be,preferred,since,they,are,likely,to,contain,relevant,metadata,that,corresponds,to,the,method,on,the,target,class,param,method,the,method,to,check,param,target,type,the,target,type,to,search,methods,on,typically,an,interface,based,jdk,proxy,return,a,corresponding,invocable,method,on,the,target,type,throws,illegal,state,exception,if,the,given,method,is,not,invocable,on,the,given,target,type,typically,due,to,a,proxy,mismatch;public,static,method,select,invocable,method,method,method,class,target,type,if,method,get,declaring,class,is,assignable,from,target,type,return,method,try,string,method,name,method,get,name,class,parameter,types,method,get,parameter,types,for,class,ifc,target,type,get,interfaces,try,return,ifc,get,method,method,name,parameter,types,catch,no,such,method,exception,ex,return,target,type,get,method,method,name,parameter,types,catch,no,such,method,exception,ex,throw,new,illegal,state,exception,string,format,need,to,invoke,method,s,declared,on,target,class,s,but,not,found,in,any,interface,s,of,the,exposed,proxy,type,either,pull,the,method,up,to,an,interface,or,switch,to,cglib,proxies,by,enforcing,proxy,target,class,mode,in,your,configuration,method,get,name,method,get,declaring,class,get,simple,name
MethodIntrospector -> public static Method selectInvocableMethod(Method method, Class<?> targetType);1495868221;Select an invocable method on the target type: either the given method itself_if actually exposed on the target type, or otherwise a corresponding method_on one of the target type's interfaces or on the target type itself._<p>Matches on user-declared interfaces will be preferred since they are likely_to contain relevant metadata that corresponds to the method on the target class._@param method the method to check_@param targetType the target type to search methods on_(typically an interface-based JDK proxy)_@return a corresponding invocable method on the target type_@throws IllegalStateException if the given method is not invocable on the given_target type (typically due to a proxy mismatch);public static Method selectInvocableMethod(Method method, Class<?> targetType) {_		if (method.getDeclaringClass().isAssignableFrom(targetType)) {_			return method__		}_		try {_			String methodName = method.getName()__			Class<?>[] parameterTypes = method.getParameterTypes()__			for (Class<?> ifc : targetType.getInterfaces()) {_				try {_					return ifc.getMethod(methodName, parameterTypes)__				}_				catch (NoSuchMethodException ex) {_					_				}_			}_			_			return targetType.getMethod(methodName, parameterTypes)__		}_		catch (NoSuchMethodException ex) {_			throw new IllegalStateException(String.format(_					"Need to invoke method '%s' declared on target class '%s', " +_					"but not found in any interface(s) of the exposed proxy type. " +_					"Either pull the method up to an interface or switch to CGLIB " +_					"proxies by enforcing proxy-target-class mode in your configuration.",_					method.getName(), method.getDeclaringClass().getSimpleName()))__		}_	};select,an,invocable,method,on,the,target,type,either,the,given,method,itself,if,actually,exposed,on,the,target,type,or,otherwise,a,corresponding,method,on,one,of,the,target,type,s,interfaces,or,on,the,target,type,itself,p,matches,on,user,declared,interfaces,will,be,preferred,since,they,are,likely,to,contain,relevant,metadata,that,corresponds,to,the,method,on,the,target,class,param,method,the,method,to,check,param,target,type,the,target,type,to,search,methods,on,typically,an,interface,based,jdk,proxy,return,a,corresponding,invocable,method,on,the,target,type,throws,illegal,state,exception,if,the,given,method,is,not,invocable,on,the,given,target,type,typically,due,to,a,proxy,mismatch;public,static,method,select,invocable,method,method,method,class,target,type,if,method,get,declaring,class,is,assignable,from,target,type,return,method,try,string,method,name,method,get,name,class,parameter,types,method,get,parameter,types,for,class,ifc,target,type,get,interfaces,try,return,ifc,get,method,method,name,parameter,types,catch,no,such,method,exception,ex,return,target,type,get,method,method,name,parameter,types,catch,no,such,method,exception,ex,throw,new,illegal,state,exception,string,format,need,to,invoke,method,s,declared,on,target,class,s,but,not,found,in,any,interface,s,of,the,exposed,proxy,type,either,pull,the,method,up,to,an,interface,or,switch,to,cglib,proxies,by,enforcing,proxy,target,class,mode,in,your,configuration,method,get,name,method,get,declaring,class,get,simple,name
MethodIntrospector -> public static Method selectInvocableMethod(Method method, Class<?> targetType);1496837955;Select an invocable method on the target type: either the given method itself_if actually exposed on the target type, or otherwise a corresponding method_on one of the target type's interfaces or on the target type itself._<p>Matches on user-declared interfaces will be preferred since they are likely_to contain relevant metadata that corresponds to the method on the target class._@param method the method to check_@param targetType the target type to search methods on_(typically an interface-based JDK proxy)_@return a corresponding invocable method on the target type_@throws IllegalStateException if the given method is not invocable on the given_target type (typically due to a proxy mismatch);public static Method selectInvocableMethod(Method method, Class<?> targetType) {_		if (method.getDeclaringClass().isAssignableFrom(targetType)) {_			return method__		}_		try {_			String methodName = method.getName()__			Class<?>[] parameterTypes = method.getParameterTypes()__			for (Class<?> ifc : targetType.getInterfaces()) {_				try {_					return ifc.getMethod(methodName, parameterTypes)__				}_				catch (NoSuchMethodException ex) {_					_				}_			}_			_			return targetType.getMethod(methodName, parameterTypes)__		}_		catch (NoSuchMethodException ex) {_			throw new IllegalStateException(String.format(_					"Need to invoke method '%s' declared on target class '%s', " +_					"but not found in any interface(s) of the exposed proxy type. " +_					"Either pull the method up to an interface or switch to CGLIB " +_					"proxies by enforcing proxy-target-class mode in your configuration.",_					method.getName(), method.getDeclaringClass().getSimpleName()))__		}_	};select,an,invocable,method,on,the,target,type,either,the,given,method,itself,if,actually,exposed,on,the,target,type,or,otherwise,a,corresponding,method,on,one,of,the,target,type,s,interfaces,or,on,the,target,type,itself,p,matches,on,user,declared,interfaces,will,be,preferred,since,they,are,likely,to,contain,relevant,metadata,that,corresponds,to,the,method,on,the,target,class,param,method,the,method,to,check,param,target,type,the,target,type,to,search,methods,on,typically,an,interface,based,jdk,proxy,return,a,corresponding,invocable,method,on,the,target,type,throws,illegal,state,exception,if,the,given,method,is,not,invocable,on,the,given,target,type,typically,due,to,a,proxy,mismatch;public,static,method,select,invocable,method,method,method,class,target,type,if,method,get,declaring,class,is,assignable,from,target,type,return,method,try,string,method,name,method,get,name,class,parameter,types,method,get,parameter,types,for,class,ifc,target,type,get,interfaces,try,return,ifc,get,method,method,name,parameter,types,catch,no,such,method,exception,ex,return,target,type,get,method,method,name,parameter,types,catch,no,such,method,exception,ex,throw,new,illegal,state,exception,string,format,need,to,invoke,method,s,declared,on,target,class,s,but,not,found,in,any,interface,s,of,the,exposed,proxy,type,either,pull,the,method,up,to,an,interface,or,switch,to,cglib,proxies,by,enforcing,proxy,target,class,mode,in,your,configuration,method,get,name,method,get,declaring,class,get,simple,name
MethodIntrospector -> public static Method selectInvocableMethod(Method method, Class<?> targetType);1519514499;Select an invocable method on the target type: either the given method itself_if actually exposed on the target type, or otherwise a corresponding method_on one of the target type's interfaces or on the target type itself._<p>Matches on user-declared interfaces will be preferred since they are likely_to contain relevant metadata that corresponds to the method on the target class._@param method the method to check_@param targetType the target type to search methods on_(typically an interface-based JDK proxy)_@return a corresponding invocable method on the target type_@throws IllegalStateException if the given method is not invocable on the given_target type (typically due to a proxy mismatch);public static Method selectInvocableMethod(Method method, Class<?> targetType) {_		if (method.getDeclaringClass().isAssignableFrom(targetType)) {_			return method__		}_		try {_			String methodName = method.getName()__			Class<?>[] parameterTypes = method.getParameterTypes()__			for (Class<?> ifc : targetType.getInterfaces()) {_				try {_					return ifc.getMethod(methodName, parameterTypes)__				}_				catch (NoSuchMethodException ex) {_					_				}_			}_			_			return targetType.getMethod(methodName, parameterTypes)__		}_		catch (NoSuchMethodException ex) {_			throw new IllegalStateException(String.format(_					"Need to invoke method '%s' declared on target class '%s', " +_					"but not found in any interface(s) of the exposed proxy type. " +_					"Either pull the method up to an interface or switch to CGLIB " +_					"proxies by enforcing proxy-target-class mode in your configuration.",_					method.getName(), method.getDeclaringClass().getSimpleName()))__		}_	};select,an,invocable,method,on,the,target,type,either,the,given,method,itself,if,actually,exposed,on,the,target,type,or,otherwise,a,corresponding,method,on,one,of,the,target,type,s,interfaces,or,on,the,target,type,itself,p,matches,on,user,declared,interfaces,will,be,preferred,since,they,are,likely,to,contain,relevant,metadata,that,corresponds,to,the,method,on,the,target,class,param,method,the,method,to,check,param,target,type,the,target,type,to,search,methods,on,typically,an,interface,based,jdk,proxy,return,a,corresponding,invocable,method,on,the,target,type,throws,illegal,state,exception,if,the,given,method,is,not,invocable,on,the,given,target,type,typically,due,to,a,proxy,mismatch;public,static,method,select,invocable,method,method,method,class,target,type,if,method,get,declaring,class,is,assignable,from,target,type,return,method,try,string,method,name,method,get,name,class,parameter,types,method,get,parameter,types,for,class,ifc,target,type,get,interfaces,try,return,ifc,get,method,method,name,parameter,types,catch,no,such,method,exception,ex,return,target,type,get,method,method,name,parameter,types,catch,no,such,method,exception,ex,throw,new,illegal,state,exception,string,format,need,to,invoke,method,s,declared,on,target,class,s,but,not,found,in,any,interface,s,of,the,exposed,proxy,type,either,pull,the,method,up,to,an,interface,or,switch,to,cglib,proxies,by,enforcing,proxy,target,class,mode,in,your,configuration,method,get,name,method,get,declaring,class,get,simple,name
MethodIntrospector -> public static Method selectInvocableMethod(Method method, Class<?> targetType);1522716161;Select an invocable method on the target type: either the given method itself_if actually exposed on the target type, or otherwise a corresponding method_on one of the target type's interfaces or on the target type itself._<p>Matches on user-declared interfaces will be preferred since they are likely_to contain relevant metadata that corresponds to the method on the target class._@param method the method to check_@param targetType the target type to search methods on_(typically an interface-based JDK proxy)_@return a corresponding invocable method on the target type_@throws IllegalStateException if the given method is not invocable on the given_target type (typically due to a proxy mismatch);public static Method selectInvocableMethod(Method method, Class<?> targetType) {_		if (method.getDeclaringClass().isAssignableFrom(targetType)) {_			return method__		}_		try {_			String methodName = method.getName()__			Class<?>[] parameterTypes = method.getParameterTypes()__			for (Class<?> ifc : targetType.getInterfaces()) {_				try {_					return ifc.getMethod(methodName, parameterTypes)__				}_				catch (NoSuchMethodException ex) {_					_				}_			}_			_			return targetType.getMethod(methodName, parameterTypes)__		}_		catch (NoSuchMethodException ex) {_			throw new IllegalStateException(String.format(_					"Need to invoke method '%s' declared on target class '%s', " +_					"but not found in any interface(s) of the exposed proxy type. " +_					"Either pull the method up to an interface or switch to CGLIB " +_					"proxies by enforcing proxy-target-class mode in your configuration.",_					method.getName(), method.getDeclaringClass().getSimpleName()))__		}_	};select,an,invocable,method,on,the,target,type,either,the,given,method,itself,if,actually,exposed,on,the,target,type,or,otherwise,a,corresponding,method,on,one,of,the,target,type,s,interfaces,or,on,the,target,type,itself,p,matches,on,user,declared,interfaces,will,be,preferred,since,they,are,likely,to,contain,relevant,metadata,that,corresponds,to,the,method,on,the,target,class,param,method,the,method,to,check,param,target,type,the,target,type,to,search,methods,on,typically,an,interface,based,jdk,proxy,return,a,corresponding,invocable,method,on,the,target,type,throws,illegal,state,exception,if,the,given,method,is,not,invocable,on,the,given,target,type,typically,due,to,a,proxy,mismatch;public,static,method,select,invocable,method,method,method,class,target,type,if,method,get,declaring,class,is,assignable,from,target,type,return,method,try,string,method,name,method,get,name,class,parameter,types,method,get,parameter,types,for,class,ifc,target,type,get,interfaces,try,return,ifc,get,method,method,name,parameter,types,catch,no,such,method,exception,ex,return,target,type,get,method,method,name,parameter,types,catch,no,such,method,exception,ex,throw,new,illegal,state,exception,string,format,need,to,invoke,method,s,declared,on,target,class,s,but,not,found,in,any,interface,s,of,the,exposed,proxy,type,either,pull,the,method,up,to,an,interface,or,switch,to,cglib,proxies,by,enforcing,proxy,target,class,mode,in,your,configuration,method,get,name,method,get,declaring,class,get,simple,name
MethodIntrospector -> public static Method selectInvocableMethod(Method method, Class<?> targetType);1530532518;Select an invocable method on the target type: either the given method itself_if actually exposed on the target type, or otherwise a corresponding method_on one of the target type's interfaces or on the target type itself._<p>Matches on user-declared interfaces will be preferred since they are likely_to contain relevant metadata that corresponds to the method on the target class._@param method the method to check_@param targetType the target type to search methods on_(typically an interface-based JDK proxy)_@return a corresponding invocable method on the target type_@throws IllegalStateException if the given method is not invocable on the given_target type (typically due to a proxy mismatch);public static Method selectInvocableMethod(Method method, Class<?> targetType) {_		if (method.getDeclaringClass().isAssignableFrom(targetType)) {_			return method__		}_		try {_			String methodName = method.getName()__			Class<?>[] parameterTypes = method.getParameterTypes()__			for (Class<?> ifc : targetType.getInterfaces()) {_				try {_					return ifc.getMethod(methodName, parameterTypes)__				}_				catch (NoSuchMethodException ex) {_					_				}_			}_			_			return targetType.getMethod(methodName, parameterTypes)__		}_		catch (NoSuchMethodException ex) {_			throw new IllegalStateException(String.format(_					"Need to invoke method '%s' declared on target class '%s', " +_					"but not found in any interface(s) of the exposed proxy type. " +_					"Either pull the method up to an interface or switch to CGLIB " +_					"proxies by enforcing proxy-target-class mode in your configuration.",_					method.getName(), method.getDeclaringClass().getSimpleName()))__		}_	};select,an,invocable,method,on,the,target,type,either,the,given,method,itself,if,actually,exposed,on,the,target,type,or,otherwise,a,corresponding,method,on,one,of,the,target,type,s,interfaces,or,on,the,target,type,itself,p,matches,on,user,declared,interfaces,will,be,preferred,since,they,are,likely,to,contain,relevant,metadata,that,corresponds,to,the,method,on,the,target,class,param,method,the,method,to,check,param,target,type,the,target,type,to,search,methods,on,typically,an,interface,based,jdk,proxy,return,a,corresponding,invocable,method,on,the,target,type,throws,illegal,state,exception,if,the,given,method,is,not,invocable,on,the,given,target,type,typically,due,to,a,proxy,mismatch;public,static,method,select,invocable,method,method,method,class,target,type,if,method,get,declaring,class,is,assignable,from,target,type,return,method,try,string,method,name,method,get,name,class,parameter,types,method,get,parameter,types,for,class,ifc,target,type,get,interfaces,try,return,ifc,get,method,method,name,parameter,types,catch,no,such,method,exception,ex,return,target,type,get,method,method,name,parameter,types,catch,no,such,method,exception,ex,throw,new,illegal,state,exception,string,format,need,to,invoke,method,s,declared,on,target,class,s,but,not,found,in,any,interface,s,of,the,exposed,proxy,type,either,pull,the,method,up,to,an,interface,or,switch,to,cglib,proxies,by,enforcing,proxy,target,class,mode,in,your,configuration,method,get,name,method,get,declaring,class,get,simple,name
MethodIntrospector -> MetadataLookup -> T inspect(Method method)_;1447077465;Perform a lookup on the given method and return associated metadata, if any._@param method the method to inspect_@return non-null metadata to be associated with a method if there is a match,_or {@code null} for no match;T inspect(Method method)_;perform,a,lookup,on,the,given,method,and,return,associated,metadata,if,any,param,method,the,method,to,inspect,return,non,null,metadata,to,be,associated,with,a,method,if,there,is,a,match,or,code,null,for,no,match;t,inspect,method,method
MethodIntrospector -> MetadataLookup -> T inspect(Method method)_;1450900048;Perform a lookup on the given method and return associated metadata, if any._@param method the method to inspect_@return non-null metadata to be associated with a method if there is a match,_or {@code null} for no match;T inspect(Method method)_;perform,a,lookup,on,the,given,method,and,return,associated,metadata,if,any,param,method,the,method,to,inspect,return,non,null,metadata,to,be,associated,with,a,method,if,there,is,a,match,or,code,null,for,no,match;t,inspect,method,method
MethodIntrospector -> MetadataLookup -> T inspect(Method method)_;1467677340;Perform a lookup on the given method and return associated metadata, if any._@param method the method to inspect_@return non-null metadata to be associated with a method if there is a match,_or {@code null} for no match;T inspect(Method method)_;perform,a,lookup,on,the,given,method,and,return,associated,metadata,if,any,param,method,the,method,to,inspect,return,non,null,metadata,to,be,associated,with,a,method,if,there,is,a,match,or,code,null,for,no,match;t,inspect,method,method
MethodIntrospector -> MetadataLookup -> T inspect(Method method)_;1467730834;Perform a lookup on the given method and return associated metadata, if any._@param method the method to inspect_@return non-null metadata to be associated with a method if there is a match,_or {@code null} for no match;T inspect(Method method)_;perform,a,lookup,on,the,given,method,and,return,associated,metadata,if,any,param,method,the,method,to,inspect,return,non,null,metadata,to,be,associated,with,a,method,if,there,is,a,match,or,code,null,for,no,match;t,inspect,method,method
MethodIntrospector -> MetadataLookup -> T inspect(Method method)_;1467808333;Perform a lookup on the given method and return associated metadata, if any._@param method the method to inspect_@return non-null metadata to be associated with a method if there is a match,_or {@code null} for no match;T inspect(Method method)_;perform,a,lookup,on,the,given,method,and,return,associated,metadata,if,any,param,method,the,method,to,inspect,return,non,null,metadata,to,be,associated,with,a,method,if,there,is,a,match,or,code,null,for,no,match;t,inspect,method,method
MethodIntrospector -> MetadataLookup -> @Nullable 		T inspect(Method method)_;1495868221;Perform a lookup on the given method and return associated metadata, if any._@param method the method to inspect_@return non-null metadata to be associated with a method if there is a match,_or {@code null} for no match;@Nullable_		T inspect(Method method)_;perform,a,lookup,on,the,given,method,and,return,associated,metadata,if,any,param,method,the,method,to,inspect,return,non,null,metadata,to,be,associated,with,a,method,if,there,is,a,match,or,code,null,for,no,match;nullable,t,inspect,method,method
MethodIntrospector -> MetadataLookup -> @Nullable 		T inspect(Method method)_;1496837955;Perform a lookup on the given method and return associated metadata, if any._@param method the method to inspect_@return non-null metadata to be associated with a method if there is a match,_or {@code null} for no match;@Nullable_		T inspect(Method method)_;perform,a,lookup,on,the,given,method,and,return,associated,metadata,if,any,param,method,the,method,to,inspect,return,non,null,metadata,to,be,associated,with,a,method,if,there,is,a,match,or,code,null,for,no,match;nullable,t,inspect,method,method
MethodIntrospector -> MetadataLookup -> @Nullable 		T inspect(Method method)_;1519514499;Perform a lookup on the given method and return associated metadata, if any._@param method the method to inspect_@return non-null metadata to be associated with a method if there is a match,_or {@code null} for no match;@Nullable_		T inspect(Method method)_;perform,a,lookup,on,the,given,method,and,return,associated,metadata,if,any,param,method,the,method,to,inspect,return,non,null,metadata,to,be,associated,with,a,method,if,there,is,a,match,or,code,null,for,no,match;nullable,t,inspect,method,method
MethodIntrospector -> MetadataLookup -> @Nullable 		T inspect(Method method)_;1522716161;Perform a lookup on the given method and return associated metadata, if any._@param method the method to inspect_@return non-null metadata to be associated with a method if there is a match,_or {@code null} for no match;@Nullable_		T inspect(Method method)_;perform,a,lookup,on,the,given,method,and,return,associated,metadata,if,any,param,method,the,method,to,inspect,return,non,null,metadata,to,be,associated,with,a,method,if,there,is,a,match,or,code,null,for,no,match;nullable,t,inspect,method,method
MethodIntrospector -> MetadataLookup -> @Nullable 		T inspect(Method method)_;1530532518;Perform a lookup on the given method and return associated metadata, if any._@param method the method to inspect_@return non-null metadata to be associated with a method if there is a match,_or {@code null} for no match;@Nullable_		T inspect(Method method)_;perform,a,lookup,on,the,given,method,and,return,associated,metadata,if,any,param,method,the,method,to,inspect,return,non,null,metadata,to,be,associated,with,a,method,if,there,is,a,match,or,code,null,for,no,match;nullable,t,inspect,method,method
MethodIntrospector -> public static <T> Map<Method, T> selectMethods(Class<?> targetType, final MetadataLookup<T> metadataLookup);1447077465;Select methods on the given target type based on the lookup of associated metadata._<p>Callers define methods of interest through the {@link MetadataLookup} parameter,_allowing to collect the associated metadata into the result map._@param targetType the target type to search methods on_@param metadataLookup a {@link MetadataLookup} callback to inspect methods of interest,_returning non-null metadata to be associated with a given method if there is a match,_or {@code null} for no match_@return the selected methods associated with their metadata (in the order of retrieval),_or an empty map in case of no match;public static <T> Map<Method, T> selectMethods(Class<?> targetType, final MetadataLookup<T> metadataLookup) {_		final Map<Method, T> methodMap = new LinkedHashMap<Method, T>()__		Set<Class<?>> handlerTypes = new LinkedHashSet<Class<?>>()__		Class<?> specificHandlerType = null___		if (!Proxy.isProxyClass(targetType)) {_			handlerTypes.add(targetType)__			specificHandlerType = targetType__		}_		handlerTypes.addAll(Arrays.asList(targetType.getInterfaces()))___		for (Class<?> currentHandlerType : handlerTypes) {_			final Class<?> targetClass = (specificHandlerType != null ? specificHandlerType : currentHandlerType)___			ReflectionUtils.doWithMethods(currentHandlerType, new ReflectionUtils.MethodCallback() {_				@Override_				public void doWith(Method method) {_					Method specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass)__					T result = metadataLookup.inspect(specificMethod)__					if (result != null) {_						Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(specificMethod)__						if (bridgedMethod == specificMethod || metadataLookup.inspect(bridgedMethod) == null) {_							methodMap.put(specificMethod, result)__						}_					}_				}_			}, ReflectionUtils.USER_DECLARED_METHODS)__		}__		return methodMap__	};select,methods,on,the,given,target,type,based,on,the,lookup,of,associated,metadata,p,callers,define,methods,of,interest,through,the,link,metadata,lookup,parameter,allowing,to,collect,the,associated,metadata,into,the,result,map,param,target,type,the,target,type,to,search,methods,on,param,metadata,lookup,a,link,metadata,lookup,callback,to,inspect,methods,of,interest,returning,non,null,metadata,to,be,associated,with,a,given,method,if,there,is,a,match,or,code,null,for,no,match,return,the,selected,methods,associated,with,their,metadata,in,the,order,of,retrieval,or,an,empty,map,in,case,of,no,match;public,static,t,map,method,t,select,methods,class,target,type,final,metadata,lookup,t,metadata,lookup,final,map,method,t,method,map,new,linked,hash,map,method,t,set,class,handler,types,new,linked,hash,set,class,class,specific,handler,type,null,if,proxy,is,proxy,class,target,type,handler,types,add,target,type,specific,handler,type,target,type,handler,types,add,all,arrays,as,list,target,type,get,interfaces,for,class,current,handler,type,handler,types,final,class,target,class,specific,handler,type,null,specific,handler,type,current,handler,type,reflection,utils,do,with,methods,current,handler,type,new,reflection,utils,method,callback,override,public,void,do,with,method,method,method,specific,method,class,utils,get,most,specific,method,method,target,class,t,result,metadata,lookup,inspect,specific,method,if,result,null,method,bridged,method,bridge,method,resolver,find,bridged,method,specific,method,if,bridged,method,specific,method,metadata,lookup,inspect,bridged,method,null,method,map,put,specific,method,result,reflection,utils,return,method,map
MethodIntrospector -> public static <T> Map<Method, T> selectMethods(Class<?> targetType, final MetadataLookup<T> metadataLookup);1450900048;Select methods on the given target type based on the lookup of associated metadata._<p>Callers define methods of interest through the {@link MetadataLookup} parameter,_allowing to collect the associated metadata into the result map._@param targetType the target type to search methods on_@param metadataLookup a {@link MetadataLookup} callback to inspect methods of interest,_returning non-null metadata to be associated with a given method if there is a match,_or {@code null} for no match_@return the selected methods associated with their metadata (in the order of retrieval),_or an empty map in case of no match;public static <T> Map<Method, T> selectMethods(Class<?> targetType, final MetadataLookup<T> metadataLookup) {_		final Map<Method, T> methodMap = new LinkedHashMap<Method, T>()__		Set<Class<?>> handlerTypes = new LinkedHashSet<Class<?>>()__		Class<?> specificHandlerType = null___		if (!Proxy.isProxyClass(targetType)) {_			handlerTypes.add(targetType)__			specificHandlerType = targetType__		}_		handlerTypes.addAll(Arrays.asList(targetType.getInterfaces()))___		for (Class<?> currentHandlerType : handlerTypes) {_			final Class<?> targetClass = (specificHandlerType != null ? specificHandlerType : currentHandlerType)___			ReflectionUtils.doWithMethods(currentHandlerType, new ReflectionUtils.MethodCallback() {_				@Override_				public void doWith(Method method) {_					Method specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass)__					T result = metadataLookup.inspect(specificMethod)__					if (result != null) {_						Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(specificMethod)__						if (bridgedMethod == specificMethod || metadataLookup.inspect(bridgedMethod) == null) {_							methodMap.put(specificMethod, result)__						}_					}_				}_			}, ReflectionUtils.USER_DECLARED_METHODS)__		}__		return methodMap__	};select,methods,on,the,given,target,type,based,on,the,lookup,of,associated,metadata,p,callers,define,methods,of,interest,through,the,link,metadata,lookup,parameter,allowing,to,collect,the,associated,metadata,into,the,result,map,param,target,type,the,target,type,to,search,methods,on,param,metadata,lookup,a,link,metadata,lookup,callback,to,inspect,methods,of,interest,returning,non,null,metadata,to,be,associated,with,a,given,method,if,there,is,a,match,or,code,null,for,no,match,return,the,selected,methods,associated,with,their,metadata,in,the,order,of,retrieval,or,an,empty,map,in,case,of,no,match;public,static,t,map,method,t,select,methods,class,target,type,final,metadata,lookup,t,metadata,lookup,final,map,method,t,method,map,new,linked,hash,map,method,t,set,class,handler,types,new,linked,hash,set,class,class,specific,handler,type,null,if,proxy,is,proxy,class,target,type,handler,types,add,target,type,specific,handler,type,target,type,handler,types,add,all,arrays,as,list,target,type,get,interfaces,for,class,current,handler,type,handler,types,final,class,target,class,specific,handler,type,null,specific,handler,type,current,handler,type,reflection,utils,do,with,methods,current,handler,type,new,reflection,utils,method,callback,override,public,void,do,with,method,method,method,specific,method,class,utils,get,most,specific,method,method,target,class,t,result,metadata,lookup,inspect,specific,method,if,result,null,method,bridged,method,bridge,method,resolver,find,bridged,method,specific,method,if,bridged,method,specific,method,metadata,lookup,inspect,bridged,method,null,method,map,put,specific,method,result,reflection,utils,return,method,map
MethodIntrospector -> public static <T> Map<Method, T> selectMethods(Class<?> targetType, final MetadataLookup<T> metadataLookup);1467677340;Select methods on the given target type based on the lookup of associated metadata._<p>Callers define methods of interest through the {@link MetadataLookup} parameter,_allowing to collect the associated metadata into the result map._@param targetType the target type to search methods on_@param metadataLookup a {@link MetadataLookup} callback to inspect methods of interest,_returning non-null metadata to be associated with a given method if there is a match,_or {@code null} for no match_@return the selected methods associated with their metadata (in the order of retrieval),_or an empty map in case of no match;public static <T> Map<Method, T> selectMethods(Class<?> targetType, final MetadataLookup<T> metadataLookup) {_		final Map<Method, T> methodMap = new LinkedHashMap<Method, T>()__		Set<Class<?>> handlerTypes = new LinkedHashSet<Class<?>>()__		Class<?> specificHandlerType = null___		if (!Proxy.isProxyClass(targetType)) {_			handlerTypes.add(targetType)__			specificHandlerType = targetType__		}_		handlerTypes.addAll(Arrays.asList(targetType.getInterfaces()))___		for (Class<?> currentHandlerType : handlerTypes) {_			final Class<?> targetClass = (specificHandlerType != null ? specificHandlerType : currentHandlerType)___			ReflectionUtils.doWithMethods(currentHandlerType, new ReflectionUtils.MethodCallback() {_				@Override_				public void doWith(Method method) {_					Method specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass)__					T result = metadataLookup.inspect(specificMethod)__					if (result != null) {_						Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(specificMethod)__						if (bridgedMethod == specificMethod || metadataLookup.inspect(bridgedMethod) == null) {_							methodMap.put(specificMethod, result)__						}_					}_				}_			}, ReflectionUtils.USER_DECLARED_METHODS)__		}__		return methodMap__	};select,methods,on,the,given,target,type,based,on,the,lookup,of,associated,metadata,p,callers,define,methods,of,interest,through,the,link,metadata,lookup,parameter,allowing,to,collect,the,associated,metadata,into,the,result,map,param,target,type,the,target,type,to,search,methods,on,param,metadata,lookup,a,link,metadata,lookup,callback,to,inspect,methods,of,interest,returning,non,null,metadata,to,be,associated,with,a,given,method,if,there,is,a,match,or,code,null,for,no,match,return,the,selected,methods,associated,with,their,metadata,in,the,order,of,retrieval,or,an,empty,map,in,case,of,no,match;public,static,t,map,method,t,select,methods,class,target,type,final,metadata,lookup,t,metadata,lookup,final,map,method,t,method,map,new,linked,hash,map,method,t,set,class,handler,types,new,linked,hash,set,class,class,specific,handler,type,null,if,proxy,is,proxy,class,target,type,handler,types,add,target,type,specific,handler,type,target,type,handler,types,add,all,arrays,as,list,target,type,get,interfaces,for,class,current,handler,type,handler,types,final,class,target,class,specific,handler,type,null,specific,handler,type,current,handler,type,reflection,utils,do,with,methods,current,handler,type,new,reflection,utils,method,callback,override,public,void,do,with,method,method,method,specific,method,class,utils,get,most,specific,method,method,target,class,t,result,metadata,lookup,inspect,specific,method,if,result,null,method,bridged,method,bridge,method,resolver,find,bridged,method,specific,method,if,bridged,method,specific,method,metadata,lookup,inspect,bridged,method,null,method,map,put,specific,method,result,reflection,utils,return,method,map
MethodIntrospector -> public static <T> Map<Method, T> selectMethods(Class<?> targetType, final MetadataLookup<T> metadataLookup);1467730834;Select methods on the given target type based on the lookup of associated metadata._<p>Callers define methods of interest through the {@link MetadataLookup} parameter,_allowing to collect the associated metadata into the result map._@param targetType the target type to search methods on_@param metadataLookup a {@link MetadataLookup} callback to inspect methods of interest,_returning non-null metadata to be associated with a given method if there is a match,_or {@code null} for no match_@return the selected methods associated with their metadata (in the order of retrieval),_or an empty map in case of no match;public static <T> Map<Method, T> selectMethods(Class<?> targetType, final MetadataLookup<T> metadataLookup) {_		final Map<Method, T> methodMap = new LinkedHashMap<>()__		Set<Class<?>> handlerTypes = new LinkedHashSet<>()__		Class<?> specificHandlerType = null___		if (!Proxy.isProxyClass(targetType)) {_			handlerTypes.add(targetType)__			specificHandlerType = targetType__		}_		handlerTypes.addAll(Arrays.asList(targetType.getInterfaces()))___		for (Class<?> currentHandlerType : handlerTypes) {_			final Class<?> targetClass = (specificHandlerType != null ? specificHandlerType : currentHandlerType)___			ReflectionUtils.doWithMethods(currentHandlerType, new ReflectionUtils.MethodCallback() {_				@Override_				public void doWith(Method method) {_					Method specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass)__					T result = metadataLookup.inspect(specificMethod)__					if (result != null) {_						Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(specificMethod)__						if (bridgedMethod == specificMethod || metadataLookup.inspect(bridgedMethod) == null) {_							methodMap.put(specificMethod, result)__						}_					}_				}_			}, ReflectionUtils.USER_DECLARED_METHODS)__		}__		return methodMap__	};select,methods,on,the,given,target,type,based,on,the,lookup,of,associated,metadata,p,callers,define,methods,of,interest,through,the,link,metadata,lookup,parameter,allowing,to,collect,the,associated,metadata,into,the,result,map,param,target,type,the,target,type,to,search,methods,on,param,metadata,lookup,a,link,metadata,lookup,callback,to,inspect,methods,of,interest,returning,non,null,metadata,to,be,associated,with,a,given,method,if,there,is,a,match,or,code,null,for,no,match,return,the,selected,methods,associated,with,their,metadata,in,the,order,of,retrieval,or,an,empty,map,in,case,of,no,match;public,static,t,map,method,t,select,methods,class,target,type,final,metadata,lookup,t,metadata,lookup,final,map,method,t,method,map,new,linked,hash,map,set,class,handler,types,new,linked,hash,set,class,specific,handler,type,null,if,proxy,is,proxy,class,target,type,handler,types,add,target,type,specific,handler,type,target,type,handler,types,add,all,arrays,as,list,target,type,get,interfaces,for,class,current,handler,type,handler,types,final,class,target,class,specific,handler,type,null,specific,handler,type,current,handler,type,reflection,utils,do,with,methods,current,handler,type,new,reflection,utils,method,callback,override,public,void,do,with,method,method,method,specific,method,class,utils,get,most,specific,method,method,target,class,t,result,metadata,lookup,inspect,specific,method,if,result,null,method,bridged,method,bridge,method,resolver,find,bridged,method,specific,method,if,bridged,method,specific,method,metadata,lookup,inspect,bridged,method,null,method,map,put,specific,method,result,reflection,utils,return,method,map
MethodIntrospector -> public static <T> Map<Method, T> selectMethods(Class<?> targetType, final MetadataLookup<T> metadataLookup);1467808333;Select methods on the given target type based on the lookup of associated metadata._<p>Callers define methods of interest through the {@link MetadataLookup} parameter,_allowing to collect the associated metadata into the result map._@param targetType the target type to search methods on_@param metadataLookup a {@link MetadataLookup} callback to inspect methods of interest,_returning non-null metadata to be associated with a given method if there is a match,_or {@code null} for no match_@return the selected methods associated with their metadata (in the order of retrieval),_or an empty map in case of no match;public static <T> Map<Method, T> selectMethods(Class<?> targetType, final MetadataLookup<T> metadataLookup) {_		final Map<Method, T> methodMap = new LinkedHashMap<>()__		Set<Class<?>> handlerTypes = new LinkedHashSet<>()__		Class<?> specificHandlerType = null___		if (!Proxy.isProxyClass(targetType)) {_			handlerTypes.add(targetType)__			specificHandlerType = targetType__		}_		handlerTypes.addAll(Arrays.asList(targetType.getInterfaces()))___		for (Class<?> currentHandlerType : handlerTypes) {_			final Class<?> targetClass = (specificHandlerType != null ? specificHandlerType : currentHandlerType)___			ReflectionUtils.doWithMethods(currentHandlerType, new ReflectionUtils.MethodCallback() {_				@Override_				public void doWith(Method method) {_					Method specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass)__					T result = metadataLookup.inspect(specificMethod)__					if (result != null) {_						Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(specificMethod)__						if (bridgedMethod == specificMethod || metadataLookup.inspect(bridgedMethod) == null) {_							methodMap.put(specificMethod, result)__						}_					}_				}_			}, ReflectionUtils.USER_DECLARED_METHODS)__		}__		return methodMap__	};select,methods,on,the,given,target,type,based,on,the,lookup,of,associated,metadata,p,callers,define,methods,of,interest,through,the,link,metadata,lookup,parameter,allowing,to,collect,the,associated,metadata,into,the,result,map,param,target,type,the,target,type,to,search,methods,on,param,metadata,lookup,a,link,metadata,lookup,callback,to,inspect,methods,of,interest,returning,non,null,metadata,to,be,associated,with,a,given,method,if,there,is,a,match,or,code,null,for,no,match,return,the,selected,methods,associated,with,their,metadata,in,the,order,of,retrieval,or,an,empty,map,in,case,of,no,match;public,static,t,map,method,t,select,methods,class,target,type,final,metadata,lookup,t,metadata,lookup,final,map,method,t,method,map,new,linked,hash,map,set,class,handler,types,new,linked,hash,set,class,specific,handler,type,null,if,proxy,is,proxy,class,target,type,handler,types,add,target,type,specific,handler,type,target,type,handler,types,add,all,arrays,as,list,target,type,get,interfaces,for,class,current,handler,type,handler,types,final,class,target,class,specific,handler,type,null,specific,handler,type,current,handler,type,reflection,utils,do,with,methods,current,handler,type,new,reflection,utils,method,callback,override,public,void,do,with,method,method,method,specific,method,class,utils,get,most,specific,method,method,target,class,t,result,metadata,lookup,inspect,specific,method,if,result,null,method,bridged,method,bridge,method,resolver,find,bridged,method,specific,method,if,bridged,method,specific,method,metadata,lookup,inspect,bridged,method,null,method,map,put,specific,method,result,reflection,utils,return,method,map
MethodIntrospector -> public static <T> Map<Method, T> selectMethods(Class<?> targetType, final MetadataLookup<T> metadataLookup);1496837955;Select methods on the given target type based on the lookup of associated metadata._<p>Callers define methods of interest through the {@link MetadataLookup} parameter,_allowing to collect the associated metadata into the result map._@param targetType the target type to search methods on_@param metadataLookup a {@link MetadataLookup} callback to inspect methods of interest,_returning non-null metadata to be associated with a given method if there is a match,_or {@code null} for no match_@return the selected methods associated with their metadata (in the order of retrieval),_or an empty map in case of no match;public static <T> Map<Method, T> selectMethods(Class<?> targetType, final MetadataLookup<T> metadataLookup) {_		final Map<Method, T> methodMap = new LinkedHashMap<>()__		Set<Class<?>> handlerTypes = new LinkedHashSet<>()__		Class<?> specificHandlerType = null___		if (!Proxy.isProxyClass(targetType)) {_			handlerTypes.add(targetType)__			specificHandlerType = targetType__		}_		handlerTypes.addAll(Arrays.asList(targetType.getInterfaces()))___		for (Class<?> currentHandlerType : handlerTypes) {_			final Class<?> targetClass = (specificHandlerType != null ? specificHandlerType : currentHandlerType)___			ReflectionUtils.doWithMethods(currentHandlerType, method -> {_				Method specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass)__				T result = metadataLookup.inspect(specificMethod)__				if (result != null) {_					Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(specificMethod)__					if (bridgedMethod == specificMethod || metadataLookup.inspect(bridgedMethod) == null) {_						methodMap.put(specificMethod, result)__					}_				}_			}, ReflectionUtils.USER_DECLARED_METHODS)__		}__		return methodMap__	};select,methods,on,the,given,target,type,based,on,the,lookup,of,associated,metadata,p,callers,define,methods,of,interest,through,the,link,metadata,lookup,parameter,allowing,to,collect,the,associated,metadata,into,the,result,map,param,target,type,the,target,type,to,search,methods,on,param,metadata,lookup,a,link,metadata,lookup,callback,to,inspect,methods,of,interest,returning,non,null,metadata,to,be,associated,with,a,given,method,if,there,is,a,match,or,code,null,for,no,match,return,the,selected,methods,associated,with,their,metadata,in,the,order,of,retrieval,or,an,empty,map,in,case,of,no,match;public,static,t,map,method,t,select,methods,class,target,type,final,metadata,lookup,t,metadata,lookup,final,map,method,t,method,map,new,linked,hash,map,set,class,handler,types,new,linked,hash,set,class,specific,handler,type,null,if,proxy,is,proxy,class,target,type,handler,types,add,target,type,specific,handler,type,target,type,handler,types,add,all,arrays,as,list,target,type,get,interfaces,for,class,current,handler,type,handler,types,final,class,target,class,specific,handler,type,null,specific,handler,type,current,handler,type,reflection,utils,do,with,methods,current,handler,type,method,method,specific,method,class,utils,get,most,specific,method,method,target,class,t,result,metadata,lookup,inspect,specific,method,if,result,null,method,bridged,method,bridge,method,resolver,find,bridged,method,specific,method,if,bridged,method,specific,method,metadata,lookup,inspect,bridged,method,null,method,map,put,specific,method,result,reflection,utils,return,method,map
MethodIntrospector -> public static <T> Map<Method, T> selectMethods(Class<?> targetType, final MetadataLookup<T> metadataLookup);1519514499;Select methods on the given target type based on the lookup of associated metadata._<p>Callers define methods of interest through the {@link MetadataLookup} parameter,_allowing to collect the associated metadata into the result map._@param targetType the target type to search methods on_@param metadataLookup a {@link MetadataLookup} callback to inspect methods of interest,_returning non-null metadata to be associated with a given method if there is a match,_or {@code null} for no match_@return the selected methods associated with their metadata (in the order of retrieval),_or an empty map in case of no match;public static <T> Map<Method, T> selectMethods(Class<?> targetType, final MetadataLookup<T> metadataLookup) {_		final Map<Method, T> methodMap = new LinkedHashMap<>()__		Set<Class<?>> handlerTypes = new LinkedHashSet<>()__		Class<?> specificHandlerType = null___		if (!Proxy.isProxyClass(targetType)) {_			handlerTypes.add(targetType)__			specificHandlerType = targetType__		}_		Collections.addAll(handlerTypes, targetType.getInterfaces())___		for (Class<?> currentHandlerType : handlerTypes) {_			final Class<?> targetClass = (specificHandlerType != null ? specificHandlerType : currentHandlerType)___			ReflectionUtils.doWithMethods(currentHandlerType, method -> {_				Method specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass)__				T result = metadataLookup.inspect(specificMethod)__				if (result != null) {_					Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(specificMethod)__					if (bridgedMethod == specificMethod || metadataLookup.inspect(bridgedMethod) == null) {_						methodMap.put(specificMethod, result)__					}_				}_			}, ReflectionUtils.USER_DECLARED_METHODS)__		}__		return methodMap__	};select,methods,on,the,given,target,type,based,on,the,lookup,of,associated,metadata,p,callers,define,methods,of,interest,through,the,link,metadata,lookup,parameter,allowing,to,collect,the,associated,metadata,into,the,result,map,param,target,type,the,target,type,to,search,methods,on,param,metadata,lookup,a,link,metadata,lookup,callback,to,inspect,methods,of,interest,returning,non,null,metadata,to,be,associated,with,a,given,method,if,there,is,a,match,or,code,null,for,no,match,return,the,selected,methods,associated,with,their,metadata,in,the,order,of,retrieval,or,an,empty,map,in,case,of,no,match;public,static,t,map,method,t,select,methods,class,target,type,final,metadata,lookup,t,metadata,lookup,final,map,method,t,method,map,new,linked,hash,map,set,class,handler,types,new,linked,hash,set,class,specific,handler,type,null,if,proxy,is,proxy,class,target,type,handler,types,add,target,type,specific,handler,type,target,type,collections,add,all,handler,types,target,type,get,interfaces,for,class,current,handler,type,handler,types,final,class,target,class,specific,handler,type,null,specific,handler,type,current,handler,type,reflection,utils,do,with,methods,current,handler,type,method,method,specific,method,class,utils,get,most,specific,method,method,target,class,t,result,metadata,lookup,inspect,specific,method,if,result,null,method,bridged,method,bridge,method,resolver,find,bridged,method,specific,method,if,bridged,method,specific,method,metadata,lookup,inspect,bridged,method,null,method,map,put,specific,method,result,reflection,utils,return,method,map
MethodIntrospector -> public static <T> Map<Method, T> selectMethods(Class<?> targetType, final MetadataLookup<T> metadataLookup);1522716161;Select methods on the given target type based on the lookup of associated metadata._<p>Callers define methods of interest through the {@link MetadataLookup} parameter,_allowing to collect the associated metadata into the result map._@param targetType the target type to search methods on_@param metadataLookup a {@link MetadataLookup} callback to inspect methods of interest,_returning non-null metadata to be associated with a given method if there is a match,_or {@code null} for no match_@return the selected methods associated with their metadata (in the order of retrieval),_or an empty map in case of no match;public static <T> Map<Method, T> selectMethods(Class<?> targetType, final MetadataLookup<T> metadataLookup) {_		final Map<Method, T> methodMap = new LinkedHashMap<>()__		Set<Class<?>> handlerTypes = new LinkedHashSet<>()__		Class<?> specificHandlerType = null___		if (!Proxy.isProxyClass(targetType)) {_			specificHandlerType = ClassUtils.getUserClass(targetType)__			handlerTypes.add(specificHandlerType)__		}_		handlerTypes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetType))___		for (Class<?> currentHandlerType : handlerTypes) {_			final Class<?> targetClass = (specificHandlerType != null ? specificHandlerType : currentHandlerType)___			ReflectionUtils.doWithMethods(currentHandlerType, method -> {_				Method specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass)__				T result = metadataLookup.inspect(specificMethod)__				if (result != null) {_					Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(specificMethod)__					if (bridgedMethod == specificMethod || metadataLookup.inspect(bridgedMethod) == null) {_						methodMap.put(specificMethod, result)__					}_				}_			}, ReflectionUtils.USER_DECLARED_METHODS)__		}__		return methodMap__	};select,methods,on,the,given,target,type,based,on,the,lookup,of,associated,metadata,p,callers,define,methods,of,interest,through,the,link,metadata,lookup,parameter,allowing,to,collect,the,associated,metadata,into,the,result,map,param,target,type,the,target,type,to,search,methods,on,param,metadata,lookup,a,link,metadata,lookup,callback,to,inspect,methods,of,interest,returning,non,null,metadata,to,be,associated,with,a,given,method,if,there,is,a,match,or,code,null,for,no,match,return,the,selected,methods,associated,with,their,metadata,in,the,order,of,retrieval,or,an,empty,map,in,case,of,no,match;public,static,t,map,method,t,select,methods,class,target,type,final,metadata,lookup,t,metadata,lookup,final,map,method,t,method,map,new,linked,hash,map,set,class,handler,types,new,linked,hash,set,class,specific,handler,type,null,if,proxy,is,proxy,class,target,type,specific,handler,type,class,utils,get,user,class,target,type,handler,types,add,specific,handler,type,handler,types,add,all,class,utils,get,all,interfaces,for,class,as,set,target,type,for,class,current,handler,type,handler,types,final,class,target,class,specific,handler,type,null,specific,handler,type,current,handler,type,reflection,utils,do,with,methods,current,handler,type,method,method,specific,method,class,utils,get,most,specific,method,method,target,class,t,result,metadata,lookup,inspect,specific,method,if,result,null,method,bridged,method,bridge,method,resolver,find,bridged,method,specific,method,if,bridged,method,specific,method,metadata,lookup,inspect,bridged,method,null,method,map,put,specific,method,result,reflection,utils,return,method,map
MethodIntrospector -> public static <T> Map<Method, T> selectMethods(Class<?> targetType, final MetadataLookup<T> metadataLookup);1530532518;Select methods on the given target type based on the lookup of associated metadata._<p>Callers define methods of interest through the {@link MetadataLookup} parameter,_allowing to collect the associated metadata into the result map._@param targetType the target type to search methods on_@param metadataLookup a {@link MetadataLookup} callback to inspect methods of interest,_returning non-null metadata to be associated with a given method if there is a match,_or {@code null} for no match_@return the selected methods associated with their metadata (in the order of retrieval),_or an empty map in case of no match;public static <T> Map<Method, T> selectMethods(Class<?> targetType, final MetadataLookup<T> metadataLookup) {_		final Map<Method, T> methodMap = new LinkedHashMap<>()__		Set<Class<?>> handlerTypes = new LinkedHashSet<>()__		Class<?> specificHandlerType = null___		if (!Proxy.isProxyClass(targetType)) {_			specificHandlerType = ClassUtils.getUserClass(targetType)__			handlerTypes.add(specificHandlerType)__		}_		handlerTypes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetType))___		for (Class<?> currentHandlerType : handlerTypes) {_			final Class<?> targetClass = (specificHandlerType != null ? specificHandlerType : currentHandlerType)___			ReflectionUtils.doWithMethods(currentHandlerType, method -> {_				Method specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass)__				T result = metadataLookup.inspect(specificMethod)__				if (result != null) {_					Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(specificMethod)__					if (bridgedMethod == specificMethod || metadataLookup.inspect(bridgedMethod) == null) {_						methodMap.put(specificMethod, result)__					}_				}_			}, ReflectionUtils.USER_DECLARED_METHODS)__		}__		return methodMap__	};select,methods,on,the,given,target,type,based,on,the,lookup,of,associated,metadata,p,callers,define,methods,of,interest,through,the,link,metadata,lookup,parameter,allowing,to,collect,the,associated,metadata,into,the,result,map,param,target,type,the,target,type,to,search,methods,on,param,metadata,lookup,a,link,metadata,lookup,callback,to,inspect,methods,of,interest,returning,non,null,metadata,to,be,associated,with,a,given,method,if,there,is,a,match,or,code,null,for,no,match,return,the,selected,methods,associated,with,their,metadata,in,the,order,of,retrieval,or,an,empty,map,in,case,of,no,match;public,static,t,map,method,t,select,methods,class,target,type,final,metadata,lookup,t,metadata,lookup,final,map,method,t,method,map,new,linked,hash,map,set,class,handler,types,new,linked,hash,set,class,specific,handler,type,null,if,proxy,is,proxy,class,target,type,specific,handler,type,class,utils,get,user,class,target,type,handler,types,add,specific,handler,type,handler,types,add,all,class,utils,get,all,interfaces,for,class,as,set,target,type,for,class,current,handler,type,handler,types,final,class,target,class,specific,handler,type,null,specific,handler,type,current,handler,type,reflection,utils,do,with,methods,current,handler,type,method,method,specific,method,class,utils,get,most,specific,method,method,target,class,t,result,metadata,lookup,inspect,specific,method,if,result,null,method,bridged,method,bridge,method,resolver,find,bridged,method,specific,method,if,bridged,method,specific,method,metadata,lookup,inspect,bridged,method,null,method,map,put,specific,method,result,reflection,utils,return,method,map
MethodIntrospector -> public static Set<Method> selectMethods(Class<?> targetType, final ReflectionUtils.MethodFilter methodFilter);1447077465;Select methods on the given target type based on a filter._<p>Callers define methods of interest through the_{@link ReflectionUtils.MethodFilter} parameter._@param targetType the target type to search methods on_@param methodFilter a {@link ReflectionUtils.MethodFilter} to help_recognize handler methods of interest_@return the selected methods, or an empty set in case of no match;public static Set<Method> selectMethods(Class<?> targetType, final ReflectionUtils.MethodFilter methodFilter) {_		return selectMethods(targetType, new MetadataLookup<Boolean>() {_			@Override_			public Boolean inspect(Method method) {_				return (methodFilter.matches(method) ? Boolean.TRUE : null)__			}_		}).keySet()__	};select,methods,on,the,given,target,type,based,on,a,filter,p,callers,define,methods,of,interest,through,the,link,reflection,utils,method,filter,parameter,param,target,type,the,target,type,to,search,methods,on,param,method,filter,a,link,reflection,utils,method,filter,to,help,recognize,handler,methods,of,interest,return,the,selected,methods,or,an,empty,set,in,case,of,no,match;public,static,set,method,select,methods,class,target,type,final,reflection,utils,method,filter,method,filter,return,select,methods,target,type,new,metadata,lookup,boolean,override,public,boolean,inspect,method,method,return,method,filter,matches,method,boolean,true,null,key,set
MethodIntrospector -> public static Set<Method> selectMethods(Class<?> targetType, final ReflectionUtils.MethodFilter methodFilter);1450900048;Select methods on the given target type based on a filter._<p>Callers define methods of interest through the_{@link ReflectionUtils.MethodFilter} parameter._@param targetType the target type to search methods on_@param methodFilter a {@link ReflectionUtils.MethodFilter} to help_recognize handler methods of interest_@return the selected methods, or an empty set in case of no match;public static Set<Method> selectMethods(Class<?> targetType, final ReflectionUtils.MethodFilter methodFilter) {_		return selectMethods(targetType, new MetadataLookup<Boolean>() {_			@Override_			public Boolean inspect(Method method) {_				return (methodFilter.matches(method) ? Boolean.TRUE : null)__			}_		}).keySet()__	};select,methods,on,the,given,target,type,based,on,a,filter,p,callers,define,methods,of,interest,through,the,link,reflection,utils,method,filter,parameter,param,target,type,the,target,type,to,search,methods,on,param,method,filter,a,link,reflection,utils,method,filter,to,help,recognize,handler,methods,of,interest,return,the,selected,methods,or,an,empty,set,in,case,of,no,match;public,static,set,method,select,methods,class,target,type,final,reflection,utils,method,filter,method,filter,return,select,methods,target,type,new,metadata,lookup,boolean,override,public,boolean,inspect,method,method,return,method,filter,matches,method,boolean,true,null,key,set
MethodIntrospector -> public static Set<Method> selectMethods(Class<?> targetType, final ReflectionUtils.MethodFilter methodFilter);1467677340;Select methods on the given target type based on a filter._<p>Callers define methods of interest through the {@code MethodFilter} parameter._@param targetType the target type to search methods on_@param methodFilter a {@code MethodFilter} to help_recognize handler methods of interest_@return the selected methods, or an empty set in case of no match;public static Set<Method> selectMethods(Class<?> targetType, final ReflectionUtils.MethodFilter methodFilter) {_		return selectMethods(targetType, new MetadataLookup<Boolean>() {_			@Override_			public Boolean inspect(Method method) {_				return (methodFilter.matches(method) ? Boolean.TRUE : null)__			}_		}).keySet()__	};select,methods,on,the,given,target,type,based,on,a,filter,p,callers,define,methods,of,interest,through,the,code,method,filter,parameter,param,target,type,the,target,type,to,search,methods,on,param,method,filter,a,code,method,filter,to,help,recognize,handler,methods,of,interest,return,the,selected,methods,or,an,empty,set,in,case,of,no,match;public,static,set,method,select,methods,class,target,type,final,reflection,utils,method,filter,method,filter,return,select,methods,target,type,new,metadata,lookup,boolean,override,public,boolean,inspect,method,method,return,method,filter,matches,method,boolean,true,null,key,set
MethodIntrospector -> public static Set<Method> selectMethods(Class<?> targetType, final ReflectionUtils.MethodFilter methodFilter);1467730834;Select methods on the given target type based on a filter._<p>Callers define methods of interest through the {@code MethodFilter} parameter._@param targetType the target type to search methods on_@param methodFilter a {@code MethodFilter} to help_recognize handler methods of interest_@return the selected methods, or an empty set in case of no match;public static Set<Method> selectMethods(Class<?> targetType, final ReflectionUtils.MethodFilter methodFilter) {_		return selectMethods(targetType, new MetadataLookup<Boolean>() {_			@Override_			public Boolean inspect(Method method) {_				return (methodFilter.matches(method) ? Boolean.TRUE : null)__			}_		}).keySet()__	};select,methods,on,the,given,target,type,based,on,a,filter,p,callers,define,methods,of,interest,through,the,code,method,filter,parameter,param,target,type,the,target,type,to,search,methods,on,param,method,filter,a,code,method,filter,to,help,recognize,handler,methods,of,interest,return,the,selected,methods,or,an,empty,set,in,case,of,no,match;public,static,set,method,select,methods,class,target,type,final,reflection,utils,method,filter,method,filter,return,select,methods,target,type,new,metadata,lookup,boolean,override,public,boolean,inspect,method,method,return,method,filter,matches,method,boolean,true,null,key,set
MethodIntrospector -> public static Set<Method> selectMethods(Class<?> targetType, final ReflectionUtils.MethodFilter methodFilter);1467808333;Select methods on the given target type based on a filter._<p>Callers define methods of interest through the {@code MethodFilter} parameter._@param targetType the target type to search methods on_@param methodFilter a {@code MethodFilter} to help_recognize handler methods of interest_@return the selected methods, or an empty set in case of no match;public static Set<Method> selectMethods(Class<?> targetType, final ReflectionUtils.MethodFilter methodFilter) {_		return selectMethods(targetType, new MetadataLookup<Boolean>() {_			@Override_			public Boolean inspect(Method method) {_				return (methodFilter.matches(method) ? Boolean.TRUE : null)__			}_		}).keySet()__	};select,methods,on,the,given,target,type,based,on,a,filter,p,callers,define,methods,of,interest,through,the,code,method,filter,parameter,param,target,type,the,target,type,to,search,methods,on,param,method,filter,a,code,method,filter,to,help,recognize,handler,methods,of,interest,return,the,selected,methods,or,an,empty,set,in,case,of,no,match;public,static,set,method,select,methods,class,target,type,final,reflection,utils,method,filter,method,filter,return,select,methods,target,type,new,metadata,lookup,boolean,override,public,boolean,inspect,method,method,return,method,filter,matches,method,boolean,true,null,key,set
MethodIntrospector -> public static Set<Method> selectMethods(Class<?> targetType, final ReflectionUtils.MethodFilter methodFilter);1495868221;Select methods on the given target type based on a filter._<p>Callers define methods of interest through the {@code MethodFilter} parameter._@param targetType the target type to search methods on_@param methodFilter a {@code MethodFilter} to help_recognize handler methods of interest_@return the selected methods, or an empty set in case of no match;public static Set<Method> selectMethods(Class<?> targetType, final ReflectionUtils.MethodFilter methodFilter) {_		return selectMethods(targetType, new MetadataLookup<Boolean>() {_			@Override_			public Boolean inspect(Method method) {_				return (methodFilter.matches(method) ? Boolean.TRUE : null)__			}_		}).keySet()__	};select,methods,on,the,given,target,type,based,on,a,filter,p,callers,define,methods,of,interest,through,the,code,method,filter,parameter,param,target,type,the,target,type,to,search,methods,on,param,method,filter,a,code,method,filter,to,help,recognize,handler,methods,of,interest,return,the,selected,methods,or,an,empty,set,in,case,of,no,match;public,static,set,method,select,methods,class,target,type,final,reflection,utils,method,filter,method,filter,return,select,methods,target,type,new,metadata,lookup,boolean,override,public,boolean,inspect,method,method,return,method,filter,matches,method,boolean,true,null,key,set
MethodIntrospector -> public static Set<Method> selectMethods(Class<?> targetType, final ReflectionUtils.MethodFilter methodFilter);1496837955;Select methods on the given target type based on a filter._<p>Callers define methods of interest through the {@code MethodFilter} parameter._@param targetType the target type to search methods on_@param methodFilter a {@code MethodFilter} to help_recognize handler methods of interest_@return the selected methods, or an empty set in case of no match;public static Set<Method> selectMethods(Class<?> targetType, final ReflectionUtils.MethodFilter methodFilter) {_		return selectMethods(targetType,_				(MetadataLookup<Boolean>) method -> (methodFilter.matches(method) ? Boolean.TRUE : null)).keySet()__	};select,methods,on,the,given,target,type,based,on,a,filter,p,callers,define,methods,of,interest,through,the,code,method,filter,parameter,param,target,type,the,target,type,to,search,methods,on,param,method,filter,a,code,method,filter,to,help,recognize,handler,methods,of,interest,return,the,selected,methods,or,an,empty,set,in,case,of,no,match;public,static,set,method,select,methods,class,target,type,final,reflection,utils,method,filter,method,filter,return,select,methods,target,type,metadata,lookup,boolean,method,method,filter,matches,method,boolean,true,null,key,set
MethodIntrospector -> public static Set<Method> selectMethods(Class<?> targetType, final ReflectionUtils.MethodFilter methodFilter);1519514499;Select methods on the given target type based on a filter._<p>Callers define methods of interest through the {@code MethodFilter} parameter._@param targetType the target type to search methods on_@param methodFilter a {@code MethodFilter} to help_recognize handler methods of interest_@return the selected methods, or an empty set in case of no match;public static Set<Method> selectMethods(Class<?> targetType, final ReflectionUtils.MethodFilter methodFilter) {_		return selectMethods(targetType,_				(MetadataLookup<Boolean>) method -> (methodFilter.matches(method) ? Boolean.TRUE : null)).keySet()__	};select,methods,on,the,given,target,type,based,on,a,filter,p,callers,define,methods,of,interest,through,the,code,method,filter,parameter,param,target,type,the,target,type,to,search,methods,on,param,method,filter,a,code,method,filter,to,help,recognize,handler,methods,of,interest,return,the,selected,methods,or,an,empty,set,in,case,of,no,match;public,static,set,method,select,methods,class,target,type,final,reflection,utils,method,filter,method,filter,return,select,methods,target,type,metadata,lookup,boolean,method,method,filter,matches,method,boolean,true,null,key,set
MethodIntrospector -> public static Set<Method> selectMethods(Class<?> targetType, final ReflectionUtils.MethodFilter methodFilter);1522716161;Select methods on the given target type based on a filter._<p>Callers define methods of interest through the {@code MethodFilter} parameter._@param targetType the target type to search methods on_@param methodFilter a {@code MethodFilter} to help_recognize handler methods of interest_@return the selected methods, or an empty set in case of no match;public static Set<Method> selectMethods(Class<?> targetType, final ReflectionUtils.MethodFilter methodFilter) {_		return selectMethods(targetType,_				(MetadataLookup<Boolean>) method -> (methodFilter.matches(method) ? Boolean.TRUE : null)).keySet()__	};select,methods,on,the,given,target,type,based,on,a,filter,p,callers,define,methods,of,interest,through,the,code,method,filter,parameter,param,target,type,the,target,type,to,search,methods,on,param,method,filter,a,code,method,filter,to,help,recognize,handler,methods,of,interest,return,the,selected,methods,or,an,empty,set,in,case,of,no,match;public,static,set,method,select,methods,class,target,type,final,reflection,utils,method,filter,method,filter,return,select,methods,target,type,metadata,lookup,boolean,method,method,filter,matches,method,boolean,true,null,key,set
MethodIntrospector -> public static Set<Method> selectMethods(Class<?> targetType, final ReflectionUtils.MethodFilter methodFilter);1530532518;Select methods on the given target type based on a filter._<p>Callers define methods of interest through the {@code MethodFilter} parameter._@param targetType the target type to search methods on_@param methodFilter a {@code MethodFilter} to help_recognize handler methods of interest_@return the selected methods, or an empty set in case of no match;public static Set<Method> selectMethods(Class<?> targetType, final ReflectionUtils.MethodFilter methodFilter) {_		return selectMethods(targetType,_				(MetadataLookup<Boolean>) method -> (methodFilter.matches(method) ? Boolean.TRUE : null)).keySet()__	};select,methods,on,the,given,target,type,based,on,a,filter,p,callers,define,methods,of,interest,through,the,code,method,filter,parameter,param,target,type,the,target,type,to,search,methods,on,param,method,filter,a,code,method,filter,to,help,recognize,handler,methods,of,interest,return,the,selected,methods,or,an,empty,set,in,case,of,no,match;public,static,set,method,select,methods,class,target,type,final,reflection,utils,method,filter,method,filter,return,select,methods,target,type,metadata,lookup,boolean,method,method,filter,matches,method,boolean,true,null,key,set
