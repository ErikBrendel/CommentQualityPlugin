commented;modifiers;parameterAmount;loc;comment;code
false;public;2;5;;@Override public boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType) {     Class<?> clazz = elementType.toClass().     return super.canEncode(elementType, mimeType) && CharSequence.class.isAssignableFrom(clazz). }
false;public;5;32;;@Override public Flux<DataBuffer> encode(Publisher<? extends CharSequence> inputStream, DataBufferFactory bufferFactory, ResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {     Charset charset = getCharset(mimeType).     return Flux.from(inputStream).map(charSequence -> {         if (!Hints.isLoggingSuppressed(hints)) {             LogFormatUtils.traceDebug(logger, traceOn -> {                 String formatted = LogFormatUtils.formatValue(charSequence, !traceOn).                 return Hints.getLogPrefix(hints) + "Writing " + formatted.             }).         }         boolean release = true.         int capacity = calculateCapacity(charSequence, charset).         DataBuffer dataBuffer = bufferFactory.allocateBuffer(capacity).         try {             dataBuffer.write(charSequence, charset).             release = false.         } catch (CoderMalfunctionError ex) {             throw new EncodingException("String encoding error: " + ex.getMessage(), ex).         } finally {             if (release) {                 DataBufferUtils.release(dataBuffer).             }         }         return dataBuffer.     }). }
false;;2;6;;int calculateCapacity(CharSequence sequence, Charset charset) {     float maxBytesPerChar = this.charsetToMaxBytesPerChar.computeIfAbsent(charset, cs -> cs.newEncoder().maxBytesPerChar()).     float maxBytesForSequence = sequence.length() * maxBytesPerChar.     return (int) Math.ceil(maxBytesForSequence). }
false;private;1;8;;private Charset getCharset(@Nullable MimeType mimeType) {     if (mimeType != null && mimeType.getCharset() != null) {         return mimeType.getCharset().     } else {         return DEFAULT_CHARSET.     } }
true;public,static;0;3;/**  * Create a {@code CharSequenceEncoder} that supports only "text/plain".  */ ;/**  * Create a {@code CharSequenceEncoder} that supports only "text/plain".  */ public static CharSequenceEncoder textPlainOnly() {     return new CharSequenceEncoder(new MimeType("text", "plain", DEFAULT_CHARSET)). }
true;public,static;0;3;/**  * Create a {@code CharSequenceEncoder} that supports all MIME types.  */ ;/**  * Create a {@code CharSequenceEncoder} that supports all MIME types.  */ public static CharSequenceEncoder allMimeTypes() {     return new CharSequenceEncoder(new MimeType("text", "plain", DEFAULT_CHARSET), MimeTypeUtils.ALL). }
