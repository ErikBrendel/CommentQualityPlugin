commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public DefaultDataBuffer allocateBuffer() {     return allocateBuffer(this.defaultInitialCapacity). }
false;public;1;7;;@Override public DefaultDataBuffer allocateBuffer(int initialCapacity) {     ByteBuffer byteBuffer = (this.preferDirect ? ByteBuffer.allocateDirect(initialCapacity) : ByteBuffer.allocate(initialCapacity)).     return DefaultDataBuffer.fromEmptyByteBuffer(this, byteBuffer). }
false;public;1;4;;@Override public DefaultDataBuffer wrap(ByteBuffer byteBuffer) {     return DefaultDataBuffer.fromFilledByteBuffer(this, byteBuffer.slice()). }
false;public;1;4;;@Override public DefaultDataBuffer wrap(byte[] bytes) {     return DefaultDataBuffer.fromFilledByteBuffer(this, ByteBuffer.wrap(bytes)). }
true;public;1;9;/**  * {@inheritDoc}  * <p>This implementation creates a single {@link DefaultDataBuffer}  * to contain the data in {@code dataBuffers}.  */ ;/**  * {@inheritDoc}  * <p>This implementation creates a single {@link DefaultDataBuffer}  * to contain the data in {@code dataBuffers}.  */ @Override public DefaultDataBuffer join(List<? extends DataBuffer> dataBuffers) {     Assert.notEmpty(dataBuffers, "DataBuffer List must not be empty").     int capacity = dataBuffers.stream().mapToInt(DataBuffer::readableByteCount).sum().     DefaultDataBuffer result = allocateBuffer(capacity).     dataBuffers.forEach(result::write).     dataBuffers.forEach(DataBufferUtils::release).     return result. }
false;public;0;4;;@Override public String toString() {     return "DefaultDataBufferFactory (preferDirect=" + this.preferDirect + ")". }
