commented;modifiers;parameterAmount;loc;comment;code
false;public;2;74;;// ----------------------------------------------------------------------------------------------- // Implementation of the AnnotationVisitor abstract class // ----------------------------------------------------------------------------------------------- @Override public void visit(final String name, final Object value) {     // Case of an element_value with a const_value_index, class_info_index or array_index field.     // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.16.1.     ++numElementValuePairs.     if (useNamedValues) {         annotation.putShort(symbolTable.addConstantUtf8(name)).     }     if (value instanceof String) {         annotation.put12('s', symbolTable.addConstantUtf8((String) value)).     } else if (value instanceof Byte) {         annotation.put12('B', symbolTable.addConstantInteger(((Byte) value).byteValue()).index).     } else if (value instanceof Boolean) {         int booleanValue = ((Boolean) value).booleanValue() ? 1 : 0.         annotation.put12('Z', symbolTable.addConstantInteger(booleanValue).index).     } else if (value instanceof Character) {         annotation.put12('C', symbolTable.addConstantInteger(((Character) value).charValue()).index).     } else if (value instanceof Short) {         annotation.put12('S', symbolTable.addConstantInteger(((Short) value).shortValue()).index).     } else if (value instanceof Type) {         annotation.put12('c', symbolTable.addConstantUtf8(((Type) value).getDescriptor())).     } else if (value instanceof byte[]) {         byte[] byteArray = (byte[]) value.         annotation.put12('[', byteArray.length).         for (byte byteValue : byteArray) {             annotation.put12('B', symbolTable.addConstantInteger(byteValue).index).         }     } else if (value instanceof boolean[]) {         boolean[] booleanArray = (boolean[]) value.         annotation.put12('[', booleanArray.length).         for (boolean booleanValue : booleanArray) {             annotation.put12('Z', symbolTable.addConstantInteger(booleanValue ? 1 : 0).index).         }     } else if (value instanceof short[]) {         short[] shortArray = (short[]) value.         annotation.put12('[', shortArray.length).         for (short shortValue : shortArray) {             annotation.put12('S', symbolTable.addConstantInteger(shortValue).index).         }     } else if (value instanceof char[]) {         char[] charArray = (char[]) value.         annotation.put12('[', charArray.length).         for (char charValue : charArray) {             annotation.put12('C', symbolTable.addConstantInteger(charValue).index).         }     } else if (value instanceof int[]) {         int[] intArray = (int[]) value.         annotation.put12('[', intArray.length).         for (int intValue : intArray) {             annotation.put12('I', symbolTable.addConstantInteger(intValue).index).         }     } else if (value instanceof long[]) {         long[] longArray = (long[]) value.         annotation.put12('[', longArray.length).         for (long longValue : longArray) {             annotation.put12('J', symbolTable.addConstantLong(longValue).index).         }     } else if (value instanceof float[]) {         float[] floatArray = (float[]) value.         annotation.put12('[', floatArray.length).         for (float floatValue : floatArray) {             annotation.put12('F', symbolTable.addConstantFloat(floatValue).index).         }     } else if (value instanceof double[]) {         double[] doubleArray = (double[]) value.         annotation.put12('[', doubleArray.length).         for (double doubleValue : doubleArray) {             annotation.put12('D', symbolTable.addConstantDouble(doubleValue).index).         }     } else {         Symbol symbol = symbolTable.addConstant(value).         annotation.put12(".s.IFJDCS".charAt(symbol.tag), symbol.index).     } }
false;public;3;12;;@Override public void visitEnum(final String name, final String descriptor, final String value) {     // Case of an element_value with an enum_const_value field.     // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.16.1.     ++numElementValuePairs.     if (useNamedValues) {         annotation.putShort(symbolTable.addConstantUtf8(name)).     }     annotation.put12('e', symbolTable.addConstantUtf8(descriptor)).putShort(symbolTable.addConstantUtf8(value)). }
false;public;2;12;;@Override public AnnotationVisitor visitAnnotation(final String name, final String descriptor) {     // Case of an element_value with an annotation_value field.     // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.16.1.     ++numElementValuePairs.     if (useNamedValues) {         annotation.putShort(symbolTable.addConstantUtf8(name)).     }     // Write tag and type_index, and reserve 2 bytes for num_element_value_pairs.     annotation.put12('@', symbolTable.addConstantUtf8(descriptor)).putShort(0).     return new AnnotationWriter(symbolTable, annotation, null). }
false;public;1;18;;@Override public AnnotationVisitor visitArray(final String name) {     // Case of an element_value with an array_value field.     // https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.16.1     ++numElementValuePairs.     if (useNamedValues) {         annotation.putShort(symbolTable.addConstantUtf8(name)).     }     // Write tag, and reserve 2 bytes for num_values. Here we take advantage of the fact that the     // end of an element_value of array type is similar to the end of an 'annotation' structure: an     // unsigned short num_values followed by num_values element_value, versus an unsigned short     // num_element_value_pairs, followed by num_element_value_pairs { element_name_index,     // element_value } tuples. This allows us to use an AnnotationWriter with unnamed values to     // visit the array elements. Its num_element_value_pairs will correspond to the number of array     // elements and will be stored in what is in fact num_values.     annotation.put12('[', 0).     return new AnnotationWriter(symbolTable, /* useNamedValues = */     false, annotation, null). }
false;public;0;8;;@Override public void visitEnd() {     if (numElementValuePairsOffset != -1) {         byte[] data = annotation.data.         data[numElementValuePairsOffset] = (byte) (numElementValuePairs >>> 8).         data[numElementValuePairsOffset + 1] = (byte) numElementValuePairs.     } }
true;;1;13;/**  * Returns the size of a Runtime[In]Visible[Type]Annotations attribute containing this annotation  * and all its <i>predecessors</i> (see {@link #previousAnnotation}. Also adds the attribute name  * to the constant pool of the class (if not null).  *  * @param attributeName one of "Runtime[In]Visible[Type]Annotations", or null.  * @return the size in bytes of a Runtime[In]Visible[Type]Annotations attribute containing this  *     annotation and all its predecessors. This includes the size of the attribute_name_index and  *     attribute_length fields.  */ ;// ----------------------------------------------------------------------------------------------- // Utility methods // ----------------------------------------------------------------------------------------------- /**  * Returns the size of a Runtime[In]Visible[Type]Annotations attribute containing this annotation  * and all its <i>predecessors</i> (see {@link #previousAnnotation}. Also adds the attribute name  * to the constant pool of the class (if not null).  *  * @param attributeName one of "Runtime[In]Visible[Type]Annotations", or null.  * @return the size in bytes of a Runtime[In]Visible[Type]Annotations attribute containing this  *     annotation and all its predecessors. This includes the size of the attribute_name_index and  *     attribute_length fields.  */ int computeAnnotationsSize(final String attributeName) {     if (attributeName != null) {         symbolTable.addConstantUtf8(attributeName).     }     // The attribute_name_index, attribute_length and num_annotations fields use 8 bytes.     int attributeSize = 8.     AnnotationWriter annotationWriter = this.     while (annotationWriter != null) {         attributeSize += annotationWriter.annotation.length.         annotationWriter = annotationWriter.previousAnnotation.     }     return attributeSize. }
true;;2;22;/**  * Puts a Runtime[In]Visible[Type]Annotations attribute containing this annotations and all its  * <i>predecessors</i> (see {@link #previousAnnotation} in the given ByteVector. Annotations are  * put in the same order they have been visited.  *  * @param attributeNameIndex the constant pool index of the attribute name (one of  *     "Runtime[In]Visible[Type]Annotations").  * @param output where the attribute must be put.  */ ;/**  * Puts a Runtime[In]Visible[Type]Annotations attribute containing this annotations and all its  * <i>predecessors</i> (see {@link #previousAnnotation} in the given ByteVector. Annotations are  * put in the same order they have been visited.  *  * @param attributeNameIndex the constant pool index of the attribute name (one of  *     "Runtime[In]Visible[Type]Annotations").  * @param output where the attribute must be put.  */ void putAnnotations(final int attributeNameIndex, final ByteVector output) {     // For num_annotations.     int attributeLength = 2.     int numAnnotations = 0.     AnnotationWriter annotationWriter = this.     AnnotationWriter firstAnnotation = null.     while (annotationWriter != null) {         // In case the user forgot to call visitEnd().         annotationWriter.visitEnd().         attributeLength += annotationWriter.annotation.length.         numAnnotations++.         firstAnnotation = annotationWriter.         annotationWriter = annotationWriter.previousAnnotation.     }     output.putShort(attributeNameIndex).     output.putInt(attributeLength).     output.putShort(numAnnotations).     annotationWriter = firstAnnotation.     while (annotationWriter != null) {         output.putByteArray(annotationWriter.annotation.data, 0, annotationWriter.annotation.length).         annotationWriter = annotationWriter.nextAnnotation.     } }
true;static;3;17;/**  * Returns the size of a Runtime[In]VisibleParameterAnnotations attribute containing all the  * annotation lists from the given AnnotationWriter sub-array. Also adds the attribute name to the  * constant pool of the class.  *  * @param attributeName one of "Runtime[In]VisibleParameterAnnotations".  * @param annotationWriters an array of AnnotationWriter lists (designated by their <i>last</i>  *     element).  * @param annotableParameterCount the number of elements in annotationWriters to take into account  *     (elements [0..annotableParameterCount[ are taken into account).  * @return the size in bytes of a Runtime[In]VisibleParameterAnnotations attribute corresponding  *     to the given sub-array of AnnotationWriter lists. This includes the size of the  *     attribute_name_index and attribute_length fields.  */ ;/**  * Returns the size of a Runtime[In]VisibleParameterAnnotations attribute containing all the  * annotation lists from the given AnnotationWriter sub-array. Also adds the attribute name to the  * constant pool of the class.  *  * @param attributeName one of "Runtime[In]VisibleParameterAnnotations".  * @param annotationWriters an array of AnnotationWriter lists (designated by their <i>last</i>  *     element).  * @param annotableParameterCount the number of elements in annotationWriters to take into account  *     (elements [0..annotableParameterCount[ are taken into account).  * @return the size in bytes of a Runtime[In]VisibleParameterAnnotations attribute corresponding  *     to the given sub-array of AnnotationWriter lists. This includes the size of the  *     attribute_name_index and attribute_length fields.  */ static int computeParameterAnnotationsSize(final String attributeName, final AnnotationWriter[] annotationWriters, final int annotableParameterCount) {     // Note: attributeName is added to the constant pool by the call to computeAnnotationsSize     // below. This assumes that there is at least one non-null element in the annotationWriters     // sub-array (which is ensured by the lazy instantiation of this array in MethodWriter).     // The attribute_name_index, attribute_length and num_parameters fields use 7 bytes, and each     // element of the parameter_annotations array uses 2 bytes for its num_annotations field.     int attributeSize = 7 + 2 * annotableParameterCount.     for (int i = 0. i < annotableParameterCount. ++i) {         AnnotationWriter annotationWriter = annotationWriters[i].         attributeSize += annotationWriter == null ? 0 : annotationWriter.computeAnnotationsSize(attributeName) - 8.     }     return attributeSize. }
true;static;4;36;/**  * Puts a Runtime[In]VisibleParameterAnnotations attribute containing all the annotation lists  * from the given AnnotationWriter sub-array in the given ByteVector.  *  * @param attributeNameIndex constant pool index of the attribute name (one of  *     Runtime[In]VisibleParameterAnnotations).  * @param annotationWriters an array of AnnotationWriter lists (designated by their <i>last</i>  *     element).  * @param annotableParameterCount the number of elements in annotationWriters to put (elements  *     [0..annotableParameterCount[ are put).  * @param output where the attribute must be put.  */ ;/**  * Puts a Runtime[In]VisibleParameterAnnotations attribute containing all the annotation lists  * from the given AnnotationWriter sub-array in the given ByteVector.  *  * @param attributeNameIndex constant pool index of the attribute name (one of  *     Runtime[In]VisibleParameterAnnotations).  * @param annotationWriters an array of AnnotationWriter lists (designated by their <i>last</i>  *     element).  * @param annotableParameterCount the number of elements in annotationWriters to put (elements  *     [0..annotableParameterCount[ are put).  * @param output where the attribute must be put.  */ static void putParameterAnnotations(final int attributeNameIndex, final AnnotationWriter[] annotationWriters, final int annotableParameterCount, final ByteVector output) {     // The num_parameters field uses 1 byte, and each element of the parameter_annotations array     // uses 2 bytes for its num_annotations field.     int attributeLength = 1 + 2 * annotableParameterCount.     for (int i = 0. i < annotableParameterCount. ++i) {         AnnotationWriter annotationWriter = annotationWriters[i].         attributeLength += annotationWriter == null ? 0 : annotationWriter.computeAnnotationsSize(null) - 8.     }     output.putShort(attributeNameIndex).     output.putInt(attributeLength).     output.putByte(annotableParameterCount).     for (int i = 0. i < annotableParameterCount. ++i) {         AnnotationWriter annotationWriter = annotationWriters[i].         AnnotationWriter firstAnnotation = null.         int numAnnotations = 0.         while (annotationWriter != null) {             // In case user the forgot to call visitEnd().             annotationWriter.visitEnd().             numAnnotations++.             firstAnnotation = annotationWriter.             annotationWriter = annotationWriter.previousAnnotation.         }         output.putShort(numAnnotations).         annotationWriter = firstAnnotation.         while (annotationWriter != null) {             output.putByteArray(annotationWriter.annotation.data, 0, annotationWriter.annotation.length).             annotationWriter = annotationWriter.nextAnnotation.         }     } }
