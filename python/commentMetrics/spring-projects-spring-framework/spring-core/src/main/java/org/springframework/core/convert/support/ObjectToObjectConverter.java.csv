commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public Set<ConvertiblePair> getConvertibleTypes() {     return Collections.singleton(new ConvertiblePair(Object.class, Object.class)). }
false;public;2;5;;@Override public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {     return (sourceType.getType() != targetType.getType() && hasConversionMethodOrConstructor(targetType.getType(), sourceType.getType())). }
false;public;3;41;;@Override @Nullable public Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {     if (source == null) {         return null.     }     Class<?> sourceClass = sourceType.getType().     Class<?> targetClass = targetType.getType().     Member member = getValidatedMember(targetClass, sourceClass).     try {         if (member instanceof Method) {             Method method = (Method) member.             ReflectionUtils.makeAccessible(method).             if (!Modifier.isStatic(method.getModifiers())) {                 return method.invoke(source).             } else {                 return method.invoke(null, source).             }         } else if (member instanceof Constructor) {             Constructor<?> ctor = (Constructor<?>) member.             ReflectionUtils.makeAccessible(ctor).             return ctor.newInstance(source).         }     } catch (InvocationTargetException ex) {         throw new ConversionFailedException(sourceType, targetType, source, ex.getTargetException()).     } catch (Throwable ex) {         throw new ConversionFailedException(sourceType, targetType, source, ex).     }     // method or Integer(java.lang.Number) constructor exists on java.lang.Integer.     throw new IllegalStateException(String.format("No to%3$s() method exists on %1$s, " + "and no static valueOf/of/from(%1$s) method or %3$s(%1$s) constructor exists on %2$s.", sourceClass.getName(), targetClass.getName(), targetClass.getSimpleName())). }
false;static;2;3;;static boolean hasConversionMethodOrConstructor(Class<?> targetClass, Class<?> sourceClass) {     return (getValidatedMember(targetClass, sourceClass) != null). }
false;private,static;2;21;;@Nullable private static Member getValidatedMember(Class<?> targetClass, Class<?> sourceClass) {     Member member = conversionMemberCache.get(targetClass).     if (isApplicable(member, sourceClass)) {         return member.     }     member = determineToMethod(targetClass, sourceClass).     if (member == null) {         member = determineFactoryMethod(targetClass, sourceClass).         if (member == null) {             member = determineFactoryConstructor(targetClass, sourceClass).             if (member == null) {                 return null.             }         }     }     conversionMemberCache.put(targetClass, member).     return member. }
false;private,static;2;15;;private static boolean isApplicable(Member member, Class<?> sourceClass) {     if (member instanceof Method) {         Method method = (Method) member.         return (!Modifier.isStatic(method.getModifiers()) ? ClassUtils.isAssignable(method.getDeclaringClass(), sourceClass) : method.getParameterTypes()[0] == sourceClass).     } else if (member instanceof Constructor) {         Constructor<?> ctor = (Constructor<?>) member.         return (ctor.getParameterTypes()[0] == sourceClass).     } else {         return false.     } }
false;private,static;2;11;;@Nullable private static Method determineToMethod(Class<?> targetClass, Class<?> sourceClass) {     if (String.class == targetClass || String.class == sourceClass) {         // Do not accept a toString() method or any to methods on String itself         return null.     }     Method method = ClassUtils.getMethodIfAvailable(sourceClass, "to" + targetClass.getSimpleName()).     return (method != null && !Modifier.isStatic(method.getModifiers()) && ClassUtils.isAssignable(targetClass, method.getReturnType()) ? method : null). }
false;private,static;2;16;;@Nullable private static Method determineFactoryMethod(Class<?> targetClass, Class<?> sourceClass) {     if (String.class == targetClass) {         // Do not accept the String.valueOf(Object) method         return null.     }     Method method = ClassUtils.getStaticMethod(targetClass, "valueOf", sourceClass).     if (method == null) {         method = ClassUtils.getStaticMethod(targetClass, "of", sourceClass).         if (method == null) {             method = ClassUtils.getStaticMethod(targetClass, "from", sourceClass).         }     }     return method. }
false;private,static;2;4;;@Nullable private static Constructor<?> determineFactoryConstructor(Class<?> targetClass, Class<?> sourceClass) {     return ClassUtils.getConstructorIfAvailable(targetClass, sourceClass). }
