commented;modifiers;parameterAmount;loc;comment;code
true;public;0;4;/**  * Returns the length of this path, i.e. its number of steps.  *  * @return the length of this path.  */ ;/**  * Returns the length of this path, i.e. its number of steps.  *  * @return the length of this path.  */ public int getLength() {     // path_length is stored in the first byte of a type_path.     return typePathContainer[typePathOffset]. }
true;public;1;4;/**  * Returns the value of the given step of this path.  *  * @param index an index between 0 and {@link #getLength()}, exclusive.  * @return one of {@link #ARRAY_ELEMENT}, {@link #INNER_TYPE}, {@link #WILDCARD_BOUND}, or {@link  *     #TYPE_ARGUMENT}.  */ ;/**  * Returns the value of the given step of this path.  *  * @param index an index between 0 and {@link #getLength()}, exclusive.  * @return one of {@link #ARRAY_ELEMENT}, {@link #INNER_TYPE}, {@link #WILDCARD_BOUND}, or {@link  *     #TYPE_ARGUMENT}.  */ public int getStep(final int index) {     // Returns the type_path_kind of the path element of the given index.     return typePathContainer[typePathOffset + 2 * index + 1]. }
true;public;1;4;/**  * Returns the index of the type argument that the given step is stepping into. This method should  * only be used for steps whose value is {@link #TYPE_ARGUMENT}.  *  * @param index an index between 0 and {@link #getLength()}, exclusive.  * @return the index of the type argument that the given step is stepping into.  */ ;/**  * Returns the index of the type argument that the given step is stepping into. This method should  * only be used for steps whose value is {@link #TYPE_ARGUMENT}.  *  * @param index an index between 0 and {@link #getLength()}, exclusive.  * @return the index of the type argument that the given step is stepping into.  */ public int getStepArgument(final int index) {     // Returns the type_argument_index of the path element of the given index.     return typePathContainer[typePathOffset + 2 * index + 2]. }
true;public,static;1;36;/**  * Converts a type path in string form, in the format used by {@link #toString()}, into a TypePath  * object.  *  * @param typePath a type path in string form, in the format used by {@link #toString()}. May be  *     {@literal null} or empty.  * @return the corresponding TypePath object, or {@literal null} if the path is empty.  */ ;/**  * Converts a type path in string form, in the format used by {@link #toString()}, into a TypePath  * object.  *  * @param typePath a type path in string form, in the format used by {@link #toString()}. May be  *     {@literal null} or empty.  * @return the corresponding TypePath object, or {@literal null} if the path is empty.  */ public static TypePath fromString(final String typePath) {     if (typePath == null || typePath.length() == 0) {         return null.     }     int typePathLength = typePath.length().     ByteVector output = new ByteVector(typePathLength).     output.putByte(0).     int typePathIndex = 0.     while (typePathIndex < typePathLength) {         char c = typePath.charAt(typePathIndex++).         if (c == '[') {             output.put11(ARRAY_ELEMENT, 0).         } else if (c == '.') {             output.put11(INNER_TYPE, 0).         } else if (c == '*') {             output.put11(WILDCARD_BOUND, 0).         } else if (c >= '0' && c <= '9') {             int typeArg = c - '0'.             while (typePathIndex < typePathLength) {                 c = typePath.charAt(typePathIndex++).                 if (c >= '0' && c <= '9') {                     typeArg = typeArg * 10 + c - '0'.                 } else if (c == '.') {                     break.                 } else {                     throw new IllegalArgumentException().                 }             }             output.put11(TYPE_ARGUMENT, typeArg).         } else {             throw new IllegalArgumentException().         }     }     output.data[0] = (byte) (output.length / 2).     return new TypePath(output.data, 0). }
true;public;0;24;/**  * Returns a string representation of this type path. {@link #ARRAY_ELEMENT} steps are represented  * with '[', {@link #INNER_TYPE} steps with '.', {@link #WILDCARD_BOUND} steps with '*' and {@link  * #TYPE_ARGUMENT} steps with their type argument index in decimal form followed by '.'.  */ ;/**  * Returns a string representation of this type path. {@link #ARRAY_ELEMENT} steps are represented  * with '[', {@link #INNER_TYPE} steps with '.', {@link #WILDCARD_BOUND} steps with '*' and {@link  * #TYPE_ARGUMENT} steps with their type argument index in decimal form followed by '.'.  */ @Override public String toString() {     int length = getLength().     StringBuilder result = new StringBuilder(length * 2).     for (int i = 0. i < length. ++i) {         switch(getStep(i)) {             case ARRAY_ELEMENT:                 result.append('[').                 break.             case INNER_TYPE:                 result.append('.').                 break.             case WILDCARD_BOUND:                 result.append('*').                 break.             case TYPE_ARGUMENT:                 result.append(getStepArgument(i)).append('.').                 break.             default:                 throw new AssertionError().         }     }     return result.toString(). }
true;static;2;8;/**  * Puts the type_path JVMS structure corresponding to the given TypePath into the given  * ByteVector.  *  * @param typePath a TypePath instance, or {@literal null} for empty paths.  * @param output where the type path must be put.  */ ;/**  * Puts the type_path JVMS structure corresponding to the given TypePath into the given  * ByteVector.  *  * @param typePath a TypePath instance, or {@literal null} for empty paths.  * @param output where the type path must be put.  */ static void put(final TypePath typePath, final ByteVector output) {     if (typePath == null) {         output.putByte(0).     } else {         int length = typePath.typePathContainer[typePath.typePathOffset] * 2 + 1.         output.putByteArray(typePath.typePathContainer, typePath.typePathOffset, length).     } }
