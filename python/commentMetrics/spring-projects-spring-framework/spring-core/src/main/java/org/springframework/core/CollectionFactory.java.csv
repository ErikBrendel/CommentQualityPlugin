# id;timestamp;commentText;codeText;commentWords;codeWords
CollectionFactory -> public static <E> Collection<E> createCollection(Class<?> collectionClass, int capacity);1417203046;Create the most appropriate collection for the given collection type._<p>Delegates to {@link #createCollection(Class, Class, int)} with a_{@code null} element type._@param collectionClass the desired type of the target Collection_@param capacity the initial capacity_@return the new Collection instance;public static <E> Collection<E> createCollection(Class<?> collectionClass, int capacity) {_		return createCollection(collectionClass, null, capacity)__	};create,the,most,appropriate,collection,for,the,given,collection,type,p,delegates,to,link,create,collection,class,class,int,with,a,code,null,element,type,param,collection,class,the,desired,type,of,the,target,collection,param,capacity,the,initial,capacity,return,the,new,collection,instance;public,static,e,collection,e,create,collection,class,collection,class,int,capacity,return,create,collection,collection,class,null,capacity
CollectionFactory -> public static <E> Collection<E> createCollection(Class<?> collectionClass, int capacity);1417290546;Create the most appropriate collection for the given collection type._<p>Delegates to {@link #createCollection(Class, Class, int)} with a_{@code null} element type._@param collectionClass the desired type of the target Collection_@param capacity the initial capacity_@return the new Collection instance;public static <E> Collection<E> createCollection(Class<?> collectionClass, int capacity) {_		return createCollection(collectionClass, null, capacity)__	};create,the,most,appropriate,collection,for,the,given,collection,type,p,delegates,to,link,create,collection,class,class,int,with,a,code,null,element,type,param,collection,class,the,desired,type,of,the,target,collection,param,capacity,the,initial,capacity,return,the,new,collection,instance;public,static,e,collection,e,create,collection,class,collection,class,int,capacity,return,create,collection,collection,class,null,capacity
CollectionFactory -> public static <E> Collection<E> createCollection(Class<?> collectionClass, int capacity);1418154876;Create the most appropriate collection for the given collection type._<p>Delegates to {@link #createCollection(Class, Class, int)} with a_{@code null} element type._@param collectionClass the desired type of the target Collection_@param capacity the initial capacity_@return the new Collection instance;public static <E> Collection<E> createCollection(Class<?> collectionClass, int capacity) {_		return createCollection(collectionClass, null, capacity)__	};create,the,most,appropriate,collection,for,the,given,collection,type,p,delegates,to,link,create,collection,class,class,int,with,a,code,null,element,type,param,collection,class,the,desired,type,of,the,target,collection,param,capacity,the,initial,capacity,return,the,new,collection,instance;public,static,e,collection,e,create,collection,class,collection,class,int,capacity,return,create,collection,collection,class,null,capacity
CollectionFactory -> public static <E> Collection<E> createCollection(Class<?> collectionClass, int capacity);1418156945;Create the most appropriate collection for the given collection type._<p>Delegates to {@link #createCollection(Class, Class, int)} with a_{@code null} element type._@param collectionClass the desired type of the target Collection_@param capacity the initial capacity_@return the new Collection instance;public static <E> Collection<E> createCollection(Class<?> collectionClass, int capacity) {_		return createCollection(collectionClass, null, capacity)__	};create,the,most,appropriate,collection,for,the,given,collection,type,p,delegates,to,link,create,collection,class,class,int,with,a,code,null,element,type,param,collection,class,the,desired,type,of,the,target,collection,param,capacity,the,initial,capacity,return,the,new,collection,instance;public,static,e,collection,e,create,collection,class,collection,class,int,capacity,return,create,collection,collection,class,null,capacity
CollectionFactory -> public static boolean isApproximableCollectionType(Class<?> collectionType);1328020251;Determine whether the given collection type is an approximable type,_i.e. a type that {@link #createApproximateCollection} can approximate._@param collectionType the collection type to check_@return <code>true</code> if the type is approximable,_<code>false</code> if it is not;public static boolean isApproximableCollectionType(Class<?> collectionType) {_		return (collectionType != null && approximableCollectionTypes.contains(collectionType))__	};determine,whether,the,given,collection,type,is,an,approximable,type,i,e,a,type,that,link,create,approximate,collection,can,approximate,param,collection,type,the,collection,type,to,check,return,code,true,code,if,the,type,is,approximable,code,false,code,if,it,is,not;public,static,boolean,is,approximable,collection,type,class,collection,type,return,collection,type,null,approximable,collection,types,contains,collection,type
CollectionFactory -> public static boolean isApproximableCollectionType(Class<?> collectionType);1346774041;Determine whether the given collection type is an approximable type,_i.e. a type that {@link #createApproximateCollection} can approximate._@param collectionType the collection type to check_@return <code>true</code> if the type is approximable,_<code>false</code> if it is not;public static boolean isApproximableCollectionType(Class<?> collectionType) {_		return (collectionType != null && approximableCollectionTypes.contains(collectionType))__	};determine,whether,the,given,collection,type,is,an,approximable,type,i,e,a,type,that,link,create,approximate,collection,can,approximate,param,collection,type,the,collection,type,to,check,return,code,true,code,if,the,type,is,approximable,code,false,code,if,it,is,not;public,static,boolean,is,approximable,collection,type,class,collection,type,return,collection,type,null,approximable,collection,types,contains,collection,type
CollectionFactory -> public static boolean isApproximableCollectionType(Class<?> collectionType);1346774711;Determine whether the given collection type is an approximable type,_i.e. a type that {@link #createApproximateCollection} can approximate._@param collectionType the collection type to check_@return <code>true</code> if the type is approximable,_<code>false</code> if it is not;public static boolean isApproximableCollectionType(Class<?> collectionType) {_		return (collectionType != null && approximableCollectionTypes.contains(collectionType))__	};determine,whether,the,given,collection,type,is,an,approximable,type,i,e,a,type,that,link,create,approximate,collection,can,approximate,param,collection,type,the,collection,type,to,check,return,code,true,code,if,the,type,is,approximable,code,false,code,if,it,is,not;public,static,boolean,is,approximable,collection,type,class,collection,type,return,collection,type,null,approximable,collection,types,contains,collection,type
CollectionFactory -> public static boolean isApproximableCollectionType(Class<?> collectionType);1349903156;Determine whether the given collection type is an approximable type,_i.e. a type that {@link #createApproximateCollection} can approximate._@param collectionType the collection type to check_@return <code>true</code> if the type is approximable,_<code>false</code> if it is not;public static boolean isApproximableCollectionType(Class<?> collectionType) {_		return (collectionType != null && approximableCollectionTypes.contains(collectionType))__	};determine,whether,the,given,collection,type,is,an,approximable,type,i,e,a,type,that,link,create,approximate,collection,can,approximate,param,collection,type,the,collection,type,to,check,return,code,true,code,if,the,type,is,approximable,code,false,code,if,it,is,not;public,static,boolean,is,approximable,collection,type,class,collection,type,return,collection,type,null,approximable,collection,types,contains,collection,type
CollectionFactory -> public static boolean isApproximableCollectionType(Class<?> collectionType);1355313310;Determine whether the given collection type is an approximable type,_i.e. a type that {@link #createApproximateCollection} can approximate._@param collectionType the collection type to check_@return <code>true</code> if the type is approximable,_<code>false</code> if it is not;public static boolean isApproximableCollectionType(Class<?> collectionType) {_		return (collectionType != null && approximableCollectionTypes.contains(collectionType))__	};determine,whether,the,given,collection,type,is,an,approximable,type,i,e,a,type,that,link,create,approximate,collection,can,approximate,param,collection,type,the,collection,type,to,check,return,code,true,code,if,the,type,is,approximable,code,false,code,if,it,is,not;public,static,boolean,is,approximable,collection,type,class,collection,type,return,collection,type,null,approximable,collection,types,contains,collection,type
CollectionFactory -> public static boolean isApproximableCollectionType(Class<?> collectionType);1356735495;Determine whether the given collection type is an approximable type,_i.e. a type that {@link #createApproximateCollection} can approximate._@param collectionType the collection type to check_@return {@code true} if the type is approximable,_{@code false} if it is not;public static boolean isApproximableCollectionType(Class<?> collectionType) {_		return (collectionType != null && approximableCollectionTypes.contains(collectionType))__	};determine,whether,the,given,collection,type,is,an,approximable,type,i,e,a,type,that,link,create,approximate,collection,can,approximate,param,collection,type,the,collection,type,to,check,return,code,true,if,the,type,is,approximable,code,false,if,it,is,not;public,static,boolean,is,approximable,collection,type,class,collection,type,return,collection,type,null,approximable,collection,types,contains,collection,type
CollectionFactory -> public static boolean isApproximableCollectionType(Class<?> collectionType);1364509637;Determine whether the given collection type is an approximable type,_i.e. a type that {@link #createApproximateCollection} can approximate._@param collectionType the collection type to check_@return {@code true} if the type is approximable,_{@code false} if it is not;public static boolean isApproximableCollectionType(Class<?> collectionType) {_		return (collectionType != null && approximableCollectionTypes.contains(collectionType))__	};determine,whether,the,given,collection,type,is,an,approximable,type,i,e,a,type,that,link,create,approximate,collection,can,approximate,param,collection,type,the,collection,type,to,check,return,code,true,if,the,type,is,approximable,code,false,if,it,is,not;public,static,boolean,is,approximable,collection,type,class,collection,type,return,collection,type,null,approximable,collection,types,contains,collection,type
CollectionFactory -> public static boolean isApproximableCollectionType(Class<?> collectionType);1385412762;Determine whether the given collection type is an approximable type,_i.e. a type that {@link #createApproximateCollection} can approximate._@param collectionType the collection type to check_@return {@code true} if the type is approximable,_{@code false} if it is not;public static boolean isApproximableCollectionType(Class<?> collectionType) {_		return (collectionType != null && approximableCollectionTypes.contains(collectionType))__	};determine,whether,the,given,collection,type,is,an,approximable,type,i,e,a,type,that,link,create,approximate,collection,can,approximate,param,collection,type,the,collection,type,to,check,return,code,true,if,the,type,is,approximable,code,false,if,it,is,not;public,static,boolean,is,approximable,collection,type,class,collection,type,return,collection,type,null,approximable,collection,types,contains,collection,type
CollectionFactory -> public static boolean isApproximableCollectionType(Class<?> collectionType);1388260115;Determine whether the given collection type is an approximable type,_i.e. a type that {@link #createApproximateCollection} can approximate._@param collectionType the collection type to check_@return {@code true} if the type is approximable,_{@code false} if it is not;public static boolean isApproximableCollectionType(Class<?> collectionType) {_		return (collectionType != null && approximableCollectionTypes.contains(collectionType))__	};determine,whether,the,given,collection,type,is,an,approximable,type,i,e,a,type,that,link,create,approximate,collection,can,approximate,param,collection,type,the,collection,type,to,check,return,code,true,if,the,type,is,approximable,code,false,if,it,is,not;public,static,boolean,is,approximable,collection,type,class,collection,type,return,collection,type,null,approximable,collection,types,contains,collection,type
CollectionFactory -> public static boolean isApproximableCollectionType(Class<?> collectionType);1417203046;Determine whether the given collection type is an approximable type,_i.e. a type that {@link #createApproximateCollection} can approximate._@param collectionType the collection type to check_@return {@code true} if the type is approximable,_{@code false} if it is not;public static boolean isApproximableCollectionType(Class<?> collectionType) {_		return (collectionType != null && approximableCollectionTypes.contains(collectionType))__	};determine,whether,the,given,collection,type,is,an,approximable,type,i,e,a,type,that,link,create,approximate,collection,can,approximate,param,collection,type,the,collection,type,to,check,return,code,true,if,the,type,is,approximable,code,false,if,it,is,not;public,static,boolean,is,approximable,collection,type,class,collection,type,return,collection,type,null,approximable,collection,types,contains,collection,type
CollectionFactory -> public static boolean isApproximableCollectionType(Class<?> collectionType);1417290546;Determine whether the given collection type is an approximable type,_i.e. a type that {@link #createApproximateCollection} can approximate._@param collectionType the collection type to check_@return {@code true} if the type is approximable,_{@code false} if it is not;public static boolean isApproximableCollectionType(Class<?> collectionType) {_		return (collectionType != null && approximableCollectionTypes.contains(collectionType))__	};determine,whether,the,given,collection,type,is,an,approximable,type,i,e,a,type,that,link,create,approximate,collection,can,approximate,param,collection,type,the,collection,type,to,check,return,code,true,if,the,type,is,approximable,code,false,if,it,is,not;public,static,boolean,is,approximable,collection,type,class,collection,type,return,collection,type,null,approximable,collection,types,contains,collection,type
CollectionFactory -> public static boolean isApproximableCollectionType(Class<?> collectionType);1418154876;Determine whether the given collection type is an approximable type,_i.e. a type that {@link #createApproximateCollection} can approximate._@param collectionType the collection type to check_@return {@code true} if the type is approximable,_{@code false} if it is not;public static boolean isApproximableCollectionType(Class<?> collectionType) {_		return (collectionType != null && approximableCollectionTypes.contains(collectionType))__	};determine,whether,the,given,collection,type,is,an,approximable,type,i,e,a,type,that,link,create,approximate,collection,can,approximate,param,collection,type,the,collection,type,to,check,return,code,true,if,the,type,is,approximable,code,false,if,it,is,not;public,static,boolean,is,approximable,collection,type,class,collection,type,return,collection,type,null,approximable,collection,types,contains,collection,type
CollectionFactory -> public static boolean isApproximableCollectionType(Class<?> collectionType);1418156945;Determine whether the given collection type is an approximable type,_i.e. a type that {@link #createApproximateCollection} can approximate._@param collectionType the collection type to check_@return {@code true} if the type is approximable,_{@code false} if it is not;public static boolean isApproximableCollectionType(Class<?> collectionType) {_		return (collectionType != null && approximableCollectionTypes.contains(collectionType))__	};determine,whether,the,given,collection,type,is,an,approximable,type,i,e,a,type,that,link,create,approximate,collection,can,approximate,param,collection,type,the,collection,type,to,check,return,code,true,if,the,type,is,approximable,code,false,if,it,is,not;public,static,boolean,is,approximable,collection,type,class,collection,type,return,collection,type,null,approximable,collection,types,contains,collection,type
CollectionFactory -> public static boolean isApproximableCollectionType(Class<?> collectionType);1418219235;Determine whether the given collection type is an approximable type,_i.e. a type that {@link #createApproximateCollection} can approximate._@param collectionType the collection type to check_@return {@code true} if the type is approximable;public static boolean isApproximableCollectionType(Class<?> collectionType) {_		return (collectionType != null && approximableCollectionTypes.contains(collectionType))__	};determine,whether,the,given,collection,type,is,an,approximable,type,i,e,a,type,that,link,create,approximate,collection,can,approximate,param,collection,type,the,collection,type,to,check,return,code,true,if,the,type,is,approximable;public,static,boolean,is,approximable,collection,type,class,collection,type,return,collection,type,null,approximable,collection,types,contains,collection,type
CollectionFactory -> public static boolean isApproximableCollectionType(Class<?> collectionType);1418248740;Determine whether the given collection type is an <em>approximable</em> type,_i.e. a type that {@link #createApproximateCollection} can approximate._@param collectionType the collection type to check_@return {@code true} if the type is <em>approximable</em>;public static boolean isApproximableCollectionType(Class<?> collectionType) {_		return (collectionType != null && approximableCollectionTypes.contains(collectionType))__	};determine,whether,the,given,collection,type,is,an,em,approximable,em,type,i,e,a,type,that,link,create,approximate,collection,can,approximate,param,collection,type,the,collection,type,to,check,return,code,true,if,the,type,is,em,approximable,em;public,static,boolean,is,approximable,collection,type,class,collection,type,return,collection,type,null,approximable,collection,types,contains,collection,type
CollectionFactory -> public static boolean isApproximableCollectionType(Class<?> collectionType);1419862420;Determine whether the given collection type is an <em>approximable</em> type,_i.e. a type that {@link #createApproximateCollection} can approximate._@param collectionType the collection type to check_@return {@code true} if the type is <em>approximable</em>;public static boolean isApproximableCollectionType(Class<?> collectionType) {_		return (collectionType != null && approximableCollectionTypes.contains(collectionType))__	};determine,whether,the,given,collection,type,is,an,em,approximable,em,type,i,e,a,type,that,link,create,approximate,collection,can,approximate,param,collection,type,the,collection,type,to,check,return,code,true,if,the,type,is,em,approximable,em;public,static,boolean,is,approximable,collection,type,class,collection,type,return,collection,type,null,approximable,collection,types,contains,collection,type
CollectionFactory -> public static boolean isApproximableCollectionType(Class<?> collectionType);1420408095;Determine whether the given collection type is an <em>approximable</em> type,_i.e. a type that {@link #createApproximateCollection} can approximate._@param collectionType the collection type to check_@return {@code true} if the type is <em>approximable</em>;public static boolean isApproximableCollectionType(Class<?> collectionType) {_		return (collectionType != null && approximableCollectionTypes.contains(collectionType))__	};determine,whether,the,given,collection,type,is,an,em,approximable,em,type,i,e,a,type,that,link,create,approximate,collection,can,approximate,param,collection,type,the,collection,type,to,check,return,code,true,if,the,type,is,em,approximable,em;public,static,boolean,is,approximable,collection,type,class,collection,type,return,collection,type,null,approximable,collection,types,contains,collection,type
CollectionFactory -> public static boolean isApproximableCollectionType(Class<?> collectionType);1432125256;Determine whether the given collection type is an <em>approximable</em> type,_i.e. a type that {@link #createApproximateCollection} can approximate._@param collectionType the collection type to check_@return {@code true} if the type is <em>approximable</em>;public static boolean isApproximableCollectionType(Class<?> collectionType) {_		return (collectionType != null && approximableCollectionTypes.contains(collectionType))__	};determine,whether,the,given,collection,type,is,an,em,approximable,em,type,i,e,a,type,that,link,create,approximate,collection,can,approximate,param,collection,type,the,collection,type,to,check,return,code,true,if,the,type,is,em,approximable,em;public,static,boolean,is,approximable,collection,type,class,collection,type,return,collection,type,null,approximable,collection,types,contains,collection,type
CollectionFactory -> public static boolean isApproximableCollectionType(Class<?> collectionType);1467730834;Determine whether the given collection type is an <em>approximable</em> type,_i.e. a type that {@link #createApproximateCollection} can approximate._@param collectionType the collection type to check_@return {@code true} if the type is <em>approximable</em>;public static boolean isApproximableCollectionType(Class<?> collectionType) {_		return (collectionType != null && approximableCollectionTypes.contains(collectionType))__	};determine,whether,the,given,collection,type,is,an,em,approximable,em,type,i,e,a,type,that,link,create,approximate,collection,can,approximate,param,collection,type,the,collection,type,to,check,return,code,true,if,the,type,is,em,approximable,em;public,static,boolean,is,approximable,collection,type,class,collection,type,return,collection,type,null,approximable,collection,types,contains,collection,type
CollectionFactory -> public static boolean isApproximableCollectionType(Class<?> collectionType);1468948866;Determine whether the given collection type is an <em>approximable</em> type,_i.e. a type that {@link #createApproximateCollection} can approximate._@param collectionType the collection type to check_@return {@code true} if the type is <em>approximable</em>;public static boolean isApproximableCollectionType(Class<?> collectionType) {_		return (collectionType != null && approximableCollectionTypes.contains(collectionType))__	};determine,whether,the,given,collection,type,is,an,em,approximable,em,type,i,e,a,type,that,link,create,approximate,collection,can,approximate,param,collection,type,the,collection,type,to,check,return,code,true,if,the,type,is,em,approximable,em;public,static,boolean,is,approximable,collection,type,class,collection,type,return,collection,type,null,approximable,collection,types,contains,collection,type
CollectionFactory -> public static boolean isApproximableCollectionType(Class<?> collectionType);1474830340;Determine whether the given collection type is an <em>approximable</em> type,_i.e. a type that {@link #createApproximateCollection} can approximate._@param collectionType the collection type to check_@return {@code true} if the type is <em>approximable</em>;public static boolean isApproximableCollectionType(Class<?> collectionType) {_		return (collectionType != null && approximableCollectionTypes.contains(collectionType))__	};determine,whether,the,given,collection,type,is,an,em,approximable,em,type,i,e,a,type,that,link,create,approximate,collection,can,approximate,param,collection,type,the,collection,type,to,check,return,code,true,if,the,type,is,em,approximable,em;public,static,boolean,is,approximable,collection,type,class,collection,type,return,collection,type,null,approximable,collection,types,contains,collection,type
CollectionFactory -> public static boolean isApproximableCollectionType(Class<?> collectionType);1484252281;Determine whether the given collection type is an <em>approximable</em> type,_i.e. a type that {@link #createApproximateCollection} can approximate._@param collectionType the collection type to check_@return {@code true} if the type is <em>approximable</em>;public static boolean isApproximableCollectionType(Class<?> collectionType) {_		return (collectionType != null && approximableCollectionTypes.contains(collectionType))__	};determine,whether,the,given,collection,type,is,an,em,approximable,em,type,i,e,a,type,that,link,create,approximate,collection,can,approximate,param,collection,type,the,collection,type,to,check,return,code,true,if,the,type,is,em,approximable,em;public,static,boolean,is,approximable,collection,type,class,collection,type,return,collection,type,null,approximable,collection,types,contains,collection,type
CollectionFactory -> public static boolean isApproximableCollectionType(Class<?> collectionType);1495868221;Determine whether the given collection type is an <em>approximable</em> type,_i.e. a type that {@link #createApproximateCollection} can approximate._@param collectionType the collection type to check_@return {@code true} if the type is <em>approximable</em>;public static boolean isApproximableCollectionType(Class<?> collectionType) {_		return (collectionType != null && approximableCollectionTypes.contains(collectionType))__	};determine,whether,the,given,collection,type,is,an,em,approximable,em,type,i,e,a,type,that,link,create,approximate,collection,can,approximate,param,collection,type,the,collection,type,to,check,return,code,true,if,the,type,is,em,approximable,em;public,static,boolean,is,approximable,collection,type,class,collection,type,return,collection,type,null,approximable,collection,types,contains,collection,type
CollectionFactory -> @SuppressWarnings("unchecked") 	public static <E> Collection<E> createCollection(Class<?> collectionType, int initialCapacity);1385412762;Create the most appropriate collection for the given collection type._<p>Creates an ArrayList, TreeSet or linked Set for a List, SortedSet_or Set, respectively._@param collectionType the desired type of the target Collection_@param initialCapacity the initial capacity_@return the new Collection instance_@see java.util.ArrayList_@see java.util.TreeSet_@see java.util.LinkedHashSet;@SuppressWarnings("unchecked")_	public static <E> Collection<E> createCollection(Class<?> collectionType, int initialCapacity) {_		if (collectionType.isInterface()) {_			if (List.class.equals(collectionType)) {_				return new ArrayList<E>(initialCapacity)__			}_			else if (SortedSet.class.equals(collectionType) || collectionType.equals(navigableSetClass)) {_				return new TreeSet<E>()__			}_			else if (Set.class.equals(collectionType) || Collection.class.equals(collectionType)) {_				return new LinkedHashSet<E>(initialCapacity)__			}_			else {_				throw new IllegalArgumentException("Unsupported Collection interface: " + collectionType.getName())__			}_		}_		else {_			if (!Collection.class.isAssignableFrom(collectionType)) {_				throw new IllegalArgumentException("Unsupported Collection type: " + collectionType.getName())__			}_			try {_				return (Collection<E>) collectionType.newInstance()__			}_			catch (Exception ex) {_				throw new IllegalArgumentException("Could not instantiate Collection type: " +_						collectionType.getName(), ex)__			}_		}_	};create,the,most,appropriate,collection,for,the,given,collection,type,p,creates,an,array,list,tree,set,or,linked,set,for,a,list,sorted,set,or,set,respectively,param,collection,type,the,desired,type,of,the,target,collection,param,initial,capacity,the,initial,capacity,return,the,new,collection,instance,see,java,util,array,list,see,java,util,tree,set,see,java,util,linked,hash,set;suppress,warnings,unchecked,public,static,e,collection,e,create,collection,class,collection,type,int,initial,capacity,if,collection,type,is,interface,if,list,class,equals,collection,type,return,new,array,list,e,initial,capacity,else,if,sorted,set,class,equals,collection,type,collection,type,equals,navigable,set,class,return,new,tree,set,e,else,if,set,class,equals,collection,type,collection,class,equals,collection,type,return,new,linked,hash,set,e,initial,capacity,else,throw,new,illegal,argument,exception,unsupported,collection,interface,collection,type,get,name,else,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,unsupported,collection,type,collection,type,get,name,try,return,collection,e,collection,type,new,instance,catch,exception,ex,throw,new,illegal,argument,exception,could,not,instantiate,collection,type,collection,type,get,name,ex
CollectionFactory -> @SuppressWarnings("unchecked") 	public static <E> Collection<E> createCollection(Class<?> collectionType, int initialCapacity);1388260115;Create the most appropriate collection for the given collection type._<p>Creates an ArrayList, TreeSet or linked Set for a List, SortedSet_or Set, respectively._@param collectionType the desired type of the target Collection_@param initialCapacity the initial capacity_@return the new Collection instance_@see java.util.ArrayList_@see java.util.TreeSet_@see java.util.LinkedHashSet;@SuppressWarnings("unchecked")_	public static <E> Collection<E> createCollection(Class<?> collectionType, int initialCapacity) {_		if (collectionType.isInterface()) {_			if (List.class.equals(collectionType)) {_				return new ArrayList<E>(initialCapacity)__			}_			else if (SortedSet.class.equals(collectionType) || NavigableSet.class.equals(collectionType)) {_				return new TreeSet<E>()__			}_			else if (Set.class.equals(collectionType) || Collection.class.equals(collectionType)) {_				return new LinkedHashSet<E>(initialCapacity)__			}_			else {_				throw new IllegalArgumentException("Unsupported Collection interface: " + collectionType.getName())__			}_		}_		else {_			if (!Collection.class.isAssignableFrom(collectionType)) {_				throw new IllegalArgumentException("Unsupported Collection type: " + collectionType.getName())__			}_			try {_				return (Collection<E>) collectionType.newInstance()__			}_			catch (Exception ex) {_				throw new IllegalArgumentException("Could not instantiate Collection type: " +_						collectionType.getName(), ex)__			}_		}_	};create,the,most,appropriate,collection,for,the,given,collection,type,p,creates,an,array,list,tree,set,or,linked,set,for,a,list,sorted,set,or,set,respectively,param,collection,type,the,desired,type,of,the,target,collection,param,initial,capacity,the,initial,capacity,return,the,new,collection,instance,see,java,util,array,list,see,java,util,tree,set,see,java,util,linked,hash,set;suppress,warnings,unchecked,public,static,e,collection,e,create,collection,class,collection,type,int,initial,capacity,if,collection,type,is,interface,if,list,class,equals,collection,type,return,new,array,list,e,initial,capacity,else,if,sorted,set,class,equals,collection,type,navigable,set,class,equals,collection,type,return,new,tree,set,e,else,if,set,class,equals,collection,type,collection,class,equals,collection,type,return,new,linked,hash,set,e,initial,capacity,else,throw,new,illegal,argument,exception,unsupported,collection,interface,collection,type,get,name,else,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,unsupported,collection,type,collection,type,get,name,try,return,collection,e,collection,type,new,instance,catch,exception,ex,throw,new,illegal,argument,exception,could,not,instantiate,collection,type,collection,type,get,name,ex
CollectionFactory -> public static <E> Collection<E> createCollection(Class<?> collectionType, int capacity);1418219235;Create the most appropriate collection for the given collection type._<p>Delegates to {@link #createCollection(Class, Class, int)} with a_{@code null} element type._@param collectionType the desired type of the target Collection_@param capacity the initial capacity_@return the new Collection instance;public static <E> Collection<E> createCollection(Class<?> collectionType, int capacity) {_		return createCollection(collectionType, null, capacity)__	};create,the,most,appropriate,collection,for,the,given,collection,type,p,delegates,to,link,create,collection,class,class,int,with,a,code,null,element,type,param,collection,type,the,desired,type,of,the,target,collection,param,capacity,the,initial,capacity,return,the,new,collection,instance;public,static,e,collection,e,create,collection,class,collection,type,int,capacity,return,create,collection,collection,type,null,capacity
CollectionFactory -> public static <E> Collection<E> createCollection(Class<?> collectionType, int capacity);1418248740;Create the most appropriate collection for the given collection type._<p>Delegates to {@link #createCollection(Class, Class, int)} with a_{@code null} element type._@param collectionType the desired type of the target collection_@param capacity the initial capacity_@return the new collection instance;public static <E> Collection<E> createCollection(Class<?> collectionType, int capacity) {_		return createCollection(collectionType, null, capacity)__	};create,the,most,appropriate,collection,for,the,given,collection,type,p,delegates,to,link,create,collection,class,class,int,with,a,code,null,element,type,param,collection,type,the,desired,type,of,the,target,collection,param,capacity,the,initial,capacity,return,the,new,collection,instance;public,static,e,collection,e,create,collection,class,collection,type,int,capacity,return,create,collection,collection,type,null,capacity
CollectionFactory -> public static <E> Collection<E> createCollection(Class<?> collectionType, int capacity);1419862420;Create the most appropriate collection for the given collection type._<p>Delegates to {@link #createCollection(Class, Class, int)} with a_{@code null} element type._@param collectionType the desired type of the target collection_@param capacity the initial capacity_@return the new collection instance;public static <E> Collection<E> createCollection(Class<?> collectionType, int capacity) {_		return createCollection(collectionType, null, capacity)__	};create,the,most,appropriate,collection,for,the,given,collection,type,p,delegates,to,link,create,collection,class,class,int,with,a,code,null,element,type,param,collection,type,the,desired,type,of,the,target,collection,param,capacity,the,initial,capacity,return,the,new,collection,instance;public,static,e,collection,e,create,collection,class,collection,type,int,capacity,return,create,collection,collection,type,null,capacity
CollectionFactory -> public static <E> Collection<E> createCollection(Class<?> collectionType, int capacity);1420408095;Create the most appropriate collection for the given collection type._<p>Delegates to {@link #createCollection(Class, Class, int)} with a_{@code null} element type._@param collectionType the desired type of the target collection_ never {@code null}_@param capacity the initial capacity_@return a new collection instance_@throws IllegalArgumentException if the supplied {@code collectionType}_is {@code null} or of type {@link EnumSet};public static <E> Collection<E> createCollection(Class<?> collectionType, int capacity) {_		return createCollection(collectionType, null, capacity)__	};create,the,most,appropriate,collection,for,the,given,collection,type,p,delegates,to,link,create,collection,class,class,int,with,a,code,null,element,type,param,collection,type,the,desired,type,of,the,target,collection,never,code,null,param,capacity,the,initial,capacity,return,a,new,collection,instance,throws,illegal,argument,exception,if,the,supplied,code,collection,type,is,code,null,or,of,type,link,enum,set;public,static,e,collection,e,create,collection,class,collection,type,int,capacity,return,create,collection,collection,type,null,capacity
CollectionFactory -> public static <E> Collection<E> createCollection(Class<?> collectionType, int capacity);1432125256;Create the most appropriate collection for the given collection type._<p>Delegates to {@link #createCollection(Class, Class, int)} with a_{@code null} element type._@param collectionType the desired type of the target collection_ never {@code null}_@param capacity the initial capacity_@return a new collection instance_@throws IllegalArgumentException if the supplied {@code collectionType}_is {@code null} or of type {@link EnumSet};public static <E> Collection<E> createCollection(Class<?> collectionType, int capacity) {_		return createCollection(collectionType, null, capacity)__	};create,the,most,appropriate,collection,for,the,given,collection,type,p,delegates,to,link,create,collection,class,class,int,with,a,code,null,element,type,param,collection,type,the,desired,type,of,the,target,collection,never,code,null,param,capacity,the,initial,capacity,return,a,new,collection,instance,throws,illegal,argument,exception,if,the,supplied,code,collection,type,is,code,null,or,of,type,link,enum,set;public,static,e,collection,e,create,collection,class,collection,type,int,capacity,return,create,collection,collection,type,null,capacity
CollectionFactory -> public static <E> Collection<E> createCollection(Class<?> collectionType, int capacity);1467730834;Create the most appropriate collection for the given collection type._<p>Delegates to {@link #createCollection(Class, Class, int)} with a_{@code null} element type._@param collectionType the desired type of the target collection_ never {@code null}_@param capacity the initial capacity_@return a new collection instance_@throws IllegalArgumentException if the supplied {@code collectionType}_is {@code null} or of type {@link EnumSet};public static <E> Collection<E> createCollection(Class<?> collectionType, int capacity) {_		return createCollection(collectionType, null, capacity)__	};create,the,most,appropriate,collection,for,the,given,collection,type,p,delegates,to,link,create,collection,class,class,int,with,a,code,null,element,type,param,collection,type,the,desired,type,of,the,target,collection,never,code,null,param,capacity,the,initial,capacity,return,a,new,collection,instance,throws,illegal,argument,exception,if,the,supplied,code,collection,type,is,code,null,or,of,type,link,enum,set;public,static,e,collection,e,create,collection,class,collection,type,int,capacity,return,create,collection,collection,type,null,capacity
CollectionFactory -> public static <E> Collection<E> createCollection(Class<?> collectionType, int capacity);1468948866;Create the most appropriate collection for the given collection type._<p>Delegates to {@link #createCollection(Class, Class, int)} with a_{@code null} element type._@param collectionType the desired type of the target collection_ never {@code null}_@param capacity the initial capacity_@return a new collection instance_@throws IllegalArgumentException if the supplied {@code collectionType}_is {@code null} or of type {@link EnumSet};public static <E> Collection<E> createCollection(Class<?> collectionType, int capacity) {_		return createCollection(collectionType, null, capacity)__	};create,the,most,appropriate,collection,for,the,given,collection,type,p,delegates,to,link,create,collection,class,class,int,with,a,code,null,element,type,param,collection,type,the,desired,type,of,the,target,collection,never,code,null,param,capacity,the,initial,capacity,return,a,new,collection,instance,throws,illegal,argument,exception,if,the,supplied,code,collection,type,is,code,null,or,of,type,link,enum,set;public,static,e,collection,e,create,collection,class,collection,type,int,capacity,return,create,collection,collection,type,null,capacity
CollectionFactory -> public static <E> Collection<E> createCollection(Class<?> collectionType, int capacity);1474830340;Create the most appropriate collection for the given collection type._<p>Delegates to {@link #createCollection(Class, Class, int)} with a_{@code null} element type._@param collectionType the desired type of the target collection_ never {@code null}_@param capacity the initial capacity_@return a new collection instance_@throws IllegalArgumentException if the supplied {@code collectionType}_is {@code null} or of type {@link EnumSet};public static <E> Collection<E> createCollection(Class<?> collectionType, int capacity) {_		return createCollection(collectionType, null, capacity)__	};create,the,most,appropriate,collection,for,the,given,collection,type,p,delegates,to,link,create,collection,class,class,int,with,a,code,null,element,type,param,collection,type,the,desired,type,of,the,target,collection,never,code,null,param,capacity,the,initial,capacity,return,a,new,collection,instance,throws,illegal,argument,exception,if,the,supplied,code,collection,type,is,code,null,or,of,type,link,enum,set;public,static,e,collection,e,create,collection,class,collection,type,int,capacity,return,create,collection,collection,type,null,capacity
CollectionFactory -> public static <E> Collection<E> createCollection(Class<?> collectionType, int capacity);1484252281;Create the most appropriate collection for the given collection type._<p>Delegates to {@link #createCollection(Class, Class, int)} with a_{@code null} element type._@param collectionType the desired type of the target collection_ never {@code null}_@param capacity the initial capacity_@return a new collection instance_@throws IllegalArgumentException if the supplied {@code collectionType}_is {@code null} or of type {@link EnumSet};public static <E> Collection<E> createCollection(Class<?> collectionType, int capacity) {_		return createCollection(collectionType, null, capacity)__	};create,the,most,appropriate,collection,for,the,given,collection,type,p,delegates,to,link,create,collection,class,class,int,with,a,code,null,element,type,param,collection,type,the,desired,type,of,the,target,collection,never,code,null,param,capacity,the,initial,capacity,return,a,new,collection,instance,throws,illegal,argument,exception,if,the,supplied,code,collection,type,is,code,null,or,of,type,link,enum,set;public,static,e,collection,e,create,collection,class,collection,type,int,capacity,return,create,collection,collection,type,null,capacity
CollectionFactory -> public static <E> Collection<E> createCollection(Class<?> collectionType, int capacity);1495868221;Create the most appropriate collection for the given collection type._<p>Delegates to {@link #createCollection(Class, Class, int)} with a_{@code null} element type._@param collectionType the desired type of the target collection_ never {@code null}_@param capacity the initial capacity_@return a new collection instance_@throws IllegalArgumentException if the supplied {@code collectionType}_is {@code null} or of type {@link EnumSet};public static <E> Collection<E> createCollection(Class<?> collectionType, int capacity) {_		return createCollection(collectionType, null, capacity)__	};create,the,most,appropriate,collection,for,the,given,collection,type,p,delegates,to,link,create,collection,class,class,int,with,a,code,null,element,type,param,collection,type,the,desired,type,of,the,target,collection,never,code,null,param,capacity,the,initial,capacity,return,a,new,collection,instance,throws,illegal,argument,exception,if,the,supplied,code,collection,type,is,code,null,or,of,type,link,enum,set;public,static,e,collection,e,create,collection,class,collection,type,int,capacity,return,create,collection,collection,type,null,capacity
CollectionFactory -> public static <E> Collection<E> createCollection(Class<?> collectionType, int capacity);1496837955;Create the most appropriate collection for the given collection type._<p>Delegates to {@link #createCollection(Class, Class, int)} with a_{@code null} element type._@param collectionType the desired type of the target collection_ never {@code null}_@param capacity the initial capacity_@return a new collection instance_@throws IllegalArgumentException if the supplied {@code collectionType}_is {@code null} or of type {@link EnumSet};public static <E> Collection<E> createCollection(Class<?> collectionType, int capacity) {_		return createCollection(collectionType, null, capacity)__	};create,the,most,appropriate,collection,for,the,given,collection,type,p,delegates,to,link,create,collection,class,class,int,with,a,code,null,element,type,param,collection,type,the,desired,type,of,the,target,collection,never,code,null,param,capacity,the,initial,capacity,return,a,new,collection,instance,throws,illegal,argument,exception,if,the,supplied,code,collection,type,is,code,null,or,of,type,link,enum,set;public,static,e,collection,e,create,collection,class,collection,type,int,capacity,return,create,collection,collection,type,null,capacity
CollectionFactory -> public static <E> Collection<E> createCollection(Class<?> collectionType, int capacity);1530532518;Create the most appropriate collection for the given collection type._<p>Delegates to {@link #createCollection(Class, Class, int)} with a_{@code null} element type._@param collectionType the desired type of the target collection_ never {@code null}_@param capacity the initial capacity_@return a new collection instance_@throws IllegalArgumentException if the supplied {@code collectionType}_is {@code null} or of type {@link EnumSet};public static <E> Collection<E> createCollection(Class<?> collectionType, int capacity) {_		return createCollection(collectionType, null, capacity)__	};create,the,most,appropriate,collection,for,the,given,collection,type,p,delegates,to,link,create,collection,class,class,int,with,a,code,null,element,type,param,collection,type,the,desired,type,of,the,target,collection,never,code,null,param,capacity,the,initial,capacity,return,a,new,collection,instance,throws,illegal,argument,exception,if,the,supplied,code,collection,type,is,code,null,or,of,type,link,enum,set;public,static,e,collection,e,create,collection,class,collection,type,int,capacity,return,create,collection,collection,type,null,capacity
CollectionFactory -> public static <E> Collection<E> createCollection(Class<?> collectionType, int capacity);1545740431;Create the most appropriate collection for the given collection type._<p>Delegates to {@link #createCollection(Class, Class, int)} with a_{@code null} element type._@param collectionType the desired type of the target collection_ never {@code null}_@param capacity the initial capacity_@return a new collection instance_@throws IllegalArgumentException if the supplied {@code collectionType}_is {@code null} or of type {@link EnumSet};public static <E> Collection<E> createCollection(Class<?> collectionType, int capacity) {_		return createCollection(collectionType, null, capacity)__	};create,the,most,appropriate,collection,for,the,given,collection,type,p,delegates,to,link,create,collection,class,class,int,with,a,code,null,element,type,param,collection,type,the,desired,type,of,the,target,collection,never,code,null,param,capacity,the,initial,capacity,return,a,new,collection,instance,throws,illegal,argument,exception,if,the,supplied,code,collection,type,is,code,null,or,of,type,link,enum,set;public,static,e,collection,e,create,collection,class,collection,type,int,capacity,return,create,collection,collection,type,null,capacity
CollectionFactory -> public static <E> Collection<E> createCollection(Class<?> collectionType, int capacity);1549321822;Create the most appropriate collection for the given collection type._<p>Delegates to {@link #createCollection(Class, Class, int)} with a_{@code null} element type._@param collectionType the desired type of the target collection (never {@code null})_@param capacity the initial capacity_@return a new collection instance_@throws IllegalArgumentException if the supplied {@code collectionType}_is {@code null} or of type {@link EnumSet};public static <E> Collection<E> createCollection(Class<?> collectionType, int capacity) {_		return createCollection(collectionType, null, capacity)__	};create,the,most,appropriate,collection,for,the,given,collection,type,p,delegates,to,link,create,collection,class,class,int,with,a,code,null,element,type,param,collection,type,the,desired,type,of,the,target,collection,never,code,null,param,capacity,the,initial,capacity,return,a,new,collection,instance,throws,illegal,argument,exception,if,the,supplied,code,collection,type,is,code,null,or,of,type,link,enum,set;public,static,e,collection,e,create,collection,class,collection,type,int,capacity,return,create,collection,collection,type,null,capacity
CollectionFactory -> @SuppressWarnings("rawtypes") 	private static Class<? extends Enum> asEnumType(Class<?> enumType);1418219235;Cast the given type to a subtype of {@link Enum}._@param enumType the enum type, never {@code null}_@return the given type as subtype of {@link Enum}_@throws IllegalArgumentException if the given type is not a subtype of {@link Enum};@SuppressWarnings("rawtypes")_	private static Class<? extends Enum> asEnumType(Class<?> enumType) {_		Assert.notNull(enumType, "Enum type must not be null")__		if (!Enum.class.isAssignableFrom(enumType)) {_			throw new IllegalArgumentException(String.format("The supplied type '%s' is not an enum.", enumType.getName()))__		}_		return enumType.asSubclass(Enum.class)__	};cast,the,given,type,to,a,subtype,of,link,enum,param,enum,type,the,enum,type,never,code,null,return,the,given,type,as,subtype,of,link,enum,throws,illegal,argument,exception,if,the,given,type,is,not,a,subtype,of,link,enum;suppress,warnings,rawtypes,private,static,class,extends,enum,as,enum,type,class,enum,type,assert,not,null,enum,type,enum,type,must,not,be,null,if,enum,class,is,assignable,from,enum,type,throw,new,illegal,argument,exception,string,format,the,supplied,type,s,is,not,an,enum,enum,type,get,name,return,enum,type,as,subclass,enum,class
CollectionFactory -> @SuppressWarnings("rawtypes") 	private static Class<? extends Enum> asEnumType(Class<?> enumType);1418248740;Cast the given type to a subtype of {@link Enum}._@param enumType the enum type, never {@code null}_@return the given type as subtype of {@link Enum}_@throws IllegalArgumentException if the given type is not a subtype of {@link Enum}_@since 4.1.4;@SuppressWarnings("rawtypes")_	private static Class<? extends Enum> asEnumType(Class<?> enumType) {_		Assert.notNull(enumType, "Enum type must not be null")__		if (!Enum.class.isAssignableFrom(enumType)) {_			throw new IllegalArgumentException(String.format("The supplied type '%s' is not an enum.", enumType.getName()))__		}_		return enumType.asSubclass(Enum.class)__	};cast,the,given,type,to,a,subtype,of,link,enum,param,enum,type,the,enum,type,never,code,null,return,the,given,type,as,subtype,of,link,enum,throws,illegal,argument,exception,if,the,given,type,is,not,a,subtype,of,link,enum,since,4,1,4;suppress,warnings,rawtypes,private,static,class,extends,enum,as,enum,type,class,enum,type,assert,not,null,enum,type,enum,type,must,not,be,null,if,enum,class,is,assignable,from,enum,type,throw,new,illegal,argument,exception,string,format,the,supplied,type,s,is,not,an,enum,enum,type,get,name,return,enum,type,as,subclass,enum,class
CollectionFactory -> @SuppressWarnings("rawtypes") 	private static Class<? extends Enum> asEnumType(Class<?> enumType);1419862420;Cast the given type to a subtype of {@link Enum}._@param enumType the enum type, never {@code null}_@return the given type as subtype of {@link Enum}_@throws IllegalArgumentException if the given type is not a subtype of {@link Enum};@SuppressWarnings("rawtypes")_	private static Class<? extends Enum> asEnumType(Class<?> enumType) {_		Assert.notNull(enumType, "Enum type must not be null")__		if (!Enum.class.isAssignableFrom(enumType)) {_			throw new IllegalArgumentException("Supplied type is not an enum: " + enumType.getName())__		}_		return enumType.asSubclass(Enum.class)__	};cast,the,given,type,to,a,subtype,of,link,enum,param,enum,type,the,enum,type,never,code,null,return,the,given,type,as,subtype,of,link,enum,throws,illegal,argument,exception,if,the,given,type,is,not,a,subtype,of,link,enum;suppress,warnings,rawtypes,private,static,class,extends,enum,as,enum,type,class,enum,type,assert,not,null,enum,type,enum,type,must,not,be,null,if,enum,class,is,assignable,from,enum,type,throw,new,illegal,argument,exception,supplied,type,is,not,an,enum,enum,type,get,name,return,enum,type,as,subclass,enum,class
CollectionFactory -> @SuppressWarnings("rawtypes") 	private static Class<? extends Enum> asEnumType(Class<?> enumType);1420408095;Cast the given type to a subtype of {@link Enum}._@param enumType the enum type, never {@code null}_@return the given type as subtype of {@link Enum}_@throws IllegalArgumentException if the given type is not a subtype of {@link Enum};@SuppressWarnings("rawtypes")_	private static Class<? extends Enum> asEnumType(Class<?> enumType) {_		Assert.notNull(enumType, "Enum type must not be null")__		if (!Enum.class.isAssignableFrom(enumType)) {_			throw new IllegalArgumentException("Supplied type is not an enum: " + enumType.getName())__		}_		return enumType.asSubclass(Enum.class)__	};cast,the,given,type,to,a,subtype,of,link,enum,param,enum,type,the,enum,type,never,code,null,return,the,given,type,as,subtype,of,link,enum,throws,illegal,argument,exception,if,the,given,type,is,not,a,subtype,of,link,enum;suppress,warnings,rawtypes,private,static,class,extends,enum,as,enum,type,class,enum,type,assert,not,null,enum,type,enum,type,must,not,be,null,if,enum,class,is,assignable,from,enum,type,throw,new,illegal,argument,exception,supplied,type,is,not,an,enum,enum,type,get,name,return,enum,type,as,subclass,enum,class
CollectionFactory -> @SuppressWarnings("rawtypes") 	private static Class<? extends Enum> asEnumType(Class<?> enumType);1432125256;Cast the given type to a subtype of {@link Enum}._@param enumType the enum type, never {@code null}_@return the given type as subtype of {@link Enum}_@throws IllegalArgumentException if the given type is not a subtype of {@link Enum};@SuppressWarnings("rawtypes")_	private static Class<? extends Enum> asEnumType(Class<?> enumType) {_		Assert.notNull(enumType, "Enum type must not be null")__		if (!Enum.class.isAssignableFrom(enumType)) {_			throw new IllegalArgumentException("Supplied type is not an enum: " + enumType.getName())__		}_		return enumType.asSubclass(Enum.class)__	};cast,the,given,type,to,a,subtype,of,link,enum,param,enum,type,the,enum,type,never,code,null,return,the,given,type,as,subtype,of,link,enum,throws,illegal,argument,exception,if,the,given,type,is,not,a,subtype,of,link,enum;suppress,warnings,rawtypes,private,static,class,extends,enum,as,enum,type,class,enum,type,assert,not,null,enum,type,enum,type,must,not,be,null,if,enum,class,is,assignable,from,enum,type,throw,new,illegal,argument,exception,supplied,type,is,not,an,enum,enum,type,get,name,return,enum,type,as,subclass,enum,class
CollectionFactory -> @SuppressWarnings("rawtypes") 	private static Class<? extends Enum> asEnumType(Class<?> enumType);1467730834;Cast the given type to a subtype of {@link Enum}._@param enumType the enum type, never {@code null}_@return the given type as subtype of {@link Enum}_@throws IllegalArgumentException if the given type is not a subtype of {@link Enum};@SuppressWarnings("rawtypes")_	private static Class<? extends Enum> asEnumType(Class<?> enumType) {_		Assert.notNull(enumType, "Enum type must not be null")__		if (!Enum.class.isAssignableFrom(enumType)) {_			throw new IllegalArgumentException("Supplied type is not an enum: " + enumType.getName())__		}_		return enumType.asSubclass(Enum.class)__	};cast,the,given,type,to,a,subtype,of,link,enum,param,enum,type,the,enum,type,never,code,null,return,the,given,type,as,subtype,of,link,enum,throws,illegal,argument,exception,if,the,given,type,is,not,a,subtype,of,link,enum;suppress,warnings,rawtypes,private,static,class,extends,enum,as,enum,type,class,enum,type,assert,not,null,enum,type,enum,type,must,not,be,null,if,enum,class,is,assignable,from,enum,type,throw,new,illegal,argument,exception,supplied,type,is,not,an,enum,enum,type,get,name,return,enum,type,as,subclass,enum,class
CollectionFactory -> @SuppressWarnings("rawtypes") 	private static Class<? extends Enum> asEnumType(Class<?> enumType);1468948866;Cast the given type to a subtype of {@link Enum}._@param enumType the enum type, never {@code null}_@return the given type as subtype of {@link Enum}_@throws IllegalArgumentException if the given type is not a subtype of {@link Enum};@SuppressWarnings("rawtypes")_	private static Class<? extends Enum> asEnumType(Class<?> enumType) {_		Assert.notNull(enumType, "Enum type must not be null")__		if (!Enum.class.isAssignableFrom(enumType)) {_			throw new IllegalArgumentException("Supplied type is not an enum: " + enumType.getName())__		}_		return enumType.asSubclass(Enum.class)__	};cast,the,given,type,to,a,subtype,of,link,enum,param,enum,type,the,enum,type,never,code,null,return,the,given,type,as,subtype,of,link,enum,throws,illegal,argument,exception,if,the,given,type,is,not,a,subtype,of,link,enum;suppress,warnings,rawtypes,private,static,class,extends,enum,as,enum,type,class,enum,type,assert,not,null,enum,type,enum,type,must,not,be,null,if,enum,class,is,assignable,from,enum,type,throw,new,illegal,argument,exception,supplied,type,is,not,an,enum,enum,type,get,name,return,enum,type,as,subclass,enum,class
CollectionFactory -> @SuppressWarnings("rawtypes") 	private static Class<? extends Enum> asEnumType(Class<?> enumType);1474830340;Cast the given type to a subtype of {@link Enum}._@param enumType the enum type, never {@code null}_@return the given type as subtype of {@link Enum}_@throws IllegalArgumentException if the given type is not a subtype of {@link Enum};@SuppressWarnings("rawtypes")_	private static Class<? extends Enum> asEnumType(Class<?> enumType) {_		Assert.notNull(enumType, "Enum type must not be null")__		if (!Enum.class.isAssignableFrom(enumType)) {_			throw new IllegalArgumentException("Supplied type is not an enum: " + enumType.getName())__		}_		return enumType.asSubclass(Enum.class)__	};cast,the,given,type,to,a,subtype,of,link,enum,param,enum,type,the,enum,type,never,code,null,return,the,given,type,as,subtype,of,link,enum,throws,illegal,argument,exception,if,the,given,type,is,not,a,subtype,of,link,enum;suppress,warnings,rawtypes,private,static,class,extends,enum,as,enum,type,class,enum,type,assert,not,null,enum,type,enum,type,must,not,be,null,if,enum,class,is,assignable,from,enum,type,throw,new,illegal,argument,exception,supplied,type,is,not,an,enum,enum,type,get,name,return,enum,type,as,subclass,enum,class
CollectionFactory -> @SuppressWarnings("rawtypes") 	private static Class<? extends Enum> asEnumType(Class<?> enumType);1484252281;Cast the given type to a subtype of {@link Enum}._@param enumType the enum type, never {@code null}_@return the given type as subtype of {@link Enum}_@throws IllegalArgumentException if the given type is not a subtype of {@link Enum};@SuppressWarnings("rawtypes")_	private static Class<? extends Enum> asEnumType(Class<?> enumType) {_		Assert.notNull(enumType, "Enum type must not be null")__		if (!Enum.class.isAssignableFrom(enumType)) {_			throw new IllegalArgumentException("Supplied type is not an enum: " + enumType.getName())__		}_		return enumType.asSubclass(Enum.class)__	};cast,the,given,type,to,a,subtype,of,link,enum,param,enum,type,the,enum,type,never,code,null,return,the,given,type,as,subtype,of,link,enum,throws,illegal,argument,exception,if,the,given,type,is,not,a,subtype,of,link,enum;suppress,warnings,rawtypes,private,static,class,extends,enum,as,enum,type,class,enum,type,assert,not,null,enum,type,enum,type,must,not,be,null,if,enum,class,is,assignable,from,enum,type,throw,new,illegal,argument,exception,supplied,type,is,not,an,enum,enum,type,get,name,return,enum,type,as,subclass,enum,class
CollectionFactory -> @SuppressWarnings("rawtypes") 	private static Class<? extends Enum> asEnumType(Class<?> enumType);1495868221;Cast the given type to a subtype of {@link Enum}._@param enumType the enum type, never {@code null}_@return the given type as subtype of {@link Enum}_@throws IllegalArgumentException if the given type is not a subtype of {@link Enum};@SuppressWarnings("rawtypes")_	private static Class<? extends Enum> asEnumType(Class<?> enumType) {_		Assert.notNull(enumType, "Enum type must not be null")__		if (!Enum.class.isAssignableFrom(enumType)) {_			throw new IllegalArgumentException("Supplied type is not an enum: " + enumType.getName())__		}_		return enumType.asSubclass(Enum.class)__	};cast,the,given,type,to,a,subtype,of,link,enum,param,enum,type,the,enum,type,never,code,null,return,the,given,type,as,subtype,of,link,enum,throws,illegal,argument,exception,if,the,given,type,is,not,a,subtype,of,link,enum;suppress,warnings,rawtypes,private,static,class,extends,enum,as,enum,type,class,enum,type,assert,not,null,enum,type,enum,type,must,not,be,null,if,enum,class,is,assignable,from,enum,type,throw,new,illegal,argument,exception,supplied,type,is,not,an,enum,enum,type,get,name,return,enum,type,as,subclass,enum,class
CollectionFactory -> @SuppressWarnings("rawtypes") 	private static Class<? extends Enum> asEnumType(Class<?> enumType);1496837955;Cast the given type to a subtype of {@link Enum}._@param enumType the enum type, never {@code null}_@return the given type as subtype of {@link Enum}_@throws IllegalArgumentException if the given type is not a subtype of {@link Enum};@SuppressWarnings("rawtypes")_	private static Class<? extends Enum> asEnumType(Class<?> enumType) {_		Assert.notNull(enumType, "Enum type must not be null")__		if (!Enum.class.isAssignableFrom(enumType)) {_			throw new IllegalArgumentException("Supplied type is not an enum: " + enumType.getName())__		}_		return enumType.asSubclass(Enum.class)__	};cast,the,given,type,to,a,subtype,of,link,enum,param,enum,type,the,enum,type,never,code,null,return,the,given,type,as,subtype,of,link,enum,throws,illegal,argument,exception,if,the,given,type,is,not,a,subtype,of,link,enum;suppress,warnings,rawtypes,private,static,class,extends,enum,as,enum,type,class,enum,type,assert,not,null,enum,type,enum,type,must,not,be,null,if,enum,class,is,assignable,from,enum,type,throw,new,illegal,argument,exception,supplied,type,is,not,an,enum,enum,type,get,name,return,enum,type,as,subclass,enum,class
CollectionFactory -> @SuppressWarnings("rawtypes") 	private static Class<? extends Enum> asEnumType(Class<?> enumType);1530532518;Cast the given type to a subtype of {@link Enum}._@param enumType the enum type, never {@code null}_@return the given type as subtype of {@link Enum}_@throws IllegalArgumentException if the given type is not a subtype of {@link Enum};@SuppressWarnings("rawtypes")_	private static Class<? extends Enum> asEnumType(Class<?> enumType) {_		Assert.notNull(enumType, "Enum type must not be null")__		if (!Enum.class.isAssignableFrom(enumType)) {_			throw new IllegalArgumentException("Supplied type is not an enum: " + enumType.getName())__		}_		return enumType.asSubclass(Enum.class)__	};cast,the,given,type,to,a,subtype,of,link,enum,param,enum,type,the,enum,type,never,code,null,return,the,given,type,as,subtype,of,link,enum,throws,illegal,argument,exception,if,the,given,type,is,not,a,subtype,of,link,enum;suppress,warnings,rawtypes,private,static,class,extends,enum,as,enum,type,class,enum,type,assert,not,null,enum,type,enum,type,must,not,be,null,if,enum,class,is,assignable,from,enum,type,throw,new,illegal,argument,exception,supplied,type,is,not,an,enum,enum,type,get,name,return,enum,type,as,subclass,enum,class
CollectionFactory -> @SuppressWarnings("rawtypes") 	private static Class<? extends Enum> asEnumType(Class<?> enumType);1545740431;Cast the given type to a subtype of {@link Enum}._@param enumType the enum type, never {@code null}_@return the given type as subtype of {@link Enum}_@throws IllegalArgumentException if the given type is not a subtype of {@link Enum};@SuppressWarnings("rawtypes")_	private static Class<? extends Enum> asEnumType(Class<?> enumType) {_		Assert.notNull(enumType, "Enum type must not be null")__		if (!Enum.class.isAssignableFrom(enumType)) {_			throw new IllegalArgumentException("Supplied type is not an enum: " + enumType.getName())__		}_		return enumType.asSubclass(Enum.class)__	};cast,the,given,type,to,a,subtype,of,link,enum,param,enum,type,the,enum,type,never,code,null,return,the,given,type,as,subtype,of,link,enum,throws,illegal,argument,exception,if,the,given,type,is,not,a,subtype,of,link,enum;suppress,warnings,rawtypes,private,static,class,extends,enum,as,enum,type,class,enum,type,assert,not,null,enum,type,enum,type,must,not,be,null,if,enum,class,is,assignable,from,enum,type,throw,new,illegal,argument,exception,supplied,type,is,not,an,enum,enum,type,get,name,return,enum,type,as,subclass,enum,class
CollectionFactory -> @SuppressWarnings("rawtypes") 	private static Class<? extends Enum> asEnumType(Class<?> enumType);1549321822;Cast the given type to a subtype of {@link Enum}._@param enumType the enum type, never {@code null}_@return the given type as subtype of {@link Enum}_@throws IllegalArgumentException if the given type is not a subtype of {@link Enum};@SuppressWarnings("rawtypes")_	private static Class<? extends Enum> asEnumType(Class<?> enumType) {_		Assert.notNull(enumType, "Enum type must not be null")__		if (!Enum.class.isAssignableFrom(enumType)) {_			throw new IllegalArgumentException("Supplied type is not an enum: " + enumType.getName())__		}_		return enumType.asSubclass(Enum.class)__	};cast,the,given,type,to,a,subtype,of,link,enum,param,enum,type,the,enum,type,never,code,null,return,the,given,type,as,subtype,of,link,enum,throws,illegal,argument,exception,if,the,given,type,is,not,a,subtype,of,link,enum;suppress,warnings,rawtypes,private,static,class,extends,enum,as,enum,type,class,enum,type,assert,not,null,enum,type,enum,type,must,not,be,null,if,enum,class,is,assignable,from,enum,type,throw,new,illegal,argument,exception,supplied,type,is,not,an,enum,enum,type,get,name,return,enum,type,as,subclass,enum,class
CollectionFactory -> public static boolean isApproximableMapType(Class<?> mapType);1328020251;Determine whether the given map type is an approximable type,_i.e. a type that {@link #createApproximateMap} can approximate._@param mapType the map type to check_@return <code>true</code> if the type is approximable,_<code>false</code> if it is not;public static boolean isApproximableMapType(Class<?> mapType) {_		return (mapType != null && approximableMapTypes.contains(mapType))__	};determine,whether,the,given,map,type,is,an,approximable,type,i,e,a,type,that,link,create,approximate,map,can,approximate,param,map,type,the,map,type,to,check,return,code,true,code,if,the,type,is,approximable,code,false,code,if,it,is,not;public,static,boolean,is,approximable,map,type,class,map,type,return,map,type,null,approximable,map,types,contains,map,type
CollectionFactory -> public static boolean isApproximableMapType(Class<?> mapType);1346774041;Determine whether the given map type is an approximable type,_i.e. a type that {@link #createApproximateMap} can approximate._@param mapType the map type to check_@return <code>true</code> if the type is approximable,_<code>false</code> if it is not;public static boolean isApproximableMapType(Class<?> mapType) {_		return (mapType != null && approximableMapTypes.contains(mapType))__	};determine,whether,the,given,map,type,is,an,approximable,type,i,e,a,type,that,link,create,approximate,map,can,approximate,param,map,type,the,map,type,to,check,return,code,true,code,if,the,type,is,approximable,code,false,code,if,it,is,not;public,static,boolean,is,approximable,map,type,class,map,type,return,map,type,null,approximable,map,types,contains,map,type
CollectionFactory -> public static boolean isApproximableMapType(Class<?> mapType);1346774711;Determine whether the given map type is an approximable type,_i.e. a type that {@link #createApproximateMap} can approximate._@param mapType the map type to check_@return <code>true</code> if the type is approximable,_<code>false</code> if it is not;public static boolean isApproximableMapType(Class<?> mapType) {_		return (mapType != null && approximableMapTypes.contains(mapType))__	};determine,whether,the,given,map,type,is,an,approximable,type,i,e,a,type,that,link,create,approximate,map,can,approximate,param,map,type,the,map,type,to,check,return,code,true,code,if,the,type,is,approximable,code,false,code,if,it,is,not;public,static,boolean,is,approximable,map,type,class,map,type,return,map,type,null,approximable,map,types,contains,map,type
CollectionFactory -> public static boolean isApproximableMapType(Class<?> mapType);1349903156;Determine whether the given map type is an approximable type,_i.e. a type that {@link #createApproximateMap} can approximate._@param mapType the map type to check_@return <code>true</code> if the type is approximable,_<code>false</code> if it is not;public static boolean isApproximableMapType(Class<?> mapType) {_		return (mapType != null && approximableMapTypes.contains(mapType))__	};determine,whether,the,given,map,type,is,an,approximable,type,i,e,a,type,that,link,create,approximate,map,can,approximate,param,map,type,the,map,type,to,check,return,code,true,code,if,the,type,is,approximable,code,false,code,if,it,is,not;public,static,boolean,is,approximable,map,type,class,map,type,return,map,type,null,approximable,map,types,contains,map,type
CollectionFactory -> public static boolean isApproximableMapType(Class<?> mapType);1355313310;Determine whether the given map type is an approximable type,_i.e. a type that {@link #createApproximateMap} can approximate._@param mapType the map type to check_@return <code>true</code> if the type is approximable,_<code>false</code> if it is not;public static boolean isApproximableMapType(Class<?> mapType) {_		return (mapType != null && approximableMapTypes.contains(mapType))__	};determine,whether,the,given,map,type,is,an,approximable,type,i,e,a,type,that,link,create,approximate,map,can,approximate,param,map,type,the,map,type,to,check,return,code,true,code,if,the,type,is,approximable,code,false,code,if,it,is,not;public,static,boolean,is,approximable,map,type,class,map,type,return,map,type,null,approximable,map,types,contains,map,type
CollectionFactory -> public static boolean isApproximableMapType(Class<?> mapType);1356735495;Determine whether the given map type is an approximable type,_i.e. a type that {@link #createApproximateMap} can approximate._@param mapType the map type to check_@return {@code true} if the type is approximable,_{@code false} if it is not;public static boolean isApproximableMapType(Class<?> mapType) {_		return (mapType != null && approximableMapTypes.contains(mapType))__	};determine,whether,the,given,map,type,is,an,approximable,type,i,e,a,type,that,link,create,approximate,map,can,approximate,param,map,type,the,map,type,to,check,return,code,true,if,the,type,is,approximable,code,false,if,it,is,not;public,static,boolean,is,approximable,map,type,class,map,type,return,map,type,null,approximable,map,types,contains,map,type
CollectionFactory -> public static boolean isApproximableMapType(Class<?> mapType);1364509637;Determine whether the given map type is an approximable type,_i.e. a type that {@link #createApproximateMap} can approximate._@param mapType the map type to check_@return {@code true} if the type is approximable,_{@code false} if it is not;public static boolean isApproximableMapType(Class<?> mapType) {_		return (mapType != null && approximableMapTypes.contains(mapType))__	};determine,whether,the,given,map,type,is,an,approximable,type,i,e,a,type,that,link,create,approximate,map,can,approximate,param,map,type,the,map,type,to,check,return,code,true,if,the,type,is,approximable,code,false,if,it,is,not;public,static,boolean,is,approximable,map,type,class,map,type,return,map,type,null,approximable,map,types,contains,map,type
CollectionFactory -> public static boolean isApproximableMapType(Class<?> mapType);1385412762;Determine whether the given map type is an approximable type,_i.e. a type that {@link #createApproximateMap} can approximate._@param mapType the map type to check_@return {@code true} if the type is approximable,_{@code false} if it is not;public static boolean isApproximableMapType(Class<?> mapType) {_		return (mapType != null && approximableMapTypes.contains(mapType))__	};determine,whether,the,given,map,type,is,an,approximable,type,i,e,a,type,that,link,create,approximate,map,can,approximate,param,map,type,the,map,type,to,check,return,code,true,if,the,type,is,approximable,code,false,if,it,is,not;public,static,boolean,is,approximable,map,type,class,map,type,return,map,type,null,approximable,map,types,contains,map,type
CollectionFactory -> public static boolean isApproximableMapType(Class<?> mapType);1388260115;Determine whether the given map type is an approximable type,_i.e. a type that {@link #createApproximateMap} can approximate._@param mapType the map type to check_@return {@code true} if the type is approximable,_{@code false} if it is not;public static boolean isApproximableMapType(Class<?> mapType) {_		return (mapType != null && approximableMapTypes.contains(mapType))__	};determine,whether,the,given,map,type,is,an,approximable,type,i,e,a,type,that,link,create,approximate,map,can,approximate,param,map,type,the,map,type,to,check,return,code,true,if,the,type,is,approximable,code,false,if,it,is,not;public,static,boolean,is,approximable,map,type,class,map,type,return,map,type,null,approximable,map,types,contains,map,type
CollectionFactory -> public static boolean isApproximableMapType(Class<?> mapType);1417203046;Determine whether the given map type is an approximable type,_i.e. a type that {@link #createApproximateMap} can approximate._@param mapType the map type to check_@return {@code true} if the type is approximable,_{@code false} if it is not;public static boolean isApproximableMapType(Class<?> mapType) {_		return (mapType != null && approximableMapTypes.contains(mapType))__	};determine,whether,the,given,map,type,is,an,approximable,type,i,e,a,type,that,link,create,approximate,map,can,approximate,param,map,type,the,map,type,to,check,return,code,true,if,the,type,is,approximable,code,false,if,it,is,not;public,static,boolean,is,approximable,map,type,class,map,type,return,map,type,null,approximable,map,types,contains,map,type
CollectionFactory -> public static boolean isApproximableMapType(Class<?> mapType);1417290546;Determine whether the given map type is an approximable type,_i.e. a type that {@link #createApproximateMap} can approximate._@param mapType the map type to check_@return {@code true} if the type is approximable,_{@code false} if it is not;public static boolean isApproximableMapType(Class<?> mapType) {_		return (mapType != null && approximableMapTypes.contains(mapType))__	};determine,whether,the,given,map,type,is,an,approximable,type,i,e,a,type,that,link,create,approximate,map,can,approximate,param,map,type,the,map,type,to,check,return,code,true,if,the,type,is,approximable,code,false,if,it,is,not;public,static,boolean,is,approximable,map,type,class,map,type,return,map,type,null,approximable,map,types,contains,map,type
CollectionFactory -> public static boolean isApproximableMapType(Class<?> mapType);1418154876;Determine whether the given map type is an approximable type,_i.e. a type that {@link #createApproximateMap} can approximate._@param mapType the map type to check_@return {@code true} if the type is approximable,_{@code false} if it is not;public static boolean isApproximableMapType(Class<?> mapType) {_		return (mapType != null && approximableMapTypes.contains(mapType))__	};determine,whether,the,given,map,type,is,an,approximable,type,i,e,a,type,that,link,create,approximate,map,can,approximate,param,map,type,the,map,type,to,check,return,code,true,if,the,type,is,approximable,code,false,if,it,is,not;public,static,boolean,is,approximable,map,type,class,map,type,return,map,type,null,approximable,map,types,contains,map,type
CollectionFactory -> public static boolean isApproximableMapType(Class<?> mapType);1418156945;Determine whether the given map type is an approximable type,_i.e. a type that {@link #createApproximateMap} can approximate._@param mapType the map type to check_@return {@code true} if the type is approximable,_{@code false} if it is not;public static boolean isApproximableMapType(Class<?> mapType) {_		return (mapType != null && approximableMapTypes.contains(mapType))__	};determine,whether,the,given,map,type,is,an,approximable,type,i,e,a,type,that,link,create,approximate,map,can,approximate,param,map,type,the,map,type,to,check,return,code,true,if,the,type,is,approximable,code,false,if,it,is,not;public,static,boolean,is,approximable,map,type,class,map,type,return,map,type,null,approximable,map,types,contains,map,type
CollectionFactory -> public static boolean isApproximableMapType(Class<?> mapType);1418219235;Determine whether the given map type is an approximable type,_i.e. a type that {@link #createApproximateMap} can approximate._@param mapType the map type to check_@return {@code true} if the type is approximable,_{@code false} if it is not;public static boolean isApproximableMapType(Class<?> mapType) {_		return (mapType != null && approximableMapTypes.contains(mapType))__	};determine,whether,the,given,map,type,is,an,approximable,type,i,e,a,type,that,link,create,approximate,map,can,approximate,param,map,type,the,map,type,to,check,return,code,true,if,the,type,is,approximable,code,false,if,it,is,not;public,static,boolean,is,approximable,map,type,class,map,type,return,map,type,null,approximable,map,types,contains,map,type
CollectionFactory -> public static boolean isApproximableMapType(Class<?> mapType);1418248740;Determine whether the given map type is an <em>approximable</em> type,_i.e. a type that {@link #createApproximateMap} can approximate._@param mapType the map type to check_@return {@code true} if the type is <em>approximable</em>;public static boolean isApproximableMapType(Class<?> mapType) {_		return (mapType != null && approximableMapTypes.contains(mapType))__	};determine,whether,the,given,map,type,is,an,em,approximable,em,type,i,e,a,type,that,link,create,approximate,map,can,approximate,param,map,type,the,map,type,to,check,return,code,true,if,the,type,is,em,approximable,em;public,static,boolean,is,approximable,map,type,class,map,type,return,map,type,null,approximable,map,types,contains,map,type
CollectionFactory -> public static boolean isApproximableMapType(Class<?> mapType);1419862420;Determine whether the given map type is an <em>approximable</em> type,_i.e. a type that {@link #createApproximateMap} can approximate._@param mapType the map type to check_@return {@code true} if the type is <em>approximable</em>;public static boolean isApproximableMapType(Class<?> mapType) {_		return (mapType != null && approximableMapTypes.contains(mapType))__	};determine,whether,the,given,map,type,is,an,em,approximable,em,type,i,e,a,type,that,link,create,approximate,map,can,approximate,param,map,type,the,map,type,to,check,return,code,true,if,the,type,is,em,approximable,em;public,static,boolean,is,approximable,map,type,class,map,type,return,map,type,null,approximable,map,types,contains,map,type
CollectionFactory -> public static boolean isApproximableMapType(Class<?> mapType);1420408095;Determine whether the given map type is an <em>approximable</em> type,_i.e. a type that {@link #createApproximateMap} can approximate._@param mapType the map type to check_@return {@code true} if the type is <em>approximable</em>;public static boolean isApproximableMapType(Class<?> mapType) {_		return (mapType != null && approximableMapTypes.contains(mapType))__	};determine,whether,the,given,map,type,is,an,em,approximable,em,type,i,e,a,type,that,link,create,approximate,map,can,approximate,param,map,type,the,map,type,to,check,return,code,true,if,the,type,is,em,approximable,em;public,static,boolean,is,approximable,map,type,class,map,type,return,map,type,null,approximable,map,types,contains,map,type
CollectionFactory -> public static boolean isApproximableMapType(Class<?> mapType);1432125256;Determine whether the given map type is an <em>approximable</em> type,_i.e. a type that {@link #createApproximateMap} can approximate._@param mapType the map type to check_@return {@code true} if the type is <em>approximable</em>;public static boolean isApproximableMapType(Class<?> mapType) {_		return (mapType != null && approximableMapTypes.contains(mapType))__	};determine,whether,the,given,map,type,is,an,em,approximable,em,type,i,e,a,type,that,link,create,approximate,map,can,approximate,param,map,type,the,map,type,to,check,return,code,true,if,the,type,is,em,approximable,em;public,static,boolean,is,approximable,map,type,class,map,type,return,map,type,null,approximable,map,types,contains,map,type
CollectionFactory -> public static boolean isApproximableMapType(Class<?> mapType);1467730834;Determine whether the given map type is an <em>approximable</em> type,_i.e. a type that {@link #createApproximateMap} can approximate._@param mapType the map type to check_@return {@code true} if the type is <em>approximable</em>;public static boolean isApproximableMapType(Class<?> mapType) {_		return (mapType != null && approximableMapTypes.contains(mapType))__	};determine,whether,the,given,map,type,is,an,em,approximable,em,type,i,e,a,type,that,link,create,approximate,map,can,approximate,param,map,type,the,map,type,to,check,return,code,true,if,the,type,is,em,approximable,em;public,static,boolean,is,approximable,map,type,class,map,type,return,map,type,null,approximable,map,types,contains,map,type
CollectionFactory -> public static boolean isApproximableMapType(Class<?> mapType);1468948866;Determine whether the given map type is an <em>approximable</em> type,_i.e. a type that {@link #createApproximateMap} can approximate._@param mapType the map type to check_@return {@code true} if the type is <em>approximable</em>;public static boolean isApproximableMapType(Class<?> mapType) {_		return (mapType != null && approximableMapTypes.contains(mapType))__	};determine,whether,the,given,map,type,is,an,em,approximable,em,type,i,e,a,type,that,link,create,approximate,map,can,approximate,param,map,type,the,map,type,to,check,return,code,true,if,the,type,is,em,approximable,em;public,static,boolean,is,approximable,map,type,class,map,type,return,map,type,null,approximable,map,types,contains,map,type
CollectionFactory -> public static boolean isApproximableMapType(Class<?> mapType);1474830340;Determine whether the given map type is an <em>approximable</em> type,_i.e. a type that {@link #createApproximateMap} can approximate._@param mapType the map type to check_@return {@code true} if the type is <em>approximable</em>;public static boolean isApproximableMapType(Class<?> mapType) {_		return (mapType != null && approximableMapTypes.contains(mapType))__	};determine,whether,the,given,map,type,is,an,em,approximable,em,type,i,e,a,type,that,link,create,approximate,map,can,approximate,param,map,type,the,map,type,to,check,return,code,true,if,the,type,is,em,approximable,em;public,static,boolean,is,approximable,map,type,class,map,type,return,map,type,null,approximable,map,types,contains,map,type
CollectionFactory -> public static boolean isApproximableMapType(Class<?> mapType);1484252281;Determine whether the given map type is an <em>approximable</em> type,_i.e. a type that {@link #createApproximateMap} can approximate._@param mapType the map type to check_@return {@code true} if the type is <em>approximable</em>;public static boolean isApproximableMapType(Class<?> mapType) {_		return (mapType != null && approximableMapTypes.contains(mapType))__	};determine,whether,the,given,map,type,is,an,em,approximable,em,type,i,e,a,type,that,link,create,approximate,map,can,approximate,param,map,type,the,map,type,to,check,return,code,true,if,the,type,is,em,approximable,em;public,static,boolean,is,approximable,map,type,class,map,type,return,map,type,null,approximable,map,types,contains,map,type
CollectionFactory -> public static boolean isApproximableMapType(Class<?> mapType);1495868221;Determine whether the given map type is an <em>approximable</em> type,_i.e. a type that {@link #createApproximateMap} can approximate._@param mapType the map type to check_@return {@code true} if the type is <em>approximable</em>;public static boolean isApproximableMapType(Class<?> mapType) {_		return (mapType != null && approximableMapTypes.contains(mapType))__	};determine,whether,the,given,map,type,is,an,em,approximable,em,type,i,e,a,type,that,link,create,approximate,map,can,approximate,param,map,type,the,map,type,to,check,return,code,true,if,the,type,is,em,approximable,em;public,static,boolean,is,approximable,map,type,class,map,type,return,map,type,null,approximable,map,types,contains,map,type
CollectionFactory -> @SuppressWarnings({"unchecked", "rawtypes"}) 	public static <K, V> Map<K, V> createApproximateMap(Object map, int capacity);1417203046;Create the most approximate map for the given map._@param map the original Map object_@param capacity the initial capacity_@return the new Map instance_@see java.util.TreeMap_@see java.util.LinkedHashMap;@SuppressWarnings({"unchecked", "rawtypes"})_	public static <K, V> Map<K, V> createApproximateMap(Object map, int capacity) {_		if (map instanceof EnumMap) {_			return new EnumMap((Map) map)__		}_		else if (map instanceof SortedMap) {_			return new TreeMap<K, V>(((SortedMap<K, V>) map).comparator())__		}_		else {_			return new LinkedHashMap<K, V>(capacity)__		}_	};create,the,most,approximate,map,for,the,given,map,param,map,the,original,map,object,param,capacity,the,initial,capacity,return,the,new,map,instance,see,java,util,tree,map,see,java,util,linked,hash,map;suppress,warnings,unchecked,rawtypes,public,static,k,v,map,k,v,create,approximate,map,object,map,int,capacity,if,map,instanceof,enum,map,return,new,enum,map,map,map,else,if,map,instanceof,sorted,map,return,new,tree,map,k,v,sorted,map,k,v,map,comparator,else,return,new,linked,hash,map,k,v,capacity
CollectionFactory -> @SuppressWarnings({"unchecked", "rawtypes"}) 	public static <K, V> Map<K, V> createApproximateMap(Object map, int capacity);1417290546;Create the most approximate map for the given map._@param map the original Map object_@param capacity the initial capacity_@return the new Map instance_@see java.util.TreeMap_@see java.util.LinkedHashMap;@SuppressWarnings({"unchecked", "rawtypes"})_	public static <K, V> Map<K, V> createApproximateMap(Object map, int capacity) {_		if (map instanceof EnumMap) {_			return new EnumMap((Map) map)__		}_		else if (map instanceof SortedMap) {_			return new TreeMap<K, V>(((SortedMap<K, V>) map).comparator())__		}_		else {_			return new LinkedHashMap<K, V>(capacity)__		}_	};create,the,most,approximate,map,for,the,given,map,param,map,the,original,map,object,param,capacity,the,initial,capacity,return,the,new,map,instance,see,java,util,tree,map,see,java,util,linked,hash,map;suppress,warnings,unchecked,rawtypes,public,static,k,v,map,k,v,create,approximate,map,object,map,int,capacity,if,map,instanceof,enum,map,return,new,enum,map,map,map,else,if,map,instanceof,sorted,map,return,new,tree,map,k,v,sorted,map,k,v,map,comparator,else,return,new,linked,hash,map,k,v,capacity
CollectionFactory -> @SuppressWarnings({"unchecked", "rawtypes"}) 	public static <K, V> Map<K, V> createApproximateMap(Object map, int capacity);1418154876;Create the most approximate map for the given map._@param map the original Map object_@param capacity the initial capacity_@return the new Map instance_@see java.util.TreeMap_@see java.util.LinkedHashMap;@SuppressWarnings({"unchecked", "rawtypes"})_	public static <K, V> Map<K, V> createApproximateMap(Object map, int capacity) {_		if (map instanceof EnumMap) {_			return new EnumMap((Map) map)__		}_		else if (map instanceof SortedMap) {_			return new TreeMap<K, V>(((SortedMap<K, V>) map).comparator())__		}_		else {_			return new LinkedHashMap<K, V>(capacity)__		}_	};create,the,most,approximate,map,for,the,given,map,param,map,the,original,map,object,param,capacity,the,initial,capacity,return,the,new,map,instance,see,java,util,tree,map,see,java,util,linked,hash,map;suppress,warnings,unchecked,rawtypes,public,static,k,v,map,k,v,create,approximate,map,object,map,int,capacity,if,map,instanceof,enum,map,return,new,enum,map,map,map,else,if,map,instanceof,sorted,map,return,new,tree,map,k,v,sorted,map,k,v,map,comparator,else,return,new,linked,hash,map,k,v,capacity
CollectionFactory -> @SuppressWarnings({"unchecked", "rawtypes"}) 	public static <K, V> Map<K, V> createApproximateMap(Object map, int capacity);1418156945;Create the most approximate map for the given map._@param map the original Map object_@param capacity the initial capacity_@return the new Map instance_@see java.util.TreeMap_@see java.util.LinkedHashMap;@SuppressWarnings({"unchecked", "rawtypes"})_	public static <K, V> Map<K, V> createApproximateMap(Object map, int capacity) {_		if (map instanceof EnumMap) {_			return new EnumMap((Map) map)__		}_		else if (map instanceof SortedMap) {_			return new TreeMap<K, V>(((SortedMap<K, V>) map).comparator())__		}_		else {_			return new LinkedHashMap<K, V>(capacity)__		}_	};create,the,most,approximate,map,for,the,given,map,param,map,the,original,map,object,param,capacity,the,initial,capacity,return,the,new,map,instance,see,java,util,tree,map,see,java,util,linked,hash,map;suppress,warnings,unchecked,rawtypes,public,static,k,v,map,k,v,create,approximate,map,object,map,int,capacity,if,map,instanceof,enum,map,return,new,enum,map,map,map,else,if,map,instanceof,sorted,map,return,new,tree,map,k,v,sorted,map,k,v,map,comparator,else,return,new,linked,hash,map,k,v,capacity
CollectionFactory -> @SuppressWarnings({"unchecked", "rawtypes"}) 	public static <K, V> Map<K, V> createApproximateMap(Object map, int capacity);1418219235;Create the most approximate map for the given map._@param map the original Map object_@param capacity the initial capacity_@return the new Map instance_@see java.util.TreeMap_@see java.util.LinkedHashMap;@SuppressWarnings({"unchecked", "rawtypes"})_	public static <K, V> Map<K, V> createApproximateMap(Object map, int capacity) {_		if (map instanceof EnumMap) {_			return new EnumMap((Map) map)__		}_		else if (map instanceof SortedMap) {_			return new TreeMap<K, V>(((SortedMap<K, V>) map).comparator())__		}_		else {_			return new LinkedHashMap<K, V>(capacity)__		}_	};create,the,most,approximate,map,for,the,given,map,param,map,the,original,map,object,param,capacity,the,initial,capacity,return,the,new,map,instance,see,java,util,tree,map,see,java,util,linked,hash,map;suppress,warnings,unchecked,rawtypes,public,static,k,v,map,k,v,create,approximate,map,object,map,int,capacity,if,map,instanceof,enum,map,return,new,enum,map,map,map,else,if,map,instanceof,sorted,map,return,new,tree,map,k,v,sorted,map,k,v,map,comparator,else,return,new,linked,hash,map,k,v,capacity
CollectionFactory -> @SuppressWarnings({"unchecked", "rawtypes"}) 	public static <K, V> Map<K, V> createApproximateMap(Object map, int capacity);1418248740;Create the most approximate map for the given map._@param map the original Map object_@param capacity the initial capacity_@return the new, empty Map instance_@see #isApproximableMapType_@see java.util.EnumMap_@see java.util.TreeMap_@see java.util.LinkedHashMap;@SuppressWarnings({"unchecked", "rawtypes"})_	public static <K, V> Map<K, V> createApproximateMap(Object map, int capacity) {_		if (map instanceof EnumMap) {_			EnumMap enumMap = new EnumMap((EnumMap) map)__			enumMap.clear()__			return enumMap__		}_		else if (map instanceof SortedMap) {_			return new TreeMap<K, V>(((SortedMap<K, V>) map).comparator())__		}_		else {_			return new LinkedHashMap<K, V>(capacity)__		}_	};create,the,most,approximate,map,for,the,given,map,param,map,the,original,map,object,param,capacity,the,initial,capacity,return,the,new,empty,map,instance,see,is,approximable,map,type,see,java,util,enum,map,see,java,util,tree,map,see,java,util,linked,hash,map;suppress,warnings,unchecked,rawtypes,public,static,k,v,map,k,v,create,approximate,map,object,map,int,capacity,if,map,instanceof,enum,map,enum,map,enum,map,new,enum,map,enum,map,map,enum,map,clear,return,enum,map,else,if,map,instanceof,sorted,map,return,new,tree,map,k,v,sorted,map,k,v,map,comparator,else,return,new,linked,hash,map,k,v,capacity
CollectionFactory -> @SuppressWarnings({"unchecked", "rawtypes"}) 	public static <K, V> Map<K, V> createApproximateMap(Object map, int capacity);1419862420;Create the most approximate map for the given map._@param map the original Map object_@param capacity the initial capacity_@return the new, empty Map instance_@see #isApproximableMapType_@see java.util.EnumMap_@see java.util.TreeMap_@see java.util.LinkedHashMap;@SuppressWarnings({"unchecked", "rawtypes"})_	public static <K, V> Map<K, V> createApproximateMap(Object map, int capacity) {_		if (map instanceof EnumMap) {_			EnumMap enumMap = new EnumMap((EnumMap) map)__			enumMap.clear()__			return enumMap__		}_		else if (map instanceof SortedMap) {_			return new TreeMap<K, V>(((SortedMap<K, V>) map).comparator())__		}_		else {_			return new LinkedHashMap<K, V>(capacity)__		}_	};create,the,most,approximate,map,for,the,given,map,param,map,the,original,map,object,param,capacity,the,initial,capacity,return,the,new,empty,map,instance,see,is,approximable,map,type,see,java,util,enum,map,see,java,util,tree,map,see,java,util,linked,hash,map;suppress,warnings,unchecked,rawtypes,public,static,k,v,map,k,v,create,approximate,map,object,map,int,capacity,if,map,instanceof,enum,map,enum,map,enum,map,new,enum,map,enum,map,map,enum,map,clear,return,enum,map,else,if,map,instanceof,sorted,map,return,new,tree,map,k,v,sorted,map,k,v,map,comparator,else,return,new,linked,hash,map,k,v,capacity
CollectionFactory -> @SuppressWarnings({"unchecked", "rawtypes"}) 	public static <K, V> Map<K, V> createApproximateMap(Object map, int capacity);1420408095;Create the most approximate map for the given map._<p><strong>Warning</strong>: Since the parameterized type {@code K} is_not bound to the type of keys contained in the supplied {@code map},_type safety cannot be guaranteed if the supplied {@code map} is an_{@link EnumMap}. In such scenarios, the caller is responsible for_ensuring that the key type in the supplied {@code map} is an enum type_matching type {@code K}. As an alternative, the caller may wish to_treat the return value as a raw map or map keyed by {@link Object}._@param map the original map object, potentially {@code null}_@param capacity the initial capacity_@return a new, empty map instance_@see #isApproximableMapType_@see java.util.EnumMap_@see java.util.TreeMap_@see java.util.LinkedHashMap;@SuppressWarnings({"unchecked", "rawtypes"})_	public static <K, V> Map<K, V> createApproximateMap(Object map, int capacity) {_		if (map instanceof EnumMap) {_			EnumMap enumMap = new EnumMap((EnumMap) map)__			enumMap.clear()__			return enumMap__		}_		else if (map instanceof SortedMap) {_			return new TreeMap<K, V>(((SortedMap<K, V>) map).comparator())__		}_		else {_			return new LinkedHashMap<K, V>(capacity)__		}_	};create,the,most,approximate,map,for,the,given,map,p,strong,warning,strong,since,the,parameterized,type,code,k,is,not,bound,to,the,type,of,keys,contained,in,the,supplied,code,map,type,safety,cannot,be,guaranteed,if,the,supplied,code,map,is,an,link,enum,map,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,key,type,in,the,supplied,code,map,is,an,enum,type,matching,type,code,k,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,map,or,map,keyed,by,link,object,param,map,the,original,map,object,potentially,code,null,param,capacity,the,initial,capacity,return,a,new,empty,map,instance,see,is,approximable,map,type,see,java,util,enum,map,see,java,util,tree,map,see,java,util,linked,hash,map;suppress,warnings,unchecked,rawtypes,public,static,k,v,map,k,v,create,approximate,map,object,map,int,capacity,if,map,instanceof,enum,map,enum,map,enum,map,new,enum,map,enum,map,map,enum,map,clear,return,enum,map,else,if,map,instanceof,sorted,map,return,new,tree,map,k,v,sorted,map,k,v,map,comparator,else,return,new,linked,hash,map,k,v,capacity
CollectionFactory -> @SuppressWarnings({"unchecked", "rawtypes"}) 	public static <K, V> Map<K, V> createApproximateMap(Object map, int capacity);1432125256;Create the most approximate map for the given map._<p><strong>Warning</strong>: Since the parameterized type {@code K} is_not bound to the type of keys contained in the supplied {@code map},_type safety cannot be guaranteed if the supplied {@code map} is an_{@link EnumMap}. In such scenarios, the caller is responsible for_ensuring that the key type in the supplied {@code map} is an enum type_matching type {@code K}. As an alternative, the caller may wish to_treat the return value as a raw map or map keyed by {@link Object}._@param map the original map object, potentially {@code null}_@param capacity the initial capacity_@return a new, empty map instance_@see #isApproximableMapType_@see java.util.EnumMap_@see java.util.TreeMap_@see java.util.LinkedHashMap;@SuppressWarnings({"unchecked", "rawtypes"})_	public static <K, V> Map<K, V> createApproximateMap(Object map, int capacity) {_		if (map instanceof EnumMap) {_			EnumMap enumMap = new EnumMap((EnumMap) map)__			enumMap.clear()__			return enumMap__		}_		else if (map instanceof SortedMap) {_			return new TreeMap<K, V>(((SortedMap<K, V>) map).comparator())__		}_		else {_			return new LinkedHashMap<K, V>(capacity)__		}_	};create,the,most,approximate,map,for,the,given,map,p,strong,warning,strong,since,the,parameterized,type,code,k,is,not,bound,to,the,type,of,keys,contained,in,the,supplied,code,map,type,safety,cannot,be,guaranteed,if,the,supplied,code,map,is,an,link,enum,map,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,key,type,in,the,supplied,code,map,is,an,enum,type,matching,type,code,k,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,map,or,map,keyed,by,link,object,param,map,the,original,map,object,potentially,code,null,param,capacity,the,initial,capacity,return,a,new,empty,map,instance,see,is,approximable,map,type,see,java,util,enum,map,see,java,util,tree,map,see,java,util,linked,hash,map;suppress,warnings,unchecked,rawtypes,public,static,k,v,map,k,v,create,approximate,map,object,map,int,capacity,if,map,instanceof,enum,map,enum,map,enum,map,new,enum,map,enum,map,map,enum,map,clear,return,enum,map,else,if,map,instanceof,sorted,map,return,new,tree,map,k,v,sorted,map,k,v,map,comparator,else,return,new,linked,hash,map,k,v,capacity
CollectionFactory -> @SuppressWarnings({"unchecked", "rawtypes"}) 	public static <K, V> Map<K, V> createApproximateMap(Object map, int capacity);1467730834;Create the most approximate map for the given map._<p><strong>Warning</strong>: Since the parameterized type {@code K} is_not bound to the type of keys contained in the supplied {@code map},_type safety cannot be guaranteed if the supplied {@code map} is an_{@link EnumMap}. In such scenarios, the caller is responsible for_ensuring that the key type in the supplied {@code map} is an enum type_matching type {@code K}. As an alternative, the caller may wish to_treat the return value as a raw map or map keyed by {@link Object}._@param map the original map object, potentially {@code null}_@param capacity the initial capacity_@return a new, empty map instance_@see #isApproximableMapType_@see java.util.EnumMap_@see java.util.TreeMap_@see java.util.LinkedHashMap;@SuppressWarnings({"unchecked", "rawtypes"})_	public static <K, V> Map<K, V> createApproximateMap(Object map, int capacity) {_		if (map instanceof EnumMap) {_			EnumMap enumMap = new EnumMap((EnumMap) map)__			enumMap.clear()__			return enumMap__		}_		else if (map instanceof SortedMap) {_			return new TreeMap<>(((SortedMap<K, V>) map).comparator())__		}_		else {_			return new LinkedHashMap<>(capacity)__		}_	};create,the,most,approximate,map,for,the,given,map,p,strong,warning,strong,since,the,parameterized,type,code,k,is,not,bound,to,the,type,of,keys,contained,in,the,supplied,code,map,type,safety,cannot,be,guaranteed,if,the,supplied,code,map,is,an,link,enum,map,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,key,type,in,the,supplied,code,map,is,an,enum,type,matching,type,code,k,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,map,or,map,keyed,by,link,object,param,map,the,original,map,object,potentially,code,null,param,capacity,the,initial,capacity,return,a,new,empty,map,instance,see,is,approximable,map,type,see,java,util,enum,map,see,java,util,tree,map,see,java,util,linked,hash,map;suppress,warnings,unchecked,rawtypes,public,static,k,v,map,k,v,create,approximate,map,object,map,int,capacity,if,map,instanceof,enum,map,enum,map,enum,map,new,enum,map,enum,map,map,enum,map,clear,return,enum,map,else,if,map,instanceof,sorted,map,return,new,tree,map,sorted,map,k,v,map,comparator,else,return,new,linked,hash,map,capacity
CollectionFactory -> @SuppressWarnings({"unchecked", "rawtypes"}) 	public static <K, V> Map<K, V> createApproximateMap(Object map, int capacity);1468948866;Create the most approximate map for the given map._<p><strong>Warning</strong>: Since the parameterized type {@code K} is_not bound to the type of keys contained in the supplied {@code map},_type safety cannot be guaranteed if the supplied {@code map} is an_{@link EnumMap}. In such scenarios, the caller is responsible for_ensuring that the key type in the supplied {@code map} is an enum type_matching type {@code K}. As an alternative, the caller may wish to_treat the return value as a raw map or map keyed by {@link Object}._@param map the original map object, potentially {@code null}_@param capacity the initial capacity_@return a new, empty map instance_@see #isApproximableMapType_@see java.util.EnumMap_@see java.util.TreeMap_@see java.util.LinkedHashMap;@SuppressWarnings({"unchecked", "rawtypes"})_	public static <K, V> Map<K, V> createApproximateMap(Object map, int capacity) {_		if (map instanceof EnumMap) {_			EnumMap enumMap = new EnumMap((EnumMap) map)__			enumMap.clear()__			return enumMap__		}_		else if (map instanceof SortedMap) {_			return new TreeMap<>(((SortedMap<K, V>) map).comparator())__		}_		else {_			return new LinkedHashMap<>(capacity)__		}_	};create,the,most,approximate,map,for,the,given,map,p,strong,warning,strong,since,the,parameterized,type,code,k,is,not,bound,to,the,type,of,keys,contained,in,the,supplied,code,map,type,safety,cannot,be,guaranteed,if,the,supplied,code,map,is,an,link,enum,map,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,key,type,in,the,supplied,code,map,is,an,enum,type,matching,type,code,k,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,map,or,map,keyed,by,link,object,param,map,the,original,map,object,potentially,code,null,param,capacity,the,initial,capacity,return,a,new,empty,map,instance,see,is,approximable,map,type,see,java,util,enum,map,see,java,util,tree,map,see,java,util,linked,hash,map;suppress,warnings,unchecked,rawtypes,public,static,k,v,map,k,v,create,approximate,map,object,map,int,capacity,if,map,instanceof,enum,map,enum,map,enum,map,new,enum,map,enum,map,map,enum,map,clear,return,enum,map,else,if,map,instanceof,sorted,map,return,new,tree,map,sorted,map,k,v,map,comparator,else,return,new,linked,hash,map,capacity
CollectionFactory -> @SuppressWarnings({"unchecked", "rawtypes"}) 	public static <K, V> Map<K, V> createApproximateMap(Object map, int capacity);1474830340;Create the most approximate map for the given map._<p><strong>Warning</strong>: Since the parameterized type {@code K} is_not bound to the type of keys contained in the supplied {@code map},_type safety cannot be guaranteed if the supplied {@code map} is an_{@link EnumMap}. In such scenarios, the caller is responsible for_ensuring that the key type in the supplied {@code map} is an enum type_matching type {@code K}. As an alternative, the caller may wish to_treat the return value as a raw map or map keyed by {@link Object}._@param map the original map object, potentially {@code null}_@param capacity the initial capacity_@return a new, empty map instance_@see #isApproximableMapType_@see java.util.EnumMap_@see java.util.TreeMap_@see java.util.LinkedHashMap;@SuppressWarnings({"unchecked", "rawtypes"})_	public static <K, V> Map<K, V> createApproximateMap(Object map, int capacity) {_		if (map instanceof EnumMap) {_			EnumMap enumMap = new EnumMap((EnumMap) map)__			enumMap.clear()__			return enumMap__		}_		else if (map instanceof SortedMap) {_			return new TreeMap<>(((SortedMap<K, V>) map).comparator())__		}_		else {_			return new LinkedHashMap<>(capacity)__		}_	};create,the,most,approximate,map,for,the,given,map,p,strong,warning,strong,since,the,parameterized,type,code,k,is,not,bound,to,the,type,of,keys,contained,in,the,supplied,code,map,type,safety,cannot,be,guaranteed,if,the,supplied,code,map,is,an,link,enum,map,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,key,type,in,the,supplied,code,map,is,an,enum,type,matching,type,code,k,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,map,or,map,keyed,by,link,object,param,map,the,original,map,object,potentially,code,null,param,capacity,the,initial,capacity,return,a,new,empty,map,instance,see,is,approximable,map,type,see,java,util,enum,map,see,java,util,tree,map,see,java,util,linked,hash,map;suppress,warnings,unchecked,rawtypes,public,static,k,v,map,k,v,create,approximate,map,object,map,int,capacity,if,map,instanceof,enum,map,enum,map,enum,map,new,enum,map,enum,map,map,enum,map,clear,return,enum,map,else,if,map,instanceof,sorted,map,return,new,tree,map,sorted,map,k,v,map,comparator,else,return,new,linked,hash,map,capacity
CollectionFactory -> @SuppressWarnings({"unchecked", "rawtypes"}) 	public static <K, V> Map<K, V> createApproximateMap(Object map, int capacity);1484252281;Create the most approximate map for the given map._<p><strong>Warning</strong>: Since the parameterized type {@code K} is_not bound to the type of keys contained in the supplied {@code map},_type safety cannot be guaranteed if the supplied {@code map} is an_{@link EnumMap}. In such scenarios, the caller is responsible for_ensuring that the key type in the supplied {@code map} is an enum type_matching type {@code K}. As an alternative, the caller may wish to_treat the return value as a raw map or map keyed by {@link Object}._@param map the original map object, potentially {@code null}_@param capacity the initial capacity_@return a new, empty map instance_@see #isApproximableMapType_@see java.util.EnumMap_@see java.util.TreeMap_@see java.util.LinkedHashMap;@SuppressWarnings({"unchecked", "rawtypes"})_	public static <K, V> Map<K, V> createApproximateMap(Object map, int capacity) {_		if (map instanceof EnumMap) {_			EnumMap enumMap = new EnumMap((EnumMap) map)__			enumMap.clear()__			return enumMap__		}_		else if (map instanceof SortedMap) {_			return new TreeMap<>(((SortedMap<K, V>) map).comparator())__		}_		else {_			return new LinkedHashMap<>(capacity)__		}_	};create,the,most,approximate,map,for,the,given,map,p,strong,warning,strong,since,the,parameterized,type,code,k,is,not,bound,to,the,type,of,keys,contained,in,the,supplied,code,map,type,safety,cannot,be,guaranteed,if,the,supplied,code,map,is,an,link,enum,map,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,key,type,in,the,supplied,code,map,is,an,enum,type,matching,type,code,k,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,map,or,map,keyed,by,link,object,param,map,the,original,map,object,potentially,code,null,param,capacity,the,initial,capacity,return,a,new,empty,map,instance,see,is,approximable,map,type,see,java,util,enum,map,see,java,util,tree,map,see,java,util,linked,hash,map;suppress,warnings,unchecked,rawtypes,public,static,k,v,map,k,v,create,approximate,map,object,map,int,capacity,if,map,instanceof,enum,map,enum,map,enum,map,new,enum,map,enum,map,map,enum,map,clear,return,enum,map,else,if,map,instanceof,sorted,map,return,new,tree,map,sorted,map,k,v,map,comparator,else,return,new,linked,hash,map,capacity
CollectionFactory -> @SuppressWarnings("serial") 	public static Properties createStringAdaptingProperties();1474830340;Create a variant of {@code java.util.Properties} that automatically adapts_non-String values to String representations on {@link Properties#getProperty}._@return a new {@code Properties} instance_@since 4.3.4;@SuppressWarnings("serial")_	public static Properties createStringAdaptingProperties() {_		return new Properties() {_			@Override_			public String getProperty(String key) {_				Object value = get(key)__				return (value != null ? value.toString() : null)__			}_		}__	};create,a,variant,of,code,java,util,properties,that,automatically,adapts,non,string,values,to,string,representations,on,link,properties,get,property,return,a,new,code,properties,instance,since,4,3,4;suppress,warnings,serial,public,static,properties,create,string,adapting,properties,return,new,properties,override,public,string,get,property,string,key,object,value,get,key,return,value,null,value,to,string,null
CollectionFactory -> @SuppressWarnings("serial") 	public static Properties createStringAdaptingProperties();1484252281;Create a variant of {@code java.util.Properties} that automatically adapts_non-String values to String representations on {@link Properties#getProperty}._@return a new {@code Properties} instance_@since 4.3.4;@SuppressWarnings("serial")_	public static Properties createStringAdaptingProperties() {_		return new Properties() {_			@Override_			public String getProperty(String key) {_				Object value = get(key)__				return (value != null ? value.toString() : null)__			}_		}__	};create,a,variant,of,code,java,util,properties,that,automatically,adapts,non,string,values,to,string,representations,on,link,properties,get,property,return,a,new,code,properties,instance,since,4,3,4;suppress,warnings,serial,public,static,properties,create,string,adapting,properties,return,new,properties,override,public,string,get,property,string,key,object,value,get,key,return,value,null,value,to,string,null
CollectionFactory -> @SuppressWarnings("serial") 	public static Properties createStringAdaptingProperties();1495868221;Create a variant of {@code java.util.Properties} that automatically adapts_non-String values to String representations on {@link Properties#getProperty}._@return a new {@code Properties} instance_@since 4.3.4;@SuppressWarnings("serial")_	public static Properties createStringAdaptingProperties() {_		return new Properties() {_			@Override_			public String getProperty(String key) {_				Object value = get(key)__				return (value != null ? value.toString() : null)__			}_		}__	};create,a,variant,of,code,java,util,properties,that,automatically,adapts,non,string,values,to,string,representations,on,link,properties,get,property,return,a,new,code,properties,instance,since,4,3,4;suppress,warnings,serial,public,static,properties,create,string,adapting,properties,return,new,properties,override,public,string,get,property,string,key,object,value,get,key,return,value,null,value,to,string,null
CollectionFactory -> @SuppressWarnings("serial") 	public static Properties createStringAdaptingProperties();1496837955;Create a variant of {@code java.util.Properties} that automatically adapts_non-String values to String representations on {@link Properties#getProperty}._@return a new {@code Properties} instance_@since 4.3.4;@SuppressWarnings("serial")_	public static Properties createStringAdaptingProperties() {_		return new Properties() {_			@Override_			@Nullable_			public String getProperty(String key) {_				Object value = get(key)__				return (value != null ? value.toString() : null)__			}_		}__	};create,a,variant,of,code,java,util,properties,that,automatically,adapts,non,string,values,to,string,representations,on,link,properties,get,property,return,a,new,code,properties,instance,since,4,3,4;suppress,warnings,serial,public,static,properties,create,string,adapting,properties,return,new,properties,override,nullable,public,string,get,property,string,key,object,value,get,key,return,value,null,value,to,string,null
CollectionFactory -> @SuppressWarnings("serial") 	public static Properties createStringAdaptingProperties();1530532518;Create a variant of {@code java.util.Properties} that automatically adapts_non-String values to String representations on {@link Properties#getProperty}._@return a new {@code Properties} instance_@since 4.3.4;@SuppressWarnings("serial")_	public static Properties createStringAdaptingProperties() {_		return new Properties() {_			@Override_			@Nullable_			public String getProperty(String key) {_				Object value = get(key)__				return (value != null ? value.toString() : null)__			}_		}__	};create,a,variant,of,code,java,util,properties,that,automatically,adapts,non,string,values,to,string,representations,on,link,properties,get,property,return,a,new,code,properties,instance,since,4,3,4;suppress,warnings,serial,public,static,properties,create,string,adapting,properties,return,new,properties,override,nullable,public,string,get,property,string,key,object,value,get,key,return,value,null,value,to,string,null
CollectionFactory -> @SuppressWarnings("serial") 	public static Properties createStringAdaptingProperties();1545740431;Create a variant of {@code java.util.Properties} that automatically adapts_non-String values to String representations on {@link Properties#getProperty}._@return a new {@code Properties} instance_@since 4.3.4;@SuppressWarnings("serial")_	public static Properties createStringAdaptingProperties() {_		return new Properties() {_			@Override_			@Nullable_			public String getProperty(String key) {_				Object value = get(key)__				return (value != null ? value.toString() : null)__			}_		}__	};create,a,variant,of,code,java,util,properties,that,automatically,adapts,non,string,values,to,string,representations,on,link,properties,get,property,return,a,new,code,properties,instance,since,4,3,4;suppress,warnings,serial,public,static,properties,create,string,adapting,properties,return,new,properties,override,nullable,public,string,get,property,string,key,object,value,get,key,return,value,null,value,to,string,null
CollectionFactory -> @SuppressWarnings("serial") 	public static Properties createStringAdaptingProperties();1549321822;Create a variant of {@code java.util.Properties} that automatically adapts_non-String values to String representations on {@link Properties#getProperty}._@return a new {@code Properties} instance_@since 4.3.4;@SuppressWarnings("serial")_	public static Properties createStringAdaptingProperties() {_		return new Properties() {_			@Override_			@Nullable_			public String getProperty(String key) {_				Object value = get(key)__				return (value != null ? value.toString() : null)__			}_		}__	};create,a,variant,of,code,java,util,properties,that,automatically,adapts,non,string,values,to,string,representations,on,link,properties,get,property,return,a,new,code,properties,instance,since,4,3,4;suppress,warnings,serial,public,static,properties,create,string,adapting,properties,return,new,properties,override,nullable,public,string,get,property,string,key,object,value,get,key,return,value,null,value,to,string,null
CollectionFactory -> @SuppressWarnings("unchecked") 	public static <K, V> Map<K, V> createApproximateMap(Object map, int initialCapacity);1385412762;Create the most approximate map for the given map._<p>Creates a TreeMap or linked Map for a SortedMap or Map, respectively._@param map the original Map object_@param initialCapacity the initial capacity_@return the new Map instance_@see java.util.TreeMap_@see java.util.LinkedHashMap;@SuppressWarnings("unchecked")_	public static <K, V> Map<K, V> createApproximateMap(Object map, int initialCapacity) {_		if (map instanceof SortedMap) {_			return new TreeMap<K, V>(((SortedMap<K, V>) map).comparator())__		}_		else {_			return new LinkedHashMap<K, V>(initialCapacity)__		}_	};create,the,most,approximate,map,for,the,given,map,p,creates,a,tree,map,or,linked,map,for,a,sorted,map,or,map,respectively,param,map,the,original,map,object,param,initial,capacity,the,initial,capacity,return,the,new,map,instance,see,java,util,tree,map,see,java,util,linked,hash,map;suppress,warnings,unchecked,public,static,k,v,map,k,v,create,approximate,map,object,map,int,initial,capacity,if,map,instanceof,sorted,map,return,new,tree,map,k,v,sorted,map,k,v,map,comparator,else,return,new,linked,hash,map,k,v,initial,capacity
CollectionFactory -> @SuppressWarnings("unchecked") 	public static <K, V> Map<K, V> createApproximateMap(Object map, int initialCapacity);1388260115;Create the most approximate map for the given map._<p>Creates a TreeMap or linked Map for a SortedMap or Map, respectively._@param map the original Map object_@param initialCapacity the initial capacity_@return the new Map instance_@see java.util.TreeMap_@see java.util.LinkedHashMap;@SuppressWarnings("unchecked")_	public static <K, V> Map<K, V> createApproximateMap(Object map, int initialCapacity) {_		if (map instanceof SortedMap) {_			return new TreeMap<K, V>(((SortedMap<K, V>) map).comparator())__		}_		else {_			return new LinkedHashMap<K, V>(initialCapacity)__		}_	};create,the,most,approximate,map,for,the,given,map,p,creates,a,tree,map,or,linked,map,for,a,sorted,map,or,map,respectively,param,map,the,original,map,object,param,initial,capacity,the,initial,capacity,return,the,new,map,instance,see,java,util,tree,map,see,java,util,linked,hash,map;suppress,warnings,unchecked,public,static,k,v,map,k,v,create,approximate,map,object,map,int,initial,capacity,if,map,instanceof,sorted,map,return,new,tree,map,k,v,sorted,map,k,v,map,comparator,else,return,new,linked,hash,map,k,v,initial,capacity
CollectionFactory -> @SuppressWarnings({"unchecked", "rawtypes"}) 	public static <K, V> Map<K, V> createMap(Class<?> mapType, @Nullable Class<?> keyType, int capacity);1495868221;Create the most appropriate map for the given map type._<p><strong>Warning</strong>: Since the parameterized type {@code K}_is not bound to the supplied {@code keyType}, type safety cannot be_guaranteed if the desired {@code mapType} is {@link EnumMap}. In such_scenarios, the caller is responsible for ensuring that the {@code keyType}_is an enum type matching type {@code K}. As an alternative, the caller_may wish to treat the return value as a raw map or map keyed by_{@link Object}. Similarly, type safety cannot be enforced if the_desired {@code mapType} is {@link MultiValueMap}._@param mapType the desired type of the target map_ never {@code null}_@param keyType the map's key type, or {@code null} if unknown_(note: only relevant for {@link EnumMap} creation)_@param capacity the initial capacity_@return a new map instance_@since 4.1.3_@see java.util.LinkedHashMap_@see java.util.TreeMap_@see org.springframework.util.LinkedMultiValueMap_@see java.util.EnumMap_@throws IllegalArgumentException if the supplied {@code mapType} is_{@code null}_ or if the desired {@code mapType} is {@link EnumMap} and_the supplied {@code keyType} is not a subtype of {@link Enum};@SuppressWarnings({"unchecked", "rawtypes"})_	public static <K, V> Map<K, V> createMap(Class<?> mapType, @Nullable Class<?> keyType, int capacity) {_		Assert.notNull(mapType, "Map type must not be null")__		if (mapType.isInterface()) {_			if (Map.class == mapType) {_				return new LinkedHashMap<>(capacity)__			}_			else if (SortedMap.class == mapType || NavigableMap.class == mapType) {_				return new TreeMap<>()__			}_			else if (MultiValueMap.class == mapType) {_				return new LinkedMultiValueMap()__			}_			else {_				throw new IllegalArgumentException("Unsupported Map interface: " + mapType.getName())__			}_		}_		else if (EnumMap.class == mapType) {_			Assert.notNull(keyType, "Cannot create EnumMap for unknown key type")__			return new EnumMap(asEnumType(keyType))__		}_		else {_			if (!Map.class.isAssignableFrom(mapType)) {_				throw new IllegalArgumentException("Unsupported Map type: " + mapType.getName())__			}_			try {_				return (Map<K, V>) ReflectionUtils.accessibleConstructor(mapType).newInstance()__			}_			catch (Throwable ex) {_				throw new IllegalArgumentException("Could not instantiate Map type: " + mapType.getName(), ex)__			}_		}_	};create,the,most,appropriate,map,for,the,given,map,type,p,strong,warning,strong,since,the,parameterized,type,code,k,is,not,bound,to,the,supplied,code,key,type,type,safety,cannot,be,guaranteed,if,the,desired,code,map,type,is,link,enum,map,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,code,key,type,is,an,enum,type,matching,type,code,k,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,map,or,map,keyed,by,link,object,similarly,type,safety,cannot,be,enforced,if,the,desired,code,map,type,is,link,multi,value,map,param,map,type,the,desired,type,of,the,target,map,never,code,null,param,key,type,the,map,s,key,type,or,code,null,if,unknown,note,only,relevant,for,link,enum,map,creation,param,capacity,the,initial,capacity,return,a,new,map,instance,since,4,1,3,see,java,util,linked,hash,map,see,java,util,tree,map,see,org,springframework,util,linked,multi,value,map,see,java,util,enum,map,throws,illegal,argument,exception,if,the,supplied,code,map,type,is,code,null,or,if,the,desired,code,map,type,is,link,enum,map,and,the,supplied,code,key,type,is,not,a,subtype,of,link,enum;suppress,warnings,unchecked,rawtypes,public,static,k,v,map,k,v,create,map,class,map,type,nullable,class,key,type,int,capacity,assert,not,null,map,type,map,type,must,not,be,null,if,map,type,is,interface,if,map,class,map,type,return,new,linked,hash,map,capacity,else,if,sorted,map,class,map,type,navigable,map,class,map,type,return,new,tree,map,else,if,multi,value,map,class,map,type,return,new,linked,multi,value,map,else,throw,new,illegal,argument,exception,unsupported,map,interface,map,type,get,name,else,if,enum,map,class,map,type,assert,not,null,key,type,cannot,create,enum,map,for,unknown,key,type,return,new,enum,map,as,enum,type,key,type,else,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,unsupported,map,type,map,type,get,name,try,return,map,k,v,reflection,utils,accessible,constructor,map,type,new,instance,catch,throwable,ex,throw,new,illegal,argument,exception,could,not,instantiate,map,type,map,type,get,name,ex
CollectionFactory -> @SuppressWarnings({"unchecked", "rawtypes"}) 	public static <K, V> Map<K, V> createMap(Class<?> mapType, @Nullable Class<?> keyType, int capacity);1496837955;Create the most appropriate map for the given map type._<p><strong>Warning</strong>: Since the parameterized type {@code K}_is not bound to the supplied {@code keyType}, type safety cannot be_guaranteed if the desired {@code mapType} is {@link EnumMap}. In such_scenarios, the caller is responsible for ensuring that the {@code keyType}_is an enum type matching type {@code K}. As an alternative, the caller_may wish to treat the return value as a raw map or map keyed by_{@link Object}. Similarly, type safety cannot be enforced if the_desired {@code mapType} is {@link MultiValueMap}._@param mapType the desired type of the target map_ never {@code null}_@param keyType the map's key type, or {@code null} if unknown_(note: only relevant for {@link EnumMap} creation)_@param capacity the initial capacity_@return a new map instance_@since 4.1.3_@see java.util.LinkedHashMap_@see java.util.TreeMap_@see org.springframework.util.LinkedMultiValueMap_@see java.util.EnumMap_@throws IllegalArgumentException if the supplied {@code mapType} is_{@code null}_ or if the desired {@code mapType} is {@link EnumMap} and_the supplied {@code keyType} is not a subtype of {@link Enum};@SuppressWarnings({"unchecked", "rawtypes"})_	public static <K, V> Map<K, V> createMap(Class<?> mapType, @Nullable Class<?> keyType, int capacity) {_		Assert.notNull(mapType, "Map type must not be null")__		if (mapType.isInterface()) {_			if (Map.class == mapType) {_				return new LinkedHashMap<>(capacity)__			}_			else if (SortedMap.class == mapType || NavigableMap.class == mapType) {_				return new TreeMap<>()__			}_			else if (MultiValueMap.class == mapType) {_				return new LinkedMultiValueMap()__			}_			else {_				throw new IllegalArgumentException("Unsupported Map interface: " + mapType.getName())__			}_		}_		else if (EnumMap.class == mapType) {_			Assert.notNull(keyType, "Cannot create EnumMap for unknown key type")__			return new EnumMap(asEnumType(keyType))__		}_		else {_			if (!Map.class.isAssignableFrom(mapType)) {_				throw new IllegalArgumentException("Unsupported Map type: " + mapType.getName())__			}_			try {_				return (Map<K, V>) ReflectionUtils.accessibleConstructor(mapType).newInstance()__			}_			catch (Throwable ex) {_				throw new IllegalArgumentException("Could not instantiate Map type: " + mapType.getName(), ex)__			}_		}_	};create,the,most,appropriate,map,for,the,given,map,type,p,strong,warning,strong,since,the,parameterized,type,code,k,is,not,bound,to,the,supplied,code,key,type,type,safety,cannot,be,guaranteed,if,the,desired,code,map,type,is,link,enum,map,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,code,key,type,is,an,enum,type,matching,type,code,k,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,map,or,map,keyed,by,link,object,similarly,type,safety,cannot,be,enforced,if,the,desired,code,map,type,is,link,multi,value,map,param,map,type,the,desired,type,of,the,target,map,never,code,null,param,key,type,the,map,s,key,type,or,code,null,if,unknown,note,only,relevant,for,link,enum,map,creation,param,capacity,the,initial,capacity,return,a,new,map,instance,since,4,1,3,see,java,util,linked,hash,map,see,java,util,tree,map,see,org,springframework,util,linked,multi,value,map,see,java,util,enum,map,throws,illegal,argument,exception,if,the,supplied,code,map,type,is,code,null,or,if,the,desired,code,map,type,is,link,enum,map,and,the,supplied,code,key,type,is,not,a,subtype,of,link,enum;suppress,warnings,unchecked,rawtypes,public,static,k,v,map,k,v,create,map,class,map,type,nullable,class,key,type,int,capacity,assert,not,null,map,type,map,type,must,not,be,null,if,map,type,is,interface,if,map,class,map,type,return,new,linked,hash,map,capacity,else,if,sorted,map,class,map,type,navigable,map,class,map,type,return,new,tree,map,else,if,multi,value,map,class,map,type,return,new,linked,multi,value,map,else,throw,new,illegal,argument,exception,unsupported,map,interface,map,type,get,name,else,if,enum,map,class,map,type,assert,not,null,key,type,cannot,create,enum,map,for,unknown,key,type,return,new,enum,map,as,enum,type,key,type,else,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,unsupported,map,type,map,type,get,name,try,return,map,k,v,reflection,utils,accessible,constructor,map,type,new,instance,catch,throwable,ex,throw,new,illegal,argument,exception,could,not,instantiate,map,type,map,type,get,name,ex
CollectionFactory -> @SuppressWarnings({"unchecked", "rawtypes"}) 	public static <K, V> Map<K, V> createMap(Class<?> mapType, @Nullable Class<?> keyType, int capacity);1530532518;Create the most appropriate map for the given map type._<p><strong>Warning</strong>: Since the parameterized type {@code K}_is not bound to the supplied {@code keyType}, type safety cannot be_guaranteed if the desired {@code mapType} is {@link EnumMap}. In such_scenarios, the caller is responsible for ensuring that the {@code keyType}_is an enum type matching type {@code K}. As an alternative, the caller_may wish to treat the return value as a raw map or map keyed by_{@link Object}. Similarly, type safety cannot be enforced if the_desired {@code mapType} is {@link MultiValueMap}._@param mapType the desired type of the target map_ never {@code null}_@param keyType the map's key type, or {@code null} if unknown_(note: only relevant for {@link EnumMap} creation)_@param capacity the initial capacity_@return a new map instance_@since 4.1.3_@see java.util.LinkedHashMap_@see java.util.TreeMap_@see org.springframework.util.LinkedMultiValueMap_@see java.util.EnumMap_@throws IllegalArgumentException if the supplied {@code mapType} is_{@code null}_ or if the desired {@code mapType} is {@link EnumMap} and_the supplied {@code keyType} is not a subtype of {@link Enum};@SuppressWarnings({"unchecked", "rawtypes"})_	public static <K, V> Map<K, V> createMap(Class<?> mapType, @Nullable Class<?> keyType, int capacity) {_		Assert.notNull(mapType, "Map type must not be null")__		if (mapType.isInterface()) {_			if (Map.class == mapType) {_				return new LinkedHashMap<>(capacity)__			}_			else if (SortedMap.class == mapType || NavigableMap.class == mapType) {_				return new TreeMap<>()__			}_			else if (MultiValueMap.class == mapType) {_				return new LinkedMultiValueMap()__			}_			else {_				throw new IllegalArgumentException("Unsupported Map interface: " + mapType.getName())__			}_		}_		else if (EnumMap.class == mapType) {_			Assert.notNull(keyType, "Cannot create EnumMap for unknown key type")__			return new EnumMap(asEnumType(keyType))__		}_		else {_			if (!Map.class.isAssignableFrom(mapType)) {_				throw new IllegalArgumentException("Unsupported Map type: " + mapType.getName())__			}_			try {_				return (Map<K, V>) ReflectionUtils.accessibleConstructor(mapType).newInstance()__			}_			catch (Throwable ex) {_				throw new IllegalArgumentException("Could not instantiate Map type: " + mapType.getName(), ex)__			}_		}_	};create,the,most,appropriate,map,for,the,given,map,type,p,strong,warning,strong,since,the,parameterized,type,code,k,is,not,bound,to,the,supplied,code,key,type,type,safety,cannot,be,guaranteed,if,the,desired,code,map,type,is,link,enum,map,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,code,key,type,is,an,enum,type,matching,type,code,k,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,map,or,map,keyed,by,link,object,similarly,type,safety,cannot,be,enforced,if,the,desired,code,map,type,is,link,multi,value,map,param,map,type,the,desired,type,of,the,target,map,never,code,null,param,key,type,the,map,s,key,type,or,code,null,if,unknown,note,only,relevant,for,link,enum,map,creation,param,capacity,the,initial,capacity,return,a,new,map,instance,since,4,1,3,see,java,util,linked,hash,map,see,java,util,tree,map,see,org,springframework,util,linked,multi,value,map,see,java,util,enum,map,throws,illegal,argument,exception,if,the,supplied,code,map,type,is,code,null,or,if,the,desired,code,map,type,is,link,enum,map,and,the,supplied,code,key,type,is,not,a,subtype,of,link,enum;suppress,warnings,unchecked,rawtypes,public,static,k,v,map,k,v,create,map,class,map,type,nullable,class,key,type,int,capacity,assert,not,null,map,type,map,type,must,not,be,null,if,map,type,is,interface,if,map,class,map,type,return,new,linked,hash,map,capacity,else,if,sorted,map,class,map,type,navigable,map,class,map,type,return,new,tree,map,else,if,multi,value,map,class,map,type,return,new,linked,multi,value,map,else,throw,new,illegal,argument,exception,unsupported,map,interface,map,type,get,name,else,if,enum,map,class,map,type,assert,not,null,key,type,cannot,create,enum,map,for,unknown,key,type,return,new,enum,map,as,enum,type,key,type,else,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,unsupported,map,type,map,type,get,name,try,return,map,k,v,reflection,utils,accessible,constructor,map,type,new,instance,catch,throwable,ex,throw,new,illegal,argument,exception,could,not,instantiate,map,type,map,type,get,name,ex
CollectionFactory -> @SuppressWarnings({"unchecked", "rawtypes"}) 	public static <K, V> Map<K, V> createMap(Class<?> mapType, @Nullable Class<?> keyType, int capacity);1545740431;Create the most appropriate map for the given map type._<p><strong>Warning</strong>: Since the parameterized type {@code K}_is not bound to the supplied {@code keyType}, type safety cannot be_guaranteed if the desired {@code mapType} is {@link EnumMap}. In such_scenarios, the caller is responsible for ensuring that the {@code keyType}_is an enum type matching type {@code K}. As an alternative, the caller_may wish to treat the return value as a raw map or map keyed by_{@link Object}. Similarly, type safety cannot be enforced if the_desired {@code mapType} is {@link MultiValueMap}._@param mapType the desired type of the target map_ never {@code null}_@param keyType the map's key type, or {@code null} if unknown_(note: only relevant for {@link EnumMap} creation)_@param capacity the initial capacity_@return a new map instance_@since 4.1.3_@see java.util.LinkedHashMap_@see java.util.TreeMap_@see org.springframework.util.LinkedMultiValueMap_@see java.util.EnumMap_@throws IllegalArgumentException if the supplied {@code mapType} is_{@code null}_ or if the desired {@code mapType} is {@link EnumMap} and_the supplied {@code keyType} is not a subtype of {@link Enum};@SuppressWarnings({"unchecked", "rawtypes"})_	public static <K, V> Map<K, V> createMap(Class<?> mapType, @Nullable Class<?> keyType, int capacity) {_		Assert.notNull(mapType, "Map type must not be null")__		if (mapType.isInterface()) {_			if (Map.class == mapType) {_				return new LinkedHashMap<>(capacity)__			}_			else if (SortedMap.class == mapType || NavigableMap.class == mapType) {_				return new TreeMap<>()__			}_			else if (MultiValueMap.class == mapType) {_				return new LinkedMultiValueMap()__			}_			else {_				throw new IllegalArgumentException("Unsupported Map interface: " + mapType.getName())__			}_		}_		else if (EnumMap.class == mapType) {_			Assert.notNull(keyType, "Cannot create EnumMap for unknown key type")__			return new EnumMap(asEnumType(keyType))__		}_		else {_			if (!Map.class.isAssignableFrom(mapType)) {_				throw new IllegalArgumentException("Unsupported Map type: " + mapType.getName())__			}_			try {_				return (Map<K, V>) ReflectionUtils.accessibleConstructor(mapType).newInstance()__			}_			catch (Throwable ex) {_				throw new IllegalArgumentException("Could not instantiate Map type: " + mapType.getName(), ex)__			}_		}_	};create,the,most,appropriate,map,for,the,given,map,type,p,strong,warning,strong,since,the,parameterized,type,code,k,is,not,bound,to,the,supplied,code,key,type,type,safety,cannot,be,guaranteed,if,the,desired,code,map,type,is,link,enum,map,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,code,key,type,is,an,enum,type,matching,type,code,k,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,map,or,map,keyed,by,link,object,similarly,type,safety,cannot,be,enforced,if,the,desired,code,map,type,is,link,multi,value,map,param,map,type,the,desired,type,of,the,target,map,never,code,null,param,key,type,the,map,s,key,type,or,code,null,if,unknown,note,only,relevant,for,link,enum,map,creation,param,capacity,the,initial,capacity,return,a,new,map,instance,since,4,1,3,see,java,util,linked,hash,map,see,java,util,tree,map,see,org,springframework,util,linked,multi,value,map,see,java,util,enum,map,throws,illegal,argument,exception,if,the,supplied,code,map,type,is,code,null,or,if,the,desired,code,map,type,is,link,enum,map,and,the,supplied,code,key,type,is,not,a,subtype,of,link,enum;suppress,warnings,unchecked,rawtypes,public,static,k,v,map,k,v,create,map,class,map,type,nullable,class,key,type,int,capacity,assert,not,null,map,type,map,type,must,not,be,null,if,map,type,is,interface,if,map,class,map,type,return,new,linked,hash,map,capacity,else,if,sorted,map,class,map,type,navigable,map,class,map,type,return,new,tree,map,else,if,multi,value,map,class,map,type,return,new,linked,multi,value,map,else,throw,new,illegal,argument,exception,unsupported,map,interface,map,type,get,name,else,if,enum,map,class,map,type,assert,not,null,key,type,cannot,create,enum,map,for,unknown,key,type,return,new,enum,map,as,enum,type,key,type,else,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,unsupported,map,type,map,type,get,name,try,return,map,k,v,reflection,utils,accessible,constructor,map,type,new,instance,catch,throwable,ex,throw,new,illegal,argument,exception,could,not,instantiate,map,type,map,type,get,name,ex
CollectionFactory -> @SuppressWarnings({"unchecked", "rawtypes"}) 	public static <K, V> Map<K, V> createMap(Class<?> mapType, @Nullable Class<?> keyType, int capacity);1549321822;Create the most appropriate map for the given map type._<p><strong>Warning</strong>: Since the parameterized type {@code K}_is not bound to the supplied {@code keyType}, type safety cannot be_guaranteed if the desired {@code mapType} is {@link EnumMap}. In such_scenarios, the caller is responsible for ensuring that the {@code keyType}_is an enum type matching type {@code K}. As an alternative, the caller_may wish to treat the return value as a raw map or map keyed by_{@link Object}. Similarly, type safety cannot be enforced if the_desired {@code mapType} is {@link MultiValueMap}._@param mapType the desired type of the target map (never {@code null})_@param keyType the map's key type, or {@code null} if unknown_(note: only relevant for {@link EnumMap} creation)_@param capacity the initial capacity_@return a new map instance_@since 4.1.3_@see java.util.LinkedHashMap_@see java.util.TreeMap_@see org.springframework.util.LinkedMultiValueMap_@see java.util.EnumMap_@throws IllegalArgumentException if the supplied {@code mapType} is_{@code null}_ or if the desired {@code mapType} is {@link EnumMap} and_the supplied {@code keyType} is not a subtype of {@link Enum};@SuppressWarnings({"unchecked", "rawtypes"})_	public static <K, V> Map<K, V> createMap(Class<?> mapType, @Nullable Class<?> keyType, int capacity) {_		Assert.notNull(mapType, "Map type must not be null")__		if (mapType.isInterface()) {_			if (Map.class == mapType) {_				return new LinkedHashMap<>(capacity)__			}_			else if (SortedMap.class == mapType || NavigableMap.class == mapType) {_				return new TreeMap<>()__			}_			else if (MultiValueMap.class == mapType) {_				return new LinkedMultiValueMap()__			}_			else {_				throw new IllegalArgumentException("Unsupported Map interface: " + mapType.getName())__			}_		}_		else if (EnumMap.class == mapType) {_			Assert.notNull(keyType, "Cannot create EnumMap for unknown key type")__			return new EnumMap(asEnumType(keyType))__		}_		else {_			if (!Map.class.isAssignableFrom(mapType)) {_				throw new IllegalArgumentException("Unsupported Map type: " + mapType.getName())__			}_			try {_				return (Map<K, V>) ReflectionUtils.accessibleConstructor(mapType).newInstance()__			}_			catch (Throwable ex) {_				throw new IllegalArgumentException("Could not instantiate Map type: " + mapType.getName(), ex)__			}_		}_	};create,the,most,appropriate,map,for,the,given,map,type,p,strong,warning,strong,since,the,parameterized,type,code,k,is,not,bound,to,the,supplied,code,key,type,type,safety,cannot,be,guaranteed,if,the,desired,code,map,type,is,link,enum,map,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,code,key,type,is,an,enum,type,matching,type,code,k,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,map,or,map,keyed,by,link,object,similarly,type,safety,cannot,be,enforced,if,the,desired,code,map,type,is,link,multi,value,map,param,map,type,the,desired,type,of,the,target,map,never,code,null,param,key,type,the,map,s,key,type,or,code,null,if,unknown,note,only,relevant,for,link,enum,map,creation,param,capacity,the,initial,capacity,return,a,new,map,instance,since,4,1,3,see,java,util,linked,hash,map,see,java,util,tree,map,see,org,springframework,util,linked,multi,value,map,see,java,util,enum,map,throws,illegal,argument,exception,if,the,supplied,code,map,type,is,code,null,or,if,the,desired,code,map,type,is,link,enum,map,and,the,supplied,code,key,type,is,not,a,subtype,of,link,enum;suppress,warnings,unchecked,rawtypes,public,static,k,v,map,k,v,create,map,class,map,type,nullable,class,key,type,int,capacity,assert,not,null,map,type,map,type,must,not,be,null,if,map,type,is,interface,if,map,class,map,type,return,new,linked,hash,map,capacity,else,if,sorted,map,class,map,type,navigable,map,class,map,type,return,new,tree,map,else,if,multi,value,map,class,map,type,return,new,linked,multi,value,map,else,throw,new,illegal,argument,exception,unsupported,map,interface,map,type,get,name,else,if,enum,map,class,map,type,assert,not,null,key,type,cannot,create,enum,map,for,unknown,key,type,return,new,enum,map,as,enum,type,key,type,else,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,unsupported,map,type,map,type,get,name,try,return,map,k,v,reflection,utils,accessible,constructor,map,type,new,instance,catch,throwable,ex,throw,new,illegal,argument,exception,could,not,instantiate,map,type,map,type,get,name,ex
CollectionFactory -> @Deprecated 	public static <T> Set<T> createCopyOnWriteSet();1328020251;Create a copy-on-write Set (allowing for synchronization-less iteration) if possible:_This implementation always creates a {@link java.util.concurrent.CopyOnWriteArraySet},_since Spring 3 requires JDK 1.5 anyway._@return the new Set instance_@deprecated as of Spring 3.0, for usage on JDK 1.5 or higher;@Deprecated_	public static <T> Set<T> createCopyOnWriteSet() {_		return new CopyOnWriteArraySet<T>()__	};create,a,copy,on,write,set,allowing,for,synchronization,less,iteration,if,possible,this,implementation,always,creates,a,link,java,util,concurrent,copy,on,write,array,set,since,spring,3,requires,jdk,1,5,anyway,return,the,new,set,instance,deprecated,as,of,spring,3,0,for,usage,on,jdk,1,5,or,higher;deprecated,public,static,t,set,t,create,copy,on,write,set,return,new,copy,on,write,array,set,t
CollectionFactory -> @Deprecated 	public static <T> Set<T> createCopyOnWriteSet();1346774041;Create a copy-on-write Set (allowing for synchronization-less iteration) if possible:_This implementation always creates a {@link java.util.concurrent.CopyOnWriteArraySet},_since Spring 3 requires JDK 1.5 anyway._@return the new Set instance_@deprecated as of Spring 3.0, for usage on JDK 1.5 or higher;@Deprecated_	public static <T> Set<T> createCopyOnWriteSet() {_		return new CopyOnWriteArraySet<T>()__	};create,a,copy,on,write,set,allowing,for,synchronization,less,iteration,if,possible,this,implementation,always,creates,a,link,java,util,concurrent,copy,on,write,array,set,since,spring,3,requires,jdk,1,5,anyway,return,the,new,set,instance,deprecated,as,of,spring,3,0,for,usage,on,jdk,1,5,or,higher;deprecated,public,static,t,set,t,create,copy,on,write,set,return,new,copy,on,write,array,set,t
CollectionFactory -> @Deprecated 	public static <T> Set<T> createCopyOnWriteSet();1346774711;Create a copy-on-write Set (allowing for synchronization-less iteration) if possible:_This implementation always creates a {@link java.util.concurrent.CopyOnWriteArraySet},_since Spring 3 requires JDK 1.5 anyway._@return the new Set instance_@deprecated as of Spring 3.0, for usage on JDK 1.5 or higher;@Deprecated_	public static <T> Set<T> createCopyOnWriteSet() {_		return new CopyOnWriteArraySet<T>()__	};create,a,copy,on,write,set,allowing,for,synchronization,less,iteration,if,possible,this,implementation,always,creates,a,link,java,util,concurrent,copy,on,write,array,set,since,spring,3,requires,jdk,1,5,anyway,return,the,new,set,instance,deprecated,as,of,spring,3,0,for,usage,on,jdk,1,5,or,higher;deprecated,public,static,t,set,t,create,copy,on,write,set,return,new,copy,on,write,array,set,t
CollectionFactory -> @Deprecated 	public static <T> Set<T> createCopyOnWriteSet();1349903156;Create a copy-on-write Set (allowing for synchronization-less iteration) if possible:_This implementation always creates a {@link java.util.concurrent.CopyOnWriteArraySet},_since Spring 3 requires JDK 1.5 anyway._@return the new Set instance_@deprecated as of Spring 3.0, for usage on JDK 1.5 or higher;@Deprecated_	public static <T> Set<T> createCopyOnWriteSet() {_		return new CopyOnWriteArraySet<T>()__	};create,a,copy,on,write,set,allowing,for,synchronization,less,iteration,if,possible,this,implementation,always,creates,a,link,java,util,concurrent,copy,on,write,array,set,since,spring,3,requires,jdk,1,5,anyway,return,the,new,set,instance,deprecated,as,of,spring,3,0,for,usage,on,jdk,1,5,or,higher;deprecated,public,static,t,set,t,create,copy,on,write,set,return,new,copy,on,write,array,set,t
CollectionFactory -> @Deprecated 	public static <T> Set<T> createCopyOnWriteSet();1355313310;Create a copy-on-write Set (allowing for synchronization-less iteration) if possible:_This implementation always creates a {@link java.util.concurrent.CopyOnWriteArraySet},_since Spring 3 requires JDK 1.5 anyway._@return the new Set instance_@deprecated as of Spring 3.0, for usage on JDK 1.5 or higher;@Deprecated_	public static <T> Set<T> createCopyOnWriteSet() {_		return new CopyOnWriteArraySet<T>()__	};create,a,copy,on,write,set,allowing,for,synchronization,less,iteration,if,possible,this,implementation,always,creates,a,link,java,util,concurrent,copy,on,write,array,set,since,spring,3,requires,jdk,1,5,anyway,return,the,new,set,instance,deprecated,as,of,spring,3,0,for,usage,on,jdk,1,5,or,higher;deprecated,public,static,t,set,t,create,copy,on,write,set,return,new,copy,on,write,array,set,t
CollectionFactory -> @Deprecated 	public static <T> Set<T> createCopyOnWriteSet();1356735495;Create a copy-on-write Set (allowing for synchronization-less iteration) if possible:_This implementation always creates a {@link java.util.concurrent.CopyOnWriteArraySet},_since Spring 3 requires JDK 1.5 anyway._@return the new Set instance_@deprecated as of Spring 3.0, for usage on JDK 1.5 or higher;@Deprecated_	public static <T> Set<T> createCopyOnWriteSet() {_		return new CopyOnWriteArraySet<T>()__	};create,a,copy,on,write,set,allowing,for,synchronization,less,iteration,if,possible,this,implementation,always,creates,a,link,java,util,concurrent,copy,on,write,array,set,since,spring,3,requires,jdk,1,5,anyway,return,the,new,set,instance,deprecated,as,of,spring,3,0,for,usage,on,jdk,1,5,or,higher;deprecated,public,static,t,set,t,create,copy,on,write,set,return,new,copy,on,write,array,set,t
CollectionFactory -> public static Map createMap(Class<?> mapType, int initialCapacity);1328020251;Create the most approximate map for the given map._<p>Creates a TreeMap or linked Map for a SortedMap or Map, respectively._@param collectionType the desired type of the target Map_@param initialCapacity the initial capacity_@return the new Map instance_@see java.util.TreeMap_@see java.util.LinkedHashMap;public static Map createMap(Class<?> mapType, int initialCapacity) {_		if (mapType.isInterface()) {_			if (Map.class.equals(mapType)) {_				return new LinkedHashMap(initialCapacity)__			}_			else if (SortedMap.class.equals(mapType) || mapType.equals(navigableMapClass)) {_				return new TreeMap()__			}_			else {_				throw new IllegalArgumentException("Unsupported Map interface: " + mapType.getName())__			}_		}_		else {_			if (!Map.class.isAssignableFrom(mapType)) {_				throw new IllegalArgumentException("Unsupported Map type: " + mapType.getName())__			}_			try {_				return (Map) mapType.newInstance()__			}_			catch (Exception ex) {_				throw new IllegalArgumentException("Could not instantiate Map type: " + mapType.getName())__			}_		}_	};create,the,most,approximate,map,for,the,given,map,p,creates,a,tree,map,or,linked,map,for,a,sorted,map,or,map,respectively,param,collection,type,the,desired,type,of,the,target,map,param,initial,capacity,the,initial,capacity,return,the,new,map,instance,see,java,util,tree,map,see,java,util,linked,hash,map;public,static,map,create,map,class,map,type,int,initial,capacity,if,map,type,is,interface,if,map,class,equals,map,type,return,new,linked,hash,map,initial,capacity,else,if,sorted,map,class,equals,map,type,map,type,equals,navigable,map,class,return,new,tree,map,else,throw,new,illegal,argument,exception,unsupported,map,interface,map,type,get,name,else,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,unsupported,map,type,map,type,get,name,try,return,map,map,type,new,instance,catch,exception,ex,throw,new,illegal,argument,exception,could,not,instantiate,map,type,map,type,get,name
CollectionFactory -> public static Map createMap(Class<?> mapType, int initialCapacity);1346774041;Create the most approximate map for the given map._<p>Creates a TreeMap or linked Map for a SortedMap or Map, respectively._@param collectionType the desired type of the target Map_@param initialCapacity the initial capacity_@return the new Map instance_@see java.util.TreeMap_@see java.util.LinkedHashMap;public static Map createMap(Class<?> mapType, int initialCapacity) {_		if (mapType.isInterface()) {_			if (Map.class.equals(mapType)) {_				return new LinkedHashMap(initialCapacity)__			}_			else if (SortedMap.class.equals(mapType) || mapType.equals(navigableMapClass)) {_				return new TreeMap()__			}_			else if (MultiValueMap.class.equals(mapType)) {_				return new LinkedMultiValueMap()__			}_			else {_				throw new IllegalArgumentException("Unsupported Map interface: " + mapType.getName())__			}_		}_		else {_			if (!Map.class.isAssignableFrom(mapType)) {_				throw new IllegalArgumentException("Unsupported Map type: " + mapType.getName())__			}_			try {_				return (Map) mapType.newInstance()__			}_			catch (Exception ex) {_				throw new IllegalArgumentException("Could not instantiate Map type: " + mapType.getName())__			}_		}_	};create,the,most,approximate,map,for,the,given,map,p,creates,a,tree,map,or,linked,map,for,a,sorted,map,or,map,respectively,param,collection,type,the,desired,type,of,the,target,map,param,initial,capacity,the,initial,capacity,return,the,new,map,instance,see,java,util,tree,map,see,java,util,linked,hash,map;public,static,map,create,map,class,map,type,int,initial,capacity,if,map,type,is,interface,if,map,class,equals,map,type,return,new,linked,hash,map,initial,capacity,else,if,sorted,map,class,equals,map,type,map,type,equals,navigable,map,class,return,new,tree,map,else,if,multi,value,map,class,equals,map,type,return,new,linked,multi,value,map,else,throw,new,illegal,argument,exception,unsupported,map,interface,map,type,get,name,else,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,unsupported,map,type,map,type,get,name,try,return,map,map,type,new,instance,catch,exception,ex,throw,new,illegal,argument,exception,could,not,instantiate,map,type,map,type,get,name
CollectionFactory -> public static Map createMap(Class<?> mapType, int initialCapacity);1346774711;Create the most approximate map for the given map._<p>Creates a TreeMap or linked Map for a SortedMap or Map, respectively._@param collectionType the desired type of the target Map_@param initialCapacity the initial capacity_@return the new Map instance_@see java.util.TreeMap_@see java.util.LinkedHashMap;public static Map createMap(Class<?> mapType, int initialCapacity) {_		if (mapType.isInterface()) {_			if (Map.class.equals(mapType)) {_				return new LinkedHashMap(initialCapacity)__			}_			else if (SortedMap.class.equals(mapType) || mapType.equals(navigableMapClass)) {_				return new TreeMap()__			}_			else if (MultiValueMap.class.equals(mapType)) {_				return new LinkedMultiValueMap()__			}_			else {_				throw new IllegalArgumentException("Unsupported Map interface: " + mapType.getName())__			}_		}_		else {_			if (!Map.class.isAssignableFrom(mapType)) {_				throw new IllegalArgumentException("Unsupported Map type: " + mapType.getName())__			}_			try {_				return (Map) mapType.newInstance()__			}_			catch (Exception ex) {_				throw new IllegalArgumentException("Could not instantiate Map type: " + mapType.getName())__			}_		}_	};create,the,most,approximate,map,for,the,given,map,p,creates,a,tree,map,or,linked,map,for,a,sorted,map,or,map,respectively,param,collection,type,the,desired,type,of,the,target,map,param,initial,capacity,the,initial,capacity,return,the,new,map,instance,see,java,util,tree,map,see,java,util,linked,hash,map;public,static,map,create,map,class,map,type,int,initial,capacity,if,map,type,is,interface,if,map,class,equals,map,type,return,new,linked,hash,map,initial,capacity,else,if,sorted,map,class,equals,map,type,map,type,equals,navigable,map,class,return,new,tree,map,else,if,multi,value,map,class,equals,map,type,return,new,linked,multi,value,map,else,throw,new,illegal,argument,exception,unsupported,map,interface,map,type,get,name,else,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,unsupported,map,type,map,type,get,name,try,return,map,map,type,new,instance,catch,exception,ex,throw,new,illegal,argument,exception,could,not,instantiate,map,type,map,type,get,name
CollectionFactory -> public static Map createMap(Class<?> mapType, int initialCapacity);1349903156;Create the most approximate map for the given map._<p>Creates a TreeMap or linked Map for a SortedMap or Map, respectively._@param collectionType the desired type of the target Map_@param initialCapacity the initial capacity_@return the new Map instance_@see java.util.TreeMap_@see java.util.LinkedHashMap;public static Map createMap(Class<?> mapType, int initialCapacity) {_		if (mapType.isInterface()) {_			if (Map.class.equals(mapType)) {_				return new LinkedHashMap(initialCapacity)__			}_			else if (SortedMap.class.equals(mapType) || mapType.equals(navigableMapClass)) {_				return new TreeMap()__			}_			else if (MultiValueMap.class.equals(mapType)) {_				return new LinkedMultiValueMap()__			}_			else {_				throw new IllegalArgumentException("Unsupported Map interface: " + mapType.getName())__			}_		}_		else {_			if (!Map.class.isAssignableFrom(mapType)) {_				throw new IllegalArgumentException("Unsupported Map type: " + mapType.getName())__			}_			try {_				return (Map) mapType.newInstance()__			}_			catch (Exception ex) {_				throw new IllegalArgumentException("Could not instantiate Map type: " +_						mapType.getName(), ex)__			}_		}_	};create,the,most,approximate,map,for,the,given,map,p,creates,a,tree,map,or,linked,map,for,a,sorted,map,or,map,respectively,param,collection,type,the,desired,type,of,the,target,map,param,initial,capacity,the,initial,capacity,return,the,new,map,instance,see,java,util,tree,map,see,java,util,linked,hash,map;public,static,map,create,map,class,map,type,int,initial,capacity,if,map,type,is,interface,if,map,class,equals,map,type,return,new,linked,hash,map,initial,capacity,else,if,sorted,map,class,equals,map,type,map,type,equals,navigable,map,class,return,new,tree,map,else,if,multi,value,map,class,equals,map,type,return,new,linked,multi,value,map,else,throw,new,illegal,argument,exception,unsupported,map,interface,map,type,get,name,else,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,unsupported,map,type,map,type,get,name,try,return,map,map,type,new,instance,catch,exception,ex,throw,new,illegal,argument,exception,could,not,instantiate,map,type,map,type,get,name,ex
CollectionFactory -> public static Map createMap(Class<?> mapType, int initialCapacity);1355313310;Create the most approximate map for the given map._<p>Creates a TreeMap or linked Map for a SortedMap or Map, respectively._@param mapType the desired type of the target Map_@param initialCapacity the initial capacity_@return the new Map instance_@see java.util.TreeMap_@see java.util.LinkedHashMap;public static Map createMap(Class<?> mapType, int initialCapacity) {_		if (mapType.isInterface()) {_			if (Map.class.equals(mapType)) {_				return new LinkedHashMap(initialCapacity)__			}_			else if (SortedMap.class.equals(mapType) || mapType.equals(navigableMapClass)) {_				return new TreeMap()__			}_			else if (MultiValueMap.class.equals(mapType)) {_				return new LinkedMultiValueMap()__			}_			else {_				throw new IllegalArgumentException("Unsupported Map interface: " + mapType.getName())__			}_		}_		else {_			if (!Map.class.isAssignableFrom(mapType)) {_				throw new IllegalArgumentException("Unsupported Map type: " + mapType.getName())__			}_			try {_				return (Map) mapType.newInstance()__			}_			catch (Exception ex) {_				throw new IllegalArgumentException("Could not instantiate Map type: " +_						mapType.getName(), ex)__			}_		}_	};create,the,most,approximate,map,for,the,given,map,p,creates,a,tree,map,or,linked,map,for,a,sorted,map,or,map,respectively,param,map,type,the,desired,type,of,the,target,map,param,initial,capacity,the,initial,capacity,return,the,new,map,instance,see,java,util,tree,map,see,java,util,linked,hash,map;public,static,map,create,map,class,map,type,int,initial,capacity,if,map,type,is,interface,if,map,class,equals,map,type,return,new,linked,hash,map,initial,capacity,else,if,sorted,map,class,equals,map,type,map,type,equals,navigable,map,class,return,new,tree,map,else,if,multi,value,map,class,equals,map,type,return,new,linked,multi,value,map,else,throw,new,illegal,argument,exception,unsupported,map,interface,map,type,get,name,else,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,unsupported,map,type,map,type,get,name,try,return,map,map,type,new,instance,catch,exception,ex,throw,new,illegal,argument,exception,could,not,instantiate,map,type,map,type,get,name,ex
CollectionFactory -> public static Map createMap(Class<?> mapType, int initialCapacity);1356735495;Create the most approximate map for the given map._<p>Creates a TreeMap or linked Map for a SortedMap or Map, respectively._@param mapType the desired type of the target Map_@param initialCapacity the initial capacity_@return the new Map instance_@see java.util.TreeMap_@see java.util.LinkedHashMap;public static Map createMap(Class<?> mapType, int initialCapacity) {_		if (mapType.isInterface()) {_			if (Map.class.equals(mapType)) {_				return new LinkedHashMap(initialCapacity)__			}_			else if (SortedMap.class.equals(mapType) || mapType.equals(navigableMapClass)) {_				return new TreeMap()__			}_			else if (MultiValueMap.class.equals(mapType)) {_				return new LinkedMultiValueMap()__			}_			else {_				throw new IllegalArgumentException("Unsupported Map interface: " + mapType.getName())__			}_		}_		else {_			if (!Map.class.isAssignableFrom(mapType)) {_				throw new IllegalArgumentException("Unsupported Map type: " + mapType.getName())__			}_			try {_				return (Map) mapType.newInstance()__			}_			catch (Exception ex) {_				throw new IllegalArgumentException("Could not instantiate Map type: " +_						mapType.getName(), ex)__			}_		}_	};create,the,most,approximate,map,for,the,given,map,p,creates,a,tree,map,or,linked,map,for,a,sorted,map,or,map,respectively,param,map,type,the,desired,type,of,the,target,map,param,initial,capacity,the,initial,capacity,return,the,new,map,instance,see,java,util,tree,map,see,java,util,linked,hash,map;public,static,map,create,map,class,map,type,int,initial,capacity,if,map,type,is,interface,if,map,class,equals,map,type,return,new,linked,hash,map,initial,capacity,else,if,sorted,map,class,equals,map,type,map,type,equals,navigable,map,class,return,new,tree,map,else,if,multi,value,map,class,equals,map,type,return,new,linked,multi,value,map,else,throw,new,illegal,argument,exception,unsupported,map,interface,map,type,get,name,else,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,unsupported,map,type,map,type,get,name,try,return,map,map,type,new,instance,catch,exception,ex,throw,new,illegal,argument,exception,could,not,instantiate,map,type,map,type,get,name,ex
CollectionFactory -> public static Map createMap(Class<?> mapType, int initialCapacity);1364509637;Create the most approximate map for the given map._<p>Creates a TreeMap or linked Map for a SortedMap or Map, respectively._@param mapType the desired type of the target Map_@param initialCapacity the initial capacity_@return the new Map instance_@see java.util.TreeMap_@see java.util.LinkedHashMap;public static Map createMap(Class<?> mapType, int initialCapacity) {_		if (mapType.isInterface()) {_			if (Map.class.equals(mapType)) {_				return new LinkedHashMap(initialCapacity)__			}_			else if (SortedMap.class.equals(mapType) || mapType.equals(navigableMapClass)) {_				return new TreeMap()__			}_			else if (MultiValueMap.class.equals(mapType)) {_				return new LinkedMultiValueMap()__			}_			else {_				throw new IllegalArgumentException("Unsupported Map interface: " + mapType.getName())__			}_		}_		else {_			if (!Map.class.isAssignableFrom(mapType)) {_				throw new IllegalArgumentException("Unsupported Map type: " + mapType.getName())__			}_			try {_				return (Map) mapType.newInstance()__			}_			catch (Exception ex) {_				throw new IllegalArgumentException("Could not instantiate Map type: " +_						mapType.getName(), ex)__			}_		}_	};create,the,most,approximate,map,for,the,given,map,p,creates,a,tree,map,or,linked,map,for,a,sorted,map,or,map,respectively,param,map,type,the,desired,type,of,the,target,map,param,initial,capacity,the,initial,capacity,return,the,new,map,instance,see,java,util,tree,map,see,java,util,linked,hash,map;public,static,map,create,map,class,map,type,int,initial,capacity,if,map,type,is,interface,if,map,class,equals,map,type,return,new,linked,hash,map,initial,capacity,else,if,sorted,map,class,equals,map,type,map,type,equals,navigable,map,class,return,new,tree,map,else,if,multi,value,map,class,equals,map,type,return,new,linked,multi,value,map,else,throw,new,illegal,argument,exception,unsupported,map,interface,map,type,get,name,else,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,unsupported,map,type,map,type,get,name,try,return,map,map,type,new,instance,catch,exception,ex,throw,new,illegal,argument,exception,could,not,instantiate,map,type,map,type,get,name,ex
CollectionFactory -> @SuppressWarnings("unchecked") 	public static <E> Collection<E> createCollection(Class<?> collectionClass, Class<?> elementType, int capacity);1417203046;Create the most appropriate collection for the given collection type._@param collectionClass the desired type of the target Collection_@param elementType the collection's element type, or {@code null} if not known_@param capacity the initial capacity_@return the new Collection instance_@see java.util.LinkedHashSet_@see java.util.TreeSet_@see java.util.EnumSet_@see java.util.ArrayList;@SuppressWarnings("unchecked")_	public static <E> Collection<E> createCollection(Class<?> collectionClass, Class<?> elementType, int capacity) {_		if (collectionClass.isInterface()) {_			if (Set.class.equals(collectionClass) || Collection.class.equals(collectionClass)) {_				return new LinkedHashSet<E>(capacity)__			}_			else if (List.class.equals(collectionClass)) {_				return new ArrayList<E>(capacity)__			}_			else if (SortedSet.class.equals(collectionClass) || NavigableSet.class.equals(collectionClass)) {_				return new TreeSet<E>()__			}_			else {_				throw new IllegalArgumentException("Unsupported Collection interface: " + collectionClass.getName())__			}_		}_		else if (EnumSet.class.equals(collectionClass)) {_			Assert.notNull(elementType, "Cannot create EnumSet for unknown element type")__			return EnumSet.noneOf((Class) elementType)__		}_		else {_			if (!Collection.class.isAssignableFrom(collectionClass)) {_				throw new IllegalArgumentException("Unsupported Collection type: " + collectionClass.getName())__			}_			try {_				return (Collection<E>) collectionClass.newInstance()__			}_			catch (Exception ex) {_				throw new IllegalArgumentException(_						"Could not instantiate Collection type: " + collectionClass.getName(), ex)__			}_		}_	};create,the,most,appropriate,collection,for,the,given,collection,type,param,collection,class,the,desired,type,of,the,target,collection,param,element,type,the,collection,s,element,type,or,code,null,if,not,known,param,capacity,the,initial,capacity,return,the,new,collection,instance,see,java,util,linked,hash,set,see,java,util,tree,set,see,java,util,enum,set,see,java,util,array,list;suppress,warnings,unchecked,public,static,e,collection,e,create,collection,class,collection,class,class,element,type,int,capacity,if,collection,class,is,interface,if,set,class,equals,collection,class,collection,class,equals,collection,class,return,new,linked,hash,set,e,capacity,else,if,list,class,equals,collection,class,return,new,array,list,e,capacity,else,if,sorted,set,class,equals,collection,class,navigable,set,class,equals,collection,class,return,new,tree,set,e,else,throw,new,illegal,argument,exception,unsupported,collection,interface,collection,class,get,name,else,if,enum,set,class,equals,collection,class,assert,not,null,element,type,cannot,create,enum,set,for,unknown,element,type,return,enum,set,none,of,class,element,type,else,if,collection,class,is,assignable,from,collection,class,throw,new,illegal,argument,exception,unsupported,collection,type,collection,class,get,name,try,return,collection,e,collection,class,new,instance,catch,exception,ex,throw,new,illegal,argument,exception,could,not,instantiate,collection,type,collection,class,get,name,ex
CollectionFactory -> @SuppressWarnings("unchecked") 	public static <E> Collection<E> createCollection(Class<?> collectionClass, Class<?> elementType, int capacity);1417290546;Create the most appropriate collection for the given collection type._@param collectionClass the desired type of the target Collection_@param elementType the collection's element type, or {@code null} if not known_(note: only relevant for {@link EnumSet} creation)_@param capacity the initial capacity_@return the new Collection instance_@since 4.1.3_@see java.util.LinkedHashSet_@see java.util.TreeSet_@see java.util.EnumSet_@see java.util.ArrayList;@SuppressWarnings("unchecked")_	public static <E> Collection<E> createCollection(Class<?> collectionClass, Class<?> elementType, int capacity) {_		if (collectionClass.isInterface()) {_			if (Set.class.equals(collectionClass) || Collection.class.equals(collectionClass)) {_				return new LinkedHashSet<E>(capacity)__			}_			else if (List.class.equals(collectionClass)) {_				return new ArrayList<E>(capacity)__			}_			else if (SortedSet.class.equals(collectionClass) || NavigableSet.class.equals(collectionClass)) {_				return new TreeSet<E>()__			}_			else {_				throw new IllegalArgumentException("Unsupported Collection interface: " + collectionClass.getName())__			}_		}_		else if (EnumSet.class.equals(collectionClass)) {_			Assert.notNull(elementType, "Cannot create EnumSet for unknown element type")__			return EnumSet.noneOf((Class) elementType)__		}_		else {_			if (!Collection.class.isAssignableFrom(collectionClass)) {_				throw new IllegalArgumentException("Unsupported Collection type: " + collectionClass.getName())__			}_			try {_				return (Collection<E>) collectionClass.newInstance()__			}_			catch (Exception ex) {_				throw new IllegalArgumentException(_						"Could not instantiate Collection type: " + collectionClass.getName(), ex)__			}_		}_	};create,the,most,appropriate,collection,for,the,given,collection,type,param,collection,class,the,desired,type,of,the,target,collection,param,element,type,the,collection,s,element,type,or,code,null,if,not,known,note,only,relevant,for,link,enum,set,creation,param,capacity,the,initial,capacity,return,the,new,collection,instance,since,4,1,3,see,java,util,linked,hash,set,see,java,util,tree,set,see,java,util,enum,set,see,java,util,array,list;suppress,warnings,unchecked,public,static,e,collection,e,create,collection,class,collection,class,class,element,type,int,capacity,if,collection,class,is,interface,if,set,class,equals,collection,class,collection,class,equals,collection,class,return,new,linked,hash,set,e,capacity,else,if,list,class,equals,collection,class,return,new,array,list,e,capacity,else,if,sorted,set,class,equals,collection,class,navigable,set,class,equals,collection,class,return,new,tree,set,e,else,throw,new,illegal,argument,exception,unsupported,collection,interface,collection,class,get,name,else,if,enum,set,class,equals,collection,class,assert,not,null,element,type,cannot,create,enum,set,for,unknown,element,type,return,enum,set,none,of,class,element,type,else,if,collection,class,is,assignable,from,collection,class,throw,new,illegal,argument,exception,unsupported,collection,type,collection,class,get,name,try,return,collection,e,collection,class,new,instance,catch,exception,ex,throw,new,illegal,argument,exception,could,not,instantiate,collection,type,collection,class,get,name,ex
CollectionFactory -> public static Collection createCollection(Class<?> collectionType, int initialCapacity);1328020251;Create the most appropriate collection for the given collection type._<p>Creates an ArrayList, TreeSet or linked Set for a List, SortedSet_or Set, respectively._@param collectionType the desired type of the target Collection_@param initialCapacity the initial capacity_@return the new Collection instance_@see java.util.ArrayList_@see java.util.TreeSet_@see java.util.LinkedHashSet;public static Collection createCollection(Class<?> collectionType, int initialCapacity) {_		if (collectionType.isInterface()) {_			if (List.class.equals(collectionType)) {_				return new ArrayList(initialCapacity)__			}_			else if (SortedSet.class.equals(collectionType) || collectionType.equals(navigableSetClass)) {_				return new TreeSet()__			}_			else if (Set.class.equals(collectionType) || Collection.class.equals(collectionType)) {_				return new LinkedHashSet(initialCapacity)__			}_			else {_				throw new IllegalArgumentException("Unsupported Collection interface: " + collectionType.getName())__			}_		}_		else {_			if (!Collection.class.isAssignableFrom(collectionType)) {_				throw new IllegalArgumentException("Unsupported Collection type: " + collectionType.getName())__			}_			try {_				return (Collection) collectionType.newInstance()__			}_			catch (Exception ex) {_				throw new IllegalArgumentException("Could not instantiate Collection type: " + collectionType.getName())__			}_		}_	};create,the,most,appropriate,collection,for,the,given,collection,type,p,creates,an,array,list,tree,set,or,linked,set,for,a,list,sorted,set,or,set,respectively,param,collection,type,the,desired,type,of,the,target,collection,param,initial,capacity,the,initial,capacity,return,the,new,collection,instance,see,java,util,array,list,see,java,util,tree,set,see,java,util,linked,hash,set;public,static,collection,create,collection,class,collection,type,int,initial,capacity,if,collection,type,is,interface,if,list,class,equals,collection,type,return,new,array,list,initial,capacity,else,if,sorted,set,class,equals,collection,type,collection,type,equals,navigable,set,class,return,new,tree,set,else,if,set,class,equals,collection,type,collection,class,equals,collection,type,return,new,linked,hash,set,initial,capacity,else,throw,new,illegal,argument,exception,unsupported,collection,interface,collection,type,get,name,else,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,unsupported,collection,type,collection,type,get,name,try,return,collection,collection,type,new,instance,catch,exception,ex,throw,new,illegal,argument,exception,could,not,instantiate,collection,type,collection,type,get,name
CollectionFactory -> public static Collection createCollection(Class<?> collectionType, int initialCapacity);1346774041;Create the most appropriate collection for the given collection type._<p>Creates an ArrayList, TreeSet or linked Set for a List, SortedSet_or Set, respectively._@param collectionType the desired type of the target Collection_@param initialCapacity the initial capacity_@return the new Collection instance_@see java.util.ArrayList_@see java.util.TreeSet_@see java.util.LinkedHashSet;public static Collection createCollection(Class<?> collectionType, int initialCapacity) {_		if (collectionType.isInterface()) {_			if (List.class.equals(collectionType)) {_				return new ArrayList(initialCapacity)__			}_			else if (SortedSet.class.equals(collectionType) || collectionType.equals(navigableSetClass)) {_				return new TreeSet()__			}_			else if (Set.class.equals(collectionType) || Collection.class.equals(collectionType)) {_				return new LinkedHashSet(initialCapacity)__			}_			else {_				throw new IllegalArgumentException("Unsupported Collection interface: " + collectionType.getName())__			}_		}_		else {_			if (!Collection.class.isAssignableFrom(collectionType)) {_				throw new IllegalArgumentException("Unsupported Collection type: " + collectionType.getName())__			}_			try {_				return (Collection) collectionType.newInstance()__			}_			catch (Exception ex) {_				throw new IllegalArgumentException("Could not instantiate Collection type: " + collectionType.getName())__			}_		}_	};create,the,most,appropriate,collection,for,the,given,collection,type,p,creates,an,array,list,tree,set,or,linked,set,for,a,list,sorted,set,or,set,respectively,param,collection,type,the,desired,type,of,the,target,collection,param,initial,capacity,the,initial,capacity,return,the,new,collection,instance,see,java,util,array,list,see,java,util,tree,set,see,java,util,linked,hash,set;public,static,collection,create,collection,class,collection,type,int,initial,capacity,if,collection,type,is,interface,if,list,class,equals,collection,type,return,new,array,list,initial,capacity,else,if,sorted,set,class,equals,collection,type,collection,type,equals,navigable,set,class,return,new,tree,set,else,if,set,class,equals,collection,type,collection,class,equals,collection,type,return,new,linked,hash,set,initial,capacity,else,throw,new,illegal,argument,exception,unsupported,collection,interface,collection,type,get,name,else,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,unsupported,collection,type,collection,type,get,name,try,return,collection,collection,type,new,instance,catch,exception,ex,throw,new,illegal,argument,exception,could,not,instantiate,collection,type,collection,type,get,name
CollectionFactory -> public static Collection createCollection(Class<?> collectionType, int initialCapacity);1346774711;Create the most appropriate collection for the given collection type._<p>Creates an ArrayList, TreeSet or linked Set for a List, SortedSet_or Set, respectively._@param collectionType the desired type of the target Collection_@param initialCapacity the initial capacity_@return the new Collection instance_@see java.util.ArrayList_@see java.util.TreeSet_@see java.util.LinkedHashSet;public static Collection createCollection(Class<?> collectionType, int initialCapacity) {_		if (collectionType.isInterface()) {_			if (List.class.equals(collectionType)) {_				return new ArrayList(initialCapacity)__			}_			else if (SortedSet.class.equals(collectionType) || collectionType.equals(navigableSetClass)) {_				return new TreeSet()__			}_			else if (Set.class.equals(collectionType) || Collection.class.equals(collectionType)) {_				return new LinkedHashSet(initialCapacity)__			}_			else {_				throw new IllegalArgumentException("Unsupported Collection interface: " + collectionType.getName())__			}_		}_		else {_			if (!Collection.class.isAssignableFrom(collectionType)) {_				throw new IllegalArgumentException("Unsupported Collection type: " + collectionType.getName())__			}_			try {_				return (Collection) collectionType.newInstance()__			}_			catch (Exception ex) {_				throw new IllegalArgumentException("Could not instantiate Collection type: " + collectionType.getName())__			}_		}_	};create,the,most,appropriate,collection,for,the,given,collection,type,p,creates,an,array,list,tree,set,or,linked,set,for,a,list,sorted,set,or,set,respectively,param,collection,type,the,desired,type,of,the,target,collection,param,initial,capacity,the,initial,capacity,return,the,new,collection,instance,see,java,util,array,list,see,java,util,tree,set,see,java,util,linked,hash,set;public,static,collection,create,collection,class,collection,type,int,initial,capacity,if,collection,type,is,interface,if,list,class,equals,collection,type,return,new,array,list,initial,capacity,else,if,sorted,set,class,equals,collection,type,collection,type,equals,navigable,set,class,return,new,tree,set,else,if,set,class,equals,collection,type,collection,class,equals,collection,type,return,new,linked,hash,set,initial,capacity,else,throw,new,illegal,argument,exception,unsupported,collection,interface,collection,type,get,name,else,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,unsupported,collection,type,collection,type,get,name,try,return,collection,collection,type,new,instance,catch,exception,ex,throw,new,illegal,argument,exception,could,not,instantiate,collection,type,collection,type,get,name
CollectionFactory -> public static Collection createCollection(Class<?> collectionType, int initialCapacity);1349903156;Create the most appropriate collection for the given collection type._<p>Creates an ArrayList, TreeSet or linked Set for a List, SortedSet_or Set, respectively._@param collectionType the desired type of the target Collection_@param initialCapacity the initial capacity_@return the new Collection instance_@see java.util.ArrayList_@see java.util.TreeSet_@see java.util.LinkedHashSet;public static Collection createCollection(Class<?> collectionType, int initialCapacity) {_		if (collectionType.isInterface()) {_			if (List.class.equals(collectionType)) {_				return new ArrayList(initialCapacity)__			}_			else if (SortedSet.class.equals(collectionType) || collectionType.equals(navigableSetClass)) {_				return new TreeSet()__			}_			else if (Set.class.equals(collectionType) || Collection.class.equals(collectionType)) {_				return new LinkedHashSet(initialCapacity)__			}_			else {_				throw new IllegalArgumentException("Unsupported Collection interface: " + collectionType.getName())__			}_		}_		else {_			if (!Collection.class.isAssignableFrom(collectionType)) {_				throw new IllegalArgumentException("Unsupported Collection type: " + collectionType.getName())__			}_			try {_				return (Collection) collectionType.newInstance()__			}_			catch (Exception ex) {_				throw new IllegalArgumentException("Could not instantiate Collection type: " +_						collectionType.getName(), ex)__			}_		}_	};create,the,most,appropriate,collection,for,the,given,collection,type,p,creates,an,array,list,tree,set,or,linked,set,for,a,list,sorted,set,or,set,respectively,param,collection,type,the,desired,type,of,the,target,collection,param,initial,capacity,the,initial,capacity,return,the,new,collection,instance,see,java,util,array,list,see,java,util,tree,set,see,java,util,linked,hash,set;public,static,collection,create,collection,class,collection,type,int,initial,capacity,if,collection,type,is,interface,if,list,class,equals,collection,type,return,new,array,list,initial,capacity,else,if,sorted,set,class,equals,collection,type,collection,type,equals,navigable,set,class,return,new,tree,set,else,if,set,class,equals,collection,type,collection,class,equals,collection,type,return,new,linked,hash,set,initial,capacity,else,throw,new,illegal,argument,exception,unsupported,collection,interface,collection,type,get,name,else,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,unsupported,collection,type,collection,type,get,name,try,return,collection,collection,type,new,instance,catch,exception,ex,throw,new,illegal,argument,exception,could,not,instantiate,collection,type,collection,type,get,name,ex
CollectionFactory -> public static Collection createCollection(Class<?> collectionType, int initialCapacity);1355313310;Create the most appropriate collection for the given collection type._<p>Creates an ArrayList, TreeSet or linked Set for a List, SortedSet_or Set, respectively._@param collectionType the desired type of the target Collection_@param initialCapacity the initial capacity_@return the new Collection instance_@see java.util.ArrayList_@see java.util.TreeSet_@see java.util.LinkedHashSet;public static Collection createCollection(Class<?> collectionType, int initialCapacity) {_		if (collectionType.isInterface()) {_			if (List.class.equals(collectionType)) {_				return new ArrayList(initialCapacity)__			}_			else if (SortedSet.class.equals(collectionType) || collectionType.equals(navigableSetClass)) {_				return new TreeSet()__			}_			else if (Set.class.equals(collectionType) || Collection.class.equals(collectionType)) {_				return new LinkedHashSet(initialCapacity)__			}_			else {_				throw new IllegalArgumentException("Unsupported Collection interface: " + collectionType.getName())__			}_		}_		else {_			if (!Collection.class.isAssignableFrom(collectionType)) {_				throw new IllegalArgumentException("Unsupported Collection type: " + collectionType.getName())__			}_			try {_				return (Collection) collectionType.newInstance()__			}_			catch (Exception ex) {_				throw new IllegalArgumentException("Could not instantiate Collection type: " +_						collectionType.getName(), ex)__			}_		}_	};create,the,most,appropriate,collection,for,the,given,collection,type,p,creates,an,array,list,tree,set,or,linked,set,for,a,list,sorted,set,or,set,respectively,param,collection,type,the,desired,type,of,the,target,collection,param,initial,capacity,the,initial,capacity,return,the,new,collection,instance,see,java,util,array,list,see,java,util,tree,set,see,java,util,linked,hash,set;public,static,collection,create,collection,class,collection,type,int,initial,capacity,if,collection,type,is,interface,if,list,class,equals,collection,type,return,new,array,list,initial,capacity,else,if,sorted,set,class,equals,collection,type,collection,type,equals,navigable,set,class,return,new,tree,set,else,if,set,class,equals,collection,type,collection,class,equals,collection,type,return,new,linked,hash,set,initial,capacity,else,throw,new,illegal,argument,exception,unsupported,collection,interface,collection,type,get,name,else,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,unsupported,collection,type,collection,type,get,name,try,return,collection,collection,type,new,instance,catch,exception,ex,throw,new,illegal,argument,exception,could,not,instantiate,collection,type,collection,type,get,name,ex
CollectionFactory -> public static Collection createCollection(Class<?> collectionType, int initialCapacity);1356735495;Create the most appropriate collection for the given collection type._<p>Creates an ArrayList, TreeSet or linked Set for a List, SortedSet_or Set, respectively._@param collectionType the desired type of the target Collection_@param initialCapacity the initial capacity_@return the new Collection instance_@see java.util.ArrayList_@see java.util.TreeSet_@see java.util.LinkedHashSet;public static Collection createCollection(Class<?> collectionType, int initialCapacity) {_		if (collectionType.isInterface()) {_			if (List.class.equals(collectionType)) {_				return new ArrayList(initialCapacity)__			}_			else if (SortedSet.class.equals(collectionType) || collectionType.equals(navigableSetClass)) {_				return new TreeSet()__			}_			else if (Set.class.equals(collectionType) || Collection.class.equals(collectionType)) {_				return new LinkedHashSet(initialCapacity)__			}_			else {_				throw new IllegalArgumentException("Unsupported Collection interface: " + collectionType.getName())__			}_		}_		else {_			if (!Collection.class.isAssignableFrom(collectionType)) {_				throw new IllegalArgumentException("Unsupported Collection type: " + collectionType.getName())__			}_			try {_				return (Collection) collectionType.newInstance()__			}_			catch (Exception ex) {_				throw new IllegalArgumentException("Could not instantiate Collection type: " +_						collectionType.getName(), ex)__			}_		}_	};create,the,most,appropriate,collection,for,the,given,collection,type,p,creates,an,array,list,tree,set,or,linked,set,for,a,list,sorted,set,or,set,respectively,param,collection,type,the,desired,type,of,the,target,collection,param,initial,capacity,the,initial,capacity,return,the,new,collection,instance,see,java,util,array,list,see,java,util,tree,set,see,java,util,linked,hash,set;public,static,collection,create,collection,class,collection,type,int,initial,capacity,if,collection,type,is,interface,if,list,class,equals,collection,type,return,new,array,list,initial,capacity,else,if,sorted,set,class,equals,collection,type,collection,type,equals,navigable,set,class,return,new,tree,set,else,if,set,class,equals,collection,type,collection,class,equals,collection,type,return,new,linked,hash,set,initial,capacity,else,throw,new,illegal,argument,exception,unsupported,collection,interface,collection,type,get,name,else,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,unsupported,collection,type,collection,type,get,name,try,return,collection,collection,type,new,instance,catch,exception,ex,throw,new,illegal,argument,exception,could,not,instantiate,collection,type,collection,type,get,name,ex
CollectionFactory -> public static Collection createCollection(Class<?> collectionType, int initialCapacity);1364509637;Create the most appropriate collection for the given collection type._<p>Creates an ArrayList, TreeSet or linked Set for a List, SortedSet_or Set, respectively._@param collectionType the desired type of the target Collection_@param initialCapacity the initial capacity_@return the new Collection instance_@see java.util.ArrayList_@see java.util.TreeSet_@see java.util.LinkedHashSet;public static Collection createCollection(Class<?> collectionType, int initialCapacity) {_		if (collectionType.isInterface()) {_			if (List.class.equals(collectionType)) {_				return new ArrayList(initialCapacity)__			}_			else if (SortedSet.class.equals(collectionType) || collectionType.equals(navigableSetClass)) {_				return new TreeSet()__			}_			else if (Set.class.equals(collectionType) || Collection.class.equals(collectionType)) {_				return new LinkedHashSet(initialCapacity)__			}_			else {_				throw new IllegalArgumentException("Unsupported Collection interface: " + collectionType.getName())__			}_		}_		else {_			if (!Collection.class.isAssignableFrom(collectionType)) {_				throw new IllegalArgumentException("Unsupported Collection type: " + collectionType.getName())__			}_			try {_				return (Collection) collectionType.newInstance()__			}_			catch (Exception ex) {_				throw new IllegalArgumentException("Could not instantiate Collection type: " +_						collectionType.getName(), ex)__			}_		}_	};create,the,most,appropriate,collection,for,the,given,collection,type,p,creates,an,array,list,tree,set,or,linked,set,for,a,list,sorted,set,or,set,respectively,param,collection,type,the,desired,type,of,the,target,collection,param,initial,capacity,the,initial,capacity,return,the,new,collection,instance,see,java,util,array,list,see,java,util,tree,set,see,java,util,linked,hash,set;public,static,collection,create,collection,class,collection,type,int,initial,capacity,if,collection,type,is,interface,if,list,class,equals,collection,type,return,new,array,list,initial,capacity,else,if,sorted,set,class,equals,collection,type,collection,type,equals,navigable,set,class,return,new,tree,set,else,if,set,class,equals,collection,type,collection,class,equals,collection,type,return,new,linked,hash,set,initial,capacity,else,throw,new,illegal,argument,exception,unsupported,collection,interface,collection,type,get,name,else,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,unsupported,collection,type,collection,type,get,name,try,return,collection,collection,type,new,instance,catch,exception,ex,throw,new,illegal,argument,exception,could,not,instantiate,collection,type,collection,type,get,name,ex
CollectionFactory -> @SuppressWarnings({ "unchecked", "cast" }) 	public static <E> Collection<E> createCollection(Class<?> collectionType, Class<?> elementType, int capacity);1418219235;Create the most appropriate collection for the given collection type._@param collectionType the desired type of the target Collection_ never {@code null}_@param elementType the collection's element type, or {@code null} if not known_(note: only relevant for {@link EnumSet} creation)_@param capacity the initial capacity_@return the new Collection instance_@since 4.1.3_@see java.util.LinkedHashSet_@see java.util.TreeSet_@see java.util.EnumSet_@see java.util.ArrayList;@SuppressWarnings({ "unchecked", "cast" })_	public static <E> Collection<E> createCollection(Class<?> collectionType, Class<?> elementType, int capacity) {_		Assert.notNull(collectionType, "Collection type must not be null")__		if (collectionType.isInterface()) {_			if (Set.class.equals(collectionType) || Collection.class.equals(collectionType)) {_				return new LinkedHashSet<E>(capacity)__			}_			else if (List.class.equals(collectionType)) {_				return new ArrayList<E>(capacity)__			}_			else if (SortedSet.class.equals(collectionType) || NavigableSet.class.equals(collectionType)) {_				return new TreeSet<E>()__			}_			else {_				throw new IllegalArgumentException("Unsupported Collection interface: " + collectionType.getName())__			}_		}_		else if (EnumSet.class.equals(collectionType)) {_			Assert.notNull(elementType, "Cannot create EnumSet for unknown element type")__			_			_			return (Collection<E>) EnumSet.noneOf(asEnumType(elementType))__		}_		else {_			if (!Collection.class.isAssignableFrom(collectionType)) {_				throw new IllegalArgumentException("Unsupported Collection type: " + collectionType.getName())__			}_			try {_				return (Collection<E>) collectionType.newInstance()__			}_			catch (Exception ex) {_				throw new IllegalArgumentException(_					"Could not instantiate Collection type: " + collectionType.getName(), ex)__			}_		}_	};create,the,most,appropriate,collection,for,the,given,collection,type,param,collection,type,the,desired,type,of,the,target,collection,never,code,null,param,element,type,the,collection,s,element,type,or,code,null,if,not,known,note,only,relevant,for,link,enum,set,creation,param,capacity,the,initial,capacity,return,the,new,collection,instance,since,4,1,3,see,java,util,linked,hash,set,see,java,util,tree,set,see,java,util,enum,set,see,java,util,array,list;suppress,warnings,unchecked,cast,public,static,e,collection,e,create,collection,class,collection,type,class,element,type,int,capacity,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,type,is,interface,if,set,class,equals,collection,type,collection,class,equals,collection,type,return,new,linked,hash,set,e,capacity,else,if,list,class,equals,collection,type,return,new,array,list,e,capacity,else,if,sorted,set,class,equals,collection,type,navigable,set,class,equals,collection,type,return,new,tree,set,e,else,throw,new,illegal,argument,exception,unsupported,collection,interface,collection,type,get,name,else,if,enum,set,class,equals,collection,type,assert,not,null,element,type,cannot,create,enum,set,for,unknown,element,type,return,collection,e,enum,set,none,of,as,enum,type,element,type,else,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,unsupported,collection,type,collection,type,get,name,try,return,collection,e,collection,type,new,instance,catch,exception,ex,throw,new,illegal,argument,exception,could,not,instantiate,collection,type,collection,type,get,name,ex
CollectionFactory -> @SuppressWarnings({ "unchecked", "cast" }) 	public static <E> Collection<E> createCollection(Class<?> collectionType, Class<?> elementType, int capacity);1418248740;Create the most appropriate collection for the given collection type._@param collectionType the desired type of the target collection_ never {@code null}_@param elementType the collection's element type, or {@code null} if not known_(note: only relevant for {@link EnumSet} creation)_@param capacity the initial capacity_@return the new collection instance_@since 4.1.3_@see java.util.LinkedHashSet_@see java.util.ArrayList_@see java.util.TreeSet_@see java.util.EnumSet;@SuppressWarnings({ "unchecked", "cast" })_	public static <E> Collection<E> createCollection(Class<?> collectionType, Class<?> elementType, int capacity) {_		Assert.notNull(collectionType, "Collection type must not be null")__		if (collectionType.isInterface()) {_			if (Set.class.equals(collectionType) || Collection.class.equals(collectionType)) {_				return new LinkedHashSet<E>(capacity)__			}_			else if (List.class.equals(collectionType)) {_				return new ArrayList<E>(capacity)__			}_			else if (SortedSet.class.equals(collectionType) || NavigableSet.class.equals(collectionType)) {_				return new TreeSet<E>()__			}_			else {_				throw new IllegalArgumentException("Unsupported Collection interface: " + collectionType.getName())__			}_		}_		else if (EnumSet.class.equals(collectionType)) {_			Assert.notNull(elementType, "Cannot create EnumSet for unknown element type")__			_			return (Collection<E>) EnumSet.noneOf(asEnumType(elementType))__		}_		else {_			if (!Collection.class.isAssignableFrom(collectionType)) {_				throw new IllegalArgumentException("Unsupported Collection type: " + collectionType.getName())__			}_			try {_				return (Collection<E>) collectionType.newInstance()__			}_			catch (Exception ex) {_				throw new IllegalArgumentException(_					"Could not instantiate Collection type: " + collectionType.getName(), ex)__			}_		}_	};create,the,most,appropriate,collection,for,the,given,collection,type,param,collection,type,the,desired,type,of,the,target,collection,never,code,null,param,element,type,the,collection,s,element,type,or,code,null,if,not,known,note,only,relevant,for,link,enum,set,creation,param,capacity,the,initial,capacity,return,the,new,collection,instance,since,4,1,3,see,java,util,linked,hash,set,see,java,util,array,list,see,java,util,tree,set,see,java,util,enum,set;suppress,warnings,unchecked,cast,public,static,e,collection,e,create,collection,class,collection,type,class,element,type,int,capacity,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,type,is,interface,if,set,class,equals,collection,type,collection,class,equals,collection,type,return,new,linked,hash,set,e,capacity,else,if,list,class,equals,collection,type,return,new,array,list,e,capacity,else,if,sorted,set,class,equals,collection,type,navigable,set,class,equals,collection,type,return,new,tree,set,e,else,throw,new,illegal,argument,exception,unsupported,collection,interface,collection,type,get,name,else,if,enum,set,class,equals,collection,type,assert,not,null,element,type,cannot,create,enum,set,for,unknown,element,type,return,collection,e,enum,set,none,of,as,enum,type,element,type,else,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,unsupported,collection,type,collection,type,get,name,try,return,collection,e,collection,type,new,instance,catch,exception,ex,throw,new,illegal,argument,exception,could,not,instantiate,collection,type,collection,type,get,name,ex
CollectionFactory -> @SuppressWarnings({ "unchecked", "cast" }) 	public static <E> Collection<E> createCollection(Class<?> collectionType, Class<?> elementType, int capacity);1419862420;Create the most appropriate collection for the given collection type._@param collectionType the desired type of the target collection_ never {@code null}_@param elementType the collection's element type, or {@code null} if not known_(note: only relevant for {@link EnumSet} creation)_@param capacity the initial capacity_@return the new collection instance_@since 4.1.3_@see java.util.LinkedHashSet_@see java.util.ArrayList_@see java.util.TreeSet_@see java.util.EnumSet;@SuppressWarnings({ "unchecked", "cast" })_	public static <E> Collection<E> createCollection(Class<?> collectionType, Class<?> elementType, int capacity) {_		Assert.notNull(collectionType, "Collection type must not be null")__		if (collectionType.isInterface()) {_			if (Set.class.equals(collectionType) || Collection.class.equals(collectionType)) {_				return new LinkedHashSet<E>(capacity)__			}_			else if (List.class.equals(collectionType)) {_				return new ArrayList<E>(capacity)__			}_			else if (SortedSet.class.equals(collectionType) || NavigableSet.class.equals(collectionType)) {_				return new TreeSet<E>()__			}_			else {_				throw new IllegalArgumentException("Unsupported Collection interface: " + collectionType.getName())__			}_		}_		else if (EnumSet.class.equals(collectionType)) {_			Assert.notNull(elementType, "Cannot create EnumSet for unknown element type")__			_			return (Collection<E>) EnumSet.noneOf(asEnumType(elementType))__		}_		else {_			if (!Collection.class.isAssignableFrom(collectionType)) {_				throw new IllegalArgumentException("Unsupported Collection type: " + collectionType.getName())__			}_			try {_				return (Collection<E>) collectionType.newInstance()__			}_			catch (Exception ex) {_				throw new IllegalArgumentException(_					"Could not instantiate Collection type: " + collectionType.getName(), ex)__			}_		}_	};create,the,most,appropriate,collection,for,the,given,collection,type,param,collection,type,the,desired,type,of,the,target,collection,never,code,null,param,element,type,the,collection,s,element,type,or,code,null,if,not,known,note,only,relevant,for,link,enum,set,creation,param,capacity,the,initial,capacity,return,the,new,collection,instance,since,4,1,3,see,java,util,linked,hash,set,see,java,util,array,list,see,java,util,tree,set,see,java,util,enum,set;suppress,warnings,unchecked,cast,public,static,e,collection,e,create,collection,class,collection,type,class,element,type,int,capacity,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,type,is,interface,if,set,class,equals,collection,type,collection,class,equals,collection,type,return,new,linked,hash,set,e,capacity,else,if,list,class,equals,collection,type,return,new,array,list,e,capacity,else,if,sorted,set,class,equals,collection,type,navigable,set,class,equals,collection,type,return,new,tree,set,e,else,throw,new,illegal,argument,exception,unsupported,collection,interface,collection,type,get,name,else,if,enum,set,class,equals,collection,type,assert,not,null,element,type,cannot,create,enum,set,for,unknown,element,type,return,collection,e,enum,set,none,of,as,enum,type,element,type,else,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,unsupported,collection,type,collection,type,get,name,try,return,collection,e,collection,type,new,instance,catch,exception,ex,throw,new,illegal,argument,exception,could,not,instantiate,collection,type,collection,type,get,name,ex
CollectionFactory -> @SuppressWarnings({ "unchecked", "cast" }) 	public static <E> Collection<E> createCollection(Class<?> collectionType, Class<?> elementType, int capacity);1420408095;Create the most appropriate collection for the given collection type._<p><strong>Warning</strong>: Since the parameterized type {@code E} is_not bound to the supplied {@code elementType}, type safety cannot be_guaranteed if the desired {@code collectionType} is {@link EnumSet}._In such scenarios, the caller is responsible for ensuring that the_supplied {@code elementType} is an enum type matching type {@code E}._As an alternative, the caller may wish to treat the return value as a_raw collection or collection of {@link Object}._@param collectionType the desired type of the target collection_ never {@code null}_@param elementType the collection's element type, or {@code null} if unknown_(note: only relevant for {@link EnumSet} creation)_@param capacity the initial capacity_@return a new collection instance_@since 4.1.3_@see java.util.LinkedHashSet_@see java.util.ArrayList_@see java.util.TreeSet_@see java.util.EnumSet_@throws IllegalArgumentException if the supplied {@code collectionType} is_{@code null}_ or if the desired {@code collectionType} is {@link EnumSet} and_the supplied {@code elementType} is not a subtype of {@link Enum};@SuppressWarnings({ "unchecked", "cast" })_	public static <E> Collection<E> createCollection(Class<?> collectionType, Class<?> elementType, int capacity) {_		Assert.notNull(collectionType, "Collection type must not be null")__		if (collectionType.isInterface()) {_			if (Set.class.equals(collectionType) || Collection.class.equals(collectionType)) {_				return new LinkedHashSet<E>(capacity)__			}_			else if (List.class.equals(collectionType)) {_				return new ArrayList<E>(capacity)__			}_			else if (SortedSet.class.equals(collectionType) || NavigableSet.class.equals(collectionType)) {_				return new TreeSet<E>()__			}_			else {_				throw new IllegalArgumentException("Unsupported Collection interface: " + collectionType.getName())__			}_		}_		else if (EnumSet.class.equals(collectionType)) {_			Assert.notNull(elementType, "Cannot create EnumSet for unknown element type")__			_			return (Collection<E>) EnumSet.noneOf(asEnumType(elementType))__		}_		else {_			if (!Collection.class.isAssignableFrom(collectionType)) {_				throw new IllegalArgumentException("Unsupported Collection type: " + collectionType.getName())__			}_			try {_				return (Collection<E>) collectionType.newInstance()__			}_			catch (Exception ex) {_				throw new IllegalArgumentException(_					"Could not instantiate Collection type: " + collectionType.getName(), ex)__			}_		}_	};create,the,most,appropriate,collection,for,the,given,collection,type,p,strong,warning,strong,since,the,parameterized,type,code,e,is,not,bound,to,the,supplied,code,element,type,type,safety,cannot,be,guaranteed,if,the,desired,code,collection,type,is,link,enum,set,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,supplied,code,element,type,is,an,enum,type,matching,type,code,e,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,collection,or,collection,of,link,object,param,collection,type,the,desired,type,of,the,target,collection,never,code,null,param,element,type,the,collection,s,element,type,or,code,null,if,unknown,note,only,relevant,for,link,enum,set,creation,param,capacity,the,initial,capacity,return,a,new,collection,instance,since,4,1,3,see,java,util,linked,hash,set,see,java,util,array,list,see,java,util,tree,set,see,java,util,enum,set,throws,illegal,argument,exception,if,the,supplied,code,collection,type,is,code,null,or,if,the,desired,code,collection,type,is,link,enum,set,and,the,supplied,code,element,type,is,not,a,subtype,of,link,enum;suppress,warnings,unchecked,cast,public,static,e,collection,e,create,collection,class,collection,type,class,element,type,int,capacity,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,type,is,interface,if,set,class,equals,collection,type,collection,class,equals,collection,type,return,new,linked,hash,set,e,capacity,else,if,list,class,equals,collection,type,return,new,array,list,e,capacity,else,if,sorted,set,class,equals,collection,type,navigable,set,class,equals,collection,type,return,new,tree,set,e,else,throw,new,illegal,argument,exception,unsupported,collection,interface,collection,type,get,name,else,if,enum,set,class,equals,collection,type,assert,not,null,element,type,cannot,create,enum,set,for,unknown,element,type,return,collection,e,enum,set,none,of,as,enum,type,element,type,else,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,unsupported,collection,type,collection,type,get,name,try,return,collection,e,collection,type,new,instance,catch,exception,ex,throw,new,illegal,argument,exception,could,not,instantiate,collection,type,collection,type,get,name,ex
CollectionFactory -> @SuppressWarnings({ "unchecked", "cast" }) 	public static <E> Collection<E> createCollection(Class<?> collectionType, Class<?> elementType, int capacity);1432125256;Create the most appropriate collection for the given collection type._<p><strong>Warning</strong>: Since the parameterized type {@code E} is_not bound to the supplied {@code elementType}, type safety cannot be_guaranteed if the desired {@code collectionType} is {@link EnumSet}._In such scenarios, the caller is responsible for ensuring that the_supplied {@code elementType} is an enum type matching type {@code E}._As an alternative, the caller may wish to treat the return value as a_raw collection or collection of {@link Object}._@param collectionType the desired type of the target collection_ never {@code null}_@param elementType the collection's element type, or {@code null} if unknown_(note: only relevant for {@link EnumSet} creation)_@param capacity the initial capacity_@return a new collection instance_@since 4.1.3_@see java.util.LinkedHashSet_@see java.util.ArrayList_@see java.util.TreeSet_@see java.util.EnumSet_@throws IllegalArgumentException if the supplied {@code collectionType} is_{@code null}_ or if the desired {@code collectionType} is {@link EnumSet} and_the supplied {@code elementType} is not a subtype of {@link Enum};@SuppressWarnings({ "unchecked", "cast" })_	public static <E> Collection<E> createCollection(Class<?> collectionType, Class<?> elementType, int capacity) {_		Assert.notNull(collectionType, "Collection type must not be null")__		if (collectionType.isInterface()) {_			if (Set.class == collectionType || Collection.class == collectionType) {_				return new LinkedHashSet<E>(capacity)__			}_			else if (List.class == collectionType) {_				return new ArrayList<E>(capacity)__			}_			else if (SortedSet.class == collectionType || NavigableSet.class == collectionType) {_				return new TreeSet<E>()__			}_			else {_				throw new IllegalArgumentException("Unsupported Collection interface: " + collectionType.getName())__			}_		}_		else if (EnumSet.class == collectionType) {_			Assert.notNull(elementType, "Cannot create EnumSet for unknown element type")__			_			return (Collection<E>) EnumSet.noneOf(asEnumType(elementType))__		}_		else {_			if (!Collection.class.isAssignableFrom(collectionType)) {_				throw new IllegalArgumentException("Unsupported Collection type: " + collectionType.getName())__			}_			try {_				return (Collection<E>) collectionType.newInstance()__			}_			catch (Exception ex) {_				throw new IllegalArgumentException(_					"Could not instantiate Collection type: " + collectionType.getName(), ex)__			}_		}_	};create,the,most,appropriate,collection,for,the,given,collection,type,p,strong,warning,strong,since,the,parameterized,type,code,e,is,not,bound,to,the,supplied,code,element,type,type,safety,cannot,be,guaranteed,if,the,desired,code,collection,type,is,link,enum,set,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,supplied,code,element,type,is,an,enum,type,matching,type,code,e,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,collection,or,collection,of,link,object,param,collection,type,the,desired,type,of,the,target,collection,never,code,null,param,element,type,the,collection,s,element,type,or,code,null,if,unknown,note,only,relevant,for,link,enum,set,creation,param,capacity,the,initial,capacity,return,a,new,collection,instance,since,4,1,3,see,java,util,linked,hash,set,see,java,util,array,list,see,java,util,tree,set,see,java,util,enum,set,throws,illegal,argument,exception,if,the,supplied,code,collection,type,is,code,null,or,if,the,desired,code,collection,type,is,link,enum,set,and,the,supplied,code,element,type,is,not,a,subtype,of,link,enum;suppress,warnings,unchecked,cast,public,static,e,collection,e,create,collection,class,collection,type,class,element,type,int,capacity,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,type,is,interface,if,set,class,collection,type,collection,class,collection,type,return,new,linked,hash,set,e,capacity,else,if,list,class,collection,type,return,new,array,list,e,capacity,else,if,sorted,set,class,collection,type,navigable,set,class,collection,type,return,new,tree,set,e,else,throw,new,illegal,argument,exception,unsupported,collection,interface,collection,type,get,name,else,if,enum,set,class,collection,type,assert,not,null,element,type,cannot,create,enum,set,for,unknown,element,type,return,collection,e,enum,set,none,of,as,enum,type,element,type,else,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,unsupported,collection,type,collection,type,get,name,try,return,collection,e,collection,type,new,instance,catch,exception,ex,throw,new,illegal,argument,exception,could,not,instantiate,collection,type,collection,type,get,name,ex
CollectionFactory -> @SuppressWarnings({ "unchecked", "cast" }) 	public static <E> Collection<E> createCollection(Class<?> collectionType, Class<?> elementType, int capacity);1467730834;Create the most appropriate collection for the given collection type._<p><strong>Warning</strong>: Since the parameterized type {@code E} is_not bound to the supplied {@code elementType}, type safety cannot be_guaranteed if the desired {@code collectionType} is {@link EnumSet}._In such scenarios, the caller is responsible for ensuring that the_supplied {@code elementType} is an enum type matching type {@code E}._As an alternative, the caller may wish to treat the return value as a_raw collection or collection of {@link Object}._@param collectionType the desired type of the target collection_ never {@code null}_@param elementType the collection's element type, or {@code null} if unknown_(note: only relevant for {@link EnumSet} creation)_@param capacity the initial capacity_@return a new collection instance_@since 4.1.3_@see java.util.LinkedHashSet_@see java.util.ArrayList_@see java.util.TreeSet_@see java.util.EnumSet_@throws IllegalArgumentException if the supplied {@code collectionType} is_{@code null}_ or if the desired {@code collectionType} is {@link EnumSet} and_the supplied {@code elementType} is not a subtype of {@link Enum};@SuppressWarnings({ "unchecked", "cast" })_	public static <E> Collection<E> createCollection(Class<?> collectionType, Class<?> elementType, int capacity) {_		Assert.notNull(collectionType, "Collection type must not be null")__		if (collectionType.isInterface()) {_			if (Set.class == collectionType || Collection.class == collectionType) {_				return new LinkedHashSet<>(capacity)__			}_			else if (List.class == collectionType) {_				return new ArrayList<>(capacity)__			}_			else if (SortedSet.class == collectionType || NavigableSet.class == collectionType) {_				return new TreeSet<>()__			}_			else {_				throw new IllegalArgumentException("Unsupported Collection interface: " + collectionType.getName())__			}_		}_		else if (EnumSet.class == collectionType) {_			Assert.notNull(elementType, "Cannot create EnumSet for unknown element type")__			_			return (Collection<E>) EnumSet.noneOf(asEnumType(elementType))__		}_		else {_			if (!Collection.class.isAssignableFrom(collectionType)) {_				throw new IllegalArgumentException("Unsupported Collection type: " + collectionType.getName())__			}_			try {_				return (Collection<E>) collectionType.newInstance()__			}_			catch (Exception ex) {_				throw new IllegalArgumentException(_					"Could not instantiate Collection type: " + collectionType.getName(), ex)__			}_		}_	};create,the,most,appropriate,collection,for,the,given,collection,type,p,strong,warning,strong,since,the,parameterized,type,code,e,is,not,bound,to,the,supplied,code,element,type,type,safety,cannot,be,guaranteed,if,the,desired,code,collection,type,is,link,enum,set,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,supplied,code,element,type,is,an,enum,type,matching,type,code,e,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,collection,or,collection,of,link,object,param,collection,type,the,desired,type,of,the,target,collection,never,code,null,param,element,type,the,collection,s,element,type,or,code,null,if,unknown,note,only,relevant,for,link,enum,set,creation,param,capacity,the,initial,capacity,return,a,new,collection,instance,since,4,1,3,see,java,util,linked,hash,set,see,java,util,array,list,see,java,util,tree,set,see,java,util,enum,set,throws,illegal,argument,exception,if,the,supplied,code,collection,type,is,code,null,or,if,the,desired,code,collection,type,is,link,enum,set,and,the,supplied,code,element,type,is,not,a,subtype,of,link,enum;suppress,warnings,unchecked,cast,public,static,e,collection,e,create,collection,class,collection,type,class,element,type,int,capacity,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,type,is,interface,if,set,class,collection,type,collection,class,collection,type,return,new,linked,hash,set,capacity,else,if,list,class,collection,type,return,new,array,list,capacity,else,if,sorted,set,class,collection,type,navigable,set,class,collection,type,return,new,tree,set,else,throw,new,illegal,argument,exception,unsupported,collection,interface,collection,type,get,name,else,if,enum,set,class,collection,type,assert,not,null,element,type,cannot,create,enum,set,for,unknown,element,type,return,collection,e,enum,set,none,of,as,enum,type,element,type,else,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,unsupported,collection,type,collection,type,get,name,try,return,collection,e,collection,type,new,instance,catch,exception,ex,throw,new,illegal,argument,exception,could,not,instantiate,collection,type,collection,type,get,name,ex
CollectionFactory -> @SuppressWarnings({ "unchecked", "cast" }) 	public static <E> Collection<E> createCollection(Class<?> collectionType, Class<?> elementType, int capacity);1468948866;Create the most appropriate collection for the given collection type._<p><strong>Warning</strong>: Since the parameterized type {@code E} is_not bound to the supplied {@code elementType}, type safety cannot be_guaranteed if the desired {@code collectionType} is {@link EnumSet}._In such scenarios, the caller is responsible for ensuring that the_supplied {@code elementType} is an enum type matching type {@code E}._As an alternative, the caller may wish to treat the return value as a_raw collection or collection of {@link Object}._@param collectionType the desired type of the target collection_ never {@code null}_@param elementType the collection's element type, or {@code null} if unknown_(note: only relevant for {@link EnumSet} creation)_@param capacity the initial capacity_@return a new collection instance_@since 4.1.3_@see java.util.LinkedHashSet_@see java.util.ArrayList_@see java.util.TreeSet_@see java.util.EnumSet_@throws IllegalArgumentException if the supplied {@code collectionType} is_{@code null}_ or if the desired {@code collectionType} is {@link EnumSet} and_the supplied {@code elementType} is not a subtype of {@link Enum};@SuppressWarnings({ "unchecked", "cast" })_	public static <E> Collection<E> createCollection(Class<?> collectionType, Class<?> elementType, int capacity) {_		Assert.notNull(collectionType, "Collection type must not be null")__		if (collectionType.isInterface()) {_			if (Set.class == collectionType || Collection.class == collectionType) {_				return new LinkedHashSet<>(capacity)__			}_			else if (List.class == collectionType) {_				return new ArrayList<>(capacity)__			}_			else if (SortedSet.class == collectionType || NavigableSet.class == collectionType) {_				return new TreeSet<>()__			}_			else {_				throw new IllegalArgumentException("Unsupported Collection interface: " + collectionType.getName())__			}_		}_		else if (EnumSet.class == collectionType) {_			Assert.notNull(elementType, "Cannot create EnumSet for unknown element type")__			_			return (Collection<E>) EnumSet.noneOf(asEnumType(elementType))__		}_		else {_			if (!Collection.class.isAssignableFrom(collectionType)) {_				throw new IllegalArgumentException("Unsupported Collection type: " + collectionType.getName())__			}_			try {_				return (Collection<E>) ReflectionUtils.accessibleConstructor(collectionType).newInstance()__			}_			catch (Throwable ex) {_				throw new IllegalArgumentException(_					"Could not instantiate Collection type: " + collectionType.getName(), ex)__			}_		}_	};create,the,most,appropriate,collection,for,the,given,collection,type,p,strong,warning,strong,since,the,parameterized,type,code,e,is,not,bound,to,the,supplied,code,element,type,type,safety,cannot,be,guaranteed,if,the,desired,code,collection,type,is,link,enum,set,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,supplied,code,element,type,is,an,enum,type,matching,type,code,e,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,collection,or,collection,of,link,object,param,collection,type,the,desired,type,of,the,target,collection,never,code,null,param,element,type,the,collection,s,element,type,or,code,null,if,unknown,note,only,relevant,for,link,enum,set,creation,param,capacity,the,initial,capacity,return,a,new,collection,instance,since,4,1,3,see,java,util,linked,hash,set,see,java,util,array,list,see,java,util,tree,set,see,java,util,enum,set,throws,illegal,argument,exception,if,the,supplied,code,collection,type,is,code,null,or,if,the,desired,code,collection,type,is,link,enum,set,and,the,supplied,code,element,type,is,not,a,subtype,of,link,enum;suppress,warnings,unchecked,cast,public,static,e,collection,e,create,collection,class,collection,type,class,element,type,int,capacity,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,type,is,interface,if,set,class,collection,type,collection,class,collection,type,return,new,linked,hash,set,capacity,else,if,list,class,collection,type,return,new,array,list,capacity,else,if,sorted,set,class,collection,type,navigable,set,class,collection,type,return,new,tree,set,else,throw,new,illegal,argument,exception,unsupported,collection,interface,collection,type,get,name,else,if,enum,set,class,collection,type,assert,not,null,element,type,cannot,create,enum,set,for,unknown,element,type,return,collection,e,enum,set,none,of,as,enum,type,element,type,else,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,unsupported,collection,type,collection,type,get,name,try,return,collection,e,reflection,utils,accessible,constructor,collection,type,new,instance,catch,throwable,ex,throw,new,illegal,argument,exception,could,not,instantiate,collection,type,collection,type,get,name,ex
CollectionFactory -> @SuppressWarnings({ "unchecked", "cast" }) 	public static <E> Collection<E> createCollection(Class<?> collectionType, Class<?> elementType, int capacity);1474830340;Create the most appropriate collection for the given collection type._<p><strong>Warning</strong>: Since the parameterized type {@code E} is_not bound to the supplied {@code elementType}, type safety cannot be_guaranteed if the desired {@code collectionType} is {@link EnumSet}._In such scenarios, the caller is responsible for ensuring that the_supplied {@code elementType} is an enum type matching type {@code E}._As an alternative, the caller may wish to treat the return value as a_raw collection or collection of {@link Object}._@param collectionType the desired type of the target collection_ never {@code null}_@param elementType the collection's element type, or {@code null} if unknown_(note: only relevant for {@link EnumSet} creation)_@param capacity the initial capacity_@return a new collection instance_@since 4.1.3_@see java.util.LinkedHashSet_@see java.util.ArrayList_@see java.util.TreeSet_@see java.util.EnumSet_@throws IllegalArgumentException if the supplied {@code collectionType} is_{@code null}_ or if the desired {@code collectionType} is {@link EnumSet} and_the supplied {@code elementType} is not a subtype of {@link Enum};@SuppressWarnings({ "unchecked", "cast" })_	public static <E> Collection<E> createCollection(Class<?> collectionType, Class<?> elementType, int capacity) {_		Assert.notNull(collectionType, "Collection type must not be null")__		if (collectionType.isInterface()) {_			if (Set.class == collectionType || Collection.class == collectionType) {_				return new LinkedHashSet<>(capacity)__			}_			else if (List.class == collectionType) {_				return new ArrayList<>(capacity)__			}_			else if (SortedSet.class == collectionType || NavigableSet.class == collectionType) {_				return new TreeSet<>()__			}_			else {_				throw new IllegalArgumentException("Unsupported Collection interface: " + collectionType.getName())__			}_		}_		else if (EnumSet.class == collectionType) {_			Assert.notNull(elementType, "Cannot create EnumSet for unknown element type")__			_			return (Collection<E>) EnumSet.noneOf(asEnumType(elementType))__		}_		else {_			if (!Collection.class.isAssignableFrom(collectionType)) {_				throw new IllegalArgumentException("Unsupported Collection type: " + collectionType.getName())__			}_			try {_				return (Collection<E>) ReflectionUtils.accessibleConstructor(collectionType).newInstance()__			}_			catch (Throwable ex) {_				throw new IllegalArgumentException(_					"Could not instantiate Collection type: " + collectionType.getName(), ex)__			}_		}_	};create,the,most,appropriate,collection,for,the,given,collection,type,p,strong,warning,strong,since,the,parameterized,type,code,e,is,not,bound,to,the,supplied,code,element,type,type,safety,cannot,be,guaranteed,if,the,desired,code,collection,type,is,link,enum,set,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,supplied,code,element,type,is,an,enum,type,matching,type,code,e,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,collection,or,collection,of,link,object,param,collection,type,the,desired,type,of,the,target,collection,never,code,null,param,element,type,the,collection,s,element,type,or,code,null,if,unknown,note,only,relevant,for,link,enum,set,creation,param,capacity,the,initial,capacity,return,a,new,collection,instance,since,4,1,3,see,java,util,linked,hash,set,see,java,util,array,list,see,java,util,tree,set,see,java,util,enum,set,throws,illegal,argument,exception,if,the,supplied,code,collection,type,is,code,null,or,if,the,desired,code,collection,type,is,link,enum,set,and,the,supplied,code,element,type,is,not,a,subtype,of,link,enum;suppress,warnings,unchecked,cast,public,static,e,collection,e,create,collection,class,collection,type,class,element,type,int,capacity,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,type,is,interface,if,set,class,collection,type,collection,class,collection,type,return,new,linked,hash,set,capacity,else,if,list,class,collection,type,return,new,array,list,capacity,else,if,sorted,set,class,collection,type,navigable,set,class,collection,type,return,new,tree,set,else,throw,new,illegal,argument,exception,unsupported,collection,interface,collection,type,get,name,else,if,enum,set,class,collection,type,assert,not,null,element,type,cannot,create,enum,set,for,unknown,element,type,return,collection,e,enum,set,none,of,as,enum,type,element,type,else,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,unsupported,collection,type,collection,type,get,name,try,return,collection,e,reflection,utils,accessible,constructor,collection,type,new,instance,catch,throwable,ex,throw,new,illegal,argument,exception,could,not,instantiate,collection,type,collection,type,get,name,ex
CollectionFactory -> @SuppressWarnings({ "unchecked", "cast" }) 	public static <E> Collection<E> createCollection(Class<?> collectionType, Class<?> elementType, int capacity);1484252281;Create the most appropriate collection for the given collection type._<p><strong>Warning</strong>: Since the parameterized type {@code E} is_not bound to the supplied {@code elementType}, type safety cannot be_guaranteed if the desired {@code collectionType} is {@link EnumSet}._In such scenarios, the caller is responsible for ensuring that the_supplied {@code elementType} is an enum type matching type {@code E}._As an alternative, the caller may wish to treat the return value as a_raw collection or collection of {@link Object}._@param collectionType the desired type of the target collection_ never {@code null}_@param elementType the collection's element type, or {@code null} if unknown_(note: only relevant for {@link EnumSet} creation)_@param capacity the initial capacity_@return a new collection instance_@since 4.1.3_@see java.util.LinkedHashSet_@see java.util.ArrayList_@see java.util.TreeSet_@see java.util.EnumSet_@throws IllegalArgumentException if the supplied {@code collectionType} is_{@code null}_ or if the desired {@code collectionType} is {@link EnumSet} and_the supplied {@code elementType} is not a subtype of {@link Enum};@SuppressWarnings({ "unchecked", "cast" })_	public static <E> Collection<E> createCollection(Class<?> collectionType, Class<?> elementType, int capacity) {_		Assert.notNull(collectionType, "Collection type must not be null")__		if (collectionType.isInterface()) {_			if (Set.class == collectionType || Collection.class == collectionType) {_				return new LinkedHashSet<>(capacity)__			}_			else if (List.class == collectionType) {_				return new ArrayList<>(capacity)__			}_			else if (SortedSet.class == collectionType || NavigableSet.class == collectionType) {_				return new TreeSet<>()__			}_			else {_				throw new IllegalArgumentException("Unsupported Collection interface: " + collectionType.getName())__			}_		}_		else if (EnumSet.class == collectionType) {_			Assert.notNull(elementType, "Cannot create EnumSet for unknown element type")__			_			return (Collection<E>) EnumSet.noneOf(asEnumType(elementType))__		}_		else {_			if (!Collection.class.isAssignableFrom(collectionType)) {_				throw new IllegalArgumentException("Unsupported Collection type: " + collectionType.getName())__			}_			try {_				return (Collection<E>) ReflectionUtils.accessibleConstructor(collectionType).newInstance()__			}_			catch (Throwable ex) {_				throw new IllegalArgumentException(_					"Could not instantiate Collection type: " + collectionType.getName(), ex)__			}_		}_	};create,the,most,appropriate,collection,for,the,given,collection,type,p,strong,warning,strong,since,the,parameterized,type,code,e,is,not,bound,to,the,supplied,code,element,type,type,safety,cannot,be,guaranteed,if,the,desired,code,collection,type,is,link,enum,set,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,supplied,code,element,type,is,an,enum,type,matching,type,code,e,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,collection,or,collection,of,link,object,param,collection,type,the,desired,type,of,the,target,collection,never,code,null,param,element,type,the,collection,s,element,type,or,code,null,if,unknown,note,only,relevant,for,link,enum,set,creation,param,capacity,the,initial,capacity,return,a,new,collection,instance,since,4,1,3,see,java,util,linked,hash,set,see,java,util,array,list,see,java,util,tree,set,see,java,util,enum,set,throws,illegal,argument,exception,if,the,supplied,code,collection,type,is,code,null,or,if,the,desired,code,collection,type,is,link,enum,set,and,the,supplied,code,element,type,is,not,a,subtype,of,link,enum;suppress,warnings,unchecked,cast,public,static,e,collection,e,create,collection,class,collection,type,class,element,type,int,capacity,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,type,is,interface,if,set,class,collection,type,collection,class,collection,type,return,new,linked,hash,set,capacity,else,if,list,class,collection,type,return,new,array,list,capacity,else,if,sorted,set,class,collection,type,navigable,set,class,collection,type,return,new,tree,set,else,throw,new,illegal,argument,exception,unsupported,collection,interface,collection,type,get,name,else,if,enum,set,class,collection,type,assert,not,null,element,type,cannot,create,enum,set,for,unknown,element,type,return,collection,e,enum,set,none,of,as,enum,type,element,type,else,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,unsupported,collection,type,collection,type,get,name,try,return,collection,e,reflection,utils,accessible,constructor,collection,type,new,instance,catch,throwable,ex,throw,new,illegal,argument,exception,could,not,instantiate,collection,type,collection,type,get,name,ex
CollectionFactory -> public static <K, V> Map<K, V> createMap(Class<?> mapType, int capacity);1418219235;Create the most approximate map for the given map._<p>Delegates to {@link #createMap(Class, Class, int)} with a_{@code null} key type._@param mapType the desired type of the target Map_@param capacity the initial capacity_@return the new Map instance;public static <K, V> Map<K, V> createMap(Class<?> mapType, int capacity) {_		return createMap(mapType, null, capacity)__	};create,the,most,approximate,map,for,the,given,map,p,delegates,to,link,create,map,class,class,int,with,a,code,null,key,type,param,map,type,the,desired,type,of,the,target,map,param,capacity,the,initial,capacity,return,the,new,map,instance;public,static,k,v,map,k,v,create,map,class,map,type,int,capacity,return,create,map,map,type,null,capacity
CollectionFactory -> public static <K, V> Map<K, V> createMap(Class<?> mapType, int capacity);1418248740;Create the most appropriate map for the given map type._<p>Delegates to {@link #createMap(Class, Class, int)} with a_{@code null} key type._@param mapType the desired type of the target Map_@param capacity the initial capacity_@return the new Map instance;public static <K, V> Map<K, V> createMap(Class<?> mapType, int capacity) {_		return createMap(mapType, null, capacity)__	};create,the,most,appropriate,map,for,the,given,map,type,p,delegates,to,link,create,map,class,class,int,with,a,code,null,key,type,param,map,type,the,desired,type,of,the,target,map,param,capacity,the,initial,capacity,return,the,new,map,instance;public,static,k,v,map,k,v,create,map,class,map,type,int,capacity,return,create,map,map,type,null,capacity
CollectionFactory -> public static <K, V> Map<K, V> createMap(Class<?> mapType, int capacity);1419862420;Create the most appropriate map for the given map type._<p>Delegates to {@link #createMap(Class, Class, int)} with a_{@code null} key type._@param mapType the desired type of the target Map_@param capacity the initial capacity_@return the new Map instance;public static <K, V> Map<K, V> createMap(Class<?> mapType, int capacity) {_		return createMap(mapType, null, capacity)__	};create,the,most,appropriate,map,for,the,given,map,type,p,delegates,to,link,create,map,class,class,int,with,a,code,null,key,type,param,map,type,the,desired,type,of,the,target,map,param,capacity,the,initial,capacity,return,the,new,map,instance;public,static,k,v,map,k,v,create,map,class,map,type,int,capacity,return,create,map,map,type,null,capacity
CollectionFactory -> public static <K, V> Map<K, V> createMap(Class<?> mapType, int capacity);1420408095;Create the most appropriate map for the given map type._<p>Delegates to {@link #createMap(Class, Class, int)} with a_{@code null} key type._@param mapType the desired type of the target map_@param capacity the initial capacity_@return a new map instance_@throws IllegalArgumentException if the supplied {@code mapType} is_{@code null} or of type {@link EnumMap};public static <K, V> Map<K, V> createMap(Class<?> mapType, int capacity) {_		return createMap(mapType, null, capacity)__	};create,the,most,appropriate,map,for,the,given,map,type,p,delegates,to,link,create,map,class,class,int,with,a,code,null,key,type,param,map,type,the,desired,type,of,the,target,map,param,capacity,the,initial,capacity,return,a,new,map,instance,throws,illegal,argument,exception,if,the,supplied,code,map,type,is,code,null,or,of,type,link,enum,map;public,static,k,v,map,k,v,create,map,class,map,type,int,capacity,return,create,map,map,type,null,capacity
CollectionFactory -> public static <K, V> Map<K, V> createMap(Class<?> mapType, int capacity);1432125256;Create the most appropriate map for the given map type._<p>Delegates to {@link #createMap(Class, Class, int)} with a_{@code null} key type._@param mapType the desired type of the target map_@param capacity the initial capacity_@return a new map instance_@throws IllegalArgumentException if the supplied {@code mapType} is_{@code null} or of type {@link EnumMap};public static <K, V> Map<K, V> createMap(Class<?> mapType, int capacity) {_		return createMap(mapType, null, capacity)__	};create,the,most,appropriate,map,for,the,given,map,type,p,delegates,to,link,create,map,class,class,int,with,a,code,null,key,type,param,map,type,the,desired,type,of,the,target,map,param,capacity,the,initial,capacity,return,a,new,map,instance,throws,illegal,argument,exception,if,the,supplied,code,map,type,is,code,null,or,of,type,link,enum,map;public,static,k,v,map,k,v,create,map,class,map,type,int,capacity,return,create,map,map,type,null,capacity
CollectionFactory -> public static <K, V> Map<K, V> createMap(Class<?> mapType, int capacity);1467730834;Create the most appropriate map for the given map type._<p>Delegates to {@link #createMap(Class, Class, int)} with a_{@code null} key type._@param mapType the desired type of the target map_@param capacity the initial capacity_@return a new map instance_@throws IllegalArgumentException if the supplied {@code mapType} is_{@code null} or of type {@link EnumMap};public static <K, V> Map<K, V> createMap(Class<?> mapType, int capacity) {_		return createMap(mapType, null, capacity)__	};create,the,most,appropriate,map,for,the,given,map,type,p,delegates,to,link,create,map,class,class,int,with,a,code,null,key,type,param,map,type,the,desired,type,of,the,target,map,param,capacity,the,initial,capacity,return,a,new,map,instance,throws,illegal,argument,exception,if,the,supplied,code,map,type,is,code,null,or,of,type,link,enum,map;public,static,k,v,map,k,v,create,map,class,map,type,int,capacity,return,create,map,map,type,null,capacity
CollectionFactory -> public static <K, V> Map<K, V> createMap(Class<?> mapType, int capacity);1468948866;Create the most appropriate map for the given map type._<p>Delegates to {@link #createMap(Class, Class, int)} with a_{@code null} key type._@param mapType the desired type of the target map_@param capacity the initial capacity_@return a new map instance_@throws IllegalArgumentException if the supplied {@code mapType} is_{@code null} or of type {@link EnumMap};public static <K, V> Map<K, V> createMap(Class<?> mapType, int capacity) {_		return createMap(mapType, null, capacity)__	};create,the,most,appropriate,map,for,the,given,map,type,p,delegates,to,link,create,map,class,class,int,with,a,code,null,key,type,param,map,type,the,desired,type,of,the,target,map,param,capacity,the,initial,capacity,return,a,new,map,instance,throws,illegal,argument,exception,if,the,supplied,code,map,type,is,code,null,or,of,type,link,enum,map;public,static,k,v,map,k,v,create,map,class,map,type,int,capacity,return,create,map,map,type,null,capacity
CollectionFactory -> public static <K, V> Map<K, V> createMap(Class<?> mapType, int capacity);1474830340;Create the most appropriate map for the given map type._<p>Delegates to {@link #createMap(Class, Class, int)} with a_{@code null} key type._@param mapType the desired type of the target map_@param capacity the initial capacity_@return a new map instance_@throws IllegalArgumentException if the supplied {@code mapType} is_{@code null} or of type {@link EnumMap};public static <K, V> Map<K, V> createMap(Class<?> mapType, int capacity) {_		return createMap(mapType, null, capacity)__	};create,the,most,appropriate,map,for,the,given,map,type,p,delegates,to,link,create,map,class,class,int,with,a,code,null,key,type,param,map,type,the,desired,type,of,the,target,map,param,capacity,the,initial,capacity,return,a,new,map,instance,throws,illegal,argument,exception,if,the,supplied,code,map,type,is,code,null,or,of,type,link,enum,map;public,static,k,v,map,k,v,create,map,class,map,type,int,capacity,return,create,map,map,type,null,capacity
CollectionFactory -> public static <K, V> Map<K, V> createMap(Class<?> mapType, int capacity);1484252281;Create the most appropriate map for the given map type._<p>Delegates to {@link #createMap(Class, Class, int)} with a_{@code null} key type._@param mapType the desired type of the target map_@param capacity the initial capacity_@return a new map instance_@throws IllegalArgumentException if the supplied {@code mapType} is_{@code null} or of type {@link EnumMap};public static <K, V> Map<K, V> createMap(Class<?> mapType, int capacity) {_		return createMap(mapType, null, capacity)__	};create,the,most,appropriate,map,for,the,given,map,type,p,delegates,to,link,create,map,class,class,int,with,a,code,null,key,type,param,map,type,the,desired,type,of,the,target,map,param,capacity,the,initial,capacity,return,a,new,map,instance,throws,illegal,argument,exception,if,the,supplied,code,map,type,is,code,null,or,of,type,link,enum,map;public,static,k,v,map,k,v,create,map,class,map,type,int,capacity,return,create,map,map,type,null,capacity
CollectionFactory -> public static <K, V> Map<K, V> createMap(Class<?> mapType, int capacity);1495868221;Create the most appropriate map for the given map type._<p>Delegates to {@link #createMap(Class, Class, int)} with a_{@code null} key type._@param mapType the desired type of the target map_@param capacity the initial capacity_@return a new map instance_@throws IllegalArgumentException if the supplied {@code mapType} is_{@code null} or of type {@link EnumMap};public static <K, V> Map<K, V> createMap(Class<?> mapType, int capacity) {_		return createMap(mapType, null, capacity)__	};create,the,most,appropriate,map,for,the,given,map,type,p,delegates,to,link,create,map,class,class,int,with,a,code,null,key,type,param,map,type,the,desired,type,of,the,target,map,param,capacity,the,initial,capacity,return,a,new,map,instance,throws,illegal,argument,exception,if,the,supplied,code,map,type,is,code,null,or,of,type,link,enum,map;public,static,k,v,map,k,v,create,map,class,map,type,int,capacity,return,create,map,map,type,null,capacity
CollectionFactory -> public static <K, V> Map<K, V> createMap(Class<?> mapType, int capacity);1496837955;Create the most appropriate map for the given map type._<p>Delegates to {@link #createMap(Class, Class, int)} with a_{@code null} key type._@param mapType the desired type of the target map_@param capacity the initial capacity_@return a new map instance_@throws IllegalArgumentException if the supplied {@code mapType} is_{@code null} or of type {@link EnumMap};public static <K, V> Map<K, V> createMap(Class<?> mapType, int capacity) {_		return createMap(mapType, null, capacity)__	};create,the,most,appropriate,map,for,the,given,map,type,p,delegates,to,link,create,map,class,class,int,with,a,code,null,key,type,param,map,type,the,desired,type,of,the,target,map,param,capacity,the,initial,capacity,return,a,new,map,instance,throws,illegal,argument,exception,if,the,supplied,code,map,type,is,code,null,or,of,type,link,enum,map;public,static,k,v,map,k,v,create,map,class,map,type,int,capacity,return,create,map,map,type,null,capacity
CollectionFactory -> public static <K, V> Map<K, V> createMap(Class<?> mapType, int capacity);1530532518;Create the most appropriate map for the given map type._<p>Delegates to {@link #createMap(Class, Class, int)} with a_{@code null} key type._@param mapType the desired type of the target map_@param capacity the initial capacity_@return a new map instance_@throws IllegalArgumentException if the supplied {@code mapType} is_{@code null} or of type {@link EnumMap};public static <K, V> Map<K, V> createMap(Class<?> mapType, int capacity) {_		return createMap(mapType, null, capacity)__	};create,the,most,appropriate,map,for,the,given,map,type,p,delegates,to,link,create,map,class,class,int,with,a,code,null,key,type,param,map,type,the,desired,type,of,the,target,map,param,capacity,the,initial,capacity,return,a,new,map,instance,throws,illegal,argument,exception,if,the,supplied,code,map,type,is,code,null,or,of,type,link,enum,map;public,static,k,v,map,k,v,create,map,class,map,type,int,capacity,return,create,map,map,type,null,capacity
CollectionFactory -> public static <K, V> Map<K, V> createMap(Class<?> mapType, int capacity);1545740431;Create the most appropriate map for the given map type._<p>Delegates to {@link #createMap(Class, Class, int)} with a_{@code null} key type._@param mapType the desired type of the target map_@param capacity the initial capacity_@return a new map instance_@throws IllegalArgumentException if the supplied {@code mapType} is_{@code null} or of type {@link EnumMap};public static <K, V> Map<K, V> createMap(Class<?> mapType, int capacity) {_		return createMap(mapType, null, capacity)__	};create,the,most,appropriate,map,for,the,given,map,type,p,delegates,to,link,create,map,class,class,int,with,a,code,null,key,type,param,map,type,the,desired,type,of,the,target,map,param,capacity,the,initial,capacity,return,a,new,map,instance,throws,illegal,argument,exception,if,the,supplied,code,map,type,is,code,null,or,of,type,link,enum,map;public,static,k,v,map,k,v,create,map,class,map,type,int,capacity,return,create,map,map,type,null,capacity
CollectionFactory -> public static <K, V> Map<K, V> createMap(Class<?> mapType, int capacity);1549321822;Create the most appropriate map for the given map type._<p>Delegates to {@link #createMap(Class, Class, int)} with a_{@code null} key type._@param mapType the desired type of the target map_@param capacity the initial capacity_@return a new map instance_@throws IllegalArgumentException if the supplied {@code mapType} is_{@code null} or of type {@link EnumMap};public static <K, V> Map<K, V> createMap(Class<?> mapType, int capacity) {_		return createMap(mapType, null, capacity)__	};create,the,most,appropriate,map,for,the,given,map,type,p,delegates,to,link,create,map,class,class,int,with,a,code,null,key,type,param,map,type,the,desired,type,of,the,target,map,param,capacity,the,initial,capacity,return,a,new,map,instance,throws,illegal,argument,exception,if,the,supplied,code,map,type,is,code,null,or,of,type,link,enum,map;public,static,k,v,map,k,v,create,map,class,map,type,int,capacity,return,create,map,map,type,null,capacity
CollectionFactory -> @SuppressWarnings({"unchecked", "rawtypes"}) 	public static <K, V> Map<K, V> createApproximateMap(@Nullable Object map, int capacity);1495868221;Create the most approximate map for the given map._<p><strong>Warning</strong>: Since the parameterized type {@code K} is_not bound to the type of keys contained in the supplied {@code map},_type safety cannot be guaranteed if the supplied {@code map} is an_{@link EnumMap}. In such scenarios, the caller is responsible for_ensuring that the key type in the supplied {@code map} is an enum type_matching type {@code K}. As an alternative, the caller may wish to_treat the return value as a raw map or map keyed by {@link Object}._@param map the original map object, potentially {@code null}_@param capacity the initial capacity_@return a new, empty map instance_@see #isApproximableMapType_@see java.util.EnumMap_@see java.util.TreeMap_@see java.util.LinkedHashMap;@SuppressWarnings({"unchecked", "rawtypes"})_	public static <K, V> Map<K, V> createApproximateMap(@Nullable Object map, int capacity) {_		if (map instanceof EnumMap) {_			EnumMap enumMap = new EnumMap((EnumMap) map)__			enumMap.clear()__			return enumMap__		}_		else if (map instanceof SortedMap) {_			return new TreeMap<>(((SortedMap<K, V>) map).comparator())__		}_		else {_			return new LinkedHashMap<>(capacity)__		}_	};create,the,most,approximate,map,for,the,given,map,p,strong,warning,strong,since,the,parameterized,type,code,k,is,not,bound,to,the,type,of,keys,contained,in,the,supplied,code,map,type,safety,cannot,be,guaranteed,if,the,supplied,code,map,is,an,link,enum,map,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,key,type,in,the,supplied,code,map,is,an,enum,type,matching,type,code,k,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,map,or,map,keyed,by,link,object,param,map,the,original,map,object,potentially,code,null,param,capacity,the,initial,capacity,return,a,new,empty,map,instance,see,is,approximable,map,type,see,java,util,enum,map,see,java,util,tree,map,see,java,util,linked,hash,map;suppress,warnings,unchecked,rawtypes,public,static,k,v,map,k,v,create,approximate,map,nullable,object,map,int,capacity,if,map,instanceof,enum,map,enum,map,enum,map,new,enum,map,enum,map,map,enum,map,clear,return,enum,map,else,if,map,instanceof,sorted,map,return,new,tree,map,sorted,map,k,v,map,comparator,else,return,new,linked,hash,map,capacity
CollectionFactory -> @SuppressWarnings({"unchecked", "rawtypes"}) 	public static <K, V> Map<K, V> createApproximateMap(@Nullable Object map, int capacity);1496837955;Create the most approximate map for the given map._<p><strong>Warning</strong>: Since the parameterized type {@code K} is_not bound to the type of keys contained in the supplied {@code map},_type safety cannot be guaranteed if the supplied {@code map} is an_{@link EnumMap}. In such scenarios, the caller is responsible for_ensuring that the key type in the supplied {@code map} is an enum type_matching type {@code K}. As an alternative, the caller may wish to_treat the return value as a raw map or map keyed by {@link Object}._@param map the original map object, potentially {@code null}_@param capacity the initial capacity_@return a new, empty map instance_@see #isApproximableMapType_@see java.util.EnumMap_@see java.util.TreeMap_@see java.util.LinkedHashMap;@SuppressWarnings({"unchecked", "rawtypes"})_	public static <K, V> Map<K, V> createApproximateMap(@Nullable Object map, int capacity) {_		if (map instanceof EnumMap) {_			EnumMap enumMap = new EnumMap((EnumMap) map)__			enumMap.clear()__			return enumMap__		}_		else if (map instanceof SortedMap) {_			return new TreeMap<>(((SortedMap<K, V>) map).comparator())__		}_		else {_			return new LinkedHashMap<>(capacity)__		}_	};create,the,most,approximate,map,for,the,given,map,p,strong,warning,strong,since,the,parameterized,type,code,k,is,not,bound,to,the,type,of,keys,contained,in,the,supplied,code,map,type,safety,cannot,be,guaranteed,if,the,supplied,code,map,is,an,link,enum,map,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,key,type,in,the,supplied,code,map,is,an,enum,type,matching,type,code,k,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,map,or,map,keyed,by,link,object,param,map,the,original,map,object,potentially,code,null,param,capacity,the,initial,capacity,return,a,new,empty,map,instance,see,is,approximable,map,type,see,java,util,enum,map,see,java,util,tree,map,see,java,util,linked,hash,map;suppress,warnings,unchecked,rawtypes,public,static,k,v,map,k,v,create,approximate,map,nullable,object,map,int,capacity,if,map,instanceof,enum,map,enum,map,enum,map,new,enum,map,enum,map,map,enum,map,clear,return,enum,map,else,if,map,instanceof,sorted,map,return,new,tree,map,sorted,map,k,v,map,comparator,else,return,new,linked,hash,map,capacity
CollectionFactory -> @SuppressWarnings({"unchecked", "rawtypes"}) 	public static <K, V> Map<K, V> createApproximateMap(@Nullable Object map, int capacity);1530532518;Create the most approximate map for the given map._<p><strong>Warning</strong>: Since the parameterized type {@code K} is_not bound to the type of keys contained in the supplied {@code map},_type safety cannot be guaranteed if the supplied {@code map} is an_{@link EnumMap}. In such scenarios, the caller is responsible for_ensuring that the key type in the supplied {@code map} is an enum type_matching type {@code K}. As an alternative, the caller may wish to_treat the return value as a raw map or map keyed by {@link Object}._@param map the original map object, potentially {@code null}_@param capacity the initial capacity_@return a new, empty map instance_@see #isApproximableMapType_@see java.util.EnumMap_@see java.util.TreeMap_@see java.util.LinkedHashMap;@SuppressWarnings({"unchecked", "rawtypes"})_	public static <K, V> Map<K, V> createApproximateMap(@Nullable Object map, int capacity) {_		if (map instanceof EnumMap) {_			EnumMap enumMap = new EnumMap((EnumMap) map)__			enumMap.clear()__			return enumMap__		}_		else if (map instanceof SortedMap) {_			return new TreeMap<>(((SortedMap<K, V>) map).comparator())__		}_		else {_			return new LinkedHashMap<>(capacity)__		}_	};create,the,most,approximate,map,for,the,given,map,p,strong,warning,strong,since,the,parameterized,type,code,k,is,not,bound,to,the,type,of,keys,contained,in,the,supplied,code,map,type,safety,cannot,be,guaranteed,if,the,supplied,code,map,is,an,link,enum,map,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,key,type,in,the,supplied,code,map,is,an,enum,type,matching,type,code,k,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,map,or,map,keyed,by,link,object,param,map,the,original,map,object,potentially,code,null,param,capacity,the,initial,capacity,return,a,new,empty,map,instance,see,is,approximable,map,type,see,java,util,enum,map,see,java,util,tree,map,see,java,util,linked,hash,map;suppress,warnings,unchecked,rawtypes,public,static,k,v,map,k,v,create,approximate,map,nullable,object,map,int,capacity,if,map,instanceof,enum,map,enum,map,enum,map,new,enum,map,enum,map,map,enum,map,clear,return,enum,map,else,if,map,instanceof,sorted,map,return,new,tree,map,sorted,map,k,v,map,comparator,else,return,new,linked,hash,map,capacity
CollectionFactory -> @SuppressWarnings({"unchecked", "rawtypes"}) 	public static <K, V> Map<K, V> createApproximateMap(@Nullable Object map, int capacity);1545740431;Create the most approximate map for the given map._<p><strong>Warning</strong>: Since the parameterized type {@code K} is_not bound to the type of keys contained in the supplied {@code map},_type safety cannot be guaranteed if the supplied {@code map} is an_{@link EnumMap}. In such scenarios, the caller is responsible for_ensuring that the key type in the supplied {@code map} is an enum type_matching type {@code K}. As an alternative, the caller may wish to_treat the return value as a raw map or map keyed by {@link Object}._@param map the original map object, potentially {@code null}_@param capacity the initial capacity_@return a new, empty map instance_@see #isApproximableMapType_@see java.util.EnumMap_@see java.util.TreeMap_@see java.util.LinkedHashMap;@SuppressWarnings({"unchecked", "rawtypes"})_	public static <K, V> Map<K, V> createApproximateMap(@Nullable Object map, int capacity) {_		if (map instanceof EnumMap) {_			EnumMap enumMap = new EnumMap((EnumMap) map)__			enumMap.clear()__			return enumMap__		}_		else if (map instanceof SortedMap) {_			return new TreeMap<>(((SortedMap<K, V>) map).comparator())__		}_		else {_			return new LinkedHashMap<>(capacity)__		}_	};create,the,most,approximate,map,for,the,given,map,p,strong,warning,strong,since,the,parameterized,type,code,k,is,not,bound,to,the,type,of,keys,contained,in,the,supplied,code,map,type,safety,cannot,be,guaranteed,if,the,supplied,code,map,is,an,link,enum,map,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,key,type,in,the,supplied,code,map,is,an,enum,type,matching,type,code,k,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,map,or,map,keyed,by,link,object,param,map,the,original,map,object,potentially,code,null,param,capacity,the,initial,capacity,return,a,new,empty,map,instance,see,is,approximable,map,type,see,java,util,enum,map,see,java,util,tree,map,see,java,util,linked,hash,map;suppress,warnings,unchecked,rawtypes,public,static,k,v,map,k,v,create,approximate,map,nullable,object,map,int,capacity,if,map,instanceof,enum,map,enum,map,enum,map,new,enum,map,enum,map,map,enum,map,clear,return,enum,map,else,if,map,instanceof,sorted,map,return,new,tree,map,sorted,map,k,v,map,comparator,else,return,new,linked,hash,map,capacity
CollectionFactory -> @SuppressWarnings({"unchecked", "rawtypes"}) 	public static <K, V> Map<K, V> createApproximateMap(@Nullable Object map, int capacity);1549321822;Create the most approximate map for the given map._<p><strong>Warning</strong>: Since the parameterized type {@code K} is_not bound to the type of keys contained in the supplied {@code map},_type safety cannot be guaranteed if the supplied {@code map} is an_{@link EnumMap}. In such scenarios, the caller is responsible for_ensuring that the key type in the supplied {@code map} is an enum type_matching type {@code K}. As an alternative, the caller may wish to_treat the return value as a raw map or map keyed by {@link Object}._@param map the original map object, potentially {@code null}_@param capacity the initial capacity_@return a new, empty map instance_@see #isApproximableMapType_@see java.util.EnumMap_@see java.util.TreeMap_@see java.util.LinkedHashMap;@SuppressWarnings({"unchecked", "rawtypes"})_	public static <K, V> Map<K, V> createApproximateMap(@Nullable Object map, int capacity) {_		if (map instanceof EnumMap) {_			EnumMap enumMap = new EnumMap((EnumMap) map)__			enumMap.clear()__			return enumMap__		}_		else if (map instanceof SortedMap) {_			return new TreeMap<>(((SortedMap<K, V>) map).comparator())__		}_		else {_			return new LinkedHashMap<>(capacity)__		}_	};create,the,most,approximate,map,for,the,given,map,p,strong,warning,strong,since,the,parameterized,type,code,k,is,not,bound,to,the,type,of,keys,contained,in,the,supplied,code,map,type,safety,cannot,be,guaranteed,if,the,supplied,code,map,is,an,link,enum,map,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,key,type,in,the,supplied,code,map,is,an,enum,type,matching,type,code,k,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,map,or,map,keyed,by,link,object,param,map,the,original,map,object,potentially,code,null,param,capacity,the,initial,capacity,return,a,new,empty,map,instance,see,is,approximable,map,type,see,java,util,enum,map,see,java,util,tree,map,see,java,util,linked,hash,map;suppress,warnings,unchecked,rawtypes,public,static,k,v,map,k,v,create,approximate,map,nullable,object,map,int,capacity,if,map,instanceof,enum,map,enum,map,enum,map,new,enum,map,enum,map,map,enum,map,clear,return,enum,map,else,if,map,instanceof,sorted,map,return,new,tree,map,sorted,map,k,v,map,comparator,else,return,new,linked,hash,map,capacity
CollectionFactory -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public static <K, V> Map<K, V> createMap(Class<?> mapType, int initialCapacity);1385412762;Create the most approximate map for the given map._<p>Creates a TreeMap or linked Map for a SortedMap or Map, respectively._@param mapType the desired type of the target Map_@param initialCapacity the initial capacity_@return the new Map instance_@see java.util.TreeMap_@see java.util.LinkedHashMap;@SuppressWarnings({ "unchecked", "rawtypes" })_	public static <K, V> Map<K, V> createMap(Class<?> mapType, int initialCapacity) {_		if (mapType.isInterface()) {_			if (Map.class.equals(mapType)) {_				return new LinkedHashMap<K, V>(initialCapacity)__			}_			else if (SortedMap.class.equals(mapType) || mapType.equals(navigableMapClass)) {_				return new TreeMap<K, V>()__			}_			else if (MultiValueMap.class.equals(mapType)) {_				return new LinkedMultiValueMap()__			}_			else {_				throw new IllegalArgumentException("Unsupported Map interface: " + mapType.getName())__			}_		}_		else {_			if (!Map.class.isAssignableFrom(mapType)) {_				throw new IllegalArgumentException("Unsupported Map type: " + mapType.getName())__			}_			try {_				return (Map<K, V>) mapType.newInstance()__			}_			catch (Exception ex) {_				throw new IllegalArgumentException("Could not instantiate Map type: " +_						mapType.getName(), ex)__			}_		}_	};create,the,most,approximate,map,for,the,given,map,p,creates,a,tree,map,or,linked,map,for,a,sorted,map,or,map,respectively,param,map,type,the,desired,type,of,the,target,map,param,initial,capacity,the,initial,capacity,return,the,new,map,instance,see,java,util,tree,map,see,java,util,linked,hash,map;suppress,warnings,unchecked,rawtypes,public,static,k,v,map,k,v,create,map,class,map,type,int,initial,capacity,if,map,type,is,interface,if,map,class,equals,map,type,return,new,linked,hash,map,k,v,initial,capacity,else,if,sorted,map,class,equals,map,type,map,type,equals,navigable,map,class,return,new,tree,map,k,v,else,if,multi,value,map,class,equals,map,type,return,new,linked,multi,value,map,else,throw,new,illegal,argument,exception,unsupported,map,interface,map,type,get,name,else,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,unsupported,map,type,map,type,get,name,try,return,map,k,v,map,type,new,instance,catch,exception,ex,throw,new,illegal,argument,exception,could,not,instantiate,map,type,map,type,get,name,ex
CollectionFactory -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public static <K, V> Map<K, V> createMap(Class<?> mapType, int initialCapacity);1388260115;Create the most approximate map for the given map._<p>Creates a TreeMap or linked Map for a SortedMap or Map, respectively._@param mapType the desired type of the target Map_@param initialCapacity the initial capacity_@return the new Map instance_@see java.util.TreeMap_@see java.util.LinkedHashMap;@SuppressWarnings({ "unchecked", "rawtypes" })_	public static <K, V> Map<K, V> createMap(Class<?> mapType, int initialCapacity) {_		if (mapType.isInterface()) {_			if (Map.class.equals(mapType)) {_				return new LinkedHashMap<K, V>(initialCapacity)__			}_			else if (SortedMap.class.equals(mapType) || NavigableMap.class.equals(mapType)) {_				return new TreeMap<K, V>()__			}_			else if (MultiValueMap.class.equals(mapType)) {_				return new LinkedMultiValueMap()__			}_			else {_				throw new IllegalArgumentException("Unsupported Map interface: " + mapType.getName())__			}_		}_		else {_			if (!Map.class.isAssignableFrom(mapType)) {_				throw new IllegalArgumentException("Unsupported Map type: " + mapType.getName())__			}_			try {_				return (Map<K, V>) mapType.newInstance()__			}_			catch (Exception ex) {_				throw new IllegalArgumentException("Could not instantiate Map type: " +_						mapType.getName(), ex)__			}_		}_	};create,the,most,approximate,map,for,the,given,map,p,creates,a,tree,map,or,linked,map,for,a,sorted,map,or,map,respectively,param,map,type,the,desired,type,of,the,target,map,param,initial,capacity,the,initial,capacity,return,the,new,map,instance,see,java,util,tree,map,see,java,util,linked,hash,map;suppress,warnings,unchecked,rawtypes,public,static,k,v,map,k,v,create,map,class,map,type,int,initial,capacity,if,map,type,is,interface,if,map,class,equals,map,type,return,new,linked,hash,map,k,v,initial,capacity,else,if,sorted,map,class,equals,map,type,navigable,map,class,equals,map,type,return,new,tree,map,k,v,else,if,multi,value,map,class,equals,map,type,return,new,linked,multi,value,map,else,throw,new,illegal,argument,exception,unsupported,map,interface,map,type,get,name,else,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,unsupported,map,type,map,type,get,name,try,return,map,k,v,map,type,new,instance,catch,exception,ex,throw,new,illegal,argument,exception,could,not,instantiate,map,type,map,type,get,name,ex
CollectionFactory -> @Deprecated 	public static Map createConcurrentMapIfPossible(int initialCapacity);1328020251;Create a concurrent Map if possible: This implementation always_creates a {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0_requires JDK 1.5 anyway._@param initialCapacity the initial capacity of the Map_@return the new Map instance_@deprecated as of Spring 3.0, for usage on JDK 1.5 or higher;@Deprecated_	public static Map createConcurrentMapIfPossible(int initialCapacity) {_		return new ConcurrentHashMap(initialCapacity)__	};create,a,concurrent,map,if,possible,this,implementation,always,creates,a,link,java,util,concurrent,concurrent,hash,map,since,spring,3,0,requires,jdk,1,5,anyway,param,initial,capacity,the,initial,capacity,of,the,map,return,the,new,map,instance,deprecated,as,of,spring,3,0,for,usage,on,jdk,1,5,or,higher;deprecated,public,static,map,create,concurrent,map,if,possible,int,initial,capacity,return,new,concurrent,hash,map,initial,capacity
CollectionFactory -> @Deprecated 	public static Map createConcurrentMapIfPossible(int initialCapacity);1346774041;Create a concurrent Map if possible: This implementation always_creates a {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0_requires JDK 1.5 anyway._@param initialCapacity the initial capacity of the Map_@return the new Map instance_@deprecated as of Spring 3.0, for usage on JDK 1.5 or higher;@Deprecated_	public static Map createConcurrentMapIfPossible(int initialCapacity) {_		return new ConcurrentHashMap(initialCapacity)__	};create,a,concurrent,map,if,possible,this,implementation,always,creates,a,link,java,util,concurrent,concurrent,hash,map,since,spring,3,0,requires,jdk,1,5,anyway,param,initial,capacity,the,initial,capacity,of,the,map,return,the,new,map,instance,deprecated,as,of,spring,3,0,for,usage,on,jdk,1,5,or,higher;deprecated,public,static,map,create,concurrent,map,if,possible,int,initial,capacity,return,new,concurrent,hash,map,initial,capacity
CollectionFactory -> @Deprecated 	public static Map createConcurrentMapIfPossible(int initialCapacity);1346774711;Create a concurrent Map if possible: This implementation always_creates a {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0_requires JDK 1.5 anyway._@param initialCapacity the initial capacity of the Map_@return the new Map instance_@deprecated as of Spring 3.0, for usage on JDK 1.5 or higher;@Deprecated_	public static Map createConcurrentMapIfPossible(int initialCapacity) {_		return new ConcurrentHashMap(initialCapacity)__	};create,a,concurrent,map,if,possible,this,implementation,always,creates,a,link,java,util,concurrent,concurrent,hash,map,since,spring,3,0,requires,jdk,1,5,anyway,param,initial,capacity,the,initial,capacity,of,the,map,return,the,new,map,instance,deprecated,as,of,spring,3,0,for,usage,on,jdk,1,5,or,higher;deprecated,public,static,map,create,concurrent,map,if,possible,int,initial,capacity,return,new,concurrent,hash,map,initial,capacity
CollectionFactory -> @Deprecated 	public static Map createConcurrentMapIfPossible(int initialCapacity);1349903156;Create a concurrent Map if possible: This implementation always_creates a {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0_requires JDK 1.5 anyway._@param initialCapacity the initial capacity of the Map_@return the new Map instance_@deprecated as of Spring 3.0, for usage on JDK 1.5 or higher;@Deprecated_	public static Map createConcurrentMapIfPossible(int initialCapacity) {_		return new ConcurrentHashMap(initialCapacity)__	};create,a,concurrent,map,if,possible,this,implementation,always,creates,a,link,java,util,concurrent,concurrent,hash,map,since,spring,3,0,requires,jdk,1,5,anyway,param,initial,capacity,the,initial,capacity,of,the,map,return,the,new,map,instance,deprecated,as,of,spring,3,0,for,usage,on,jdk,1,5,or,higher;deprecated,public,static,map,create,concurrent,map,if,possible,int,initial,capacity,return,new,concurrent,hash,map,initial,capacity
CollectionFactory -> @Deprecated 	public static Map createConcurrentMapIfPossible(int initialCapacity);1355313310;Create a concurrent Map if possible: This implementation always_creates a {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0_requires JDK 1.5 anyway._@param initialCapacity the initial capacity of the Map_@return the new Map instance_@deprecated as of Spring 3.0, for usage on JDK 1.5 or higher;@Deprecated_	public static Map createConcurrentMapIfPossible(int initialCapacity) {_		return new ConcurrentHashMap(initialCapacity)__	};create,a,concurrent,map,if,possible,this,implementation,always,creates,a,link,java,util,concurrent,concurrent,hash,map,since,spring,3,0,requires,jdk,1,5,anyway,param,initial,capacity,the,initial,capacity,of,the,map,return,the,new,map,instance,deprecated,as,of,spring,3,0,for,usage,on,jdk,1,5,or,higher;deprecated,public,static,map,create,concurrent,map,if,possible,int,initial,capacity,return,new,concurrent,hash,map,initial,capacity
CollectionFactory -> @Deprecated 	public static Map createConcurrentMapIfPossible(int initialCapacity);1356735495;Create a concurrent Map if possible: This implementation always_creates a {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0_requires JDK 1.5 anyway._@param initialCapacity the initial capacity of the Map_@return the new Map instance_@deprecated as of Spring 3.0, for usage on JDK 1.5 or higher;@Deprecated_	public static Map createConcurrentMapIfPossible(int initialCapacity) {_		return new ConcurrentHashMap(initialCapacity)__	};create,a,concurrent,map,if,possible,this,implementation,always,creates,a,link,java,util,concurrent,concurrent,hash,map,since,spring,3,0,requires,jdk,1,5,anyway,param,initial,capacity,the,initial,capacity,of,the,map,return,the,new,map,instance,deprecated,as,of,spring,3,0,for,usage,on,jdk,1,5,or,higher;deprecated,public,static,map,create,concurrent,map,if,possible,int,initial,capacity,return,new,concurrent,hash,map,initial,capacity
CollectionFactory -> @Deprecated 	public static ConcurrentMap createConcurrentMap(int initialCapacity);1328020251;Create a concurrent Map with a dedicated {@link ConcurrentMap} interface:_This implementation always creates a {@link java.util.concurrent.ConcurrentHashMap},_since Spring 3.0 requires JDK 1.5 anyway._@param initialCapacity the initial capacity of the Map_@return the new ConcurrentMap instance_@deprecated as of Spring 3.0, for usage on JDK 1.5 or higher;@Deprecated_	public static ConcurrentMap createConcurrentMap(int initialCapacity) {_		return new JdkConcurrentHashMap(initialCapacity)__	};create,a,concurrent,map,with,a,dedicated,link,concurrent,map,interface,this,implementation,always,creates,a,link,java,util,concurrent,concurrent,hash,map,since,spring,3,0,requires,jdk,1,5,anyway,param,initial,capacity,the,initial,capacity,of,the,map,return,the,new,concurrent,map,instance,deprecated,as,of,spring,3,0,for,usage,on,jdk,1,5,or,higher;deprecated,public,static,concurrent,map,create,concurrent,map,int,initial,capacity,return,new,jdk,concurrent,hash,map,initial,capacity
CollectionFactory -> @Deprecated 	public static ConcurrentMap createConcurrentMap(int initialCapacity);1346774041;Create a concurrent Map with a dedicated {@link ConcurrentMap} interface:_This implementation always creates a {@link java.util.concurrent.ConcurrentHashMap},_since Spring 3.0 requires JDK 1.5 anyway._@param initialCapacity the initial capacity of the Map_@return the new ConcurrentMap instance_@deprecated as of Spring 3.0, for usage on JDK 1.5 or higher;@Deprecated_	public static ConcurrentMap createConcurrentMap(int initialCapacity) {_		return new JdkConcurrentHashMap(initialCapacity)__	};create,a,concurrent,map,with,a,dedicated,link,concurrent,map,interface,this,implementation,always,creates,a,link,java,util,concurrent,concurrent,hash,map,since,spring,3,0,requires,jdk,1,5,anyway,param,initial,capacity,the,initial,capacity,of,the,map,return,the,new,concurrent,map,instance,deprecated,as,of,spring,3,0,for,usage,on,jdk,1,5,or,higher;deprecated,public,static,concurrent,map,create,concurrent,map,int,initial,capacity,return,new,jdk,concurrent,hash,map,initial,capacity
CollectionFactory -> @Deprecated 	public static ConcurrentMap createConcurrentMap(int initialCapacity);1346774711;Create a concurrent Map with a dedicated {@link ConcurrentMap} interface:_This implementation always creates a {@link java.util.concurrent.ConcurrentHashMap},_since Spring 3.0 requires JDK 1.5 anyway._@param initialCapacity the initial capacity of the Map_@return the new ConcurrentMap instance_@deprecated as of Spring 3.0, for usage on JDK 1.5 or higher;@Deprecated_	public static ConcurrentMap createConcurrentMap(int initialCapacity) {_		return new JdkConcurrentHashMap(initialCapacity)__	};create,a,concurrent,map,with,a,dedicated,link,concurrent,map,interface,this,implementation,always,creates,a,link,java,util,concurrent,concurrent,hash,map,since,spring,3,0,requires,jdk,1,5,anyway,param,initial,capacity,the,initial,capacity,of,the,map,return,the,new,concurrent,map,instance,deprecated,as,of,spring,3,0,for,usage,on,jdk,1,5,or,higher;deprecated,public,static,concurrent,map,create,concurrent,map,int,initial,capacity,return,new,jdk,concurrent,hash,map,initial,capacity
CollectionFactory -> @Deprecated 	public static ConcurrentMap createConcurrentMap(int initialCapacity);1349903156;Create a concurrent Map with a dedicated {@link ConcurrentMap} interface:_This implementation always creates a {@link java.util.concurrent.ConcurrentHashMap},_since Spring 3.0 requires JDK 1.5 anyway._@param initialCapacity the initial capacity of the Map_@return the new ConcurrentMap instance_@deprecated as of Spring 3.0, for usage on JDK 1.5 or higher;@Deprecated_	public static ConcurrentMap createConcurrentMap(int initialCapacity) {_		return new JdkConcurrentHashMap(initialCapacity)__	};create,a,concurrent,map,with,a,dedicated,link,concurrent,map,interface,this,implementation,always,creates,a,link,java,util,concurrent,concurrent,hash,map,since,spring,3,0,requires,jdk,1,5,anyway,param,initial,capacity,the,initial,capacity,of,the,map,return,the,new,concurrent,map,instance,deprecated,as,of,spring,3,0,for,usage,on,jdk,1,5,or,higher;deprecated,public,static,concurrent,map,create,concurrent,map,int,initial,capacity,return,new,jdk,concurrent,hash,map,initial,capacity
CollectionFactory -> @Deprecated 	public static ConcurrentMap createConcurrentMap(int initialCapacity);1355313310;Create a concurrent Map with a dedicated {@link ConcurrentMap} interface:_This implementation always creates a {@link java.util.concurrent.ConcurrentHashMap},_since Spring 3.0 requires JDK 1.5 anyway._@param initialCapacity the initial capacity of the Map_@return the new ConcurrentMap instance_@deprecated as of Spring 3.0, for usage on JDK 1.5 or higher;@Deprecated_	public static ConcurrentMap createConcurrentMap(int initialCapacity) {_		return new JdkConcurrentHashMap(initialCapacity)__	};create,a,concurrent,map,with,a,dedicated,link,concurrent,map,interface,this,implementation,always,creates,a,link,java,util,concurrent,concurrent,hash,map,since,spring,3,0,requires,jdk,1,5,anyway,param,initial,capacity,the,initial,capacity,of,the,map,return,the,new,concurrent,map,instance,deprecated,as,of,spring,3,0,for,usage,on,jdk,1,5,or,higher;deprecated,public,static,concurrent,map,create,concurrent,map,int,initial,capacity,return,new,jdk,concurrent,hash,map,initial,capacity
CollectionFactory -> @Deprecated 	public static ConcurrentMap createConcurrentMap(int initialCapacity);1356735495;Create a concurrent Map with a dedicated {@link ConcurrentMap} interface:_This implementation always creates a {@link java.util.concurrent.ConcurrentHashMap},_since Spring 3.0 requires JDK 1.5 anyway._@param initialCapacity the initial capacity of the Map_@return the new ConcurrentMap instance_@deprecated as of Spring 3.0, for usage on JDK 1.5 or higher;@Deprecated_	public static ConcurrentMap createConcurrentMap(int initialCapacity) {_		return new JdkConcurrentHashMap(initialCapacity)__	};create,a,concurrent,map,with,a,dedicated,link,concurrent,map,interface,this,implementation,always,creates,a,link,java,util,concurrent,concurrent,hash,map,since,spring,3,0,requires,jdk,1,5,anyway,param,initial,capacity,the,initial,capacity,of,the,map,return,the,new,concurrent,map,instance,deprecated,as,of,spring,3,0,for,usage,on,jdk,1,5,or,higher;deprecated,public,static,concurrent,map,create,concurrent,map,int,initial,capacity,return,new,jdk,concurrent,hash,map,initial,capacity
CollectionFactory -> public static boolean isApproximableMapType(@Nullable Class<?> mapType);1496837955;Determine whether the given map type is an <em>approximable</em> type,_i.e. a type that {@link #createApproximateMap} can approximate._@param mapType the map type to check_@return {@code true} if the type is <em>approximable</em>;public static boolean isApproximableMapType(@Nullable Class<?> mapType) {_		return (mapType != null && approximableMapTypes.contains(mapType))__	};determine,whether,the,given,map,type,is,an,em,approximable,em,type,i,e,a,type,that,link,create,approximate,map,can,approximate,param,map,type,the,map,type,to,check,return,code,true,if,the,type,is,em,approximable,em;public,static,boolean,is,approximable,map,type,nullable,class,map,type,return,map,type,null,approximable,map,types,contains,map,type
CollectionFactory -> public static boolean isApproximableMapType(@Nullable Class<?> mapType);1530532518;Determine whether the given map type is an <em>approximable</em> type,_i.e. a type that {@link #createApproximateMap} can approximate._@param mapType the map type to check_@return {@code true} if the type is <em>approximable</em>;public static boolean isApproximableMapType(@Nullable Class<?> mapType) {_		return (mapType != null && approximableMapTypes.contains(mapType))__	};determine,whether,the,given,map,type,is,an,em,approximable,em,type,i,e,a,type,that,link,create,approximate,map,can,approximate,param,map,type,the,map,type,to,check,return,code,true,if,the,type,is,em,approximable,em;public,static,boolean,is,approximable,map,type,nullable,class,map,type,return,map,type,null,approximable,map,types,contains,map,type
CollectionFactory -> public static boolean isApproximableMapType(@Nullable Class<?> mapType);1545740431;Determine whether the given map type is an <em>approximable</em> type,_i.e. a type that {@link #createApproximateMap} can approximate._@param mapType the map type to check_@return {@code true} if the type is <em>approximable</em>;public static boolean isApproximableMapType(@Nullable Class<?> mapType) {_		return (mapType != null && approximableMapTypes.contains(mapType))__	};determine,whether,the,given,map,type,is,an,em,approximable,em,type,i,e,a,type,that,link,create,approximate,map,can,approximate,param,map,type,the,map,type,to,check,return,code,true,if,the,type,is,em,approximable,em;public,static,boolean,is,approximable,map,type,nullable,class,map,type,return,map,type,null,approximable,map,types,contains,map,type
CollectionFactory -> public static boolean isApproximableMapType(@Nullable Class<?> mapType);1549321822;Determine whether the given map type is an <em>approximable</em> type,_i.e. a type that {@link #createApproximateMap} can approximate._@param mapType the map type to check_@return {@code true} if the type is <em>approximable</em>;public static boolean isApproximableMapType(@Nullable Class<?> mapType) {_		return (mapType != null && approximableMapTypes.contains(mapType))__	};determine,whether,the,given,map,type,is,an,em,approximable,em,type,i,e,a,type,that,link,create,approximate,map,can,approximate,param,map,type,the,map,type,to,check,return,code,true,if,the,type,is,em,approximable,em;public,static,boolean,is,approximable,map,type,nullable,class,map,type,return,map,type,null,approximable,map,types,contains,map,type
CollectionFactory -> @Deprecated 	public static Map createLinkedCaseInsensitiveMapIfPossible(int initialCapacity);1328020251;Create a linked case-insensitive Map if possible: This implementation_always returns a {@link org.springframework.util.LinkedCaseInsensitiveMap}._@param initialCapacity the initial capacity of the Map_@return the new Map instance_@deprecated as of Spring 3.0, for usage on JDK 1.5 or higher;@Deprecated_	public static Map createLinkedCaseInsensitiveMapIfPossible(int initialCapacity) {_		return new LinkedCaseInsensitiveMap(initialCapacity)__	};create,a,linked,case,insensitive,map,if,possible,this,implementation,always,returns,a,link,org,springframework,util,linked,case,insensitive,map,param,initial,capacity,the,initial,capacity,of,the,map,return,the,new,map,instance,deprecated,as,of,spring,3,0,for,usage,on,jdk,1,5,or,higher;deprecated,public,static,map,create,linked,case,insensitive,map,if,possible,int,initial,capacity,return,new,linked,case,insensitive,map,initial,capacity
CollectionFactory -> @Deprecated 	public static Map createLinkedCaseInsensitiveMapIfPossible(int initialCapacity);1346774041;Create a linked case-insensitive Map if possible: This implementation_always returns a {@link org.springframework.util.LinkedCaseInsensitiveMap}._@param initialCapacity the initial capacity of the Map_@return the new Map instance_@deprecated as of Spring 3.0, for usage on JDK 1.5 or higher;@Deprecated_	public static Map createLinkedCaseInsensitiveMapIfPossible(int initialCapacity) {_		return new LinkedCaseInsensitiveMap(initialCapacity)__	};create,a,linked,case,insensitive,map,if,possible,this,implementation,always,returns,a,link,org,springframework,util,linked,case,insensitive,map,param,initial,capacity,the,initial,capacity,of,the,map,return,the,new,map,instance,deprecated,as,of,spring,3,0,for,usage,on,jdk,1,5,or,higher;deprecated,public,static,map,create,linked,case,insensitive,map,if,possible,int,initial,capacity,return,new,linked,case,insensitive,map,initial,capacity
CollectionFactory -> @Deprecated 	public static Map createLinkedCaseInsensitiveMapIfPossible(int initialCapacity);1346774711;Create a linked case-insensitive Map if possible: This implementation_always returns a {@link org.springframework.util.LinkedCaseInsensitiveMap}._@param initialCapacity the initial capacity of the Map_@return the new Map instance_@deprecated as of Spring 3.0, for usage on JDK 1.5 or higher;@Deprecated_	public static Map createLinkedCaseInsensitiveMapIfPossible(int initialCapacity) {_		return new LinkedCaseInsensitiveMap(initialCapacity)__	};create,a,linked,case,insensitive,map,if,possible,this,implementation,always,returns,a,link,org,springframework,util,linked,case,insensitive,map,param,initial,capacity,the,initial,capacity,of,the,map,return,the,new,map,instance,deprecated,as,of,spring,3,0,for,usage,on,jdk,1,5,or,higher;deprecated,public,static,map,create,linked,case,insensitive,map,if,possible,int,initial,capacity,return,new,linked,case,insensitive,map,initial,capacity
CollectionFactory -> @Deprecated 	public static Map createLinkedCaseInsensitiveMapIfPossible(int initialCapacity);1349903156;Create a linked case-insensitive Map if possible: This implementation_always returns a {@link org.springframework.util.LinkedCaseInsensitiveMap}._@param initialCapacity the initial capacity of the Map_@return the new Map instance_@deprecated as of Spring 3.0, for usage on JDK 1.5 or higher;@Deprecated_	public static Map createLinkedCaseInsensitiveMapIfPossible(int initialCapacity) {_		return new LinkedCaseInsensitiveMap(initialCapacity)__	};create,a,linked,case,insensitive,map,if,possible,this,implementation,always,returns,a,link,org,springframework,util,linked,case,insensitive,map,param,initial,capacity,the,initial,capacity,of,the,map,return,the,new,map,instance,deprecated,as,of,spring,3,0,for,usage,on,jdk,1,5,or,higher;deprecated,public,static,map,create,linked,case,insensitive,map,if,possible,int,initial,capacity,return,new,linked,case,insensitive,map,initial,capacity
CollectionFactory -> @Deprecated 	public static Map createLinkedCaseInsensitiveMapIfPossible(int initialCapacity);1355313310;Create a linked case-insensitive Map if possible: This implementation_always returns a {@link org.springframework.util.LinkedCaseInsensitiveMap}._@param initialCapacity the initial capacity of the Map_@return the new Map instance_@deprecated as of Spring 3.0, for usage on JDK 1.5 or higher;@Deprecated_	public static Map createLinkedCaseInsensitiveMapIfPossible(int initialCapacity) {_		return new LinkedCaseInsensitiveMap(initialCapacity)__	};create,a,linked,case,insensitive,map,if,possible,this,implementation,always,returns,a,link,org,springframework,util,linked,case,insensitive,map,param,initial,capacity,the,initial,capacity,of,the,map,return,the,new,map,instance,deprecated,as,of,spring,3,0,for,usage,on,jdk,1,5,or,higher;deprecated,public,static,map,create,linked,case,insensitive,map,if,possible,int,initial,capacity,return,new,linked,case,insensitive,map,initial,capacity
CollectionFactory -> @Deprecated 	public static Map createLinkedCaseInsensitiveMapIfPossible(int initialCapacity);1356735495;Create a linked case-insensitive Map if possible: This implementation_always returns a {@link org.springframework.util.LinkedCaseInsensitiveMap}._@param initialCapacity the initial capacity of the Map_@return the new Map instance_@deprecated as of Spring 3.0, for usage on JDK 1.5 or higher;@Deprecated_	public static Map createLinkedCaseInsensitiveMapIfPossible(int initialCapacity) {_		return new LinkedCaseInsensitiveMap(initialCapacity)__	};create,a,linked,case,insensitive,map,if,possible,this,implementation,always,returns,a,link,org,springframework,util,linked,case,insensitive,map,param,initial,capacity,the,initial,capacity,of,the,map,return,the,new,map,instance,deprecated,as,of,spring,3,0,for,usage,on,jdk,1,5,or,higher;deprecated,public,static,map,create,linked,case,insensitive,map,if,possible,int,initial,capacity,return,new,linked,case,insensitive,map,initial,capacity
CollectionFactory -> @SuppressWarnings({ "unchecked", "cast" }) 	public static <E> Collection<E> createCollection(Class<?> collectionType, @Nullable Class<?> elementType, int capacity);1495868221;Create the most appropriate collection for the given collection type._<p><strong>Warning</strong>: Since the parameterized type {@code E} is_not bound to the supplied {@code elementType}, type safety cannot be_guaranteed if the desired {@code collectionType} is {@link EnumSet}._In such scenarios, the caller is responsible for ensuring that the_supplied {@code elementType} is an enum type matching type {@code E}._As an alternative, the caller may wish to treat the return value as a_raw collection or collection of {@link Object}._@param collectionType the desired type of the target collection_ never {@code null}_@param elementType the collection's element type, or {@code null} if unknown_(note: only relevant for {@link EnumSet} creation)_@param capacity the initial capacity_@return a new collection instance_@since 4.1.3_@see java.util.LinkedHashSet_@see java.util.ArrayList_@see java.util.TreeSet_@see java.util.EnumSet_@throws IllegalArgumentException if the supplied {@code collectionType} is_{@code null}_ or if the desired {@code collectionType} is {@link EnumSet} and_the supplied {@code elementType} is not a subtype of {@link Enum};@SuppressWarnings({ "unchecked", "cast" })_	public static <E> Collection<E> createCollection(Class<?> collectionType, @Nullable Class<?> elementType, int capacity) {_		Assert.notNull(collectionType, "Collection type must not be null")__		if (collectionType.isInterface()) {_			if (Set.class == collectionType || Collection.class == collectionType) {_				return new LinkedHashSet<>(capacity)__			}_			else if (List.class == collectionType) {_				return new ArrayList<>(capacity)__			}_			else if (SortedSet.class == collectionType || NavigableSet.class == collectionType) {_				return new TreeSet<>()__			}_			else {_				throw new IllegalArgumentException("Unsupported Collection interface: " + collectionType.getName())__			}_		}_		else if (EnumSet.class == collectionType) {_			Assert.notNull(elementType, "Cannot create EnumSet for unknown element type")__			_			return (Collection<E>) EnumSet.noneOf(asEnumType(elementType))__		}_		else {_			if (!Collection.class.isAssignableFrom(collectionType)) {_				throw new IllegalArgumentException("Unsupported Collection type: " + collectionType.getName())__			}_			try {_				return (Collection<E>) ReflectionUtils.accessibleConstructor(collectionType).newInstance()__			}_			catch (Throwable ex) {_				throw new IllegalArgumentException(_					"Could not instantiate Collection type: " + collectionType.getName(), ex)__			}_		}_	};create,the,most,appropriate,collection,for,the,given,collection,type,p,strong,warning,strong,since,the,parameterized,type,code,e,is,not,bound,to,the,supplied,code,element,type,type,safety,cannot,be,guaranteed,if,the,desired,code,collection,type,is,link,enum,set,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,supplied,code,element,type,is,an,enum,type,matching,type,code,e,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,collection,or,collection,of,link,object,param,collection,type,the,desired,type,of,the,target,collection,never,code,null,param,element,type,the,collection,s,element,type,or,code,null,if,unknown,note,only,relevant,for,link,enum,set,creation,param,capacity,the,initial,capacity,return,a,new,collection,instance,since,4,1,3,see,java,util,linked,hash,set,see,java,util,array,list,see,java,util,tree,set,see,java,util,enum,set,throws,illegal,argument,exception,if,the,supplied,code,collection,type,is,code,null,or,if,the,desired,code,collection,type,is,link,enum,set,and,the,supplied,code,element,type,is,not,a,subtype,of,link,enum;suppress,warnings,unchecked,cast,public,static,e,collection,e,create,collection,class,collection,type,nullable,class,element,type,int,capacity,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,type,is,interface,if,set,class,collection,type,collection,class,collection,type,return,new,linked,hash,set,capacity,else,if,list,class,collection,type,return,new,array,list,capacity,else,if,sorted,set,class,collection,type,navigable,set,class,collection,type,return,new,tree,set,else,throw,new,illegal,argument,exception,unsupported,collection,interface,collection,type,get,name,else,if,enum,set,class,collection,type,assert,not,null,element,type,cannot,create,enum,set,for,unknown,element,type,return,collection,e,enum,set,none,of,as,enum,type,element,type,else,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,unsupported,collection,type,collection,type,get,name,try,return,collection,e,reflection,utils,accessible,constructor,collection,type,new,instance,catch,throwable,ex,throw,new,illegal,argument,exception,could,not,instantiate,collection,type,collection,type,get,name,ex
CollectionFactory -> @SuppressWarnings({ "unchecked", "cast" }) 	public static <E> Collection<E> createCollection(Class<?> collectionType, @Nullable Class<?> elementType, int capacity);1496837955;Create the most appropriate collection for the given collection type._<p><strong>Warning</strong>: Since the parameterized type {@code E} is_not bound to the supplied {@code elementType}, type safety cannot be_guaranteed if the desired {@code collectionType} is {@link EnumSet}._In such scenarios, the caller is responsible for ensuring that the_supplied {@code elementType} is an enum type matching type {@code E}._As an alternative, the caller may wish to treat the return value as a_raw collection or collection of {@link Object}._@param collectionType the desired type of the target collection_ never {@code null}_@param elementType the collection's element type, or {@code null} if unknown_(note: only relevant for {@link EnumSet} creation)_@param capacity the initial capacity_@return a new collection instance_@since 4.1.3_@see java.util.LinkedHashSet_@see java.util.ArrayList_@see java.util.TreeSet_@see java.util.EnumSet_@throws IllegalArgumentException if the supplied {@code collectionType} is_{@code null}_ or if the desired {@code collectionType} is {@link EnumSet} and_the supplied {@code elementType} is not a subtype of {@link Enum};@SuppressWarnings({ "unchecked", "cast" })_	public static <E> Collection<E> createCollection(Class<?> collectionType, @Nullable Class<?> elementType, int capacity) {_		Assert.notNull(collectionType, "Collection type must not be null")__		if (collectionType.isInterface()) {_			if (Set.class == collectionType || Collection.class == collectionType) {_				return new LinkedHashSet<>(capacity)__			}_			else if (List.class == collectionType) {_				return new ArrayList<>(capacity)__			}_			else if (SortedSet.class == collectionType || NavigableSet.class == collectionType) {_				return new TreeSet<>()__			}_			else {_				throw new IllegalArgumentException("Unsupported Collection interface: " + collectionType.getName())__			}_		}_		else if (EnumSet.class == collectionType) {_			Assert.notNull(elementType, "Cannot create EnumSet for unknown element type")__			_			return (Collection<E>) EnumSet.noneOf(asEnumType(elementType))__		}_		else {_			if (!Collection.class.isAssignableFrom(collectionType)) {_				throw new IllegalArgumentException("Unsupported Collection type: " + collectionType.getName())__			}_			try {_				return (Collection<E>) ReflectionUtils.accessibleConstructor(collectionType).newInstance()__			}_			catch (Throwable ex) {_				throw new IllegalArgumentException(_					"Could not instantiate Collection type: " + collectionType.getName(), ex)__			}_		}_	};create,the,most,appropriate,collection,for,the,given,collection,type,p,strong,warning,strong,since,the,parameterized,type,code,e,is,not,bound,to,the,supplied,code,element,type,type,safety,cannot,be,guaranteed,if,the,desired,code,collection,type,is,link,enum,set,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,supplied,code,element,type,is,an,enum,type,matching,type,code,e,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,collection,or,collection,of,link,object,param,collection,type,the,desired,type,of,the,target,collection,never,code,null,param,element,type,the,collection,s,element,type,or,code,null,if,unknown,note,only,relevant,for,link,enum,set,creation,param,capacity,the,initial,capacity,return,a,new,collection,instance,since,4,1,3,see,java,util,linked,hash,set,see,java,util,array,list,see,java,util,tree,set,see,java,util,enum,set,throws,illegal,argument,exception,if,the,supplied,code,collection,type,is,code,null,or,if,the,desired,code,collection,type,is,link,enum,set,and,the,supplied,code,element,type,is,not,a,subtype,of,link,enum;suppress,warnings,unchecked,cast,public,static,e,collection,e,create,collection,class,collection,type,nullable,class,element,type,int,capacity,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,type,is,interface,if,set,class,collection,type,collection,class,collection,type,return,new,linked,hash,set,capacity,else,if,list,class,collection,type,return,new,array,list,capacity,else,if,sorted,set,class,collection,type,navigable,set,class,collection,type,return,new,tree,set,else,throw,new,illegal,argument,exception,unsupported,collection,interface,collection,type,get,name,else,if,enum,set,class,collection,type,assert,not,null,element,type,cannot,create,enum,set,for,unknown,element,type,return,collection,e,enum,set,none,of,as,enum,type,element,type,else,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,unsupported,collection,type,collection,type,get,name,try,return,collection,e,reflection,utils,accessible,constructor,collection,type,new,instance,catch,throwable,ex,throw,new,illegal,argument,exception,could,not,instantiate,collection,type,collection,type,get,name,ex
CollectionFactory -> @SuppressWarnings({ "unchecked", "cast" }) 	public static <E> Collection<E> createCollection(Class<?> collectionType, @Nullable Class<?> elementType, int capacity);1530532518;Create the most appropriate collection for the given collection type._<p><strong>Warning</strong>: Since the parameterized type {@code E} is_not bound to the supplied {@code elementType}, type safety cannot be_guaranteed if the desired {@code collectionType} is {@link EnumSet}._In such scenarios, the caller is responsible for ensuring that the_supplied {@code elementType} is an enum type matching type {@code E}._As an alternative, the caller may wish to treat the return value as a_raw collection or collection of {@link Object}._@param collectionType the desired type of the target collection_ never {@code null}_@param elementType the collection's element type, or {@code null} if unknown_(note: only relevant for {@link EnumSet} creation)_@param capacity the initial capacity_@return a new collection instance_@since 4.1.3_@see java.util.LinkedHashSet_@see java.util.ArrayList_@see java.util.TreeSet_@see java.util.EnumSet_@throws IllegalArgumentException if the supplied {@code collectionType} is_{@code null}_ or if the desired {@code collectionType} is {@link EnumSet} and_the supplied {@code elementType} is not a subtype of {@link Enum};@SuppressWarnings({ "unchecked", "cast" })_	public static <E> Collection<E> createCollection(Class<?> collectionType, @Nullable Class<?> elementType, int capacity) {_		Assert.notNull(collectionType, "Collection type must not be null")__		if (collectionType.isInterface()) {_			if (Set.class == collectionType || Collection.class == collectionType) {_				return new LinkedHashSet<>(capacity)__			}_			else if (List.class == collectionType) {_				return new ArrayList<>(capacity)__			}_			else if (SortedSet.class == collectionType || NavigableSet.class == collectionType) {_				return new TreeSet<>()__			}_			else {_				throw new IllegalArgumentException("Unsupported Collection interface: " + collectionType.getName())__			}_		}_		else if (EnumSet.class == collectionType) {_			Assert.notNull(elementType, "Cannot create EnumSet for unknown element type")__			_			return (Collection<E>) EnumSet.noneOf(asEnumType(elementType))__		}_		else {_			if (!Collection.class.isAssignableFrom(collectionType)) {_				throw new IllegalArgumentException("Unsupported Collection type: " + collectionType.getName())__			}_			try {_				return (Collection<E>) ReflectionUtils.accessibleConstructor(collectionType).newInstance()__			}_			catch (Throwable ex) {_				throw new IllegalArgumentException(_					"Could not instantiate Collection type: " + collectionType.getName(), ex)__			}_		}_	};create,the,most,appropriate,collection,for,the,given,collection,type,p,strong,warning,strong,since,the,parameterized,type,code,e,is,not,bound,to,the,supplied,code,element,type,type,safety,cannot,be,guaranteed,if,the,desired,code,collection,type,is,link,enum,set,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,supplied,code,element,type,is,an,enum,type,matching,type,code,e,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,collection,or,collection,of,link,object,param,collection,type,the,desired,type,of,the,target,collection,never,code,null,param,element,type,the,collection,s,element,type,or,code,null,if,unknown,note,only,relevant,for,link,enum,set,creation,param,capacity,the,initial,capacity,return,a,new,collection,instance,since,4,1,3,see,java,util,linked,hash,set,see,java,util,array,list,see,java,util,tree,set,see,java,util,enum,set,throws,illegal,argument,exception,if,the,supplied,code,collection,type,is,code,null,or,if,the,desired,code,collection,type,is,link,enum,set,and,the,supplied,code,element,type,is,not,a,subtype,of,link,enum;suppress,warnings,unchecked,cast,public,static,e,collection,e,create,collection,class,collection,type,nullable,class,element,type,int,capacity,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,type,is,interface,if,set,class,collection,type,collection,class,collection,type,return,new,linked,hash,set,capacity,else,if,list,class,collection,type,return,new,array,list,capacity,else,if,sorted,set,class,collection,type,navigable,set,class,collection,type,return,new,tree,set,else,throw,new,illegal,argument,exception,unsupported,collection,interface,collection,type,get,name,else,if,enum,set,class,collection,type,assert,not,null,element,type,cannot,create,enum,set,for,unknown,element,type,return,collection,e,enum,set,none,of,as,enum,type,element,type,else,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,unsupported,collection,type,collection,type,get,name,try,return,collection,e,reflection,utils,accessible,constructor,collection,type,new,instance,catch,throwable,ex,throw,new,illegal,argument,exception,could,not,instantiate,collection,type,collection,type,get,name,ex
CollectionFactory -> @SuppressWarnings({ "unchecked", "cast" }) 	public static <E> Collection<E> createCollection(Class<?> collectionType, @Nullable Class<?> elementType, int capacity);1545740431;Create the most appropriate collection for the given collection type._<p><strong>Warning</strong>: Since the parameterized type {@code E} is_not bound to the supplied {@code elementType}, type safety cannot be_guaranteed if the desired {@code collectionType} is {@link EnumSet}._In such scenarios, the caller is responsible for ensuring that the_supplied {@code elementType} is an enum type matching type {@code E}._As an alternative, the caller may wish to treat the return value as a_raw collection or collection of {@link Object}._@param collectionType the desired type of the target collection_ never {@code null}_@param elementType the collection's element type, or {@code null} if unknown_(note: only relevant for {@link EnumSet} creation)_@param capacity the initial capacity_@return a new collection instance_@since 4.1.3_@see java.util.LinkedHashSet_@see java.util.ArrayList_@see java.util.TreeSet_@see java.util.EnumSet_@throws IllegalArgumentException if the supplied {@code collectionType} is_{@code null}_ or if the desired {@code collectionType} is {@link EnumSet} and_the supplied {@code elementType} is not a subtype of {@link Enum};@SuppressWarnings({ "unchecked", "cast" })_	public static <E> Collection<E> createCollection(Class<?> collectionType, @Nullable Class<?> elementType, int capacity) {_		Assert.notNull(collectionType, "Collection type must not be null")__		if (collectionType.isInterface()) {_			if (Set.class == collectionType || Collection.class == collectionType) {_				return new LinkedHashSet<>(capacity)__			}_			else if (List.class == collectionType) {_				return new ArrayList<>(capacity)__			}_			else if (SortedSet.class == collectionType || NavigableSet.class == collectionType) {_				return new TreeSet<>()__			}_			else {_				throw new IllegalArgumentException("Unsupported Collection interface: " + collectionType.getName())__			}_		}_		else if (EnumSet.class.isAssignableFrom(collectionType)) {_			Assert.notNull(elementType, "Cannot create EnumSet for unknown element type")__			_			return (Collection<E>) EnumSet.noneOf(asEnumType(elementType))__		}_		else {_			if (!Collection.class.isAssignableFrom(collectionType)) {_				throw new IllegalArgumentException("Unsupported Collection type: " + collectionType.getName())__			}_			try {_				return (Collection<E>) ReflectionUtils.accessibleConstructor(collectionType).newInstance()__			}_			catch (Throwable ex) {_				throw new IllegalArgumentException(_					"Could not instantiate Collection type: " + collectionType.getName(), ex)__			}_		}_	};create,the,most,appropriate,collection,for,the,given,collection,type,p,strong,warning,strong,since,the,parameterized,type,code,e,is,not,bound,to,the,supplied,code,element,type,type,safety,cannot,be,guaranteed,if,the,desired,code,collection,type,is,link,enum,set,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,supplied,code,element,type,is,an,enum,type,matching,type,code,e,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,collection,or,collection,of,link,object,param,collection,type,the,desired,type,of,the,target,collection,never,code,null,param,element,type,the,collection,s,element,type,or,code,null,if,unknown,note,only,relevant,for,link,enum,set,creation,param,capacity,the,initial,capacity,return,a,new,collection,instance,since,4,1,3,see,java,util,linked,hash,set,see,java,util,array,list,see,java,util,tree,set,see,java,util,enum,set,throws,illegal,argument,exception,if,the,supplied,code,collection,type,is,code,null,or,if,the,desired,code,collection,type,is,link,enum,set,and,the,supplied,code,element,type,is,not,a,subtype,of,link,enum;suppress,warnings,unchecked,cast,public,static,e,collection,e,create,collection,class,collection,type,nullable,class,element,type,int,capacity,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,type,is,interface,if,set,class,collection,type,collection,class,collection,type,return,new,linked,hash,set,capacity,else,if,list,class,collection,type,return,new,array,list,capacity,else,if,sorted,set,class,collection,type,navigable,set,class,collection,type,return,new,tree,set,else,throw,new,illegal,argument,exception,unsupported,collection,interface,collection,type,get,name,else,if,enum,set,class,is,assignable,from,collection,type,assert,not,null,element,type,cannot,create,enum,set,for,unknown,element,type,return,collection,e,enum,set,none,of,as,enum,type,element,type,else,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,unsupported,collection,type,collection,type,get,name,try,return,collection,e,reflection,utils,accessible,constructor,collection,type,new,instance,catch,throwable,ex,throw,new,illegal,argument,exception,could,not,instantiate,collection,type,collection,type,get,name,ex
CollectionFactory -> @SuppressWarnings({ "unchecked", "cast" }) 	public static <E> Collection<E> createCollection(Class<?> collectionType, @Nullable Class<?> elementType, int capacity);1549321822;Create the most appropriate collection for the given collection type._<p><strong>Warning</strong>: Since the parameterized type {@code E} is_not bound to the supplied {@code elementType}, type safety cannot be_guaranteed if the desired {@code collectionType} is {@link EnumSet}._In such scenarios, the caller is responsible for ensuring that the_supplied {@code elementType} is an enum type matching type {@code E}._As an alternative, the caller may wish to treat the return value as a_raw collection or collection of {@link Object}._@param collectionType the desired type of the target collection (never {@code null})_@param elementType the collection's element type, or {@code null} if unknown_(note: only relevant for {@link EnumSet} creation)_@param capacity the initial capacity_@return a new collection instance_@since 4.1.3_@see java.util.LinkedHashSet_@see java.util.ArrayList_@see java.util.TreeSet_@see java.util.EnumSet_@throws IllegalArgumentException if the supplied {@code collectionType} is_{@code null}_ or if the desired {@code collectionType} is {@link EnumSet} and_the supplied {@code elementType} is not a subtype of {@link Enum};@SuppressWarnings({ "unchecked", "cast" })_	public static <E> Collection<E> createCollection(Class<?> collectionType, @Nullable Class<?> elementType, int capacity) {_		Assert.notNull(collectionType, "Collection type must not be null")__		if (collectionType.isInterface()) {_			if (Set.class == collectionType || Collection.class == collectionType) {_				return new LinkedHashSet<>(capacity)__			}_			else if (List.class == collectionType) {_				return new ArrayList<>(capacity)__			}_			else if (SortedSet.class == collectionType || NavigableSet.class == collectionType) {_				return new TreeSet<>()__			}_			else {_				throw new IllegalArgumentException("Unsupported Collection interface: " + collectionType.getName())__			}_		}_		else if (EnumSet.class.isAssignableFrom(collectionType)) {_			Assert.notNull(elementType, "Cannot create EnumSet for unknown element type")__			_			return (Collection<E>) EnumSet.noneOf(asEnumType(elementType))__		}_		else {_			if (!Collection.class.isAssignableFrom(collectionType)) {_				throw new IllegalArgumentException("Unsupported Collection type: " + collectionType.getName())__			}_			try {_				return (Collection<E>) ReflectionUtils.accessibleConstructor(collectionType).newInstance()__			}_			catch (Throwable ex) {_				throw new IllegalArgumentException(_					"Could not instantiate Collection type: " + collectionType.getName(), ex)__			}_		}_	};create,the,most,appropriate,collection,for,the,given,collection,type,p,strong,warning,strong,since,the,parameterized,type,code,e,is,not,bound,to,the,supplied,code,element,type,type,safety,cannot,be,guaranteed,if,the,desired,code,collection,type,is,link,enum,set,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,supplied,code,element,type,is,an,enum,type,matching,type,code,e,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,collection,or,collection,of,link,object,param,collection,type,the,desired,type,of,the,target,collection,never,code,null,param,element,type,the,collection,s,element,type,or,code,null,if,unknown,note,only,relevant,for,link,enum,set,creation,param,capacity,the,initial,capacity,return,a,new,collection,instance,since,4,1,3,see,java,util,linked,hash,set,see,java,util,array,list,see,java,util,tree,set,see,java,util,enum,set,throws,illegal,argument,exception,if,the,supplied,code,collection,type,is,code,null,or,if,the,desired,code,collection,type,is,link,enum,set,and,the,supplied,code,element,type,is,not,a,subtype,of,link,enum;suppress,warnings,unchecked,cast,public,static,e,collection,e,create,collection,class,collection,type,nullable,class,element,type,int,capacity,assert,not,null,collection,type,collection,type,must,not,be,null,if,collection,type,is,interface,if,set,class,collection,type,collection,class,collection,type,return,new,linked,hash,set,capacity,else,if,list,class,collection,type,return,new,array,list,capacity,else,if,sorted,set,class,collection,type,navigable,set,class,collection,type,return,new,tree,set,else,throw,new,illegal,argument,exception,unsupported,collection,interface,collection,type,get,name,else,if,enum,set,class,is,assignable,from,collection,type,assert,not,null,element,type,cannot,create,enum,set,for,unknown,element,type,return,collection,e,enum,set,none,of,as,enum,type,element,type,else,if,collection,class,is,assignable,from,collection,type,throw,new,illegal,argument,exception,unsupported,collection,type,collection,type,get,name,try,return,collection,e,reflection,utils,accessible,constructor,collection,type,new,instance,catch,throwable,ex,throw,new,illegal,argument,exception,could,not,instantiate,collection,type,collection,type,get,name,ex
CollectionFactory -> @SuppressWarnings({ "unchecked", "cast", "rawtypes" }) 	public static <E> Collection<E> createApproximateCollection(Object collection, int capacity);1418156945;Create the most approximate collection for the given collection._@param collection the original Collection object_@param capacity the initial capacity_@return the new Collection instance_@see java.util.LinkedHashSet_@see java.util.TreeSet_@see java.util.EnumSet_@see java.util.ArrayList_@see java.util.LinkedList;@SuppressWarnings({ "unchecked", "cast", "rawtypes" })_	public static <E> Collection<E> createApproximateCollection(Object collection, int capacity) {_		if (collection instanceof LinkedList) {_			return new LinkedList<E>()__		}_		else if (collection instanceof List) {_			return new ArrayList<E>(capacity)__		}_		else if (collection instanceof EnumSet) {_			_			_			return (Collection<E>) EnumSet.copyOf((EnumSet) collection)__		}_		else if (collection instanceof SortedSet) {_			return new TreeSet<E>(((SortedSet<E>) collection).comparator())__		}_		else {_			return new LinkedHashSet<E>(capacity)__		}_	};create,the,most,approximate,collection,for,the,given,collection,param,collection,the,original,collection,object,param,capacity,the,initial,capacity,return,the,new,collection,instance,see,java,util,linked,hash,set,see,java,util,tree,set,see,java,util,enum,set,see,java,util,array,list,see,java,util,linked,list;suppress,warnings,unchecked,cast,rawtypes,public,static,e,collection,e,create,approximate,collection,object,collection,int,capacity,if,collection,instanceof,linked,list,return,new,linked,list,e,else,if,collection,instanceof,list,return,new,array,list,e,capacity,else,if,collection,instanceof,enum,set,return,collection,e,enum,set,copy,of,enum,set,collection,else,if,collection,instanceof,sorted,set,return,new,tree,set,e,sorted,set,e,collection,comparator,else,return,new,linked,hash,set,e,capacity
CollectionFactory -> @SuppressWarnings({ "unchecked", "cast", "rawtypes" }) 	public static <E> Collection<E> createApproximateCollection(Object collection, int capacity);1418219235;Create the most approximate collection for the given collection._@param collection the original Collection object_@param capacity the initial capacity_@return the new Collection instance_@see java.util.LinkedHashSet_@see java.util.TreeSet_@see java.util.EnumSet_@see java.util.ArrayList_@see java.util.LinkedList;@SuppressWarnings({ "unchecked", "cast", "rawtypes" })_	public static <E> Collection<E> createApproximateCollection(Object collection, int capacity) {_		if (collection instanceof LinkedList) {_			return new LinkedList<E>()__		}_		else if (collection instanceof List) {_			return new ArrayList<E>(capacity)__		}_		else if (collection instanceof EnumSet) {_			_			_			return (Collection<E>) EnumSet.copyOf((EnumSet) collection)__		}_		else if (collection instanceof SortedSet) {_			return new TreeSet<E>(((SortedSet<E>) collection).comparator())__		}_		else {_			return new LinkedHashSet<E>(capacity)__		}_	};create,the,most,approximate,collection,for,the,given,collection,param,collection,the,original,collection,object,param,capacity,the,initial,capacity,return,the,new,collection,instance,see,java,util,linked,hash,set,see,java,util,tree,set,see,java,util,enum,set,see,java,util,array,list,see,java,util,linked,list;suppress,warnings,unchecked,cast,rawtypes,public,static,e,collection,e,create,approximate,collection,object,collection,int,capacity,if,collection,instanceof,linked,list,return,new,linked,list,e,else,if,collection,instanceof,list,return,new,array,list,e,capacity,else,if,collection,instanceof,enum,set,return,collection,e,enum,set,copy,of,enum,set,collection,else,if,collection,instanceof,sorted,set,return,new,tree,set,e,sorted,set,e,collection,comparator,else,return,new,linked,hash,set,e,capacity
CollectionFactory -> @SuppressWarnings({ "unchecked", "cast", "rawtypes" }) 	public static <E> Collection<E> createApproximateCollection(Object collection, int capacity);1418248740;Create the most approximate collection for the given collection._@param collection the original collection object_@param capacity the initial capacity_@return the new, empty collection instance_@see #isApproximableCollectionType_@see java.util.LinkedList_@see java.util.ArrayList_@see java.util.EnumSet_@see java.util.TreeSet_@see java.util.LinkedHashSet;@SuppressWarnings({ "unchecked", "cast", "rawtypes" })_	public static <E> Collection<E> createApproximateCollection(Object collection, int capacity) {_		if (collection instanceof LinkedList) {_			return new LinkedList<E>()__		}_		else if (collection instanceof List) {_			return new ArrayList<E>(capacity)__		}_		else if (collection instanceof EnumSet) {_			_			Collection<E> enumSet = (Collection<E>) EnumSet.copyOf((EnumSet) collection)__			enumSet.clear()__			return enumSet__		}_		else if (collection instanceof SortedSet) {_			return new TreeSet<E>(((SortedSet<E>) collection).comparator())__		}_		else {_			return new LinkedHashSet<E>(capacity)__		}_	};create,the,most,approximate,collection,for,the,given,collection,param,collection,the,original,collection,object,param,capacity,the,initial,capacity,return,the,new,empty,collection,instance,see,is,approximable,collection,type,see,java,util,linked,list,see,java,util,array,list,see,java,util,enum,set,see,java,util,tree,set,see,java,util,linked,hash,set;suppress,warnings,unchecked,cast,rawtypes,public,static,e,collection,e,create,approximate,collection,object,collection,int,capacity,if,collection,instanceof,linked,list,return,new,linked,list,e,else,if,collection,instanceof,list,return,new,array,list,e,capacity,else,if,collection,instanceof,enum,set,collection,e,enum,set,collection,e,enum,set,copy,of,enum,set,collection,enum,set,clear,return,enum,set,else,if,collection,instanceof,sorted,set,return,new,tree,set,e,sorted,set,e,collection,comparator,else,return,new,linked,hash,set,e,capacity
CollectionFactory -> @SuppressWarnings({ "unchecked", "cast", "rawtypes" }) 	public static <E> Collection<E> createApproximateCollection(Object collection, int capacity);1419862420;Create the most approximate collection for the given collection._@param collection the original collection object_@param capacity the initial capacity_@return the new, empty collection instance_@see #isApproximableCollectionType_@see java.util.LinkedList_@see java.util.ArrayList_@see java.util.EnumSet_@see java.util.TreeSet_@see java.util.LinkedHashSet;@SuppressWarnings({ "unchecked", "cast", "rawtypes" })_	public static <E> Collection<E> createApproximateCollection(Object collection, int capacity) {_		if (collection instanceof LinkedList) {_			return new LinkedList<E>()__		}_		else if (collection instanceof List) {_			return new ArrayList<E>(capacity)__		}_		else if (collection instanceof EnumSet) {_			_			Collection<E> enumSet = (Collection<E>) EnumSet.copyOf((EnumSet) collection)__			enumSet.clear()__			return enumSet__		}_		else if (collection instanceof SortedSet) {_			return new TreeSet<E>(((SortedSet<E>) collection).comparator())__		}_		else {_			return new LinkedHashSet<E>(capacity)__		}_	};create,the,most,approximate,collection,for,the,given,collection,param,collection,the,original,collection,object,param,capacity,the,initial,capacity,return,the,new,empty,collection,instance,see,is,approximable,collection,type,see,java,util,linked,list,see,java,util,array,list,see,java,util,enum,set,see,java,util,tree,set,see,java,util,linked,hash,set;suppress,warnings,unchecked,cast,rawtypes,public,static,e,collection,e,create,approximate,collection,object,collection,int,capacity,if,collection,instanceof,linked,list,return,new,linked,list,e,else,if,collection,instanceof,list,return,new,array,list,e,capacity,else,if,collection,instanceof,enum,set,collection,e,enum,set,collection,e,enum,set,copy,of,enum,set,collection,enum,set,clear,return,enum,set,else,if,collection,instanceof,sorted,set,return,new,tree,set,e,sorted,set,e,collection,comparator,else,return,new,linked,hash,set,e,capacity
CollectionFactory -> @SuppressWarnings({ "unchecked", "cast", "rawtypes" }) 	public static <E> Collection<E> createApproximateCollection(Object collection, int capacity);1420408095;Create the most approximate collection for the given collection._<p><strong>Warning</strong>: Since the parameterized type {@code E} is_not bound to the type of elements contained in the supplied_{@code collection}, type safety cannot be guaranteed if the supplied_{@code collection} is an {@link EnumSet}. In such scenarios, the caller_is responsible for ensuring that the element type for the supplied_{@code collection} is an enum type matching type {@code E}. As an_alternative, the caller may wish to treat the return value as a raw_collection or collection of {@link Object}._@param collection the original collection object, potentially {@code null}_@param capacity the initial capacity_@return a new, empty collection instance_@see #isApproximableCollectionType_@see java.util.LinkedList_@see java.util.ArrayList_@see java.util.EnumSet_@see java.util.TreeSet_@see java.util.LinkedHashSet;@SuppressWarnings({ "unchecked", "cast", "rawtypes" })_	public static <E> Collection<E> createApproximateCollection(Object collection, int capacity) {_		if (collection instanceof LinkedList) {_			return new LinkedList<E>()__		}_		else if (collection instanceof List) {_			return new ArrayList<E>(capacity)__		}_		else if (collection instanceof EnumSet) {_			_			Collection<E> enumSet = (Collection<E>) EnumSet.copyOf((EnumSet) collection)__			enumSet.clear()__			return enumSet__		}_		else if (collection instanceof SortedSet) {_			return new TreeSet<E>(((SortedSet<E>) collection).comparator())__		}_		else {_			return new LinkedHashSet<E>(capacity)__		}_	};create,the,most,approximate,collection,for,the,given,collection,p,strong,warning,strong,since,the,parameterized,type,code,e,is,not,bound,to,the,type,of,elements,contained,in,the,supplied,code,collection,type,safety,cannot,be,guaranteed,if,the,supplied,code,collection,is,an,link,enum,set,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,element,type,for,the,supplied,code,collection,is,an,enum,type,matching,type,code,e,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,collection,or,collection,of,link,object,param,collection,the,original,collection,object,potentially,code,null,param,capacity,the,initial,capacity,return,a,new,empty,collection,instance,see,is,approximable,collection,type,see,java,util,linked,list,see,java,util,array,list,see,java,util,enum,set,see,java,util,tree,set,see,java,util,linked,hash,set;suppress,warnings,unchecked,cast,rawtypes,public,static,e,collection,e,create,approximate,collection,object,collection,int,capacity,if,collection,instanceof,linked,list,return,new,linked,list,e,else,if,collection,instanceof,list,return,new,array,list,e,capacity,else,if,collection,instanceof,enum,set,collection,e,enum,set,collection,e,enum,set,copy,of,enum,set,collection,enum,set,clear,return,enum,set,else,if,collection,instanceof,sorted,set,return,new,tree,set,e,sorted,set,e,collection,comparator,else,return,new,linked,hash,set,e,capacity
CollectionFactory -> @SuppressWarnings({ "unchecked", "cast", "rawtypes" }) 	public static <E> Collection<E> createApproximateCollection(Object collection, int capacity);1432125256;Create the most approximate collection for the given collection._<p><strong>Warning</strong>: Since the parameterized type {@code E} is_not bound to the type of elements contained in the supplied_{@code collection}, type safety cannot be guaranteed if the supplied_{@code collection} is an {@link EnumSet}. In such scenarios, the caller_is responsible for ensuring that the element type for the supplied_{@code collection} is an enum type matching type {@code E}. As an_alternative, the caller may wish to treat the return value as a raw_collection or collection of {@link Object}._@param collection the original collection object, potentially {@code null}_@param capacity the initial capacity_@return a new, empty collection instance_@see #isApproximableCollectionType_@see java.util.LinkedList_@see java.util.ArrayList_@see java.util.EnumSet_@see java.util.TreeSet_@see java.util.LinkedHashSet;@SuppressWarnings({ "unchecked", "cast", "rawtypes" })_	public static <E> Collection<E> createApproximateCollection(Object collection, int capacity) {_		if (collection instanceof LinkedList) {_			return new LinkedList<E>()__		}_		else if (collection instanceof List) {_			return new ArrayList<E>(capacity)__		}_		else if (collection instanceof EnumSet) {_			_			Collection<E> enumSet = (Collection<E>) EnumSet.copyOf((EnumSet) collection)__			enumSet.clear()__			return enumSet__		}_		else if (collection instanceof SortedSet) {_			return new TreeSet<E>(((SortedSet<E>) collection).comparator())__		}_		else {_			return new LinkedHashSet<E>(capacity)__		}_	};create,the,most,approximate,collection,for,the,given,collection,p,strong,warning,strong,since,the,parameterized,type,code,e,is,not,bound,to,the,type,of,elements,contained,in,the,supplied,code,collection,type,safety,cannot,be,guaranteed,if,the,supplied,code,collection,is,an,link,enum,set,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,element,type,for,the,supplied,code,collection,is,an,enum,type,matching,type,code,e,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,collection,or,collection,of,link,object,param,collection,the,original,collection,object,potentially,code,null,param,capacity,the,initial,capacity,return,a,new,empty,collection,instance,see,is,approximable,collection,type,see,java,util,linked,list,see,java,util,array,list,see,java,util,enum,set,see,java,util,tree,set,see,java,util,linked,hash,set;suppress,warnings,unchecked,cast,rawtypes,public,static,e,collection,e,create,approximate,collection,object,collection,int,capacity,if,collection,instanceof,linked,list,return,new,linked,list,e,else,if,collection,instanceof,list,return,new,array,list,e,capacity,else,if,collection,instanceof,enum,set,collection,e,enum,set,collection,e,enum,set,copy,of,enum,set,collection,enum,set,clear,return,enum,set,else,if,collection,instanceof,sorted,set,return,new,tree,set,e,sorted,set,e,collection,comparator,else,return,new,linked,hash,set,e,capacity
CollectionFactory -> @SuppressWarnings({ "unchecked", "cast", "rawtypes" }) 	public static <E> Collection<E> createApproximateCollection(Object collection, int capacity);1467730834;Create the most approximate collection for the given collection._<p><strong>Warning</strong>: Since the parameterized type {@code E} is_not bound to the type of elements contained in the supplied_{@code collection}, type safety cannot be guaranteed if the supplied_{@code collection} is an {@link EnumSet}. In such scenarios, the caller_is responsible for ensuring that the element type for the supplied_{@code collection} is an enum type matching type {@code E}. As an_alternative, the caller may wish to treat the return value as a raw_collection or collection of {@link Object}._@param collection the original collection object, potentially {@code null}_@param capacity the initial capacity_@return a new, empty collection instance_@see #isApproximableCollectionType_@see java.util.LinkedList_@see java.util.ArrayList_@see java.util.EnumSet_@see java.util.TreeSet_@see java.util.LinkedHashSet;@SuppressWarnings({ "unchecked", "cast", "rawtypes" })_	public static <E> Collection<E> createApproximateCollection(Object collection, int capacity) {_		if (collection instanceof LinkedList) {_			return new LinkedList<>()__		}_		else if (collection instanceof List) {_			return new ArrayList<>(capacity)__		}_		else if (collection instanceof EnumSet) {_			_			Collection<E> enumSet = (Collection<E>) EnumSet.copyOf((EnumSet) collection)__			enumSet.clear()__			return enumSet__		}_		else if (collection instanceof SortedSet) {_			return new TreeSet<>(((SortedSet<E>) collection).comparator())__		}_		else {_			return new LinkedHashSet<>(capacity)__		}_	};create,the,most,approximate,collection,for,the,given,collection,p,strong,warning,strong,since,the,parameterized,type,code,e,is,not,bound,to,the,type,of,elements,contained,in,the,supplied,code,collection,type,safety,cannot,be,guaranteed,if,the,supplied,code,collection,is,an,link,enum,set,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,element,type,for,the,supplied,code,collection,is,an,enum,type,matching,type,code,e,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,collection,or,collection,of,link,object,param,collection,the,original,collection,object,potentially,code,null,param,capacity,the,initial,capacity,return,a,new,empty,collection,instance,see,is,approximable,collection,type,see,java,util,linked,list,see,java,util,array,list,see,java,util,enum,set,see,java,util,tree,set,see,java,util,linked,hash,set;suppress,warnings,unchecked,cast,rawtypes,public,static,e,collection,e,create,approximate,collection,object,collection,int,capacity,if,collection,instanceof,linked,list,return,new,linked,list,else,if,collection,instanceof,list,return,new,array,list,capacity,else,if,collection,instanceof,enum,set,collection,e,enum,set,collection,e,enum,set,copy,of,enum,set,collection,enum,set,clear,return,enum,set,else,if,collection,instanceof,sorted,set,return,new,tree,set,sorted,set,e,collection,comparator,else,return,new,linked,hash,set,capacity
CollectionFactory -> @SuppressWarnings({ "unchecked", "cast", "rawtypes" }) 	public static <E> Collection<E> createApproximateCollection(Object collection, int capacity);1468948866;Create the most approximate collection for the given collection._<p><strong>Warning</strong>: Since the parameterized type {@code E} is_not bound to the type of elements contained in the supplied_{@code collection}, type safety cannot be guaranteed if the supplied_{@code collection} is an {@link EnumSet}. In such scenarios, the caller_is responsible for ensuring that the element type for the supplied_{@code collection} is an enum type matching type {@code E}. As an_alternative, the caller may wish to treat the return value as a raw_collection or collection of {@link Object}._@param collection the original collection object, potentially {@code null}_@param capacity the initial capacity_@return a new, empty collection instance_@see #isApproximableCollectionType_@see java.util.LinkedList_@see java.util.ArrayList_@see java.util.EnumSet_@see java.util.TreeSet_@see java.util.LinkedHashSet;@SuppressWarnings({ "unchecked", "cast", "rawtypes" })_	public static <E> Collection<E> createApproximateCollection(Object collection, int capacity) {_		if (collection instanceof LinkedList) {_			return new LinkedList<>()__		}_		else if (collection instanceof List) {_			return new ArrayList<>(capacity)__		}_		else if (collection instanceof EnumSet) {_			_			Collection<E> enumSet = (Collection<E>) EnumSet.copyOf((EnumSet) collection)__			enumSet.clear()__			return enumSet__		}_		else if (collection instanceof SortedSet) {_			return new TreeSet<>(((SortedSet<E>) collection).comparator())__		}_		else {_			return new LinkedHashSet<>(capacity)__		}_	};create,the,most,approximate,collection,for,the,given,collection,p,strong,warning,strong,since,the,parameterized,type,code,e,is,not,bound,to,the,type,of,elements,contained,in,the,supplied,code,collection,type,safety,cannot,be,guaranteed,if,the,supplied,code,collection,is,an,link,enum,set,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,element,type,for,the,supplied,code,collection,is,an,enum,type,matching,type,code,e,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,collection,or,collection,of,link,object,param,collection,the,original,collection,object,potentially,code,null,param,capacity,the,initial,capacity,return,a,new,empty,collection,instance,see,is,approximable,collection,type,see,java,util,linked,list,see,java,util,array,list,see,java,util,enum,set,see,java,util,tree,set,see,java,util,linked,hash,set;suppress,warnings,unchecked,cast,rawtypes,public,static,e,collection,e,create,approximate,collection,object,collection,int,capacity,if,collection,instanceof,linked,list,return,new,linked,list,else,if,collection,instanceof,list,return,new,array,list,capacity,else,if,collection,instanceof,enum,set,collection,e,enum,set,collection,e,enum,set,copy,of,enum,set,collection,enum,set,clear,return,enum,set,else,if,collection,instanceof,sorted,set,return,new,tree,set,sorted,set,e,collection,comparator,else,return,new,linked,hash,set,capacity
CollectionFactory -> @SuppressWarnings({ "unchecked", "cast", "rawtypes" }) 	public static <E> Collection<E> createApproximateCollection(Object collection, int capacity);1474830340;Create the most approximate collection for the given collection._<p><strong>Warning</strong>: Since the parameterized type {@code E} is_not bound to the type of elements contained in the supplied_{@code collection}, type safety cannot be guaranteed if the supplied_{@code collection} is an {@link EnumSet}. In such scenarios, the caller_is responsible for ensuring that the element type for the supplied_{@code collection} is an enum type matching type {@code E}. As an_alternative, the caller may wish to treat the return value as a raw_collection or collection of {@link Object}._@param collection the original collection object, potentially {@code null}_@param capacity the initial capacity_@return a new, empty collection instance_@see #isApproximableCollectionType_@see java.util.LinkedList_@see java.util.ArrayList_@see java.util.EnumSet_@see java.util.TreeSet_@see java.util.LinkedHashSet;@SuppressWarnings({ "unchecked", "cast", "rawtypes" })_	public static <E> Collection<E> createApproximateCollection(Object collection, int capacity) {_		if (collection instanceof LinkedList) {_			return new LinkedList<>()__		}_		else if (collection instanceof List) {_			return new ArrayList<>(capacity)__		}_		else if (collection instanceof EnumSet) {_			_			Collection<E> enumSet = (Collection<E>) EnumSet.copyOf((EnumSet) collection)__			enumSet.clear()__			return enumSet__		}_		else if (collection instanceof SortedSet) {_			return new TreeSet<>(((SortedSet<E>) collection).comparator())__		}_		else {_			return new LinkedHashSet<>(capacity)__		}_	};create,the,most,approximate,collection,for,the,given,collection,p,strong,warning,strong,since,the,parameterized,type,code,e,is,not,bound,to,the,type,of,elements,contained,in,the,supplied,code,collection,type,safety,cannot,be,guaranteed,if,the,supplied,code,collection,is,an,link,enum,set,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,element,type,for,the,supplied,code,collection,is,an,enum,type,matching,type,code,e,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,collection,or,collection,of,link,object,param,collection,the,original,collection,object,potentially,code,null,param,capacity,the,initial,capacity,return,a,new,empty,collection,instance,see,is,approximable,collection,type,see,java,util,linked,list,see,java,util,array,list,see,java,util,enum,set,see,java,util,tree,set,see,java,util,linked,hash,set;suppress,warnings,unchecked,cast,rawtypes,public,static,e,collection,e,create,approximate,collection,object,collection,int,capacity,if,collection,instanceof,linked,list,return,new,linked,list,else,if,collection,instanceof,list,return,new,array,list,capacity,else,if,collection,instanceof,enum,set,collection,e,enum,set,collection,e,enum,set,copy,of,enum,set,collection,enum,set,clear,return,enum,set,else,if,collection,instanceof,sorted,set,return,new,tree,set,sorted,set,e,collection,comparator,else,return,new,linked,hash,set,capacity
CollectionFactory -> @SuppressWarnings({ "unchecked", "cast", "rawtypes" }) 	public static <E> Collection<E> createApproximateCollection(Object collection, int capacity);1484252281;Create the most approximate collection for the given collection._<p><strong>Warning</strong>: Since the parameterized type {@code E} is_not bound to the type of elements contained in the supplied_{@code collection}, type safety cannot be guaranteed if the supplied_{@code collection} is an {@link EnumSet}. In such scenarios, the caller_is responsible for ensuring that the element type for the supplied_{@code collection} is an enum type matching type {@code E}. As an_alternative, the caller may wish to treat the return value as a raw_collection or collection of {@link Object}._@param collection the original collection object, potentially {@code null}_@param capacity the initial capacity_@return a new, empty collection instance_@see #isApproximableCollectionType_@see java.util.LinkedList_@see java.util.ArrayList_@see java.util.EnumSet_@see java.util.TreeSet_@see java.util.LinkedHashSet;@SuppressWarnings({ "unchecked", "cast", "rawtypes" })_	public static <E> Collection<E> createApproximateCollection(Object collection, int capacity) {_		if (collection instanceof LinkedList) {_			return new LinkedList<>()__		}_		else if (collection instanceof List) {_			return new ArrayList<>(capacity)__		}_		else if (collection instanceof EnumSet) {_			_			Collection<E> enumSet = (Collection<E>) EnumSet.copyOf((EnumSet) collection)__			enumSet.clear()__			return enumSet__		}_		else if (collection instanceof SortedSet) {_			return new TreeSet<>(((SortedSet<E>) collection).comparator())__		}_		else {_			return new LinkedHashSet<>(capacity)__		}_	};create,the,most,approximate,collection,for,the,given,collection,p,strong,warning,strong,since,the,parameterized,type,code,e,is,not,bound,to,the,type,of,elements,contained,in,the,supplied,code,collection,type,safety,cannot,be,guaranteed,if,the,supplied,code,collection,is,an,link,enum,set,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,element,type,for,the,supplied,code,collection,is,an,enum,type,matching,type,code,e,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,collection,or,collection,of,link,object,param,collection,the,original,collection,object,potentially,code,null,param,capacity,the,initial,capacity,return,a,new,empty,collection,instance,see,is,approximable,collection,type,see,java,util,linked,list,see,java,util,array,list,see,java,util,enum,set,see,java,util,tree,set,see,java,util,linked,hash,set;suppress,warnings,unchecked,cast,rawtypes,public,static,e,collection,e,create,approximate,collection,object,collection,int,capacity,if,collection,instanceof,linked,list,return,new,linked,list,else,if,collection,instanceof,list,return,new,array,list,capacity,else,if,collection,instanceof,enum,set,collection,e,enum,set,collection,e,enum,set,copy,of,enum,set,collection,enum,set,clear,return,enum,set,else,if,collection,instanceof,sorted,set,return,new,tree,set,sorted,set,e,collection,comparator,else,return,new,linked,hash,set,capacity
CollectionFactory -> @SuppressWarnings("unchecked") 	public static <E> Collection<E> createApproximateCollection(Object collection, int initialCapacity);1385412762;Create the most approximate collection for the given collection._<p>Creates an ArrayList, TreeSet or linked Set for a List, SortedSet_or Set, respectively._@param collection the original Collection object_@param initialCapacity the initial capacity_@return the new Collection instance_@see java.util.ArrayList_@see java.util.TreeSet_@see java.util.LinkedHashSet;@SuppressWarnings("unchecked")_	public static <E> Collection<E> createApproximateCollection(Object collection, int initialCapacity) {_		if (collection instanceof LinkedList) {_			return new LinkedList<E>()__		}_		else if (collection instanceof List) {_			return new ArrayList<E>(initialCapacity)__		}_		else if (collection instanceof SortedSet) {_			return new TreeSet<E>(((SortedSet<E>) collection).comparator())__		}_		else {_			return new LinkedHashSet<E>(initialCapacity)__		}_	};create,the,most,approximate,collection,for,the,given,collection,p,creates,an,array,list,tree,set,or,linked,set,for,a,list,sorted,set,or,set,respectively,param,collection,the,original,collection,object,param,initial,capacity,the,initial,capacity,return,the,new,collection,instance,see,java,util,array,list,see,java,util,tree,set,see,java,util,linked,hash,set;suppress,warnings,unchecked,public,static,e,collection,e,create,approximate,collection,object,collection,int,initial,capacity,if,collection,instanceof,linked,list,return,new,linked,list,e,else,if,collection,instanceof,list,return,new,array,list,e,initial,capacity,else,if,collection,instanceof,sorted,set,return,new,tree,set,e,sorted,set,e,collection,comparator,else,return,new,linked,hash,set,e,initial,capacity
CollectionFactory -> @SuppressWarnings("unchecked") 	public static <E> Collection<E> createApproximateCollection(Object collection, int initialCapacity);1388260115;Create the most approximate collection for the given collection._<p>Creates an ArrayList, TreeSet or linked Set for a List, SortedSet_or Set, respectively._@param collection the original Collection object_@param initialCapacity the initial capacity_@return the new Collection instance_@see java.util.ArrayList_@see java.util.TreeSet_@see java.util.LinkedHashSet;@SuppressWarnings("unchecked")_	public static <E> Collection<E> createApproximateCollection(Object collection, int initialCapacity) {_		if (collection instanceof LinkedList) {_			return new LinkedList<E>()__		}_		else if (collection instanceof List) {_			return new ArrayList<E>(initialCapacity)__		}_		else if (collection instanceof SortedSet) {_			return new TreeSet<E>(((SortedSet<E>) collection).comparator())__		}_		else {_			return new LinkedHashSet<E>(initialCapacity)__		}_	};create,the,most,approximate,collection,for,the,given,collection,p,creates,an,array,list,tree,set,or,linked,set,for,a,list,sorted,set,or,set,respectively,param,collection,the,original,collection,object,param,initial,capacity,the,initial,capacity,return,the,new,collection,instance,see,java,util,array,list,see,java,util,tree,set,see,java,util,linked,hash,set;suppress,warnings,unchecked,public,static,e,collection,e,create,approximate,collection,object,collection,int,initial,capacity,if,collection,instanceof,linked,list,return,new,linked,list,e,else,if,collection,instanceof,list,return,new,array,list,e,initial,capacity,else,if,collection,instanceof,sorted,set,return,new,tree,set,e,sorted,set,e,collection,comparator,else,return,new,linked,hash,set,e,initial,capacity
CollectionFactory -> public static boolean isApproximableCollectionType(@Nullable Class<?> collectionType);1496837955;Determine whether the given collection type is an <em>approximable</em> type,_i.e. a type that {@link #createApproximateCollection} can approximate._@param collectionType the collection type to check_@return {@code true} if the type is <em>approximable</em>;public static boolean isApproximableCollectionType(@Nullable Class<?> collectionType) {_		return (collectionType != null && approximableCollectionTypes.contains(collectionType))__	};determine,whether,the,given,collection,type,is,an,em,approximable,em,type,i,e,a,type,that,link,create,approximate,collection,can,approximate,param,collection,type,the,collection,type,to,check,return,code,true,if,the,type,is,em,approximable,em;public,static,boolean,is,approximable,collection,type,nullable,class,collection,type,return,collection,type,null,approximable,collection,types,contains,collection,type
CollectionFactory -> public static boolean isApproximableCollectionType(@Nullable Class<?> collectionType);1530532518;Determine whether the given collection type is an <em>approximable</em> type,_i.e. a type that {@link #createApproximateCollection} can approximate._@param collectionType the collection type to check_@return {@code true} if the type is <em>approximable</em>;public static boolean isApproximableCollectionType(@Nullable Class<?> collectionType) {_		return (collectionType != null && approximableCollectionTypes.contains(collectionType))__	};determine,whether,the,given,collection,type,is,an,em,approximable,em,type,i,e,a,type,that,link,create,approximate,collection,can,approximate,param,collection,type,the,collection,type,to,check,return,code,true,if,the,type,is,em,approximable,em;public,static,boolean,is,approximable,collection,type,nullable,class,collection,type,return,collection,type,null,approximable,collection,types,contains,collection,type
CollectionFactory -> public static boolean isApproximableCollectionType(@Nullable Class<?> collectionType);1545740431;Determine whether the given collection type is an <em>approximable</em> type,_i.e. a type that {@link #createApproximateCollection} can approximate._@param collectionType the collection type to check_@return {@code true} if the type is <em>approximable</em>;public static boolean isApproximableCollectionType(@Nullable Class<?> collectionType) {_		return (collectionType != null && approximableCollectionTypes.contains(collectionType))__	};determine,whether,the,given,collection,type,is,an,em,approximable,em,type,i,e,a,type,that,link,create,approximate,collection,can,approximate,param,collection,type,the,collection,type,to,check,return,code,true,if,the,type,is,em,approximable,em;public,static,boolean,is,approximable,collection,type,nullable,class,collection,type,return,collection,type,null,approximable,collection,types,contains,collection,type
CollectionFactory -> public static boolean isApproximableCollectionType(@Nullable Class<?> collectionType);1549321822;Determine whether the given collection type is an <em>approximable</em> type,_i.e. a type that {@link #createApproximateCollection} can approximate._@param collectionType the collection type to check_@return {@code true} if the type is <em>approximable</em>;public static boolean isApproximableCollectionType(@Nullable Class<?> collectionType) {_		return (collectionType != null && approximableCollectionTypes.contains(collectionType))__	};determine,whether,the,given,collection,type,is,an,em,approximable,em,type,i,e,a,type,that,link,create,approximate,collection,can,approximate,param,collection,type,the,collection,type,to,check,return,code,true,if,the,type,is,em,approximable,em;public,static,boolean,is,approximable,collection,type,nullable,class,collection,type,return,collection,type,null,approximable,collection,types,contains,collection,type
CollectionFactory -> @Deprecated 	public static Map createIdentityMapIfPossible(int initialCapacity);1328020251;Create an identity Map if possible: This implementation always_creates a {@link java.util.IdentityHashMap}, since Spring 2.5_requires JDK 1.4 anyway._@param initialCapacity the initial capacity of the Map_@return the new Map instance_@deprecated as of Spring 2.5, for usage on JDK 1.4 or higher;@Deprecated_	public static Map createIdentityMapIfPossible(int initialCapacity) {_		return new IdentityHashMap(initialCapacity)__	};create,an,identity,map,if,possible,this,implementation,always,creates,a,link,java,util,identity,hash,map,since,spring,2,5,requires,jdk,1,4,anyway,param,initial,capacity,the,initial,capacity,of,the,map,return,the,new,map,instance,deprecated,as,of,spring,2,5,for,usage,on,jdk,1,4,or,higher;deprecated,public,static,map,create,identity,map,if,possible,int,initial,capacity,return,new,identity,hash,map,initial,capacity
CollectionFactory -> @Deprecated 	public static Map createIdentityMapIfPossible(int initialCapacity);1346774041;Create an identity Map if possible: This implementation always_creates a {@link java.util.IdentityHashMap}, since Spring 2.5_requires JDK 1.4 anyway._@param initialCapacity the initial capacity of the Map_@return the new Map instance_@deprecated as of Spring 2.5, for usage on JDK 1.4 or higher;@Deprecated_	public static Map createIdentityMapIfPossible(int initialCapacity) {_		return new IdentityHashMap(initialCapacity)__	};create,an,identity,map,if,possible,this,implementation,always,creates,a,link,java,util,identity,hash,map,since,spring,2,5,requires,jdk,1,4,anyway,param,initial,capacity,the,initial,capacity,of,the,map,return,the,new,map,instance,deprecated,as,of,spring,2,5,for,usage,on,jdk,1,4,or,higher;deprecated,public,static,map,create,identity,map,if,possible,int,initial,capacity,return,new,identity,hash,map,initial,capacity
CollectionFactory -> @Deprecated 	public static Map createIdentityMapIfPossible(int initialCapacity);1346774711;Create an identity Map if possible: This implementation always_creates a {@link java.util.IdentityHashMap}, since Spring 2.5_requires JDK 1.4 anyway._@param initialCapacity the initial capacity of the Map_@return the new Map instance_@deprecated as of Spring 2.5, for usage on JDK 1.4 or higher;@Deprecated_	public static Map createIdentityMapIfPossible(int initialCapacity) {_		return new IdentityHashMap(initialCapacity)__	};create,an,identity,map,if,possible,this,implementation,always,creates,a,link,java,util,identity,hash,map,since,spring,2,5,requires,jdk,1,4,anyway,param,initial,capacity,the,initial,capacity,of,the,map,return,the,new,map,instance,deprecated,as,of,spring,2,5,for,usage,on,jdk,1,4,or,higher;deprecated,public,static,map,create,identity,map,if,possible,int,initial,capacity,return,new,identity,hash,map,initial,capacity
CollectionFactory -> @Deprecated 	public static Map createIdentityMapIfPossible(int initialCapacity);1349903156;Create an identity Map if possible: This implementation always_creates a {@link java.util.IdentityHashMap}, since Spring 2.5_requires JDK 1.4 anyway._@param initialCapacity the initial capacity of the Map_@return the new Map instance_@deprecated as of Spring 2.5, for usage on JDK 1.4 or higher;@Deprecated_	public static Map createIdentityMapIfPossible(int initialCapacity) {_		return new IdentityHashMap(initialCapacity)__	};create,an,identity,map,if,possible,this,implementation,always,creates,a,link,java,util,identity,hash,map,since,spring,2,5,requires,jdk,1,4,anyway,param,initial,capacity,the,initial,capacity,of,the,map,return,the,new,map,instance,deprecated,as,of,spring,2,5,for,usage,on,jdk,1,4,or,higher;deprecated,public,static,map,create,identity,map,if,possible,int,initial,capacity,return,new,identity,hash,map,initial,capacity
CollectionFactory -> @Deprecated 	public static Map createIdentityMapIfPossible(int initialCapacity);1355313310;Create an identity Map if possible: This implementation always_creates a {@link java.util.IdentityHashMap}, since Spring 2.5_requires JDK 1.4 anyway._@param initialCapacity the initial capacity of the Map_@return the new Map instance_@deprecated as of Spring 2.5, for usage on JDK 1.4 or higher;@Deprecated_	public static Map createIdentityMapIfPossible(int initialCapacity) {_		return new IdentityHashMap(initialCapacity)__	};create,an,identity,map,if,possible,this,implementation,always,creates,a,link,java,util,identity,hash,map,since,spring,2,5,requires,jdk,1,4,anyway,param,initial,capacity,the,initial,capacity,of,the,map,return,the,new,map,instance,deprecated,as,of,spring,2,5,for,usage,on,jdk,1,4,or,higher;deprecated,public,static,map,create,identity,map,if,possible,int,initial,capacity,return,new,identity,hash,map,initial,capacity
CollectionFactory -> @Deprecated 	public static Map createIdentityMapIfPossible(int initialCapacity);1356735495;Create an identity Map if possible: This implementation always_creates a {@link java.util.IdentityHashMap}, since Spring 2.5_requires JDK 1.4 anyway._@param initialCapacity the initial capacity of the Map_@return the new Map instance_@deprecated as of Spring 2.5, for usage on JDK 1.4 or higher;@Deprecated_	public static Map createIdentityMapIfPossible(int initialCapacity) {_		return new IdentityHashMap(initialCapacity)__	};create,an,identity,map,if,possible,this,implementation,always,creates,a,link,java,util,identity,hash,map,since,spring,2,5,requires,jdk,1,4,anyway,param,initial,capacity,the,initial,capacity,of,the,map,return,the,new,map,instance,deprecated,as,of,spring,2,5,for,usage,on,jdk,1,4,or,higher;deprecated,public,static,map,create,identity,map,if,possible,int,initial,capacity,return,new,identity,hash,map,initial,capacity
CollectionFactory -> @SuppressWarnings("unchecked") 	public static Collection createApproximateCollection(Object collection, int initialCapacity);1328020251;Create the most approximate collection for the given collection._<p>Creates an ArrayList, TreeSet or linked Set for a List, SortedSet_or Set, respectively._@param collection the original Collection object_@param initialCapacity the initial capacity_@return the new Collection instance_@see java.util.ArrayList_@see java.util.TreeSet_@see java.util.LinkedHashSet;@SuppressWarnings("unchecked")_	public static Collection createApproximateCollection(Object collection, int initialCapacity) {_		if (collection instanceof LinkedList) {_			return new LinkedList()__		}_		else if (collection instanceof List) {_			return new ArrayList(initialCapacity)__		}_		else if (collection instanceof SortedSet) {_			return new TreeSet(((SortedSet) collection).comparator())__		}_		else {_			return new LinkedHashSet(initialCapacity)__		}_	};create,the,most,approximate,collection,for,the,given,collection,p,creates,an,array,list,tree,set,or,linked,set,for,a,list,sorted,set,or,set,respectively,param,collection,the,original,collection,object,param,initial,capacity,the,initial,capacity,return,the,new,collection,instance,see,java,util,array,list,see,java,util,tree,set,see,java,util,linked,hash,set;suppress,warnings,unchecked,public,static,collection,create,approximate,collection,object,collection,int,initial,capacity,if,collection,instanceof,linked,list,return,new,linked,list,else,if,collection,instanceof,list,return,new,array,list,initial,capacity,else,if,collection,instanceof,sorted,set,return,new,tree,set,sorted,set,collection,comparator,else,return,new,linked,hash,set,initial,capacity
CollectionFactory -> @SuppressWarnings("unchecked") 	public static Collection createApproximateCollection(Object collection, int initialCapacity);1346774041;Create the most approximate collection for the given collection._<p>Creates an ArrayList, TreeSet or linked Set for a List, SortedSet_or Set, respectively._@param collection the original Collection object_@param initialCapacity the initial capacity_@return the new Collection instance_@see java.util.ArrayList_@see java.util.TreeSet_@see java.util.LinkedHashSet;@SuppressWarnings("unchecked")_	public static Collection createApproximateCollection(Object collection, int initialCapacity) {_		if (collection instanceof LinkedList) {_			return new LinkedList()__		}_		else if (collection instanceof List) {_			return new ArrayList(initialCapacity)__		}_		else if (collection instanceof SortedSet) {_			return new TreeSet(((SortedSet) collection).comparator())__		}_		else {_			return new LinkedHashSet(initialCapacity)__		}_	};create,the,most,approximate,collection,for,the,given,collection,p,creates,an,array,list,tree,set,or,linked,set,for,a,list,sorted,set,or,set,respectively,param,collection,the,original,collection,object,param,initial,capacity,the,initial,capacity,return,the,new,collection,instance,see,java,util,array,list,see,java,util,tree,set,see,java,util,linked,hash,set;suppress,warnings,unchecked,public,static,collection,create,approximate,collection,object,collection,int,initial,capacity,if,collection,instanceof,linked,list,return,new,linked,list,else,if,collection,instanceof,list,return,new,array,list,initial,capacity,else,if,collection,instanceof,sorted,set,return,new,tree,set,sorted,set,collection,comparator,else,return,new,linked,hash,set,initial,capacity
CollectionFactory -> @SuppressWarnings("unchecked") 	public static Collection createApproximateCollection(Object collection, int initialCapacity);1346774711;Create the most approximate collection for the given collection._<p>Creates an ArrayList, TreeSet or linked Set for a List, SortedSet_or Set, respectively._@param collection the original Collection object_@param initialCapacity the initial capacity_@return the new Collection instance_@see java.util.ArrayList_@see java.util.TreeSet_@see java.util.LinkedHashSet;@SuppressWarnings("unchecked")_	public static Collection createApproximateCollection(Object collection, int initialCapacity) {_		if (collection instanceof LinkedList) {_			return new LinkedList()__		}_		else if (collection instanceof List) {_			return new ArrayList(initialCapacity)__		}_		else if (collection instanceof SortedSet) {_			return new TreeSet(((SortedSet) collection).comparator())__		}_		else {_			return new LinkedHashSet(initialCapacity)__		}_	};create,the,most,approximate,collection,for,the,given,collection,p,creates,an,array,list,tree,set,or,linked,set,for,a,list,sorted,set,or,set,respectively,param,collection,the,original,collection,object,param,initial,capacity,the,initial,capacity,return,the,new,collection,instance,see,java,util,array,list,see,java,util,tree,set,see,java,util,linked,hash,set;suppress,warnings,unchecked,public,static,collection,create,approximate,collection,object,collection,int,initial,capacity,if,collection,instanceof,linked,list,return,new,linked,list,else,if,collection,instanceof,list,return,new,array,list,initial,capacity,else,if,collection,instanceof,sorted,set,return,new,tree,set,sorted,set,collection,comparator,else,return,new,linked,hash,set,initial,capacity
CollectionFactory -> @SuppressWarnings("unchecked") 	public static Collection createApproximateCollection(Object collection, int initialCapacity);1349903156;Create the most approximate collection for the given collection._<p>Creates an ArrayList, TreeSet or linked Set for a List, SortedSet_or Set, respectively._@param collection the original Collection object_@param initialCapacity the initial capacity_@return the new Collection instance_@see java.util.ArrayList_@see java.util.TreeSet_@see java.util.LinkedHashSet;@SuppressWarnings("unchecked")_	public static Collection createApproximateCollection(Object collection, int initialCapacity) {_		if (collection instanceof LinkedList) {_			return new LinkedList()__		}_		else if (collection instanceof List) {_			return new ArrayList(initialCapacity)__		}_		else if (collection instanceof SortedSet) {_			return new TreeSet(((SortedSet) collection).comparator())__		}_		else {_			return new LinkedHashSet(initialCapacity)__		}_	};create,the,most,approximate,collection,for,the,given,collection,p,creates,an,array,list,tree,set,or,linked,set,for,a,list,sorted,set,or,set,respectively,param,collection,the,original,collection,object,param,initial,capacity,the,initial,capacity,return,the,new,collection,instance,see,java,util,array,list,see,java,util,tree,set,see,java,util,linked,hash,set;suppress,warnings,unchecked,public,static,collection,create,approximate,collection,object,collection,int,initial,capacity,if,collection,instanceof,linked,list,return,new,linked,list,else,if,collection,instanceof,list,return,new,array,list,initial,capacity,else,if,collection,instanceof,sorted,set,return,new,tree,set,sorted,set,collection,comparator,else,return,new,linked,hash,set,initial,capacity
CollectionFactory -> @SuppressWarnings("unchecked") 	public static Collection createApproximateCollection(Object collection, int initialCapacity);1355313310;Create the most approximate collection for the given collection._<p>Creates an ArrayList, TreeSet or linked Set for a List, SortedSet_or Set, respectively._@param collection the original Collection object_@param initialCapacity the initial capacity_@return the new Collection instance_@see java.util.ArrayList_@see java.util.TreeSet_@see java.util.LinkedHashSet;@SuppressWarnings("unchecked")_	public static Collection createApproximateCollection(Object collection, int initialCapacity) {_		if (collection instanceof LinkedList) {_			return new LinkedList()__		}_		else if (collection instanceof List) {_			return new ArrayList(initialCapacity)__		}_		else if (collection instanceof SortedSet) {_			return new TreeSet(((SortedSet) collection).comparator())__		}_		else {_			return new LinkedHashSet(initialCapacity)__		}_	};create,the,most,approximate,collection,for,the,given,collection,p,creates,an,array,list,tree,set,or,linked,set,for,a,list,sorted,set,or,set,respectively,param,collection,the,original,collection,object,param,initial,capacity,the,initial,capacity,return,the,new,collection,instance,see,java,util,array,list,see,java,util,tree,set,see,java,util,linked,hash,set;suppress,warnings,unchecked,public,static,collection,create,approximate,collection,object,collection,int,initial,capacity,if,collection,instanceof,linked,list,return,new,linked,list,else,if,collection,instanceof,list,return,new,array,list,initial,capacity,else,if,collection,instanceof,sorted,set,return,new,tree,set,sorted,set,collection,comparator,else,return,new,linked,hash,set,initial,capacity
CollectionFactory -> @SuppressWarnings("unchecked") 	public static Collection createApproximateCollection(Object collection, int initialCapacity);1356735495;Create the most approximate collection for the given collection._<p>Creates an ArrayList, TreeSet or linked Set for a List, SortedSet_or Set, respectively._@param collection the original Collection object_@param initialCapacity the initial capacity_@return the new Collection instance_@see java.util.ArrayList_@see java.util.TreeSet_@see java.util.LinkedHashSet;@SuppressWarnings("unchecked")_	public static Collection createApproximateCollection(Object collection, int initialCapacity) {_		if (collection instanceof LinkedList) {_			return new LinkedList()__		}_		else if (collection instanceof List) {_			return new ArrayList(initialCapacity)__		}_		else if (collection instanceof SortedSet) {_			return new TreeSet(((SortedSet) collection).comparator())__		}_		else {_			return new LinkedHashSet(initialCapacity)__		}_	};create,the,most,approximate,collection,for,the,given,collection,p,creates,an,array,list,tree,set,or,linked,set,for,a,list,sorted,set,or,set,respectively,param,collection,the,original,collection,object,param,initial,capacity,the,initial,capacity,return,the,new,collection,instance,see,java,util,array,list,see,java,util,tree,set,see,java,util,linked,hash,set;suppress,warnings,unchecked,public,static,collection,create,approximate,collection,object,collection,int,initial,capacity,if,collection,instanceof,linked,list,return,new,linked,list,else,if,collection,instanceof,list,return,new,array,list,initial,capacity,else,if,collection,instanceof,sorted,set,return,new,tree,set,sorted,set,collection,comparator,else,return,new,linked,hash,set,initial,capacity
CollectionFactory -> @SuppressWarnings("unchecked") 	public static Collection createApproximateCollection(Object collection, int initialCapacity);1364509637;Create the most approximate collection for the given collection._<p>Creates an ArrayList, TreeSet or linked Set for a List, SortedSet_or Set, respectively._@param collection the original Collection object_@param initialCapacity the initial capacity_@return the new Collection instance_@see java.util.ArrayList_@see java.util.TreeSet_@see java.util.LinkedHashSet;@SuppressWarnings("unchecked")_	public static Collection createApproximateCollection(Object collection, int initialCapacity) {_		if (collection instanceof LinkedList) {_			return new LinkedList()__		}_		else if (collection instanceof List) {_			return new ArrayList(initialCapacity)__		}_		else if (collection instanceof SortedSet) {_			return new TreeSet(((SortedSet) collection).comparator())__		}_		else {_			return new LinkedHashSet(initialCapacity)__		}_	};create,the,most,approximate,collection,for,the,given,collection,p,creates,an,array,list,tree,set,or,linked,set,for,a,list,sorted,set,or,set,respectively,param,collection,the,original,collection,object,param,initial,capacity,the,initial,capacity,return,the,new,collection,instance,see,java,util,array,list,see,java,util,tree,set,see,java,util,linked,hash,set;suppress,warnings,unchecked,public,static,collection,create,approximate,collection,object,collection,int,initial,capacity,if,collection,instanceof,linked,list,return,new,linked,list,else,if,collection,instanceof,list,return,new,array,list,initial,capacity,else,if,collection,instanceof,sorted,set,return,new,tree,set,sorted,set,collection,comparator,else,return,new,linked,hash,set,initial,capacity
CollectionFactory -> @SuppressWarnings("unchecked") 	public static Map createApproximateMap(Object map, int initialCapacity);1328020251;Create the most approximate map for the given map._<p>Creates a TreeMap or linked Map for a SortedMap or Map, respectively._@param map the original Map object_@param initialCapacity the initial capacity_@return the new Map instance_@see java.util.TreeMap_@see java.util.LinkedHashMap;@SuppressWarnings("unchecked")_	public static Map createApproximateMap(Object map, int initialCapacity) {_		if (map instanceof SortedMap) {_			return new TreeMap(((SortedMap) map).comparator())__		}_		else {_			return new LinkedHashMap(initialCapacity)__		}_	};create,the,most,approximate,map,for,the,given,map,p,creates,a,tree,map,or,linked,map,for,a,sorted,map,or,map,respectively,param,map,the,original,map,object,param,initial,capacity,the,initial,capacity,return,the,new,map,instance,see,java,util,tree,map,see,java,util,linked,hash,map;suppress,warnings,unchecked,public,static,map,create,approximate,map,object,map,int,initial,capacity,if,map,instanceof,sorted,map,return,new,tree,map,sorted,map,map,comparator,else,return,new,linked,hash,map,initial,capacity
CollectionFactory -> @SuppressWarnings("unchecked") 	public static Map createApproximateMap(Object map, int initialCapacity);1346774041;Create the most approximate map for the given map._<p>Creates a TreeMap or linked Map for a SortedMap or Map, respectively._@param map the original Map object_@param initialCapacity the initial capacity_@return the new Map instance_@see java.util.TreeMap_@see java.util.LinkedHashMap;@SuppressWarnings("unchecked")_	public static Map createApproximateMap(Object map, int initialCapacity) {_		if (map instanceof SortedMap) {_			return new TreeMap(((SortedMap) map).comparator())__		}_		else {_			return new LinkedHashMap(initialCapacity)__		}_	};create,the,most,approximate,map,for,the,given,map,p,creates,a,tree,map,or,linked,map,for,a,sorted,map,or,map,respectively,param,map,the,original,map,object,param,initial,capacity,the,initial,capacity,return,the,new,map,instance,see,java,util,tree,map,see,java,util,linked,hash,map;suppress,warnings,unchecked,public,static,map,create,approximate,map,object,map,int,initial,capacity,if,map,instanceof,sorted,map,return,new,tree,map,sorted,map,map,comparator,else,return,new,linked,hash,map,initial,capacity
CollectionFactory -> @SuppressWarnings("unchecked") 	public static Map createApproximateMap(Object map, int initialCapacity);1346774711;Create the most approximate map for the given map._<p>Creates a TreeMap or linked Map for a SortedMap or Map, respectively._@param map the original Map object_@param initialCapacity the initial capacity_@return the new Map instance_@see java.util.TreeMap_@see java.util.LinkedHashMap;@SuppressWarnings("unchecked")_	public static Map createApproximateMap(Object map, int initialCapacity) {_		if (map instanceof SortedMap) {_			return new TreeMap(((SortedMap) map).comparator())__		}_		else {_			return new LinkedHashMap(initialCapacity)__		}_	};create,the,most,approximate,map,for,the,given,map,p,creates,a,tree,map,or,linked,map,for,a,sorted,map,or,map,respectively,param,map,the,original,map,object,param,initial,capacity,the,initial,capacity,return,the,new,map,instance,see,java,util,tree,map,see,java,util,linked,hash,map;suppress,warnings,unchecked,public,static,map,create,approximate,map,object,map,int,initial,capacity,if,map,instanceof,sorted,map,return,new,tree,map,sorted,map,map,comparator,else,return,new,linked,hash,map,initial,capacity
CollectionFactory -> @SuppressWarnings("unchecked") 	public static Map createApproximateMap(Object map, int initialCapacity);1349903156;Create the most approximate map for the given map._<p>Creates a TreeMap or linked Map for a SortedMap or Map, respectively._@param map the original Map object_@param initialCapacity the initial capacity_@return the new Map instance_@see java.util.TreeMap_@see java.util.LinkedHashMap;@SuppressWarnings("unchecked")_	public static Map createApproximateMap(Object map, int initialCapacity) {_		if (map instanceof SortedMap) {_			return new TreeMap(((SortedMap) map).comparator())__		}_		else {_			return new LinkedHashMap(initialCapacity)__		}_	};create,the,most,approximate,map,for,the,given,map,p,creates,a,tree,map,or,linked,map,for,a,sorted,map,or,map,respectively,param,map,the,original,map,object,param,initial,capacity,the,initial,capacity,return,the,new,map,instance,see,java,util,tree,map,see,java,util,linked,hash,map;suppress,warnings,unchecked,public,static,map,create,approximate,map,object,map,int,initial,capacity,if,map,instanceof,sorted,map,return,new,tree,map,sorted,map,map,comparator,else,return,new,linked,hash,map,initial,capacity
CollectionFactory -> @SuppressWarnings("unchecked") 	public static Map createApproximateMap(Object map, int initialCapacity);1355313310;Create the most approximate map for the given map._<p>Creates a TreeMap or linked Map for a SortedMap or Map, respectively._@param map the original Map object_@param initialCapacity the initial capacity_@return the new Map instance_@see java.util.TreeMap_@see java.util.LinkedHashMap;@SuppressWarnings("unchecked")_	public static Map createApproximateMap(Object map, int initialCapacity) {_		if (map instanceof SortedMap) {_			return new TreeMap(((SortedMap) map).comparator())__		}_		else {_			return new LinkedHashMap(initialCapacity)__		}_	};create,the,most,approximate,map,for,the,given,map,p,creates,a,tree,map,or,linked,map,for,a,sorted,map,or,map,respectively,param,map,the,original,map,object,param,initial,capacity,the,initial,capacity,return,the,new,map,instance,see,java,util,tree,map,see,java,util,linked,hash,map;suppress,warnings,unchecked,public,static,map,create,approximate,map,object,map,int,initial,capacity,if,map,instanceof,sorted,map,return,new,tree,map,sorted,map,map,comparator,else,return,new,linked,hash,map,initial,capacity
CollectionFactory -> @SuppressWarnings("unchecked") 	public static Map createApproximateMap(Object map, int initialCapacity);1356735495;Create the most approximate map for the given map._<p>Creates a TreeMap or linked Map for a SortedMap or Map, respectively._@param map the original Map object_@param initialCapacity the initial capacity_@return the new Map instance_@see java.util.TreeMap_@see java.util.LinkedHashMap;@SuppressWarnings("unchecked")_	public static Map createApproximateMap(Object map, int initialCapacity) {_		if (map instanceof SortedMap) {_			return new TreeMap(((SortedMap) map).comparator())__		}_		else {_			return new LinkedHashMap(initialCapacity)__		}_	};create,the,most,approximate,map,for,the,given,map,p,creates,a,tree,map,or,linked,map,for,a,sorted,map,or,map,respectively,param,map,the,original,map,object,param,initial,capacity,the,initial,capacity,return,the,new,map,instance,see,java,util,tree,map,see,java,util,linked,hash,map;suppress,warnings,unchecked,public,static,map,create,approximate,map,object,map,int,initial,capacity,if,map,instanceof,sorted,map,return,new,tree,map,sorted,map,map,comparator,else,return,new,linked,hash,map,initial,capacity
CollectionFactory -> @SuppressWarnings("unchecked") 	public static Map createApproximateMap(Object map, int initialCapacity);1364509637;Create the most approximate map for the given map._<p>Creates a TreeMap or linked Map for a SortedMap or Map, respectively._@param map the original Map object_@param initialCapacity the initial capacity_@return the new Map instance_@see java.util.TreeMap_@see java.util.LinkedHashMap;@SuppressWarnings("unchecked")_	public static Map createApproximateMap(Object map, int initialCapacity) {_		if (map instanceof SortedMap) {_			return new TreeMap(((SortedMap) map).comparator())__		}_		else {_			return new LinkedHashMap(initialCapacity)__		}_	};create,the,most,approximate,map,for,the,given,map,p,creates,a,tree,map,or,linked,map,for,a,sorted,map,or,map,respectively,param,map,the,original,map,object,param,initial,capacity,the,initial,capacity,return,the,new,map,instance,see,java,util,tree,map,see,java,util,linked,hash,map;suppress,warnings,unchecked,public,static,map,create,approximate,map,object,map,int,initial,capacity,if,map,instanceof,sorted,map,return,new,tree,map,sorted,map,map,comparator,else,return,new,linked,hash,map,initial,capacity
CollectionFactory -> @Deprecated 	public static <T> Set<T> createLinkedSetIfPossible(int initialCapacity);1328020251;Create a linked Set if possible: This implementation always_creates a {@link java.util.LinkedHashSet}, since Spring 2.5_requires JDK 1.4 anyway._@param initialCapacity the initial capacity of the Set_@return the new Set instance_@deprecated as of Spring 2.5, for usage on JDK 1.4 or higher;@Deprecated_	public static <T> Set<T> createLinkedSetIfPossible(int initialCapacity) {_		return new LinkedHashSet<T>(initialCapacity)__	};create,a,linked,set,if,possible,this,implementation,always,creates,a,link,java,util,linked,hash,set,since,spring,2,5,requires,jdk,1,4,anyway,param,initial,capacity,the,initial,capacity,of,the,set,return,the,new,set,instance,deprecated,as,of,spring,2,5,for,usage,on,jdk,1,4,or,higher;deprecated,public,static,t,set,t,create,linked,set,if,possible,int,initial,capacity,return,new,linked,hash,set,t,initial,capacity
CollectionFactory -> @Deprecated 	public static <T> Set<T> createLinkedSetIfPossible(int initialCapacity);1346774041;Create a linked Set if possible: This implementation always_creates a {@link java.util.LinkedHashSet}, since Spring 2.5_requires JDK 1.4 anyway._@param initialCapacity the initial capacity of the Set_@return the new Set instance_@deprecated as of Spring 2.5, for usage on JDK 1.4 or higher;@Deprecated_	public static <T> Set<T> createLinkedSetIfPossible(int initialCapacity) {_		return new LinkedHashSet<T>(initialCapacity)__	};create,a,linked,set,if,possible,this,implementation,always,creates,a,link,java,util,linked,hash,set,since,spring,2,5,requires,jdk,1,4,anyway,param,initial,capacity,the,initial,capacity,of,the,set,return,the,new,set,instance,deprecated,as,of,spring,2,5,for,usage,on,jdk,1,4,or,higher;deprecated,public,static,t,set,t,create,linked,set,if,possible,int,initial,capacity,return,new,linked,hash,set,t,initial,capacity
CollectionFactory -> @Deprecated 	public static <T> Set<T> createLinkedSetIfPossible(int initialCapacity);1346774711;Create a linked Set if possible: This implementation always_creates a {@link java.util.LinkedHashSet}, since Spring 2.5_requires JDK 1.4 anyway._@param initialCapacity the initial capacity of the Set_@return the new Set instance_@deprecated as of Spring 2.5, for usage on JDK 1.4 or higher;@Deprecated_	public static <T> Set<T> createLinkedSetIfPossible(int initialCapacity) {_		return new LinkedHashSet<T>(initialCapacity)__	};create,a,linked,set,if,possible,this,implementation,always,creates,a,link,java,util,linked,hash,set,since,spring,2,5,requires,jdk,1,4,anyway,param,initial,capacity,the,initial,capacity,of,the,set,return,the,new,set,instance,deprecated,as,of,spring,2,5,for,usage,on,jdk,1,4,or,higher;deprecated,public,static,t,set,t,create,linked,set,if,possible,int,initial,capacity,return,new,linked,hash,set,t,initial,capacity
CollectionFactory -> @Deprecated 	public static <T> Set<T> createLinkedSetIfPossible(int initialCapacity);1349903156;Create a linked Set if possible: This implementation always_creates a {@link java.util.LinkedHashSet}, since Spring 2.5_requires JDK 1.4 anyway._@param initialCapacity the initial capacity of the Set_@return the new Set instance_@deprecated as of Spring 2.5, for usage on JDK 1.4 or higher;@Deprecated_	public static <T> Set<T> createLinkedSetIfPossible(int initialCapacity) {_		return new LinkedHashSet<T>(initialCapacity)__	};create,a,linked,set,if,possible,this,implementation,always,creates,a,link,java,util,linked,hash,set,since,spring,2,5,requires,jdk,1,4,anyway,param,initial,capacity,the,initial,capacity,of,the,set,return,the,new,set,instance,deprecated,as,of,spring,2,5,for,usage,on,jdk,1,4,or,higher;deprecated,public,static,t,set,t,create,linked,set,if,possible,int,initial,capacity,return,new,linked,hash,set,t,initial,capacity
CollectionFactory -> @Deprecated 	public static <T> Set<T> createLinkedSetIfPossible(int initialCapacity);1355313310;Create a linked Set if possible: This implementation always_creates a {@link java.util.LinkedHashSet}, since Spring 2.5_requires JDK 1.4 anyway._@param initialCapacity the initial capacity of the Set_@return the new Set instance_@deprecated as of Spring 2.5, for usage on JDK 1.4 or higher;@Deprecated_	public static <T> Set<T> createLinkedSetIfPossible(int initialCapacity) {_		return new LinkedHashSet<T>(initialCapacity)__	};create,a,linked,set,if,possible,this,implementation,always,creates,a,link,java,util,linked,hash,set,since,spring,2,5,requires,jdk,1,4,anyway,param,initial,capacity,the,initial,capacity,of,the,set,return,the,new,set,instance,deprecated,as,of,spring,2,5,for,usage,on,jdk,1,4,or,higher;deprecated,public,static,t,set,t,create,linked,set,if,possible,int,initial,capacity,return,new,linked,hash,set,t,initial,capacity
CollectionFactory -> @Deprecated 	public static <T> Set<T> createLinkedSetIfPossible(int initialCapacity);1356735495;Create a linked Set if possible: This implementation always_creates a {@link java.util.LinkedHashSet}, since Spring 2.5_requires JDK 1.4 anyway._@param initialCapacity the initial capacity of the Set_@return the new Set instance_@deprecated as of Spring 2.5, for usage on JDK 1.4 or higher;@Deprecated_	public static <T> Set<T> createLinkedSetIfPossible(int initialCapacity) {_		return new LinkedHashSet<T>(initialCapacity)__	};create,a,linked,set,if,possible,this,implementation,always,creates,a,link,java,util,linked,hash,set,since,spring,2,5,requires,jdk,1,4,anyway,param,initial,capacity,the,initial,capacity,of,the,set,return,the,new,set,instance,deprecated,as,of,spring,2,5,for,usage,on,jdk,1,4,or,higher;deprecated,public,static,t,set,t,create,linked,set,if,possible,int,initial,capacity,return,new,linked,hash,set,t,initial,capacity
CollectionFactory -> public static <K, V> Map<K, V> createMap(Class<?> mapClass, int capacity);1417203046;Create the most approximate map for the given map._<p>Delegates to {@link #createMap(Class, Class, int)} with a_{@code null} key type._@param mapClass the desired type of the target Map_@param capacity the initial capacity_@return the new Map instance;public static <K, V> Map<K, V> createMap(Class<?> mapClass, int capacity) {_		return createMap(mapClass, null, capacity)__	};create,the,most,approximate,map,for,the,given,map,p,delegates,to,link,create,map,class,class,int,with,a,code,null,key,type,param,map,class,the,desired,type,of,the,target,map,param,capacity,the,initial,capacity,return,the,new,map,instance;public,static,k,v,map,k,v,create,map,class,map,class,int,capacity,return,create,map,map,class,null,capacity
CollectionFactory -> public static <K, V> Map<K, V> createMap(Class<?> mapClass, int capacity);1417290546;Create the most approximate map for the given map._<p>Delegates to {@link #createMap(Class, Class, int)} with a_{@code null} key type._@param mapClass the desired type of the target Map_@param capacity the initial capacity_@return the new Map instance;public static <K, V> Map<K, V> createMap(Class<?> mapClass, int capacity) {_		return createMap(mapClass, null, capacity)__	};create,the,most,approximate,map,for,the,given,map,p,delegates,to,link,create,map,class,class,int,with,a,code,null,key,type,param,map,class,the,desired,type,of,the,target,map,param,capacity,the,initial,capacity,return,the,new,map,instance;public,static,k,v,map,k,v,create,map,class,map,class,int,capacity,return,create,map,map,class,null,capacity
CollectionFactory -> public static <K, V> Map<K, V> createMap(Class<?> mapClass, int capacity);1418154876;Create the most approximate map for the given map._<p>Delegates to {@link #createMap(Class, Class, int)} with a_{@code null} key type._@param mapClass the desired type of the target Map_@param capacity the initial capacity_@return the new Map instance;public static <K, V> Map<K, V> createMap(Class<?> mapClass, int capacity) {_		return createMap(mapClass, null, capacity)__	};create,the,most,approximate,map,for,the,given,map,p,delegates,to,link,create,map,class,class,int,with,a,code,null,key,type,param,map,class,the,desired,type,of,the,target,map,param,capacity,the,initial,capacity,return,the,new,map,instance;public,static,k,v,map,k,v,create,map,class,map,class,int,capacity,return,create,map,map,class,null,capacity
CollectionFactory -> public static <K, V> Map<K, V> createMap(Class<?> mapClass, int capacity);1418156945;Create the most approximate map for the given map._<p>Delegates to {@link #createMap(Class, Class, int)} with a_{@code null} key type._@param mapClass the desired type of the target Map_@param capacity the initial capacity_@return the new Map instance;public static <K, V> Map<K, V> createMap(Class<?> mapClass, int capacity) {_		return createMap(mapClass, null, capacity)__	};create,the,most,approximate,map,for,the,given,map,p,delegates,to,link,create,map,class,class,int,with,a,code,null,key,type,param,map,class,the,desired,type,of,the,target,map,param,capacity,the,initial,capacity,return,the,new,map,instance;public,static,k,v,map,k,v,create,map,class,map,class,int,capacity,return,create,map,map,class,null,capacity
CollectionFactory -> @SuppressWarnings("unchecked") 	public static <E> Collection<E> createApproximateCollection(Object collection, int capacity);1417203046;Create the most approximate collection for the given collection._@param collection the original Collection object_@param capacity the initial capacity_@return the new Collection instance_@see java.util.LinkedHashSet_@see java.util.TreeSet_@see java.util.EnumSet_@see java.util.ArrayList_@see java.util.LinkedList;@SuppressWarnings("unchecked")_	public static <E> Collection<E> createApproximateCollection(Object collection, int capacity) {_		if (collection instanceof LinkedList) {_			return new LinkedList<E>()__		}_		else if (collection instanceof List) {_			return new ArrayList<E>(capacity)__		}_		else if (collection instanceof EnumSet) {_			return EnumSet.copyOf((Collection) collection)__		}_		else if (collection instanceof SortedSet) {_			return new TreeSet<E>(((SortedSet<E>) collection).comparator())__		}_		else {_			return new LinkedHashSet<E>(capacity)__		}_	};create,the,most,approximate,collection,for,the,given,collection,param,collection,the,original,collection,object,param,capacity,the,initial,capacity,return,the,new,collection,instance,see,java,util,linked,hash,set,see,java,util,tree,set,see,java,util,enum,set,see,java,util,array,list,see,java,util,linked,list;suppress,warnings,unchecked,public,static,e,collection,e,create,approximate,collection,object,collection,int,capacity,if,collection,instanceof,linked,list,return,new,linked,list,e,else,if,collection,instanceof,list,return,new,array,list,e,capacity,else,if,collection,instanceof,enum,set,return,enum,set,copy,of,collection,collection,else,if,collection,instanceof,sorted,set,return,new,tree,set,e,sorted,set,e,collection,comparator,else,return,new,linked,hash,set,e,capacity
CollectionFactory -> @SuppressWarnings("unchecked") 	public static <E> Collection<E> createApproximateCollection(Object collection, int capacity);1417290546;Create the most approximate collection for the given collection._@param collection the original Collection object_@param capacity the initial capacity_@return the new Collection instance_@see java.util.LinkedHashSet_@see java.util.TreeSet_@see java.util.EnumSet_@see java.util.ArrayList_@see java.util.LinkedList;@SuppressWarnings("unchecked")_	public static <E> Collection<E> createApproximateCollection(Object collection, int capacity) {_		if (collection instanceof LinkedList) {_			return new LinkedList<E>()__		}_		else if (collection instanceof List) {_			return new ArrayList<E>(capacity)__		}_		else if (collection instanceof EnumSet) {_			return EnumSet.copyOf((Collection) collection)__		}_		else if (collection instanceof SortedSet) {_			return new TreeSet<E>(((SortedSet<E>) collection).comparator())__		}_		else {_			return new LinkedHashSet<E>(capacity)__		}_	};create,the,most,approximate,collection,for,the,given,collection,param,collection,the,original,collection,object,param,capacity,the,initial,capacity,return,the,new,collection,instance,see,java,util,linked,hash,set,see,java,util,tree,set,see,java,util,enum,set,see,java,util,array,list,see,java,util,linked,list;suppress,warnings,unchecked,public,static,e,collection,e,create,approximate,collection,object,collection,int,capacity,if,collection,instanceof,linked,list,return,new,linked,list,e,else,if,collection,instanceof,list,return,new,array,list,e,capacity,else,if,collection,instanceof,enum,set,return,enum,set,copy,of,collection,collection,else,if,collection,instanceof,sorted,set,return,new,tree,set,e,sorted,set,e,collection,comparator,else,return,new,linked,hash,set,e,capacity
CollectionFactory -> @SuppressWarnings({ "unchecked", "cast", "rawtypes" }) 	public static <E> Collection<E> createApproximateCollection(@Nullable Object collection, int capacity);1495868221;Create the most approximate collection for the given collection._<p><strong>Warning</strong>: Since the parameterized type {@code E} is_not bound to the type of elements contained in the supplied_{@code collection}, type safety cannot be guaranteed if the supplied_{@code collection} is an {@link EnumSet}. In such scenarios, the caller_is responsible for ensuring that the element type for the supplied_{@code collection} is an enum type matching type {@code E}. As an_alternative, the caller may wish to treat the return value as a raw_collection or collection of {@link Object}._@param collection the original collection object, potentially {@code null}_@param capacity the initial capacity_@return a new, empty collection instance_@see #isApproximableCollectionType_@see java.util.LinkedList_@see java.util.ArrayList_@see java.util.EnumSet_@see java.util.TreeSet_@see java.util.LinkedHashSet;@SuppressWarnings({ "unchecked", "cast", "rawtypes" })_	public static <E> Collection<E> createApproximateCollection(@Nullable Object collection, int capacity) {_		if (collection instanceof LinkedList) {_			return new LinkedList<>()__		}_		else if (collection instanceof List) {_			return new ArrayList<>(capacity)__		}_		else if (collection instanceof EnumSet) {_			_			Collection<E> enumSet = (Collection<E>) EnumSet.copyOf((EnumSet) collection)__			enumSet.clear()__			return enumSet__		}_		else if (collection instanceof SortedSet) {_			return new TreeSet<>(((SortedSet<E>) collection).comparator())__		}_		else {_			return new LinkedHashSet<>(capacity)__		}_	};create,the,most,approximate,collection,for,the,given,collection,p,strong,warning,strong,since,the,parameterized,type,code,e,is,not,bound,to,the,type,of,elements,contained,in,the,supplied,code,collection,type,safety,cannot,be,guaranteed,if,the,supplied,code,collection,is,an,link,enum,set,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,element,type,for,the,supplied,code,collection,is,an,enum,type,matching,type,code,e,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,collection,or,collection,of,link,object,param,collection,the,original,collection,object,potentially,code,null,param,capacity,the,initial,capacity,return,a,new,empty,collection,instance,see,is,approximable,collection,type,see,java,util,linked,list,see,java,util,array,list,see,java,util,enum,set,see,java,util,tree,set,see,java,util,linked,hash,set;suppress,warnings,unchecked,cast,rawtypes,public,static,e,collection,e,create,approximate,collection,nullable,object,collection,int,capacity,if,collection,instanceof,linked,list,return,new,linked,list,else,if,collection,instanceof,list,return,new,array,list,capacity,else,if,collection,instanceof,enum,set,collection,e,enum,set,collection,e,enum,set,copy,of,enum,set,collection,enum,set,clear,return,enum,set,else,if,collection,instanceof,sorted,set,return,new,tree,set,sorted,set,e,collection,comparator,else,return,new,linked,hash,set,capacity
CollectionFactory -> @SuppressWarnings({ "unchecked", "cast", "rawtypes" }) 	public static <E> Collection<E> createApproximateCollection(@Nullable Object collection, int capacity);1496837955;Create the most approximate collection for the given collection._<p><strong>Warning</strong>: Since the parameterized type {@code E} is_not bound to the type of elements contained in the supplied_{@code collection}, type safety cannot be guaranteed if the supplied_{@code collection} is an {@link EnumSet}. In such scenarios, the caller_is responsible for ensuring that the element type for the supplied_{@code collection} is an enum type matching type {@code E}. As an_alternative, the caller may wish to treat the return value as a raw_collection or collection of {@link Object}._@param collection the original collection object, potentially {@code null}_@param capacity the initial capacity_@return a new, empty collection instance_@see #isApproximableCollectionType_@see java.util.LinkedList_@see java.util.ArrayList_@see java.util.EnumSet_@see java.util.TreeSet_@see java.util.LinkedHashSet;@SuppressWarnings({ "unchecked", "cast", "rawtypes" })_	public static <E> Collection<E> createApproximateCollection(@Nullable Object collection, int capacity) {_		if (collection instanceof LinkedList) {_			return new LinkedList<>()__		}_		else if (collection instanceof List) {_			return new ArrayList<>(capacity)__		}_		else if (collection instanceof EnumSet) {_			_			Collection<E> enumSet = (Collection<E>) EnumSet.copyOf((EnumSet) collection)__			enumSet.clear()__			return enumSet__		}_		else if (collection instanceof SortedSet) {_			return new TreeSet<>(((SortedSet<E>) collection).comparator())__		}_		else {_			return new LinkedHashSet<>(capacity)__		}_	};create,the,most,approximate,collection,for,the,given,collection,p,strong,warning,strong,since,the,parameterized,type,code,e,is,not,bound,to,the,type,of,elements,contained,in,the,supplied,code,collection,type,safety,cannot,be,guaranteed,if,the,supplied,code,collection,is,an,link,enum,set,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,element,type,for,the,supplied,code,collection,is,an,enum,type,matching,type,code,e,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,collection,or,collection,of,link,object,param,collection,the,original,collection,object,potentially,code,null,param,capacity,the,initial,capacity,return,a,new,empty,collection,instance,see,is,approximable,collection,type,see,java,util,linked,list,see,java,util,array,list,see,java,util,enum,set,see,java,util,tree,set,see,java,util,linked,hash,set;suppress,warnings,unchecked,cast,rawtypes,public,static,e,collection,e,create,approximate,collection,nullable,object,collection,int,capacity,if,collection,instanceof,linked,list,return,new,linked,list,else,if,collection,instanceof,list,return,new,array,list,capacity,else,if,collection,instanceof,enum,set,collection,e,enum,set,collection,e,enum,set,copy,of,enum,set,collection,enum,set,clear,return,enum,set,else,if,collection,instanceof,sorted,set,return,new,tree,set,sorted,set,e,collection,comparator,else,return,new,linked,hash,set,capacity
CollectionFactory -> @SuppressWarnings({ "unchecked", "cast", "rawtypes" }) 	public static <E> Collection<E> createApproximateCollection(@Nullable Object collection, int capacity);1530532518;Create the most approximate collection for the given collection._<p><strong>Warning</strong>: Since the parameterized type {@code E} is_not bound to the type of elements contained in the supplied_{@code collection}, type safety cannot be guaranteed if the supplied_{@code collection} is an {@link EnumSet}. In such scenarios, the caller_is responsible for ensuring that the element type for the supplied_{@code collection} is an enum type matching type {@code E}. As an_alternative, the caller may wish to treat the return value as a raw_collection or collection of {@link Object}._@param collection the original collection object, potentially {@code null}_@param capacity the initial capacity_@return a new, empty collection instance_@see #isApproximableCollectionType_@see java.util.LinkedList_@see java.util.ArrayList_@see java.util.EnumSet_@see java.util.TreeSet_@see java.util.LinkedHashSet;@SuppressWarnings({ "unchecked", "cast", "rawtypes" })_	public static <E> Collection<E> createApproximateCollection(@Nullable Object collection, int capacity) {_		if (collection instanceof LinkedList) {_			return new LinkedList<>()__		}_		else if (collection instanceof List) {_			return new ArrayList<>(capacity)__		}_		else if (collection instanceof EnumSet) {_			_			Collection<E> enumSet = (Collection<E>) EnumSet.copyOf((EnumSet) collection)__			enumSet.clear()__			return enumSet__		}_		else if (collection instanceof SortedSet) {_			return new TreeSet<>(((SortedSet<E>) collection).comparator())__		}_		else {_			return new LinkedHashSet<>(capacity)__		}_	};create,the,most,approximate,collection,for,the,given,collection,p,strong,warning,strong,since,the,parameterized,type,code,e,is,not,bound,to,the,type,of,elements,contained,in,the,supplied,code,collection,type,safety,cannot,be,guaranteed,if,the,supplied,code,collection,is,an,link,enum,set,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,element,type,for,the,supplied,code,collection,is,an,enum,type,matching,type,code,e,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,collection,or,collection,of,link,object,param,collection,the,original,collection,object,potentially,code,null,param,capacity,the,initial,capacity,return,a,new,empty,collection,instance,see,is,approximable,collection,type,see,java,util,linked,list,see,java,util,array,list,see,java,util,enum,set,see,java,util,tree,set,see,java,util,linked,hash,set;suppress,warnings,unchecked,cast,rawtypes,public,static,e,collection,e,create,approximate,collection,nullable,object,collection,int,capacity,if,collection,instanceof,linked,list,return,new,linked,list,else,if,collection,instanceof,list,return,new,array,list,capacity,else,if,collection,instanceof,enum,set,collection,e,enum,set,collection,e,enum,set,copy,of,enum,set,collection,enum,set,clear,return,enum,set,else,if,collection,instanceof,sorted,set,return,new,tree,set,sorted,set,e,collection,comparator,else,return,new,linked,hash,set,capacity
CollectionFactory -> @SuppressWarnings({ "unchecked", "cast", "rawtypes" }) 	public static <E> Collection<E> createApproximateCollection(@Nullable Object collection, int capacity);1545740431;Create the most approximate collection for the given collection._<p><strong>Warning</strong>: Since the parameterized type {@code E} is_not bound to the type of elements contained in the supplied_{@code collection}, type safety cannot be guaranteed if the supplied_{@code collection} is an {@link EnumSet}. In such scenarios, the caller_is responsible for ensuring that the element type for the supplied_{@code collection} is an enum type matching type {@code E}. As an_alternative, the caller may wish to treat the return value as a raw_collection or collection of {@link Object}._@param collection the original collection object, potentially {@code null}_@param capacity the initial capacity_@return a new, empty collection instance_@see #isApproximableCollectionType_@see java.util.LinkedList_@see java.util.ArrayList_@see java.util.EnumSet_@see java.util.TreeSet_@see java.util.LinkedHashSet;@SuppressWarnings({ "unchecked", "cast", "rawtypes" })_	public static <E> Collection<E> createApproximateCollection(@Nullable Object collection, int capacity) {_		if (collection instanceof LinkedList) {_			return new LinkedList<>()__		}_		else if (collection instanceof List) {_			return new ArrayList<>(capacity)__		}_		else if (collection instanceof EnumSet) {_			_			Collection<E> enumSet = (Collection<E>) EnumSet.copyOf((EnumSet) collection)__			enumSet.clear()__			return enumSet__		}_		else if (collection instanceof SortedSet) {_			return new TreeSet<>(((SortedSet<E>) collection).comparator())__		}_		else {_			return new LinkedHashSet<>(capacity)__		}_	};create,the,most,approximate,collection,for,the,given,collection,p,strong,warning,strong,since,the,parameterized,type,code,e,is,not,bound,to,the,type,of,elements,contained,in,the,supplied,code,collection,type,safety,cannot,be,guaranteed,if,the,supplied,code,collection,is,an,link,enum,set,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,element,type,for,the,supplied,code,collection,is,an,enum,type,matching,type,code,e,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,collection,or,collection,of,link,object,param,collection,the,original,collection,object,potentially,code,null,param,capacity,the,initial,capacity,return,a,new,empty,collection,instance,see,is,approximable,collection,type,see,java,util,linked,list,see,java,util,array,list,see,java,util,enum,set,see,java,util,tree,set,see,java,util,linked,hash,set;suppress,warnings,unchecked,cast,rawtypes,public,static,e,collection,e,create,approximate,collection,nullable,object,collection,int,capacity,if,collection,instanceof,linked,list,return,new,linked,list,else,if,collection,instanceof,list,return,new,array,list,capacity,else,if,collection,instanceof,enum,set,collection,e,enum,set,collection,e,enum,set,copy,of,enum,set,collection,enum,set,clear,return,enum,set,else,if,collection,instanceof,sorted,set,return,new,tree,set,sorted,set,e,collection,comparator,else,return,new,linked,hash,set,capacity
CollectionFactory -> @SuppressWarnings({ "unchecked", "cast", "rawtypes" }) 	public static <E> Collection<E> createApproximateCollection(@Nullable Object collection, int capacity);1549321822;Create the most approximate collection for the given collection._<p><strong>Warning</strong>: Since the parameterized type {@code E} is_not bound to the type of elements contained in the supplied_{@code collection}, type safety cannot be guaranteed if the supplied_{@code collection} is an {@link EnumSet}. In such scenarios, the caller_is responsible for ensuring that the element type for the supplied_{@code collection} is an enum type matching type {@code E}. As an_alternative, the caller may wish to treat the return value as a raw_collection or collection of {@link Object}._@param collection the original collection object, potentially {@code null}_@param capacity the initial capacity_@return a new, empty collection instance_@see #isApproximableCollectionType_@see java.util.LinkedList_@see java.util.ArrayList_@see java.util.EnumSet_@see java.util.TreeSet_@see java.util.LinkedHashSet;@SuppressWarnings({ "unchecked", "cast", "rawtypes" })_	public static <E> Collection<E> createApproximateCollection(@Nullable Object collection, int capacity) {_		if (collection instanceof LinkedList) {_			return new LinkedList<>()__		}_		else if (collection instanceof List) {_			return new ArrayList<>(capacity)__		}_		else if (collection instanceof EnumSet) {_			_			Collection<E> enumSet = (Collection<E>) EnumSet.copyOf((EnumSet) collection)__			enumSet.clear()__			return enumSet__		}_		else if (collection instanceof SortedSet) {_			return new TreeSet<>(((SortedSet<E>) collection).comparator())__		}_		else {_			return new LinkedHashSet<>(capacity)__		}_	};create,the,most,approximate,collection,for,the,given,collection,p,strong,warning,strong,since,the,parameterized,type,code,e,is,not,bound,to,the,type,of,elements,contained,in,the,supplied,code,collection,type,safety,cannot,be,guaranteed,if,the,supplied,code,collection,is,an,link,enum,set,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,element,type,for,the,supplied,code,collection,is,an,enum,type,matching,type,code,e,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,collection,or,collection,of,link,object,param,collection,the,original,collection,object,potentially,code,null,param,capacity,the,initial,capacity,return,a,new,empty,collection,instance,see,is,approximable,collection,type,see,java,util,linked,list,see,java,util,array,list,see,java,util,enum,set,see,java,util,tree,set,see,java,util,linked,hash,set;suppress,warnings,unchecked,cast,rawtypes,public,static,e,collection,e,create,approximate,collection,nullable,object,collection,int,capacity,if,collection,instanceof,linked,list,return,new,linked,list,else,if,collection,instanceof,list,return,new,array,list,capacity,else,if,collection,instanceof,enum,set,collection,e,enum,set,collection,e,enum,set,copy,of,enum,set,collection,enum,set,clear,return,enum,set,else,if,collection,instanceof,sorted,set,return,new,tree,set,sorted,set,e,collection,comparator,else,return,new,linked,hash,set,capacity
CollectionFactory -> @SuppressWarnings({"unchecked", "rawtypes"}) 	public static <K, V> Map<K, V> createMap(Class<?> mapType, Class<?> keyType, int capacity);1418219235;Create the most approximate map for the given map._@param mapType the desired type of the target Map_@param keyType the map's key type, or {@code null} if not known_(note: only relevant for {@link EnumMap} creation)_@param capacity the initial capacity_@return the new Map instance_@since 4.1.3_@see java.util.LinkedHashMap_@see java.util.TreeMap_@see java.util.EnumMap_@see org.springframework.util.LinkedMultiValueMap;@SuppressWarnings({"unchecked", "rawtypes"})_	public static <K, V> Map<K, V> createMap(Class<?> mapType, Class<?> keyType, int capacity) {_		Assert.notNull(mapType, "Map type must not be null")__		if (mapType.isInterface()) {_			if (Map.class.equals(mapType)) {_				return new LinkedHashMap<K, V>(capacity)__			}_			else if (SortedMap.class.equals(mapType) || NavigableMap.class.equals(mapType)) {_				return new TreeMap<K, V>()__			}_			else if (MultiValueMap.class.equals(mapType)) {_				return new LinkedMultiValueMap()__			}_			else {_				throw new IllegalArgumentException("Unsupported Map interface: " + mapType.getName())__			}_		}_		else if (EnumMap.class.equals(mapType)) {_			Assert.notNull(keyType, "Cannot create EnumMap for unknown key type")__			return new EnumMap(asEnumType(keyType))__		}_		else {_			if (!Map.class.isAssignableFrom(mapType)) {_				throw new IllegalArgumentException("Unsupported Map type: " + mapType.getName())__			}_			try {_				return (Map<K, V>) mapType.newInstance()__			}_			catch (Exception ex) {_				throw new IllegalArgumentException("Could not instantiate Map type: " + mapType.getName(), ex)__			}_		}_	};create,the,most,approximate,map,for,the,given,map,param,map,type,the,desired,type,of,the,target,map,param,key,type,the,map,s,key,type,or,code,null,if,not,known,note,only,relevant,for,link,enum,map,creation,param,capacity,the,initial,capacity,return,the,new,map,instance,since,4,1,3,see,java,util,linked,hash,map,see,java,util,tree,map,see,java,util,enum,map,see,org,springframework,util,linked,multi,value,map;suppress,warnings,unchecked,rawtypes,public,static,k,v,map,k,v,create,map,class,map,type,class,key,type,int,capacity,assert,not,null,map,type,map,type,must,not,be,null,if,map,type,is,interface,if,map,class,equals,map,type,return,new,linked,hash,map,k,v,capacity,else,if,sorted,map,class,equals,map,type,navigable,map,class,equals,map,type,return,new,tree,map,k,v,else,if,multi,value,map,class,equals,map,type,return,new,linked,multi,value,map,else,throw,new,illegal,argument,exception,unsupported,map,interface,map,type,get,name,else,if,enum,map,class,equals,map,type,assert,not,null,key,type,cannot,create,enum,map,for,unknown,key,type,return,new,enum,map,as,enum,type,key,type,else,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,unsupported,map,type,map,type,get,name,try,return,map,k,v,map,type,new,instance,catch,exception,ex,throw,new,illegal,argument,exception,could,not,instantiate,map,type,map,type,get,name,ex
CollectionFactory -> @SuppressWarnings({"unchecked", "rawtypes"}) 	public static <K, V> Map<K, V> createMap(Class<?> mapType, Class<?> keyType, int capacity);1418248740;Create the most appropriate map for the given map type._@param mapType the desired type of the target Map_@param keyType the map's key type, or {@code null} if not known_(note: only relevant for {@link EnumMap} creation)_@param capacity the initial capacity_@return the new Map instance_@since 4.1.3_@see java.util.LinkedHashMap_@see java.util.TreeMap_@see org.springframework.util.LinkedMultiValueMap_@see java.util.EnumMap;@SuppressWarnings({"unchecked", "rawtypes"})_	public static <K, V> Map<K, V> createMap(Class<?> mapType, Class<?> keyType, int capacity) {_		Assert.notNull(mapType, "Map type must not be null")__		if (mapType.isInterface()) {_			if (Map.class.equals(mapType)) {_				return new LinkedHashMap<K, V>(capacity)__			}_			else if (SortedMap.class.equals(mapType) || NavigableMap.class.equals(mapType)) {_				return new TreeMap<K, V>()__			}_			else if (MultiValueMap.class.equals(mapType)) {_				return new LinkedMultiValueMap()__			}_			else {_				throw new IllegalArgumentException("Unsupported Map interface: " + mapType.getName())__			}_		}_		else if (EnumMap.class.equals(mapType)) {_			Assert.notNull(keyType, "Cannot create EnumMap for unknown key type")__			return new EnumMap(asEnumType(keyType))__		}_		else {_			if (!Map.class.isAssignableFrom(mapType)) {_				throw new IllegalArgumentException("Unsupported Map type: " + mapType.getName())__			}_			try {_				return (Map<K, V>) mapType.newInstance()__			}_			catch (Exception ex) {_				throw new IllegalArgumentException("Could not instantiate Map type: " + mapType.getName(), ex)__			}_		}_	};create,the,most,appropriate,map,for,the,given,map,type,param,map,type,the,desired,type,of,the,target,map,param,key,type,the,map,s,key,type,or,code,null,if,not,known,note,only,relevant,for,link,enum,map,creation,param,capacity,the,initial,capacity,return,the,new,map,instance,since,4,1,3,see,java,util,linked,hash,map,see,java,util,tree,map,see,org,springframework,util,linked,multi,value,map,see,java,util,enum,map;suppress,warnings,unchecked,rawtypes,public,static,k,v,map,k,v,create,map,class,map,type,class,key,type,int,capacity,assert,not,null,map,type,map,type,must,not,be,null,if,map,type,is,interface,if,map,class,equals,map,type,return,new,linked,hash,map,k,v,capacity,else,if,sorted,map,class,equals,map,type,navigable,map,class,equals,map,type,return,new,tree,map,k,v,else,if,multi,value,map,class,equals,map,type,return,new,linked,multi,value,map,else,throw,new,illegal,argument,exception,unsupported,map,interface,map,type,get,name,else,if,enum,map,class,equals,map,type,assert,not,null,key,type,cannot,create,enum,map,for,unknown,key,type,return,new,enum,map,as,enum,type,key,type,else,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,unsupported,map,type,map,type,get,name,try,return,map,k,v,map,type,new,instance,catch,exception,ex,throw,new,illegal,argument,exception,could,not,instantiate,map,type,map,type,get,name,ex
CollectionFactory -> @SuppressWarnings({"unchecked", "rawtypes"}) 	public static <K, V> Map<K, V> createMap(Class<?> mapType, Class<?> keyType, int capacity);1419862420;Create the most appropriate map for the given map type._@param mapType the desired type of the target Map_@param keyType the map's key type, or {@code null} if not known_(note: only relevant for {@link EnumMap} creation)_@param capacity the initial capacity_@return the new Map instance_@since 4.1.3_@see java.util.LinkedHashMap_@see java.util.TreeMap_@see org.springframework.util.LinkedMultiValueMap_@see java.util.EnumMap;@SuppressWarnings({"unchecked", "rawtypes"})_	public static <K, V> Map<K, V> createMap(Class<?> mapType, Class<?> keyType, int capacity) {_		Assert.notNull(mapType, "Map type must not be null")__		if (mapType.isInterface()) {_			if (Map.class.equals(mapType)) {_				return new LinkedHashMap<K, V>(capacity)__			}_			else if (SortedMap.class.equals(mapType) || NavigableMap.class.equals(mapType)) {_				return new TreeMap<K, V>()__			}_			else if (MultiValueMap.class.equals(mapType)) {_				return new LinkedMultiValueMap()__			}_			else {_				throw new IllegalArgumentException("Unsupported Map interface: " + mapType.getName())__			}_		}_		else if (EnumMap.class.equals(mapType)) {_			Assert.notNull(keyType, "Cannot create EnumMap for unknown key type")__			return new EnumMap(asEnumType(keyType))__		}_		else {_			if (!Map.class.isAssignableFrom(mapType)) {_				throw new IllegalArgumentException("Unsupported Map type: " + mapType.getName())__			}_			try {_				return (Map<K, V>) mapType.newInstance()__			}_			catch (Exception ex) {_				throw new IllegalArgumentException("Could not instantiate Map type: " + mapType.getName(), ex)__			}_		}_	};create,the,most,appropriate,map,for,the,given,map,type,param,map,type,the,desired,type,of,the,target,map,param,key,type,the,map,s,key,type,or,code,null,if,not,known,note,only,relevant,for,link,enum,map,creation,param,capacity,the,initial,capacity,return,the,new,map,instance,since,4,1,3,see,java,util,linked,hash,map,see,java,util,tree,map,see,org,springframework,util,linked,multi,value,map,see,java,util,enum,map;suppress,warnings,unchecked,rawtypes,public,static,k,v,map,k,v,create,map,class,map,type,class,key,type,int,capacity,assert,not,null,map,type,map,type,must,not,be,null,if,map,type,is,interface,if,map,class,equals,map,type,return,new,linked,hash,map,k,v,capacity,else,if,sorted,map,class,equals,map,type,navigable,map,class,equals,map,type,return,new,tree,map,k,v,else,if,multi,value,map,class,equals,map,type,return,new,linked,multi,value,map,else,throw,new,illegal,argument,exception,unsupported,map,interface,map,type,get,name,else,if,enum,map,class,equals,map,type,assert,not,null,key,type,cannot,create,enum,map,for,unknown,key,type,return,new,enum,map,as,enum,type,key,type,else,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,unsupported,map,type,map,type,get,name,try,return,map,k,v,map,type,new,instance,catch,exception,ex,throw,new,illegal,argument,exception,could,not,instantiate,map,type,map,type,get,name,ex
CollectionFactory -> @SuppressWarnings({"unchecked", "rawtypes"}) 	public static <K, V> Map<K, V> createMap(Class<?> mapType, Class<?> keyType, int capacity);1420408095;Create the most appropriate map for the given map type._<p><strong>Warning</strong>: Since the parameterized type {@code K}_is not bound to the supplied {@code keyType}, type safety cannot be_guaranteed if the desired {@code mapType} is {@link EnumMap}. In such_scenarios, the caller is responsible for ensuring that the {@code keyType}_is an enum type matching type {@code K}. As an alternative, the caller_may wish to treat the return value as a raw map or map keyed by_{@link Object}. Similarly, type safety cannot be enforced if the_desired {@code mapType} is {@link MultiValueMap}._@param mapType the desired type of the target map_ never {@code null}_@param keyType the map's key type, or {@code null} if unknown_(note: only relevant for {@link EnumMap} creation)_@param capacity the initial capacity_@return a new map instance_@since 4.1.3_@see java.util.LinkedHashMap_@see java.util.TreeMap_@see org.springframework.util.LinkedMultiValueMap_@see java.util.EnumMap_@throws IllegalArgumentException if the supplied {@code mapType} is_{@code null}_ or if the desired {@code mapType} is {@link EnumMap} and_the supplied {@code keyType} is not a subtype of {@link Enum};@SuppressWarnings({"unchecked", "rawtypes"})_	public static <K, V> Map<K, V> createMap(Class<?> mapType, Class<?> keyType, int capacity) {_		Assert.notNull(mapType, "Map type must not be null")__		if (mapType.isInterface()) {_			if (Map.class.equals(mapType)) {_				return new LinkedHashMap<K, V>(capacity)__			}_			else if (SortedMap.class.equals(mapType) || NavigableMap.class.equals(mapType)) {_				return new TreeMap<K, V>()__			}_			else if (MultiValueMap.class.equals(mapType)) {_				return new LinkedMultiValueMap()__			}_			else {_				throw new IllegalArgumentException("Unsupported Map interface: " + mapType.getName())__			}_		}_		else if (EnumMap.class.equals(mapType)) {_			Assert.notNull(keyType, "Cannot create EnumMap for unknown key type")__			return new EnumMap(asEnumType(keyType))__		}_		else {_			if (!Map.class.isAssignableFrom(mapType)) {_				throw new IllegalArgumentException("Unsupported Map type: " + mapType.getName())__			}_			try {_				return (Map<K, V>) mapType.newInstance()__			}_			catch (Exception ex) {_				throw new IllegalArgumentException("Could not instantiate Map type: " + mapType.getName(), ex)__			}_		}_	};create,the,most,appropriate,map,for,the,given,map,type,p,strong,warning,strong,since,the,parameterized,type,code,k,is,not,bound,to,the,supplied,code,key,type,type,safety,cannot,be,guaranteed,if,the,desired,code,map,type,is,link,enum,map,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,code,key,type,is,an,enum,type,matching,type,code,k,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,map,or,map,keyed,by,link,object,similarly,type,safety,cannot,be,enforced,if,the,desired,code,map,type,is,link,multi,value,map,param,map,type,the,desired,type,of,the,target,map,never,code,null,param,key,type,the,map,s,key,type,or,code,null,if,unknown,note,only,relevant,for,link,enum,map,creation,param,capacity,the,initial,capacity,return,a,new,map,instance,since,4,1,3,see,java,util,linked,hash,map,see,java,util,tree,map,see,org,springframework,util,linked,multi,value,map,see,java,util,enum,map,throws,illegal,argument,exception,if,the,supplied,code,map,type,is,code,null,or,if,the,desired,code,map,type,is,link,enum,map,and,the,supplied,code,key,type,is,not,a,subtype,of,link,enum;suppress,warnings,unchecked,rawtypes,public,static,k,v,map,k,v,create,map,class,map,type,class,key,type,int,capacity,assert,not,null,map,type,map,type,must,not,be,null,if,map,type,is,interface,if,map,class,equals,map,type,return,new,linked,hash,map,k,v,capacity,else,if,sorted,map,class,equals,map,type,navigable,map,class,equals,map,type,return,new,tree,map,k,v,else,if,multi,value,map,class,equals,map,type,return,new,linked,multi,value,map,else,throw,new,illegal,argument,exception,unsupported,map,interface,map,type,get,name,else,if,enum,map,class,equals,map,type,assert,not,null,key,type,cannot,create,enum,map,for,unknown,key,type,return,new,enum,map,as,enum,type,key,type,else,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,unsupported,map,type,map,type,get,name,try,return,map,k,v,map,type,new,instance,catch,exception,ex,throw,new,illegal,argument,exception,could,not,instantiate,map,type,map,type,get,name,ex
CollectionFactory -> @SuppressWarnings({"unchecked", "rawtypes"}) 	public static <K, V> Map<K, V> createMap(Class<?> mapType, Class<?> keyType, int capacity);1432125256;Create the most appropriate map for the given map type._<p><strong>Warning</strong>: Since the parameterized type {@code K}_is not bound to the supplied {@code keyType}, type safety cannot be_guaranteed if the desired {@code mapType} is {@link EnumMap}. In such_scenarios, the caller is responsible for ensuring that the {@code keyType}_is an enum type matching type {@code K}. As an alternative, the caller_may wish to treat the return value as a raw map or map keyed by_{@link Object}. Similarly, type safety cannot be enforced if the_desired {@code mapType} is {@link MultiValueMap}._@param mapType the desired type of the target map_ never {@code null}_@param keyType the map's key type, or {@code null} if unknown_(note: only relevant for {@link EnumMap} creation)_@param capacity the initial capacity_@return a new map instance_@since 4.1.3_@see java.util.LinkedHashMap_@see java.util.TreeMap_@see org.springframework.util.LinkedMultiValueMap_@see java.util.EnumMap_@throws IllegalArgumentException if the supplied {@code mapType} is_{@code null}_ or if the desired {@code mapType} is {@link EnumMap} and_the supplied {@code keyType} is not a subtype of {@link Enum};@SuppressWarnings({"unchecked", "rawtypes"})_	public static <K, V> Map<K, V> createMap(Class<?> mapType, Class<?> keyType, int capacity) {_		Assert.notNull(mapType, "Map type must not be null")__		if (mapType.isInterface()) {_			if (Map.class == mapType) {_				return new LinkedHashMap<K, V>(capacity)__			}_			else if (SortedMap.class == mapType || NavigableMap.class == mapType) {_				return new TreeMap<K, V>()__			}_			else if (MultiValueMap.class == mapType) {_				return new LinkedMultiValueMap()__			}_			else {_				throw new IllegalArgumentException("Unsupported Map interface: " + mapType.getName())__			}_		}_		else if (EnumMap.class == mapType) {_			Assert.notNull(keyType, "Cannot create EnumMap for unknown key type")__			return new EnumMap(asEnumType(keyType))__		}_		else {_			if (!Map.class.isAssignableFrom(mapType)) {_				throw new IllegalArgumentException("Unsupported Map type: " + mapType.getName())__			}_			try {_				return (Map<K, V>) mapType.newInstance()__			}_			catch (Exception ex) {_				throw new IllegalArgumentException("Could not instantiate Map type: " + mapType.getName(), ex)__			}_		}_	};create,the,most,appropriate,map,for,the,given,map,type,p,strong,warning,strong,since,the,parameterized,type,code,k,is,not,bound,to,the,supplied,code,key,type,type,safety,cannot,be,guaranteed,if,the,desired,code,map,type,is,link,enum,map,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,code,key,type,is,an,enum,type,matching,type,code,k,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,map,or,map,keyed,by,link,object,similarly,type,safety,cannot,be,enforced,if,the,desired,code,map,type,is,link,multi,value,map,param,map,type,the,desired,type,of,the,target,map,never,code,null,param,key,type,the,map,s,key,type,or,code,null,if,unknown,note,only,relevant,for,link,enum,map,creation,param,capacity,the,initial,capacity,return,a,new,map,instance,since,4,1,3,see,java,util,linked,hash,map,see,java,util,tree,map,see,org,springframework,util,linked,multi,value,map,see,java,util,enum,map,throws,illegal,argument,exception,if,the,supplied,code,map,type,is,code,null,or,if,the,desired,code,map,type,is,link,enum,map,and,the,supplied,code,key,type,is,not,a,subtype,of,link,enum;suppress,warnings,unchecked,rawtypes,public,static,k,v,map,k,v,create,map,class,map,type,class,key,type,int,capacity,assert,not,null,map,type,map,type,must,not,be,null,if,map,type,is,interface,if,map,class,map,type,return,new,linked,hash,map,k,v,capacity,else,if,sorted,map,class,map,type,navigable,map,class,map,type,return,new,tree,map,k,v,else,if,multi,value,map,class,map,type,return,new,linked,multi,value,map,else,throw,new,illegal,argument,exception,unsupported,map,interface,map,type,get,name,else,if,enum,map,class,map,type,assert,not,null,key,type,cannot,create,enum,map,for,unknown,key,type,return,new,enum,map,as,enum,type,key,type,else,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,unsupported,map,type,map,type,get,name,try,return,map,k,v,map,type,new,instance,catch,exception,ex,throw,new,illegal,argument,exception,could,not,instantiate,map,type,map,type,get,name,ex
CollectionFactory -> @SuppressWarnings({"unchecked", "rawtypes"}) 	public static <K, V> Map<K, V> createMap(Class<?> mapType, Class<?> keyType, int capacity);1467730834;Create the most appropriate map for the given map type._<p><strong>Warning</strong>: Since the parameterized type {@code K}_is not bound to the supplied {@code keyType}, type safety cannot be_guaranteed if the desired {@code mapType} is {@link EnumMap}. In such_scenarios, the caller is responsible for ensuring that the {@code keyType}_is an enum type matching type {@code K}. As an alternative, the caller_may wish to treat the return value as a raw map or map keyed by_{@link Object}. Similarly, type safety cannot be enforced if the_desired {@code mapType} is {@link MultiValueMap}._@param mapType the desired type of the target map_ never {@code null}_@param keyType the map's key type, or {@code null} if unknown_(note: only relevant for {@link EnumMap} creation)_@param capacity the initial capacity_@return a new map instance_@since 4.1.3_@see java.util.LinkedHashMap_@see java.util.TreeMap_@see org.springframework.util.LinkedMultiValueMap_@see java.util.EnumMap_@throws IllegalArgumentException if the supplied {@code mapType} is_{@code null}_ or if the desired {@code mapType} is {@link EnumMap} and_the supplied {@code keyType} is not a subtype of {@link Enum};@SuppressWarnings({"unchecked", "rawtypes"})_	public static <K, V> Map<K, V> createMap(Class<?> mapType, Class<?> keyType, int capacity) {_		Assert.notNull(mapType, "Map type must not be null")__		if (mapType.isInterface()) {_			if (Map.class == mapType) {_				return new LinkedHashMap<>(capacity)__			}_			else if (SortedMap.class == mapType || NavigableMap.class == mapType) {_				return new TreeMap<>()__			}_			else if (MultiValueMap.class == mapType) {_				return new LinkedMultiValueMap()__			}_			else {_				throw new IllegalArgumentException("Unsupported Map interface: " + mapType.getName())__			}_		}_		else if (EnumMap.class == mapType) {_			Assert.notNull(keyType, "Cannot create EnumMap for unknown key type")__			return new EnumMap(asEnumType(keyType))__		}_		else {_			if (!Map.class.isAssignableFrom(mapType)) {_				throw new IllegalArgumentException("Unsupported Map type: " + mapType.getName())__			}_			try {_				return (Map<K, V>) mapType.newInstance()__			}_			catch (Exception ex) {_				throw new IllegalArgumentException("Could not instantiate Map type: " + mapType.getName(), ex)__			}_		}_	};create,the,most,appropriate,map,for,the,given,map,type,p,strong,warning,strong,since,the,parameterized,type,code,k,is,not,bound,to,the,supplied,code,key,type,type,safety,cannot,be,guaranteed,if,the,desired,code,map,type,is,link,enum,map,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,code,key,type,is,an,enum,type,matching,type,code,k,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,map,or,map,keyed,by,link,object,similarly,type,safety,cannot,be,enforced,if,the,desired,code,map,type,is,link,multi,value,map,param,map,type,the,desired,type,of,the,target,map,never,code,null,param,key,type,the,map,s,key,type,or,code,null,if,unknown,note,only,relevant,for,link,enum,map,creation,param,capacity,the,initial,capacity,return,a,new,map,instance,since,4,1,3,see,java,util,linked,hash,map,see,java,util,tree,map,see,org,springframework,util,linked,multi,value,map,see,java,util,enum,map,throws,illegal,argument,exception,if,the,supplied,code,map,type,is,code,null,or,if,the,desired,code,map,type,is,link,enum,map,and,the,supplied,code,key,type,is,not,a,subtype,of,link,enum;suppress,warnings,unchecked,rawtypes,public,static,k,v,map,k,v,create,map,class,map,type,class,key,type,int,capacity,assert,not,null,map,type,map,type,must,not,be,null,if,map,type,is,interface,if,map,class,map,type,return,new,linked,hash,map,capacity,else,if,sorted,map,class,map,type,navigable,map,class,map,type,return,new,tree,map,else,if,multi,value,map,class,map,type,return,new,linked,multi,value,map,else,throw,new,illegal,argument,exception,unsupported,map,interface,map,type,get,name,else,if,enum,map,class,map,type,assert,not,null,key,type,cannot,create,enum,map,for,unknown,key,type,return,new,enum,map,as,enum,type,key,type,else,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,unsupported,map,type,map,type,get,name,try,return,map,k,v,map,type,new,instance,catch,exception,ex,throw,new,illegal,argument,exception,could,not,instantiate,map,type,map,type,get,name,ex
CollectionFactory -> @SuppressWarnings({"unchecked", "rawtypes"}) 	public static <K, V> Map<K, V> createMap(Class<?> mapType, Class<?> keyType, int capacity);1468948866;Create the most appropriate map for the given map type._<p><strong>Warning</strong>: Since the parameterized type {@code K}_is not bound to the supplied {@code keyType}, type safety cannot be_guaranteed if the desired {@code mapType} is {@link EnumMap}. In such_scenarios, the caller is responsible for ensuring that the {@code keyType}_is an enum type matching type {@code K}. As an alternative, the caller_may wish to treat the return value as a raw map or map keyed by_{@link Object}. Similarly, type safety cannot be enforced if the_desired {@code mapType} is {@link MultiValueMap}._@param mapType the desired type of the target map_ never {@code null}_@param keyType the map's key type, or {@code null} if unknown_(note: only relevant for {@link EnumMap} creation)_@param capacity the initial capacity_@return a new map instance_@since 4.1.3_@see java.util.LinkedHashMap_@see java.util.TreeMap_@see org.springframework.util.LinkedMultiValueMap_@see java.util.EnumMap_@throws IllegalArgumentException if the supplied {@code mapType} is_{@code null}_ or if the desired {@code mapType} is {@link EnumMap} and_the supplied {@code keyType} is not a subtype of {@link Enum};@SuppressWarnings({"unchecked", "rawtypes"})_	public static <K, V> Map<K, V> createMap(Class<?> mapType, Class<?> keyType, int capacity) {_		Assert.notNull(mapType, "Map type must not be null")__		if (mapType.isInterface()) {_			if (Map.class == mapType) {_				return new LinkedHashMap<>(capacity)__			}_			else if (SortedMap.class == mapType || NavigableMap.class == mapType) {_				return new TreeMap<>()__			}_			else if (MultiValueMap.class == mapType) {_				return new LinkedMultiValueMap()__			}_			else {_				throw new IllegalArgumentException("Unsupported Map interface: " + mapType.getName())__			}_		}_		else if (EnumMap.class == mapType) {_			Assert.notNull(keyType, "Cannot create EnumMap for unknown key type")__			return new EnumMap(asEnumType(keyType))__		}_		else {_			if (!Map.class.isAssignableFrom(mapType)) {_				throw new IllegalArgumentException("Unsupported Map type: " + mapType.getName())__			}_			try {_				return (Map<K, V>) ReflectionUtils.accessibleConstructor(mapType).newInstance()__			}_			catch (Throwable ex) {_				throw new IllegalArgumentException("Could not instantiate Map type: " + mapType.getName(), ex)__			}_		}_	};create,the,most,appropriate,map,for,the,given,map,type,p,strong,warning,strong,since,the,parameterized,type,code,k,is,not,bound,to,the,supplied,code,key,type,type,safety,cannot,be,guaranteed,if,the,desired,code,map,type,is,link,enum,map,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,code,key,type,is,an,enum,type,matching,type,code,k,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,map,or,map,keyed,by,link,object,similarly,type,safety,cannot,be,enforced,if,the,desired,code,map,type,is,link,multi,value,map,param,map,type,the,desired,type,of,the,target,map,never,code,null,param,key,type,the,map,s,key,type,or,code,null,if,unknown,note,only,relevant,for,link,enum,map,creation,param,capacity,the,initial,capacity,return,a,new,map,instance,since,4,1,3,see,java,util,linked,hash,map,see,java,util,tree,map,see,org,springframework,util,linked,multi,value,map,see,java,util,enum,map,throws,illegal,argument,exception,if,the,supplied,code,map,type,is,code,null,or,if,the,desired,code,map,type,is,link,enum,map,and,the,supplied,code,key,type,is,not,a,subtype,of,link,enum;suppress,warnings,unchecked,rawtypes,public,static,k,v,map,k,v,create,map,class,map,type,class,key,type,int,capacity,assert,not,null,map,type,map,type,must,not,be,null,if,map,type,is,interface,if,map,class,map,type,return,new,linked,hash,map,capacity,else,if,sorted,map,class,map,type,navigable,map,class,map,type,return,new,tree,map,else,if,multi,value,map,class,map,type,return,new,linked,multi,value,map,else,throw,new,illegal,argument,exception,unsupported,map,interface,map,type,get,name,else,if,enum,map,class,map,type,assert,not,null,key,type,cannot,create,enum,map,for,unknown,key,type,return,new,enum,map,as,enum,type,key,type,else,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,unsupported,map,type,map,type,get,name,try,return,map,k,v,reflection,utils,accessible,constructor,map,type,new,instance,catch,throwable,ex,throw,new,illegal,argument,exception,could,not,instantiate,map,type,map,type,get,name,ex
CollectionFactory -> @SuppressWarnings({"unchecked", "rawtypes"}) 	public static <K, V> Map<K, V> createMap(Class<?> mapType, Class<?> keyType, int capacity);1474830340;Create the most appropriate map for the given map type._<p><strong>Warning</strong>: Since the parameterized type {@code K}_is not bound to the supplied {@code keyType}, type safety cannot be_guaranteed if the desired {@code mapType} is {@link EnumMap}. In such_scenarios, the caller is responsible for ensuring that the {@code keyType}_is an enum type matching type {@code K}. As an alternative, the caller_may wish to treat the return value as a raw map or map keyed by_{@link Object}. Similarly, type safety cannot be enforced if the_desired {@code mapType} is {@link MultiValueMap}._@param mapType the desired type of the target map_ never {@code null}_@param keyType the map's key type, or {@code null} if unknown_(note: only relevant for {@link EnumMap} creation)_@param capacity the initial capacity_@return a new map instance_@since 4.1.3_@see java.util.LinkedHashMap_@see java.util.TreeMap_@see org.springframework.util.LinkedMultiValueMap_@see java.util.EnumMap_@throws IllegalArgumentException if the supplied {@code mapType} is_{@code null}_ or if the desired {@code mapType} is {@link EnumMap} and_the supplied {@code keyType} is not a subtype of {@link Enum};@SuppressWarnings({"unchecked", "rawtypes"})_	public static <K, V> Map<K, V> createMap(Class<?> mapType, Class<?> keyType, int capacity) {_		Assert.notNull(mapType, "Map type must not be null")__		if (mapType.isInterface()) {_			if (Map.class == mapType) {_				return new LinkedHashMap<>(capacity)__			}_			else if (SortedMap.class == mapType || NavigableMap.class == mapType) {_				return new TreeMap<>()__			}_			else if (MultiValueMap.class == mapType) {_				return new LinkedMultiValueMap()__			}_			else {_				throw new IllegalArgumentException("Unsupported Map interface: " + mapType.getName())__			}_		}_		else if (EnumMap.class == mapType) {_			Assert.notNull(keyType, "Cannot create EnumMap for unknown key type")__			return new EnumMap(asEnumType(keyType))__		}_		else {_			if (!Map.class.isAssignableFrom(mapType)) {_				throw new IllegalArgumentException("Unsupported Map type: " + mapType.getName())__			}_			try {_				return (Map<K, V>) ReflectionUtils.accessibleConstructor(mapType).newInstance()__			}_			catch (Throwable ex) {_				throw new IllegalArgumentException("Could not instantiate Map type: " + mapType.getName(), ex)__			}_		}_	};create,the,most,appropriate,map,for,the,given,map,type,p,strong,warning,strong,since,the,parameterized,type,code,k,is,not,bound,to,the,supplied,code,key,type,type,safety,cannot,be,guaranteed,if,the,desired,code,map,type,is,link,enum,map,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,code,key,type,is,an,enum,type,matching,type,code,k,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,map,or,map,keyed,by,link,object,similarly,type,safety,cannot,be,enforced,if,the,desired,code,map,type,is,link,multi,value,map,param,map,type,the,desired,type,of,the,target,map,never,code,null,param,key,type,the,map,s,key,type,or,code,null,if,unknown,note,only,relevant,for,link,enum,map,creation,param,capacity,the,initial,capacity,return,a,new,map,instance,since,4,1,3,see,java,util,linked,hash,map,see,java,util,tree,map,see,org,springframework,util,linked,multi,value,map,see,java,util,enum,map,throws,illegal,argument,exception,if,the,supplied,code,map,type,is,code,null,or,if,the,desired,code,map,type,is,link,enum,map,and,the,supplied,code,key,type,is,not,a,subtype,of,link,enum;suppress,warnings,unchecked,rawtypes,public,static,k,v,map,k,v,create,map,class,map,type,class,key,type,int,capacity,assert,not,null,map,type,map,type,must,not,be,null,if,map,type,is,interface,if,map,class,map,type,return,new,linked,hash,map,capacity,else,if,sorted,map,class,map,type,navigable,map,class,map,type,return,new,tree,map,else,if,multi,value,map,class,map,type,return,new,linked,multi,value,map,else,throw,new,illegal,argument,exception,unsupported,map,interface,map,type,get,name,else,if,enum,map,class,map,type,assert,not,null,key,type,cannot,create,enum,map,for,unknown,key,type,return,new,enum,map,as,enum,type,key,type,else,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,unsupported,map,type,map,type,get,name,try,return,map,k,v,reflection,utils,accessible,constructor,map,type,new,instance,catch,throwable,ex,throw,new,illegal,argument,exception,could,not,instantiate,map,type,map,type,get,name,ex
CollectionFactory -> @SuppressWarnings({"unchecked", "rawtypes"}) 	public static <K, V> Map<K, V> createMap(Class<?> mapType, Class<?> keyType, int capacity);1484252281;Create the most appropriate map for the given map type._<p><strong>Warning</strong>: Since the parameterized type {@code K}_is not bound to the supplied {@code keyType}, type safety cannot be_guaranteed if the desired {@code mapType} is {@link EnumMap}. In such_scenarios, the caller is responsible for ensuring that the {@code keyType}_is an enum type matching type {@code K}. As an alternative, the caller_may wish to treat the return value as a raw map or map keyed by_{@link Object}. Similarly, type safety cannot be enforced if the_desired {@code mapType} is {@link MultiValueMap}._@param mapType the desired type of the target map_ never {@code null}_@param keyType the map's key type, or {@code null} if unknown_(note: only relevant for {@link EnumMap} creation)_@param capacity the initial capacity_@return a new map instance_@since 4.1.3_@see java.util.LinkedHashMap_@see java.util.TreeMap_@see org.springframework.util.LinkedMultiValueMap_@see java.util.EnumMap_@throws IllegalArgumentException if the supplied {@code mapType} is_{@code null}_ or if the desired {@code mapType} is {@link EnumMap} and_the supplied {@code keyType} is not a subtype of {@link Enum};@SuppressWarnings({"unchecked", "rawtypes"})_	public static <K, V> Map<K, V> createMap(Class<?> mapType, Class<?> keyType, int capacity) {_		Assert.notNull(mapType, "Map type must not be null")__		if (mapType.isInterface()) {_			if (Map.class == mapType) {_				return new LinkedHashMap<>(capacity)__			}_			else if (SortedMap.class == mapType || NavigableMap.class == mapType) {_				return new TreeMap<>()__			}_			else if (MultiValueMap.class == mapType) {_				return new LinkedMultiValueMap()__			}_			else {_				throw new IllegalArgumentException("Unsupported Map interface: " + mapType.getName())__			}_		}_		else if (EnumMap.class == mapType) {_			Assert.notNull(keyType, "Cannot create EnumMap for unknown key type")__			return new EnumMap(asEnumType(keyType))__		}_		else {_			if (!Map.class.isAssignableFrom(mapType)) {_				throw new IllegalArgumentException("Unsupported Map type: " + mapType.getName())__			}_			try {_				return (Map<K, V>) ReflectionUtils.accessibleConstructor(mapType).newInstance()__			}_			catch (Throwable ex) {_				throw new IllegalArgumentException("Could not instantiate Map type: " + mapType.getName(), ex)__			}_		}_	};create,the,most,appropriate,map,for,the,given,map,type,p,strong,warning,strong,since,the,parameterized,type,code,k,is,not,bound,to,the,supplied,code,key,type,type,safety,cannot,be,guaranteed,if,the,desired,code,map,type,is,link,enum,map,in,such,scenarios,the,caller,is,responsible,for,ensuring,that,the,code,key,type,is,an,enum,type,matching,type,code,k,as,an,alternative,the,caller,may,wish,to,treat,the,return,value,as,a,raw,map,or,map,keyed,by,link,object,similarly,type,safety,cannot,be,enforced,if,the,desired,code,map,type,is,link,multi,value,map,param,map,type,the,desired,type,of,the,target,map,never,code,null,param,key,type,the,map,s,key,type,or,code,null,if,unknown,note,only,relevant,for,link,enum,map,creation,param,capacity,the,initial,capacity,return,a,new,map,instance,since,4,1,3,see,java,util,linked,hash,map,see,java,util,tree,map,see,org,springframework,util,linked,multi,value,map,see,java,util,enum,map,throws,illegal,argument,exception,if,the,supplied,code,map,type,is,code,null,or,if,the,desired,code,map,type,is,link,enum,map,and,the,supplied,code,key,type,is,not,a,subtype,of,link,enum;suppress,warnings,unchecked,rawtypes,public,static,k,v,map,k,v,create,map,class,map,type,class,key,type,int,capacity,assert,not,null,map,type,map,type,must,not,be,null,if,map,type,is,interface,if,map,class,map,type,return,new,linked,hash,map,capacity,else,if,sorted,map,class,map,type,navigable,map,class,map,type,return,new,tree,map,else,if,multi,value,map,class,map,type,return,new,linked,multi,value,map,else,throw,new,illegal,argument,exception,unsupported,map,interface,map,type,get,name,else,if,enum,map,class,map,type,assert,not,null,key,type,cannot,create,enum,map,for,unknown,key,type,return,new,enum,map,as,enum,type,key,type,else,if,map,class,is,assignable,from,map,type,throw,new,illegal,argument,exception,unsupported,map,type,map,type,get,name,try,return,map,k,v,reflection,utils,accessible,constructor,map,type,new,instance,catch,throwable,ex,throw,new,illegal,argument,exception,could,not,instantiate,map,type,map,type,get,name,ex
CollectionFactory -> @Deprecated 	public static <K,V> Map<K,V> createLinkedMapIfPossible(int initialCapacity);1328020251;Create a linked Map if possible: This implementation always_creates a {@link java.util.LinkedHashMap}, since Spring 2.5_requires JDK 1.4 anyway._@param initialCapacity the initial capacity of the Map_@return the new Map instance_@deprecated as of Spring 2.5, for usage on JDK 1.4 or higher;@Deprecated_	public static <K,V> Map<K,V> createLinkedMapIfPossible(int initialCapacity) {_		return new LinkedHashMap<K,V>(initialCapacity)__	};create,a,linked,map,if,possible,this,implementation,always,creates,a,link,java,util,linked,hash,map,since,spring,2,5,requires,jdk,1,4,anyway,param,initial,capacity,the,initial,capacity,of,the,map,return,the,new,map,instance,deprecated,as,of,spring,2,5,for,usage,on,jdk,1,4,or,higher;deprecated,public,static,k,v,map,k,v,create,linked,map,if,possible,int,initial,capacity,return,new,linked,hash,map,k,v,initial,capacity
CollectionFactory -> @Deprecated 	public static <K,V> Map<K,V> createLinkedMapIfPossible(int initialCapacity);1346774041;Create a linked Map if possible: This implementation always_creates a {@link java.util.LinkedHashMap}, since Spring 2.5_requires JDK 1.4 anyway._@param initialCapacity the initial capacity of the Map_@return the new Map instance_@deprecated as of Spring 2.5, for usage on JDK 1.4 or higher;@Deprecated_	public static <K,V> Map<K,V> createLinkedMapIfPossible(int initialCapacity) {_		return new LinkedHashMap<K,V>(initialCapacity)__	};create,a,linked,map,if,possible,this,implementation,always,creates,a,link,java,util,linked,hash,map,since,spring,2,5,requires,jdk,1,4,anyway,param,initial,capacity,the,initial,capacity,of,the,map,return,the,new,map,instance,deprecated,as,of,spring,2,5,for,usage,on,jdk,1,4,or,higher;deprecated,public,static,k,v,map,k,v,create,linked,map,if,possible,int,initial,capacity,return,new,linked,hash,map,k,v,initial,capacity
CollectionFactory -> @Deprecated 	public static <K,V> Map<K,V> createLinkedMapIfPossible(int initialCapacity);1346774711;Create a linked Map if possible: This implementation always_creates a {@link java.util.LinkedHashMap}, since Spring 2.5_requires JDK 1.4 anyway._@param initialCapacity the initial capacity of the Map_@return the new Map instance_@deprecated as of Spring 2.5, for usage on JDK 1.4 or higher;@Deprecated_	public static <K,V> Map<K,V> createLinkedMapIfPossible(int initialCapacity) {_		return new LinkedHashMap<K,V>(initialCapacity)__	};create,a,linked,map,if,possible,this,implementation,always,creates,a,link,java,util,linked,hash,map,since,spring,2,5,requires,jdk,1,4,anyway,param,initial,capacity,the,initial,capacity,of,the,map,return,the,new,map,instance,deprecated,as,of,spring,2,5,for,usage,on,jdk,1,4,or,higher;deprecated,public,static,k,v,map,k,v,create,linked,map,if,possible,int,initial,capacity,return,new,linked,hash,map,k,v,initial,capacity
CollectionFactory -> @Deprecated 	public static <K,V> Map<K,V> createLinkedMapIfPossible(int initialCapacity);1349903156;Create a linked Map if possible: This implementation always_creates a {@link java.util.LinkedHashMap}, since Spring 2.5_requires JDK 1.4 anyway._@param initialCapacity the initial capacity of the Map_@return the new Map instance_@deprecated as of Spring 2.5, for usage on JDK 1.4 or higher;@Deprecated_	public static <K,V> Map<K,V> createLinkedMapIfPossible(int initialCapacity) {_		return new LinkedHashMap<K,V>(initialCapacity)__	};create,a,linked,map,if,possible,this,implementation,always,creates,a,link,java,util,linked,hash,map,since,spring,2,5,requires,jdk,1,4,anyway,param,initial,capacity,the,initial,capacity,of,the,map,return,the,new,map,instance,deprecated,as,of,spring,2,5,for,usage,on,jdk,1,4,or,higher;deprecated,public,static,k,v,map,k,v,create,linked,map,if,possible,int,initial,capacity,return,new,linked,hash,map,k,v,initial,capacity
CollectionFactory -> @Deprecated 	public static <K,V> Map<K,V> createLinkedMapIfPossible(int initialCapacity);1355313310;Create a linked Map if possible: This implementation always_creates a {@link java.util.LinkedHashMap}, since Spring 2.5_requires JDK 1.4 anyway._@param initialCapacity the initial capacity of the Map_@return the new Map instance_@deprecated as of Spring 2.5, for usage on JDK 1.4 or higher;@Deprecated_	public static <K,V> Map<K,V> createLinkedMapIfPossible(int initialCapacity) {_		return new LinkedHashMap<K,V>(initialCapacity)__	};create,a,linked,map,if,possible,this,implementation,always,creates,a,link,java,util,linked,hash,map,since,spring,2,5,requires,jdk,1,4,anyway,param,initial,capacity,the,initial,capacity,of,the,map,return,the,new,map,instance,deprecated,as,of,spring,2,5,for,usage,on,jdk,1,4,or,higher;deprecated,public,static,k,v,map,k,v,create,linked,map,if,possible,int,initial,capacity,return,new,linked,hash,map,k,v,initial,capacity
CollectionFactory -> @Deprecated 	public static <K,V> Map<K,V> createLinkedMapIfPossible(int initialCapacity);1356735495;Create a linked Map if possible: This implementation always_creates a {@link java.util.LinkedHashMap}, since Spring 2.5_requires JDK 1.4 anyway._@param initialCapacity the initial capacity of the Map_@return the new Map instance_@deprecated as of Spring 2.5, for usage on JDK 1.4 or higher;@Deprecated_	public static <K,V> Map<K,V> createLinkedMapIfPossible(int initialCapacity) {_		return new LinkedHashMap<K,V>(initialCapacity)__	};create,a,linked,map,if,possible,this,implementation,always,creates,a,link,java,util,linked,hash,map,since,spring,2,5,requires,jdk,1,4,anyway,param,initial,capacity,the,initial,capacity,of,the,map,return,the,new,map,instance,deprecated,as,of,spring,2,5,for,usage,on,jdk,1,4,or,higher;deprecated,public,static,k,v,map,k,v,create,linked,map,if,possible,int,initial,capacity,return,new,linked,hash,map,k,v,initial,capacity
CollectionFactory -> @SuppressWarnings({"unchecked", "rawtypes"}) 	public static <K, V> Map<K, V> createMap(Class<?> mapClass, Class<?> keyType, int capacity);1417203046;Create the most approximate map for the given map._@param mapClass the desired type of the target Map_@param keyType the map's key type, or {@code null} if not known_@param capacity the initial capacity_@return the new Map instance_@see java.util.LinkedHashMap_@see java.util.TreeMap_@see java.util.EnumMap_@see org.springframework.util.LinkedMultiValueMap;@SuppressWarnings({"unchecked", "rawtypes"})_	public static <K, V> Map<K, V> createMap(Class<?> mapClass, Class<?> keyType, int capacity) {_		if (mapClass.isInterface()) {_			if (Map.class.equals(mapClass)) {_				return new LinkedHashMap<K, V>(capacity)__			}_			else if (SortedMap.class.equals(mapClass) || NavigableMap.class.equals(mapClass)) {_				return new TreeMap<K, V>()__			}_			else if (MultiValueMap.class.equals(mapClass)) {_				return new LinkedMultiValueMap()__			}_			else {_				throw new IllegalArgumentException("Unsupported Map interface: " + mapClass.getName())__			}_		}_		else if (EnumMap.class.equals(mapClass)) {_			Assert.notNull(keyType, "Cannot create EnumMap for unknown key type")__			return new EnumMap(keyType)__		}_		else {_			if (!Map.class.isAssignableFrom(mapClass)) {_				throw new IllegalArgumentException("Unsupported Map type: " + mapClass.getName())__			}_			try {_				return (Map<K, V>) mapClass.newInstance()__			}_			catch (Exception ex) {_				throw new IllegalArgumentException(_						"Could not instantiate Map type: " + mapClass.getName(), ex)__			}_		}_	};create,the,most,approximate,map,for,the,given,map,param,map,class,the,desired,type,of,the,target,map,param,key,type,the,map,s,key,type,or,code,null,if,not,known,param,capacity,the,initial,capacity,return,the,new,map,instance,see,java,util,linked,hash,map,see,java,util,tree,map,see,java,util,enum,map,see,org,springframework,util,linked,multi,value,map;suppress,warnings,unchecked,rawtypes,public,static,k,v,map,k,v,create,map,class,map,class,class,key,type,int,capacity,if,map,class,is,interface,if,map,class,equals,map,class,return,new,linked,hash,map,k,v,capacity,else,if,sorted,map,class,equals,map,class,navigable,map,class,equals,map,class,return,new,tree,map,k,v,else,if,multi,value,map,class,equals,map,class,return,new,linked,multi,value,map,else,throw,new,illegal,argument,exception,unsupported,map,interface,map,class,get,name,else,if,enum,map,class,equals,map,class,assert,not,null,key,type,cannot,create,enum,map,for,unknown,key,type,return,new,enum,map,key,type,else,if,map,class,is,assignable,from,map,class,throw,new,illegal,argument,exception,unsupported,map,type,map,class,get,name,try,return,map,k,v,map,class,new,instance,catch,exception,ex,throw,new,illegal,argument,exception,could,not,instantiate,map,type,map,class,get,name,ex
CollectionFactory -> @SuppressWarnings({"unchecked", "rawtypes"}) 	public static <K, V> Map<K, V> createMap(Class<?> mapClass, Class<?> keyType, int capacity);1417290546;Create the most approximate map for the given map._@param mapClass the desired type of the target Map_@param keyType the map's key type, or {@code null} if not known_(note: only relevant for {@link EnumMap} creation)_@param capacity the initial capacity_@return the new Map instance_@since 4.1.3_@see java.util.LinkedHashMap_@see java.util.TreeMap_@see java.util.EnumMap_@see org.springframework.util.LinkedMultiValueMap;@SuppressWarnings({"unchecked", "rawtypes"})_	public static <K, V> Map<K, V> createMap(Class<?> mapClass, Class<?> keyType, int capacity) {_		if (mapClass.isInterface()) {_			if (Map.class.equals(mapClass)) {_				return new LinkedHashMap<K, V>(capacity)__			}_			else if (SortedMap.class.equals(mapClass) || NavigableMap.class.equals(mapClass)) {_				return new TreeMap<K, V>()__			}_			else if (MultiValueMap.class.equals(mapClass)) {_				return new LinkedMultiValueMap()__			}_			else {_				throw new IllegalArgumentException("Unsupported Map interface: " + mapClass.getName())__			}_		}_		else if (EnumMap.class.equals(mapClass)) {_			Assert.notNull(keyType, "Cannot create EnumMap for unknown key type")__			return new EnumMap(keyType)__		}_		else {_			if (!Map.class.isAssignableFrom(mapClass)) {_				throw new IllegalArgumentException("Unsupported Map type: " + mapClass.getName())__			}_			try {_				return (Map<K, V>) mapClass.newInstance()__			}_			catch (Exception ex) {_				throw new IllegalArgumentException(_						"Could not instantiate Map type: " + mapClass.getName(), ex)__			}_		}_	};create,the,most,approximate,map,for,the,given,map,param,map,class,the,desired,type,of,the,target,map,param,key,type,the,map,s,key,type,or,code,null,if,not,known,note,only,relevant,for,link,enum,map,creation,param,capacity,the,initial,capacity,return,the,new,map,instance,since,4,1,3,see,java,util,linked,hash,map,see,java,util,tree,map,see,java,util,enum,map,see,org,springframework,util,linked,multi,value,map;suppress,warnings,unchecked,rawtypes,public,static,k,v,map,k,v,create,map,class,map,class,class,key,type,int,capacity,if,map,class,is,interface,if,map,class,equals,map,class,return,new,linked,hash,map,k,v,capacity,else,if,sorted,map,class,equals,map,class,navigable,map,class,equals,map,class,return,new,tree,map,k,v,else,if,multi,value,map,class,equals,map,class,return,new,linked,multi,value,map,else,throw,new,illegal,argument,exception,unsupported,map,interface,map,class,get,name,else,if,enum,map,class,equals,map,class,assert,not,null,key,type,cannot,create,enum,map,for,unknown,key,type,return,new,enum,map,key,type,else,if,map,class,is,assignable,from,map,class,throw,new,illegal,argument,exception,unsupported,map,type,map,class,get,name,try,return,map,k,v,map,class,new,instance,catch,exception,ex,throw,new,illegal,argument,exception,could,not,instantiate,map,type,map,class,get,name,ex
CollectionFactory -> @SuppressWarnings({"unchecked", "rawtypes"}) 	public static <K, V> Map<K, V> createMap(Class<?> mapClass, Class<?> keyType, int capacity);1418154876;Create the most approximate map for the given map._@param mapClass the desired type of the target Map_@param keyType the map's key type, or {@code null} if not known_(note: only relevant for {@link EnumMap} creation)_@param capacity the initial capacity_@return the new Map instance_@since 4.1.3_@see java.util.LinkedHashMap_@see java.util.TreeMap_@see java.util.EnumMap_@see org.springframework.util.LinkedMultiValueMap;@SuppressWarnings({"unchecked", "rawtypes"})_	public static <K, V> Map<K, V> createMap(Class<?> mapClass, Class<?> keyType, int capacity) {_		if (mapClass.isInterface()) {_			if (Map.class.equals(mapClass)) {_				return new LinkedHashMap<K, V>(capacity)__			}_			else if (SortedMap.class.equals(mapClass) || NavigableMap.class.equals(mapClass)) {_				return new TreeMap<K, V>()__			}_			else if (MultiValueMap.class.equals(mapClass)) {_				return new LinkedMultiValueMap()__			}_			else {_				throw new IllegalArgumentException("Unsupported Map interface: " + mapClass.getName())__			}_		}_		else if (EnumMap.class.equals(mapClass)) {_			Assert.notNull(keyType, "Cannot create EnumMap for unknown key type")__			return new EnumMap(keyType)__		}_		else {_			if (!Map.class.isAssignableFrom(mapClass)) {_				throw new IllegalArgumentException("Unsupported Map type: " + mapClass.getName())__			}_			try {_				return (Map<K, V>) mapClass.newInstance()__			}_			catch (Exception ex) {_				throw new IllegalArgumentException(_						"Could not instantiate Map type: " + mapClass.getName(), ex)__			}_		}_	};create,the,most,approximate,map,for,the,given,map,param,map,class,the,desired,type,of,the,target,map,param,key,type,the,map,s,key,type,or,code,null,if,not,known,note,only,relevant,for,link,enum,map,creation,param,capacity,the,initial,capacity,return,the,new,map,instance,since,4,1,3,see,java,util,linked,hash,map,see,java,util,tree,map,see,java,util,enum,map,see,org,springframework,util,linked,multi,value,map;suppress,warnings,unchecked,rawtypes,public,static,k,v,map,k,v,create,map,class,map,class,class,key,type,int,capacity,if,map,class,is,interface,if,map,class,equals,map,class,return,new,linked,hash,map,k,v,capacity,else,if,sorted,map,class,equals,map,class,navigable,map,class,equals,map,class,return,new,tree,map,k,v,else,if,multi,value,map,class,equals,map,class,return,new,linked,multi,value,map,else,throw,new,illegal,argument,exception,unsupported,map,interface,map,class,get,name,else,if,enum,map,class,equals,map,class,assert,not,null,key,type,cannot,create,enum,map,for,unknown,key,type,return,new,enum,map,key,type,else,if,map,class,is,assignable,from,map,class,throw,new,illegal,argument,exception,unsupported,map,type,map,class,get,name,try,return,map,k,v,map,class,new,instance,catch,exception,ex,throw,new,illegal,argument,exception,could,not,instantiate,map,type,map,class,get,name,ex
CollectionFactory -> @SuppressWarnings({"unchecked", "rawtypes"}) 	public static <K, V> Map<K, V> createMap(Class<?> mapClass, Class<?> keyType, int capacity);1418156945;Create the most approximate map for the given map._@param mapClass the desired type of the target Map_@param keyType the map's key type, or {@code null} if not known_(note: only relevant for {@link EnumMap} creation)_@param capacity the initial capacity_@return the new Map instance_@since 4.1.3_@see java.util.LinkedHashMap_@see java.util.TreeMap_@see java.util.EnumMap_@see org.springframework.util.LinkedMultiValueMap;@SuppressWarnings({"unchecked", "rawtypes"})_	public static <K, V> Map<K, V> createMap(Class<?> mapClass, Class<?> keyType, int capacity) {_		if (mapClass.isInterface()) {_			if (Map.class.equals(mapClass)) {_				return new LinkedHashMap<K, V>(capacity)__			}_			else if (SortedMap.class.equals(mapClass) || NavigableMap.class.equals(mapClass)) {_				return new TreeMap<K, V>()__			}_			else if (MultiValueMap.class.equals(mapClass)) {_				return new LinkedMultiValueMap()__			}_			else {_				throw new IllegalArgumentException("Unsupported Map interface: " + mapClass.getName())__			}_		}_		else if (EnumMap.class.equals(mapClass)) {_			Assert.notNull(keyType, "Cannot create EnumMap for unknown key type")__			return new EnumMap(keyType)__		}_		else {_			if (!Map.class.isAssignableFrom(mapClass)) {_				throw new IllegalArgumentException("Unsupported Map type: " + mapClass.getName())__			}_			try {_				return (Map<K, V>) mapClass.newInstance()__			}_			catch (Exception ex) {_				throw new IllegalArgumentException(_						"Could not instantiate Map type: " + mapClass.getName(), ex)__			}_		}_	};create,the,most,approximate,map,for,the,given,map,param,map,class,the,desired,type,of,the,target,map,param,key,type,the,map,s,key,type,or,code,null,if,not,known,note,only,relevant,for,link,enum,map,creation,param,capacity,the,initial,capacity,return,the,new,map,instance,since,4,1,3,see,java,util,linked,hash,map,see,java,util,tree,map,see,java,util,enum,map,see,org,springframework,util,linked,multi,value,map;suppress,warnings,unchecked,rawtypes,public,static,k,v,map,k,v,create,map,class,map,class,class,key,type,int,capacity,if,map,class,is,interface,if,map,class,equals,map,class,return,new,linked,hash,map,k,v,capacity,else,if,sorted,map,class,equals,map,class,navigable,map,class,equals,map,class,return,new,tree,map,k,v,else,if,multi,value,map,class,equals,map,class,return,new,linked,multi,value,map,else,throw,new,illegal,argument,exception,unsupported,map,interface,map,class,get,name,else,if,enum,map,class,equals,map,class,assert,not,null,key,type,cannot,create,enum,map,for,unknown,key,type,return,new,enum,map,key,type,else,if,map,class,is,assignable,from,map,class,throw,new,illegal,argument,exception,unsupported,map,type,map,class,get,name,try,return,map,k,v,map,class,new,instance,catch,exception,ex,throw,new,illegal,argument,exception,could,not,instantiate,map,type,map,class,get,name,ex
