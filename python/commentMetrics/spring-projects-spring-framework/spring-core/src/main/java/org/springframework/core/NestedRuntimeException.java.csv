commented;modifiers;parameterAmount;loc;comment;code
true;public;0;5;/**  * Return the detail message, including the message from the nested exception  * if there is one.  */ ;/**  * Return the detail message, including the message from the nested exception  * if there is one.  */ @Override @Nullable public String getMessage() {     return NestedExceptionUtils.buildMessage(super.getMessage(), getCause()). }
true;public;0;4;/**  * Retrieve the innermost cause of this exception, if any.  * @return the innermost exception, or {@code null} if none  * @since 2.0  */ ;/**  * Retrieve the innermost cause of this exception, if any.  * @return the innermost exception, or {@code null} if none  * @since 2.0  */ @Nullable public Throwable getRootCause() {     return NestedExceptionUtils.getRootCause(this). }
true;public;0;4;/**  * Retrieve the most specific cause of this exception, that is,  * either the innermost cause (root cause) or this exception itself.  * <p>Differs from {@link #getRootCause()} in that it falls back  * to the present exception if there is no root cause.  * @return the most specific cause (never {@code null})  * @since 2.0.3  */ ;/**  * Retrieve the most specific cause of this exception, that is,  * either the innermost cause (root cause) or this exception itself.  * <p>Differs from {@link #getRootCause()} in that it falls back  * to the present exception if there is no root cause.  * @return the most specific cause (never {@code null})  * @since 2.0.3  */ public Throwable getMostSpecificCause() {     Throwable rootCause = getRootCause().     return (rootCause != null ? rootCause : this). }
true;public;1;27;/**  * Check whether this exception contains an exception of the given type:  * either it is of the given class itself or it contains a nested cause  * of the given type.  * @param exType the exception type to look for  * @return whether there is a nested exception of the specified type  */ ;/**  * Check whether this exception contains an exception of the given type:  * either it is of the given class itself or it contains a nested cause  * of the given type.  * @param exType the exception type to look for  * @return whether there is a nested exception of the specified type  */ public boolean contains(@Nullable Class<?> exType) {     if (exType == null) {         return false.     }     if (exType.isInstance(this)) {         return true.     }     Throwable cause = getCause().     if (cause == this) {         return false.     }     if (cause instanceof NestedRuntimeException) {         return ((NestedRuntimeException) cause).contains(exType).     } else {         while (cause != null) {             if (exType.isInstance(cause)) {                 return true.             }             if (cause.getCause() == cause) {                 break.             }             cause = cause.getCause().         }         return false.     } }
