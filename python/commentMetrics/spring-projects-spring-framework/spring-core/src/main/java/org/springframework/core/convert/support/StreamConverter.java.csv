commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public Set<ConvertiblePair> getConvertibleTypes() {     return CONVERTIBLE_TYPES. }
false;public;2;10;;@Override public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {     if (sourceType.isAssignableTo(STREAM_TYPE)) {         return matchesFromStream(sourceType.getElementTypeDescriptor(), targetType).     }     if (targetType.isAssignableTo(STREAM_TYPE)) {         return matchesToStream(targetType.getElementTypeDescriptor(), sourceType).     }     return false. }
true;public;2;4;/**  * Validate that a {@link Collection} of the elements held within the stream can be  * converted to the specified {@code targetType}.  * @param elementType the type of the stream elements  * @param targetType the type to convert to  */ ;/**  * Validate that a {@link Collection} of the elements held within the stream can be  * converted to the specified {@code targetType}.  * @param elementType the type of the stream elements  * @param targetType the type to convert to  */ public boolean matchesFromStream(@Nullable TypeDescriptor elementType, TypeDescriptor targetType) {     TypeDescriptor collectionOfElement = TypeDescriptor.collection(Collection.class, elementType).     return this.conversionService.canConvert(collectionOfElement, targetType). }
true;public;2;4;/**  * Validate that the specified {@code sourceType} can be converted to a {@link Collection} of  * the type of the stream elements.  * @param elementType the type of the stream elements  * @param sourceType the type to convert from  */ ;/**  * Validate that the specified {@code sourceType} can be converted to a {@link Collection} of  * the type of the stream elements.  * @param elementType the type of the stream elements  * @param sourceType the type to convert from  */ public boolean matchesToStream(@Nullable TypeDescriptor elementType, TypeDescriptor sourceType) {     TypeDescriptor collectionOfElement = TypeDescriptor.collection(Collection.class, elementType).     return this.conversionService.canConvert(sourceType, collectionOfElement). }
false;public;3;12;;@Override @Nullable public Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {     if (sourceType.isAssignableTo(STREAM_TYPE)) {         return convertFromStream((Stream<?>) source, sourceType, targetType).     }     if (targetType.isAssignableTo(STREAM_TYPE)) {         return convertToStream(source, sourceType, targetType).     }     // Should not happen     throw new IllegalStateException("Unexpected source/target types"). }
false;private;3;6;;@Nullable private Object convertFromStream(@Nullable Stream<?> source, TypeDescriptor streamType, TypeDescriptor targetType) {     List<Object> content = (source != null ? source.collect(Collectors.<Object>toList()) : Collections.emptyList()).     TypeDescriptor listType = TypeDescriptor.collection(List.class, streamType.getElementTypeDescriptor()).     return this.conversionService.convert(content, listType, targetType). }
false;private;3;8;;private Object convertToStream(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor streamType) {     TypeDescriptor targetCollection = TypeDescriptor.collection(List.class, streamType.getElementTypeDescriptor()).     List<?> target = (List<?>) this.conversionService.convert(source, sourceType, targetCollection).     if (target == null) {         target = Collections.emptyList().     }     return target.stream(). }
false;private,static;0;8;;private static Set<ConvertiblePair> createConvertibleTypes() {     Set<ConvertiblePair> convertiblePairs = new HashSet<>().     convertiblePairs.add(new ConvertiblePair(Stream.class, Collection.class)).     convertiblePairs.add(new ConvertiblePair(Stream.class, Object[].class)).     convertiblePairs.add(new ConvertiblePair(Collection.class, Stream.class)).     convertiblePairs.add(new ConvertiblePair(Object[].class, Stream.class)).     return convertiblePairs. }
