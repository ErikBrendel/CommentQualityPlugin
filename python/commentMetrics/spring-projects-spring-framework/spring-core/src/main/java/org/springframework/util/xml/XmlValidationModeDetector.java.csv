commented;modifiers;parameterAmount;loc;comment;code
true;public;1;31;/**  * Detect the validation mode for the XML document in the supplied {@link InputStream}.  * Note that the supplied {@link InputStream} is closed by this method before returning.  * @param inputStream the InputStream to parse  * @throws IOException in case of I/O failure  * @see #VALIDATION_DTD  * @see #VALIDATION_XSD  */ ;/**  * Detect the validation mode for the XML document in the supplied {@link InputStream}.  * Note that the supplied {@link InputStream} is closed by this method before returning.  * @param inputStream the InputStream to parse  * @throws IOException in case of I/O failure  * @see #VALIDATION_DTD  * @see #VALIDATION_XSD  */ public int detectValidationMode(InputStream inputStream) throws IOException {     // Peek into the file to look for DOCTYPE.     BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)).     try {         boolean isDtdValidated = false.         String content.         while ((content = reader.readLine()) != null) {             content = consumeCommentTokens(content).             if (this.inComment || !StringUtils.hasText(content)) {                 continue.             }             if (hasDoctype(content)) {                 isDtdValidated = true.                 break.             }             if (hasOpeningTag(content)) {                 // End of meaningful data...                 break.             }         }         return (isDtdValidated ? VALIDATION_DTD : VALIDATION_XSD).     } catch (CharConversionException ex) {         // Leave the decision up to the caller.         return VALIDATION_AUTO.     } finally {         reader.close().     } }
true;private;1;3;/**  * Does the content contain the DTD DOCTYPE declaration?  */ ;/**  * Does the content contain the DTD DOCTYPE declaration?  */ private boolean hasDoctype(String content) {     return content.contains(DOCTYPE). }
true;private;1;8;/**  * Does the supplied content contain an XML opening tag. If the parse state is currently  * in an XML comment then this method always returns false. It is expected that all comment  * tokens will have consumed for the supplied content before passing the remainder to this method.  */ ;/**  * Does the supplied content contain an XML opening tag. If the parse state is currently  * in an XML comment then this method always returns false. It is expected that all comment  * tokens will have consumed for the supplied content before passing the remainder to this method.  */ private boolean hasOpeningTag(String content) {     if (this.inComment) {         return false.     }     int openTagIndex = content.indexOf('<').     return (openTagIndex > -1 && (content.length() > openTagIndex + 1) && Character.isLetter(content.charAt(openTagIndex + 1))). }
true;private;1;13;/**  * Consumes all the leading comment data in the given String and returns the remaining content, which  * may be empty since the supplied content might be all comment data. For our purposes it is only important  * to strip leading comment content on a line since the first piece of non comment content will be either  * the DOCTYPE declaration or the root element of the document.  */ ;/**  * Consumes all the leading comment data in the given String and returns the remaining content, which  * may be empty since the supplied content might be all comment data. For our purposes it is only important  * to strip leading comment content on a line since the first piece of non comment content will be either  * the DOCTYPE declaration or the root element of the document.  */ @Nullable private String consumeCommentTokens(String line) {     if (!line.contains(START_COMMENT) && !line.contains(END_COMMENT)) {         return line.     }     String currLine = line.     while ((currLine = consume(currLine)) != null) {         if (!this.inComment && !currLine.trim().startsWith(START_COMMENT)) {             return currLine.         }     }     return null. }
true;private;1;5;/**  * Consume the next comment token, update the "inComment" flag  * and return the remaining content.  */ ;/**  * Consume the next comment token, update the "inComment" flag  * and return the remaining content.  */ @Nullable private String consume(String line) {     int index = (this.inComment ? endComment(line) : startComment(line)).     return (index == -1 ? null : line.substring(index)). }
true;private;1;3;/**  * Try to consume the {@link #START_COMMENT} token.  * @see #commentToken(String, String, boolean)  */ ;/**  * Try to consume the {@link #START_COMMENT} token.  * @see #commentToken(String, String, boolean)  */ private int startComment(String line) {     return commentToken(line, START_COMMENT, true). }
false;private;1;3;;private int endComment(String line) {     return commentToken(line, END_COMMENT, false). }
true;private;3;7;/**  * Try to consume the supplied token against the supplied content and update the  * in comment parse state to the supplied value. Returns the index into the content  * which is after the token or -1 if the token is not found.  */ ;/**  * Try to consume the supplied token against the supplied content and update the  * in comment parse state to the supplied value. Returns the index into the content  * which is after the token or -1 if the token is not found.  */ private int commentToken(String line, String token, boolean inCommentIfPresent) {     int index = line.indexOf(token).     if (index > -1) {         this.inComment = inCommentIfPresent.     }     return (index == -1 ? index : index + token.length()). }
