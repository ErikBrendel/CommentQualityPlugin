# id;timestamp;commentText;codeText;commentWords;codeWords
MapAnnotationAttributeExtractor -> @SuppressWarnings("unchecked") 	private static Map<String, Object> enrichAndValidateAttributes( 			Map<String, Object> originalAttributes, Class<? extends Annotation> annotationType);1439211354;Enrich and validate the supplied <em>attributes</em> map by ensuring_that it contains a non-null entry for each annotation attribute in_the specified {@code annotationType} and that the type of the entry_matches the return type for the corresponding annotation attribute._<p>If an entry is a map (presumably of annotation attributes), an_attempt will be made to synthesize an annotation from it. Similarly,_if an entry is an array of maps, an attempt will be made to synthesize_an array of annotations from those maps._<p>If an attribute is missing in the supplied map, it will be set_either to the value of its alias (if an alias exists) or to the_value of the attribute's default value (if defined), and otherwise_an {@link IllegalArgumentException} will be thrown.;@SuppressWarnings("unchecked")_	private static Map<String, Object> enrichAndValidateAttributes(_			Map<String, Object> originalAttributes, Class<? extends Annotation> annotationType) {__		Map<String, Object> attributes = new HashMap<String, Object>(originalAttributes)__		Map<String, String> attributeAliasMap = getAttributeAliasMap(annotationType)___		for (Method attributeMethod : getAttributeMethods(annotationType)) {_			String attributeName = attributeMethod.getName()__			Object attributeValue = attributes.get(attributeName)___			_			if (attributeValue == null) {_				String aliasName = attributeAliasMap.get(attributeName)__				if (aliasName != null) {_					Object aliasValue = attributes.get(aliasName)__					if (aliasValue != null) {_						attributeValue = aliasValue__						attributes.put(attributeName, attributeValue)__					}_				}_			}__			_			if (attributeValue == null) {_				Object defaultValue = getDefaultValue(annotationType, attributeName)__				if (defaultValue != null) {_					attributeValue = defaultValue__					attributes.put(attributeName, attributeValue)__				}_			}__			_			if (attributeValue == null) {_				throw new IllegalArgumentException(String.format(_					"Attributes map [%s] returned null for required attribute [%s] defined by annotation type [%s].",_					attributes, attributeName, annotationType.getName()))__			}__			_			Class<?> requiredReturnType = attributeMethod.getReturnType()__			Class<? extends Object> actualReturnType = attributeValue.getClass()__			if (!ClassUtils.isAssignable(requiredReturnType, actualReturnType)) {_				boolean converted = false___				_				if (Annotation.class.isAssignableFrom(requiredReturnType)_						&& Map.class.isAssignableFrom(actualReturnType)) {__					Class<? extends Annotation> nestedAnnotationType = (Class<? extends Annotation>) requiredReturnType__					Map<String, Object> map = (Map<String, Object>) attributeValue__					attributes.put(attributeName, synthesizeAnnotation(map, nestedAnnotationType, null))__					converted = true__				}__				_				else if (requiredReturnType.isArray()_						&& Annotation.class.isAssignableFrom(requiredReturnType.getComponentType())_						&& actualReturnType.isArray()_						&& Map.class.isAssignableFrom(actualReturnType.getComponentType())) {__					Class<? extends Annotation> nestedAnnotationType = (Class<? extends Annotation>) requiredReturnType.getComponentType()__					Map<String, Object>[] maps = (Map<String, Object>[]) attributeValue__					attributes.put(attributeName, synthesizeAnnotationArray(maps, nestedAnnotationType))__					converted = true__				}__				if (!converted) {_					throw new IllegalArgumentException(String.format(_							"Attributes map [%s] returned a value of type [%s] for attribute [%s], "_							+ "but a value of type [%s] is required as defined by annotation type [%s].",_							attributes, actualReturnType.getName(), attributeName, requiredReturnType.getName(),_							annotationType.getName()))__				}_			}_		}__		return attributes__	};enrich,and,validate,the,supplied,em,attributes,em,map,by,ensuring,that,it,contains,a,non,null,entry,for,each,annotation,attribute,in,the,specified,code,annotation,type,and,that,the,type,of,the,entry,matches,the,return,type,for,the,corresponding,annotation,attribute,p,if,an,entry,is,a,map,presumably,of,annotation,attributes,an,attempt,will,be,made,to,synthesize,an,annotation,from,it,similarly,if,an,entry,is,an,array,of,maps,an,attempt,will,be,made,to,synthesize,an,array,of,annotations,from,those,maps,p,if,an,attribute,is,missing,in,the,supplied,map,it,will,be,set,either,to,the,value,of,its,alias,if,an,alias,exists,or,to,the,value,of,the,attribute,s,default,value,if,defined,and,otherwise,an,link,illegal,argument,exception,will,be,thrown;suppress,warnings,unchecked,private,static,map,string,object,enrich,and,validate,attributes,map,string,object,original,attributes,class,extends,annotation,annotation,type,map,string,object,attributes,new,hash,map,string,object,original,attributes,map,string,string,attribute,alias,map,get,attribute,alias,map,annotation,type,for,method,attribute,method,get,attribute,methods,annotation,type,string,attribute,name,attribute,method,get,name,object,attribute,value,attributes,get,attribute,name,if,attribute,value,null,string,alias,name,attribute,alias,map,get,attribute,name,if,alias,name,null,object,alias,value,attributes,get,alias,name,if,alias,value,null,attribute,value,alias,value,attributes,put,attribute,name,attribute,value,if,attribute,value,null,object,default,value,get,default,value,annotation,type,attribute,name,if,default,value,null,attribute,value,default,value,attributes,put,attribute,name,attribute,value,if,attribute,value,null,throw,new,illegal,argument,exception,string,format,attributes,map,s,returned,null,for,required,attribute,s,defined,by,annotation,type,s,attributes,attribute,name,annotation,type,get,name,class,required,return,type,attribute,method,get,return,type,class,extends,object,actual,return,type,attribute,value,get,class,if,class,utils,is,assignable,required,return,type,actual,return,type,boolean,converted,false,if,annotation,class,is,assignable,from,required,return,type,map,class,is,assignable,from,actual,return,type,class,extends,annotation,nested,annotation,type,class,extends,annotation,required,return,type,map,string,object,map,map,string,object,attribute,value,attributes,put,attribute,name,synthesize,annotation,map,nested,annotation,type,null,converted,true,else,if,required,return,type,is,array,annotation,class,is,assignable,from,required,return,type,get,component,type,actual,return,type,is,array,map,class,is,assignable,from,actual,return,type,get,component,type,class,extends,annotation,nested,annotation,type,class,extends,annotation,required,return,type,get,component,type,map,string,object,maps,map,string,object,attribute,value,attributes,put,attribute,name,synthesize,annotation,array,maps,nested,annotation,type,converted,true,if,converted,throw,new,illegal,argument,exception,string,format,attributes,map,s,returned,a,value,of,type,s,for,attribute,s,but,a,value,of,type,s,is,required,as,defined,by,annotation,type,s,attributes,actual,return,type,get,name,attribute,name,required,return,type,get,name,annotation,type,get,name,return,attributes
MapAnnotationAttributeExtractor -> @SuppressWarnings("unchecked") 	private static Map<String, Object> enrichAndValidateAttributes( 			Map<String, Object> originalAttributes, Class<? extends Annotation> annotationType);1439214025;Enrich and validate the supplied <em>attributes</em> map by ensuring_that it contains a non-null entry for each annotation attribute in_the specified {@code annotationType} and that the type of the entry_matches the return type for the corresponding annotation attribute._<p>If an entry is a map (presumably of annotation attributes), an_attempt will be made to synthesize an annotation from it. Similarly,_if an entry is an array of maps, an attempt will be made to synthesize_an array of annotations from those maps._<p>If an attribute is missing in the supplied map, it will be set_either to the value of its alias (if an alias exists) or to the_value of the attribute's default value (if defined), and otherwise_an {@link IllegalArgumentException} will be thrown.;@SuppressWarnings("unchecked")_	private static Map<String, Object> enrichAndValidateAttributes(_			Map<String, Object> originalAttributes, Class<? extends Annotation> annotationType) {__		Map<String, Object> attributes = new HashMap<String, Object>(originalAttributes)__		Map<String, String> attributeAliasMap = getAttributeAliasMap(annotationType)___		for (Method attributeMethod : getAttributeMethods(annotationType)) {_			String attributeName = attributeMethod.getName()__			Object attributeValue = attributes.get(attributeName)___			_			if (attributeValue == null) {_				String aliasName = attributeAliasMap.get(attributeName)__				if (aliasName != null) {_					Object aliasValue = attributes.get(aliasName)__					if (aliasValue != null) {_						attributeValue = aliasValue__						attributes.put(attributeName, attributeValue)__					}_				}_			}__			_			if (attributeValue == null) {_				Object defaultValue = getDefaultValue(annotationType, attributeName)__				if (defaultValue != null) {_					attributeValue = defaultValue__					attributes.put(attributeName, attributeValue)__				}_			}__			_			if (attributeValue == null) {_				throw new IllegalArgumentException(String.format(_					"Attributes map [%s] returned null for required attribute [%s] defined by annotation type [%s].",_					attributes, attributeName, annotationType.getName()))__			}__			_			Class<?> requiredReturnType = attributeMethod.getReturnType()__			Class<? extends Object> actualReturnType = attributeValue.getClass()__			if (!ClassUtils.isAssignable(requiredReturnType, actualReturnType)) {_				boolean converted = false___				_				if (Annotation.class.isAssignableFrom(requiredReturnType)_						&& Map.class.isAssignableFrom(actualReturnType)) {__					Class<? extends Annotation> nestedAnnotationType = (Class<? extends Annotation>) requiredReturnType__					Map<String, Object> map = (Map<String, Object>) attributeValue__					attributes.put(attributeName, synthesizeAnnotation(map, nestedAnnotationType, null))__					converted = true__				}__				_				else if (requiredReturnType.isArray()_						&& Annotation.class.isAssignableFrom(requiredReturnType.getComponentType())_						&& actualReturnType.isArray()_						&& Map.class.isAssignableFrom(actualReturnType.getComponentType())) {__					Class<? extends Annotation> nestedAnnotationType = (Class<? extends Annotation>) requiredReturnType.getComponentType()__					Map<String, Object>[] maps = (Map<String, Object>[]) attributeValue__					attributes.put(attributeName, synthesizeAnnotationArray(maps, nestedAnnotationType))__					converted = true__				}__				if (!converted) {_					throw new IllegalArgumentException(String.format(_							"Attributes map [%s] returned a value of type [%s] for attribute [%s], "_							+ "but a value of type [%s] is required as defined by annotation type [%s].",_							attributes, actualReturnType.getName(), attributeName, requiredReturnType.getName(),_							annotationType.getName()))__				}_			}_		}__		return attributes__	};enrich,and,validate,the,supplied,em,attributes,em,map,by,ensuring,that,it,contains,a,non,null,entry,for,each,annotation,attribute,in,the,specified,code,annotation,type,and,that,the,type,of,the,entry,matches,the,return,type,for,the,corresponding,annotation,attribute,p,if,an,entry,is,a,map,presumably,of,annotation,attributes,an,attempt,will,be,made,to,synthesize,an,annotation,from,it,similarly,if,an,entry,is,an,array,of,maps,an,attempt,will,be,made,to,synthesize,an,array,of,annotations,from,those,maps,p,if,an,attribute,is,missing,in,the,supplied,map,it,will,be,set,either,to,the,value,of,its,alias,if,an,alias,exists,or,to,the,value,of,the,attribute,s,default,value,if,defined,and,otherwise,an,link,illegal,argument,exception,will,be,thrown;suppress,warnings,unchecked,private,static,map,string,object,enrich,and,validate,attributes,map,string,object,original,attributes,class,extends,annotation,annotation,type,map,string,object,attributes,new,hash,map,string,object,original,attributes,map,string,string,attribute,alias,map,get,attribute,alias,map,annotation,type,for,method,attribute,method,get,attribute,methods,annotation,type,string,attribute,name,attribute,method,get,name,object,attribute,value,attributes,get,attribute,name,if,attribute,value,null,string,alias,name,attribute,alias,map,get,attribute,name,if,alias,name,null,object,alias,value,attributes,get,alias,name,if,alias,value,null,attribute,value,alias,value,attributes,put,attribute,name,attribute,value,if,attribute,value,null,object,default,value,get,default,value,annotation,type,attribute,name,if,default,value,null,attribute,value,default,value,attributes,put,attribute,name,attribute,value,if,attribute,value,null,throw,new,illegal,argument,exception,string,format,attributes,map,s,returned,null,for,required,attribute,s,defined,by,annotation,type,s,attributes,attribute,name,annotation,type,get,name,class,required,return,type,attribute,method,get,return,type,class,extends,object,actual,return,type,attribute,value,get,class,if,class,utils,is,assignable,required,return,type,actual,return,type,boolean,converted,false,if,annotation,class,is,assignable,from,required,return,type,map,class,is,assignable,from,actual,return,type,class,extends,annotation,nested,annotation,type,class,extends,annotation,required,return,type,map,string,object,map,map,string,object,attribute,value,attributes,put,attribute,name,synthesize,annotation,map,nested,annotation,type,null,converted,true,else,if,required,return,type,is,array,annotation,class,is,assignable,from,required,return,type,get,component,type,actual,return,type,is,array,map,class,is,assignable,from,actual,return,type,get,component,type,class,extends,annotation,nested,annotation,type,class,extends,annotation,required,return,type,get,component,type,map,string,object,maps,map,string,object,attribute,value,attributes,put,attribute,name,synthesize,annotation,array,maps,nested,annotation,type,converted,true,if,converted,throw,new,illegal,argument,exception,string,format,attributes,map,s,returned,a,value,of,type,s,for,attribute,s,but,a,value,of,type,s,is,required,as,defined,by,annotation,type,s,attributes,actual,return,type,get,name,attribute,name,required,return,type,get,name,annotation,type,get,name,return,attributes
MapAnnotationAttributeExtractor -> @SuppressWarnings("unchecked") 	private static Map<String, Object> enrichAndValidateAttributes( 			Map<String, Object> originalAttributes, Class<? extends Annotation> annotationType);1440781118;Enrich and validate the supplied <em>attributes</em> map by ensuring_that it contains a non-null entry for each annotation attribute in_the specified {@code annotationType} and that the type of the entry_matches the return type for the corresponding annotation attribute._<p>If an entry is a map (presumably of annotation attributes), an_attempt will be made to synthesize an annotation from it. Similarly,_if an entry is an array of maps, an attempt will be made to synthesize_an array of annotations from those maps._<p>If an attribute is missing in the supplied map, it will be set_either to the value of its alias (if an alias exists) or to the_value of the attribute's default value (if defined), and otherwise_an {@link IllegalArgumentException} will be thrown.;@SuppressWarnings("unchecked")_	private static Map<String, Object> enrichAndValidateAttributes(_			Map<String, Object> originalAttributes, Class<? extends Annotation> annotationType) {__		Map<String, Object> attributes = new HashMap<String, Object>(originalAttributes)__		Map<String, List<String>> attributeAliasMap = getAttributeAliasMap(annotationType)___		for (Method attributeMethod : getAttributeMethods(annotationType)) {_			String attributeName = attributeMethod.getName()__			Object attributeValue = attributes.get(attributeName)___			_			if (attributeValue == null) {_				List<String> aliasNames = attributeAliasMap.get(attributeName)__				if (aliasNames != null) {_					for (String aliasName : aliasNames) {_						if (aliasName != null) {_							Object aliasValue = attributes.get(aliasName)__							if (aliasValue != null) {_								attributeValue = aliasValue__								attributes.put(attributeName, attributeValue)__								break__							}_						}_					}_				}_			}__			_			if (attributeValue == null) {_				Object defaultValue = getDefaultValue(annotationType, attributeName)__				if (defaultValue != null) {_					attributeValue = defaultValue__					attributes.put(attributeName, attributeValue)__				}_			}__			_			if (attributeValue == null) {_				throw new IllegalArgumentException(String.format(_					"Attributes map [%s] returned null for required attribute [%s] defined by annotation type [%s].",_					attributes, attributeName, annotationType.getName()))__			}__			_			Class<?> requiredReturnType = attributeMethod.getReturnType()__			Class<? extends Object> actualReturnType = attributeValue.getClass()__			if (!ClassUtils.isAssignable(requiredReturnType, actualReturnType)) {_				boolean converted = false___				_				if (Annotation.class.isAssignableFrom(requiredReturnType)_						&& Map.class.isAssignableFrom(actualReturnType)) {__					Class<? extends Annotation> nestedAnnotationType = (Class<? extends Annotation>) requiredReturnType__					Map<String, Object> map = (Map<String, Object>) attributeValue__					attributes.put(attributeName, synthesizeAnnotation(map, nestedAnnotationType, null))__					converted = true__				}__				_				else if (requiredReturnType.isArray()_						&& Annotation.class.isAssignableFrom(requiredReturnType.getComponentType())_						&& actualReturnType.isArray()_						&& Map.class.isAssignableFrom(actualReturnType.getComponentType())) {__					Class<? extends Annotation> nestedAnnotationType = (Class<? extends Annotation>) requiredReturnType.getComponentType()__					Map<String, Object>[] maps = (Map<String, Object>[]) attributeValue__					attributes.put(attributeName, synthesizeAnnotationArray(maps, nestedAnnotationType))__					converted = true__				}__				if (!converted) {_					throw new IllegalArgumentException(String.format(_							"Attributes map [%s] returned a value of type [%s] for attribute [%s], "_							+ "but a value of type [%s] is required as defined by annotation type [%s].",_							attributes, actualReturnType.getName(), attributeName, requiredReturnType.getName(),_							annotationType.getName()))__				}_			}_		}__		return attributes__	};enrich,and,validate,the,supplied,em,attributes,em,map,by,ensuring,that,it,contains,a,non,null,entry,for,each,annotation,attribute,in,the,specified,code,annotation,type,and,that,the,type,of,the,entry,matches,the,return,type,for,the,corresponding,annotation,attribute,p,if,an,entry,is,a,map,presumably,of,annotation,attributes,an,attempt,will,be,made,to,synthesize,an,annotation,from,it,similarly,if,an,entry,is,an,array,of,maps,an,attempt,will,be,made,to,synthesize,an,array,of,annotations,from,those,maps,p,if,an,attribute,is,missing,in,the,supplied,map,it,will,be,set,either,to,the,value,of,its,alias,if,an,alias,exists,or,to,the,value,of,the,attribute,s,default,value,if,defined,and,otherwise,an,link,illegal,argument,exception,will,be,thrown;suppress,warnings,unchecked,private,static,map,string,object,enrich,and,validate,attributes,map,string,object,original,attributes,class,extends,annotation,annotation,type,map,string,object,attributes,new,hash,map,string,object,original,attributes,map,string,list,string,attribute,alias,map,get,attribute,alias,map,annotation,type,for,method,attribute,method,get,attribute,methods,annotation,type,string,attribute,name,attribute,method,get,name,object,attribute,value,attributes,get,attribute,name,if,attribute,value,null,list,string,alias,names,attribute,alias,map,get,attribute,name,if,alias,names,null,for,string,alias,name,alias,names,if,alias,name,null,object,alias,value,attributes,get,alias,name,if,alias,value,null,attribute,value,alias,value,attributes,put,attribute,name,attribute,value,break,if,attribute,value,null,object,default,value,get,default,value,annotation,type,attribute,name,if,default,value,null,attribute,value,default,value,attributes,put,attribute,name,attribute,value,if,attribute,value,null,throw,new,illegal,argument,exception,string,format,attributes,map,s,returned,null,for,required,attribute,s,defined,by,annotation,type,s,attributes,attribute,name,annotation,type,get,name,class,required,return,type,attribute,method,get,return,type,class,extends,object,actual,return,type,attribute,value,get,class,if,class,utils,is,assignable,required,return,type,actual,return,type,boolean,converted,false,if,annotation,class,is,assignable,from,required,return,type,map,class,is,assignable,from,actual,return,type,class,extends,annotation,nested,annotation,type,class,extends,annotation,required,return,type,map,string,object,map,map,string,object,attribute,value,attributes,put,attribute,name,synthesize,annotation,map,nested,annotation,type,null,converted,true,else,if,required,return,type,is,array,annotation,class,is,assignable,from,required,return,type,get,component,type,actual,return,type,is,array,map,class,is,assignable,from,actual,return,type,get,component,type,class,extends,annotation,nested,annotation,type,class,extends,annotation,required,return,type,get,component,type,map,string,object,maps,map,string,object,attribute,value,attributes,put,attribute,name,synthesize,annotation,array,maps,nested,annotation,type,converted,true,if,converted,throw,new,illegal,argument,exception,string,format,attributes,map,s,returned,a,value,of,type,s,for,attribute,s,but,a,value,of,type,s,is,required,as,defined,by,annotation,type,s,attributes,actual,return,type,get,name,attribute,name,required,return,type,get,name,annotation,type,get,name,return,attributes
MapAnnotationAttributeExtractor -> @SuppressWarnings("unchecked") 	private static Map<String, Object> enrichAndValidateAttributes( 			Map<String, Object> originalAttributes, Class<? extends Annotation> annotationType);1440857126;Enrich and validate the supplied <em>attributes</em> map by ensuring_that it contains a non-null entry for each annotation attribute in_the specified {@code annotationType} and that the type of the entry_matches the return type for the corresponding annotation attribute._<p>If an entry is a map (presumably of annotation attributes), an_attempt will be made to synthesize an annotation from it. Similarly,_if an entry is an array of maps, an attempt will be made to synthesize_an array of annotations from those maps._<p>If an attribute is missing in the supplied map, it will be set_either to the value of its alias (if an alias exists) or to the_value of the attribute's default value (if defined), and otherwise_an {@link IllegalArgumentException} will be thrown.;@SuppressWarnings("unchecked")_	private static Map<String, Object> enrichAndValidateAttributes(_			Map<String, Object> originalAttributes, Class<? extends Annotation> annotationType) {__		Map<String, Object> attributes = new HashMap<String, Object>(originalAttributes)__		Map<String, List<String>> attributeAliasMap = getAttributeAliasMap(annotationType)___		for (Method attributeMethod : getAttributeMethods(annotationType)) {_			String attributeName = attributeMethod.getName()__			Object attributeValue = attributes.get(attributeName)___			_			if (attributeValue == null) {_				List<String> aliasNames = attributeAliasMap.get(attributeName)__				if (aliasNames != null) {_					for (String aliasName : aliasNames) {_						Object aliasValue = attributes.get(aliasName)__						if (aliasValue != null) {_							attributeValue = aliasValue__							attributes.put(attributeName, attributeValue)__							break__						}_					}_				}_			}__			_			if (attributeValue == null) {_				Object defaultValue = getDefaultValue(annotationType, attributeName)__				if (defaultValue != null) {_					attributeValue = defaultValue__					attributes.put(attributeName, attributeValue)__				}_			}__			_			if (attributeValue == null) {_				throw new IllegalArgumentException(String.format(_					"Attributes map [%s] returned null for required attribute [%s] defined by annotation type [%s].",_					attributes, attributeName, annotationType.getName()))__			}__			_			Class<?> requiredReturnType = attributeMethod.getReturnType()__			Class<? extends Object> actualReturnType = attributeValue.getClass()__			if (!ClassUtils.isAssignable(requiredReturnType, actualReturnType)) {_				boolean converted = false___				_				if (Annotation.class.isAssignableFrom(requiredReturnType)_						&& Map.class.isAssignableFrom(actualReturnType)) {__					Class<? extends Annotation> nestedAnnotationType = (Class<? extends Annotation>) requiredReturnType__					Map<String, Object> map = (Map<String, Object>) attributeValue__					attributes.put(attributeName, synthesizeAnnotation(map, nestedAnnotationType, null))__					converted = true__				}__				_				else if (requiredReturnType.isArray()_						&& Annotation.class.isAssignableFrom(requiredReturnType.getComponentType())_						&& actualReturnType.isArray()_						&& Map.class.isAssignableFrom(actualReturnType.getComponentType())) {__					Class<? extends Annotation> nestedAnnotationType = (Class<? extends Annotation>) requiredReturnType.getComponentType()__					Map<String, Object>[] maps = (Map<String, Object>[]) attributeValue__					attributes.put(attributeName, synthesizeAnnotationArray(maps, nestedAnnotationType))__					converted = true__				}__				if (!converted) {_					throw new IllegalArgumentException(String.format(_							"Attributes map [%s] returned a value of type [%s] for attribute [%s], "_							+ "but a value of type [%s] is required as defined by annotation type [%s].",_							attributes, actualReturnType.getName(), attributeName, requiredReturnType.getName(),_							annotationType.getName()))__				}_			}_		}__		return attributes__	};enrich,and,validate,the,supplied,em,attributes,em,map,by,ensuring,that,it,contains,a,non,null,entry,for,each,annotation,attribute,in,the,specified,code,annotation,type,and,that,the,type,of,the,entry,matches,the,return,type,for,the,corresponding,annotation,attribute,p,if,an,entry,is,a,map,presumably,of,annotation,attributes,an,attempt,will,be,made,to,synthesize,an,annotation,from,it,similarly,if,an,entry,is,an,array,of,maps,an,attempt,will,be,made,to,synthesize,an,array,of,annotations,from,those,maps,p,if,an,attribute,is,missing,in,the,supplied,map,it,will,be,set,either,to,the,value,of,its,alias,if,an,alias,exists,or,to,the,value,of,the,attribute,s,default,value,if,defined,and,otherwise,an,link,illegal,argument,exception,will,be,thrown;suppress,warnings,unchecked,private,static,map,string,object,enrich,and,validate,attributes,map,string,object,original,attributes,class,extends,annotation,annotation,type,map,string,object,attributes,new,hash,map,string,object,original,attributes,map,string,list,string,attribute,alias,map,get,attribute,alias,map,annotation,type,for,method,attribute,method,get,attribute,methods,annotation,type,string,attribute,name,attribute,method,get,name,object,attribute,value,attributes,get,attribute,name,if,attribute,value,null,list,string,alias,names,attribute,alias,map,get,attribute,name,if,alias,names,null,for,string,alias,name,alias,names,object,alias,value,attributes,get,alias,name,if,alias,value,null,attribute,value,alias,value,attributes,put,attribute,name,attribute,value,break,if,attribute,value,null,object,default,value,get,default,value,annotation,type,attribute,name,if,default,value,null,attribute,value,default,value,attributes,put,attribute,name,attribute,value,if,attribute,value,null,throw,new,illegal,argument,exception,string,format,attributes,map,s,returned,null,for,required,attribute,s,defined,by,annotation,type,s,attributes,attribute,name,annotation,type,get,name,class,required,return,type,attribute,method,get,return,type,class,extends,object,actual,return,type,attribute,value,get,class,if,class,utils,is,assignable,required,return,type,actual,return,type,boolean,converted,false,if,annotation,class,is,assignable,from,required,return,type,map,class,is,assignable,from,actual,return,type,class,extends,annotation,nested,annotation,type,class,extends,annotation,required,return,type,map,string,object,map,map,string,object,attribute,value,attributes,put,attribute,name,synthesize,annotation,map,nested,annotation,type,null,converted,true,else,if,required,return,type,is,array,annotation,class,is,assignable,from,required,return,type,get,component,type,actual,return,type,is,array,map,class,is,assignable,from,actual,return,type,get,component,type,class,extends,annotation,nested,annotation,type,class,extends,annotation,required,return,type,get,component,type,map,string,object,maps,map,string,object,attribute,value,attributes,put,attribute,name,synthesize,annotation,array,maps,nested,annotation,type,converted,true,if,converted,throw,new,illegal,argument,exception,string,format,attributes,map,s,returned,a,value,of,type,s,for,attribute,s,but,a,value,of,type,s,is,required,as,defined,by,annotation,type,s,attributes,actual,return,type,get,name,attribute,name,required,return,type,get,name,annotation,type,get,name,return,attributes
MapAnnotationAttributeExtractor -> @SuppressWarnings("unchecked") 	private static Map<String, Object> enrichAndValidateAttributes( 			Map<String, Object> originalAttributes, Class<? extends Annotation> annotationType);1446737720;Enrich and validate the supplied <em>attributes</em> map by ensuring_that it contains a non-null entry for each annotation attribute in_the specified {@code annotationType} and that the type of the entry_matches the return type for the corresponding annotation attribute._<p>If an entry is a map (presumably of annotation attributes), an_attempt will be made to synthesize an annotation from it. Similarly,_if an entry is an array of maps, an attempt will be made to synthesize_an array of annotations from those maps._<p>If an attribute is missing in the supplied map, it will be set_either to the value of its alias (if an alias exists) or to the_value of the attribute's default value (if defined), and otherwise_an {@link IllegalArgumentException} will be thrown.;@SuppressWarnings("unchecked")_	private static Map<String, Object> enrichAndValidateAttributes(_			Map<String, Object> originalAttributes, Class<? extends Annotation> annotationType) {__		Map<String, Object> attributes = new HashMap<String, Object>(originalAttributes)__		Map<String, List<String>> attributeAliasMap = getAttributeAliasMap(annotationType)___		for (Method attributeMethod : getAttributeMethods(annotationType)) {_			String attributeName = attributeMethod.getName()__			Object attributeValue = attributes.get(attributeName)___			_			if (attributeValue == null) {_				List<String> aliasNames = attributeAliasMap.get(attributeName)__				if (aliasNames != null) {_					for (String aliasName : aliasNames) {_						Object aliasValue = attributes.get(aliasName)__						if (aliasValue != null) {_							attributeValue = aliasValue__							attributes.put(attributeName, attributeValue)__							break__						}_					}_				}_			}__			_			if (attributeValue == null) {_				Object defaultValue = getDefaultValue(annotationType, attributeName)__				if (defaultValue != null) {_					attributeValue = defaultValue__					attributes.put(attributeName, attributeValue)__				}_			}__			_			if (attributeValue == null) {_				throw new IllegalArgumentException(String.format(_						"Attributes map [%s] returned null for required attribute [%s] defined by annotation type [%s].",_						attributes, attributeName, annotationType.getName()))__			}__			_			Class<?> requiredReturnType = attributeMethod.getReturnType()__			Class<? extends Object> actualReturnType = attributeValue.getClass()___			if (!ClassUtils.isAssignable(requiredReturnType, actualReturnType)) {_				boolean converted = false___				_				if (Annotation.class.isAssignableFrom(requiredReturnType) &&_						Map.class.isAssignableFrom(actualReturnType)) {_					Class<? extends Annotation> nestedAnnotationType =_							(Class<? extends Annotation>) requiredReturnType__					Map<String, Object> map = (Map<String, Object>) attributeValue__					attributes.put(attributeName, synthesizeAnnotation(map, nestedAnnotationType, null))__					converted = true__				}__				_				else if (requiredReturnType.isArray() && actualReturnType.isArray() &&_						Annotation.class.isAssignableFrom(requiredReturnType.getComponentType()) &&_						Map.class.isAssignableFrom(actualReturnType.getComponentType())) {_					Class<? extends Annotation> nestedAnnotationType =_							(Class<? extends Annotation>) requiredReturnType.getComponentType()__					Map<String, Object>[] maps = (Map<String, Object>[]) attributeValue__					attributes.put(attributeName, synthesizeAnnotationArray(maps, nestedAnnotationType))__					converted = true__				}__				if (!converted) {_					throw new IllegalArgumentException(String.format(_							"Attributes map [%s] returned a value of type [%s] for attribute [%s], "_							+ "but a value of type [%s] is required as defined by annotation type [%s].",_							attributes, actualReturnType.getName(), attributeName, requiredReturnType.getName(),_							annotationType.getName()))__				}_			}_		}__		return attributes__	};enrich,and,validate,the,supplied,em,attributes,em,map,by,ensuring,that,it,contains,a,non,null,entry,for,each,annotation,attribute,in,the,specified,code,annotation,type,and,that,the,type,of,the,entry,matches,the,return,type,for,the,corresponding,annotation,attribute,p,if,an,entry,is,a,map,presumably,of,annotation,attributes,an,attempt,will,be,made,to,synthesize,an,annotation,from,it,similarly,if,an,entry,is,an,array,of,maps,an,attempt,will,be,made,to,synthesize,an,array,of,annotations,from,those,maps,p,if,an,attribute,is,missing,in,the,supplied,map,it,will,be,set,either,to,the,value,of,its,alias,if,an,alias,exists,or,to,the,value,of,the,attribute,s,default,value,if,defined,and,otherwise,an,link,illegal,argument,exception,will,be,thrown;suppress,warnings,unchecked,private,static,map,string,object,enrich,and,validate,attributes,map,string,object,original,attributes,class,extends,annotation,annotation,type,map,string,object,attributes,new,hash,map,string,object,original,attributes,map,string,list,string,attribute,alias,map,get,attribute,alias,map,annotation,type,for,method,attribute,method,get,attribute,methods,annotation,type,string,attribute,name,attribute,method,get,name,object,attribute,value,attributes,get,attribute,name,if,attribute,value,null,list,string,alias,names,attribute,alias,map,get,attribute,name,if,alias,names,null,for,string,alias,name,alias,names,object,alias,value,attributes,get,alias,name,if,alias,value,null,attribute,value,alias,value,attributes,put,attribute,name,attribute,value,break,if,attribute,value,null,object,default,value,get,default,value,annotation,type,attribute,name,if,default,value,null,attribute,value,default,value,attributes,put,attribute,name,attribute,value,if,attribute,value,null,throw,new,illegal,argument,exception,string,format,attributes,map,s,returned,null,for,required,attribute,s,defined,by,annotation,type,s,attributes,attribute,name,annotation,type,get,name,class,required,return,type,attribute,method,get,return,type,class,extends,object,actual,return,type,attribute,value,get,class,if,class,utils,is,assignable,required,return,type,actual,return,type,boolean,converted,false,if,annotation,class,is,assignable,from,required,return,type,map,class,is,assignable,from,actual,return,type,class,extends,annotation,nested,annotation,type,class,extends,annotation,required,return,type,map,string,object,map,map,string,object,attribute,value,attributes,put,attribute,name,synthesize,annotation,map,nested,annotation,type,null,converted,true,else,if,required,return,type,is,array,actual,return,type,is,array,annotation,class,is,assignable,from,required,return,type,get,component,type,map,class,is,assignable,from,actual,return,type,get,component,type,class,extends,annotation,nested,annotation,type,class,extends,annotation,required,return,type,get,component,type,map,string,object,maps,map,string,object,attribute,value,attributes,put,attribute,name,synthesize,annotation,array,maps,nested,annotation,type,converted,true,if,converted,throw,new,illegal,argument,exception,string,format,attributes,map,s,returned,a,value,of,type,s,for,attribute,s,but,a,value,of,type,s,is,required,as,defined,by,annotation,type,s,attributes,actual,return,type,get,name,attribute,name,required,return,type,get,name,annotation,type,get,name,return,attributes
MapAnnotationAttributeExtractor -> @SuppressWarnings("unchecked") 	private static Map<String, Object> enrichAndValidateAttributes( 			Map<String, Object> originalAttributes, Class<? extends Annotation> annotationType);1456179870;Enrich and validate the supplied <em>attributes</em> map by ensuring_that it contains a non-null entry for each annotation attribute in_the specified {@code annotationType} and that the type of the entry_matches the return type for the corresponding annotation attribute._<p>If an entry is a map (presumably of annotation attributes), an_attempt will be made to synthesize an annotation from it. Similarly,_if an entry is an array of maps, an attempt will be made to synthesize_an array of annotations from those maps._<p>If an attribute is missing in the supplied map, it will be set_either to the value of its alias (if an alias exists) or to the_value of the attribute's default value (if defined), and otherwise_an {@link IllegalArgumentException} will be thrown.;@SuppressWarnings("unchecked")_	private static Map<String, Object> enrichAndValidateAttributes(_			Map<String, Object> originalAttributes, Class<? extends Annotation> annotationType) {__		Map<String, Object> attributes = new LinkedHashMap<String, Object>(originalAttributes)__		Map<String, List<String>> attributeAliasMap = getAttributeAliasMap(annotationType)___		for (Method attributeMethod : getAttributeMethods(annotationType)) {_			String attributeName = attributeMethod.getName()__			Object attributeValue = attributes.get(attributeName)___			_			if (attributeValue == null) {_				List<String> aliasNames = attributeAliasMap.get(attributeName)__				if (aliasNames != null) {_					for (String aliasName : aliasNames) {_						Object aliasValue = attributes.get(aliasName)__						if (aliasValue != null) {_							attributeValue = aliasValue__							attributes.put(attributeName, attributeValue)__							break__						}_					}_				}_			}__			_			if (attributeValue == null) {_				Object defaultValue = getDefaultValue(annotationType, attributeName)__				if (defaultValue != null) {_					attributeValue = defaultValue__					attributes.put(attributeName, attributeValue)__				}_			}__			_			if (attributeValue == null) {_				throw new IllegalArgumentException(String.format(_						"Attributes map %s returned null for required attribute '%s' defined by annotation type [%s].",_						attributes, attributeName, annotationType.getName()))__			}__			_			Class<?> requiredReturnType = attributeMethod.getReturnType()__			Class<? extends Object> actualReturnType = attributeValue.getClass()___			if (!ClassUtils.isAssignable(requiredReturnType, actualReturnType)) {_				boolean converted = false___				_				if (Annotation.class.isAssignableFrom(requiredReturnType) &&_						Map.class.isAssignableFrom(actualReturnType)) {_					Class<? extends Annotation> nestedAnnotationType =_							(Class<? extends Annotation>) requiredReturnType__					Map<String, Object> map = (Map<String, Object>) attributeValue__					attributes.put(attributeName, synthesizeAnnotation(map, nestedAnnotationType, null))__					converted = true__				}__				_				else if (requiredReturnType.isArray() && actualReturnType.isArray() &&_						Annotation.class.isAssignableFrom(requiredReturnType.getComponentType()) &&_						Map.class.isAssignableFrom(actualReturnType.getComponentType())) {_					Class<? extends Annotation> nestedAnnotationType =_							(Class<? extends Annotation>) requiredReturnType.getComponentType()__					Map<String, Object>[] maps = (Map<String, Object>[]) attributeValue__					attributes.put(attributeName, synthesizeAnnotationArray(maps, nestedAnnotationType))__					converted = true__				}__				if (!converted) {_					throw new IllegalArgumentException(String.format(_							"Attributes map %s returned a value of type [%s] for attribute '%s', " +_							"but a value of type [%s] is required as defined by annotation type [%s].",_							attributes, actualReturnType.getName(), attributeName, requiredReturnType.getName(),_							annotationType.getName()))__				}_			}_		}__		return attributes__	};enrich,and,validate,the,supplied,em,attributes,em,map,by,ensuring,that,it,contains,a,non,null,entry,for,each,annotation,attribute,in,the,specified,code,annotation,type,and,that,the,type,of,the,entry,matches,the,return,type,for,the,corresponding,annotation,attribute,p,if,an,entry,is,a,map,presumably,of,annotation,attributes,an,attempt,will,be,made,to,synthesize,an,annotation,from,it,similarly,if,an,entry,is,an,array,of,maps,an,attempt,will,be,made,to,synthesize,an,array,of,annotations,from,those,maps,p,if,an,attribute,is,missing,in,the,supplied,map,it,will,be,set,either,to,the,value,of,its,alias,if,an,alias,exists,or,to,the,value,of,the,attribute,s,default,value,if,defined,and,otherwise,an,link,illegal,argument,exception,will,be,thrown;suppress,warnings,unchecked,private,static,map,string,object,enrich,and,validate,attributes,map,string,object,original,attributes,class,extends,annotation,annotation,type,map,string,object,attributes,new,linked,hash,map,string,object,original,attributes,map,string,list,string,attribute,alias,map,get,attribute,alias,map,annotation,type,for,method,attribute,method,get,attribute,methods,annotation,type,string,attribute,name,attribute,method,get,name,object,attribute,value,attributes,get,attribute,name,if,attribute,value,null,list,string,alias,names,attribute,alias,map,get,attribute,name,if,alias,names,null,for,string,alias,name,alias,names,object,alias,value,attributes,get,alias,name,if,alias,value,null,attribute,value,alias,value,attributes,put,attribute,name,attribute,value,break,if,attribute,value,null,object,default,value,get,default,value,annotation,type,attribute,name,if,default,value,null,attribute,value,default,value,attributes,put,attribute,name,attribute,value,if,attribute,value,null,throw,new,illegal,argument,exception,string,format,attributes,map,s,returned,null,for,required,attribute,s,defined,by,annotation,type,s,attributes,attribute,name,annotation,type,get,name,class,required,return,type,attribute,method,get,return,type,class,extends,object,actual,return,type,attribute,value,get,class,if,class,utils,is,assignable,required,return,type,actual,return,type,boolean,converted,false,if,annotation,class,is,assignable,from,required,return,type,map,class,is,assignable,from,actual,return,type,class,extends,annotation,nested,annotation,type,class,extends,annotation,required,return,type,map,string,object,map,map,string,object,attribute,value,attributes,put,attribute,name,synthesize,annotation,map,nested,annotation,type,null,converted,true,else,if,required,return,type,is,array,actual,return,type,is,array,annotation,class,is,assignable,from,required,return,type,get,component,type,map,class,is,assignable,from,actual,return,type,get,component,type,class,extends,annotation,nested,annotation,type,class,extends,annotation,required,return,type,get,component,type,map,string,object,maps,map,string,object,attribute,value,attributes,put,attribute,name,synthesize,annotation,array,maps,nested,annotation,type,converted,true,if,converted,throw,new,illegal,argument,exception,string,format,attributes,map,s,returned,a,value,of,type,s,for,attribute,s,but,a,value,of,type,s,is,required,as,defined,by,annotation,type,s,attributes,actual,return,type,get,name,attribute,name,required,return,type,get,name,annotation,type,get,name,return,attributes
MapAnnotationAttributeExtractor -> @SuppressWarnings("unchecked") 	private static Map<String, Object> enrichAndValidateAttributes( 			Map<String, Object> originalAttributes, Class<? extends Annotation> annotationType);1457360547;Enrich and validate the supplied <em>attributes</em> map by ensuring_that it contains a non-null entry for each annotation attribute in_the specified {@code annotationType} and that the type of the entry_matches the return type for the corresponding annotation attribute._<p>If an entry is a map (presumably of annotation attributes), an_attempt will be made to synthesize an annotation from it. Similarly,_if an entry is an array of maps, an attempt will be made to synthesize_an array of annotations from those maps._<p>If an attribute is missing in the supplied map, it will be set_either to the value of its alias (if an alias exists) or to the_value of the attribute's default value (if defined), and otherwise_an {@link IllegalArgumentException} will be thrown.;@SuppressWarnings("unchecked")_	private static Map<String, Object> enrichAndValidateAttributes(_			Map<String, Object> originalAttributes, Class<? extends Annotation> annotationType) {__		Map<String, Object> attributes = new LinkedHashMap<String, Object>(originalAttributes)__		Map<String, List<String>> attributeAliasMap = getAttributeAliasMap(annotationType)___		for (Method attributeMethod : getAttributeMethods(annotationType)) {_			String attributeName = attributeMethod.getName()__			Object attributeValue = attributes.get(attributeName)___			_			if (attributeValue == null) {_				List<String> aliasNames = attributeAliasMap.get(attributeName)__				if (aliasNames != null) {_					for (String aliasName : aliasNames) {_						Object aliasValue = attributes.get(aliasName)__						if (aliasValue != null) {_							attributeValue = aliasValue__							attributes.put(attributeName, attributeValue)__							break__						}_					}_				}_			}__			_			if (attributeValue == null) {_				Object defaultValue = getDefaultValue(annotationType, attributeName)__				if (defaultValue != null) {_					attributeValue = defaultValue__					attributes.put(attributeName, attributeValue)__				}_			}__			_			if (attributeValue == null) {_				throw new IllegalArgumentException(String.format(_						"Attributes map %s returned null for required attribute '%s' defined by annotation type [%s].",_						attributes, attributeName, annotationType.getName()))__			}__			_			Class<?> requiredReturnType = attributeMethod.getReturnType()__			Class<? extends Object> actualReturnType = attributeValue.getClass()___			if (!ClassUtils.isAssignable(requiredReturnType, actualReturnType)) {_				boolean converted = false___				_				if (requiredReturnType.isArray() && requiredReturnType.getComponentType() == actualReturnType) {_					Object array = Array.newInstance(requiredReturnType.getComponentType(), 1)__					Array.set(array, 0, attributeValue)__					attributes.put(attributeName, array)__					converted = true__				}__				_				else if (Annotation.class.isAssignableFrom(requiredReturnType) &&_						Map.class.isAssignableFrom(actualReturnType)) {_					Class<? extends Annotation> nestedAnnotationType =_							(Class<? extends Annotation>) requiredReturnType__					Map<String, Object> map = (Map<String, Object>) attributeValue__					attributes.put(attributeName, synthesizeAnnotation(map, nestedAnnotationType, null))__					converted = true__				}__				_				else if (requiredReturnType.isArray() && actualReturnType.isArray() &&_						Annotation.class.isAssignableFrom(requiredReturnType.getComponentType()) &&_						Map.class.isAssignableFrom(actualReturnType.getComponentType())) {_					Class<? extends Annotation> nestedAnnotationType =_							(Class<? extends Annotation>) requiredReturnType.getComponentType()__					Map<String, Object>[] maps = (Map<String, Object>[]) attributeValue__					attributes.put(attributeName, synthesizeAnnotationArray(maps, nestedAnnotationType))__					converted = true__				}__				if (!converted) {_					throw new IllegalArgumentException(String.format(_							"Attributes map %s returned a value of type [%s] for attribute '%s', " +_							"but a value of type [%s] is required as defined by annotation type [%s].",_							attributes, actualReturnType.getName(), attributeName, requiredReturnType.getName(),_							annotationType.getName()))__				}_			}_		}__		return attributes__	};enrich,and,validate,the,supplied,em,attributes,em,map,by,ensuring,that,it,contains,a,non,null,entry,for,each,annotation,attribute,in,the,specified,code,annotation,type,and,that,the,type,of,the,entry,matches,the,return,type,for,the,corresponding,annotation,attribute,p,if,an,entry,is,a,map,presumably,of,annotation,attributes,an,attempt,will,be,made,to,synthesize,an,annotation,from,it,similarly,if,an,entry,is,an,array,of,maps,an,attempt,will,be,made,to,synthesize,an,array,of,annotations,from,those,maps,p,if,an,attribute,is,missing,in,the,supplied,map,it,will,be,set,either,to,the,value,of,its,alias,if,an,alias,exists,or,to,the,value,of,the,attribute,s,default,value,if,defined,and,otherwise,an,link,illegal,argument,exception,will,be,thrown;suppress,warnings,unchecked,private,static,map,string,object,enrich,and,validate,attributes,map,string,object,original,attributes,class,extends,annotation,annotation,type,map,string,object,attributes,new,linked,hash,map,string,object,original,attributes,map,string,list,string,attribute,alias,map,get,attribute,alias,map,annotation,type,for,method,attribute,method,get,attribute,methods,annotation,type,string,attribute,name,attribute,method,get,name,object,attribute,value,attributes,get,attribute,name,if,attribute,value,null,list,string,alias,names,attribute,alias,map,get,attribute,name,if,alias,names,null,for,string,alias,name,alias,names,object,alias,value,attributes,get,alias,name,if,alias,value,null,attribute,value,alias,value,attributes,put,attribute,name,attribute,value,break,if,attribute,value,null,object,default,value,get,default,value,annotation,type,attribute,name,if,default,value,null,attribute,value,default,value,attributes,put,attribute,name,attribute,value,if,attribute,value,null,throw,new,illegal,argument,exception,string,format,attributes,map,s,returned,null,for,required,attribute,s,defined,by,annotation,type,s,attributes,attribute,name,annotation,type,get,name,class,required,return,type,attribute,method,get,return,type,class,extends,object,actual,return,type,attribute,value,get,class,if,class,utils,is,assignable,required,return,type,actual,return,type,boolean,converted,false,if,required,return,type,is,array,required,return,type,get,component,type,actual,return,type,object,array,array,new,instance,required,return,type,get,component,type,1,array,set,array,0,attribute,value,attributes,put,attribute,name,array,converted,true,else,if,annotation,class,is,assignable,from,required,return,type,map,class,is,assignable,from,actual,return,type,class,extends,annotation,nested,annotation,type,class,extends,annotation,required,return,type,map,string,object,map,map,string,object,attribute,value,attributes,put,attribute,name,synthesize,annotation,map,nested,annotation,type,null,converted,true,else,if,required,return,type,is,array,actual,return,type,is,array,annotation,class,is,assignable,from,required,return,type,get,component,type,map,class,is,assignable,from,actual,return,type,get,component,type,class,extends,annotation,nested,annotation,type,class,extends,annotation,required,return,type,get,component,type,map,string,object,maps,map,string,object,attribute,value,attributes,put,attribute,name,synthesize,annotation,array,maps,nested,annotation,type,converted,true,if,converted,throw,new,illegal,argument,exception,string,format,attributes,map,s,returned,a,value,of,type,s,for,attribute,s,but,a,value,of,type,s,is,required,as,defined,by,annotation,type,s,attributes,actual,return,type,get,name,attribute,name,required,return,type,get,name,annotation,type,get,name,return,attributes
MapAnnotationAttributeExtractor -> @SuppressWarnings("unchecked") 	private static Map<String, Object> enrichAndValidateAttributes( 			Map<String, Object> originalAttributes, Class<? extends Annotation> annotationType);1467730834;Enrich and validate the supplied <em>attributes</em> map by ensuring_that it contains a non-null entry for each annotation attribute in_the specified {@code annotationType} and that the type of the entry_matches the return type for the corresponding annotation attribute._<p>If an entry is a map (presumably of annotation attributes), an_attempt will be made to synthesize an annotation from it. Similarly,_if an entry is an array of maps, an attempt will be made to synthesize_an array of annotations from those maps._<p>If an attribute is missing in the supplied map, it will be set_either to the value of its alias (if an alias exists) or to the_value of the attribute's default value (if defined), and otherwise_an {@link IllegalArgumentException} will be thrown.;@SuppressWarnings("unchecked")_	private static Map<String, Object> enrichAndValidateAttributes(_			Map<String, Object> originalAttributes, Class<? extends Annotation> annotationType) {__		Map<String, Object> attributes = new LinkedHashMap<>(originalAttributes)__		Map<String, List<String>> attributeAliasMap = getAttributeAliasMap(annotationType)___		for (Method attributeMethod : getAttributeMethods(annotationType)) {_			String attributeName = attributeMethod.getName()__			Object attributeValue = attributes.get(attributeName)___			_			if (attributeValue == null) {_				List<String> aliasNames = attributeAliasMap.get(attributeName)__				if (aliasNames != null) {_					for (String aliasName : aliasNames) {_						Object aliasValue = attributes.get(aliasName)__						if (aliasValue != null) {_							attributeValue = aliasValue__							attributes.put(attributeName, attributeValue)__							break__						}_					}_				}_			}__			_			if (attributeValue == null) {_				Object defaultValue = getDefaultValue(annotationType, attributeName)__				if (defaultValue != null) {_					attributeValue = defaultValue__					attributes.put(attributeName, attributeValue)__				}_			}__			_			if (attributeValue == null) {_				throw new IllegalArgumentException(String.format(_						"Attributes map %s returned null for required attribute '%s' defined by annotation type [%s].",_						attributes, attributeName, annotationType.getName()))__			}__			_			Class<?> requiredReturnType = attributeMethod.getReturnType()__			Class<? extends Object> actualReturnType = attributeValue.getClass()___			if (!ClassUtils.isAssignable(requiredReturnType, actualReturnType)) {_				boolean converted = false___				_				if (requiredReturnType.isArray() && requiredReturnType.getComponentType() == actualReturnType) {_					Object array = Array.newInstance(requiredReturnType.getComponentType(), 1)__					Array.set(array, 0, attributeValue)__					attributes.put(attributeName, array)__					converted = true__				}__				_				else if (Annotation.class.isAssignableFrom(requiredReturnType) &&_						Map.class.isAssignableFrom(actualReturnType)) {_					Class<? extends Annotation> nestedAnnotationType =_							(Class<? extends Annotation>) requiredReturnType__					Map<String, Object> map = (Map<String, Object>) attributeValue__					attributes.put(attributeName, synthesizeAnnotation(map, nestedAnnotationType, null))__					converted = true__				}__				_				else if (requiredReturnType.isArray() && actualReturnType.isArray() &&_						Annotation.class.isAssignableFrom(requiredReturnType.getComponentType()) &&_						Map.class.isAssignableFrom(actualReturnType.getComponentType())) {_					Class<? extends Annotation> nestedAnnotationType =_							(Class<? extends Annotation>) requiredReturnType.getComponentType()__					Map<String, Object>[] maps = (Map<String, Object>[]) attributeValue__					attributes.put(attributeName, synthesizeAnnotationArray(maps, nestedAnnotationType))__					converted = true__				}__				if (!converted) {_					throw new IllegalArgumentException(String.format(_							"Attributes map %s returned a value of type [%s] for attribute '%s', " +_							"but a value of type [%s] is required as defined by annotation type [%s].",_							attributes, actualReturnType.getName(), attributeName, requiredReturnType.getName(),_							annotationType.getName()))__				}_			}_		}__		return attributes__	};enrich,and,validate,the,supplied,em,attributes,em,map,by,ensuring,that,it,contains,a,non,null,entry,for,each,annotation,attribute,in,the,specified,code,annotation,type,and,that,the,type,of,the,entry,matches,the,return,type,for,the,corresponding,annotation,attribute,p,if,an,entry,is,a,map,presumably,of,annotation,attributes,an,attempt,will,be,made,to,synthesize,an,annotation,from,it,similarly,if,an,entry,is,an,array,of,maps,an,attempt,will,be,made,to,synthesize,an,array,of,annotations,from,those,maps,p,if,an,attribute,is,missing,in,the,supplied,map,it,will,be,set,either,to,the,value,of,its,alias,if,an,alias,exists,or,to,the,value,of,the,attribute,s,default,value,if,defined,and,otherwise,an,link,illegal,argument,exception,will,be,thrown;suppress,warnings,unchecked,private,static,map,string,object,enrich,and,validate,attributes,map,string,object,original,attributes,class,extends,annotation,annotation,type,map,string,object,attributes,new,linked,hash,map,original,attributes,map,string,list,string,attribute,alias,map,get,attribute,alias,map,annotation,type,for,method,attribute,method,get,attribute,methods,annotation,type,string,attribute,name,attribute,method,get,name,object,attribute,value,attributes,get,attribute,name,if,attribute,value,null,list,string,alias,names,attribute,alias,map,get,attribute,name,if,alias,names,null,for,string,alias,name,alias,names,object,alias,value,attributes,get,alias,name,if,alias,value,null,attribute,value,alias,value,attributes,put,attribute,name,attribute,value,break,if,attribute,value,null,object,default,value,get,default,value,annotation,type,attribute,name,if,default,value,null,attribute,value,default,value,attributes,put,attribute,name,attribute,value,if,attribute,value,null,throw,new,illegal,argument,exception,string,format,attributes,map,s,returned,null,for,required,attribute,s,defined,by,annotation,type,s,attributes,attribute,name,annotation,type,get,name,class,required,return,type,attribute,method,get,return,type,class,extends,object,actual,return,type,attribute,value,get,class,if,class,utils,is,assignable,required,return,type,actual,return,type,boolean,converted,false,if,required,return,type,is,array,required,return,type,get,component,type,actual,return,type,object,array,array,new,instance,required,return,type,get,component,type,1,array,set,array,0,attribute,value,attributes,put,attribute,name,array,converted,true,else,if,annotation,class,is,assignable,from,required,return,type,map,class,is,assignable,from,actual,return,type,class,extends,annotation,nested,annotation,type,class,extends,annotation,required,return,type,map,string,object,map,map,string,object,attribute,value,attributes,put,attribute,name,synthesize,annotation,map,nested,annotation,type,null,converted,true,else,if,required,return,type,is,array,actual,return,type,is,array,annotation,class,is,assignable,from,required,return,type,get,component,type,map,class,is,assignable,from,actual,return,type,get,component,type,class,extends,annotation,nested,annotation,type,class,extends,annotation,required,return,type,get,component,type,map,string,object,maps,map,string,object,attribute,value,attributes,put,attribute,name,synthesize,annotation,array,maps,nested,annotation,type,converted,true,if,converted,throw,new,illegal,argument,exception,string,format,attributes,map,s,returned,a,value,of,type,s,for,attribute,s,but,a,value,of,type,s,is,required,as,defined,by,annotation,type,s,attributes,actual,return,type,get,name,attribute,name,required,return,type,get,name,annotation,type,get,name,return,attributes
MapAnnotationAttributeExtractor -> @SuppressWarnings("unchecked") 	private static Map<String, Object> enrichAndValidateAttributes( 			Map<String, Object> originalAttributes, Class<? extends Annotation> annotationType);1468334463;Enrich and validate the supplied <em>attributes</em> map by ensuring_that it contains a non-null entry for each annotation attribute in_the specified {@code annotationType} and that the type of the entry_matches the return type for the corresponding annotation attribute._<p>If an entry is a map (presumably of annotation attributes), an_attempt will be made to synthesize an annotation from it. Similarly,_if an entry is an array of maps, an attempt will be made to synthesize_an array of annotations from those maps._<p>If an attribute is missing in the supplied map, it will be set_either to the value of its alias (if an alias exists) or to the_value of the attribute's default value (if defined), and otherwise_an {@link IllegalArgumentException} will be thrown.;@SuppressWarnings("unchecked")_	private static Map<String, Object> enrichAndValidateAttributes(_			Map<String, Object> originalAttributes, Class<? extends Annotation> annotationType) {__		Map<String, Object> attributes = new LinkedHashMap<>(originalAttributes)__		Map<String, List<String>> attributeAliasMap = getAttributeAliasMap(annotationType)___		for (Method attributeMethod : getAttributeMethods(annotationType)) {_			String attributeName = attributeMethod.getName()__			Object attributeValue = attributes.get(attributeName)___			_			if (attributeValue == null) {_				List<String> aliasNames = attributeAliasMap.get(attributeName)__				if (aliasNames != null) {_					for (String aliasName : aliasNames) {_						Object aliasValue = attributes.get(aliasName)__						if (aliasValue != null) {_							attributeValue = aliasValue__							attributes.put(attributeName, attributeValue)__							break__						}_					}_				}_			}__			_			if (attributeValue == null) {_				Object defaultValue = getDefaultValue(annotationType, attributeName)__				if (defaultValue != null) {_					attributeValue = defaultValue__					attributes.put(attributeName, attributeValue)__				}_			}__			_			Assert.notNull(attributeValue, () -> String.format(_					"Attributes map %s returned null for required attribute '%s' defined by annotation type [%s].",_					attributes, attributeName, annotationType.getName()))___			_			Class<?> requiredReturnType = attributeMethod.getReturnType()__			Class<? extends Object> actualReturnType = attributeValue.getClass()___			if (!ClassUtils.isAssignable(requiredReturnType, actualReturnType)) {_				boolean converted = false___				_				if (requiredReturnType.isArray() && requiredReturnType.getComponentType() == actualReturnType) {_					Object array = Array.newInstance(requiredReturnType.getComponentType(), 1)__					Array.set(array, 0, attributeValue)__					attributes.put(attributeName, array)__					converted = true__				}__				_				else if (Annotation.class.isAssignableFrom(requiredReturnType) &&_						Map.class.isAssignableFrom(actualReturnType)) {_					Class<? extends Annotation> nestedAnnotationType =_							(Class<? extends Annotation>) requiredReturnType__					Map<String, Object> map = (Map<String, Object>) attributeValue__					attributes.put(attributeName, synthesizeAnnotation(map, nestedAnnotationType, null))__					converted = true__				}__				_				else if (requiredReturnType.isArray() && actualReturnType.isArray() &&_						Annotation.class.isAssignableFrom(requiredReturnType.getComponentType()) &&_						Map.class.isAssignableFrom(actualReturnType.getComponentType())) {_					Class<? extends Annotation> nestedAnnotationType =_							(Class<? extends Annotation>) requiredReturnType.getComponentType()__					Map<String, Object>[] maps = (Map<String, Object>[]) attributeValue__					attributes.put(attributeName, synthesizeAnnotationArray(maps, nestedAnnotationType))__					converted = true__				}__				Assert.isTrue(converted, () -> String.format(_						"Attributes map %s returned a value of type [%s] for attribute '%s', " +_						"but a value of type [%s] is required as defined by annotation type [%s].",_						attributes, actualReturnType.getName(), attributeName, requiredReturnType.getName(),_						annotationType.getName()))__			}_		}__		return attributes__	};enrich,and,validate,the,supplied,em,attributes,em,map,by,ensuring,that,it,contains,a,non,null,entry,for,each,annotation,attribute,in,the,specified,code,annotation,type,and,that,the,type,of,the,entry,matches,the,return,type,for,the,corresponding,annotation,attribute,p,if,an,entry,is,a,map,presumably,of,annotation,attributes,an,attempt,will,be,made,to,synthesize,an,annotation,from,it,similarly,if,an,entry,is,an,array,of,maps,an,attempt,will,be,made,to,synthesize,an,array,of,annotations,from,those,maps,p,if,an,attribute,is,missing,in,the,supplied,map,it,will,be,set,either,to,the,value,of,its,alias,if,an,alias,exists,or,to,the,value,of,the,attribute,s,default,value,if,defined,and,otherwise,an,link,illegal,argument,exception,will,be,thrown;suppress,warnings,unchecked,private,static,map,string,object,enrich,and,validate,attributes,map,string,object,original,attributes,class,extends,annotation,annotation,type,map,string,object,attributes,new,linked,hash,map,original,attributes,map,string,list,string,attribute,alias,map,get,attribute,alias,map,annotation,type,for,method,attribute,method,get,attribute,methods,annotation,type,string,attribute,name,attribute,method,get,name,object,attribute,value,attributes,get,attribute,name,if,attribute,value,null,list,string,alias,names,attribute,alias,map,get,attribute,name,if,alias,names,null,for,string,alias,name,alias,names,object,alias,value,attributes,get,alias,name,if,alias,value,null,attribute,value,alias,value,attributes,put,attribute,name,attribute,value,break,if,attribute,value,null,object,default,value,get,default,value,annotation,type,attribute,name,if,default,value,null,attribute,value,default,value,attributes,put,attribute,name,attribute,value,assert,not,null,attribute,value,string,format,attributes,map,s,returned,null,for,required,attribute,s,defined,by,annotation,type,s,attributes,attribute,name,annotation,type,get,name,class,required,return,type,attribute,method,get,return,type,class,extends,object,actual,return,type,attribute,value,get,class,if,class,utils,is,assignable,required,return,type,actual,return,type,boolean,converted,false,if,required,return,type,is,array,required,return,type,get,component,type,actual,return,type,object,array,array,new,instance,required,return,type,get,component,type,1,array,set,array,0,attribute,value,attributes,put,attribute,name,array,converted,true,else,if,annotation,class,is,assignable,from,required,return,type,map,class,is,assignable,from,actual,return,type,class,extends,annotation,nested,annotation,type,class,extends,annotation,required,return,type,map,string,object,map,map,string,object,attribute,value,attributes,put,attribute,name,synthesize,annotation,map,nested,annotation,type,null,converted,true,else,if,required,return,type,is,array,actual,return,type,is,array,annotation,class,is,assignable,from,required,return,type,get,component,type,map,class,is,assignable,from,actual,return,type,get,component,type,class,extends,annotation,nested,annotation,type,class,extends,annotation,required,return,type,get,component,type,map,string,object,maps,map,string,object,attribute,value,attributes,put,attribute,name,synthesize,annotation,array,maps,nested,annotation,type,converted,true,assert,is,true,converted,string,format,attributes,map,s,returned,a,value,of,type,s,for,attribute,s,but,a,value,of,type,s,is,required,as,defined,by,annotation,type,s,attributes,actual,return,type,get,name,attribute,name,required,return,type,get,name,annotation,type,get,name,return,attributes
MapAnnotationAttributeExtractor -> @SuppressWarnings("unchecked") 	private static Map<String, Object> enrichAndValidateAttributes( 			Map<String, Object> originalAttributes, Class<? extends Annotation> annotationType);1468583965;Enrich and validate the supplied <em>attributes</em> map by ensuring_that it contains a non-null entry for each annotation attribute in_the specified {@code annotationType} and that the type of the entry_matches the return type for the corresponding annotation attribute._<p>If an entry is a map (presumably of annotation attributes), an_attempt will be made to synthesize an annotation from it. Similarly,_if an entry is an array of maps, an attempt will be made to synthesize_an array of annotations from those maps._<p>If an attribute is missing in the supplied map, it will be set_either to the value of its alias (if an alias exists) or to the_value of the attribute's default value (if defined), and otherwise_an {@link IllegalArgumentException} will be thrown.;@SuppressWarnings("unchecked")_	private static Map<String, Object> enrichAndValidateAttributes(_			Map<String, Object> originalAttributes, Class<? extends Annotation> annotationType) {__		Map<String, Object> attributes = new LinkedHashMap<>(originalAttributes)__		Map<String, List<String>> attributeAliasMap = AnnotationUtils.getAttributeAliasMap(annotationType)___		for (Method attributeMethod : AnnotationUtils.getAttributeMethods(annotationType)) {_			String attributeName = attributeMethod.getName()__			Object attributeValue = attributes.get(attributeName)___			_			if (attributeValue == null) {_				List<String> aliasNames = attributeAliasMap.get(attributeName)__				if (aliasNames != null) {_					for (String aliasName : aliasNames) {_						Object aliasValue = attributes.get(aliasName)__						if (aliasValue != null) {_							attributeValue = aliasValue__							attributes.put(attributeName, attributeValue)__							break__						}_					}_				}_			}__			_			if (attributeValue == null) {_				Object defaultValue = AnnotationUtils.getDefaultValue(annotationType, attributeName)__				if (defaultValue != null) {_					attributeValue = defaultValue__					attributes.put(attributeName, attributeValue)__				}_			}__			_			Assert.notNull(attributeValue, () -> String.format(_					"Attributes map %s returned null for required attribute '%s' defined by annotation type [%s].",_					attributes, attributeName, annotationType.getName()))___			_			Class<?> requiredReturnType = attributeMethod.getReturnType()__			Class<? extends Object> actualReturnType = attributeValue.getClass()___			if (!ClassUtils.isAssignable(requiredReturnType, actualReturnType)) {_				boolean converted = false___				_				if (requiredReturnType.isArray() && requiredReturnType.getComponentType() == actualReturnType) {_					Object array = Array.newInstance(requiredReturnType.getComponentType(), 1)__					Array.set(array, 0, attributeValue)__					attributes.put(attributeName, array)__					converted = true__				}__				_				else if (Annotation.class.isAssignableFrom(requiredReturnType) &&_						Map.class.isAssignableFrom(actualReturnType)) {_					Class<? extends Annotation> nestedAnnotationType =_							(Class<? extends Annotation>) requiredReturnType__					Map<String, Object> map = (Map<String, Object>) attributeValue__					attributes.put(attributeName, AnnotationUtils.synthesizeAnnotation(map, nestedAnnotationType, null))__					converted = true__				}__				_				else if (requiredReturnType.isArray() && actualReturnType.isArray() &&_						Annotation.class.isAssignableFrom(requiredReturnType.getComponentType()) &&_						Map.class.isAssignableFrom(actualReturnType.getComponentType())) {_					Class<? extends Annotation> nestedAnnotationType =_							(Class<? extends Annotation>) requiredReturnType.getComponentType()__					Map<String, Object>[] maps = (Map<String, Object>[]) attributeValue__					attributes.put(attributeName, AnnotationUtils.synthesizeAnnotationArray(maps, nestedAnnotationType))__					converted = true__				}__				Assert.isTrue(converted, () -> String.format(_						"Attributes map %s returned a value of type [%s] for attribute '%s', " +_						"but a value of type [%s] is required as defined by annotation type [%s].",_						attributes, actualReturnType.getName(), attributeName, requiredReturnType.getName(),_						annotationType.getName()))__			}_		}__		return attributes__	};enrich,and,validate,the,supplied,em,attributes,em,map,by,ensuring,that,it,contains,a,non,null,entry,for,each,annotation,attribute,in,the,specified,code,annotation,type,and,that,the,type,of,the,entry,matches,the,return,type,for,the,corresponding,annotation,attribute,p,if,an,entry,is,a,map,presumably,of,annotation,attributes,an,attempt,will,be,made,to,synthesize,an,annotation,from,it,similarly,if,an,entry,is,an,array,of,maps,an,attempt,will,be,made,to,synthesize,an,array,of,annotations,from,those,maps,p,if,an,attribute,is,missing,in,the,supplied,map,it,will,be,set,either,to,the,value,of,its,alias,if,an,alias,exists,or,to,the,value,of,the,attribute,s,default,value,if,defined,and,otherwise,an,link,illegal,argument,exception,will,be,thrown;suppress,warnings,unchecked,private,static,map,string,object,enrich,and,validate,attributes,map,string,object,original,attributes,class,extends,annotation,annotation,type,map,string,object,attributes,new,linked,hash,map,original,attributes,map,string,list,string,attribute,alias,map,annotation,utils,get,attribute,alias,map,annotation,type,for,method,attribute,method,annotation,utils,get,attribute,methods,annotation,type,string,attribute,name,attribute,method,get,name,object,attribute,value,attributes,get,attribute,name,if,attribute,value,null,list,string,alias,names,attribute,alias,map,get,attribute,name,if,alias,names,null,for,string,alias,name,alias,names,object,alias,value,attributes,get,alias,name,if,alias,value,null,attribute,value,alias,value,attributes,put,attribute,name,attribute,value,break,if,attribute,value,null,object,default,value,annotation,utils,get,default,value,annotation,type,attribute,name,if,default,value,null,attribute,value,default,value,attributes,put,attribute,name,attribute,value,assert,not,null,attribute,value,string,format,attributes,map,s,returned,null,for,required,attribute,s,defined,by,annotation,type,s,attributes,attribute,name,annotation,type,get,name,class,required,return,type,attribute,method,get,return,type,class,extends,object,actual,return,type,attribute,value,get,class,if,class,utils,is,assignable,required,return,type,actual,return,type,boolean,converted,false,if,required,return,type,is,array,required,return,type,get,component,type,actual,return,type,object,array,array,new,instance,required,return,type,get,component,type,1,array,set,array,0,attribute,value,attributes,put,attribute,name,array,converted,true,else,if,annotation,class,is,assignable,from,required,return,type,map,class,is,assignable,from,actual,return,type,class,extends,annotation,nested,annotation,type,class,extends,annotation,required,return,type,map,string,object,map,map,string,object,attribute,value,attributes,put,attribute,name,annotation,utils,synthesize,annotation,map,nested,annotation,type,null,converted,true,else,if,required,return,type,is,array,actual,return,type,is,array,annotation,class,is,assignable,from,required,return,type,get,component,type,map,class,is,assignable,from,actual,return,type,get,component,type,class,extends,annotation,nested,annotation,type,class,extends,annotation,required,return,type,get,component,type,map,string,object,maps,map,string,object,attribute,value,attributes,put,attribute,name,annotation,utils,synthesize,annotation,array,maps,nested,annotation,type,converted,true,assert,is,true,converted,string,format,attributes,map,s,returned,a,value,of,type,s,for,attribute,s,but,a,value,of,type,s,is,required,as,defined,by,annotation,type,s,attributes,actual,return,type,get,name,attribute,name,required,return,type,get,name,annotation,type,get,name,return,attributes
MapAnnotationAttributeExtractor -> @SuppressWarnings("unchecked") 	private static Map<String, Object> enrichAndValidateAttributes( 			Map<String, Object> originalAttributes, Class<? extends Annotation> annotationType);1495868221;Enrich and validate the supplied <em>attributes</em> map by ensuring_that it contains a non-null entry for each annotation attribute in_the specified {@code annotationType} and that the type of the entry_matches the return type for the corresponding annotation attribute._<p>If an entry is a map (presumably of annotation attributes), an_attempt will be made to synthesize an annotation from it. Similarly,_if an entry is an array of maps, an attempt will be made to synthesize_an array of annotations from those maps._<p>If an attribute is missing in the supplied map, it will be set_either to the value of its alias (if an alias exists) or to the_value of the attribute's default value (if defined), and otherwise_an {@link IllegalArgumentException} will be thrown.;@SuppressWarnings("unchecked")_	private static Map<String, Object> enrichAndValidateAttributes(_			Map<String, Object> originalAttributes, Class<? extends Annotation> annotationType) {__		Map<String, Object> attributes = new LinkedHashMap<>(originalAttributes)__		Map<String, List<String>> attributeAliasMap = AnnotationUtils.getAttributeAliasMap(annotationType)___		for (Method attributeMethod : AnnotationUtils.getAttributeMethods(annotationType)) {_			String attributeName = attributeMethod.getName()__			Object attributeValue = attributes.get(attributeName)___			_			if (attributeValue == null) {_				List<String> aliasNames = attributeAliasMap.get(attributeName)__				if (aliasNames != null) {_					for (String aliasName : aliasNames) {_						Object aliasValue = attributes.get(aliasName)__						if (aliasValue != null) {_							attributeValue = aliasValue__							attributes.put(attributeName, attributeValue)__							break__						}_					}_				}_			}__			_			if (attributeValue == null) {_				Object defaultValue = AnnotationUtils.getDefaultValue(annotationType, attributeName)__				if (defaultValue != null) {_					attributeValue = defaultValue__					attributes.put(attributeName, attributeValue)__				}_			}__			_			Assert.notNull(attributeValue, () -> String.format(_					"Attributes map %s returned null for required attribute '%s' defined by annotation type [%s].",_					attributes, attributeName, annotationType.getName()))___			_			Class<?> requiredReturnType = attributeMethod.getReturnType()__			Class<? extends Object> actualReturnType = attributeValue.getClass()___			if (!ClassUtils.isAssignable(requiredReturnType, actualReturnType)) {_				boolean converted = false___				_				if (requiredReturnType.isArray() && requiredReturnType.getComponentType() == actualReturnType) {_					Object array = Array.newInstance(requiredReturnType.getComponentType(), 1)__					Array.set(array, 0, attributeValue)__					attributes.put(attributeName, array)__					converted = true__				}__				_				else if (Annotation.class.isAssignableFrom(requiredReturnType) &&_						Map.class.isAssignableFrom(actualReturnType)) {_					Class<? extends Annotation> nestedAnnotationType =_							(Class<? extends Annotation>) requiredReturnType__					Map<String, Object> map = (Map<String, Object>) attributeValue__					attributes.put(attributeName, AnnotationUtils.synthesizeAnnotation(map, nestedAnnotationType, null))__					converted = true__				}__				_				else if (requiredReturnType.isArray() && actualReturnType.isArray() &&_						Annotation.class.isAssignableFrom(requiredReturnType.getComponentType()) &&_						Map.class.isAssignableFrom(actualReturnType.getComponentType())) {_					Class<? extends Annotation> nestedAnnotationType =_							(Class<? extends Annotation>) requiredReturnType.getComponentType()__					Map<String, Object>[] maps = (Map<String, Object>[]) attributeValue__					attributes.put(attributeName, AnnotationUtils.synthesizeAnnotationArray(maps, nestedAnnotationType))__					converted = true__				}__				Assert.isTrue(converted, () -> String.format(_						"Attributes map %s returned a value of type [%s] for attribute '%s', " +_						"but a value of type [%s] is required as defined by annotation type [%s].",_						attributes, actualReturnType.getName(), attributeName, requiredReturnType.getName(),_						annotationType.getName()))__			}_		}__		return attributes__	};enrich,and,validate,the,supplied,em,attributes,em,map,by,ensuring,that,it,contains,a,non,null,entry,for,each,annotation,attribute,in,the,specified,code,annotation,type,and,that,the,type,of,the,entry,matches,the,return,type,for,the,corresponding,annotation,attribute,p,if,an,entry,is,a,map,presumably,of,annotation,attributes,an,attempt,will,be,made,to,synthesize,an,annotation,from,it,similarly,if,an,entry,is,an,array,of,maps,an,attempt,will,be,made,to,synthesize,an,array,of,annotations,from,those,maps,p,if,an,attribute,is,missing,in,the,supplied,map,it,will,be,set,either,to,the,value,of,its,alias,if,an,alias,exists,or,to,the,value,of,the,attribute,s,default,value,if,defined,and,otherwise,an,link,illegal,argument,exception,will,be,thrown;suppress,warnings,unchecked,private,static,map,string,object,enrich,and,validate,attributes,map,string,object,original,attributes,class,extends,annotation,annotation,type,map,string,object,attributes,new,linked,hash,map,original,attributes,map,string,list,string,attribute,alias,map,annotation,utils,get,attribute,alias,map,annotation,type,for,method,attribute,method,annotation,utils,get,attribute,methods,annotation,type,string,attribute,name,attribute,method,get,name,object,attribute,value,attributes,get,attribute,name,if,attribute,value,null,list,string,alias,names,attribute,alias,map,get,attribute,name,if,alias,names,null,for,string,alias,name,alias,names,object,alias,value,attributes,get,alias,name,if,alias,value,null,attribute,value,alias,value,attributes,put,attribute,name,attribute,value,break,if,attribute,value,null,object,default,value,annotation,utils,get,default,value,annotation,type,attribute,name,if,default,value,null,attribute,value,default,value,attributes,put,attribute,name,attribute,value,assert,not,null,attribute,value,string,format,attributes,map,s,returned,null,for,required,attribute,s,defined,by,annotation,type,s,attributes,attribute,name,annotation,type,get,name,class,required,return,type,attribute,method,get,return,type,class,extends,object,actual,return,type,attribute,value,get,class,if,class,utils,is,assignable,required,return,type,actual,return,type,boolean,converted,false,if,required,return,type,is,array,required,return,type,get,component,type,actual,return,type,object,array,array,new,instance,required,return,type,get,component,type,1,array,set,array,0,attribute,value,attributes,put,attribute,name,array,converted,true,else,if,annotation,class,is,assignable,from,required,return,type,map,class,is,assignable,from,actual,return,type,class,extends,annotation,nested,annotation,type,class,extends,annotation,required,return,type,map,string,object,map,map,string,object,attribute,value,attributes,put,attribute,name,annotation,utils,synthesize,annotation,map,nested,annotation,type,null,converted,true,else,if,required,return,type,is,array,actual,return,type,is,array,annotation,class,is,assignable,from,required,return,type,get,component,type,map,class,is,assignable,from,actual,return,type,get,component,type,class,extends,annotation,nested,annotation,type,class,extends,annotation,required,return,type,get,component,type,map,string,object,maps,map,string,object,attribute,value,attributes,put,attribute,name,annotation,utils,synthesize,annotation,array,maps,nested,annotation,type,converted,true,assert,is,true,converted,string,format,attributes,map,s,returned,a,value,of,type,s,for,attribute,s,but,a,value,of,type,s,is,required,as,defined,by,annotation,type,s,attributes,actual,return,type,get,name,attribute,name,required,return,type,get,name,annotation,type,get,name,return,attributes
MapAnnotationAttributeExtractor -> @SuppressWarnings("unchecked") 	private static Map<String, Object> enrichAndValidateAttributes( 			Map<String, Object> originalAttributes, Class<? extends Annotation> annotationType);1501164416;Enrich and validate the supplied <em>attributes</em> map by ensuring_that it contains a non-null entry for each annotation attribute in_the specified {@code annotationType} and that the type of the entry_matches the return type for the corresponding annotation attribute._<p>If an entry is a map (presumably of annotation attributes), an_attempt will be made to synthesize an annotation from it. Similarly,_if an entry is an array of maps, an attempt will be made to synthesize_an array of annotations from those maps._<p>If an attribute is missing in the supplied map, it will be set_either to the value of its alias (if an alias exists) or to the_value of the attribute's default value (if defined), and otherwise_an {@link IllegalArgumentException} will be thrown.;@SuppressWarnings("unchecked")_	private static Map<String, Object> enrichAndValidateAttributes(_			Map<String, Object> originalAttributes, Class<? extends Annotation> annotationType) {__		Map<String, Object> attributes = new LinkedHashMap<>(originalAttributes)__		Map<String, List<String>> attributeAliasMap = AnnotationUtils.getAttributeAliasMap(annotationType)___		for (Method attributeMethod : AnnotationUtils.getAttributeMethods(annotationType)) {_			String attributeName = attributeMethod.getName()__			Object attributeValue = attributes.get(attributeName)___			_			if (attributeValue == null) {_				List<String> aliasNames = attributeAliasMap.get(attributeName)__				if (aliasNames != null) {_					for (String aliasName : aliasNames) {_						Object aliasValue = attributes.get(aliasName)__						if (aliasValue != null) {_							attributeValue = aliasValue__							attributes.put(attributeName, attributeValue)__							break__						}_					}_				}_			}__			_			if (attributeValue == null) {_				Object defaultValue = AnnotationUtils.getDefaultValue(annotationType, attributeName)__				if (defaultValue != null) {_					attributeValue = defaultValue__					attributes.put(attributeName, attributeValue)__				}_			}__			_			Assert.notNull(attributeValue, () -> String.format(_					"Attributes map %s returned null for required attribute '%s' defined by annotation type [%s].",_					attributes, attributeName, annotationType.getName()))___			_			Class<?> requiredReturnType = attributeMethod.getReturnType()__			Class<?> actualReturnType = attributeValue.getClass()___			if (!ClassUtils.isAssignable(requiredReturnType, actualReturnType)) {_				boolean converted = false___				_				if (requiredReturnType.isArray() && requiredReturnType.getComponentType() == actualReturnType) {_					Object array = Array.newInstance(requiredReturnType.getComponentType(), 1)__					Array.set(array, 0, attributeValue)__					attributes.put(attributeName, array)__					converted = true__				}__				_				else if (Annotation.class.isAssignableFrom(requiredReturnType) &&_						Map.class.isAssignableFrom(actualReturnType)) {_					Class<? extends Annotation> nestedAnnotationType =_							(Class<? extends Annotation>) requiredReturnType__					Map<String, Object> map = (Map<String, Object>) attributeValue__					attributes.put(attributeName, AnnotationUtils.synthesizeAnnotation(map, nestedAnnotationType, null))__					converted = true__				}__				_				else if (requiredReturnType.isArray() && actualReturnType.isArray() &&_						Annotation.class.isAssignableFrom(requiredReturnType.getComponentType()) &&_						Map.class.isAssignableFrom(actualReturnType.getComponentType())) {_					Class<? extends Annotation> nestedAnnotationType =_							(Class<? extends Annotation>) requiredReturnType.getComponentType()__					Map<String, Object>[] maps = (Map<String, Object>[]) attributeValue__					attributes.put(attributeName, AnnotationUtils.synthesizeAnnotationArray(maps, nestedAnnotationType))__					converted = true__				}__				Assert.isTrue(converted, () -> String.format(_						"Attributes map %s returned a value of type [%s] for attribute '%s', " +_						"but a value of type [%s] is required as defined by annotation type [%s].",_						attributes, actualReturnType.getName(), attributeName, requiredReturnType.getName(),_						annotationType.getName()))__			}_		}__		return attributes__	};enrich,and,validate,the,supplied,em,attributes,em,map,by,ensuring,that,it,contains,a,non,null,entry,for,each,annotation,attribute,in,the,specified,code,annotation,type,and,that,the,type,of,the,entry,matches,the,return,type,for,the,corresponding,annotation,attribute,p,if,an,entry,is,a,map,presumably,of,annotation,attributes,an,attempt,will,be,made,to,synthesize,an,annotation,from,it,similarly,if,an,entry,is,an,array,of,maps,an,attempt,will,be,made,to,synthesize,an,array,of,annotations,from,those,maps,p,if,an,attribute,is,missing,in,the,supplied,map,it,will,be,set,either,to,the,value,of,its,alias,if,an,alias,exists,or,to,the,value,of,the,attribute,s,default,value,if,defined,and,otherwise,an,link,illegal,argument,exception,will,be,thrown;suppress,warnings,unchecked,private,static,map,string,object,enrich,and,validate,attributes,map,string,object,original,attributes,class,extends,annotation,annotation,type,map,string,object,attributes,new,linked,hash,map,original,attributes,map,string,list,string,attribute,alias,map,annotation,utils,get,attribute,alias,map,annotation,type,for,method,attribute,method,annotation,utils,get,attribute,methods,annotation,type,string,attribute,name,attribute,method,get,name,object,attribute,value,attributes,get,attribute,name,if,attribute,value,null,list,string,alias,names,attribute,alias,map,get,attribute,name,if,alias,names,null,for,string,alias,name,alias,names,object,alias,value,attributes,get,alias,name,if,alias,value,null,attribute,value,alias,value,attributes,put,attribute,name,attribute,value,break,if,attribute,value,null,object,default,value,annotation,utils,get,default,value,annotation,type,attribute,name,if,default,value,null,attribute,value,default,value,attributes,put,attribute,name,attribute,value,assert,not,null,attribute,value,string,format,attributes,map,s,returned,null,for,required,attribute,s,defined,by,annotation,type,s,attributes,attribute,name,annotation,type,get,name,class,required,return,type,attribute,method,get,return,type,class,actual,return,type,attribute,value,get,class,if,class,utils,is,assignable,required,return,type,actual,return,type,boolean,converted,false,if,required,return,type,is,array,required,return,type,get,component,type,actual,return,type,object,array,array,new,instance,required,return,type,get,component,type,1,array,set,array,0,attribute,value,attributes,put,attribute,name,array,converted,true,else,if,annotation,class,is,assignable,from,required,return,type,map,class,is,assignable,from,actual,return,type,class,extends,annotation,nested,annotation,type,class,extends,annotation,required,return,type,map,string,object,map,map,string,object,attribute,value,attributes,put,attribute,name,annotation,utils,synthesize,annotation,map,nested,annotation,type,null,converted,true,else,if,required,return,type,is,array,actual,return,type,is,array,annotation,class,is,assignable,from,required,return,type,get,component,type,map,class,is,assignable,from,actual,return,type,get,component,type,class,extends,annotation,nested,annotation,type,class,extends,annotation,required,return,type,get,component,type,map,string,object,maps,map,string,object,attribute,value,attributes,put,attribute,name,annotation,utils,synthesize,annotation,array,maps,nested,annotation,type,converted,true,assert,is,true,converted,string,format,attributes,map,s,returned,a,value,of,type,s,for,attribute,s,but,a,value,of,type,s,is,required,as,defined,by,annotation,type,s,attributes,actual,return,type,get,name,attribute,name,required,return,type,get,name,annotation,type,get,name,return,attributes
MapAnnotationAttributeExtractor -> @SuppressWarnings("unchecked") 	private static Map<String, Object> enrichAndValidateAttributes( 			Map<String, Object> originalAttributes, Class<? extends Annotation> annotationType);1502974979;Enrich and validate the supplied <em>attributes</em> map by ensuring_that it contains a non-null entry for each annotation attribute in_the specified {@code annotationType} and that the type of the entry_matches the return type for the corresponding annotation attribute._<p>If an entry is a map (presumably of annotation attributes), an_attempt will be made to synthesize an annotation from it. Similarly,_if an entry is an array of maps, an attempt will be made to synthesize_an array of annotations from those maps._<p>If an attribute is missing in the supplied map, it will be set_either to the value of its alias (if an alias exists) or to the_value of the attribute's default value (if defined), and otherwise_an {@link IllegalArgumentException} will be thrown.;@SuppressWarnings("unchecked")_	private static Map<String, Object> enrichAndValidateAttributes(_			Map<String, Object> originalAttributes, Class<? extends Annotation> annotationType) {__		Map<String, Object> attributes = new LinkedHashMap<>(originalAttributes)__		Map<String, List<String>> attributeAliasMap = AnnotationUtils.getAttributeAliasMap(annotationType)___		for (Method attributeMethod : AnnotationUtils.getAttributeMethods(annotationType)) {_			String attributeName = attributeMethod.getName()__			Object attributeValue = attributes.get(attributeName)___			_			if (attributeValue == null) {_				List<String> aliasNames = attributeAliasMap.get(attributeName)__				if (aliasNames != null) {_					for (String aliasName : aliasNames) {_						Object aliasValue = attributes.get(aliasName)__						if (aliasValue != null) {_							attributeValue = aliasValue__							attributes.put(attributeName, attributeValue)__							break__						}_					}_				}_			}__			_			if (attributeValue == null) {_				Object defaultValue = AnnotationUtils.getDefaultValue(annotationType, attributeName)__				if (defaultValue != null) {_					attributeValue = defaultValue__					attributes.put(attributeName, attributeValue)__				}_			}__			_			Assert.notNull(attributeValue, () -> String.format(_					"Attributes map %s returned null for required attribute '%s' defined by annotation type [%s].",_					attributes, attributeName, annotationType.getName()))___			_			Class<?> requiredReturnType = attributeMethod.getReturnType()__			Class<?> actualReturnType = attributeValue.getClass()___			if (!ClassUtils.isAssignable(requiredReturnType, actualReturnType)) {_				boolean converted = false___				_				if (requiredReturnType.isArray() && requiredReturnType.getComponentType() == actualReturnType) {_					Object array = Array.newInstance(requiredReturnType.getComponentType(), 1)__					Array.set(array, 0, attributeValue)__					attributes.put(attributeName, array)__					converted = true__				}__				_				else if (Annotation.class.isAssignableFrom(requiredReturnType) &&_						Map.class.isAssignableFrom(actualReturnType)) {_					Class<? extends Annotation> nestedAnnotationType =_							(Class<? extends Annotation>) requiredReturnType__					Map<String, Object> map = (Map<String, Object>) attributeValue__					attributes.put(attributeName, AnnotationUtils.synthesizeAnnotation(map, nestedAnnotationType, null))__					converted = true__				}__				_				else if (requiredReturnType.isArray() && actualReturnType.isArray() &&_						Annotation.class.isAssignableFrom(requiredReturnType.getComponentType()) &&_						Map.class.isAssignableFrom(actualReturnType.getComponentType())) {_					Class<? extends Annotation> nestedAnnotationType =_							(Class<? extends Annotation>) requiredReturnType.getComponentType()__					Map<String, Object>[] maps = (Map<String, Object>[]) attributeValue__					attributes.put(attributeName, AnnotationUtils.synthesizeAnnotationArray(maps, nestedAnnotationType))__					converted = true__				}__				Assert.isTrue(converted, () -> String.format(_						"Attributes map %s returned a value of type [%s] for attribute '%s', " +_						"but a value of type [%s] is required as defined by annotation type [%s].",_						attributes, actualReturnType.getName(), attributeName, requiredReturnType.getName(),_						annotationType.getName()))__			}_		}__		return attributes__	};enrich,and,validate,the,supplied,em,attributes,em,map,by,ensuring,that,it,contains,a,non,null,entry,for,each,annotation,attribute,in,the,specified,code,annotation,type,and,that,the,type,of,the,entry,matches,the,return,type,for,the,corresponding,annotation,attribute,p,if,an,entry,is,a,map,presumably,of,annotation,attributes,an,attempt,will,be,made,to,synthesize,an,annotation,from,it,similarly,if,an,entry,is,an,array,of,maps,an,attempt,will,be,made,to,synthesize,an,array,of,annotations,from,those,maps,p,if,an,attribute,is,missing,in,the,supplied,map,it,will,be,set,either,to,the,value,of,its,alias,if,an,alias,exists,or,to,the,value,of,the,attribute,s,default,value,if,defined,and,otherwise,an,link,illegal,argument,exception,will,be,thrown;suppress,warnings,unchecked,private,static,map,string,object,enrich,and,validate,attributes,map,string,object,original,attributes,class,extends,annotation,annotation,type,map,string,object,attributes,new,linked,hash,map,original,attributes,map,string,list,string,attribute,alias,map,annotation,utils,get,attribute,alias,map,annotation,type,for,method,attribute,method,annotation,utils,get,attribute,methods,annotation,type,string,attribute,name,attribute,method,get,name,object,attribute,value,attributes,get,attribute,name,if,attribute,value,null,list,string,alias,names,attribute,alias,map,get,attribute,name,if,alias,names,null,for,string,alias,name,alias,names,object,alias,value,attributes,get,alias,name,if,alias,value,null,attribute,value,alias,value,attributes,put,attribute,name,attribute,value,break,if,attribute,value,null,object,default,value,annotation,utils,get,default,value,annotation,type,attribute,name,if,default,value,null,attribute,value,default,value,attributes,put,attribute,name,attribute,value,assert,not,null,attribute,value,string,format,attributes,map,s,returned,null,for,required,attribute,s,defined,by,annotation,type,s,attributes,attribute,name,annotation,type,get,name,class,required,return,type,attribute,method,get,return,type,class,actual,return,type,attribute,value,get,class,if,class,utils,is,assignable,required,return,type,actual,return,type,boolean,converted,false,if,required,return,type,is,array,required,return,type,get,component,type,actual,return,type,object,array,array,new,instance,required,return,type,get,component,type,1,array,set,array,0,attribute,value,attributes,put,attribute,name,array,converted,true,else,if,annotation,class,is,assignable,from,required,return,type,map,class,is,assignable,from,actual,return,type,class,extends,annotation,nested,annotation,type,class,extends,annotation,required,return,type,map,string,object,map,map,string,object,attribute,value,attributes,put,attribute,name,annotation,utils,synthesize,annotation,map,nested,annotation,type,null,converted,true,else,if,required,return,type,is,array,actual,return,type,is,array,annotation,class,is,assignable,from,required,return,type,get,component,type,map,class,is,assignable,from,actual,return,type,get,component,type,class,extends,annotation,nested,annotation,type,class,extends,annotation,required,return,type,get,component,type,map,string,object,maps,map,string,object,attribute,value,attributes,put,attribute,name,annotation,utils,synthesize,annotation,array,maps,nested,annotation,type,converted,true,assert,is,true,converted,string,format,attributes,map,s,returned,a,value,of,type,s,for,attribute,s,but,a,value,of,type,s,is,required,as,defined,by,annotation,type,s,attributes,actual,return,type,get,name,attribute,name,required,return,type,get,name,annotation,type,get,name,return,attributes
MapAnnotationAttributeExtractor -> MapAnnotationAttributeExtractor(Map<String, Object> attributes, Class<? extends Annotation> annotationType, 			@Nullable AnnotatedElement annotatedElement);1495868221;Construct a new {@code MapAnnotationAttributeExtractor}._<p>The supplied map must contain a key-value pair for every attribute_defined in the supplied {@code annotationType} that is not aliased or_does not have a default value._@param attributes the map of annotation attributes_ never {@code null}_@param annotationType the type of annotation to synthesize_ never {@code null}_@param annotatedElement the element that is annotated with the annotation_of the supplied type_ may be {@code null} if unknown;MapAnnotationAttributeExtractor(Map<String, Object> attributes, Class<? extends Annotation> annotationType,_			@Nullable AnnotatedElement annotatedElement) {__		super(annotationType, annotatedElement, enrichAndValidateAttributes(attributes, annotationType))__	};construct,a,new,code,map,annotation,attribute,extractor,p,the,supplied,map,must,contain,a,key,value,pair,for,every,attribute,defined,in,the,supplied,code,annotation,type,that,is,not,aliased,or,does,not,have,a,default,value,param,attributes,the,map,of,annotation,attributes,never,code,null,param,annotation,type,the,type,of,annotation,to,synthesize,never,code,null,param,annotated,element,the,element,that,is,annotated,with,the,annotation,of,the,supplied,type,may,be,code,null,if,unknown;map,annotation,attribute,extractor,map,string,object,attributes,class,extends,annotation,annotation,type,nullable,annotated,element,annotated,element,super,annotation,type,annotated,element,enrich,and,validate,attributes,attributes,annotation,type
MapAnnotationAttributeExtractor -> MapAnnotationAttributeExtractor(Map<String, Object> attributes, Class<? extends Annotation> annotationType, 			@Nullable AnnotatedElement annotatedElement);1501164416;Construct a new {@code MapAnnotationAttributeExtractor}._<p>The supplied map must contain a key-value pair for every attribute_defined in the supplied {@code annotationType} that is not aliased or_does not have a default value._@param attributes the map of annotation attributes_ never {@code null}_@param annotationType the type of annotation to synthesize_ never {@code null}_@param annotatedElement the element that is annotated with the annotation_of the supplied type_ may be {@code null} if unknown;MapAnnotationAttributeExtractor(Map<String, Object> attributes, Class<? extends Annotation> annotationType,_			@Nullable AnnotatedElement annotatedElement) {__		super(annotationType, annotatedElement, enrichAndValidateAttributes(attributes, annotationType))__	};construct,a,new,code,map,annotation,attribute,extractor,p,the,supplied,map,must,contain,a,key,value,pair,for,every,attribute,defined,in,the,supplied,code,annotation,type,that,is,not,aliased,or,does,not,have,a,default,value,param,attributes,the,map,of,annotation,attributes,never,code,null,param,annotation,type,the,type,of,annotation,to,synthesize,never,code,null,param,annotated,element,the,element,that,is,annotated,with,the,annotation,of,the,supplied,type,may,be,code,null,if,unknown;map,annotation,attribute,extractor,map,string,object,attributes,class,extends,annotation,annotation,type,nullable,annotated,element,annotated,element,super,annotation,type,annotated,element,enrich,and,validate,attributes,attributes,annotation,type
MapAnnotationAttributeExtractor -> MapAnnotationAttributeExtractor(Map<String, Object> attributes, Class<? extends Annotation> annotationType, 			@Nullable AnnotatedElement annotatedElement);1502974979;Construct a new {@code MapAnnotationAttributeExtractor}._<p>The supplied map must contain a key-value pair for every attribute_defined in the supplied {@code annotationType} that is not aliased or_does not have a default value._@param attributes the map of annotation attributes_ never {@code null}_@param annotationType the type of annotation to synthesize_ never {@code null}_@param annotatedElement the element that is annotated with the annotation_of the supplied type_ may be {@code null} if unknown;MapAnnotationAttributeExtractor(Map<String, Object> attributes, Class<? extends Annotation> annotationType,_			@Nullable AnnotatedElement annotatedElement) {__		super(annotationType, annotatedElement, enrichAndValidateAttributes(attributes, annotationType))__	};construct,a,new,code,map,annotation,attribute,extractor,p,the,supplied,map,must,contain,a,key,value,pair,for,every,attribute,defined,in,the,supplied,code,annotation,type,that,is,not,aliased,or,does,not,have,a,default,value,param,attributes,the,map,of,annotation,attributes,never,code,null,param,annotation,type,the,type,of,annotation,to,synthesize,never,code,null,param,annotated,element,the,element,that,is,annotated,with,the,annotation,of,the,supplied,type,may,be,code,null,if,unknown;map,annotation,attribute,extractor,map,string,object,attributes,class,extends,annotation,annotation,type,nullable,annotated,element,annotated,element,super,annotation,type,annotated,element,enrich,and,validate,attributes,attributes,annotation,type
MapAnnotationAttributeExtractor -> MapAnnotationAttributeExtractor(Map<String, Object> attributes, Class<? extends Annotation> annotationType, 			AnnotatedElement annotatedElement);1432856630;Construct a new {@code MapAnnotationAttributeExtractor}._<p>The supplied map must contain key-value pairs for every attribute_defined in the supplied {@code annotationType}._@param attributes the map of annotation attributes_ never {@code null}_@param annotationType the type of annotation to synthesize_ never {@code null}_@param annotatedElement the element that is annotated with the annotation_of the supplied type_ may be {@code null} if unknown;MapAnnotationAttributeExtractor(Map<String, Object> attributes, Class<? extends Annotation> annotationType,_			AnnotatedElement annotatedElement) {_		super(annotationType, annotatedElement, new HashMap<String, Object>(attributes))__		validateAttributes(attributes, annotationType)__	};construct,a,new,code,map,annotation,attribute,extractor,p,the,supplied,map,must,contain,key,value,pairs,for,every,attribute,defined,in,the,supplied,code,annotation,type,param,attributes,the,map,of,annotation,attributes,never,code,null,param,annotation,type,the,type,of,annotation,to,synthesize,never,code,null,param,annotated,element,the,element,that,is,annotated,with,the,annotation,of,the,supplied,type,may,be,code,null,if,unknown;map,annotation,attribute,extractor,map,string,object,attributes,class,extends,annotation,annotation,type,annotated,element,annotated,element,super,annotation,type,annotated,element,new,hash,map,string,object,attributes,validate,attributes,attributes,annotation,type
MapAnnotationAttributeExtractor -> MapAnnotationAttributeExtractor(Map<String, Object> attributes, Class<? extends Annotation> annotationType, 			AnnotatedElement annotatedElement);1434720443;Construct a new {@code MapAnnotationAttributeExtractor}._<p>The supplied map must contain a key-value pair for every attribute_defined in the supplied {@code annotationType} that is not aliased or_does not have a default value._@param attributes the map of annotation attributes_ never {@code null}_@param annotationType the type of annotation to synthesize_ never {@code null}_@param annotatedElement the element that is annotated with the annotation_of the supplied type_ may be {@code null} if unknown;MapAnnotationAttributeExtractor(Map<String, Object> attributes, Class<? extends Annotation> annotationType,_			AnnotatedElement annotatedElement) {_		super(annotationType, annotatedElement, enrichAndValidateAttributes(new HashMap<String, Object>(attributes), annotationType))__	};construct,a,new,code,map,annotation,attribute,extractor,p,the,supplied,map,must,contain,a,key,value,pair,for,every,attribute,defined,in,the,supplied,code,annotation,type,that,is,not,aliased,or,does,not,have,a,default,value,param,attributes,the,map,of,annotation,attributes,never,code,null,param,annotation,type,the,type,of,annotation,to,synthesize,never,code,null,param,annotated,element,the,element,that,is,annotated,with,the,annotation,of,the,supplied,type,may,be,code,null,if,unknown;map,annotation,attribute,extractor,map,string,object,attributes,class,extends,annotation,annotation,type,annotated,element,annotated,element,super,annotation,type,annotated,element,enrich,and,validate,attributes,new,hash,map,string,object,attributes,annotation,type
MapAnnotationAttributeExtractor -> MapAnnotationAttributeExtractor(Map<String, Object> attributes, Class<? extends Annotation> annotationType, 			AnnotatedElement annotatedElement);1434721201;Construct a new {@code MapAnnotationAttributeExtractor}._<p>The supplied map must contain a key-value pair for every attribute_defined in the supplied {@code annotationType} that is not aliased or_does not have a default value._@param attributes the map of annotation attributes_ never {@code null}_@param annotationType the type of annotation to synthesize_ never {@code null}_@param annotatedElement the element that is annotated with the annotation_of the supplied type_ may be {@code null} if unknown;MapAnnotationAttributeExtractor(Map<String, Object> attributes, Class<? extends Annotation> annotationType,_			AnnotatedElement annotatedElement) {_		super(annotationType, annotatedElement, enrichAndValidateAttributes(new HashMap<String, Object>(attributes), annotationType))__	};construct,a,new,code,map,annotation,attribute,extractor,p,the,supplied,map,must,contain,a,key,value,pair,for,every,attribute,defined,in,the,supplied,code,annotation,type,that,is,not,aliased,or,does,not,have,a,default,value,param,attributes,the,map,of,annotation,attributes,never,code,null,param,annotation,type,the,type,of,annotation,to,synthesize,never,code,null,param,annotated,element,the,element,that,is,annotated,with,the,annotation,of,the,supplied,type,may,be,code,null,if,unknown;map,annotation,attribute,extractor,map,string,object,attributes,class,extends,annotation,annotation,type,annotated,element,annotated,element,super,annotation,type,annotated,element,enrich,and,validate,attributes,new,hash,map,string,object,attributes,annotation,type
MapAnnotationAttributeExtractor -> MapAnnotationAttributeExtractor(Map<String, Object> attributes, Class<? extends Annotation> annotationType, 			AnnotatedElement annotatedElement);1437139444;Construct a new {@code MapAnnotationAttributeExtractor}._<p>The supplied map must contain a key-value pair for every attribute_defined in the supplied {@code annotationType} that is not aliased or_does not have a default value._@param attributes the map of annotation attributes_ never {@code null}_@param annotationType the type of annotation to synthesize_ never {@code null}_@param annotatedElement the element that is annotated with the annotation_of the supplied type_ may be {@code null} if unknown;MapAnnotationAttributeExtractor(Map<String, Object> attributes, Class<? extends Annotation> annotationType,_			AnnotatedElement annotatedElement) {__		super(annotationType, annotatedElement, enrichAndValidateAttributes(attributes, annotationType))__	};construct,a,new,code,map,annotation,attribute,extractor,p,the,supplied,map,must,contain,a,key,value,pair,for,every,attribute,defined,in,the,supplied,code,annotation,type,that,is,not,aliased,or,does,not,have,a,default,value,param,attributes,the,map,of,annotation,attributes,never,code,null,param,annotation,type,the,type,of,annotation,to,synthesize,never,code,null,param,annotated,element,the,element,that,is,annotated,with,the,annotation,of,the,supplied,type,may,be,code,null,if,unknown;map,annotation,attribute,extractor,map,string,object,attributes,class,extends,annotation,annotation,type,annotated,element,annotated,element,super,annotation,type,annotated,element,enrich,and,validate,attributes,attributes,annotation,type
MapAnnotationAttributeExtractor -> MapAnnotationAttributeExtractor(Map<String, Object> attributes, Class<? extends Annotation> annotationType, 			AnnotatedElement annotatedElement);1439211354;Construct a new {@code MapAnnotationAttributeExtractor}._<p>The supplied map must contain a key-value pair for every attribute_defined in the supplied {@code annotationType} that is not aliased or_does not have a default value._@param attributes the map of annotation attributes_ never {@code null}_@param annotationType the type of annotation to synthesize_ never {@code null}_@param annotatedElement the element that is annotated with the annotation_of the supplied type_ may be {@code null} if unknown;MapAnnotationAttributeExtractor(Map<String, Object> attributes, Class<? extends Annotation> annotationType,_			AnnotatedElement annotatedElement) {__		super(annotationType, annotatedElement, enrichAndValidateAttributes(attributes, annotationType))__	};construct,a,new,code,map,annotation,attribute,extractor,p,the,supplied,map,must,contain,a,key,value,pair,for,every,attribute,defined,in,the,supplied,code,annotation,type,that,is,not,aliased,or,does,not,have,a,default,value,param,attributes,the,map,of,annotation,attributes,never,code,null,param,annotation,type,the,type,of,annotation,to,synthesize,never,code,null,param,annotated,element,the,element,that,is,annotated,with,the,annotation,of,the,supplied,type,may,be,code,null,if,unknown;map,annotation,attribute,extractor,map,string,object,attributes,class,extends,annotation,annotation,type,annotated,element,annotated,element,super,annotation,type,annotated,element,enrich,and,validate,attributes,attributes,annotation,type
MapAnnotationAttributeExtractor -> MapAnnotationAttributeExtractor(Map<String, Object> attributes, Class<? extends Annotation> annotationType, 			AnnotatedElement annotatedElement);1439214025;Construct a new {@code MapAnnotationAttributeExtractor}._<p>The supplied map must contain a key-value pair for every attribute_defined in the supplied {@code annotationType} that is not aliased or_does not have a default value._@param attributes the map of annotation attributes_ never {@code null}_@param annotationType the type of annotation to synthesize_ never {@code null}_@param annotatedElement the element that is annotated with the annotation_of the supplied type_ may be {@code null} if unknown;MapAnnotationAttributeExtractor(Map<String, Object> attributes, Class<? extends Annotation> annotationType,_			AnnotatedElement annotatedElement) {__		super(annotationType, annotatedElement, enrichAndValidateAttributes(attributes, annotationType))__	};construct,a,new,code,map,annotation,attribute,extractor,p,the,supplied,map,must,contain,a,key,value,pair,for,every,attribute,defined,in,the,supplied,code,annotation,type,that,is,not,aliased,or,does,not,have,a,default,value,param,attributes,the,map,of,annotation,attributes,never,code,null,param,annotation,type,the,type,of,annotation,to,synthesize,never,code,null,param,annotated,element,the,element,that,is,annotated,with,the,annotation,of,the,supplied,type,may,be,code,null,if,unknown;map,annotation,attribute,extractor,map,string,object,attributes,class,extends,annotation,annotation,type,annotated,element,annotated,element,super,annotation,type,annotated,element,enrich,and,validate,attributes,attributes,annotation,type
MapAnnotationAttributeExtractor -> MapAnnotationAttributeExtractor(Map<String, Object> attributes, Class<? extends Annotation> annotationType, 			AnnotatedElement annotatedElement);1440781118;Construct a new {@code MapAnnotationAttributeExtractor}._<p>The supplied map must contain a key-value pair for every attribute_defined in the supplied {@code annotationType} that is not aliased or_does not have a default value._@param attributes the map of annotation attributes_ never {@code null}_@param annotationType the type of annotation to synthesize_ never {@code null}_@param annotatedElement the element that is annotated with the annotation_of the supplied type_ may be {@code null} if unknown;MapAnnotationAttributeExtractor(Map<String, Object> attributes, Class<? extends Annotation> annotationType,_			AnnotatedElement annotatedElement) {__		super(annotationType, annotatedElement, enrichAndValidateAttributes(attributes, annotationType))__	};construct,a,new,code,map,annotation,attribute,extractor,p,the,supplied,map,must,contain,a,key,value,pair,for,every,attribute,defined,in,the,supplied,code,annotation,type,that,is,not,aliased,or,does,not,have,a,default,value,param,attributes,the,map,of,annotation,attributes,never,code,null,param,annotation,type,the,type,of,annotation,to,synthesize,never,code,null,param,annotated,element,the,element,that,is,annotated,with,the,annotation,of,the,supplied,type,may,be,code,null,if,unknown;map,annotation,attribute,extractor,map,string,object,attributes,class,extends,annotation,annotation,type,annotated,element,annotated,element,super,annotation,type,annotated,element,enrich,and,validate,attributes,attributes,annotation,type
MapAnnotationAttributeExtractor -> MapAnnotationAttributeExtractor(Map<String, Object> attributes, Class<? extends Annotation> annotationType, 			AnnotatedElement annotatedElement);1440857126;Construct a new {@code MapAnnotationAttributeExtractor}._<p>The supplied map must contain a key-value pair for every attribute_defined in the supplied {@code annotationType} that is not aliased or_does not have a default value._@param attributes the map of annotation attributes_ never {@code null}_@param annotationType the type of annotation to synthesize_ never {@code null}_@param annotatedElement the element that is annotated with the annotation_of the supplied type_ may be {@code null} if unknown;MapAnnotationAttributeExtractor(Map<String, Object> attributes, Class<? extends Annotation> annotationType,_			AnnotatedElement annotatedElement) {__		super(annotationType, annotatedElement, enrichAndValidateAttributes(attributes, annotationType))__	};construct,a,new,code,map,annotation,attribute,extractor,p,the,supplied,map,must,contain,a,key,value,pair,for,every,attribute,defined,in,the,supplied,code,annotation,type,that,is,not,aliased,or,does,not,have,a,default,value,param,attributes,the,map,of,annotation,attributes,never,code,null,param,annotation,type,the,type,of,annotation,to,synthesize,never,code,null,param,annotated,element,the,element,that,is,annotated,with,the,annotation,of,the,supplied,type,may,be,code,null,if,unknown;map,annotation,attribute,extractor,map,string,object,attributes,class,extends,annotation,annotation,type,annotated,element,annotated,element,super,annotation,type,annotated,element,enrich,and,validate,attributes,attributes,annotation,type
MapAnnotationAttributeExtractor -> MapAnnotationAttributeExtractor(Map<String, Object> attributes, Class<? extends Annotation> annotationType, 			AnnotatedElement annotatedElement);1446737720;Construct a new {@code MapAnnotationAttributeExtractor}._<p>The supplied map must contain a key-value pair for every attribute_defined in the supplied {@code annotationType} that is not aliased or_does not have a default value._@param attributes the map of annotation attributes_ never {@code null}_@param annotationType the type of annotation to synthesize_ never {@code null}_@param annotatedElement the element that is annotated with the annotation_of the supplied type_ may be {@code null} if unknown;MapAnnotationAttributeExtractor(Map<String, Object> attributes, Class<? extends Annotation> annotationType,_			AnnotatedElement annotatedElement) {__		super(annotationType, annotatedElement, enrichAndValidateAttributes(attributes, annotationType))__	};construct,a,new,code,map,annotation,attribute,extractor,p,the,supplied,map,must,contain,a,key,value,pair,for,every,attribute,defined,in,the,supplied,code,annotation,type,that,is,not,aliased,or,does,not,have,a,default,value,param,attributes,the,map,of,annotation,attributes,never,code,null,param,annotation,type,the,type,of,annotation,to,synthesize,never,code,null,param,annotated,element,the,element,that,is,annotated,with,the,annotation,of,the,supplied,type,may,be,code,null,if,unknown;map,annotation,attribute,extractor,map,string,object,attributes,class,extends,annotation,annotation,type,annotated,element,annotated,element,super,annotation,type,annotated,element,enrich,and,validate,attributes,attributes,annotation,type
MapAnnotationAttributeExtractor -> MapAnnotationAttributeExtractor(Map<String, Object> attributes, Class<? extends Annotation> annotationType, 			AnnotatedElement annotatedElement);1456179870;Construct a new {@code MapAnnotationAttributeExtractor}._<p>The supplied map must contain a key-value pair for every attribute_defined in the supplied {@code annotationType} that is not aliased or_does not have a default value._@param attributes the map of annotation attributes_ never {@code null}_@param annotationType the type of annotation to synthesize_ never {@code null}_@param annotatedElement the element that is annotated with the annotation_of the supplied type_ may be {@code null} if unknown;MapAnnotationAttributeExtractor(Map<String, Object> attributes, Class<? extends Annotation> annotationType,_			AnnotatedElement annotatedElement) {__		super(annotationType, annotatedElement, enrichAndValidateAttributes(attributes, annotationType))__	};construct,a,new,code,map,annotation,attribute,extractor,p,the,supplied,map,must,contain,a,key,value,pair,for,every,attribute,defined,in,the,supplied,code,annotation,type,that,is,not,aliased,or,does,not,have,a,default,value,param,attributes,the,map,of,annotation,attributes,never,code,null,param,annotation,type,the,type,of,annotation,to,synthesize,never,code,null,param,annotated,element,the,element,that,is,annotated,with,the,annotation,of,the,supplied,type,may,be,code,null,if,unknown;map,annotation,attribute,extractor,map,string,object,attributes,class,extends,annotation,annotation,type,annotated,element,annotated,element,super,annotation,type,annotated,element,enrich,and,validate,attributes,attributes,annotation,type
MapAnnotationAttributeExtractor -> MapAnnotationAttributeExtractor(Map<String, Object> attributes, Class<? extends Annotation> annotationType, 			AnnotatedElement annotatedElement);1457360547;Construct a new {@code MapAnnotationAttributeExtractor}._<p>The supplied map must contain a key-value pair for every attribute_defined in the supplied {@code annotationType} that is not aliased or_does not have a default value._@param attributes the map of annotation attributes_ never {@code null}_@param annotationType the type of annotation to synthesize_ never {@code null}_@param annotatedElement the element that is annotated with the annotation_of the supplied type_ may be {@code null} if unknown;MapAnnotationAttributeExtractor(Map<String, Object> attributes, Class<? extends Annotation> annotationType,_			AnnotatedElement annotatedElement) {__		super(annotationType, annotatedElement, enrichAndValidateAttributes(attributes, annotationType))__	};construct,a,new,code,map,annotation,attribute,extractor,p,the,supplied,map,must,contain,a,key,value,pair,for,every,attribute,defined,in,the,supplied,code,annotation,type,that,is,not,aliased,or,does,not,have,a,default,value,param,attributes,the,map,of,annotation,attributes,never,code,null,param,annotation,type,the,type,of,annotation,to,synthesize,never,code,null,param,annotated,element,the,element,that,is,annotated,with,the,annotation,of,the,supplied,type,may,be,code,null,if,unknown;map,annotation,attribute,extractor,map,string,object,attributes,class,extends,annotation,annotation,type,annotated,element,annotated,element,super,annotation,type,annotated,element,enrich,and,validate,attributes,attributes,annotation,type
MapAnnotationAttributeExtractor -> MapAnnotationAttributeExtractor(Map<String, Object> attributes, Class<? extends Annotation> annotationType, 			AnnotatedElement annotatedElement);1467730834;Construct a new {@code MapAnnotationAttributeExtractor}._<p>The supplied map must contain a key-value pair for every attribute_defined in the supplied {@code annotationType} that is not aliased or_does not have a default value._@param attributes the map of annotation attributes_ never {@code null}_@param annotationType the type of annotation to synthesize_ never {@code null}_@param annotatedElement the element that is annotated with the annotation_of the supplied type_ may be {@code null} if unknown;MapAnnotationAttributeExtractor(Map<String, Object> attributes, Class<? extends Annotation> annotationType,_			AnnotatedElement annotatedElement) {__		super(annotationType, annotatedElement, enrichAndValidateAttributes(attributes, annotationType))__	};construct,a,new,code,map,annotation,attribute,extractor,p,the,supplied,map,must,contain,a,key,value,pair,for,every,attribute,defined,in,the,supplied,code,annotation,type,that,is,not,aliased,or,does,not,have,a,default,value,param,attributes,the,map,of,annotation,attributes,never,code,null,param,annotation,type,the,type,of,annotation,to,synthesize,never,code,null,param,annotated,element,the,element,that,is,annotated,with,the,annotation,of,the,supplied,type,may,be,code,null,if,unknown;map,annotation,attribute,extractor,map,string,object,attributes,class,extends,annotation,annotation,type,annotated,element,annotated,element,super,annotation,type,annotated,element,enrich,and,validate,attributes,attributes,annotation,type
MapAnnotationAttributeExtractor -> MapAnnotationAttributeExtractor(Map<String, Object> attributes, Class<? extends Annotation> annotationType, 			AnnotatedElement annotatedElement);1468334463;Construct a new {@code MapAnnotationAttributeExtractor}._<p>The supplied map must contain a key-value pair for every attribute_defined in the supplied {@code annotationType} that is not aliased or_does not have a default value._@param attributes the map of annotation attributes_ never {@code null}_@param annotationType the type of annotation to synthesize_ never {@code null}_@param annotatedElement the element that is annotated with the annotation_of the supplied type_ may be {@code null} if unknown;MapAnnotationAttributeExtractor(Map<String, Object> attributes, Class<? extends Annotation> annotationType,_			AnnotatedElement annotatedElement) {__		super(annotationType, annotatedElement, enrichAndValidateAttributes(attributes, annotationType))__	};construct,a,new,code,map,annotation,attribute,extractor,p,the,supplied,map,must,contain,a,key,value,pair,for,every,attribute,defined,in,the,supplied,code,annotation,type,that,is,not,aliased,or,does,not,have,a,default,value,param,attributes,the,map,of,annotation,attributes,never,code,null,param,annotation,type,the,type,of,annotation,to,synthesize,never,code,null,param,annotated,element,the,element,that,is,annotated,with,the,annotation,of,the,supplied,type,may,be,code,null,if,unknown;map,annotation,attribute,extractor,map,string,object,attributes,class,extends,annotation,annotation,type,annotated,element,annotated,element,super,annotation,type,annotated,element,enrich,and,validate,attributes,attributes,annotation,type
MapAnnotationAttributeExtractor -> MapAnnotationAttributeExtractor(Map<String, Object> attributes, Class<? extends Annotation> annotationType, 			AnnotatedElement annotatedElement);1468583965;Construct a new {@code MapAnnotationAttributeExtractor}._<p>The supplied map must contain a key-value pair for every attribute_defined in the supplied {@code annotationType} that is not aliased or_does not have a default value._@param attributes the map of annotation attributes_ never {@code null}_@param annotationType the type of annotation to synthesize_ never {@code null}_@param annotatedElement the element that is annotated with the annotation_of the supplied type_ may be {@code null} if unknown;MapAnnotationAttributeExtractor(Map<String, Object> attributes, Class<? extends Annotation> annotationType,_			AnnotatedElement annotatedElement) {__		super(annotationType, annotatedElement, enrichAndValidateAttributes(attributes, annotationType))__	};construct,a,new,code,map,annotation,attribute,extractor,p,the,supplied,map,must,contain,a,key,value,pair,for,every,attribute,defined,in,the,supplied,code,annotation,type,that,is,not,aliased,or,does,not,have,a,default,value,param,attributes,the,map,of,annotation,attributes,never,code,null,param,annotation,type,the,type,of,annotation,to,synthesize,never,code,null,param,annotated,element,the,element,that,is,annotated,with,the,annotation,of,the,supplied,type,may,be,code,null,if,unknown;map,annotation,attribute,extractor,map,string,object,attributes,class,extends,annotation,annotation,type,annotated,element,annotated,element,super,annotation,type,annotated,element,enrich,and,validate,attributes,attributes,annotation,type
MapAnnotationAttributeExtractor -> private static Map<String, Object> enrichAndValidateAttributes(Map<String, Object> attributes, 			Class<? extends Annotation> annotationType);1434720443;Enrich and validate the supplied {@code attributes} map by ensuring_that it contains a non-null entry for each annotation attribute in_the specified {@code annotationType} and that the type of the entry_matches the return type for the corresponding annotation attribute._<p>If an attribute is missing in the supplied map, it will be set_either to value of its alias (if an alias value exists) or to the_value of the attribute's default value (if defined), and otherwise_an {@link IllegalArgumentException} will be thrown._@see AliasFor;private static Map<String, Object> enrichAndValidateAttributes(Map<String, Object> attributes,_			Class<? extends Annotation> annotationType) {__		Map<String, String> attributeAliasMap = getAttributeAliasMap(annotationType)___		for (Method attributeMethod : getAttributeMethods(annotationType)) {_			String attributeName = attributeMethod.getName()__			Object attributeValue = attributes.get(attributeName)____			_			if (attributeValue == null) {_				String aliasName = attributeAliasMap.get(attributeName)__				if (aliasName != null) {_					Object aliasValue = attributes.get(aliasName)__					if (aliasValue != null) {_						attributeValue = aliasValue__						attributes.put(attributeName, attributeValue)__					}_				}_			}__			_			if (attributeValue == null) {_				Object defaultValue = getDefaultValue(annotationType, attributeName)__				if (defaultValue != null) {_					attributeValue = defaultValue__					attributes.put(attributeName, attributeValue)__				}_			}__			_			if (attributeValue == null) {_				throw new IllegalArgumentException(String.format(_					"Attributes map [%s] returned null for required attribute [%s] defined by annotation type [%s].",_					attributes, attributeName, annotationType.getName()))__			}__			_			Class<?> returnType = attributeMethod.getReturnType()__			if (!ClassUtils.isAssignable(returnType, attributeValue.getClass())) {_				throw new IllegalArgumentException(String.format(_					"Attributes map [%s] returned a value of type [%s] for attribute [%s], "_							+ "but a value of type [%s] is required as defined by annotation type [%s].", attributes,_					attributeValue.getClass().getName(), attributeName, returnType.getName(), annotationType.getName()))__			}_		}__		return attributes__	};enrich,and,validate,the,supplied,code,attributes,map,by,ensuring,that,it,contains,a,non,null,entry,for,each,annotation,attribute,in,the,specified,code,annotation,type,and,that,the,type,of,the,entry,matches,the,return,type,for,the,corresponding,annotation,attribute,p,if,an,attribute,is,missing,in,the,supplied,map,it,will,be,set,either,to,value,of,its,alias,if,an,alias,value,exists,or,to,the,value,of,the,attribute,s,default,value,if,defined,and,otherwise,an,link,illegal,argument,exception,will,be,thrown,see,alias,for;private,static,map,string,object,enrich,and,validate,attributes,map,string,object,attributes,class,extends,annotation,annotation,type,map,string,string,attribute,alias,map,get,attribute,alias,map,annotation,type,for,method,attribute,method,get,attribute,methods,annotation,type,string,attribute,name,attribute,method,get,name,object,attribute,value,attributes,get,attribute,name,if,attribute,value,null,string,alias,name,attribute,alias,map,get,attribute,name,if,alias,name,null,object,alias,value,attributes,get,alias,name,if,alias,value,null,attribute,value,alias,value,attributes,put,attribute,name,attribute,value,if,attribute,value,null,object,default,value,get,default,value,annotation,type,attribute,name,if,default,value,null,attribute,value,default,value,attributes,put,attribute,name,attribute,value,if,attribute,value,null,throw,new,illegal,argument,exception,string,format,attributes,map,s,returned,null,for,required,attribute,s,defined,by,annotation,type,s,attributes,attribute,name,annotation,type,get,name,class,return,type,attribute,method,get,return,type,if,class,utils,is,assignable,return,type,attribute,value,get,class,throw,new,illegal,argument,exception,string,format,attributes,map,s,returned,a,value,of,type,s,for,attribute,s,but,a,value,of,type,s,is,required,as,defined,by,annotation,type,s,attributes,attribute,value,get,class,get,name,attribute,name,return,type,get,name,annotation,type,get,name,return,attributes
MapAnnotationAttributeExtractor -> private static Map<String, Object> enrichAndValidateAttributes(Map<String, Object> attributes, 			Class<? extends Annotation> annotationType);1434721201;Enrich and validate the supplied {@code attributes} map by ensuring_that it contains a non-null entry for each annotation attribute in_the specified {@code annotationType} and that the type of the entry_matches the return type for the corresponding annotation attribute._<p>If an attribute is missing in the supplied map, it will be set_either to value of its alias (if an alias value exists) or to the_value of the attribute's default value (if defined), and otherwise_an {@link IllegalArgumentException} will be thrown._@see AliasFor;private static Map<String, Object> enrichAndValidateAttributes(Map<String, Object> attributes,_			Class<? extends Annotation> annotationType) {__		Map<String, String> attributeAliasMap = getAttributeAliasMap(annotationType)___		for (Method attributeMethod : getAttributeMethods(annotationType)) {_			String attributeName = attributeMethod.getName()__			Object attributeValue = attributes.get(attributeName)___			_			if (attributeValue == null) {_				String aliasName = attributeAliasMap.get(attributeName)__				if (aliasName != null) {_					Object aliasValue = attributes.get(aliasName)__					if (aliasValue != null) {_						attributeValue = aliasValue__						attributes.put(attributeName, attributeValue)__					}_				}_			}__			_			if (attributeValue == null) {_				Object defaultValue = getDefaultValue(annotationType, attributeName)__				if (defaultValue != null) {_					attributeValue = defaultValue__					attributes.put(attributeName, attributeValue)__				}_			}__			_			if (attributeValue == null) {_				throw new IllegalArgumentException(String.format(_					"Attributes map [%s] returned null for required attribute [%s] defined by annotation type [%s].",_					attributes, attributeName, annotationType.getName()))__			}__			_			Class<?> returnType = attributeMethod.getReturnType()__			if (!ClassUtils.isAssignable(returnType, attributeValue.getClass())) {_				throw new IllegalArgumentException(String.format(_					"Attributes map [%s] returned a value of type [%s] for attribute [%s], "_							+ "but a value of type [%s] is required as defined by annotation type [%s].", attributes,_					attributeValue.getClass().getName(), attributeName, returnType.getName(), annotationType.getName()))__			}_		}__		return attributes__	};enrich,and,validate,the,supplied,code,attributes,map,by,ensuring,that,it,contains,a,non,null,entry,for,each,annotation,attribute,in,the,specified,code,annotation,type,and,that,the,type,of,the,entry,matches,the,return,type,for,the,corresponding,annotation,attribute,p,if,an,attribute,is,missing,in,the,supplied,map,it,will,be,set,either,to,value,of,its,alias,if,an,alias,value,exists,or,to,the,value,of,the,attribute,s,default,value,if,defined,and,otherwise,an,link,illegal,argument,exception,will,be,thrown,see,alias,for;private,static,map,string,object,enrich,and,validate,attributes,map,string,object,attributes,class,extends,annotation,annotation,type,map,string,string,attribute,alias,map,get,attribute,alias,map,annotation,type,for,method,attribute,method,get,attribute,methods,annotation,type,string,attribute,name,attribute,method,get,name,object,attribute,value,attributes,get,attribute,name,if,attribute,value,null,string,alias,name,attribute,alias,map,get,attribute,name,if,alias,name,null,object,alias,value,attributes,get,alias,name,if,alias,value,null,attribute,value,alias,value,attributes,put,attribute,name,attribute,value,if,attribute,value,null,object,default,value,get,default,value,annotation,type,attribute,name,if,default,value,null,attribute,value,default,value,attributes,put,attribute,name,attribute,value,if,attribute,value,null,throw,new,illegal,argument,exception,string,format,attributes,map,s,returned,null,for,required,attribute,s,defined,by,annotation,type,s,attributes,attribute,name,annotation,type,get,name,class,return,type,attribute,method,get,return,type,if,class,utils,is,assignable,return,type,attribute,value,get,class,throw,new,illegal,argument,exception,string,format,attributes,map,s,returned,a,value,of,type,s,for,attribute,s,but,a,value,of,type,s,is,required,as,defined,by,annotation,type,s,attributes,attribute,value,get,class,get,name,attribute,name,return,type,get,name,annotation,type,get,name,return,attributes
