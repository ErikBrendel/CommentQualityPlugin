commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;5;;@Override @Nullable protected Object getRawAttributeValue(Method attributeMethod) {     return getRawAttributeValue(attributeMethod.getName()). }
false;protected;1;5;;@Override @Nullable protected Object getRawAttributeValue(String attributeName) {     return getSource().get(attributeName). }
true;private,static;2;86;/**  * Enrich and validate the supplied <em>attributes</em> map by ensuring  * that it contains a non-null entry for each annotation attribute in  * the specified {@code annotationType} and that the type of the entry  * matches the return type for the corresponding annotation attribute.  * <p>If an entry is a map (presumably of annotation attributes), an  * attempt will be made to synthesize an annotation from it. Similarly,  * if an entry is an array of maps, an attempt will be made to synthesize  * an array of annotations from those maps.  * <p>If an attribute is missing in the supplied map, it will be set  * either to the value of its alias (if an alias exists) or to the  * value of the attribute's default value (if defined), and otherwise  * an {@link IllegalArgumentException} will be thrown.  */ ;/**  * Enrich and validate the supplied <em>attributes</em> map by ensuring  * that it contains a non-null entry for each annotation attribute in  * the specified {@code annotationType} and that the type of the entry  * matches the return type for the corresponding annotation attribute.  * <p>If an entry is a map (presumably of annotation attributes), an  * attempt will be made to synthesize an annotation from it. Similarly,  * if an entry is an array of maps, an attempt will be made to synthesize  * an array of annotations from those maps.  * <p>If an attribute is missing in the supplied map, it will be set  * either to the value of its alias (if an alias exists) or to the  * value of the attribute's default value (if defined), and otherwise  * an {@link IllegalArgumentException} will be thrown.  */ @SuppressWarnings("unchecked") private static Map<String, Object> enrichAndValidateAttributes(Map<String, Object> originalAttributes, Class<? extends Annotation> annotationType) {     Map<String, Object> attributes = new LinkedHashMap<>(originalAttributes).     Map<String, List<String>> attributeAliasMap = AnnotationUtils.getAttributeAliasMap(annotationType).     for (Method attributeMethod : AnnotationUtils.getAttributeMethods(annotationType)) {         String attributeName = attributeMethod.getName().         Object attributeValue = attributes.get(attributeName).         // if attribute not present, check aliases         if (attributeValue == null) {             List<String> aliasNames = attributeAliasMap.get(attributeName).             if (aliasNames != null) {                 for (String aliasName : aliasNames) {                     Object aliasValue = attributes.get(aliasName).                     if (aliasValue != null) {                         attributeValue = aliasValue.                         attributes.put(attributeName, attributeValue).                         break.                     }                 }             }         }         // if aliases not present, check default         if (attributeValue == null) {             Object defaultValue = AnnotationUtils.getDefaultValue(annotationType, attributeName).             if (defaultValue != null) {                 attributeValue = defaultValue.                 attributes.put(attributeName, attributeValue).             }         }         // if still null         Assert.notNull(attributeValue, () -> String.format("Attributes map %s returned null for required attribute '%s' defined by annotation type [%s].", attributes, attributeName, annotationType.getName())).         // finally, ensure correct type         Class<?> requiredReturnType = attributeMethod.getReturnType().         Class<?> actualReturnType = attributeValue.getClass().         if (!ClassUtils.isAssignable(requiredReturnType, actualReturnType)) {             boolean converted = false.             // Single element overriding an array of the same type?             if (requiredReturnType.isArray() && requiredReturnType.getComponentType() == actualReturnType) {                 Object array = Array.newInstance(requiredReturnType.getComponentType(), 1).                 Array.set(array, 0, attributeValue).                 attributes.put(attributeName, array).                 converted = true.             } else // Nested map representing a single annotation?             if (Annotation.class.isAssignableFrom(requiredReturnType) && Map.class.isAssignableFrom(actualReturnType)) {                 Class<? extends Annotation> nestedAnnotationType = (Class<? extends Annotation>) requiredReturnType.                 Map<String, Object> map = (Map<String, Object>) attributeValue.                 attributes.put(attributeName, AnnotationUtils.synthesizeAnnotation(map, nestedAnnotationType, null)).                 converted = true.             } else // Nested array of maps representing an array of annotations?             if (requiredReturnType.isArray() && actualReturnType.isArray() && Annotation.class.isAssignableFrom(requiredReturnType.getComponentType()) && Map.class.isAssignableFrom(actualReturnType.getComponentType())) {                 Class<? extends Annotation> nestedAnnotationType = (Class<? extends Annotation>) requiredReturnType.getComponentType().                 Map<String, Object>[] maps = (Map<String, Object>[]) attributeValue.                 attributes.put(attributeName, AnnotationUtils.synthesizeAnnotationArray(maps, nestedAnnotationType)).                 converted = true.             }             Assert.isTrue(converted, () -> String.format("Attributes map %s returned a value of type [%s] for attribute '%s', " + "but a value of type [%s] is required as defined by annotation type [%s].", attributes, actualReturnType.getName(), attributeName, requiredReturnType.getName(), annotationType.getName())).         }     }     return attributes. }
