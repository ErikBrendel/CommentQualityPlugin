commented;modifiers;parameterAmount;loc;comment;code
false;protected,final;0;3;;protected final float getLoadFactor() {     return this.loadFactor. }
false;protected,final;0;3;;protected final int getSegmentsSize() {     return this.segments.length. }
false;protected,final;1;3;;protected final Segment getSegment(int index) {     return this.segments[index]. }
true;protected;0;3;/**  * Factory method that returns the {@link ReferenceManager}.  * This method will be called once for each {@link Segment}.  * @return a new reference manager  */ ;/**  * Factory method that returns the {@link ReferenceManager}.  * This method will be called once for each {@link Segment}.  * @return a new reference manager  */ protected ReferenceManager createReferenceManager() {     return new ReferenceManager(). }
true;protected;1;10;/**  * Get the hash for a given object, apply an additional hash function to reduce  * collisions. This implementation uses the same Wang/Jenkins algorithm as  * {@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing.  * @param o the object to hash (may be null)  * @return the resulting hash code  */ ;/**  * Get the hash for a given object, apply an additional hash function to reduce  * collisions. This implementation uses the same Wang/Jenkins algorithm as  * {@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing.  * @param o the object to hash (may be null)  * @return the resulting hash code  */ protected int getHash(@Nullable Object o) {     int hash = (o != null ? o.hashCode() : 0).     hash += (hash << 15) ^ 0xffffcd7d.     hash ^= (hash >>> 10).     hash += (hash << 3).     hash ^= (hash >>> 6).     hash += (hash << 2) + (hash << 14).     hash ^= (hash >>> 16).     return hash. }
false;public;1;6;;@Override @Nullable public V get(@Nullable Object key) {     Entry<K, V> entry = getEntryIfAvailable(key).     return (entry != null ? entry.getValue() : null). }
false;public;2;6;;@Override @Nullable public V getOrDefault(@Nullable Object key, @Nullable V defaultValue) {     Entry<K, V> entry = getEntryIfAvailable(key).     return (entry != null ? entry.getValue() : defaultValue). }
false;public;1;5;;@Override public boolean containsKey(@Nullable Object key) {     Entry<K, V> entry = getEntryIfAvailable(key).     return (entry != null && ObjectUtils.nullSafeEquals(entry.getKey(), key)). }
false;private;1;5;;@Nullable private Entry<K, V> getEntryIfAvailable(@Nullable Object key) {     Reference<K, V> ref = getReference(key, Restructure.WHEN_NECESSARY).     return (ref != null ? ref.get() : null). }
true;protected,final;2;5;/**  * Return a {@link Reference} to the {@link Entry} for the specified {@code key},  * or {@code null} if not found.  * @param key the key (can be {@code null})  * @param restructure types of restructure allowed during this call  * @return the reference, or {@code null} if not found  */ ;/**  * Return a {@link Reference} to the {@link Entry} for the specified {@code key},  * or {@code null} if not found.  * @param key the key (can be {@code null})  * @param restructure types of restructure allowed during this call  * @return the reference, or {@code null} if not found  */ @Nullable protected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure) {     int hash = getHash(key).     return getSegmentForHash(hash).getReference(key, hash, restructure). }
false;public;2;5;;@Override @Nullable public V put(@Nullable K key, @Nullable V value) {     return put(key, value, true). }
false;public;2;5;;@Override @Nullable public V putIfAbsent(@Nullable K key, @Nullable V value) {     return put(key, value, false). }
false;protected;3;14;;@Override @Nullable protected V execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry, @Nullable Entries<V> entries) {     if (entry != null) {         V oldValue = entry.getValue().         if (overwriteExisting) {             entry.setValue(value).         }         return oldValue.     }     Assert.state(entries != null, "No entries segment").     entries.add(value).     return null. }
false;private;3;19;;@Nullable private V put(@Nullable final K key, @Nullable final V value, final boolean overwriteExisting) {     return doTask(key, new Task<V>(TaskOption.RESTRUCTURE_BEFORE, TaskOption.RESIZE) {          @Override         @Nullable         protected V execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry, @Nullable Entries<V> entries) {             if (entry != null) {                 V oldValue = entry.getValue().                 if (overwriteExisting) {                     entry.setValue(value).                 }                 return oldValue.             }             Assert.state(entries != null, "No entries segment").             entries.add(value).             return null.         }     }). }
false;protected;2;11;;@Override @Nullable protected V execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {     if (entry != null) {         if (ref != null) {             ref.release().         }         return entry.value.     }     return null. }
false;public;1;17;;@Override @Nullable public V remove(Object key) {     return doTask(key, new Task<V>(TaskOption.RESTRUCTURE_AFTER, TaskOption.SKIP_IF_EMPTY) {          @Override         @Nullable         protected V execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {             if (entry != null) {                 if (ref != null) {                     ref.release().                 }                 return entry.value.             }             return null.         }     }). }
false;protected;2;10;;@Override protected Boolean execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {     if (entry != null && ObjectUtils.nullSafeEquals(entry.getValue(), value)) {         if (ref != null) {             ref.release().         }         return true.     }     return false. }
false;public;2;16;;@Override public boolean remove(Object key, final Object value) {     Boolean result = doTask(key, new Task<Boolean>(TaskOption.RESTRUCTURE_AFTER, TaskOption.SKIP_IF_EMPTY) {          @Override         protected Boolean execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {             if (entry != null && ObjectUtils.nullSafeEquals(entry.getValue(), value)) {                 if (ref != null) {                     ref.release().                 }                 return true.             }             return false.         }     }).     return (result == Boolean.TRUE). }
false;protected;2;8;;@Override protected Boolean execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {     if (entry != null && ObjectUtils.nullSafeEquals(entry.getValue(), oldValue)) {         entry.setValue(newValue).         return true.     }     return false. }
false;public;3;14;;@Override public boolean replace(K key, final V oldValue, final V newValue) {     Boolean result = doTask(key, new Task<Boolean>(TaskOption.RESTRUCTURE_BEFORE, TaskOption.SKIP_IF_EMPTY) {          @Override         protected Boolean execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {             if (entry != null && ObjectUtils.nullSafeEquals(entry.getValue(), oldValue)) {                 entry.setValue(newValue).                 return true.             }             return false.         }     }).     return (result == Boolean.TRUE). }
false;protected;2;10;;@Override @Nullable protected V execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {     if (entry != null) {         V oldValue = entry.getValue().         entry.setValue(value).         return oldValue.     }     return null. }
false;public;2;16;;@Override @Nullable public V replace(K key, final V value) {     return doTask(key, new Task<V>(TaskOption.RESTRUCTURE_BEFORE, TaskOption.SKIP_IF_EMPTY) {          @Override         @Nullable         protected V execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {             if (entry != null) {                 V oldValue = entry.getValue().                 entry.setValue(value).                 return oldValue.             }             return null.         }     }). }
false;public;0;6;;@Override public void clear() {     for (Segment segment : this.segments) {         segment.clear().     } }
true;public;0;5;/**  * Remove any entries that have been garbage collected and are no longer referenced.  * Under normal circumstances garbage collected entries are automatically purged as  * items are added or removed from the Map. This method can be used to force a purge,  * and is useful when the Map is read frequently but updated less often.  */ ;/**  * Remove any entries that have been garbage collected and are no longer referenced.  * Under normal circumstances garbage collected entries are automatically purged as  * items are added or removed from the Map. This method can be used to force a purge,  * and is useful when the Map is read frequently but updated less often.  */ public void purgeUnreferencedEntries() {     for (Segment segment : this.segments) {         segment.restructureIfNecessary(false).     } }
false;public;0;8;;@Override public int size() {     int size = 0.     for (Segment segment : this.segments) {         size += segment.getCount().     }     return size. }
false;public;0;9;;@Override public boolean isEmpty() {     for (Segment segment : this.segments) {         if (segment.getCount() > 0) {             return false.         }     }     return true. }
false;public;0;9;;@Override public Set<Map.Entry<K, V>> entrySet() {     Set<Map.Entry<K, V>> entrySet = this.entrySet.     if (entrySet == null) {         entrySet = new EntrySet().         this.entrySet = entrySet.     }     return entrySet. }
false;private;2;5;;@Nullable private <T> T doTask(@Nullable Object key, Task<T> task) {     int hash = getHash(key).     return getSegmentForHash(hash).doTask(hash, key, task). }
false;private;1;3;;private Segment getSegmentForHash(int hash) {     return this.segments[(hash >>> (32 - this.shift)) & (this.segments.length - 1)]. }
true;protected,static;2;9;/**  * Calculate a shift value that can be used to create a power-of-two value between  * the specified maximum and minimum values.  * @param minimumValue the minimum value  * @param maximumValue the maximum value  * @return the calculated shift (use {@code 1 << shift} to obtain a value)  */ ;/**  * Calculate a shift value that can be used to create a power-of-two value between  * the specified maximum and minimum values.  * @param minimumValue the minimum value  * @param maximumValue the maximum value  * @return the calculated shift (use {@code 1 << shift} to obtain a value)  */ protected static int calculateShift(int minimumValue, int maximumValue) {     int shift = 0.     int value = 1.     while (value < minimumValue && value < maximumValue) {         value <<= 1.         shift++.     }     return shift. }
false;public;3;14;;@Nullable public Reference<K, V> getReference(@Nullable Object key, int hash, Restructure restructure) {     if (restructure == Restructure.WHEN_NECESSARY) {         restructureIfNecessary(false).     }     if (this.count.get() == 0) {         return null.     }     // Use a local copy to protect against other threads writing     Reference<K, V>[] references = this.references.     int index = getIndex(hash, references).     Reference<K, V> head = references[index].     return findInChain(head, key, hash). }
true;public;3;31;/**  * Apply an update operation to this segment.  * The segment will be locked during the update.  * @param hash the hash of the key  * @param key the key  * @param task the update operation  * @return the result of the operation  */ ;/**  * Apply an update operation to this segment.  * The segment will be locked during the update.  * @param hash the hash of the key  * @param key the key  * @param task the update operation  * @return the result of the operation  */ @Nullable public <T> T doTask(final int hash, @Nullable final Object key, final Task<T> task) {     boolean resize = task.hasOption(TaskOption.RESIZE).     if (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {         restructureIfNecessary(resize).     }     if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && this.count.get() == 0) {         return task.execute(null, null, null).     }     lock().     try {         final int index = getIndex(hash, this.references).         final Reference<K, V> head = this.references[index].         Reference<K, V> ref = findInChain(head, key, hash).         Entry<K, V> entry = (ref != null ? ref.get() : null).         Entries<V> entries = value -> {             @SuppressWarnings("unchecked")             Entry<K, V> newEntry = new Entry<>((K) key, value).             Reference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head).             Segment.this.references[index] = newReference.             Segment.this.count.incrementAndGet().         }.         return task.execute(ref, entry, entries).     } finally {         unlock().         if (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {             restructureIfNecessary(resize).         }     } }
true;public;0;14;/**  * Clear all items from this segment.  */ ;/**  * Clear all items from this segment.  */ public void clear() {     if (this.count.get() == 0) {         return.     }     lock().     try {         this.references = createReferenceArray(this.initialSize).         this.resizeThreshold = (int) (this.references.length * getLoadFactor()).         this.count.set(0).     } finally {         unlock().     } }
true;protected,final;1;63;/**  * Restructure the underlying data structure when it becomes necessary. This  * method can increase the size of the references table as well as purge any  * references that have been garbage collected.  * @param allowResize if resizing is permitted  */ ;/**  * Restructure the underlying data structure when it becomes necessary. This  * method can increase the size of the references table as well as purge any  * references that have been garbage collected.  * @param allowResize if resizing is permitted  */ protected final void restructureIfNecessary(boolean allowResize) {     int currCount = this.count.get().     boolean needsResize = (currCount > 0 && currCount >= this.resizeThreshold).     Reference<K, V> ref = this.referenceManager.pollForPurge().     if (ref != null || (needsResize && allowResize)) {         lock().         try {             int countAfterRestructure = this.count.get().             Set<Reference<K, V>> toPurge = Collections.emptySet().             if (ref != null) {                 toPurge = new HashSet<>().                 while (ref != null) {                     toPurge.add(ref).                     ref = this.referenceManager.pollForPurge().                 }             }             countAfterRestructure -= toPurge.size().             // Recalculate taking into account count inside lock and items that             // will be purged             needsResize = (countAfterRestructure > 0 && countAfterRestructure >= this.resizeThreshold).             boolean resizing = false.             int restructureSize = this.references.length.             if (allowResize && needsResize && restructureSize < MAXIMUM_SEGMENT_SIZE) {                 restructureSize <<= 1.                 resizing = true.             }             // Either create a new table or reuse the existing one             Reference<K, V>[] restructured = (resizing ? createReferenceArray(restructureSize) : this.references).             // Restructure             for (int i = 0. i < this.references.length. i++) {                 ref = this.references[i].                 if (!resizing) {                     restructured[i] = null.                 }                 while (ref != null) {                     if (!toPurge.contains(ref)) {                         Entry<K, V> entry = ref.get().                         if (entry != null) {                             int index = getIndex(ref.getHash(), restructured).                             restructured[index] = this.referenceManager.createReference(entry, ref.getHash(), restructured[index]).                         }                     }                     ref = ref.getNext().                 }             }             // Replace volatile members             if (resizing) {                 this.references = restructured.                 this.resizeThreshold = (int) (this.references.length * getLoadFactor()).             }             this.count.set(Math.max(countAfterRestructure, 0)).         } finally {             unlock().         }     } }
false;private;3;17;;@Nullable private Reference<K, V> findInChain(Reference<K, V> ref, @Nullable Object key, int hash) {     Reference<K, V> currRef = ref.     while (currRef != null) {         if (currRef.getHash() == hash) {             Entry<K, V> entry = currRef.get().             if (entry != null) {                 K entryKey = entry.getKey().                 if (ObjectUtils.nullSafeEquals(entryKey, key)) {                     return currRef.                 }             }         }         currRef = currRef.getNext().     }     return null. }
false;private;1;4;;@SuppressWarnings({ "rawtypes", "unchecked" }) private Reference<K, V>[] createReferenceArray(int size) {     return new Reference[size]. }
false;private;2;3;;private int getIndex(int hash, Reference<K, V>[] references) {     return (hash & (references.length - 1)). }
true;public,final;0;3;/**  * Return the size of the current references array.  */ ;/**  * Return the size of the current references array.  */ public final int getSize() {     return this.references.length. }
true;public,final;0;3;/**  * Return the total number of references in this segment.  */ ;/**  * Return the total number of references in this segment.  */ public final int getCount() {     return this.count.get(). }
true;;0;2;/**  * Return the referenced entry, or {@code null} if the entry is no longer available.  */ ;/**  * Return the referenced entry, or {@code null} if the entry is no longer available.  */ @Nullable Entry<K, V> get().
true;;0;1;/**  * Return the hash for the reference.  */ ;/**  * Return the hash for the reference.  */ int getHash().
true;;0;2;/**  * Return the next reference in the chain, or {@code null} if none.  */ ;/**  * Return the next reference in the chain, or {@code null} if none.  */ @Nullable Reference<K, V> getNext().
true;;0;1;/**  * Release this entry and ensure that it will be returned from  * {@code ReferenceManager#pollForPurge()}.  */ ;/**  * Release this entry and ensure that it will be returned from  * {@code ReferenceManager#pollForPurge()}.  */ void release().
false;public;0;5;;@Override @Nullable public K getKey() {     return this.key. }
false;public;0;5;;@Override @Nullable public V getValue() {     return this.value. }
false;public;1;7;;@Override @Nullable public V setValue(@Nullable V value) {     V previous = this.value.     this.value = value.     return previous. }
false;public;0;4;;@Override public String toString() {     return (this.key + "=" + this.value). }
false;public,final;1;13;;@Override @SuppressWarnings("rawtypes") public final boolean equals(Object other) {     if (this == other) {         return true.     }     if (!(other instanceof Map.Entry)) {         return false.     }     Map.Entry otherEntry = (Map.Entry) other.     return (ObjectUtils.nullSafeEquals(getKey(), otherEntry.getKey()) && ObjectUtils.nullSafeEquals(getValue(), otherEntry.getValue())). }
false;public,final;0;4;;@Override public final int hashCode() {     return (ObjectUtils.nullSafeHashCode(this.key) ^ ObjectUtils.nullSafeHashCode(this.value)). }
false;public;1;3;;public boolean hasOption(TaskOption option) {     return this.options.contains(option). }
true;protected;3;4;/**  * Execute the task.  * @param ref the found reference (or {@code null})  * @param entry the found entry (or {@code null})  * @param entries access to the underlying entries  * @return the result of the task  * @see #execute(Reference, Entry)  */ ;/**  * Execute the task.  * @param ref the found reference (or {@code null})  * @param entry the found entry (or {@code null})  * @param entries access to the underlying entries  * @return the result of the task  * @see #execute(Reference, Entry)  */ @Nullable protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry, @Nullable Entries<V> entries) {     return execute(ref, entry). }
true;protected;2;4;/**  * Convenience method that can be used for tasks that do not need access to {@link Entries}.  * @param ref the found reference (or {@code null})  * @param entry the found entry (or {@code null})  * @return the result of the task  * @see #execute(Reference, Entry, Entries)  */ ;/**  * Convenience method that can be used for tasks that do not need access to {@link Entries}.  * @param ref the found reference (or {@code null})  * @param entry the found entry (or {@code null})  * @return the result of the task  * @see #execute(Reference, Entry, Entries)  */ @Nullable protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {     return null. }
true;;1;1;/**  * Add a new entry with the specified value.  * @param value the value to add  */ ;/**  * Add a new entry with the specified value.  * @param value the value to add  */ void add(@Nullable V value).
false;public;0;4;;@Override public Iterator<Map.Entry<K, V>> iterator() {     return new EntryIterator(). }
false;public;1;12;;@Override public boolean contains(@Nullable Object o) {     if (o instanceof Map.Entry<?, ?>) {         Map.Entry<?, ?> entry = (Map.Entry<?, ?>) o.         Reference<K, V> ref = ConcurrentReferenceHashMap.this.getReference(entry.getKey(), Restructure.NEVER).         Entry<K, V> otherEntry = (ref != null ? ref.get() : null).         if (otherEntry != null) {             return ObjectUtils.nullSafeEquals(otherEntry.getValue(), otherEntry.getValue()).         }     }     return false. }
false;public;1;8;;@Override public boolean remove(Object o) {     if (o instanceof Map.Entry<?, ?>) {         Map.Entry<?, ?> entry = (Map.Entry<?, ?>) o.         return ConcurrentReferenceHashMap.this.remove(entry.getKey(), entry.getValue()).     }     return false. }
false;public;0;4;;@Override public int size() {     return ConcurrentReferenceHashMap.this.size(). }
false;public;0;4;;@Override public void clear() {     ConcurrentReferenceHashMap.this.clear(). }
false;public;0;5;;@Override public boolean hasNext() {     getNextIfNecessary().     return (this.next != null). }
false;public;0;10;;@Override public Entry<K, V> next() {     getNextIfNecessary().     if (this.next == null) {         throw new NoSuchElementException().     }     this.last = this.next.     this.next = null.     return this.last. }
false;private;0;9;;private void getNextIfNecessary() {     while (this.next == null) {         moveToNextReference().         if (this.reference == null) {             return.         }         this.next = this.reference.get().     } }
false;private;0;15;;private void moveToNextReference() {     if (this.reference != null) {         this.reference = this.reference.getNext().     }     while (this.reference == null && this.references != null) {         if (this.referenceIndex >= this.references.length) {             moveToNextSegment().             this.referenceIndex = 0.         } else {             this.reference = this.references[this.referenceIndex].             this.referenceIndex++.         }     } }
false;private;0;8;;private void moveToNextSegment() {     this.reference = null.     this.references = null.     if (this.segmentIndex < ConcurrentReferenceHashMap.this.segments.length) {         this.references = ConcurrentReferenceHashMap.this.segments[this.segmentIndex].references.         this.segmentIndex++.     } }
false;public;0;5;;@Override public void remove() {     Assert.state(this.last != null, "No element to remove").     ConcurrentReferenceHashMap.this.remove(this.last.getKey()). }
true;public;3;6;/**  * Factory method used to create a new {@link Reference}.  * @param entry the entry contained in the reference  * @param hash the hash  * @param next the next reference in the chain, or {@code null} if none  * @return a new {@link Reference}  */ ;/**  * Factory method used to create a new {@link Reference}.  * @param entry the entry contained in the reference  * @param hash the hash  * @param next the next reference in the chain, or {@code null} if none  * @return a new {@link Reference}  */ public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next) {     if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {         return new WeakEntryReference<>(entry, hash, next, this.queue).     }     return new SoftEntryReference<>(entry, hash, next, this.queue). }
true;public;0;5;/**  * Return any reference that has been garbage collected and can be purged from the  * underlying structure or {@code null} if no references need purging. This  * method must be thread safe and ideally should not block when returning  * {@code null}. References should be returned once and only once.  * @return a reference to purge or {@code null}  */ ;/**  * Return any reference that has been garbage collected and can be purged from the  * underlying structure or {@code null} if no references need purging. This  * method must be thread safe and ideally should not block when returning  * {@code null}. References should be returned once and only once.  * @return a reference to purge or {@code null}  */ @SuppressWarnings("unchecked") @Nullable public Reference<K, V> pollForPurge() {     return (Reference<K, V>) this.queue.poll(). }
false;public;0;4;;@Override public int getHash() {     return this.hash. }
false;public;0;5;;@Override @Nullable public Reference<K, V> getNext() {     return this.nextReference. }
false;public;0;5;;@Override public void release() {     enqueue().     clear(). }
false;public;0;4;;@Override public int getHash() {     return this.hash. }
false;public;0;5;;@Override @Nullable public Reference<K, V> getNext() {     return this.nextReference. }
false;public;0;5;;@Override public void release() {     enqueue().     clear(). }
