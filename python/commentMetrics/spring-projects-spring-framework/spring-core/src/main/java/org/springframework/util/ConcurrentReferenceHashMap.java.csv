# id;timestamp;commentText;codeText;commentWords;codeWords
ConcurrentReferenceHashMap -> protected ReferenceManager createReferenceManager();1351982790;Factory method that returns the {@link ReferenceManager}. This method will be_called once for each {@link Segment}._@return a new reference manager;protected ReferenceManager createReferenceManager() {_		return new ReferenceManager()__	};factory,method,that,returns,the,link,reference,manager,this,method,will,be,called,once,for,each,link,segment,return,a,new,reference,manager;protected,reference,manager,create,reference,manager,return,new,reference,manager
ConcurrentReferenceHashMap -> protected ReferenceManager createReferenceManager();1352039846;Factory method that returns the {@link ReferenceManager}. This method will be_called once for each {@link Segment}._@return a new reference manager;protected ReferenceManager createReferenceManager() {_		return new ReferenceManager()__	};factory,method,that,returns,the,link,reference,manager,this,method,will,be,called,once,for,each,link,segment,return,a,new,reference,manager;protected,reference,manager,create,reference,manager,return,new,reference,manager
ConcurrentReferenceHashMap -> protected ReferenceManager createReferenceManager();1355313310;Factory method that returns the {@link ReferenceManager}. This method will be_called once for each {@link Segment}._@return a new reference manager;protected ReferenceManager createReferenceManager() {_		return new ReferenceManager()__	};factory,method,that,returns,the,link,reference,manager,this,method,will,be,called,once,for,each,link,segment,return,a,new,reference,manager;protected,reference,manager,create,reference,manager,return,new,reference,manager
ConcurrentReferenceHashMap -> protected ReferenceManager createReferenceManager();1356735495;Factory method that returns the {@link ReferenceManager}. This method will be_called once for each {@link Segment}._@return a new reference manager;protected ReferenceManager createReferenceManager() {_		return new ReferenceManager()__	};factory,method,that,returns,the,link,reference,manager,this,method,will,be,called,once,for,each,link,segment,return,a,new,reference,manager;protected,reference,manager,create,reference,manager,return,new,reference,manager
ConcurrentReferenceHashMap -> protected ReferenceManager createReferenceManager();1357119239;Factory method that returns the {@link ReferenceManager}. This method will be_called once for each {@link Segment}._@return a new reference manager;protected ReferenceManager createReferenceManager() {_		return new ReferenceManager()__	};factory,method,that,returns,the,link,reference,manager,this,method,will,be,called,once,for,each,link,segment,return,a,new,reference,manager;protected,reference,manager,create,reference,manager,return,new,reference,manager
ConcurrentReferenceHashMap -> protected ReferenceManager createReferenceManager();1368482696;Factory method that returns the {@link ReferenceManager}. This method will be_called once for each {@link Segment}._@return a new reference manager;protected ReferenceManager createReferenceManager() {_		return new ReferenceManager()__	};factory,method,that,returns,the,link,reference,manager,this,method,will,be,called,once,for,each,link,segment,return,a,new,reference,manager;protected,reference,manager,create,reference,manager,return,new,reference,manager
ConcurrentReferenceHashMap -> protected ReferenceManager createReferenceManager();1383090835;Factory method that returns the {@link ReferenceManager}. This method will be_called once for each {@link Segment}._@return a new reference manager;protected ReferenceManager createReferenceManager() {_		return new ReferenceManager()__	};factory,method,that,returns,the,link,reference,manager,this,method,will,be,called,once,for,each,link,segment,return,a,new,reference,manager;protected,reference,manager,create,reference,manager,return,new,reference,manager
ConcurrentReferenceHashMap -> protected ReferenceManager createReferenceManager();1383178438;Factory method that returns the {@link ReferenceManager}. This method will be_called once for each {@link Segment}._@return a new reference manager;protected ReferenceManager createReferenceManager() {_		return new ReferenceManager()__	};factory,method,that,returns,the,link,reference,manager,this,method,will,be,called,once,for,each,link,segment,return,a,new,reference,manager;protected,reference,manager,create,reference,manager,return,new,reference,manager
ConcurrentReferenceHashMap -> protected ReferenceManager createReferenceManager();1390260938;Factory method that returns the {@link ReferenceManager}. This method will be_called once for each {@link Segment}._@return a new reference manager;protected ReferenceManager createReferenceManager() {_		return new ReferenceManager()__	};factory,method,that,returns,the,link,reference,manager,this,method,will,be,called,once,for,each,link,segment,return,a,new,reference,manager;protected,reference,manager,create,reference,manager,return,new,reference,manager
ConcurrentReferenceHashMap -> protected ReferenceManager createReferenceManager();1391715359;Factory method that returns the {@link ReferenceManager}._This method will be called once for each {@link Segment}._@return a new reference manager;protected ReferenceManager createReferenceManager() {_		return new ReferenceManager()__	};factory,method,that,returns,the,link,reference,manager,this,method,will,be,called,once,for,each,link,segment,return,a,new,reference,manager;protected,reference,manager,create,reference,manager,return,new,reference,manager
ConcurrentReferenceHashMap -> protected ReferenceManager createReferenceManager();1392765030;Factory method that returns the {@link ReferenceManager}._This method will be called once for each {@link Segment}._@return a new reference manager;protected ReferenceManager createReferenceManager() {_		return new ReferenceManager()__	};factory,method,that,returns,the,link,reference,manager,this,method,will,be,called,once,for,each,link,segment,return,a,new,reference,manager;protected,reference,manager,create,reference,manager,return,new,reference,manager
ConcurrentReferenceHashMap -> protected ReferenceManager createReferenceManager();1398175099;Factory method that returns the {@link ReferenceManager}._This method will be called once for each {@link Segment}._@return a new reference manager;protected ReferenceManager createReferenceManager() {_		return new ReferenceManager()__	};factory,method,that,returns,the,link,reference,manager,this,method,will,be,called,once,for,each,link,segment,return,a,new,reference,manager;protected,reference,manager,create,reference,manager,return,new,reference,manager
ConcurrentReferenceHashMap -> protected ReferenceManager createReferenceManager();1404132943;Factory method that returns the {@link ReferenceManager}._This method will be called once for each {@link Segment}._@return a new reference manager;protected ReferenceManager createReferenceManager() {_		return new ReferenceManager()__	};factory,method,that,returns,the,link,reference,manager,this,method,will,be,called,once,for,each,link,segment,return,a,new,reference,manager;protected,reference,manager,create,reference,manager,return,new,reference,manager
ConcurrentReferenceHashMap -> protected ReferenceManager createReferenceManager();1427240641;Factory method that returns the {@link ReferenceManager}._This method will be called once for each {@link Segment}._@return a new reference manager;protected ReferenceManager createReferenceManager() {_		return new ReferenceManager()__	};factory,method,that,returns,the,link,reference,manager,this,method,will,be,called,once,for,each,link,segment,return,a,new,reference,manager;protected,reference,manager,create,reference,manager,return,new,reference,manager
ConcurrentReferenceHashMap -> protected ReferenceManager createReferenceManager();1459795890;Factory method that returns the {@link ReferenceManager}._This method will be called once for each {@link Segment}._@return a new reference manager;protected ReferenceManager createReferenceManager() {_		return new ReferenceManager()__	};factory,method,that,returns,the,link,reference,manager,this,method,will,be,called,once,for,each,link,segment,return,a,new,reference,manager;protected,reference,manager,create,reference,manager,return,new,reference,manager
ConcurrentReferenceHashMap -> protected ReferenceManager createReferenceManager();1467730834;Factory method that returns the {@link ReferenceManager}._This method will be called once for each {@link Segment}._@return a new reference manager;protected ReferenceManager createReferenceManager() {_		return new ReferenceManager()__	};factory,method,that,returns,the,link,reference,manager,this,method,will,be,called,once,for,each,link,segment,return,a,new,reference,manager;protected,reference,manager,create,reference,manager,return,new,reference,manager
ConcurrentReferenceHashMap -> protected ReferenceManager createReferenceManager();1485810955;Factory method that returns the {@link ReferenceManager}._This method will be called once for each {@link Segment}._@return a new reference manager;protected ReferenceManager createReferenceManager() {_		return new ReferenceManager()__	};factory,method,that,returns,the,link,reference,manager,this,method,will,be,called,once,for,each,link,segment,return,a,new,reference,manager;protected,reference,manager,create,reference,manager,return,new,reference,manager
ConcurrentReferenceHashMap -> protected ReferenceManager createReferenceManager();1495868221;Factory method that returns the {@link ReferenceManager}._This method will be called once for each {@link Segment}._@return a new reference manager;protected ReferenceManager createReferenceManager() {_		return new ReferenceManager()__	};factory,method,that,returns,the,link,reference,manager,this,method,will,be,called,once,for,each,link,segment,return,a,new,reference,manager;protected,reference,manager,create,reference,manager,return,new,reference,manager
ConcurrentReferenceHashMap -> protected ReferenceManager createReferenceManager();1496242568;Factory method that returns the {@link ReferenceManager}._This method will be called once for each {@link Segment}._@return a new reference manager;protected ReferenceManager createReferenceManager() {_		return new ReferenceManager()__	};factory,method,that,returns,the,link,reference,manager,this,method,will,be,called,once,for,each,link,segment,return,a,new,reference,manager;protected,reference,manager,create,reference,manager,return,new,reference,manager
ConcurrentReferenceHashMap -> protected ReferenceManager createReferenceManager();1496837955;Factory method that returns the {@link ReferenceManager}._This method will be called once for each {@link Segment}._@return a new reference manager;protected ReferenceManager createReferenceManager() {_		return new ReferenceManager()__	};factory,method,that,returns,the,link,reference,manager,this,method,will,be,called,once,for,each,link,segment,return,a,new,reference,manager;protected,reference,manager,create,reference,manager,return,new,reference,manager
ConcurrentReferenceHashMap -> protected ReferenceManager createReferenceManager();1498780456;Factory method that returns the {@link ReferenceManager}._This method will be called once for each {@link Segment}._@return a new reference manager;protected ReferenceManager createReferenceManager() {_		return new ReferenceManager()__	};factory,method,that,returns,the,link,reference,manager,this,method,will,be,called,once,for,each,link,segment,return,a,new,reference,manager;protected,reference,manager,create,reference,manager,return,new,reference,manager
ConcurrentReferenceHashMap -> protected ReferenceManager createReferenceManager();1502974979;Factory method that returns the {@link ReferenceManager}._This method will be called once for each {@link Segment}._@return a new reference manager;protected ReferenceManager createReferenceManager() {_		return new ReferenceManager()__	};factory,method,that,returns,the,link,reference,manager,this,method,will,be,called,once,for,each,link,segment,return,a,new,reference,manager;protected,reference,manager,create,reference,manager,return,new,reference,manager
ConcurrentReferenceHashMap -> protected ReferenceManager createReferenceManager();1506097334;Factory method that returns the {@link ReferenceManager}._This method will be called once for each {@link Segment}._@return a new reference manager;protected ReferenceManager createReferenceManager() {_		return new ReferenceManager()__	};factory,method,that,returns,the,link,reference,manager,this,method,will,be,called,once,for,each,link,segment,return,a,new,reference,manager;protected,reference,manager,create,reference,manager,return,new,reference,manager
ConcurrentReferenceHashMap -> protected ReferenceManager createReferenceManager();1521044224;Factory method that returns the {@link ReferenceManager}._This method will be called once for each {@link Segment}._@return a new reference manager;protected ReferenceManager createReferenceManager() {_		return new ReferenceManager()__	};factory,method,that,returns,the,link,reference,manager,this,method,will,be,called,once,for,each,link,segment,return,a,new,reference,manager;protected,reference,manager,create,reference,manager,return,new,reference,manager
ConcurrentReferenceHashMap -> protected ReferenceManager createReferenceManager();1530174524;Factory method that returns the {@link ReferenceManager}._This method will be called once for each {@link Segment}._@return a new reference manager;protected ReferenceManager createReferenceManager() {_		return new ReferenceManager()__	};factory,method,that,returns,the,link,reference,manager,this,method,will,be,called,once,for,each,link,segment,return,a,new,reference,manager;protected,reference,manager,create,reference,manager,return,new,reference,manager
ConcurrentReferenceHashMap -> protected ReferenceManager createReferenceManager();1530190293;Factory method that returns the {@link ReferenceManager}._This method will be called once for each {@link Segment}._@return a new reference manager;protected ReferenceManager createReferenceManager() {_		return new ReferenceManager()__	};factory,method,that,returns,the,link,reference,manager,this,method,will,be,called,once,for,each,link,segment,return,a,new,reference,manager;protected,reference,manager,create,reference,manager,return,new,reference,manager
ConcurrentReferenceHashMap -> protected ReferenceManager createReferenceManager();1530563577;Factory method that returns the {@link ReferenceManager}._This method will be called once for each {@link Segment}._@return a new reference manager;protected ReferenceManager createReferenceManager() {_		return new ReferenceManager()__	};factory,method,that,returns,the,link,reference,manager,this,method,will,be,called,once,for,each,link,segment,return,a,new,reference,manager;protected,reference,manager,create,reference,manager,return,new,reference,manager
ConcurrentReferenceHashMap -> protected ReferenceManager createReferenceManager();1531136363;Factory method that returns the {@link ReferenceManager}._This method will be called once for each {@link Segment}._@return a new reference manager;protected ReferenceManager createReferenceManager() {_		return new ReferenceManager()__	};factory,method,that,returns,the,link,reference,manager,this,method,will,be,called,once,for,each,link,segment,return,a,new,reference,manager;protected,reference,manager,create,reference,manager,return,new,reference,manager
ConcurrentReferenceHashMap -> protected ReferenceManager createReferenceManager();1531139295;Factory method that returns the {@link ReferenceManager}._This method will be called once for each {@link Segment}._@return a new reference manager;protected ReferenceManager createReferenceManager() {_		return new ReferenceManager()__	};factory,method,that,returns,the,link,reference,manager,this,method,will,be,called,once,for,each,link,segment,return,a,new,reference,manager;protected,reference,manager,create,reference,manager,return,new,reference,manager
ConcurrentReferenceHashMap -> protected ReferenceManager createReferenceManager();1544716668;Factory method that returns the {@link ReferenceManager}._This method will be called once for each {@link Segment}._@return a new reference manager;protected ReferenceManager createReferenceManager() {_		return new ReferenceManager()__	};factory,method,that,returns,the,link,reference,manager,this,method,will,be,called,once,for,each,link,segment,return,a,new,reference,manager;protected,reference,manager,create,reference,manager,return,new,reference,manager
ConcurrentReferenceHashMap -> protected ReferenceManager createReferenceManager();1549318940;Factory method that returns the {@link ReferenceManager}._This method will be called once for each {@link Segment}._@return a new reference manager;protected ReferenceManager createReferenceManager() {_		return new ReferenceManager()__	};factory,method,that,returns,the,link,reference,manager,this,method,will,be,called,once,for,each,link,segment,return,a,new,reference,manager;protected,reference,manager,create,reference,manager,return,new,reference,manager
ConcurrentReferenceHashMap -> protected ReferenceManager createReferenceManager();1549321822;Factory method that returns the {@link ReferenceManager}._This method will be called once for each {@link Segment}._@return a new reference manager;protected ReferenceManager createReferenceManager() {_		return new ReferenceManager()__	};factory,method,that,returns,the,link,reference,manager,this,method,will,be,called,once,for,each,link,segment,return,a,new,reference,manager;protected,reference,manager,create,reference,manager,return,new,reference,manager
ConcurrentReferenceHashMap -> protected ReferenceManager createReferenceManager();1550237263;Factory method that returns the {@link ReferenceManager}._This method will be called once for each {@link Segment}._@return a new reference manager;protected ReferenceManager createReferenceManager() {_		return new ReferenceManager()__	};factory,method,that,returns,the,link,reference,manager,this,method,will,be,called,once,for,each,link,segment,return,a,new,reference,manager;protected,reference,manager,create,reference,manager,return,new,reference,manager
ConcurrentReferenceHashMap -> Segment -> public final int getCount();1351982790;@return the total number of references in this segment;public final int getCount() {_			return this.count__		};return,the,total,number,of,references,in,this,segment;public,final,int,get,count,return,this,count
ConcurrentReferenceHashMap -> Segment -> public final int getCount();1352039846;@return the total number of references in this segment;public final int getCount() {_			return this.count__		};return,the,total,number,of,references,in,this,segment;public,final,int,get,count,return,this,count
ConcurrentReferenceHashMap -> Segment -> public final int getCount();1355313310;@return the total number of references in this segment;public final int getCount() {_			return this.count__		};return,the,total,number,of,references,in,this,segment;public,final,int,get,count,return,this,count
ConcurrentReferenceHashMap -> Segment -> public final int getCount();1356735495;@return the total number of references in this segment;public final int getCount() {_			return this.count__		};return,the,total,number,of,references,in,this,segment;public,final,int,get,count,return,this,count
ConcurrentReferenceHashMap -> Segment -> public final int getCount();1357119239;@return the total number of references in this segment;public final int getCount() {_			return this.count__		};return,the,total,number,of,references,in,this,segment;public,final,int,get,count,return,this,count
ConcurrentReferenceHashMap -> Segment -> public final int getCount();1368482696;@return the total number of references in this segment;public final int getCount() {_			return this.count__		};return,the,total,number,of,references,in,this,segment;public,final,int,get,count,return,this,count
ConcurrentReferenceHashMap -> Segment -> public final int getCount();1383090835;@return the total number of references in this segment;public final int getCount() {_			return this.count__		};return,the,total,number,of,references,in,this,segment;public,final,int,get,count,return,this,count
ConcurrentReferenceHashMap -> Segment -> public final int getCount();1383178438;@return the total number of references in this segment;public final int getCount() {_			return this.count__		};return,the,total,number,of,references,in,this,segment;public,final,int,get,count,return,this,count
ConcurrentReferenceHashMap -> Segment -> public final int getCount();1390260938;@return the total number of references in this segment;public final int getCount() {_			return this.count__		};return,the,total,number,of,references,in,this,segment;public,final,int,get,count,return,this,count
ConcurrentReferenceHashMap -> Segment -> public final int getCount();1391715359;@return the total number of references in this segment;public final int getCount() {_			return this.count__		};return,the,total,number,of,references,in,this,segment;public,final,int,get,count,return,this,count
ConcurrentReferenceHashMap -> Segment -> public final int getCount();1392765030;@return the total number of references in this segment;public final int getCount() {_			return this.count__		};return,the,total,number,of,references,in,this,segment;public,final,int,get,count,return,this,count
ConcurrentReferenceHashMap -> Segment -> public final int getCount();1398175099;@return the total number of references in this segment;public final int getCount() {_			return this.count__		};return,the,total,number,of,references,in,this,segment;public,final,int,get,count,return,this,count
ConcurrentReferenceHashMap -> Segment -> public final int getCount();1404132943;@return the total number of references in this segment;public final int getCount() {_			return this.count__		};return,the,total,number,of,references,in,this,segment;public,final,int,get,count,return,this,count
ConcurrentReferenceHashMap -> Segment -> public final int getCount();1427240641;@return the total number of references in this segment;public final int getCount() {_			return this.count__		};return,the,total,number,of,references,in,this,segment;public,final,int,get,count,return,this,count
ConcurrentReferenceHashMap -> Segment -> public final int getCount();1459795890;@return the total number of references in this segment;public final int getCount() {_			return this.count__		};return,the,total,number,of,references,in,this,segment;public,final,int,get,count,return,this,count
ConcurrentReferenceHashMap -> Segment -> public final int getCount();1467730834;@return the total number of references in this segment;public final int getCount() {_			return this.count__		};return,the,total,number,of,references,in,this,segment;public,final,int,get,count,return,this,count
ConcurrentReferenceHashMap -> Segment -> public final int getCount();1485810955;@return the total number of references in this segment;public final int getCount() {_			return this.count__		};return,the,total,number,of,references,in,this,segment;public,final,int,get,count,return,this,count
ConcurrentReferenceHashMap -> Segment -> public final int getCount();1495868221;@return the total number of references in this segment;public final int getCount() {_			return this.count__		};return,the,total,number,of,references,in,this,segment;public,final,int,get,count,return,this,count
ConcurrentReferenceHashMap -> Segment -> public final int getCount();1496242568;@return the total number of references in this segment;public final int getCount() {_			return this.count__		};return,the,total,number,of,references,in,this,segment;public,final,int,get,count,return,this,count
ConcurrentReferenceHashMap -> Segment -> public final int getCount();1496837955;@return the total number of references in this segment;public final int getCount() {_			return this.count__		};return,the,total,number,of,references,in,this,segment;public,final,int,get,count,return,this,count
ConcurrentReferenceHashMap -> Segment -> public final int getCount();1498780456;Return the total number of references in this segment.;public final int getCount() {_			return this.count__		};return,the,total,number,of,references,in,this,segment;public,final,int,get,count,return,this,count
ConcurrentReferenceHashMap -> Segment -> public final int getCount();1502974979;Return the total number of references in this segment.;public final int getCount() {_			return this.count__		};return,the,total,number,of,references,in,this,segment;public,final,int,get,count,return,this,count
ConcurrentReferenceHashMap -> Segment -> public final int getCount();1506097334;Return the total number of references in this segment.;public final int getCount() {_			return this.count__		};return,the,total,number,of,references,in,this,segment;public,final,int,get,count,return,this,count
ConcurrentReferenceHashMap -> Segment -> public final int getCount();1521044224;Return the total number of references in this segment.;public final int getCount() {_			return this.count__		};return,the,total,number,of,references,in,this,segment;public,final,int,get,count,return,this,count
ConcurrentReferenceHashMap -> Segment -> public final int getCount();1530174524;Return the total number of references in this segment.;public final int getCount() {_			return this.count__		};return,the,total,number,of,references,in,this,segment;public,final,int,get,count,return,this,count
ConcurrentReferenceHashMap -> Segment -> public final int getCount();1530190293;Return the total number of references in this segment.;public final int getCount() {_			return this.count__		};return,the,total,number,of,references,in,this,segment;public,final,int,get,count,return,this,count
ConcurrentReferenceHashMap -> Segment -> public final int getCount();1530563577;Return the total number of references in this segment.;public final int getCount() {_			return this.count__		};return,the,total,number,of,references,in,this,segment;public,final,int,get,count,return,this,count
ConcurrentReferenceHashMap -> Segment -> public final int getCount();1531136363;Return the total number of references in this segment.;public final int getCount() {_			return this.count__		};return,the,total,number,of,references,in,this,segment;public,final,int,get,count,return,this,count
ConcurrentReferenceHashMap -> Segment -> public final int getCount();1531139295;Return the total number of references in this segment.;public final int getCount() {_			return this.count__		};return,the,total,number,of,references,in,this,segment;public,final,int,get,count,return,this,count
ConcurrentReferenceHashMap -> Segment -> public final int getCount();1544716668;Return the total number of references in this segment.;public final int getCount() {_			return this.count__		};return,the,total,number,of,references,in,this,segment;public,final,int,get,count,return,this,count
ConcurrentReferenceHashMap -> Segment -> public final int getCount();1549318940;Return the total number of references in this segment.;public final int getCount() {_			return this.count.get()__		};return,the,total,number,of,references,in,this,segment;public,final,int,get,count,return,this,count,get
ConcurrentReferenceHashMap -> Segment -> public final int getCount();1549321822;Return the total number of references in this segment.;public final int getCount() {_			return this.count.get()__		};return,the,total,number,of,references,in,this,segment;public,final,int,get,count,return,this,count,get
ConcurrentReferenceHashMap -> Segment -> public final int getCount();1550237263;Return the total number of references in this segment.;public final int getCount() {_			return this.count.get()__		};return,the,total,number,of,references,in,this,segment;public,final,int,get,count,return,this,count,get
ConcurrentReferenceHashMap -> Segment -> private void restructureIfNecessary(boolean allowResize);1351982790;Restructure the underlying data structure when it becomes necessary. This_method can increase the size of the references table as well as purge any_references that have been garbage collected._@param allowResize if resizing is permitted;private void restructureIfNecessary(boolean allowResize) {_			boolean needsResize = ((this.count > 0) && (this.count >= this.resizeThreshold))__			Reference<K, V> reference = this.referenceManager.pollForPurge()__			if ((reference != null) || (needsResize && allowResize)) {_				lock()__				try {_					int countAfterRestructure = this.count___					Set<Reference<K, V>> toPurge = Collections.emptySet()__					if (reference != null) {_						toPurge = new HashSet<Reference<K, V>>()__						while (reference != null) {_							toPurge.add(reference)__							reference = this.referenceManager.pollForPurge()__						}_					}_					countAfterRestructure -= toPurge.size()___					_					_					needsResize = ((countAfterRestructure > 0) && (countAfterRestructure >= this.resizeThreshold))__					boolean resizing = false__					int restructureSize = this.references.length__					if (allowResize && needsResize && (restructureSize < MAXIMUM_SEGMENT_SIZE)) {_						restructureSize <<= 1__						resizing = true__					}__					_					Reference<K, V>[] restructured =  (resizing ? createReferenceArray(restructureSize) : this.references)___					_					for (int i = 0_ i < this.references.length_ i++) {_						reference = this.references[i]__						if (!resizing) {_							restructured[i] = null__						}_						while (reference != null) {_							if (!toPurge.contains(reference)) {_								int index = getIndex(reference.getHash(), restructured)__								restructured[index] = this.referenceManager.createReference(_										reference.get(), reference.getHash(),_										restructured[index])__							}_							reference = reference.getNext()__						}_					}__					_					if (resizing) {_						setReferences(restructured)__					}_					this.count = countAfterRestructure__				} finally {_					unlock()__				}_			}_		};restructure,the,underlying,data,structure,when,it,becomes,necessary,this,method,can,increase,the,size,of,the,references,table,as,well,as,purge,any,references,that,have,been,garbage,collected,param,allow,resize,if,resizing,is,permitted;private,void,restructure,if,necessary,boolean,allow,resize,boolean,needs,resize,this,count,0,this,count,this,resize,threshold,reference,k,v,reference,this,reference,manager,poll,for,purge,if,reference,null,needs,resize,allow,resize,lock,try,int,count,after,restructure,this,count,set,reference,k,v,to,purge,collections,empty,set,if,reference,null,to,purge,new,hash,set,reference,k,v,while,reference,null,to,purge,add,reference,reference,this,reference,manager,poll,for,purge,count,after,restructure,to,purge,size,needs,resize,count,after,restructure,0,count,after,restructure,this,resize,threshold,boolean,resizing,false,int,restructure,size,this,references,length,if,allow,resize,needs,resize,restructure,size,restructure,size,1,resizing,true,reference,k,v,restructured,resizing,create,reference,array,restructure,size,this,references,for,int,i,0,i,this,references,length,i,reference,this,references,i,if,resizing,restructured,i,null,while,reference,null,if,to,purge,contains,reference,int,index,get,index,reference,get,hash,restructured,restructured,index,this,reference,manager,create,reference,reference,get,reference,get,hash,restructured,index,reference,reference,get,next,if,resizing,set,references,restructured,this,count,count,after,restructure,finally,unlock
ConcurrentReferenceHashMap -> Segment -> private void restructureIfNecessary(boolean allowResize);1352039846;Restructure the underlying data structure when it becomes necessary. This_method can increase the size of the references table as well as purge any_references that have been garbage collected._@param allowResize if resizing is permitted;private void restructureIfNecessary(boolean allowResize) {_			boolean needsResize = ((this.count > 0) && (this.count >= this.resizeThreshold))__			Reference<K, V> reference = this.referenceManager.pollForPurge()__			if ((reference != null) || (needsResize && allowResize)) {_				lock()__				try {_					int countAfterRestructure = this.count___					Set<Reference<K, V>> toPurge = Collections.emptySet()__					if (reference != null) {_						toPurge = new HashSet<Reference<K, V>>()__						while (reference != null) {_							toPurge.add(reference)__							reference = this.referenceManager.pollForPurge()__						}_					}_					countAfterRestructure -= toPurge.size()___					_					_					needsResize = ((countAfterRestructure > 0) && (countAfterRestructure >= this.resizeThreshold))__					boolean resizing = false__					int restructureSize = this.references.length__					if (allowResize && needsResize && (restructureSize < MAXIMUM_SEGMENT_SIZE)) {_						restructureSize <<= 1__						resizing = true__					}__					_					Reference<K, V>[] restructured =  (resizing ? createReferenceArray(restructureSize) : this.references)___					_					for (int i = 0_ i < this.references.length_ i++) {_						reference = this.references[i]__						if (!resizing) {_							restructured[i] = null__						}_						while (reference != null) {_							if (!toPurge.contains(reference)) {_								int index = getIndex(reference.getHash(), restructured)__								restructured[index] = this.referenceManager.createReference(_										reference.get(), reference.getHash(),_										restructured[index])__							}_							reference = reference.getNext()__						}_					}__					_					if (resizing) {_						setReferences(restructured)__					}_					this.count = countAfterRestructure__				} finally {_					unlock()__				}_			}_		};restructure,the,underlying,data,structure,when,it,becomes,necessary,this,method,can,increase,the,size,of,the,references,table,as,well,as,purge,any,references,that,have,been,garbage,collected,param,allow,resize,if,resizing,is,permitted;private,void,restructure,if,necessary,boolean,allow,resize,boolean,needs,resize,this,count,0,this,count,this,resize,threshold,reference,k,v,reference,this,reference,manager,poll,for,purge,if,reference,null,needs,resize,allow,resize,lock,try,int,count,after,restructure,this,count,set,reference,k,v,to,purge,collections,empty,set,if,reference,null,to,purge,new,hash,set,reference,k,v,while,reference,null,to,purge,add,reference,reference,this,reference,manager,poll,for,purge,count,after,restructure,to,purge,size,needs,resize,count,after,restructure,0,count,after,restructure,this,resize,threshold,boolean,resizing,false,int,restructure,size,this,references,length,if,allow,resize,needs,resize,restructure,size,restructure,size,1,resizing,true,reference,k,v,restructured,resizing,create,reference,array,restructure,size,this,references,for,int,i,0,i,this,references,length,i,reference,this,references,i,if,resizing,restructured,i,null,while,reference,null,if,to,purge,contains,reference,int,index,get,index,reference,get,hash,restructured,restructured,index,this,reference,manager,create,reference,reference,get,reference,get,hash,restructured,index,reference,reference,get,next,if,resizing,set,references,restructured,this,count,count,after,restructure,finally,unlock
ConcurrentReferenceHashMap -> Segment -> private void restructureIfNecessary(boolean allowResize);1355313310;Restructure the underlying data structure when it becomes necessary. This_method can increase the size of the references table as well as purge any_references that have been garbage collected._@param allowResize if resizing is permitted;private void restructureIfNecessary(boolean allowResize) {_			boolean needsResize = ((this.count > 0) && (this.count >= this.resizeThreshold))__			Reference<K, V> reference = this.referenceManager.pollForPurge()__			if ((reference != null) || (needsResize && allowResize)) {_				lock()__				try {_					int countAfterRestructure = this.count___					Set<Reference<K, V>> toPurge = Collections.emptySet()__					if (reference != null) {_						toPurge = new HashSet<Reference<K, V>>()__						while (reference != null) {_							toPurge.add(reference)__							reference = this.referenceManager.pollForPurge()__						}_					}_					countAfterRestructure -= toPurge.size()___					_					_					needsResize = ((countAfterRestructure > 0) && (countAfterRestructure >= this.resizeThreshold))__					boolean resizing = false__					int restructureSize = this.references.length__					if (allowResize && needsResize && (restructureSize < MAXIMUM_SEGMENT_SIZE)) {_						restructureSize <<= 1__						resizing = true__					}__					_					Reference<K, V>[] restructured =  (resizing ? createReferenceArray(restructureSize) : this.references)___					_					for (int i = 0_ i < this.references.length_ i++) {_						reference = this.references[i]__						if (!resizing) {_							restructured[i] = null__						}_						while (reference != null) {_							if (!toPurge.contains(reference)) {_								int index = getIndex(reference.getHash(), restructured)__								restructured[index] = this.referenceManager.createReference(_										reference.get(), reference.getHash(),_										restructured[index])__							}_							reference = reference.getNext()__						}_					}__					_					if (resizing) {_						setReferences(restructured)__					}_					this.count = countAfterRestructure__				} finally {_					unlock()__				}_			}_		};restructure,the,underlying,data,structure,when,it,becomes,necessary,this,method,can,increase,the,size,of,the,references,table,as,well,as,purge,any,references,that,have,been,garbage,collected,param,allow,resize,if,resizing,is,permitted;private,void,restructure,if,necessary,boolean,allow,resize,boolean,needs,resize,this,count,0,this,count,this,resize,threshold,reference,k,v,reference,this,reference,manager,poll,for,purge,if,reference,null,needs,resize,allow,resize,lock,try,int,count,after,restructure,this,count,set,reference,k,v,to,purge,collections,empty,set,if,reference,null,to,purge,new,hash,set,reference,k,v,while,reference,null,to,purge,add,reference,reference,this,reference,manager,poll,for,purge,count,after,restructure,to,purge,size,needs,resize,count,after,restructure,0,count,after,restructure,this,resize,threshold,boolean,resizing,false,int,restructure,size,this,references,length,if,allow,resize,needs,resize,restructure,size,restructure,size,1,resizing,true,reference,k,v,restructured,resizing,create,reference,array,restructure,size,this,references,for,int,i,0,i,this,references,length,i,reference,this,references,i,if,resizing,restructured,i,null,while,reference,null,if,to,purge,contains,reference,int,index,get,index,reference,get,hash,restructured,restructured,index,this,reference,manager,create,reference,reference,get,reference,get,hash,restructured,index,reference,reference,get,next,if,resizing,set,references,restructured,this,count,count,after,restructure,finally,unlock
ConcurrentReferenceHashMap -> Segment -> private void restructureIfNecessary(boolean allowResize);1356735495;Restructure the underlying data structure when it becomes necessary. This_method can increase the size of the references table as well as purge any_references that have been garbage collected._@param allowResize if resizing is permitted;private void restructureIfNecessary(boolean allowResize) {_			boolean needsResize = ((this.count > 0) && (this.count >= this.resizeThreshold))__			Reference<K, V> reference = this.referenceManager.pollForPurge()__			if ((reference != null) || (needsResize && allowResize)) {_				lock()__				try {_					int countAfterRestructure = this.count___					Set<Reference<K, V>> toPurge = Collections.emptySet()__					if (reference != null) {_						toPurge = new HashSet<Reference<K, V>>()__						while (reference != null) {_							toPurge.add(reference)__							reference = this.referenceManager.pollForPurge()__						}_					}_					countAfterRestructure -= toPurge.size()___					_					_					needsResize = ((countAfterRestructure > 0) && (countAfterRestructure >= this.resizeThreshold))__					boolean resizing = false__					int restructureSize = this.references.length__					if (allowResize && needsResize && (restructureSize < MAXIMUM_SEGMENT_SIZE)) {_						restructureSize <<= 1__						resizing = true__					}__					_					Reference<K, V>[] restructured =  (resizing ? createReferenceArray(restructureSize) : this.references)___					_					for (int i = 0_ i < this.references.length_ i++) {_						reference = this.references[i]__						if (!resizing) {_							restructured[i] = null__						}_						while (reference != null) {_							if (!toPurge.contains(reference)) {_								int index = getIndex(reference.getHash(), restructured)__								restructured[index] = this.referenceManager.createReference(_										reference.get(), reference.getHash(),_										restructured[index])__							}_							reference = reference.getNext()__						}_					}__					_					if (resizing) {_						setReferences(restructured)__					}_					this.count = countAfterRestructure__				} finally {_					unlock()__				}_			}_		};restructure,the,underlying,data,structure,when,it,becomes,necessary,this,method,can,increase,the,size,of,the,references,table,as,well,as,purge,any,references,that,have,been,garbage,collected,param,allow,resize,if,resizing,is,permitted;private,void,restructure,if,necessary,boolean,allow,resize,boolean,needs,resize,this,count,0,this,count,this,resize,threshold,reference,k,v,reference,this,reference,manager,poll,for,purge,if,reference,null,needs,resize,allow,resize,lock,try,int,count,after,restructure,this,count,set,reference,k,v,to,purge,collections,empty,set,if,reference,null,to,purge,new,hash,set,reference,k,v,while,reference,null,to,purge,add,reference,reference,this,reference,manager,poll,for,purge,count,after,restructure,to,purge,size,needs,resize,count,after,restructure,0,count,after,restructure,this,resize,threshold,boolean,resizing,false,int,restructure,size,this,references,length,if,allow,resize,needs,resize,restructure,size,restructure,size,1,resizing,true,reference,k,v,restructured,resizing,create,reference,array,restructure,size,this,references,for,int,i,0,i,this,references,length,i,reference,this,references,i,if,resizing,restructured,i,null,while,reference,null,if,to,purge,contains,reference,int,index,get,index,reference,get,hash,restructured,restructured,index,this,reference,manager,create,reference,reference,get,reference,get,hash,restructured,index,reference,reference,get,next,if,resizing,set,references,restructured,this,count,count,after,restructure,finally,unlock
ConcurrentReferenceHashMap -> Segment -> private void restructureIfNecessary(boolean allowResize);1357119239;Restructure the underlying data structure when it becomes necessary. This_method can increase the size of the references table as well as purge any_references that have been garbage collected._@param allowResize if resizing is permitted;private void restructureIfNecessary(boolean allowResize) {_			boolean needsResize = ((this.count > 0) && (this.count >= this.resizeThreshold))__			Reference<K, V> reference = this.referenceManager.pollForPurge()__			if ((reference != null) || (needsResize && allowResize)) {_				lock()__				try {_					int countAfterRestructure = this.count___					Set<Reference<K, V>> toPurge = Collections.emptySet()__					if (reference != null) {_						toPurge = new HashSet<Reference<K, V>>()__						while (reference != null) {_							toPurge.add(reference)__							reference = this.referenceManager.pollForPurge()__						}_					}_					countAfterRestructure -= toPurge.size()___					_					_					needsResize = ((countAfterRestructure > 0) && (countAfterRestructure >= this.resizeThreshold))__					boolean resizing = false__					int restructureSize = this.references.length__					if (allowResize && needsResize && (restructureSize < MAXIMUM_SEGMENT_SIZE)) {_						restructureSize <<= 1__						resizing = true__					}__					_					Reference<K, V>[] restructured =  (resizing ? createReferenceArray(restructureSize) : this.references)___					_					for (int i = 0_ i < this.references.length_ i++) {_						reference = this.references[i]__						if (!resizing) {_							restructured[i] = null__						}_						while (reference != null) {_							if (!toPurge.contains(reference)) {_								int index = getIndex(reference.getHash(), restructured)__								restructured[index] = this.referenceManager.createReference(_										reference.get(), reference.getHash(),_										restructured[index])__							}_							reference = reference.getNext()__						}_					}__					_					if (resizing) {_						setReferences(restructured)__					}_					this.count = countAfterRestructure__				} finally {_					unlock()__				}_			}_		};restructure,the,underlying,data,structure,when,it,becomes,necessary,this,method,can,increase,the,size,of,the,references,table,as,well,as,purge,any,references,that,have,been,garbage,collected,param,allow,resize,if,resizing,is,permitted;private,void,restructure,if,necessary,boolean,allow,resize,boolean,needs,resize,this,count,0,this,count,this,resize,threshold,reference,k,v,reference,this,reference,manager,poll,for,purge,if,reference,null,needs,resize,allow,resize,lock,try,int,count,after,restructure,this,count,set,reference,k,v,to,purge,collections,empty,set,if,reference,null,to,purge,new,hash,set,reference,k,v,while,reference,null,to,purge,add,reference,reference,this,reference,manager,poll,for,purge,count,after,restructure,to,purge,size,needs,resize,count,after,restructure,0,count,after,restructure,this,resize,threshold,boolean,resizing,false,int,restructure,size,this,references,length,if,allow,resize,needs,resize,restructure,size,restructure,size,1,resizing,true,reference,k,v,restructured,resizing,create,reference,array,restructure,size,this,references,for,int,i,0,i,this,references,length,i,reference,this,references,i,if,resizing,restructured,i,null,while,reference,null,if,to,purge,contains,reference,int,index,get,index,reference,get,hash,restructured,restructured,index,this,reference,manager,create,reference,reference,get,reference,get,hash,restructured,index,reference,reference,get,next,if,resizing,set,references,restructured,this,count,count,after,restructure,finally,unlock
ConcurrentReferenceHashMap -> Segment -> private void restructureIfNecessary(boolean allowResize);1368482696;Restructure the underlying data structure when it becomes necessary. This_method can increase the size of the references table as well as purge any_references that have been garbage collected._@param allowResize if resizing is permitted;private void restructureIfNecessary(boolean allowResize) {_			boolean needsResize = ((this.count > 0) && (this.count >= this.resizeThreshold))__			Reference<K, V> reference = this.referenceManager.pollForPurge()__			if ((reference != null) || (needsResize && allowResize)) {_				lock()__				try {_					int countAfterRestructure = this.count___					Set<Reference<K, V>> toPurge = Collections.emptySet()__					if (reference != null) {_						toPurge = new HashSet<Reference<K, V>>()__						while (reference != null) {_							toPurge.add(reference)__							reference = this.referenceManager.pollForPurge()__						}_					}_					countAfterRestructure -= toPurge.size()___					_					_					needsResize = ((countAfterRestructure > 0) && (countAfterRestructure >= this.resizeThreshold))__					boolean resizing = false__					int restructureSize = this.references.length__					if (allowResize && needsResize && (restructureSize < MAXIMUM_SEGMENT_SIZE)) {_						restructureSize <<= 1__						resizing = true__					}__					_					Reference<K, V>[] restructured =  (resizing ? createReferenceArray(restructureSize) : this.references)___					_					for (int i = 0_ i < this.references.length_ i++) {_						reference = this.references[i]__						if (!resizing) {_							restructured[i] = null__						}_						while (reference != null) {_							if (!toPurge.contains(reference)) {_								int index = getIndex(reference.getHash(), restructured)__								restructured[index] = this.referenceManager.createReference(_										reference.get(), reference.getHash(),_										restructured[index])__							}_							reference = reference.getNext()__						}_					}__					_					if (resizing) {_						setReferences(restructured)__					}_					this.count = countAfterRestructure__				} finally {_					unlock()__				}_			}_		};restructure,the,underlying,data,structure,when,it,becomes,necessary,this,method,can,increase,the,size,of,the,references,table,as,well,as,purge,any,references,that,have,been,garbage,collected,param,allow,resize,if,resizing,is,permitted;private,void,restructure,if,necessary,boolean,allow,resize,boolean,needs,resize,this,count,0,this,count,this,resize,threshold,reference,k,v,reference,this,reference,manager,poll,for,purge,if,reference,null,needs,resize,allow,resize,lock,try,int,count,after,restructure,this,count,set,reference,k,v,to,purge,collections,empty,set,if,reference,null,to,purge,new,hash,set,reference,k,v,while,reference,null,to,purge,add,reference,reference,this,reference,manager,poll,for,purge,count,after,restructure,to,purge,size,needs,resize,count,after,restructure,0,count,after,restructure,this,resize,threshold,boolean,resizing,false,int,restructure,size,this,references,length,if,allow,resize,needs,resize,restructure,size,restructure,size,1,resizing,true,reference,k,v,restructured,resizing,create,reference,array,restructure,size,this,references,for,int,i,0,i,this,references,length,i,reference,this,references,i,if,resizing,restructured,i,null,while,reference,null,if,to,purge,contains,reference,int,index,get,index,reference,get,hash,restructured,restructured,index,this,reference,manager,create,reference,reference,get,reference,get,hash,restructured,index,reference,reference,get,next,if,resizing,set,references,restructured,this,count,count,after,restructure,finally,unlock
ConcurrentReferenceHashMap -> Segment -> private void restructureIfNecessary(boolean allowResize);1383090835;Restructure the underlying data structure when it becomes necessary. This_method can increase the size of the references table as well as purge any_references that have been garbage collected._@param allowResize if resizing is permitted;private void restructureIfNecessary(boolean allowResize) {_			boolean needsResize = ((this.count > 0) && (this.count >= this.resizeThreshold))__			Reference<K, V> reference = this.referenceManager.pollForPurge()__			if ((reference != null) || (needsResize && allowResize)) {_				lock()__				try {_					int countAfterRestructure = this.count___					Set<Reference<K, V>> toPurge = Collections.emptySet()__					if (reference != null) {_						toPurge = new HashSet<Reference<K, V>>()__						while (reference != null) {_							toPurge.add(reference)__							reference = this.referenceManager.pollForPurge()__						}_					}_					countAfterRestructure -= toPurge.size()___					_					_					needsResize = ((countAfterRestructure > 0) && (countAfterRestructure >= this.resizeThreshold))__					boolean resizing = false__					int restructureSize = this.references.length__					if (allowResize && needsResize && (restructureSize < MAXIMUM_SEGMENT_SIZE)) {_						restructureSize <<= 1__						resizing = true__					}__					_					Reference<K, V>[] restructured =  (resizing ? createReferenceArray(restructureSize) : this.references)___					_					for (int i = 0_ i < this.references.length_ i++) {_						reference = this.references[i]__						if (!resizing) {_							restructured[i] = null__						}_						while (reference != null) {_							if (!toPurge.contains(reference)) {_								int index = getIndex(reference.getHash(), restructured)__								restructured[index] = this.referenceManager.createReference(_										reference.get(), reference.getHash(),_										restructured[index])__							}_							reference = reference.getNext()__						}_					}__					_					if (resizing) {_						setReferences(restructured)__					}_					this.count = countAfterRestructure__				} finally {_					unlock()__				}_			}_		};restructure,the,underlying,data,structure,when,it,becomes,necessary,this,method,can,increase,the,size,of,the,references,table,as,well,as,purge,any,references,that,have,been,garbage,collected,param,allow,resize,if,resizing,is,permitted;private,void,restructure,if,necessary,boolean,allow,resize,boolean,needs,resize,this,count,0,this,count,this,resize,threshold,reference,k,v,reference,this,reference,manager,poll,for,purge,if,reference,null,needs,resize,allow,resize,lock,try,int,count,after,restructure,this,count,set,reference,k,v,to,purge,collections,empty,set,if,reference,null,to,purge,new,hash,set,reference,k,v,while,reference,null,to,purge,add,reference,reference,this,reference,manager,poll,for,purge,count,after,restructure,to,purge,size,needs,resize,count,after,restructure,0,count,after,restructure,this,resize,threshold,boolean,resizing,false,int,restructure,size,this,references,length,if,allow,resize,needs,resize,restructure,size,restructure,size,1,resizing,true,reference,k,v,restructured,resizing,create,reference,array,restructure,size,this,references,for,int,i,0,i,this,references,length,i,reference,this,references,i,if,resizing,restructured,i,null,while,reference,null,if,to,purge,contains,reference,int,index,get,index,reference,get,hash,restructured,restructured,index,this,reference,manager,create,reference,reference,get,reference,get,hash,restructured,index,reference,reference,get,next,if,resizing,set,references,restructured,this,count,count,after,restructure,finally,unlock
ConcurrentReferenceHashMap -> Segment -> private void restructureIfNecessary(boolean allowResize);1383178438;Restructure the underlying data structure when it becomes necessary. This_method can increase the size of the references table as well as purge any_references that have been garbage collected._@param allowResize if resizing is permitted;private void restructureIfNecessary(boolean allowResize) {_			boolean needsResize = ((this.count > 0) && (this.count >= this.resizeThreshold))__			Reference<K, V> reference = this.referenceManager.pollForPurge()__			if ((reference != null) || (needsResize && allowResize)) {_				lock()__				try {_					int countAfterRestructure = this.count___					Set<Reference<K, V>> toPurge = Collections.emptySet()__					if (reference != null) {_						toPurge = new HashSet<Reference<K, V>>()__						while (reference != null) {_							toPurge.add(reference)__							reference = this.referenceManager.pollForPurge()__						}_					}_					countAfterRestructure -= toPurge.size()___					_					_					needsResize = ((countAfterRestructure > 0) && (countAfterRestructure >= this.resizeThreshold))__					boolean resizing = false__					int restructureSize = this.references.length__					if (allowResize && needsResize && (restructureSize < MAXIMUM_SEGMENT_SIZE)) {_						restructureSize <<= 1__						resizing = true__					}__					_					Reference<K, V>[] restructured =  (resizing ? createReferenceArray(restructureSize) : this.references)___					_					for (int i = 0_ i < this.references.length_ i++) {_						reference = this.references[i]__						if (!resizing) {_							restructured[i] = null__						}_						while (reference != null) {_							if (!toPurge.contains(reference)) {_								int index = getIndex(reference.getHash(), restructured)__								restructured[index] = this.referenceManager.createReference(_										reference.get(), reference.getHash(),_										restructured[index])__							}_							reference = reference.getNext()__						}_					}__					_					if (resizing) {_						setReferences(restructured)__					}_					this.count = countAfterRestructure__				} finally {_					unlock()__				}_			}_		};restructure,the,underlying,data,structure,when,it,becomes,necessary,this,method,can,increase,the,size,of,the,references,table,as,well,as,purge,any,references,that,have,been,garbage,collected,param,allow,resize,if,resizing,is,permitted;private,void,restructure,if,necessary,boolean,allow,resize,boolean,needs,resize,this,count,0,this,count,this,resize,threshold,reference,k,v,reference,this,reference,manager,poll,for,purge,if,reference,null,needs,resize,allow,resize,lock,try,int,count,after,restructure,this,count,set,reference,k,v,to,purge,collections,empty,set,if,reference,null,to,purge,new,hash,set,reference,k,v,while,reference,null,to,purge,add,reference,reference,this,reference,manager,poll,for,purge,count,after,restructure,to,purge,size,needs,resize,count,after,restructure,0,count,after,restructure,this,resize,threshold,boolean,resizing,false,int,restructure,size,this,references,length,if,allow,resize,needs,resize,restructure,size,restructure,size,1,resizing,true,reference,k,v,restructured,resizing,create,reference,array,restructure,size,this,references,for,int,i,0,i,this,references,length,i,reference,this,references,i,if,resizing,restructured,i,null,while,reference,null,if,to,purge,contains,reference,int,index,get,index,reference,get,hash,restructured,restructured,index,this,reference,manager,create,reference,reference,get,reference,get,hash,restructured,index,reference,reference,get,next,if,resizing,set,references,restructured,this,count,count,after,restructure,finally,unlock
ConcurrentReferenceHashMap -> Segment -> private void restructureIfNecessary(boolean allowResize);1390260938;Restructure the underlying data structure when it becomes necessary. This_method can increase the size of the references table as well as purge any_references that have been garbage collected._@param allowResize if resizing is permitted;private void restructureIfNecessary(boolean allowResize) {_			boolean needsResize = ((this.count > 0) && (this.count >= this.resizeThreshold))__			Reference<K, V> reference = this.referenceManager.pollForPurge()__			if ((reference != null) || (needsResize && allowResize)) {_				lock()__				try {_					int countAfterRestructure = this.count___					Set<Reference<K, V>> toPurge = Collections.emptySet()__					if (reference != null) {_						toPurge = new HashSet<Reference<K, V>>()__						while (reference != null) {_							toPurge.add(reference)__							reference = this.referenceManager.pollForPurge()__						}_					}_					countAfterRestructure -= toPurge.size()___					_					_					needsResize = ((countAfterRestructure > 0) && (countAfterRestructure >= this.resizeThreshold))__					boolean resizing = false__					int restructureSize = this.references.length__					if (allowResize && needsResize && (restructureSize < MAXIMUM_SEGMENT_SIZE)) {_						restructureSize <<= 1__						resizing = true__					}__					_					Reference<K, V>[] restructured =  (resizing ? createReferenceArray(restructureSize) : this.references)___					_					for (int i = 0_ i < this.references.length_ i++) {_						reference = this.references[i]__						if (!resizing) {_							restructured[i] = null__						}_						while (reference != null) {_							if (!toPurge.contains(reference)) {_								int index = getIndex(reference.getHash(), restructured)__								restructured[index] = this.referenceManager.createReference(_										reference.get(), reference.getHash(),_										restructured[index])__							}_							reference = reference.getNext()__						}_					}__					_					if (resizing) {_						setReferences(restructured)__					}_					this.count = countAfterRestructure__				} finally {_					unlock()__				}_			}_		};restructure,the,underlying,data,structure,when,it,becomes,necessary,this,method,can,increase,the,size,of,the,references,table,as,well,as,purge,any,references,that,have,been,garbage,collected,param,allow,resize,if,resizing,is,permitted;private,void,restructure,if,necessary,boolean,allow,resize,boolean,needs,resize,this,count,0,this,count,this,resize,threshold,reference,k,v,reference,this,reference,manager,poll,for,purge,if,reference,null,needs,resize,allow,resize,lock,try,int,count,after,restructure,this,count,set,reference,k,v,to,purge,collections,empty,set,if,reference,null,to,purge,new,hash,set,reference,k,v,while,reference,null,to,purge,add,reference,reference,this,reference,manager,poll,for,purge,count,after,restructure,to,purge,size,needs,resize,count,after,restructure,0,count,after,restructure,this,resize,threshold,boolean,resizing,false,int,restructure,size,this,references,length,if,allow,resize,needs,resize,restructure,size,restructure,size,1,resizing,true,reference,k,v,restructured,resizing,create,reference,array,restructure,size,this,references,for,int,i,0,i,this,references,length,i,reference,this,references,i,if,resizing,restructured,i,null,while,reference,null,if,to,purge,contains,reference,int,index,get,index,reference,get,hash,restructured,restructured,index,this,reference,manager,create,reference,reference,get,reference,get,hash,restructured,index,reference,reference,get,next,if,resizing,set,references,restructured,this,count,count,after,restructure,finally,unlock
ConcurrentReferenceHashMap -> Segment -> private void restructureIfNecessary(boolean allowResize);1391715359;Restructure the underlying data structure when it becomes necessary. This_method can increase the size of the references table as well as purge any_references that have been garbage collected._@param allowResize if resizing is permitted;private void restructureIfNecessary(boolean allowResize) {_			boolean needsResize = ((this.count > 0) && (this.count >= this.resizeThreshold))__			Reference<K, V> reference = this.referenceManager.pollForPurge()__			if ((reference != null) || (needsResize && allowResize)) {_				lock()__				try {_					int countAfterRestructure = this.count___					Set<Reference<K, V>> toPurge = Collections.emptySet()__					if (reference != null) {_						toPurge = new HashSet<Reference<K, V>>()__						while (reference != null) {_							toPurge.add(reference)__							reference = this.referenceManager.pollForPurge()__						}_					}_					countAfterRestructure -= toPurge.size()___					_					_					needsResize = ((countAfterRestructure > 0) && (countAfterRestructure >= this.resizeThreshold))__					boolean resizing = false__					int restructureSize = this.references.length__					if (allowResize && needsResize && (restructureSize < MAXIMUM_SEGMENT_SIZE)) {_						restructureSize <<= 1__						resizing = true__					}__					_					Reference<K, V>[] restructured =  (resizing ? createReferenceArray(restructureSize) : this.references)___					_					for (int i = 0_ i < this.references.length_ i++) {_						reference = this.references[i]__						if (!resizing) {_							restructured[i] = null__						}_						while (reference != null) {_							if (!toPurge.contains(reference)) {_								int index = getIndex(reference.getHash(), restructured)__								restructured[index] = this.referenceManager.createReference(_										reference.get(), reference.getHash(),_										restructured[index])__							}_							reference = reference.getNext()__						}_					}__					_					if (resizing) {_						setReferences(restructured)__					}_					this.count = countAfterRestructure__				} finally {_					unlock()__				}_			}_		};restructure,the,underlying,data,structure,when,it,becomes,necessary,this,method,can,increase,the,size,of,the,references,table,as,well,as,purge,any,references,that,have,been,garbage,collected,param,allow,resize,if,resizing,is,permitted;private,void,restructure,if,necessary,boolean,allow,resize,boolean,needs,resize,this,count,0,this,count,this,resize,threshold,reference,k,v,reference,this,reference,manager,poll,for,purge,if,reference,null,needs,resize,allow,resize,lock,try,int,count,after,restructure,this,count,set,reference,k,v,to,purge,collections,empty,set,if,reference,null,to,purge,new,hash,set,reference,k,v,while,reference,null,to,purge,add,reference,reference,this,reference,manager,poll,for,purge,count,after,restructure,to,purge,size,needs,resize,count,after,restructure,0,count,after,restructure,this,resize,threshold,boolean,resizing,false,int,restructure,size,this,references,length,if,allow,resize,needs,resize,restructure,size,restructure,size,1,resizing,true,reference,k,v,restructured,resizing,create,reference,array,restructure,size,this,references,for,int,i,0,i,this,references,length,i,reference,this,references,i,if,resizing,restructured,i,null,while,reference,null,if,to,purge,contains,reference,int,index,get,index,reference,get,hash,restructured,restructured,index,this,reference,manager,create,reference,reference,get,reference,get,hash,restructured,index,reference,reference,get,next,if,resizing,set,references,restructured,this,count,count,after,restructure,finally,unlock
ConcurrentReferenceHashMap -> Reference -> @Nullable 		Reference<K, V> getNext()_;1495868221;Returns the next reference in the chain or {@code null}_@return the next reference of {@code null};@Nullable_		Reference<K, V> getNext()_;returns,the,next,reference,in,the,chain,or,code,null,return,the,next,reference,of,code,null;nullable,reference,k,v,get,next
ConcurrentReferenceHashMap -> Reference -> @Nullable 		Reference<K, V> getNext()_;1496242568;Returns the next reference in the chain or {@code null}_@return the next reference of {@code null};@Nullable_		Reference<K, V> getNext()_;returns,the,next,reference,in,the,chain,or,code,null,return,the,next,reference,of,code,null;nullable,reference,k,v,get,next
ConcurrentReferenceHashMap -> Reference -> @Nullable 		Reference<K, V> getNext()_;1496837955;Return the next reference in the chain, or {@code null} if none.;@Nullable_		Reference<K, V> getNext()_;return,the,next,reference,in,the,chain,or,code,null,if,none;nullable,reference,k,v,get,next
ConcurrentReferenceHashMap -> Reference -> @Nullable 		Reference<K, V> getNext()_;1498780456;Return the next reference in the chain, or {@code null} if none.;@Nullable_		Reference<K, V> getNext()_;return,the,next,reference,in,the,chain,or,code,null,if,none;nullable,reference,k,v,get,next
ConcurrentReferenceHashMap -> Reference -> @Nullable 		Reference<K, V> getNext()_;1502974979;Return the next reference in the chain, or {@code null} if none.;@Nullable_		Reference<K, V> getNext()_;return,the,next,reference,in,the,chain,or,code,null,if,none;nullable,reference,k,v,get,next
ConcurrentReferenceHashMap -> Reference -> @Nullable 		Reference<K, V> getNext()_;1506097334;Return the next reference in the chain, or {@code null} if none.;@Nullable_		Reference<K, V> getNext()_;return,the,next,reference,in,the,chain,or,code,null,if,none;nullable,reference,k,v,get,next
ConcurrentReferenceHashMap -> Reference -> @Nullable 		Reference<K, V> getNext()_;1521044224;Return the next reference in the chain, or {@code null} if none.;@Nullable_		Reference<K, V> getNext()_;return,the,next,reference,in,the,chain,or,code,null,if,none;nullable,reference,k,v,get,next
ConcurrentReferenceHashMap -> Reference -> @Nullable 		Reference<K, V> getNext()_;1530174524;Return the next reference in the chain, or {@code null} if none.;@Nullable_		Reference<K, V> getNext()_;return,the,next,reference,in,the,chain,or,code,null,if,none;nullable,reference,k,v,get,next
ConcurrentReferenceHashMap -> Reference -> @Nullable 		Reference<K, V> getNext()_;1530190293;Return the next reference in the chain, or {@code null} if none.;@Nullable_		Reference<K, V> getNext()_;return,the,next,reference,in,the,chain,or,code,null,if,none;nullable,reference,k,v,get,next
ConcurrentReferenceHashMap -> Reference -> @Nullable 		Reference<K, V> getNext()_;1530563577;Return the next reference in the chain, or {@code null} if none.;@Nullable_		Reference<K, V> getNext()_;return,the,next,reference,in,the,chain,or,code,null,if,none;nullable,reference,k,v,get,next
ConcurrentReferenceHashMap -> Reference -> @Nullable 		Reference<K, V> getNext()_;1531136363;Return the next reference in the chain, or {@code null} if none.;@Nullable_		Reference<K, V> getNext()_;return,the,next,reference,in,the,chain,or,code,null,if,none;nullable,reference,k,v,get,next
ConcurrentReferenceHashMap -> Reference -> @Nullable 		Reference<K, V> getNext()_;1531139295;Return the next reference in the chain, or {@code null} if none.;@Nullable_		Reference<K, V> getNext()_;return,the,next,reference,in,the,chain,or,code,null,if,none;nullable,reference,k,v,get,next
ConcurrentReferenceHashMap -> Reference -> @Nullable 		Reference<K, V> getNext()_;1544716668;Return the next reference in the chain, or {@code null} if none.;@Nullable_		Reference<K, V> getNext()_;return,the,next,reference,in,the,chain,or,code,null,if,none;nullable,reference,k,v,get,next
ConcurrentReferenceHashMap -> Reference -> @Nullable 		Reference<K, V> getNext()_;1549318940;Return the next reference in the chain, or {@code null} if none.;@Nullable_		Reference<K, V> getNext()_;return,the,next,reference,in,the,chain,or,code,null,if,none;nullable,reference,k,v,get,next
ConcurrentReferenceHashMap -> Reference -> @Nullable 		Reference<K, V> getNext()_;1549321822;Return the next reference in the chain, or {@code null} if none.;@Nullable_		Reference<K, V> getNext()_;return,the,next,reference,in,the,chain,or,code,null,if,none;nullable,reference,k,v,get,next
ConcurrentReferenceHashMap -> Reference -> @Nullable 		Reference<K, V> getNext()_;1550237263;Return the next reference in the chain, or {@code null} if none.;@Nullable_		Reference<K, V> getNext()_;return,the,next,reference,in,the,chain,or,code,null,if,none;nullable,reference,k,v,get,next
ConcurrentReferenceHashMap -> Segment -> public final int getSize();1351982790;@return the size of the current references array;public final int getSize() {_			return this.references.length__		};return,the,size,of,the,current,references,array;public,final,int,get,size,return,this,references,length
ConcurrentReferenceHashMap -> Segment -> public final int getSize();1352039846;@return the size of the current references array;public final int getSize() {_			return this.references.length__		};return,the,size,of,the,current,references,array;public,final,int,get,size,return,this,references,length
ConcurrentReferenceHashMap -> Segment -> public final int getSize();1355313310;@return the size of the current references array;public final int getSize() {_			return this.references.length__		};return,the,size,of,the,current,references,array;public,final,int,get,size,return,this,references,length
ConcurrentReferenceHashMap -> Segment -> public final int getSize();1356735495;@return the size of the current references array;public final int getSize() {_			return this.references.length__		};return,the,size,of,the,current,references,array;public,final,int,get,size,return,this,references,length
ConcurrentReferenceHashMap -> Segment -> public final int getSize();1357119239;@return the size of the current references array;public final int getSize() {_			return this.references.length__		};return,the,size,of,the,current,references,array;public,final,int,get,size,return,this,references,length
ConcurrentReferenceHashMap -> Segment -> public final int getSize();1368482696;@return the size of the current references array;public final int getSize() {_			return this.references.length__		};return,the,size,of,the,current,references,array;public,final,int,get,size,return,this,references,length
ConcurrentReferenceHashMap -> Segment -> public final int getSize();1383090835;@return the size of the current references array;public final int getSize() {_			return this.references.length__		};return,the,size,of,the,current,references,array;public,final,int,get,size,return,this,references,length
ConcurrentReferenceHashMap -> Segment -> public final int getSize();1383178438;@return the size of the current references array;public final int getSize() {_			return this.references.length__		};return,the,size,of,the,current,references,array;public,final,int,get,size,return,this,references,length
ConcurrentReferenceHashMap -> Segment -> public final int getSize();1390260938;@return the size of the current references array;public final int getSize() {_			return this.references.length__		};return,the,size,of,the,current,references,array;public,final,int,get,size,return,this,references,length
ConcurrentReferenceHashMap -> Segment -> public final int getSize();1391715359;@return the size of the current references array;public final int getSize() {_			return this.references.length__		};return,the,size,of,the,current,references,array;public,final,int,get,size,return,this,references,length
ConcurrentReferenceHashMap -> Segment -> public final int getSize();1392765030;@return the size of the current references array;public final int getSize() {_			return this.references.length__		};return,the,size,of,the,current,references,array;public,final,int,get,size,return,this,references,length
ConcurrentReferenceHashMap -> Segment -> public final int getSize();1398175099;@return the size of the current references array;public final int getSize() {_			return this.references.length__		};return,the,size,of,the,current,references,array;public,final,int,get,size,return,this,references,length
ConcurrentReferenceHashMap -> Segment -> public final int getSize();1404132943;@return the size of the current references array;public final int getSize() {_			return this.references.length__		};return,the,size,of,the,current,references,array;public,final,int,get,size,return,this,references,length
ConcurrentReferenceHashMap -> Segment -> public final int getSize();1427240641;@return the size of the current references array;public final int getSize() {_			return this.references.length__		};return,the,size,of,the,current,references,array;public,final,int,get,size,return,this,references,length
ConcurrentReferenceHashMap -> Segment -> public final int getSize();1459795890;@return the size of the current references array;public final int getSize() {_			return this.references.length__		};return,the,size,of,the,current,references,array;public,final,int,get,size,return,this,references,length
ConcurrentReferenceHashMap -> Segment -> public final int getSize();1467730834;@return the size of the current references array;public final int getSize() {_			return this.references.length__		};return,the,size,of,the,current,references,array;public,final,int,get,size,return,this,references,length
ConcurrentReferenceHashMap -> Segment -> public final int getSize();1485810955;@return the size of the current references array;public final int getSize() {_			return this.references.length__		};return,the,size,of,the,current,references,array;public,final,int,get,size,return,this,references,length
ConcurrentReferenceHashMap -> Segment -> public final int getSize();1495868221;@return the size of the current references array;public final int getSize() {_			return this.references.length__		};return,the,size,of,the,current,references,array;public,final,int,get,size,return,this,references,length
ConcurrentReferenceHashMap -> Segment -> public final int getSize();1496242568;@return the size of the current references array;public final int getSize() {_			return this.references.length__		};return,the,size,of,the,current,references,array;public,final,int,get,size,return,this,references,length
ConcurrentReferenceHashMap -> Segment -> public final int getSize();1496837955;@return the size of the current references array;public final int getSize() {_			return this.references.length__		};return,the,size,of,the,current,references,array;public,final,int,get,size,return,this,references,length
ConcurrentReferenceHashMap -> Segment -> public final int getSize();1498780456;Return the size of the current references array.;public final int getSize() {_			return this.references.length__		};return,the,size,of,the,current,references,array;public,final,int,get,size,return,this,references,length
ConcurrentReferenceHashMap -> Segment -> public final int getSize();1502974979;Return the size of the current references array.;public final int getSize() {_			return this.references.length__		};return,the,size,of,the,current,references,array;public,final,int,get,size,return,this,references,length
ConcurrentReferenceHashMap -> Segment -> public final int getSize();1506097334;Return the size of the current references array.;public final int getSize() {_			return this.references.length__		};return,the,size,of,the,current,references,array;public,final,int,get,size,return,this,references,length
ConcurrentReferenceHashMap -> Segment -> public final int getSize();1521044224;Return the size of the current references array.;public final int getSize() {_			return this.references.length__		};return,the,size,of,the,current,references,array;public,final,int,get,size,return,this,references,length
ConcurrentReferenceHashMap -> Segment -> public final int getSize();1530174524;Return the size of the current references array.;public final int getSize() {_			return this.references.length__		};return,the,size,of,the,current,references,array;public,final,int,get,size,return,this,references,length
ConcurrentReferenceHashMap -> Segment -> public final int getSize();1530190293;Return the size of the current references array.;public final int getSize() {_			return this.references.length__		};return,the,size,of,the,current,references,array;public,final,int,get,size,return,this,references,length
ConcurrentReferenceHashMap -> Segment -> public final int getSize();1530563577;Return the size of the current references array.;public final int getSize() {_			return this.references.length__		};return,the,size,of,the,current,references,array;public,final,int,get,size,return,this,references,length
ConcurrentReferenceHashMap -> Segment -> public final int getSize();1531136363;Return the size of the current references array.;public final int getSize() {_			return this.references.length__		};return,the,size,of,the,current,references,array;public,final,int,get,size,return,this,references,length
ConcurrentReferenceHashMap -> Segment -> public final int getSize();1531139295;Return the size of the current references array.;public final int getSize() {_			return this.references.length__		};return,the,size,of,the,current,references,array;public,final,int,get,size,return,this,references,length
ConcurrentReferenceHashMap -> Segment -> public final int getSize();1544716668;Return the size of the current references array.;public final int getSize() {_			return this.references.length__		};return,the,size,of,the,current,references,array;public,final,int,get,size,return,this,references,length
ConcurrentReferenceHashMap -> Segment -> public final int getSize();1549318940;Return the size of the current references array.;public final int getSize() {_			return this.references.length__		};return,the,size,of,the,current,references,array;public,final,int,get,size,return,this,references,length
ConcurrentReferenceHashMap -> Segment -> public final int getSize();1549321822;Return the size of the current references array.;public final int getSize() {_			return this.references.length__		};return,the,size,of,the,current,references,array;public,final,int,get,size,return,this,references,length
ConcurrentReferenceHashMap -> Segment -> public final int getSize();1550237263;Return the size of the current references array.;public final int getSize() {_			return this.references.length__		};return,the,size,of,the,current,references,array;public,final,int,get,size,return,this,references,length
ConcurrentReferenceHashMap -> @SuppressWarnings("unchecked") 	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel, 			ReferenceType referenceType);1383090835;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map_@param referenceType the reference type used for entries;@SuppressWarnings("unchecked")_	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel,_			ReferenceType referenceType) {__		Assert.isTrue(concurrencyLevel > 0, "ConcurrencyLevel must be positive")__		Assert.isTrue(initialCapacity >= 0, "InitialCapacity must not be negative")__		Assert.isTrue(loadFactor > 0f, "LoadFactor must be positive")__		Assert.notNull(referenceType, "Reference type must not be null")__		this.loadFactor = loadFactor__		this.shift = calculateShift(concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL)__		int size = 1 << this.shift__		this.referenceType = referenceType__		int roundedUpSegmentCapactity = (int) ((initialCapacity + size - 1L) / size)__		this.segments = (Segment[]) Array.newInstance(Segment.class, size)__		for (int i = 0_ i < this.segments.length_ i++) {_			this.segments[i] = new Segment(roundedUpSegmentCapactity)__		}_	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map,param,reference,type,the,reference,type,used,for,entries;suppress,warnings,unchecked,public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,reference,type,reference,type,assert,is,true,concurrency,level,0,concurrency,level,must,be,positive,assert,is,true,initial,capacity,0,initial,capacity,must,not,be,negative,assert,is,true,load,factor,0f,load,factor,must,be,positive,assert,not,null,reference,type,reference,type,must,not,be,null,this,load,factor,load,factor,this,shift,calculate,shift,concurrency,level,int,size,1,this,shift,this,reference,type,reference,type,int,rounded,up,segment,capactity,int,initial,capacity,size,1l,size,this,segments,segment,array,new,instance,segment,class,size,for,int,i,0,i,this,segments,length,i,this,segments,i,new,segment,rounded,up,segment,capactity
ConcurrentReferenceHashMap -> @SuppressWarnings("unchecked") 	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel, 			ReferenceType referenceType);1383178438;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map_@param referenceType the reference type used for entries;@SuppressWarnings("unchecked")_	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel,_			ReferenceType referenceType) {__		Assert.isTrue(concurrencyLevel > 0, "ConcurrencyLevel must be positive")__		Assert.isTrue(initialCapacity >= 0, "InitialCapacity must not be negative")__		Assert.isTrue(loadFactor > 0f, "LoadFactor must be positive")__		Assert.notNull(referenceType, "Reference type must not be null")__		this.loadFactor = loadFactor__		this.shift = calculateShift(concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL)__		int size = 1 << this.shift__		this.referenceType = referenceType__		int roundedUpSegmentCapactity = (int) ((initialCapacity + size - 1L) / size)__		this.segments = (Segment[]) Array.newInstance(Segment.class, size)__		for (int i = 0_ i < this.segments.length_ i++) {_			this.segments[i] = new Segment(roundedUpSegmentCapactity)__		}_	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map,param,reference,type,the,reference,type,used,for,entries;suppress,warnings,unchecked,public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,reference,type,reference,type,assert,is,true,concurrency,level,0,concurrency,level,must,be,positive,assert,is,true,initial,capacity,0,initial,capacity,must,not,be,negative,assert,is,true,load,factor,0f,load,factor,must,be,positive,assert,not,null,reference,type,reference,type,must,not,be,null,this,load,factor,load,factor,this,shift,calculate,shift,concurrency,level,int,size,1,this,shift,this,reference,type,reference,type,int,rounded,up,segment,capactity,int,initial,capacity,size,1l,size,this,segments,segment,array,new,instance,segment,class,size,for,int,i,0,i,this,segments,length,i,this,segments,i,new,segment,rounded,up,segment,capactity
ConcurrentReferenceHashMap -> @SuppressWarnings("unchecked") 	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel, 			ReferenceType referenceType);1390260938;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map_@param referenceType the reference type used for entries;@SuppressWarnings("unchecked")_	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel,_			ReferenceType referenceType) {__		Assert.isTrue(initialCapacity >= 0, "Initial capacity must not be negative")__		Assert.isTrue(loadFactor > 0f, "Load factor must be positive")__		Assert.isTrue(concurrencyLevel > 0, "Concurrency level must be positive")__		Assert.notNull(referenceType, "Reference type must not be null")__		this.loadFactor = loadFactor__		this.shift = calculateShift(concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL)__		int size = 1 << this.shift__		this.referenceType = referenceType__		int roundedUpSegmentCapactity = (int) ((initialCapacity + size - 1L) / size)__		this.segments = (Segment[]) Array.newInstance(Segment.class, size)__		for (int i = 0_ i < this.segments.length_ i++) {_			this.segments[i] = new Segment(roundedUpSegmentCapactity)__		}_	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map,param,reference,type,the,reference,type,used,for,entries;suppress,warnings,unchecked,public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,reference,type,reference,type,assert,is,true,initial,capacity,0,initial,capacity,must,not,be,negative,assert,is,true,load,factor,0f,load,factor,must,be,positive,assert,is,true,concurrency,level,0,concurrency,level,must,be,positive,assert,not,null,reference,type,reference,type,must,not,be,null,this,load,factor,load,factor,this,shift,calculate,shift,concurrency,level,int,size,1,this,shift,this,reference,type,reference,type,int,rounded,up,segment,capactity,int,initial,capacity,size,1l,size,this,segments,segment,array,new,instance,segment,class,size,for,int,i,0,i,this,segments,length,i,this,segments,i,new,segment,rounded,up,segment,capactity
ConcurrentReferenceHashMap -> @SuppressWarnings("unchecked") 	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel, 			ReferenceType referenceType);1391715359;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map_@param referenceType the reference type used for entries (soft or weak);@SuppressWarnings("unchecked")_	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel,_			ReferenceType referenceType) {__		Assert.isTrue(initialCapacity >= 0, "Initial capacity must not be negative")__		Assert.isTrue(loadFactor > 0f, "Load factor must be positive")__		Assert.isTrue(concurrencyLevel > 0, "Concurrency level must be positive")__		Assert.notNull(referenceType, "Reference type must not be null")__		this.loadFactor = loadFactor__		this.shift = calculateShift(concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL)__		int size = 1 << this.shift__		this.referenceType = referenceType__		int roundedUpSegmentCapacity = (int) ((initialCapacity + size - 1L) / size)__		this.segments = (Segment[]) Array.newInstance(Segment.class, size)__		for (int i = 0_ i < this.segments.length_ i++) {_			this.segments[i] = new Segment(roundedUpSegmentCapacity)__		}_	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;suppress,warnings,unchecked,public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,reference,type,reference,type,assert,is,true,initial,capacity,0,initial,capacity,must,not,be,negative,assert,is,true,load,factor,0f,load,factor,must,be,positive,assert,is,true,concurrency,level,0,concurrency,level,must,be,positive,assert,not,null,reference,type,reference,type,must,not,be,null,this,load,factor,load,factor,this,shift,calculate,shift,concurrency,level,int,size,1,this,shift,this,reference,type,reference,type,int,rounded,up,segment,capacity,int,initial,capacity,size,1l,size,this,segments,segment,array,new,instance,segment,class,size,for,int,i,0,i,this,segments,length,i,this,segments,i,new,segment,rounded,up,segment,capacity
ConcurrentReferenceHashMap -> @SuppressWarnings("unchecked") 	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel, 			ReferenceType referenceType);1392765030;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map_@param referenceType the reference type used for entries (soft or weak);@SuppressWarnings("unchecked")_	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel,_			ReferenceType referenceType) {__		Assert.isTrue(initialCapacity >= 0, "Initial capacity must not be negative")__		Assert.isTrue(loadFactor > 0f, "Load factor must be positive")__		Assert.isTrue(concurrencyLevel > 0, "Concurrency level must be positive")__		Assert.notNull(referenceType, "Reference type must not be null")__		this.loadFactor = loadFactor__		this.shift = calculateShift(concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL)__		int size = 1 << this.shift__		this.referenceType = referenceType__		int roundedUpSegmentCapacity = (int) ((initialCapacity + size - 1L) / size)__		this.segments = (Segment[]) Array.newInstance(Segment.class, size)__		for (int i = 0_ i < this.segments.length_ i++) {_			this.segments[i] = new Segment(roundedUpSegmentCapacity)__		}_	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;suppress,warnings,unchecked,public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,reference,type,reference,type,assert,is,true,initial,capacity,0,initial,capacity,must,not,be,negative,assert,is,true,load,factor,0f,load,factor,must,be,positive,assert,is,true,concurrency,level,0,concurrency,level,must,be,positive,assert,not,null,reference,type,reference,type,must,not,be,null,this,load,factor,load,factor,this,shift,calculate,shift,concurrency,level,int,size,1,this,shift,this,reference,type,reference,type,int,rounded,up,segment,capacity,int,initial,capacity,size,1l,size,this,segments,segment,array,new,instance,segment,class,size,for,int,i,0,i,this,segments,length,i,this,segments,i,new,segment,rounded,up,segment,capacity
ConcurrentReferenceHashMap -> @SuppressWarnings("unchecked") 	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel, 			ReferenceType referenceType);1398175099;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map_@param referenceType the reference type used for entries (soft or weak);@SuppressWarnings("unchecked")_	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel,_			ReferenceType referenceType) {__		Assert.isTrue(initialCapacity >= 0, "Initial capacity must not be negative")__		Assert.isTrue(loadFactor > 0f, "Load factor must be positive")__		Assert.isTrue(concurrencyLevel > 0, "Concurrency level must be positive")__		Assert.notNull(referenceType, "Reference type must not be null")__		this.loadFactor = loadFactor__		this.shift = calculateShift(concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL)__		int size = 1 << this.shift__		this.referenceType = referenceType__		int roundedUpSegmentCapacity = (int) ((initialCapacity + size - 1L) / size)__		this.segments = (Segment[]) Array.newInstance(Segment.class, size)__		for (int i = 0_ i < this.segments.length_ i++) {_			this.segments[i] = new Segment(roundedUpSegmentCapacity)__		}_	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;suppress,warnings,unchecked,public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,reference,type,reference,type,assert,is,true,initial,capacity,0,initial,capacity,must,not,be,negative,assert,is,true,load,factor,0f,load,factor,must,be,positive,assert,is,true,concurrency,level,0,concurrency,level,must,be,positive,assert,not,null,reference,type,reference,type,must,not,be,null,this,load,factor,load,factor,this,shift,calculate,shift,concurrency,level,int,size,1,this,shift,this,reference,type,reference,type,int,rounded,up,segment,capacity,int,initial,capacity,size,1l,size,this,segments,segment,array,new,instance,segment,class,size,for,int,i,0,i,this,segments,length,i,this,segments,i,new,segment,rounded,up,segment,capacity
ConcurrentReferenceHashMap -> @SuppressWarnings("unchecked") 	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel, 			ReferenceType referenceType);1404132943;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map_@param referenceType the reference type used for entries (soft or weak);@SuppressWarnings("unchecked")_	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel,_			ReferenceType referenceType) {__		Assert.isTrue(initialCapacity >= 0, "Initial capacity must not be negative")__		Assert.isTrue(loadFactor > 0f, "Load factor must be positive")__		Assert.isTrue(concurrencyLevel > 0, "Concurrency level must be positive")__		Assert.notNull(referenceType, "Reference type must not be null")__		this.loadFactor = loadFactor__		this.shift = calculateShift(concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL)__		int size = 1 << this.shift__		this.referenceType = referenceType__		int roundedUpSegmentCapacity = (int) ((initialCapacity + size - 1L) / size)__		this.segments = (Segment[]) Array.newInstance(Segment.class, size)__		for (int i = 0_ i < this.segments.length_ i++) {_			this.segments[i] = new Segment(roundedUpSegmentCapacity)__		}_	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;suppress,warnings,unchecked,public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,reference,type,reference,type,assert,is,true,initial,capacity,0,initial,capacity,must,not,be,negative,assert,is,true,load,factor,0f,load,factor,must,be,positive,assert,is,true,concurrency,level,0,concurrency,level,must,be,positive,assert,not,null,reference,type,reference,type,must,not,be,null,this,load,factor,load,factor,this,shift,calculate,shift,concurrency,level,int,size,1,this,shift,this,reference,type,reference,type,int,rounded,up,segment,capacity,int,initial,capacity,size,1l,size,this,segments,segment,array,new,instance,segment,class,size,for,int,i,0,i,this,segments,length,i,this,segments,i,new,segment,rounded,up,segment,capacity
ConcurrentReferenceHashMap -> @SuppressWarnings("unchecked") 	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel, 			ReferenceType referenceType);1427240641;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map_@param referenceType the reference type used for entries (soft or weak);@SuppressWarnings("unchecked")_	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel,_			ReferenceType referenceType) {__		Assert.isTrue(initialCapacity >= 0, "Initial capacity must not be negative")__		Assert.isTrue(loadFactor > 0f, "Load factor must be positive")__		Assert.isTrue(concurrencyLevel > 0, "Concurrency level must be positive")__		Assert.notNull(referenceType, "Reference type must not be null")__		this.loadFactor = loadFactor__		this.shift = calculateShift(concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL)__		int size = 1 << this.shift__		this.referenceType = referenceType__		int roundedUpSegmentCapacity = (int) ((initialCapacity + size - 1L) / size)__		this.segments = (Segment[]) Array.newInstance(Segment.class, size)__		for (int i = 0_ i < this.segments.length_ i++) {_			this.segments[i] = new Segment(roundedUpSegmentCapacity)__		}_	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;suppress,warnings,unchecked,public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,reference,type,reference,type,assert,is,true,initial,capacity,0,initial,capacity,must,not,be,negative,assert,is,true,load,factor,0f,load,factor,must,be,positive,assert,is,true,concurrency,level,0,concurrency,level,must,be,positive,assert,not,null,reference,type,reference,type,must,not,be,null,this,load,factor,load,factor,this,shift,calculate,shift,concurrency,level,int,size,1,this,shift,this,reference,type,reference,type,int,rounded,up,segment,capacity,int,initial,capacity,size,1l,size,this,segments,segment,array,new,instance,segment,class,size,for,int,i,0,i,this,segments,length,i,this,segments,i,new,segment,rounded,up,segment,capacity
ConcurrentReferenceHashMap -> @SuppressWarnings("unchecked") 	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel, 			ReferenceType referenceType);1459795890;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map_@param referenceType the reference type used for entries (soft or weak);@SuppressWarnings("unchecked")_	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel,_			ReferenceType referenceType) {__		Assert.isTrue(initialCapacity >= 0, "Initial capacity must not be negative")__		Assert.isTrue(loadFactor > 0f, "Load factor must be positive")__		Assert.isTrue(concurrencyLevel > 0, "Concurrency level must be positive")__		Assert.notNull(referenceType, "Reference type must not be null")__		this.loadFactor = loadFactor__		this.shift = calculateShift(concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL)__		int size = 1 << this.shift__		this.referenceType = referenceType__		int roundedUpSegmentCapacity = (int) ((initialCapacity + size - 1L) / size)__		this.segments = (Segment[]) Array.newInstance(Segment.class, size)__		for (int i = 0_ i < this.segments.length_ i++) {_			this.segments[i] = new Segment(roundedUpSegmentCapacity)__		}_	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;suppress,warnings,unchecked,public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,reference,type,reference,type,assert,is,true,initial,capacity,0,initial,capacity,must,not,be,negative,assert,is,true,load,factor,0f,load,factor,must,be,positive,assert,is,true,concurrency,level,0,concurrency,level,must,be,positive,assert,not,null,reference,type,reference,type,must,not,be,null,this,load,factor,load,factor,this,shift,calculate,shift,concurrency,level,int,size,1,this,shift,this,reference,type,reference,type,int,rounded,up,segment,capacity,int,initial,capacity,size,1l,size,this,segments,segment,array,new,instance,segment,class,size,for,int,i,0,i,this,segments,length,i,this,segments,i,new,segment,rounded,up,segment,capacity
ConcurrentReferenceHashMap -> @SuppressWarnings("unchecked") 	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel, 			ReferenceType referenceType);1467730834;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map_@param referenceType the reference type used for entries (soft or weak);@SuppressWarnings("unchecked")_	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel,_			ReferenceType referenceType) {__		Assert.isTrue(initialCapacity >= 0, "Initial capacity must not be negative")__		Assert.isTrue(loadFactor > 0f, "Load factor must be positive")__		Assert.isTrue(concurrencyLevel > 0, "Concurrency level must be positive")__		Assert.notNull(referenceType, "Reference type must not be null")__		this.loadFactor = loadFactor__		this.shift = calculateShift(concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL)__		int size = 1 << this.shift__		this.referenceType = referenceType__		int roundedUpSegmentCapacity = (int) ((initialCapacity + size - 1L) / size)__		this.segments = (Segment[]) Array.newInstance(Segment.class, size)__		for (int i = 0_ i < this.segments.length_ i++) {_			this.segments[i] = new Segment(roundedUpSegmentCapacity)__		}_	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;suppress,warnings,unchecked,public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,reference,type,reference,type,assert,is,true,initial,capacity,0,initial,capacity,must,not,be,negative,assert,is,true,load,factor,0f,load,factor,must,be,positive,assert,is,true,concurrency,level,0,concurrency,level,must,be,positive,assert,not,null,reference,type,reference,type,must,not,be,null,this,load,factor,load,factor,this,shift,calculate,shift,concurrency,level,int,size,1,this,shift,this,reference,type,reference,type,int,rounded,up,segment,capacity,int,initial,capacity,size,1l,size,this,segments,segment,array,new,instance,segment,class,size,for,int,i,0,i,this,segments,length,i,this,segments,i,new,segment,rounded,up,segment,capacity
ConcurrentReferenceHashMap -> @SuppressWarnings("unchecked") 	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel, 			ReferenceType referenceType);1485810955;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map_@param referenceType the reference type used for entries (soft or weak);@SuppressWarnings("unchecked")_	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel,_			ReferenceType referenceType) {__		Assert.isTrue(initialCapacity >= 0, "Initial capacity must not be negative")__		Assert.isTrue(loadFactor > 0f, "Load factor must be positive")__		Assert.isTrue(concurrencyLevel > 0, "Concurrency level must be positive")__		Assert.notNull(referenceType, "Reference type must not be null")__		this.loadFactor = loadFactor__		this.shift = calculateShift(concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL)__		int size = 1 << this.shift__		this.referenceType = referenceType__		int roundedUpSegmentCapacity = (int) ((initialCapacity + size - 1L) / size)__		this.segments = (Segment[]) Array.newInstance(Segment.class, size)__		for (int i = 0_ i < this.segments.length_ i++) {_			this.segments[i] = new Segment(roundedUpSegmentCapacity)__		}_	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;suppress,warnings,unchecked,public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,reference,type,reference,type,assert,is,true,initial,capacity,0,initial,capacity,must,not,be,negative,assert,is,true,load,factor,0f,load,factor,must,be,positive,assert,is,true,concurrency,level,0,concurrency,level,must,be,positive,assert,not,null,reference,type,reference,type,must,not,be,null,this,load,factor,load,factor,this,shift,calculate,shift,concurrency,level,int,size,1,this,shift,this,reference,type,reference,type,int,rounded,up,segment,capacity,int,initial,capacity,size,1l,size,this,segments,segment,array,new,instance,segment,class,size,for,int,i,0,i,this,segments,length,i,this,segments,i,new,segment,rounded,up,segment,capacity
ConcurrentReferenceHashMap -> @SuppressWarnings("unchecked") 	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel, 			ReferenceType referenceType);1495868221;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map_@param referenceType the reference type used for entries (soft or weak);@SuppressWarnings("unchecked")_	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel,_			ReferenceType referenceType) {__		Assert.isTrue(initialCapacity >= 0, "Initial capacity must not be negative")__		Assert.isTrue(loadFactor > 0f, "Load factor must be positive")__		Assert.isTrue(concurrencyLevel > 0, "Concurrency level must be positive")__		Assert.notNull(referenceType, "Reference type must not be null")__		this.loadFactor = loadFactor__		this.shift = calculateShift(concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL)__		int size = 1 << this.shift__		this.referenceType = referenceType__		int roundedUpSegmentCapacity = (int) ((initialCapacity + size - 1L) / size)__		this.segments = (Segment[]) Array.newInstance(Segment.class, size)__		for (int i = 0_ i < this.segments.length_ i++) {_			this.segments[i] = new Segment(roundedUpSegmentCapacity)__		}_	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;suppress,warnings,unchecked,public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,reference,type,reference,type,assert,is,true,initial,capacity,0,initial,capacity,must,not,be,negative,assert,is,true,load,factor,0f,load,factor,must,be,positive,assert,is,true,concurrency,level,0,concurrency,level,must,be,positive,assert,not,null,reference,type,reference,type,must,not,be,null,this,load,factor,load,factor,this,shift,calculate,shift,concurrency,level,int,size,1,this,shift,this,reference,type,reference,type,int,rounded,up,segment,capacity,int,initial,capacity,size,1l,size,this,segments,segment,array,new,instance,segment,class,size,for,int,i,0,i,this,segments,length,i,this,segments,i,new,segment,rounded,up,segment,capacity
ConcurrentReferenceHashMap -> @SuppressWarnings("unchecked") 	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel, 			ReferenceType referenceType);1496242568;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map_@param referenceType the reference type used for entries (soft or weak);@SuppressWarnings("unchecked")_	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel,_			ReferenceType referenceType) {__		Assert.isTrue(initialCapacity >= 0, "Initial capacity must not be negative")__		Assert.isTrue(loadFactor > 0f, "Load factor must be positive")__		Assert.isTrue(concurrencyLevel > 0, "Concurrency level must be positive")__		Assert.notNull(referenceType, "Reference type must not be null")__		this.loadFactor = loadFactor__		this.shift = calculateShift(concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL)__		int size = 1 << this.shift__		this.referenceType = referenceType__		int roundedUpSegmentCapacity = (int) ((initialCapacity + size - 1L) / size)__		this.segments = (Segment[]) Array.newInstance(Segment.class, size)__		for (int i = 0_ i < this.segments.length_ i++) {_			this.segments[i] = new Segment(roundedUpSegmentCapacity)__		}_	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;suppress,warnings,unchecked,public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,reference,type,reference,type,assert,is,true,initial,capacity,0,initial,capacity,must,not,be,negative,assert,is,true,load,factor,0f,load,factor,must,be,positive,assert,is,true,concurrency,level,0,concurrency,level,must,be,positive,assert,not,null,reference,type,reference,type,must,not,be,null,this,load,factor,load,factor,this,shift,calculate,shift,concurrency,level,int,size,1,this,shift,this,reference,type,reference,type,int,rounded,up,segment,capacity,int,initial,capacity,size,1l,size,this,segments,segment,array,new,instance,segment,class,size,for,int,i,0,i,this,segments,length,i,this,segments,i,new,segment,rounded,up,segment,capacity
ConcurrentReferenceHashMap -> @SuppressWarnings("unchecked") 	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel, 			ReferenceType referenceType);1496837955;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map_@param referenceType the reference type used for entries (soft or weak);@SuppressWarnings("unchecked")_	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel,_			ReferenceType referenceType) {__		Assert.isTrue(initialCapacity >= 0, "Initial capacity must not be negative")__		Assert.isTrue(loadFactor > 0f, "Load factor must be positive")__		Assert.isTrue(concurrencyLevel > 0, "Concurrency level must be positive")__		Assert.notNull(referenceType, "Reference type must not be null")__		this.loadFactor = loadFactor__		this.shift = calculateShift(concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL)__		int size = 1 << this.shift__		this.referenceType = referenceType__		int roundedUpSegmentCapacity = (int) ((initialCapacity + size - 1L) / size)__		this.segments = (Segment[]) Array.newInstance(Segment.class, size)__		for (int i = 0_ i < this.segments.length_ i++) {_			this.segments[i] = new Segment(roundedUpSegmentCapacity)__		}_	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;suppress,warnings,unchecked,public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,reference,type,reference,type,assert,is,true,initial,capacity,0,initial,capacity,must,not,be,negative,assert,is,true,load,factor,0f,load,factor,must,be,positive,assert,is,true,concurrency,level,0,concurrency,level,must,be,positive,assert,not,null,reference,type,reference,type,must,not,be,null,this,load,factor,load,factor,this,shift,calculate,shift,concurrency,level,int,size,1,this,shift,this,reference,type,reference,type,int,rounded,up,segment,capacity,int,initial,capacity,size,1l,size,this,segments,segment,array,new,instance,segment,class,size,for,int,i,0,i,this,segments,length,i,this,segments,i,new,segment,rounded,up,segment,capacity
ConcurrentReferenceHashMap -> @SuppressWarnings("unchecked") 	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel, 			ReferenceType referenceType);1498780456;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map_@param referenceType the reference type used for entries (soft or weak);@SuppressWarnings("unchecked")_	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel,_			ReferenceType referenceType) {__		Assert.isTrue(initialCapacity >= 0, "Initial capacity must not be negative")__		Assert.isTrue(loadFactor > 0f, "Load factor must be positive")__		Assert.isTrue(concurrencyLevel > 0, "Concurrency level must be positive")__		Assert.notNull(referenceType, "Reference type must not be null")__		this.loadFactor = loadFactor__		this.shift = calculateShift(concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL)__		int size = 1 << this.shift__		this.referenceType = referenceType__		int roundedUpSegmentCapacity = (int) ((initialCapacity + size - 1L) / size)__		this.segments = (Segment[]) Array.newInstance(Segment.class, size)__		for (int i = 0_ i < this.segments.length_ i++) {_			this.segments[i] = new Segment(roundedUpSegmentCapacity)__		}_	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;suppress,warnings,unchecked,public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,reference,type,reference,type,assert,is,true,initial,capacity,0,initial,capacity,must,not,be,negative,assert,is,true,load,factor,0f,load,factor,must,be,positive,assert,is,true,concurrency,level,0,concurrency,level,must,be,positive,assert,not,null,reference,type,reference,type,must,not,be,null,this,load,factor,load,factor,this,shift,calculate,shift,concurrency,level,int,size,1,this,shift,this,reference,type,reference,type,int,rounded,up,segment,capacity,int,initial,capacity,size,1l,size,this,segments,segment,array,new,instance,segment,class,size,for,int,i,0,i,this,segments,length,i,this,segments,i,new,segment,rounded,up,segment,capacity
ConcurrentReferenceHashMap -> @SuppressWarnings("unchecked") 	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel, 			ReferenceType referenceType);1502974979;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map_@param referenceType the reference type used for entries (soft or weak);@SuppressWarnings("unchecked")_	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel,_			ReferenceType referenceType) {__		Assert.isTrue(initialCapacity >= 0, "Initial capacity must not be negative")__		Assert.isTrue(loadFactor > 0f, "Load factor must be positive")__		Assert.isTrue(concurrencyLevel > 0, "Concurrency level must be positive")__		Assert.notNull(referenceType, "Reference type must not be null")__		this.loadFactor = loadFactor__		this.shift = calculateShift(concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL)__		int size = 1 << this.shift__		this.referenceType = referenceType__		int roundedUpSegmentCapacity = (int) ((initialCapacity + size - 1L) / size)__		this.segments = (Segment[]) Array.newInstance(Segment.class, size)__		for (int i = 0_ i < this.segments.length_ i++) {_			this.segments[i] = new Segment(roundedUpSegmentCapacity)__		}_	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;suppress,warnings,unchecked,public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,reference,type,reference,type,assert,is,true,initial,capacity,0,initial,capacity,must,not,be,negative,assert,is,true,load,factor,0f,load,factor,must,be,positive,assert,is,true,concurrency,level,0,concurrency,level,must,be,positive,assert,not,null,reference,type,reference,type,must,not,be,null,this,load,factor,load,factor,this,shift,calculate,shift,concurrency,level,int,size,1,this,shift,this,reference,type,reference,type,int,rounded,up,segment,capacity,int,initial,capacity,size,1l,size,this,segments,segment,array,new,instance,segment,class,size,for,int,i,0,i,this,segments,length,i,this,segments,i,new,segment,rounded,up,segment,capacity
ConcurrentReferenceHashMap -> @SuppressWarnings("unchecked") 	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel, 			ReferenceType referenceType);1506097334;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map_@param referenceType the reference type used for entries (soft or weak);@SuppressWarnings("unchecked")_	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel,_			ReferenceType referenceType) {__		Assert.isTrue(initialCapacity >= 0, "Initial capacity must not be negative")__		Assert.isTrue(loadFactor > 0f, "Load factor must be positive")__		Assert.isTrue(concurrencyLevel > 0, "Concurrency level must be positive")__		Assert.notNull(referenceType, "Reference type must not be null")__		this.loadFactor = loadFactor__		this.shift = calculateShift(concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL)__		int size = 1 << this.shift__		this.referenceType = referenceType__		int roundedUpSegmentCapacity = (int) ((initialCapacity + size - 1L) / size)__		this.segments = (Segment[]) Array.newInstance(Segment.class, size)__		for (int i = 0_ i < this.segments.length_ i++) {_			this.segments[i] = new Segment(roundedUpSegmentCapacity)__		}_	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;suppress,warnings,unchecked,public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,reference,type,reference,type,assert,is,true,initial,capacity,0,initial,capacity,must,not,be,negative,assert,is,true,load,factor,0f,load,factor,must,be,positive,assert,is,true,concurrency,level,0,concurrency,level,must,be,positive,assert,not,null,reference,type,reference,type,must,not,be,null,this,load,factor,load,factor,this,shift,calculate,shift,concurrency,level,int,size,1,this,shift,this,reference,type,reference,type,int,rounded,up,segment,capacity,int,initial,capacity,size,1l,size,this,segments,segment,array,new,instance,segment,class,size,for,int,i,0,i,this,segments,length,i,this,segments,i,new,segment,rounded,up,segment,capacity
ConcurrentReferenceHashMap -> @SuppressWarnings("unchecked") 	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel, 			ReferenceType referenceType);1521044224;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map_@param referenceType the reference type used for entries (soft or weak);@SuppressWarnings("unchecked")_	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel,_			ReferenceType referenceType) {__		Assert.isTrue(initialCapacity >= 0, "Initial capacity must not be negative")__		Assert.isTrue(loadFactor > 0f, "Load factor must be positive")__		Assert.isTrue(concurrencyLevel > 0, "Concurrency level must be positive")__		Assert.notNull(referenceType, "Reference type must not be null")__		this.loadFactor = loadFactor__		this.shift = calculateShift(concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL)__		int size = 1 << this.shift__		this.referenceType = referenceType__		int roundedUpSegmentCapacity = (int) ((initialCapacity + size - 1L) / size)__		this.segments = (Segment[]) Array.newInstance(Segment.class, size)__		for (int i = 0_ i < this.segments.length_ i++) {_			this.segments[i] = new Segment(roundedUpSegmentCapacity)__		}_	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;suppress,warnings,unchecked,public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,reference,type,reference,type,assert,is,true,initial,capacity,0,initial,capacity,must,not,be,negative,assert,is,true,load,factor,0f,load,factor,must,be,positive,assert,is,true,concurrency,level,0,concurrency,level,must,be,positive,assert,not,null,reference,type,reference,type,must,not,be,null,this,load,factor,load,factor,this,shift,calculate,shift,concurrency,level,int,size,1,this,shift,this,reference,type,reference,type,int,rounded,up,segment,capacity,int,initial,capacity,size,1l,size,this,segments,segment,array,new,instance,segment,class,size,for,int,i,0,i,this,segments,length,i,this,segments,i,new,segment,rounded,up,segment,capacity
ConcurrentReferenceHashMap -> @SuppressWarnings("unchecked") 	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel, 			ReferenceType referenceType);1530174524;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map_@param referenceType the reference type used for entries (soft or weak);@SuppressWarnings("unchecked")_	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel,_			ReferenceType referenceType) {__		Assert.isTrue(initialCapacity >= 0, "Initial capacity must not be negative")__		Assert.isTrue(loadFactor > 0f, "Load factor must be positive")__		Assert.isTrue(concurrencyLevel > 0, "Concurrency level must be positive")__		Assert.notNull(referenceType, "Reference type must not be null")__		this.loadFactor = loadFactor__		this.shift = calculateShift(concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL)__		int size = 1 << this.shift__		this.referenceType = referenceType__		int roundedUpSegmentCapacity = (int) ((initialCapacity + size - 1L) / size)__		this.segments = (Segment[]) Array.newInstance(Segment.class, size)__		for (int i = 0_ i < this.segments.length_ i++) {_			this.segments[i] = new Segment(roundedUpSegmentCapacity)__		}_	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;suppress,warnings,unchecked,public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,reference,type,reference,type,assert,is,true,initial,capacity,0,initial,capacity,must,not,be,negative,assert,is,true,load,factor,0f,load,factor,must,be,positive,assert,is,true,concurrency,level,0,concurrency,level,must,be,positive,assert,not,null,reference,type,reference,type,must,not,be,null,this,load,factor,load,factor,this,shift,calculate,shift,concurrency,level,int,size,1,this,shift,this,reference,type,reference,type,int,rounded,up,segment,capacity,int,initial,capacity,size,1l,size,this,segments,segment,array,new,instance,segment,class,size,for,int,i,0,i,this,segments,length,i,this,segments,i,new,segment,rounded,up,segment,capacity
ConcurrentReferenceHashMap -> @SuppressWarnings("unchecked") 	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel, 			ReferenceType referenceType);1530190293;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map_@param referenceType the reference type used for entries (soft or weak);@SuppressWarnings("unchecked")_	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel,_			ReferenceType referenceType) {__		Assert.isTrue(initialCapacity >= 0, "Initial capacity must not be negative")__		Assert.isTrue(loadFactor > 0f, "Load factor must be positive")__		Assert.isTrue(concurrencyLevel > 0, "Concurrency level must be positive")__		Assert.notNull(referenceType, "Reference type must not be null")__		this.loadFactor = loadFactor__		this.shift = calculateShift(concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL)__		int size = 1 << this.shift__		this.referenceType = referenceType__		int roundedUpSegmentCapacity = (int) ((initialCapacity + size - 1L) / size)__		this.segments = (Segment[]) Array.newInstance(Segment.class, size)__		for (int i = 0_ i < this.segments.length_ i++) {_			this.segments[i] = new Segment(roundedUpSegmentCapacity)__		}_	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;suppress,warnings,unchecked,public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,reference,type,reference,type,assert,is,true,initial,capacity,0,initial,capacity,must,not,be,negative,assert,is,true,load,factor,0f,load,factor,must,be,positive,assert,is,true,concurrency,level,0,concurrency,level,must,be,positive,assert,not,null,reference,type,reference,type,must,not,be,null,this,load,factor,load,factor,this,shift,calculate,shift,concurrency,level,int,size,1,this,shift,this,reference,type,reference,type,int,rounded,up,segment,capacity,int,initial,capacity,size,1l,size,this,segments,segment,array,new,instance,segment,class,size,for,int,i,0,i,this,segments,length,i,this,segments,i,new,segment,rounded,up,segment,capacity
ConcurrentReferenceHashMap -> Reference -> @Nullable 		Entry<K, V> get()_;1495868221;Returns the referenced entry or {@code null} if the entry is no longer_available._@return the entry or {@code null};@Nullable_		Entry<K, V> get()_;returns,the,referenced,entry,or,code,null,if,the,entry,is,no,longer,available,return,the,entry,or,code,null;nullable,entry,k,v,get
ConcurrentReferenceHashMap -> Reference -> @Nullable 		Entry<K, V> get()_;1496242568;Returns the referenced entry or {@code null} if the entry is no longer_available._@return the entry or {@code null};@Nullable_		Entry<K, V> get()_;returns,the,referenced,entry,or,code,null,if,the,entry,is,no,longer,available,return,the,entry,or,code,null;nullable,entry,k,v,get
ConcurrentReferenceHashMap -> Reference -> @Nullable 		Entry<K, V> get()_;1496837955;Return the referenced entry, or {@code null} if the entry is no longer available.;@Nullable_		Entry<K, V> get()_;return,the,referenced,entry,or,code,null,if,the,entry,is,no,longer,available;nullable,entry,k,v,get
ConcurrentReferenceHashMap -> Reference -> @Nullable 		Entry<K, V> get()_;1498780456;Return the referenced entry, or {@code null} if the entry is no longer available.;@Nullable_		Entry<K, V> get()_;return,the,referenced,entry,or,code,null,if,the,entry,is,no,longer,available;nullable,entry,k,v,get
ConcurrentReferenceHashMap -> Reference -> @Nullable 		Entry<K, V> get()_;1502974979;Return the referenced entry, or {@code null} if the entry is no longer available.;@Nullable_		Entry<K, V> get()_;return,the,referenced,entry,or,code,null,if,the,entry,is,no,longer,available;nullable,entry,k,v,get
ConcurrentReferenceHashMap -> Reference -> @Nullable 		Entry<K, V> get()_;1506097334;Return the referenced entry, or {@code null} if the entry is no longer available.;@Nullable_		Entry<K, V> get()_;return,the,referenced,entry,or,code,null,if,the,entry,is,no,longer,available;nullable,entry,k,v,get
ConcurrentReferenceHashMap -> Reference -> @Nullable 		Entry<K, V> get()_;1521044224;Return the referenced entry, or {@code null} if the entry is no longer available.;@Nullable_		Entry<K, V> get()_;return,the,referenced,entry,or,code,null,if,the,entry,is,no,longer,available;nullable,entry,k,v,get
ConcurrentReferenceHashMap -> Reference -> @Nullable 		Entry<K, V> get()_;1530174524;Return the referenced entry, or {@code null} if the entry is no longer available.;@Nullable_		Entry<K, V> get()_;return,the,referenced,entry,or,code,null,if,the,entry,is,no,longer,available;nullable,entry,k,v,get
ConcurrentReferenceHashMap -> Reference -> @Nullable 		Entry<K, V> get()_;1530190293;Return the referenced entry, or {@code null} if the entry is no longer available.;@Nullable_		Entry<K, V> get()_;return,the,referenced,entry,or,code,null,if,the,entry,is,no,longer,available;nullable,entry,k,v,get
ConcurrentReferenceHashMap -> Reference -> @Nullable 		Entry<K, V> get()_;1530563577;Return the referenced entry, or {@code null} if the entry is no longer available.;@Nullable_		Entry<K, V> get()_;return,the,referenced,entry,or,code,null,if,the,entry,is,no,longer,available;nullable,entry,k,v,get
ConcurrentReferenceHashMap -> Reference -> @Nullable 		Entry<K, V> get()_;1531136363;Return the referenced entry, or {@code null} if the entry is no longer available.;@Nullable_		Entry<K, V> get()_;return,the,referenced,entry,or,code,null,if,the,entry,is,no,longer,available;nullable,entry,k,v,get
ConcurrentReferenceHashMap -> Reference -> @Nullable 		Entry<K, V> get()_;1531139295;Return the referenced entry, or {@code null} if the entry is no longer available.;@Nullable_		Entry<K, V> get()_;return,the,referenced,entry,or,code,null,if,the,entry,is,no,longer,available;nullable,entry,k,v,get
ConcurrentReferenceHashMap -> Reference -> @Nullable 		Entry<K, V> get()_;1544716668;Return the referenced entry, or {@code null} if the entry is no longer available.;@Nullable_		Entry<K, V> get()_;return,the,referenced,entry,or,code,null,if,the,entry,is,no,longer,available;nullable,entry,k,v,get
ConcurrentReferenceHashMap -> Reference -> @Nullable 		Entry<K, V> get()_;1549318940;Return the referenced entry, or {@code null} if the entry is no longer available.;@Nullable_		Entry<K, V> get()_;return,the,referenced,entry,or,code,null,if,the,entry,is,no,longer,available;nullable,entry,k,v,get
ConcurrentReferenceHashMap -> Reference -> @Nullable 		Entry<K, V> get()_;1549321822;Return the referenced entry, or {@code null} if the entry is no longer available.;@Nullable_		Entry<K, V> get()_;return,the,referenced,entry,or,code,null,if,the,entry,is,no,longer,available;nullable,entry,k,v,get
ConcurrentReferenceHashMap -> Reference -> @Nullable 		Entry<K, V> get()_;1550237263;Return the referenced entry, or {@code null} if the entry is no longer available.;@Nullable_		Entry<K, V> get()_;return,the,referenced,entry,or,code,null,if,the,entry,is,no,longer,available;nullable,entry,k,v,get
ConcurrentReferenceHashMap -> Reference -> void release()_;1351982790;Release this entry and ensure that it will be returned from_{@link ReferenceManager#pollForPurge()}.;void release()_;release,this,entry,and,ensure,that,it,will,be,returned,from,link,reference,manager,poll,for,purge;void,release
ConcurrentReferenceHashMap -> Reference -> void release()_;1352039846;Release this entry and ensure that it will be returned from_{@link ReferenceManager#pollForPurge()}.;void release()_;release,this,entry,and,ensure,that,it,will,be,returned,from,link,reference,manager,poll,for,purge;void,release
ConcurrentReferenceHashMap -> Reference -> void release()_;1355313310;Release this entry and ensure that it will be returned from_{@link ReferenceManager#pollForPurge()}.;void release()_;release,this,entry,and,ensure,that,it,will,be,returned,from,link,reference,manager,poll,for,purge;void,release
ConcurrentReferenceHashMap -> Reference -> void release()_;1356735495;Release this entry and ensure that it will be returned from_{@link ReferenceManager#pollForPurge()}.;void release()_;release,this,entry,and,ensure,that,it,will,be,returned,from,link,reference,manager,poll,for,purge;void,release
ConcurrentReferenceHashMap -> Reference -> void release()_;1357119239;Release this entry and ensure that it will be returned from_{@link ReferenceManager#pollForPurge()}.;void release()_;release,this,entry,and,ensure,that,it,will,be,returned,from,link,reference,manager,poll,for,purge;void,release
ConcurrentReferenceHashMap -> Reference -> void release()_;1368482696;Release this entry and ensure that it will be returned from_{@link ReferenceManager#pollForPurge()}.;void release()_;release,this,entry,and,ensure,that,it,will,be,returned,from,link,reference,manager,poll,for,purge;void,release
ConcurrentReferenceHashMap -> Reference -> void release()_;1383090835;Release this entry and ensure that it will be returned from_{@link ReferenceManager#pollForPurge()}.;void release()_;release,this,entry,and,ensure,that,it,will,be,returned,from,link,reference,manager,poll,for,purge;void,release
ConcurrentReferenceHashMap -> Reference -> void release()_;1383178438;Release this entry and ensure that it will be returned from_{@link ReferenceManager#pollForPurge()}.;void release()_;release,this,entry,and,ensure,that,it,will,be,returned,from,link,reference,manager,poll,for,purge;void,release
ConcurrentReferenceHashMap -> Reference -> void release()_;1390260938;Release this entry and ensure that it will be returned from_{@code ReferenceManager#pollForPurge()}.;void release()_;release,this,entry,and,ensure,that,it,will,be,returned,from,code,reference,manager,poll,for,purge;void,release
ConcurrentReferenceHashMap -> Reference -> void release()_;1391715359;Release this entry and ensure that it will be returned from_{@code ReferenceManager#pollForPurge()}.;void release()_;release,this,entry,and,ensure,that,it,will,be,returned,from,code,reference,manager,poll,for,purge;void,release
ConcurrentReferenceHashMap -> Reference -> void release()_;1392765030;Release this entry and ensure that it will be returned from_{@code ReferenceManager#pollForPurge()}.;void release()_;release,this,entry,and,ensure,that,it,will,be,returned,from,code,reference,manager,poll,for,purge;void,release
ConcurrentReferenceHashMap -> Reference -> void release()_;1398175099;Release this entry and ensure that it will be returned from_{@code ReferenceManager#pollForPurge()}.;void release()_;release,this,entry,and,ensure,that,it,will,be,returned,from,code,reference,manager,poll,for,purge;void,release
ConcurrentReferenceHashMap -> Reference -> void release()_;1404132943;Release this entry and ensure that it will be returned from_{@code ReferenceManager#pollForPurge()}.;void release()_;release,this,entry,and,ensure,that,it,will,be,returned,from,code,reference,manager,poll,for,purge;void,release
ConcurrentReferenceHashMap -> Reference -> void release()_;1427240641;Release this entry and ensure that it will be returned from_{@code ReferenceManager#pollForPurge()}.;void release()_;release,this,entry,and,ensure,that,it,will,be,returned,from,code,reference,manager,poll,for,purge;void,release
ConcurrentReferenceHashMap -> Reference -> void release()_;1459795890;Release this entry and ensure that it will be returned from_{@code ReferenceManager#pollForPurge()}.;void release()_;release,this,entry,and,ensure,that,it,will,be,returned,from,code,reference,manager,poll,for,purge;void,release
ConcurrentReferenceHashMap -> Reference -> void release()_;1467730834;Release this entry and ensure that it will be returned from_{@code ReferenceManager#pollForPurge()}.;void release()_;release,this,entry,and,ensure,that,it,will,be,returned,from,code,reference,manager,poll,for,purge;void,release
ConcurrentReferenceHashMap -> Reference -> void release()_;1485810955;Release this entry and ensure that it will be returned from_{@code ReferenceManager#pollForPurge()}.;void release()_;release,this,entry,and,ensure,that,it,will,be,returned,from,code,reference,manager,poll,for,purge;void,release
ConcurrentReferenceHashMap -> Reference -> void release()_;1495868221;Release this entry and ensure that it will be returned from_{@code ReferenceManager#pollForPurge()}.;void release()_;release,this,entry,and,ensure,that,it,will,be,returned,from,code,reference,manager,poll,for,purge;void,release
ConcurrentReferenceHashMap -> Reference -> void release()_;1496242568;Release this entry and ensure that it will be returned from_{@code ReferenceManager#pollForPurge()}.;void release()_;release,this,entry,and,ensure,that,it,will,be,returned,from,code,reference,manager,poll,for,purge;void,release
ConcurrentReferenceHashMap -> Reference -> void release()_;1496837955;Release this entry and ensure that it will be returned from_{@code ReferenceManager#pollForPurge()}.;void release()_;release,this,entry,and,ensure,that,it,will,be,returned,from,code,reference,manager,poll,for,purge;void,release
ConcurrentReferenceHashMap -> Reference -> void release()_;1498780456;Release this entry and ensure that it will be returned from_{@code ReferenceManager#pollForPurge()}.;void release()_;release,this,entry,and,ensure,that,it,will,be,returned,from,code,reference,manager,poll,for,purge;void,release
ConcurrentReferenceHashMap -> Reference -> void release()_;1502974979;Release this entry and ensure that it will be returned from_{@code ReferenceManager#pollForPurge()}.;void release()_;release,this,entry,and,ensure,that,it,will,be,returned,from,code,reference,manager,poll,for,purge;void,release
ConcurrentReferenceHashMap -> Reference -> void release()_;1506097334;Release this entry and ensure that it will be returned from_{@code ReferenceManager#pollForPurge()}.;void release()_;release,this,entry,and,ensure,that,it,will,be,returned,from,code,reference,manager,poll,for,purge;void,release
ConcurrentReferenceHashMap -> Reference -> void release()_;1521044224;Release this entry and ensure that it will be returned from_{@code ReferenceManager#pollForPurge()}.;void release()_;release,this,entry,and,ensure,that,it,will,be,returned,from,code,reference,manager,poll,for,purge;void,release
ConcurrentReferenceHashMap -> Reference -> void release()_;1530174524;Release this entry and ensure that it will be returned from_{@code ReferenceManager#pollForPurge()}.;void release()_;release,this,entry,and,ensure,that,it,will,be,returned,from,code,reference,manager,poll,for,purge;void,release
ConcurrentReferenceHashMap -> Reference -> void release()_;1530190293;Release this entry and ensure that it will be returned from_{@code ReferenceManager#pollForPurge()}.;void release()_;release,this,entry,and,ensure,that,it,will,be,returned,from,code,reference,manager,poll,for,purge;void,release
ConcurrentReferenceHashMap -> Reference -> void release()_;1530563577;Release this entry and ensure that it will be returned from_{@code ReferenceManager#pollForPurge()}.;void release()_;release,this,entry,and,ensure,that,it,will,be,returned,from,code,reference,manager,poll,for,purge;void,release
ConcurrentReferenceHashMap -> Reference -> void release()_;1531136363;Release this entry and ensure that it will be returned from_{@code ReferenceManager#pollForPurge()}.;void release()_;release,this,entry,and,ensure,that,it,will,be,returned,from,code,reference,manager,poll,for,purge;void,release
ConcurrentReferenceHashMap -> Reference -> void release()_;1531139295;Release this entry and ensure that it will be returned from_{@code ReferenceManager#pollForPurge()}.;void release()_;release,this,entry,and,ensure,that,it,will,be,returned,from,code,reference,manager,poll,for,purge;void,release
ConcurrentReferenceHashMap -> Reference -> void release()_;1544716668;Release this entry and ensure that it will be returned from_{@code ReferenceManager#pollForPurge()}.;void release()_;release,this,entry,and,ensure,that,it,will,be,returned,from,code,reference,manager,poll,for,purge;void,release
ConcurrentReferenceHashMap -> Reference -> void release()_;1549318940;Release this entry and ensure that it will be returned from_{@code ReferenceManager#pollForPurge()}.;void release()_;release,this,entry,and,ensure,that,it,will,be,returned,from,code,reference,manager,poll,for,purge;void,release
ConcurrentReferenceHashMap -> Reference -> void release()_;1549321822;Release this entry and ensure that it will be returned from_{@code ReferenceManager#pollForPurge()}.;void release()_;release,this,entry,and,ensure,that,it,will,be,returned,from,code,reference,manager,poll,for,purge;void,release
ConcurrentReferenceHashMap -> Reference -> void release()_;1550237263;Release this entry and ensure that it will be returned from_{@code ReferenceManager#pollForPurge()}.;void release()_;release,this,entry,and,ensure,that,it,will,be,returned,from,code,reference,manager,poll,for,purge;void,release
ConcurrentReferenceHashMap -> ReferenceManager -> public Reference<K, V> createReference(Entry<K, V> entry, int hash, Reference<K, V> next);1383090835;Factory method used to create a new {@link Reference}._@param entry the entry contained in the reference_@param hash the hash_@param next the next reference in the chain or {@code null}_@return a new {@link Reference};public Reference<K, V> createReference(Entry<K, V> entry, int hash, Reference<K, V> next) {_			if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {_				return new WeakEntryReference<K, V>(entry, hash, next, this.queue)__			}_			return new SoftEntryReference<K, V>(entry, hash, next, this.queue)__		};factory,method,used,to,create,a,new,link,reference,param,entry,the,entry,contained,in,the,reference,param,hash,the,hash,param,next,the,next,reference,in,the,chain,or,code,null,return,a,new,link,reference;public,reference,k,v,create,reference,entry,k,v,entry,int,hash,reference,k,v,next,if,concurrent,reference,hash,map,this,reference,type,reference,type,weak,return,new,weak,entry,reference,k,v,entry,hash,next,this,queue,return,new,soft,entry,reference,k,v,entry,hash,next,this,queue
ConcurrentReferenceHashMap -> ReferenceManager -> public Reference<K, V> createReference(Entry<K, V> entry, int hash, Reference<K, V> next);1383178438;Factory method used to create a new {@link Reference}._@param entry the entry contained in the reference_@param hash the hash_@param next the next reference in the chain or {@code null}_@return a new {@link Reference};public Reference<K, V> createReference(Entry<K, V> entry, int hash, Reference<K, V> next) {_			if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {_				return new WeakEntryReference<K, V>(entry, hash, next, this.queue)__			}_			return new SoftEntryReference<K, V>(entry, hash, next, this.queue)__		};factory,method,used,to,create,a,new,link,reference,param,entry,the,entry,contained,in,the,reference,param,hash,the,hash,param,next,the,next,reference,in,the,chain,or,code,null,return,a,new,link,reference;public,reference,k,v,create,reference,entry,k,v,entry,int,hash,reference,k,v,next,if,concurrent,reference,hash,map,this,reference,type,reference,type,weak,return,new,weak,entry,reference,k,v,entry,hash,next,this,queue,return,new,soft,entry,reference,k,v,entry,hash,next,this,queue
ConcurrentReferenceHashMap -> ReferenceManager -> public Reference<K, V> createReference(Entry<K, V> entry, int hash, Reference<K, V> next);1390260938;Factory method used to create a new {@link Reference}._@param entry the entry contained in the reference_@param hash the hash_@param next the next reference in the chain or {@code null}_@return a new {@link Reference};public Reference<K, V> createReference(Entry<K, V> entry, int hash, Reference<K, V> next) {_			if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {_				return new WeakEntryReference<K, V>(entry, hash, next, this.queue)__			}_			return new SoftEntryReference<K, V>(entry, hash, next, this.queue)__		};factory,method,used,to,create,a,new,link,reference,param,entry,the,entry,contained,in,the,reference,param,hash,the,hash,param,next,the,next,reference,in,the,chain,or,code,null,return,a,new,link,reference;public,reference,k,v,create,reference,entry,k,v,entry,int,hash,reference,k,v,next,if,concurrent,reference,hash,map,this,reference,type,reference,type,weak,return,new,weak,entry,reference,k,v,entry,hash,next,this,queue,return,new,soft,entry,reference,k,v,entry,hash,next,this,queue
ConcurrentReferenceHashMap -> ReferenceManager -> public Reference<K, V> createReference(Entry<K, V> entry, int hash, Reference<K, V> next);1391715359;Factory method used to create a new {@link Reference}._@param entry the entry contained in the reference_@param hash the hash_@param next the next reference in the chain or {@code null}_@return a new {@link Reference};public Reference<K, V> createReference(Entry<K, V> entry, int hash, Reference<K, V> next) {_			if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {_				return new WeakEntryReference<K, V>(entry, hash, next, this.queue)__			}_			return new SoftEntryReference<K, V>(entry, hash, next, this.queue)__		};factory,method,used,to,create,a,new,link,reference,param,entry,the,entry,contained,in,the,reference,param,hash,the,hash,param,next,the,next,reference,in,the,chain,or,code,null,return,a,new,link,reference;public,reference,k,v,create,reference,entry,k,v,entry,int,hash,reference,k,v,next,if,concurrent,reference,hash,map,this,reference,type,reference,type,weak,return,new,weak,entry,reference,k,v,entry,hash,next,this,queue,return,new,soft,entry,reference,k,v,entry,hash,next,this,queue
ConcurrentReferenceHashMap -> ReferenceManager -> public Reference<K, V> createReference(Entry<K, V> entry, int hash, Reference<K, V> next);1392765030;Factory method used to create a new {@link Reference}._@param entry the entry contained in the reference_@param hash the hash_@param next the next reference in the chain or {@code null}_@return a new {@link Reference};public Reference<K, V> createReference(Entry<K, V> entry, int hash, Reference<K, V> next) {_			if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {_				return new WeakEntryReference<K, V>(entry, hash, next, this.queue)__			}_			return new SoftEntryReference<K, V>(entry, hash, next, this.queue)__		};factory,method,used,to,create,a,new,link,reference,param,entry,the,entry,contained,in,the,reference,param,hash,the,hash,param,next,the,next,reference,in,the,chain,or,code,null,return,a,new,link,reference;public,reference,k,v,create,reference,entry,k,v,entry,int,hash,reference,k,v,next,if,concurrent,reference,hash,map,this,reference,type,reference,type,weak,return,new,weak,entry,reference,k,v,entry,hash,next,this,queue,return,new,soft,entry,reference,k,v,entry,hash,next,this,queue
ConcurrentReferenceHashMap -> ReferenceManager -> public Reference<K, V> createReference(Entry<K, V> entry, int hash, Reference<K, V> next);1398175099;Factory method used to create a new {@link Reference}._@param entry the entry contained in the reference_@param hash the hash_@param next the next reference in the chain or {@code null}_@return a new {@link Reference};public Reference<K, V> createReference(Entry<K, V> entry, int hash, Reference<K, V> next) {_			if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {_				return new WeakEntryReference<K, V>(entry, hash, next, this.queue)__			}_			return new SoftEntryReference<K, V>(entry, hash, next, this.queue)__		};factory,method,used,to,create,a,new,link,reference,param,entry,the,entry,contained,in,the,reference,param,hash,the,hash,param,next,the,next,reference,in,the,chain,or,code,null,return,a,new,link,reference;public,reference,k,v,create,reference,entry,k,v,entry,int,hash,reference,k,v,next,if,concurrent,reference,hash,map,this,reference,type,reference,type,weak,return,new,weak,entry,reference,k,v,entry,hash,next,this,queue,return,new,soft,entry,reference,k,v,entry,hash,next,this,queue
ConcurrentReferenceHashMap -> ReferenceManager -> public Reference<K, V> createReference(Entry<K, V> entry, int hash, Reference<K, V> next);1404132943;Factory method used to create a new {@link Reference}._@param entry the entry contained in the reference_@param hash the hash_@param next the next reference in the chain or {@code null}_@return a new {@link Reference};public Reference<K, V> createReference(Entry<K, V> entry, int hash, Reference<K, V> next) {_			if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {_				return new WeakEntryReference<K, V>(entry, hash, next, this.queue)__			}_			return new SoftEntryReference<K, V>(entry, hash, next, this.queue)__		};factory,method,used,to,create,a,new,link,reference,param,entry,the,entry,contained,in,the,reference,param,hash,the,hash,param,next,the,next,reference,in,the,chain,or,code,null,return,a,new,link,reference;public,reference,k,v,create,reference,entry,k,v,entry,int,hash,reference,k,v,next,if,concurrent,reference,hash,map,this,reference,type,reference,type,weak,return,new,weak,entry,reference,k,v,entry,hash,next,this,queue,return,new,soft,entry,reference,k,v,entry,hash,next,this,queue
ConcurrentReferenceHashMap -> ReferenceManager -> public Reference<K, V> createReference(Entry<K, V> entry, int hash, Reference<K, V> next);1427240641;Factory method used to create a new {@link Reference}._@param entry the entry contained in the reference_@param hash the hash_@param next the next reference in the chain or {@code null}_@return a new {@link Reference};public Reference<K, V> createReference(Entry<K, V> entry, int hash, Reference<K, V> next) {_			if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {_				return new WeakEntryReference<K, V>(entry, hash, next, this.queue)__			}_			return new SoftEntryReference<K, V>(entry, hash, next, this.queue)__		};factory,method,used,to,create,a,new,link,reference,param,entry,the,entry,contained,in,the,reference,param,hash,the,hash,param,next,the,next,reference,in,the,chain,or,code,null,return,a,new,link,reference;public,reference,k,v,create,reference,entry,k,v,entry,int,hash,reference,k,v,next,if,concurrent,reference,hash,map,this,reference,type,reference,type,weak,return,new,weak,entry,reference,k,v,entry,hash,next,this,queue,return,new,soft,entry,reference,k,v,entry,hash,next,this,queue
ConcurrentReferenceHashMap -> ReferenceManager -> public Reference<K, V> createReference(Entry<K, V> entry, int hash, Reference<K, V> next);1459795890;Factory method used to create a new {@link Reference}._@param entry the entry contained in the reference_@param hash the hash_@param next the next reference in the chain or {@code null}_@return a new {@link Reference};public Reference<K, V> createReference(Entry<K, V> entry, int hash, Reference<K, V> next) {_			if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {_				return new WeakEntryReference<K, V>(entry, hash, next, this.queue)__			}_			return new SoftEntryReference<K, V>(entry, hash, next, this.queue)__		};factory,method,used,to,create,a,new,link,reference,param,entry,the,entry,contained,in,the,reference,param,hash,the,hash,param,next,the,next,reference,in,the,chain,or,code,null,return,a,new,link,reference;public,reference,k,v,create,reference,entry,k,v,entry,int,hash,reference,k,v,next,if,concurrent,reference,hash,map,this,reference,type,reference,type,weak,return,new,weak,entry,reference,k,v,entry,hash,next,this,queue,return,new,soft,entry,reference,k,v,entry,hash,next,this,queue
ConcurrentReferenceHashMap -> ReferenceManager -> public Reference<K, V> createReference(Entry<K, V> entry, int hash, Reference<K, V> next);1467730834;Factory method used to create a new {@link Reference}._@param entry the entry contained in the reference_@param hash the hash_@param next the next reference in the chain or {@code null}_@return a new {@link Reference};public Reference<K, V> createReference(Entry<K, V> entry, int hash, Reference<K, V> next) {_			if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {_				return new WeakEntryReference<>(entry, hash, next, this.queue)__			}_			return new SoftEntryReference<>(entry, hash, next, this.queue)__		};factory,method,used,to,create,a,new,link,reference,param,entry,the,entry,contained,in,the,reference,param,hash,the,hash,param,next,the,next,reference,in,the,chain,or,code,null,return,a,new,link,reference;public,reference,k,v,create,reference,entry,k,v,entry,int,hash,reference,k,v,next,if,concurrent,reference,hash,map,this,reference,type,reference,type,weak,return,new,weak,entry,reference,entry,hash,next,this,queue,return,new,soft,entry,reference,entry,hash,next,this,queue
ConcurrentReferenceHashMap -> ReferenceManager -> public Reference<K, V> createReference(Entry<K, V> entry, int hash, Reference<K, V> next);1485810955;Factory method used to create a new {@link Reference}._@param entry the entry contained in the reference_@param hash the hash_@param next the next reference in the chain or {@code null}_@return a new {@link Reference};public Reference<K, V> createReference(Entry<K, V> entry, int hash, Reference<K, V> next) {_			if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {_				return new WeakEntryReference<>(entry, hash, next, this.queue)__			}_			return new SoftEntryReference<>(entry, hash, next, this.queue)__		};factory,method,used,to,create,a,new,link,reference,param,entry,the,entry,contained,in,the,reference,param,hash,the,hash,param,next,the,next,reference,in,the,chain,or,code,null,return,a,new,link,reference;public,reference,k,v,create,reference,entry,k,v,entry,int,hash,reference,k,v,next,if,concurrent,reference,hash,map,this,reference,type,reference,type,weak,return,new,weak,entry,reference,entry,hash,next,this,queue,return,new,soft,entry,reference,entry,hash,next,this,queue
ConcurrentReferenceHashMap -> Task -> @Nullable 		protected T execute(@Nullable Reference<K, V> reference, @Nullable Entry<K, V> entry, Entries entries);1495868221;Execute the task._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@param entries access to the underlying entries_@return the result of the task_@see #execute(Reference, Entry);@Nullable_		protected T execute(@Nullable Reference<K, V> reference, @Nullable Entry<K, V> entry, Entries entries) {_			return execute(reference, entry)__		};execute,the,task,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,param,entries,access,to,the,underlying,entries,return,the,result,of,the,task,see,execute,reference,entry;nullable,protected,t,execute,nullable,reference,k,v,reference,nullable,entry,k,v,entry,entries,entries,return,execute,reference,entry
ConcurrentReferenceHashMap -> Task -> @Nullable 		protected T execute(@Nullable Reference<K, V> reference, @Nullable Entry<K, V> entry, Entries entries);1496242568;Execute the task._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@param entries access to the underlying entries_@return the result of the task_@see #execute(Reference, Entry);@Nullable_		protected T execute(@Nullable Reference<K, V> reference, @Nullable Entry<K, V> entry, Entries entries) {_			return execute(reference, entry)__		};execute,the,task,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,param,entries,access,to,the,underlying,entries,return,the,result,of,the,task,see,execute,reference,entry;nullable,protected,t,execute,nullable,reference,k,v,reference,nullable,entry,k,v,entry,entries,entries,return,execute,reference,entry
ConcurrentReferenceHashMap -> ReferenceManager -> public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next);1495868221;Factory method used to create a new {@link Reference}._@param entry the entry contained in the reference_@param hash the hash_@param next the next reference in the chain or {@code null}_@return a new {@link Reference};public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next) {_			if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {_				return new WeakEntryReference<>(entry, hash, next, this.queue)__			}_			return new SoftEntryReference<>(entry, hash, next, this.queue)__		};factory,method,used,to,create,a,new,link,reference,param,entry,the,entry,contained,in,the,reference,param,hash,the,hash,param,next,the,next,reference,in,the,chain,or,code,null,return,a,new,link,reference;public,reference,k,v,create,reference,entry,k,v,entry,int,hash,nullable,reference,k,v,next,if,concurrent,reference,hash,map,this,reference,type,reference,type,weak,return,new,weak,entry,reference,entry,hash,next,this,queue,return,new,soft,entry,reference,entry,hash,next,this,queue
ConcurrentReferenceHashMap -> ReferenceManager -> public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next);1496242568;Factory method used to create a new {@link Reference}._@param entry the entry contained in the reference_@param hash the hash_@param next the next reference in the chain or {@code null}_@return a new {@link Reference};public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next) {_			if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {_				return new WeakEntryReference<>(entry, hash, next, this.queue)__			}_			return new SoftEntryReference<>(entry, hash, next, this.queue)__		};factory,method,used,to,create,a,new,link,reference,param,entry,the,entry,contained,in,the,reference,param,hash,the,hash,param,next,the,next,reference,in,the,chain,or,code,null,return,a,new,link,reference;public,reference,k,v,create,reference,entry,k,v,entry,int,hash,nullable,reference,k,v,next,if,concurrent,reference,hash,map,this,reference,type,reference,type,weak,return,new,weak,entry,reference,entry,hash,next,this,queue,return,new,soft,entry,reference,entry,hash,next,this,queue
ConcurrentReferenceHashMap -> ReferenceManager -> public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next);1496837955;Factory method used to create a new {@link Reference}._@param entry the entry contained in the reference_@param hash the hash_@param next the next reference in the chain, or {@code null} if none_@return a new {@link Reference};public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next) {_			if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {_				return new WeakEntryReference<>(entry, hash, next, this.queue)__			}_			return new SoftEntryReference<>(entry, hash, next, this.queue)__		};factory,method,used,to,create,a,new,link,reference,param,entry,the,entry,contained,in,the,reference,param,hash,the,hash,param,next,the,next,reference,in,the,chain,or,code,null,if,none,return,a,new,link,reference;public,reference,k,v,create,reference,entry,k,v,entry,int,hash,nullable,reference,k,v,next,if,concurrent,reference,hash,map,this,reference,type,reference,type,weak,return,new,weak,entry,reference,entry,hash,next,this,queue,return,new,soft,entry,reference,entry,hash,next,this,queue
ConcurrentReferenceHashMap -> ReferenceManager -> public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next);1498780456;Factory method used to create a new {@link Reference}._@param entry the entry contained in the reference_@param hash the hash_@param next the next reference in the chain, or {@code null} if none_@return a new {@link Reference};public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next) {_			if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {_				return new WeakEntryReference<>(entry, hash, next, this.queue)__			}_			return new SoftEntryReference<>(entry, hash, next, this.queue)__		};factory,method,used,to,create,a,new,link,reference,param,entry,the,entry,contained,in,the,reference,param,hash,the,hash,param,next,the,next,reference,in,the,chain,or,code,null,if,none,return,a,new,link,reference;public,reference,k,v,create,reference,entry,k,v,entry,int,hash,nullable,reference,k,v,next,if,concurrent,reference,hash,map,this,reference,type,reference,type,weak,return,new,weak,entry,reference,entry,hash,next,this,queue,return,new,soft,entry,reference,entry,hash,next,this,queue
ConcurrentReferenceHashMap -> ReferenceManager -> public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next);1502974979;Factory method used to create a new {@link Reference}._@param entry the entry contained in the reference_@param hash the hash_@param next the next reference in the chain, or {@code null} if none_@return a new {@link Reference};public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next) {_			if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {_				return new WeakEntryReference<>(entry, hash, next, this.queue)__			}_			return new SoftEntryReference<>(entry, hash, next, this.queue)__		};factory,method,used,to,create,a,new,link,reference,param,entry,the,entry,contained,in,the,reference,param,hash,the,hash,param,next,the,next,reference,in,the,chain,or,code,null,if,none,return,a,new,link,reference;public,reference,k,v,create,reference,entry,k,v,entry,int,hash,nullable,reference,k,v,next,if,concurrent,reference,hash,map,this,reference,type,reference,type,weak,return,new,weak,entry,reference,entry,hash,next,this,queue,return,new,soft,entry,reference,entry,hash,next,this,queue
ConcurrentReferenceHashMap -> ReferenceManager -> public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next);1506097334;Factory method used to create a new {@link Reference}._@param entry the entry contained in the reference_@param hash the hash_@param next the next reference in the chain, or {@code null} if none_@return a new {@link Reference};public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next) {_			if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {_				return new WeakEntryReference<>(entry, hash, next, this.queue)__			}_			return new SoftEntryReference<>(entry, hash, next, this.queue)__		};factory,method,used,to,create,a,new,link,reference,param,entry,the,entry,contained,in,the,reference,param,hash,the,hash,param,next,the,next,reference,in,the,chain,or,code,null,if,none,return,a,new,link,reference;public,reference,k,v,create,reference,entry,k,v,entry,int,hash,nullable,reference,k,v,next,if,concurrent,reference,hash,map,this,reference,type,reference,type,weak,return,new,weak,entry,reference,entry,hash,next,this,queue,return,new,soft,entry,reference,entry,hash,next,this,queue
ConcurrentReferenceHashMap -> ReferenceManager -> public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next);1521044224;Factory method used to create a new {@link Reference}._@param entry the entry contained in the reference_@param hash the hash_@param next the next reference in the chain, or {@code null} if none_@return a new {@link Reference};public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next) {_			if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {_				return new WeakEntryReference<>(entry, hash, next, this.queue)__			}_			return new SoftEntryReference<>(entry, hash, next, this.queue)__		};factory,method,used,to,create,a,new,link,reference,param,entry,the,entry,contained,in,the,reference,param,hash,the,hash,param,next,the,next,reference,in,the,chain,or,code,null,if,none,return,a,new,link,reference;public,reference,k,v,create,reference,entry,k,v,entry,int,hash,nullable,reference,k,v,next,if,concurrent,reference,hash,map,this,reference,type,reference,type,weak,return,new,weak,entry,reference,entry,hash,next,this,queue,return,new,soft,entry,reference,entry,hash,next,this,queue
ConcurrentReferenceHashMap -> ReferenceManager -> public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next);1530174524;Factory method used to create a new {@link Reference}._@param entry the entry contained in the reference_@param hash the hash_@param next the next reference in the chain, or {@code null} if none_@return a new {@link Reference};public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next) {_			if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {_				return new WeakEntryReference<>(entry, hash, next, this.queue)__			}_			return new SoftEntryReference<>(entry, hash, next, this.queue)__		};factory,method,used,to,create,a,new,link,reference,param,entry,the,entry,contained,in,the,reference,param,hash,the,hash,param,next,the,next,reference,in,the,chain,or,code,null,if,none,return,a,new,link,reference;public,reference,k,v,create,reference,entry,k,v,entry,int,hash,nullable,reference,k,v,next,if,concurrent,reference,hash,map,this,reference,type,reference,type,weak,return,new,weak,entry,reference,entry,hash,next,this,queue,return,new,soft,entry,reference,entry,hash,next,this,queue
ConcurrentReferenceHashMap -> ReferenceManager -> public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next);1530190293;Factory method used to create a new {@link Reference}._@param entry the entry contained in the reference_@param hash the hash_@param next the next reference in the chain, or {@code null} if none_@return a new {@link Reference};public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next) {_			if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {_				return new WeakEntryReference<>(entry, hash, next, this.queue)__			}_			return new SoftEntryReference<>(entry, hash, next, this.queue)__		};factory,method,used,to,create,a,new,link,reference,param,entry,the,entry,contained,in,the,reference,param,hash,the,hash,param,next,the,next,reference,in,the,chain,or,code,null,if,none,return,a,new,link,reference;public,reference,k,v,create,reference,entry,k,v,entry,int,hash,nullable,reference,k,v,next,if,concurrent,reference,hash,map,this,reference,type,reference,type,weak,return,new,weak,entry,reference,entry,hash,next,this,queue,return,new,soft,entry,reference,entry,hash,next,this,queue
ConcurrentReferenceHashMap -> ReferenceManager -> public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next);1530563577;Factory method used to create a new {@link Reference}._@param entry the entry contained in the reference_@param hash the hash_@param next the next reference in the chain, or {@code null} if none_@return a new {@link Reference};public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next) {_			if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {_				return new WeakEntryReference<>(entry, hash, next, this.queue)__			}_			return new SoftEntryReference<>(entry, hash, next, this.queue)__		};factory,method,used,to,create,a,new,link,reference,param,entry,the,entry,contained,in,the,reference,param,hash,the,hash,param,next,the,next,reference,in,the,chain,or,code,null,if,none,return,a,new,link,reference;public,reference,k,v,create,reference,entry,k,v,entry,int,hash,nullable,reference,k,v,next,if,concurrent,reference,hash,map,this,reference,type,reference,type,weak,return,new,weak,entry,reference,entry,hash,next,this,queue,return,new,soft,entry,reference,entry,hash,next,this,queue
ConcurrentReferenceHashMap -> ReferenceManager -> public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next);1531136363;Factory method used to create a new {@link Reference}._@param entry the entry contained in the reference_@param hash the hash_@param next the next reference in the chain, or {@code null} if none_@return a new {@link Reference};public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next) {_			if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {_				return new WeakEntryReference<>(entry, hash, next, this.queue)__			}_			return new SoftEntryReference<>(entry, hash, next, this.queue)__		};factory,method,used,to,create,a,new,link,reference,param,entry,the,entry,contained,in,the,reference,param,hash,the,hash,param,next,the,next,reference,in,the,chain,or,code,null,if,none,return,a,new,link,reference;public,reference,k,v,create,reference,entry,k,v,entry,int,hash,nullable,reference,k,v,next,if,concurrent,reference,hash,map,this,reference,type,reference,type,weak,return,new,weak,entry,reference,entry,hash,next,this,queue,return,new,soft,entry,reference,entry,hash,next,this,queue
ConcurrentReferenceHashMap -> ReferenceManager -> public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next);1531139295;Factory method used to create a new {@link Reference}._@param entry the entry contained in the reference_@param hash the hash_@param next the next reference in the chain, or {@code null} if none_@return a new {@link Reference};public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next) {_			if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {_				return new WeakEntryReference<>(entry, hash, next, this.queue)__			}_			return new SoftEntryReference<>(entry, hash, next, this.queue)__		};factory,method,used,to,create,a,new,link,reference,param,entry,the,entry,contained,in,the,reference,param,hash,the,hash,param,next,the,next,reference,in,the,chain,or,code,null,if,none,return,a,new,link,reference;public,reference,k,v,create,reference,entry,k,v,entry,int,hash,nullable,reference,k,v,next,if,concurrent,reference,hash,map,this,reference,type,reference,type,weak,return,new,weak,entry,reference,entry,hash,next,this,queue,return,new,soft,entry,reference,entry,hash,next,this,queue
ConcurrentReferenceHashMap -> ReferenceManager -> public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next);1544716668;Factory method used to create a new {@link Reference}._@param entry the entry contained in the reference_@param hash the hash_@param next the next reference in the chain, or {@code null} if none_@return a new {@link Reference};public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next) {_			if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {_				return new WeakEntryReference<>(entry, hash, next, this.queue)__			}_			return new SoftEntryReference<>(entry, hash, next, this.queue)__		};factory,method,used,to,create,a,new,link,reference,param,entry,the,entry,contained,in,the,reference,param,hash,the,hash,param,next,the,next,reference,in,the,chain,or,code,null,if,none,return,a,new,link,reference;public,reference,k,v,create,reference,entry,k,v,entry,int,hash,nullable,reference,k,v,next,if,concurrent,reference,hash,map,this,reference,type,reference,type,weak,return,new,weak,entry,reference,entry,hash,next,this,queue,return,new,soft,entry,reference,entry,hash,next,this,queue
ConcurrentReferenceHashMap -> ReferenceManager -> public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next);1549318940;Factory method used to create a new {@link Reference}._@param entry the entry contained in the reference_@param hash the hash_@param next the next reference in the chain, or {@code null} if none_@return a new {@link Reference};public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next) {_			if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {_				return new WeakEntryReference<>(entry, hash, next, this.queue)__			}_			return new SoftEntryReference<>(entry, hash, next, this.queue)__		};factory,method,used,to,create,a,new,link,reference,param,entry,the,entry,contained,in,the,reference,param,hash,the,hash,param,next,the,next,reference,in,the,chain,or,code,null,if,none,return,a,new,link,reference;public,reference,k,v,create,reference,entry,k,v,entry,int,hash,nullable,reference,k,v,next,if,concurrent,reference,hash,map,this,reference,type,reference,type,weak,return,new,weak,entry,reference,entry,hash,next,this,queue,return,new,soft,entry,reference,entry,hash,next,this,queue
ConcurrentReferenceHashMap -> ReferenceManager -> public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next);1549321822;Factory method used to create a new {@link Reference}._@param entry the entry contained in the reference_@param hash the hash_@param next the next reference in the chain, or {@code null} if none_@return a new {@link Reference};public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next) {_			if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {_				return new WeakEntryReference<>(entry, hash, next, this.queue)__			}_			return new SoftEntryReference<>(entry, hash, next, this.queue)__		};factory,method,used,to,create,a,new,link,reference,param,entry,the,entry,contained,in,the,reference,param,hash,the,hash,param,next,the,next,reference,in,the,chain,or,code,null,if,none,return,a,new,link,reference;public,reference,k,v,create,reference,entry,k,v,entry,int,hash,nullable,reference,k,v,next,if,concurrent,reference,hash,map,this,reference,type,reference,type,weak,return,new,weak,entry,reference,entry,hash,next,this,queue,return,new,soft,entry,reference,entry,hash,next,this,queue
ConcurrentReferenceHashMap -> ReferenceManager -> public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next);1550237263;Factory method used to create a new {@link Reference}._@param entry the entry contained in the reference_@param hash the hash_@param next the next reference in the chain, or {@code null} if none_@return a new {@link Reference};public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next) {_			if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {_				return new WeakEntryReference<>(entry, hash, next, this.queue)__			}_			return new SoftEntryReference<>(entry, hash, next, this.queue)__		};factory,method,used,to,create,a,new,link,reference,param,entry,the,entry,contained,in,the,reference,param,hash,the,hash,param,next,the,next,reference,in,the,chain,or,code,null,if,none,return,a,new,link,reference;public,reference,k,v,create,reference,entry,k,v,entry,int,hash,nullable,reference,k,v,next,if,concurrent,reference,hash,map,this,reference,type,reference,type,weak,return,new,weak,entry,reference,entry,hash,next,this,queue,return,new,soft,entry,reference,entry,hash,next,this,queue
ConcurrentReferenceHashMap -> Segment -> protected final void restructureIfNecessary(boolean allowResize);1392765030;Restructure the underlying data structure when it becomes necessary. This_method can increase the size of the references table as well as purge any_references that have been garbage collected._@param allowResize if resizing is permitted;protected final void restructureIfNecessary(boolean allowResize) {_			boolean needsResize = ((this.count > 0) && (this.count >= this.resizeThreshold))__			Reference<K, V> reference = this.referenceManager.pollForPurge()__			if ((reference != null) || (needsResize && allowResize)) {_				lock()__				try {_					int countAfterRestructure = this.count___					Set<Reference<K, V>> toPurge = Collections.emptySet()__					if (reference != null) {_						toPurge = new HashSet<Reference<K, V>>()__						while (reference != null) {_							toPurge.add(reference)__							reference = this.referenceManager.pollForPurge()__						}_					}_					countAfterRestructure -= toPurge.size()___					_					_					needsResize = ((countAfterRestructure > 0) && (countAfterRestructure >= this.resizeThreshold))__					boolean resizing = false__					int restructureSize = this.references.length__					if (allowResize && needsResize && (restructureSize < MAXIMUM_SEGMENT_SIZE)) {_						restructureSize <<= 1__						resizing = true__					}__					_					Reference<K, V>[] restructured =  (resizing ? createReferenceArray(restructureSize) : this.references)___					_					for (int i = 0_ i < this.references.length_ i++) {_						reference = this.references[i]__						if (!resizing) {_							restructured[i] = null__						}_						while (reference != null) {_							if (!toPurge.contains(reference) && (reference.get() != null)) {_								int index = getIndex(reference.getHash(), restructured)__								restructured[index] = this.referenceManager.createReference(_										reference.get(), reference.getHash(),_										restructured[index])__							}_							reference = reference.getNext()__						}_					}__					_					if (resizing) {_						setReferences(restructured)__					}_					this.count = Math.max(countAfterRestructure, 0)__				} finally {_					unlock()__				}_			}_		};restructure,the,underlying,data,structure,when,it,becomes,necessary,this,method,can,increase,the,size,of,the,references,table,as,well,as,purge,any,references,that,have,been,garbage,collected,param,allow,resize,if,resizing,is,permitted;protected,final,void,restructure,if,necessary,boolean,allow,resize,boolean,needs,resize,this,count,0,this,count,this,resize,threshold,reference,k,v,reference,this,reference,manager,poll,for,purge,if,reference,null,needs,resize,allow,resize,lock,try,int,count,after,restructure,this,count,set,reference,k,v,to,purge,collections,empty,set,if,reference,null,to,purge,new,hash,set,reference,k,v,while,reference,null,to,purge,add,reference,reference,this,reference,manager,poll,for,purge,count,after,restructure,to,purge,size,needs,resize,count,after,restructure,0,count,after,restructure,this,resize,threshold,boolean,resizing,false,int,restructure,size,this,references,length,if,allow,resize,needs,resize,restructure,size,restructure,size,1,resizing,true,reference,k,v,restructured,resizing,create,reference,array,restructure,size,this,references,for,int,i,0,i,this,references,length,i,reference,this,references,i,if,resizing,restructured,i,null,while,reference,null,if,to,purge,contains,reference,reference,get,null,int,index,get,index,reference,get,hash,restructured,restructured,index,this,reference,manager,create,reference,reference,get,reference,get,hash,restructured,index,reference,reference,get,next,if,resizing,set,references,restructured,this,count,math,max,count,after,restructure,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> protected final void restructureIfNecessary(boolean allowResize);1398175099;Restructure the underlying data structure when it becomes necessary. This_method can increase the size of the references table as well as purge any_references that have been garbage collected._@param allowResize if resizing is permitted;protected final void restructureIfNecessary(boolean allowResize) {_			boolean needsResize = ((this.count > 0) && (this.count >= this.resizeThreshold))__			Reference<K, V> reference = this.referenceManager.pollForPurge()__			if ((reference != null) || (needsResize && allowResize)) {_				lock()__				try {_					int countAfterRestructure = this.count___					Set<Reference<K, V>> toPurge = Collections.emptySet()__					if (reference != null) {_						toPurge = new HashSet<Reference<K, V>>()__						while (reference != null) {_							toPurge.add(reference)__							reference = this.referenceManager.pollForPurge()__						}_					}_					countAfterRestructure -= toPurge.size()___					_					_					needsResize = ((countAfterRestructure > 0) && (countAfterRestructure >= this.resizeThreshold))__					boolean resizing = false__					int restructureSize = this.references.length__					if (allowResize && needsResize && (restructureSize < MAXIMUM_SEGMENT_SIZE)) {_						restructureSize <<= 1__						resizing = true__					}__					_					Reference<K, V>[] restructured =  (resizing ? createReferenceArray(restructureSize) : this.references)___					_					for (int i = 0_ i < this.references.length_ i++) {_						reference = this.references[i]__						if (!resizing) {_							restructured[i] = null__						}_						while (reference != null) {_							if (!toPurge.contains(reference) && (reference.get() != null)) {_								int index = getIndex(reference.getHash(), restructured)__								restructured[index] = this.referenceManager.createReference(_										reference.get(), reference.getHash(),_										restructured[index])__							}_							reference = reference.getNext()__						}_					}__					_					if (resizing) {_						setReferences(restructured)__					}_					this.count = Math.max(countAfterRestructure, 0)__				} finally {_					unlock()__				}_			}_		};restructure,the,underlying,data,structure,when,it,becomes,necessary,this,method,can,increase,the,size,of,the,references,table,as,well,as,purge,any,references,that,have,been,garbage,collected,param,allow,resize,if,resizing,is,permitted;protected,final,void,restructure,if,necessary,boolean,allow,resize,boolean,needs,resize,this,count,0,this,count,this,resize,threshold,reference,k,v,reference,this,reference,manager,poll,for,purge,if,reference,null,needs,resize,allow,resize,lock,try,int,count,after,restructure,this,count,set,reference,k,v,to,purge,collections,empty,set,if,reference,null,to,purge,new,hash,set,reference,k,v,while,reference,null,to,purge,add,reference,reference,this,reference,manager,poll,for,purge,count,after,restructure,to,purge,size,needs,resize,count,after,restructure,0,count,after,restructure,this,resize,threshold,boolean,resizing,false,int,restructure,size,this,references,length,if,allow,resize,needs,resize,restructure,size,restructure,size,1,resizing,true,reference,k,v,restructured,resizing,create,reference,array,restructure,size,this,references,for,int,i,0,i,this,references,length,i,reference,this,references,i,if,resizing,restructured,i,null,while,reference,null,if,to,purge,contains,reference,reference,get,null,int,index,get,index,reference,get,hash,restructured,restructured,index,this,reference,manager,create,reference,reference,get,reference,get,hash,restructured,index,reference,reference,get,next,if,resizing,set,references,restructured,this,count,math,max,count,after,restructure,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> protected final void restructureIfNecessary(boolean allowResize);1404132943;Restructure the underlying data structure when it becomes necessary. This_method can increase the size of the references table as well as purge any_references that have been garbage collected._@param allowResize if resizing is permitted;protected final void restructureIfNecessary(boolean allowResize) {_			boolean needsResize = ((this.count > 0) && (this.count >= this.resizeThreshold))__			Reference<K, V> reference = this.referenceManager.pollForPurge()__			if ((reference != null) || (needsResize && allowResize)) {_				lock()__				try {_					int countAfterRestructure = this.count___					Set<Reference<K, V>> toPurge = Collections.emptySet()__					if (reference != null) {_						toPurge = new HashSet<Reference<K, V>>()__						while (reference != null) {_							toPurge.add(reference)__							reference = this.referenceManager.pollForPurge()__						}_					}_					countAfterRestructure -= toPurge.size()___					_					_					needsResize = (countAfterRestructure > 0 && countAfterRestructure >= this.resizeThreshold)__					boolean resizing = false__					int restructureSize = this.references.length__					if (allowResize && needsResize && restructureSize < MAXIMUM_SEGMENT_SIZE) {_						restructureSize <<= 1__						resizing = true__					}__					_					Reference<K, V>[] restructured = (resizing ? createReferenceArray(restructureSize) : this.references)___					_					for (int i = 0_ i < this.references.length_ i++) {_						reference = this.references[i]__						if (!resizing) {_							restructured[i] = null__						}_						while (reference != null) {_							if (!toPurge.contains(reference) && (reference.get() != null)) {_								int index = getIndex(reference.getHash(), restructured)__								restructured[index] = this.referenceManager.createReference(_										reference.get(), reference.getHash(),_										restructured[index])__							}_							reference = reference.getNext()__						}_					}__					_					if (resizing) {_						setReferences(restructured)__					}_					this.count = Math.max(countAfterRestructure, 0)__				}_				finally {_					unlock()__				}_			}_		};restructure,the,underlying,data,structure,when,it,becomes,necessary,this,method,can,increase,the,size,of,the,references,table,as,well,as,purge,any,references,that,have,been,garbage,collected,param,allow,resize,if,resizing,is,permitted;protected,final,void,restructure,if,necessary,boolean,allow,resize,boolean,needs,resize,this,count,0,this,count,this,resize,threshold,reference,k,v,reference,this,reference,manager,poll,for,purge,if,reference,null,needs,resize,allow,resize,lock,try,int,count,after,restructure,this,count,set,reference,k,v,to,purge,collections,empty,set,if,reference,null,to,purge,new,hash,set,reference,k,v,while,reference,null,to,purge,add,reference,reference,this,reference,manager,poll,for,purge,count,after,restructure,to,purge,size,needs,resize,count,after,restructure,0,count,after,restructure,this,resize,threshold,boolean,resizing,false,int,restructure,size,this,references,length,if,allow,resize,needs,resize,restructure,size,restructure,size,1,resizing,true,reference,k,v,restructured,resizing,create,reference,array,restructure,size,this,references,for,int,i,0,i,this,references,length,i,reference,this,references,i,if,resizing,restructured,i,null,while,reference,null,if,to,purge,contains,reference,reference,get,null,int,index,get,index,reference,get,hash,restructured,restructured,index,this,reference,manager,create,reference,reference,get,reference,get,hash,restructured,index,reference,reference,get,next,if,resizing,set,references,restructured,this,count,math,max,count,after,restructure,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> protected final void restructureIfNecessary(boolean allowResize);1427240641;Restructure the underlying data structure when it becomes necessary. This_method can increase the size of the references table as well as purge any_references that have been garbage collected._@param allowResize if resizing is permitted;protected final void restructureIfNecessary(boolean allowResize) {_			boolean needsResize = ((this.count > 0) && (this.count >= this.resizeThreshold))__			Reference<K, V> reference = this.referenceManager.pollForPurge()__			if ((reference != null) || (needsResize && allowResize)) {_				lock()__				try {_					int countAfterRestructure = this.count___					Set<Reference<K, V>> toPurge = Collections.emptySet()__					if (reference != null) {_						toPurge = new HashSet<Reference<K, V>>()__						while (reference != null) {_							toPurge.add(reference)__							reference = this.referenceManager.pollForPurge()__						}_					}_					countAfterRestructure -= toPurge.size()___					_					_					needsResize = (countAfterRestructure > 0 && countAfterRestructure >= this.resizeThreshold)__					boolean resizing = false__					int restructureSize = this.references.length__					if (allowResize && needsResize && restructureSize < MAXIMUM_SEGMENT_SIZE) {_						restructureSize <<= 1__						resizing = true__					}__					_					Reference<K, V>[] restructured = (resizing ? createReferenceArray(restructureSize) : this.references)___					_					for (int i = 0_ i < this.references.length_ i++) {_						reference = this.references[i]__						if (!resizing) {_							restructured[i] = null__						}_						while (reference != null) {_							if (!toPurge.contains(reference) && (reference.get() != null)) {_								int index = getIndex(reference.getHash(), restructured)__								restructured[index] = this.referenceManager.createReference(_										reference.get(), reference.getHash(),_										restructured[index])__							}_							reference = reference.getNext()__						}_					}__					_					if (resizing) {_						setReferences(restructured)__					}_					this.count = Math.max(countAfterRestructure, 0)__				}_				finally {_					unlock()__				}_			}_		};restructure,the,underlying,data,structure,when,it,becomes,necessary,this,method,can,increase,the,size,of,the,references,table,as,well,as,purge,any,references,that,have,been,garbage,collected,param,allow,resize,if,resizing,is,permitted;protected,final,void,restructure,if,necessary,boolean,allow,resize,boolean,needs,resize,this,count,0,this,count,this,resize,threshold,reference,k,v,reference,this,reference,manager,poll,for,purge,if,reference,null,needs,resize,allow,resize,lock,try,int,count,after,restructure,this,count,set,reference,k,v,to,purge,collections,empty,set,if,reference,null,to,purge,new,hash,set,reference,k,v,while,reference,null,to,purge,add,reference,reference,this,reference,manager,poll,for,purge,count,after,restructure,to,purge,size,needs,resize,count,after,restructure,0,count,after,restructure,this,resize,threshold,boolean,resizing,false,int,restructure,size,this,references,length,if,allow,resize,needs,resize,restructure,size,restructure,size,1,resizing,true,reference,k,v,restructured,resizing,create,reference,array,restructure,size,this,references,for,int,i,0,i,this,references,length,i,reference,this,references,i,if,resizing,restructured,i,null,while,reference,null,if,to,purge,contains,reference,reference,get,null,int,index,get,index,reference,get,hash,restructured,restructured,index,this,reference,manager,create,reference,reference,get,reference,get,hash,restructured,index,reference,reference,get,next,if,resizing,set,references,restructured,this,count,math,max,count,after,restructure,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> protected final void restructureIfNecessary(boolean allowResize);1459795890;Restructure the underlying data structure when it becomes necessary. This_method can increase the size of the references table as well as purge any_references that have been garbage collected._@param allowResize if resizing is permitted;protected final void restructureIfNecessary(boolean allowResize) {_			boolean needsResize = ((this.count > 0) && (this.count >= this.resizeThreshold))__			Reference<K, V> reference = this.referenceManager.pollForPurge()__			if ((reference != null) || (needsResize && allowResize)) {_				lock()__				try {_					int countAfterRestructure = this.count___					Set<Reference<K, V>> toPurge = Collections.emptySet()__					if (reference != null) {_						toPurge = new HashSet<Reference<K, V>>()__						while (reference != null) {_							toPurge.add(reference)__							reference = this.referenceManager.pollForPurge()__						}_					}_					countAfterRestructure -= toPurge.size()___					_					_					needsResize = (countAfterRestructure > 0 && countAfterRestructure >= this.resizeThreshold)__					boolean resizing = false__					int restructureSize = this.references.length__					if (allowResize && needsResize && restructureSize < MAXIMUM_SEGMENT_SIZE) {_						restructureSize <<= 1__						resizing = true__					}__					_					Reference<K, V>[] restructured = (resizing ? createReferenceArray(restructureSize) : this.references)___					_					for (int i = 0_ i < this.references.length_ i++) {_						reference = this.references[i]__						if (!resizing) {_							restructured[i] = null__						}_						while (reference != null) {_							if (!toPurge.contains(reference) && (reference.get() != null)) {_								int index = getIndex(reference.getHash(), restructured)__								restructured[index] = this.referenceManager.createReference(_										reference.get(), reference.getHash(),_										restructured[index])__							}_							reference = reference.getNext()__						}_					}__					_					if (resizing) {_						setReferences(restructured)__					}_					this.count = Math.max(countAfterRestructure, 0)__				}_				finally {_					unlock()__				}_			}_		};restructure,the,underlying,data,structure,when,it,becomes,necessary,this,method,can,increase,the,size,of,the,references,table,as,well,as,purge,any,references,that,have,been,garbage,collected,param,allow,resize,if,resizing,is,permitted;protected,final,void,restructure,if,necessary,boolean,allow,resize,boolean,needs,resize,this,count,0,this,count,this,resize,threshold,reference,k,v,reference,this,reference,manager,poll,for,purge,if,reference,null,needs,resize,allow,resize,lock,try,int,count,after,restructure,this,count,set,reference,k,v,to,purge,collections,empty,set,if,reference,null,to,purge,new,hash,set,reference,k,v,while,reference,null,to,purge,add,reference,reference,this,reference,manager,poll,for,purge,count,after,restructure,to,purge,size,needs,resize,count,after,restructure,0,count,after,restructure,this,resize,threshold,boolean,resizing,false,int,restructure,size,this,references,length,if,allow,resize,needs,resize,restructure,size,restructure,size,1,resizing,true,reference,k,v,restructured,resizing,create,reference,array,restructure,size,this,references,for,int,i,0,i,this,references,length,i,reference,this,references,i,if,resizing,restructured,i,null,while,reference,null,if,to,purge,contains,reference,reference,get,null,int,index,get,index,reference,get,hash,restructured,restructured,index,this,reference,manager,create,reference,reference,get,reference,get,hash,restructured,index,reference,reference,get,next,if,resizing,set,references,restructured,this,count,math,max,count,after,restructure,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> protected final void restructureIfNecessary(boolean allowResize);1467730834;Restructure the underlying data structure when it becomes necessary. This_method can increase the size of the references table as well as purge any_references that have been garbage collected._@param allowResize if resizing is permitted;protected final void restructureIfNecessary(boolean allowResize) {_			boolean needsResize = ((this.count > 0) && (this.count >= this.resizeThreshold))__			Reference<K, V> reference = this.referenceManager.pollForPurge()__			if ((reference != null) || (needsResize && allowResize)) {_				lock()__				try {_					int countAfterRestructure = this.count___					Set<Reference<K, V>> toPurge = Collections.emptySet()__					if (reference != null) {_						toPurge = new HashSet<>()__						while (reference != null) {_							toPurge.add(reference)__							reference = this.referenceManager.pollForPurge()__						}_					}_					countAfterRestructure -= toPurge.size()___					_					_					needsResize = (countAfterRestructure > 0 && countAfterRestructure >= this.resizeThreshold)__					boolean resizing = false__					int restructureSize = this.references.length__					if (allowResize && needsResize && restructureSize < MAXIMUM_SEGMENT_SIZE) {_						restructureSize <<= 1__						resizing = true__					}__					_					Reference<K, V>[] restructured = (resizing ? createReferenceArray(restructureSize) : this.references)___					_					for (int i = 0_ i < this.references.length_ i++) {_						reference = this.references[i]__						if (!resizing) {_							restructured[i] = null__						}_						while (reference != null) {_							if (!toPurge.contains(reference) && (reference.get() != null)) {_								int index = getIndex(reference.getHash(), restructured)__								restructured[index] = this.referenceManager.createReference(_										reference.get(), reference.getHash(),_										restructured[index])__							}_							reference = reference.getNext()__						}_					}__					_					if (resizing) {_						setReferences(restructured)__					}_					this.count = Math.max(countAfterRestructure, 0)__				}_				finally {_					unlock()__				}_			}_		};restructure,the,underlying,data,structure,when,it,becomes,necessary,this,method,can,increase,the,size,of,the,references,table,as,well,as,purge,any,references,that,have,been,garbage,collected,param,allow,resize,if,resizing,is,permitted;protected,final,void,restructure,if,necessary,boolean,allow,resize,boolean,needs,resize,this,count,0,this,count,this,resize,threshold,reference,k,v,reference,this,reference,manager,poll,for,purge,if,reference,null,needs,resize,allow,resize,lock,try,int,count,after,restructure,this,count,set,reference,k,v,to,purge,collections,empty,set,if,reference,null,to,purge,new,hash,set,while,reference,null,to,purge,add,reference,reference,this,reference,manager,poll,for,purge,count,after,restructure,to,purge,size,needs,resize,count,after,restructure,0,count,after,restructure,this,resize,threshold,boolean,resizing,false,int,restructure,size,this,references,length,if,allow,resize,needs,resize,restructure,size,restructure,size,1,resizing,true,reference,k,v,restructured,resizing,create,reference,array,restructure,size,this,references,for,int,i,0,i,this,references,length,i,reference,this,references,i,if,resizing,restructured,i,null,while,reference,null,if,to,purge,contains,reference,reference,get,null,int,index,get,index,reference,get,hash,restructured,restructured,index,this,reference,manager,create,reference,reference,get,reference,get,hash,restructured,index,reference,reference,get,next,if,resizing,set,references,restructured,this,count,math,max,count,after,restructure,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> protected final void restructureIfNecessary(boolean allowResize);1485810955;Restructure the underlying data structure when it becomes necessary. This_method can increase the size of the references table as well as purge any_references that have been garbage collected._@param allowResize if resizing is permitted;protected final void restructureIfNecessary(boolean allowResize) {_			boolean needsResize = ((this.count > 0) && (this.count >= this.resizeThreshold))__			Reference<K, V> reference = this.referenceManager.pollForPurge()__			if ((reference != null) || (needsResize && allowResize)) {_				lock()__				try {_					int countAfterRestructure = this.count___					Set<Reference<K, V>> toPurge = Collections.emptySet()__					if (reference != null) {_						toPurge = new HashSet<>()__						while (reference != null) {_							toPurge.add(reference)__							reference = this.referenceManager.pollForPurge()__						}_					}_					countAfterRestructure -= toPurge.size()___					_					_					needsResize = (countAfterRestructure > 0 && countAfterRestructure >= this.resizeThreshold)__					boolean resizing = false__					int restructureSize = this.references.length__					if (allowResize && needsResize && restructureSize < MAXIMUM_SEGMENT_SIZE) {_						restructureSize <<= 1__						resizing = true__					}__					_					Reference<K, V>[] restructured = (resizing ? createReferenceArray(restructureSize) : this.references)___					_					for (int i = 0_ i < this.references.length_ i++) {_						reference = this.references[i]__						if (!resizing) {_							restructured[i] = null__						}_						while (reference != null) {_							if (!toPurge.contains(reference) && (reference.get() != null)) {_								int index = getIndex(reference.getHash(), restructured)__								restructured[index] = this.referenceManager.createReference(_										reference.get(), reference.getHash(),_										restructured[index])__							}_							reference = reference.getNext()__						}_					}__					_					if (resizing) {_						setReferences(restructured)__					}_					this.count = Math.max(countAfterRestructure, 0)__				}_				finally {_					unlock()__				}_			}_		};restructure,the,underlying,data,structure,when,it,becomes,necessary,this,method,can,increase,the,size,of,the,references,table,as,well,as,purge,any,references,that,have,been,garbage,collected,param,allow,resize,if,resizing,is,permitted;protected,final,void,restructure,if,necessary,boolean,allow,resize,boolean,needs,resize,this,count,0,this,count,this,resize,threshold,reference,k,v,reference,this,reference,manager,poll,for,purge,if,reference,null,needs,resize,allow,resize,lock,try,int,count,after,restructure,this,count,set,reference,k,v,to,purge,collections,empty,set,if,reference,null,to,purge,new,hash,set,while,reference,null,to,purge,add,reference,reference,this,reference,manager,poll,for,purge,count,after,restructure,to,purge,size,needs,resize,count,after,restructure,0,count,after,restructure,this,resize,threshold,boolean,resizing,false,int,restructure,size,this,references,length,if,allow,resize,needs,resize,restructure,size,restructure,size,1,resizing,true,reference,k,v,restructured,resizing,create,reference,array,restructure,size,this,references,for,int,i,0,i,this,references,length,i,reference,this,references,i,if,resizing,restructured,i,null,while,reference,null,if,to,purge,contains,reference,reference,get,null,int,index,get,index,reference,get,hash,restructured,restructured,index,this,reference,manager,create,reference,reference,get,reference,get,hash,restructured,index,reference,reference,get,next,if,resizing,set,references,restructured,this,count,math,max,count,after,restructure,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> protected final void restructureIfNecessary(boolean allowResize);1495868221;Restructure the underlying data structure when it becomes necessary. This_method can increase the size of the references table as well as purge any_references that have been garbage collected._@param allowResize if resizing is permitted;protected final void restructureIfNecessary(boolean allowResize) {_			boolean needsResize = ((this.count > 0) && (this.count >= this.resizeThreshold))__			Reference<K, V> reference = this.referenceManager.pollForPurge()__			if ((reference != null) || (needsResize && allowResize)) {_				lock()__				try {_					int countAfterRestructure = this.count___					Set<Reference<K, V>> toPurge = Collections.emptySet()__					if (reference != null) {_						toPurge = new HashSet<>()__						while (reference != null) {_							toPurge.add(reference)__							reference = this.referenceManager.pollForPurge()__						}_					}_					countAfterRestructure -= toPurge.size()___					_					_					needsResize = (countAfterRestructure > 0 && countAfterRestructure >= this.resizeThreshold)__					boolean resizing = false__					int restructureSize = this.references.length__					if (allowResize && needsResize && restructureSize < MAXIMUM_SEGMENT_SIZE) {_						restructureSize <<= 1__						resizing = true__					}__					_					Reference<K, V>[] restructured = (resizing ? createReferenceArray(restructureSize) : this.references)___					_					for (int i = 0_ i < this.references.length_ i++) {_						reference = this.references[i]__						if (!resizing) {_							restructured[i] = null__						}_						while (reference != null) {_							if (!toPurge.contains(reference) && (reference.get() != null)) {_								int index = getIndex(reference.getHash(), restructured)__								restructured[index] = this.referenceManager.createReference(_										reference.get(), reference.getHash(),_										restructured[index])__							}_							reference = reference.getNext()__						}_					}__					_					if (resizing) {_						setReferences(restructured)__					}_					this.count = Math.max(countAfterRestructure, 0)__				}_				finally {_					unlock()__				}_			}_		};restructure,the,underlying,data,structure,when,it,becomes,necessary,this,method,can,increase,the,size,of,the,references,table,as,well,as,purge,any,references,that,have,been,garbage,collected,param,allow,resize,if,resizing,is,permitted;protected,final,void,restructure,if,necessary,boolean,allow,resize,boolean,needs,resize,this,count,0,this,count,this,resize,threshold,reference,k,v,reference,this,reference,manager,poll,for,purge,if,reference,null,needs,resize,allow,resize,lock,try,int,count,after,restructure,this,count,set,reference,k,v,to,purge,collections,empty,set,if,reference,null,to,purge,new,hash,set,while,reference,null,to,purge,add,reference,reference,this,reference,manager,poll,for,purge,count,after,restructure,to,purge,size,needs,resize,count,after,restructure,0,count,after,restructure,this,resize,threshold,boolean,resizing,false,int,restructure,size,this,references,length,if,allow,resize,needs,resize,restructure,size,restructure,size,1,resizing,true,reference,k,v,restructured,resizing,create,reference,array,restructure,size,this,references,for,int,i,0,i,this,references,length,i,reference,this,references,i,if,resizing,restructured,i,null,while,reference,null,if,to,purge,contains,reference,reference,get,null,int,index,get,index,reference,get,hash,restructured,restructured,index,this,reference,manager,create,reference,reference,get,reference,get,hash,restructured,index,reference,reference,get,next,if,resizing,set,references,restructured,this,count,math,max,count,after,restructure,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> protected final void restructureIfNecessary(boolean allowResize);1496242568;Restructure the underlying data structure when it becomes necessary. This_method can increase the size of the references table as well as purge any_references that have been garbage collected._@param allowResize if resizing is permitted;protected final void restructureIfNecessary(boolean allowResize) {_			boolean needsResize = ((this.count > 0) && (this.count >= this.resizeThreshold))__			Reference<K, V> reference = this.referenceManager.pollForPurge()__			if ((reference != null) || (needsResize && allowResize)) {_				lock()__				try {_					int countAfterRestructure = this.count___					Set<Reference<K, V>> toPurge = Collections.emptySet()__					if (reference != null) {_						toPurge = new HashSet<>()__						while (reference != null) {_							toPurge.add(reference)__							reference = this.referenceManager.pollForPurge()__						}_					}_					countAfterRestructure -= toPurge.size()___					_					_					needsResize = (countAfterRestructure > 0 && countAfterRestructure >= this.resizeThreshold)__					boolean resizing = false__					int restructureSize = this.references.length__					if (allowResize && needsResize && restructureSize < MAXIMUM_SEGMENT_SIZE) {_						restructureSize <<= 1__						resizing = true__					}__					_					Reference<K, V>[] restructured = (resizing ? createReferenceArray(restructureSize) : this.references)___					_					for (int i = 0_ i < this.references.length_ i++) {_						reference = this.references[i]__						if (!resizing) {_							restructured[i] = null__						}_						while (reference != null) {_							if (!toPurge.contains(reference) && (reference.get() != null)) {_								int index = getIndex(reference.getHash(), restructured)__								restructured[index] = this.referenceManager.createReference(_										reference.get(), reference.getHash(),_										restructured[index])__							}_							reference = reference.getNext()__						}_					}__					_					if (resizing) {_						setReferences(restructured)__					}_					this.count = Math.max(countAfterRestructure, 0)__				}_				finally {_					unlock()__				}_			}_		};restructure,the,underlying,data,structure,when,it,becomes,necessary,this,method,can,increase,the,size,of,the,references,table,as,well,as,purge,any,references,that,have,been,garbage,collected,param,allow,resize,if,resizing,is,permitted;protected,final,void,restructure,if,necessary,boolean,allow,resize,boolean,needs,resize,this,count,0,this,count,this,resize,threshold,reference,k,v,reference,this,reference,manager,poll,for,purge,if,reference,null,needs,resize,allow,resize,lock,try,int,count,after,restructure,this,count,set,reference,k,v,to,purge,collections,empty,set,if,reference,null,to,purge,new,hash,set,while,reference,null,to,purge,add,reference,reference,this,reference,manager,poll,for,purge,count,after,restructure,to,purge,size,needs,resize,count,after,restructure,0,count,after,restructure,this,resize,threshold,boolean,resizing,false,int,restructure,size,this,references,length,if,allow,resize,needs,resize,restructure,size,restructure,size,1,resizing,true,reference,k,v,restructured,resizing,create,reference,array,restructure,size,this,references,for,int,i,0,i,this,references,length,i,reference,this,references,i,if,resizing,restructured,i,null,while,reference,null,if,to,purge,contains,reference,reference,get,null,int,index,get,index,reference,get,hash,restructured,restructured,index,this,reference,manager,create,reference,reference,get,reference,get,hash,restructured,index,reference,reference,get,next,if,resizing,set,references,restructured,this,count,math,max,count,after,restructure,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> protected final void restructureIfNecessary(boolean allowResize);1496837955;Restructure the underlying data structure when it becomes necessary. This_method can increase the size of the references table as well as purge any_references that have been garbage collected._@param allowResize if resizing is permitted;protected final void restructureIfNecessary(boolean allowResize) {_			boolean needsResize = ((this.count > 0) && (this.count >= this.resizeThreshold))__			Reference<K, V> reference = this.referenceManager.pollForPurge()__			if ((reference != null) || (needsResize && allowResize)) {_				lock()__				try {_					int countAfterRestructure = this.count___					Set<Reference<K, V>> toPurge = Collections.emptySet()__					if (reference != null) {_						toPurge = new HashSet<>()__						while (reference != null) {_							toPurge.add(reference)__							reference = this.referenceManager.pollForPurge()__						}_					}_					countAfterRestructure -= toPurge.size()___					_					_					needsResize = (countAfterRestructure > 0 && countAfterRestructure >= this.resizeThreshold)__					boolean resizing = false__					int restructureSize = this.references.length__					if (allowResize && needsResize && restructureSize < MAXIMUM_SEGMENT_SIZE) {_						restructureSize <<= 1__						resizing = true__					}__					_					Reference<K, V>[] restructured = (resizing ? createReferenceArray(restructureSize) : this.references)___					_					for (int i = 0_ i < this.references.length_ i++) {_						reference = this.references[i]__						if (!resizing) {_							restructured[i] = null__						}_						while (reference != null) {_							if (!toPurge.contains(reference)) {_								Entry<K, V> entry = reference.get()__								if (entry != null) {_									int index = getIndex(reference.getHash(), restructured)__									restructured[index] = this.referenceManager.createReference(_											entry, reference.getHash(), restructured[index])__								}_							}_							reference = reference.getNext()__						}_					}__					_					if (resizing) {_						setReferences(restructured)__					}_					this.count = Math.max(countAfterRestructure, 0)__				}_				finally {_					unlock()__				}_			}_		};restructure,the,underlying,data,structure,when,it,becomes,necessary,this,method,can,increase,the,size,of,the,references,table,as,well,as,purge,any,references,that,have,been,garbage,collected,param,allow,resize,if,resizing,is,permitted;protected,final,void,restructure,if,necessary,boolean,allow,resize,boolean,needs,resize,this,count,0,this,count,this,resize,threshold,reference,k,v,reference,this,reference,manager,poll,for,purge,if,reference,null,needs,resize,allow,resize,lock,try,int,count,after,restructure,this,count,set,reference,k,v,to,purge,collections,empty,set,if,reference,null,to,purge,new,hash,set,while,reference,null,to,purge,add,reference,reference,this,reference,manager,poll,for,purge,count,after,restructure,to,purge,size,needs,resize,count,after,restructure,0,count,after,restructure,this,resize,threshold,boolean,resizing,false,int,restructure,size,this,references,length,if,allow,resize,needs,resize,restructure,size,restructure,size,1,resizing,true,reference,k,v,restructured,resizing,create,reference,array,restructure,size,this,references,for,int,i,0,i,this,references,length,i,reference,this,references,i,if,resizing,restructured,i,null,while,reference,null,if,to,purge,contains,reference,entry,k,v,entry,reference,get,if,entry,null,int,index,get,index,reference,get,hash,restructured,restructured,index,this,reference,manager,create,reference,entry,reference,get,hash,restructured,index,reference,reference,get,next,if,resizing,set,references,restructured,this,count,math,max,count,after,restructure,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> protected final void restructureIfNecessary(boolean allowResize);1498780456;Restructure the underlying data structure when it becomes necessary. This_method can increase the size of the references table as well as purge any_references that have been garbage collected._@param allowResize if resizing is permitted;protected final void restructureIfNecessary(boolean allowResize) {_			boolean needsResize = ((this.count > 0) && (this.count >= this.resizeThreshold))__			Reference<K, V> reference = this.referenceManager.pollForPurge()__			if ((reference != null) || (needsResize && allowResize)) {_				lock()__				try {_					int countAfterRestructure = this.count___					Set<Reference<K, V>> toPurge = Collections.emptySet()__					if (reference != null) {_						toPurge = new HashSet<>()__						while (reference != null) {_							toPurge.add(reference)__							reference = this.referenceManager.pollForPurge()__						}_					}_					countAfterRestructure -= toPurge.size()___					_					_					needsResize = (countAfterRestructure > 0 && countAfterRestructure >= this.resizeThreshold)__					boolean resizing = false__					int restructureSize = this.references.length__					if (allowResize && needsResize && restructureSize < MAXIMUM_SEGMENT_SIZE) {_						restructureSize <<= 1__						resizing = true__					}__					_					Reference<K, V>[] restructured = (resizing ? createReferenceArray(restructureSize) : this.references)___					_					for (int i = 0_ i < this.references.length_ i++) {_						reference = this.references[i]__						if (!resizing) {_							restructured[i] = null__						}_						while (reference != null) {_							if (!toPurge.contains(reference)) {_								Entry<K, V> entry = reference.get()__								if (entry != null) {_									int index = getIndex(reference.getHash(), restructured)__									restructured[index] = this.referenceManager.createReference(_											entry, reference.getHash(), restructured[index])__								}_							}_							reference = reference.getNext()__						}_					}__					_					if (resizing) {_						this.references = restructured__						this.resizeThreshold = (int) (this.references.length * getLoadFactor())__					}_					this.count = Math.max(countAfterRestructure, 0)__				}_				finally {_					unlock()__				}_			}_		};restructure,the,underlying,data,structure,when,it,becomes,necessary,this,method,can,increase,the,size,of,the,references,table,as,well,as,purge,any,references,that,have,been,garbage,collected,param,allow,resize,if,resizing,is,permitted;protected,final,void,restructure,if,necessary,boolean,allow,resize,boolean,needs,resize,this,count,0,this,count,this,resize,threshold,reference,k,v,reference,this,reference,manager,poll,for,purge,if,reference,null,needs,resize,allow,resize,lock,try,int,count,after,restructure,this,count,set,reference,k,v,to,purge,collections,empty,set,if,reference,null,to,purge,new,hash,set,while,reference,null,to,purge,add,reference,reference,this,reference,manager,poll,for,purge,count,after,restructure,to,purge,size,needs,resize,count,after,restructure,0,count,after,restructure,this,resize,threshold,boolean,resizing,false,int,restructure,size,this,references,length,if,allow,resize,needs,resize,restructure,size,restructure,size,1,resizing,true,reference,k,v,restructured,resizing,create,reference,array,restructure,size,this,references,for,int,i,0,i,this,references,length,i,reference,this,references,i,if,resizing,restructured,i,null,while,reference,null,if,to,purge,contains,reference,entry,k,v,entry,reference,get,if,entry,null,int,index,get,index,reference,get,hash,restructured,restructured,index,this,reference,manager,create,reference,entry,reference,get,hash,restructured,index,reference,reference,get,next,if,resizing,this,references,restructured,this,resize,threshold,int,this,references,length,get,load,factor,this,count,math,max,count,after,restructure,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> protected final void restructureIfNecessary(boolean allowResize);1502974979;Restructure the underlying data structure when it becomes necessary. This_method can increase the size of the references table as well as purge any_references that have been garbage collected._@param allowResize if resizing is permitted;protected final void restructureIfNecessary(boolean allowResize) {_			boolean needsResize = ((this.count > 0) && (this.count >= this.resizeThreshold))__			Reference<K, V> reference = this.referenceManager.pollForPurge()__			if ((reference != null) || (needsResize && allowResize)) {_				lock()__				try {_					int countAfterRestructure = this.count___					Set<Reference<K, V>> toPurge = Collections.emptySet()__					if (reference != null) {_						toPurge = new HashSet<>()__						while (reference != null) {_							toPurge.add(reference)__							reference = this.referenceManager.pollForPurge()__						}_					}_					countAfterRestructure -= toPurge.size()___					_					_					needsResize = (countAfterRestructure > 0 && countAfterRestructure >= this.resizeThreshold)__					boolean resizing = false__					int restructureSize = this.references.length__					if (allowResize && needsResize && restructureSize < MAXIMUM_SEGMENT_SIZE) {_						restructureSize <<= 1__						resizing = true__					}__					_					Reference<K, V>[] restructured = (resizing ? createReferenceArray(restructureSize) : this.references)___					_					for (int i = 0_ i < this.references.length_ i++) {_						reference = this.references[i]__						if (!resizing) {_							restructured[i] = null__						}_						while (reference != null) {_							if (!toPurge.contains(reference)) {_								Entry<K, V> entry = reference.get()__								if (entry != null) {_									int index = getIndex(reference.getHash(), restructured)__									restructured[index] = this.referenceManager.createReference(_											entry, reference.getHash(), restructured[index])__								}_							}_							reference = reference.getNext()__						}_					}__					_					if (resizing) {_						this.references = restructured__						this.resizeThreshold = (int) (this.references.length * getLoadFactor())__					}_					this.count = Math.max(countAfterRestructure, 0)__				}_				finally {_					unlock()__				}_			}_		};restructure,the,underlying,data,structure,when,it,becomes,necessary,this,method,can,increase,the,size,of,the,references,table,as,well,as,purge,any,references,that,have,been,garbage,collected,param,allow,resize,if,resizing,is,permitted;protected,final,void,restructure,if,necessary,boolean,allow,resize,boolean,needs,resize,this,count,0,this,count,this,resize,threshold,reference,k,v,reference,this,reference,manager,poll,for,purge,if,reference,null,needs,resize,allow,resize,lock,try,int,count,after,restructure,this,count,set,reference,k,v,to,purge,collections,empty,set,if,reference,null,to,purge,new,hash,set,while,reference,null,to,purge,add,reference,reference,this,reference,manager,poll,for,purge,count,after,restructure,to,purge,size,needs,resize,count,after,restructure,0,count,after,restructure,this,resize,threshold,boolean,resizing,false,int,restructure,size,this,references,length,if,allow,resize,needs,resize,restructure,size,restructure,size,1,resizing,true,reference,k,v,restructured,resizing,create,reference,array,restructure,size,this,references,for,int,i,0,i,this,references,length,i,reference,this,references,i,if,resizing,restructured,i,null,while,reference,null,if,to,purge,contains,reference,entry,k,v,entry,reference,get,if,entry,null,int,index,get,index,reference,get,hash,restructured,restructured,index,this,reference,manager,create,reference,entry,reference,get,hash,restructured,index,reference,reference,get,next,if,resizing,this,references,restructured,this,resize,threshold,int,this,references,length,get,load,factor,this,count,math,max,count,after,restructure,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> protected final void restructureIfNecessary(boolean allowResize);1506097334;Restructure the underlying data structure when it becomes necessary. This_method can increase the size of the references table as well as purge any_references that have been garbage collected._@param allowResize if resizing is permitted;protected final void restructureIfNecessary(boolean allowResize) {_			boolean needsResize = ((this.count > 0) && (this.count >= this.resizeThreshold))__			Reference<K, V> reference = this.referenceManager.pollForPurge()__			if ((reference != null) || (needsResize && allowResize)) {_				lock()__				try {_					int countAfterRestructure = this.count___					Set<Reference<K, V>> toPurge = Collections.emptySet()__					if (reference != null) {_						toPurge = new HashSet<>()__						while (reference != null) {_							toPurge.add(reference)__							reference = this.referenceManager.pollForPurge()__						}_					}_					countAfterRestructure -= toPurge.size()___					_					_					needsResize = (countAfterRestructure > 0 && countAfterRestructure >= this.resizeThreshold)__					boolean resizing = false__					int restructureSize = this.references.length__					if (allowResize && needsResize && restructureSize < MAXIMUM_SEGMENT_SIZE) {_						restructureSize <<= 1__						resizing = true__					}__					_					Reference<K, V>[] restructured = (resizing ? createReferenceArray(restructureSize) : this.references)___					_					for (int i = 0_ i < this.references.length_ i++) {_						reference = this.references[i]__						if (!resizing) {_							restructured[i] = null__						}_						while (reference != null) {_							if (!toPurge.contains(reference)) {_								Entry<K, V> entry = reference.get()__								if (entry != null) {_									int index = getIndex(reference.getHash(), restructured)__									restructured[index] = this.referenceManager.createReference(_											entry, reference.getHash(), restructured[index])__								}_							}_							reference = reference.getNext()__						}_					}__					_					if (resizing) {_						this.references = restructured__						this.resizeThreshold = (int) (this.references.length * getLoadFactor())__					}_					this.count = Math.max(countAfterRestructure, 0)__				}_				finally {_					unlock()__				}_			}_		};restructure,the,underlying,data,structure,when,it,becomes,necessary,this,method,can,increase,the,size,of,the,references,table,as,well,as,purge,any,references,that,have,been,garbage,collected,param,allow,resize,if,resizing,is,permitted;protected,final,void,restructure,if,necessary,boolean,allow,resize,boolean,needs,resize,this,count,0,this,count,this,resize,threshold,reference,k,v,reference,this,reference,manager,poll,for,purge,if,reference,null,needs,resize,allow,resize,lock,try,int,count,after,restructure,this,count,set,reference,k,v,to,purge,collections,empty,set,if,reference,null,to,purge,new,hash,set,while,reference,null,to,purge,add,reference,reference,this,reference,manager,poll,for,purge,count,after,restructure,to,purge,size,needs,resize,count,after,restructure,0,count,after,restructure,this,resize,threshold,boolean,resizing,false,int,restructure,size,this,references,length,if,allow,resize,needs,resize,restructure,size,restructure,size,1,resizing,true,reference,k,v,restructured,resizing,create,reference,array,restructure,size,this,references,for,int,i,0,i,this,references,length,i,reference,this,references,i,if,resizing,restructured,i,null,while,reference,null,if,to,purge,contains,reference,entry,k,v,entry,reference,get,if,entry,null,int,index,get,index,reference,get,hash,restructured,restructured,index,this,reference,manager,create,reference,entry,reference,get,hash,restructured,index,reference,reference,get,next,if,resizing,this,references,restructured,this,resize,threshold,int,this,references,length,get,load,factor,this,count,math,max,count,after,restructure,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> protected final void restructureIfNecessary(boolean allowResize);1521044224;Restructure the underlying data structure when it becomes necessary. This_method can increase the size of the references table as well as purge any_references that have been garbage collected._@param allowResize if resizing is permitted;protected final void restructureIfNecessary(boolean allowResize) {_			boolean needsResize = ((this.count > 0) && (this.count >= this.resizeThreshold))__			Reference<K, V> reference = this.referenceManager.pollForPurge()__			if ((reference != null) || (needsResize && allowResize)) {_				lock()__				try {_					int countAfterRestructure = this.count___					Set<Reference<K, V>> toPurge = Collections.emptySet()__					if (reference != null) {_						toPurge = new HashSet<>()__						while (reference != null) {_							toPurge.add(reference)__							reference = this.referenceManager.pollForPurge()__						}_					}_					countAfterRestructure -= toPurge.size()___					_					_					needsResize = (countAfterRestructure > 0 && countAfterRestructure >= this.resizeThreshold)__					boolean resizing = false__					int restructureSize = this.references.length__					if (allowResize && needsResize && restructureSize < MAXIMUM_SEGMENT_SIZE) {_						restructureSize <<= 1__						resizing = true__					}__					_					Reference<K, V>[] restructured = (resizing ? createReferenceArray(restructureSize) : this.references)___					_					for (int i = 0_ i < this.references.length_ i++) {_						reference = this.references[i]__						if (!resizing) {_							restructured[i] = null__						}_						while (reference != null) {_							if (!toPurge.contains(reference)) {_								Entry<K, V> entry = reference.get()__								if (entry != null) {_									int index = getIndex(reference.getHash(), restructured)__									restructured[index] = this.referenceManager.createReference(_											entry, reference.getHash(), restructured[index])__								}_							}_							reference = reference.getNext()__						}_					}__					_					if (resizing) {_						this.references = restructured__						this.resizeThreshold = (int) (this.references.length * getLoadFactor())__					}_					this.count = Math.max(countAfterRestructure, 0)__				}_				finally {_					unlock()__				}_			}_		};restructure,the,underlying,data,structure,when,it,becomes,necessary,this,method,can,increase,the,size,of,the,references,table,as,well,as,purge,any,references,that,have,been,garbage,collected,param,allow,resize,if,resizing,is,permitted;protected,final,void,restructure,if,necessary,boolean,allow,resize,boolean,needs,resize,this,count,0,this,count,this,resize,threshold,reference,k,v,reference,this,reference,manager,poll,for,purge,if,reference,null,needs,resize,allow,resize,lock,try,int,count,after,restructure,this,count,set,reference,k,v,to,purge,collections,empty,set,if,reference,null,to,purge,new,hash,set,while,reference,null,to,purge,add,reference,reference,this,reference,manager,poll,for,purge,count,after,restructure,to,purge,size,needs,resize,count,after,restructure,0,count,after,restructure,this,resize,threshold,boolean,resizing,false,int,restructure,size,this,references,length,if,allow,resize,needs,resize,restructure,size,restructure,size,1,resizing,true,reference,k,v,restructured,resizing,create,reference,array,restructure,size,this,references,for,int,i,0,i,this,references,length,i,reference,this,references,i,if,resizing,restructured,i,null,while,reference,null,if,to,purge,contains,reference,entry,k,v,entry,reference,get,if,entry,null,int,index,get,index,reference,get,hash,restructured,restructured,index,this,reference,manager,create,reference,entry,reference,get,hash,restructured,index,reference,reference,get,next,if,resizing,this,references,restructured,this,resize,threshold,int,this,references,length,get,load,factor,this,count,math,max,count,after,restructure,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> protected final void restructureIfNecessary(boolean allowResize);1530174524;Restructure the underlying data structure when it becomes necessary. This_method can increase the size of the references table as well as purge any_references that have been garbage collected._@param allowResize if resizing is permitted;protected final void restructureIfNecessary(boolean allowResize) {_			boolean needsResize = ((this.count > 0) && (this.count >= this.resizeThreshold))__			Reference<K, V> reference = this.referenceManager.pollForPurge()__			if ((reference != null) || (needsResize && allowResize)) {_				lock()__				try {_					int countAfterRestructure = this.count___					Set<Reference<K, V>> toPurge = Collections.emptySet()__					if (reference != null) {_						toPurge = new HashSet<>()__						while (reference != null) {_							toPurge.add(reference)__							reference = this.referenceManager.pollForPurge()__						}_					}_					countAfterRestructure -= toPurge.size()___					_					_					needsResize = (countAfterRestructure > 0 && countAfterRestructure >= this.resizeThreshold)__					boolean resizing = false__					int restructureSize = this.references.length__					if (allowResize && needsResize && restructureSize < MAXIMUM_SEGMENT_SIZE) {_						restructureSize <<= 1__						resizing = true__					}__					_					Reference<K, V>[] restructured = (resizing ? createReferenceArray(restructureSize) : this.references)___					_					for (int i = 0_ i < this.references.length_ i++) {_						reference = this.references[i]__						if (!resizing) {_							restructured[i] = null__						}_						while (reference != null) {_							if (!toPurge.contains(reference)) {_								Entry<K, V> entry = reference.get()__								if (entry != null) {_									int index = getIndex(reference.getHash(), restructured)__									restructured[index] = this.referenceManager.createReference(_											entry, reference.getHash(), restructured[index])__								}_							}_							reference = reference.getNext()__						}_					}__					_					if (resizing) {_						this.references = restructured__						this.resizeThreshold = (int) (this.references.length * getLoadFactor())__					}_					this.count = Math.max(countAfterRestructure, 0)__				}_				finally {_					unlock()__				}_			}_		};restructure,the,underlying,data,structure,when,it,becomes,necessary,this,method,can,increase,the,size,of,the,references,table,as,well,as,purge,any,references,that,have,been,garbage,collected,param,allow,resize,if,resizing,is,permitted;protected,final,void,restructure,if,necessary,boolean,allow,resize,boolean,needs,resize,this,count,0,this,count,this,resize,threshold,reference,k,v,reference,this,reference,manager,poll,for,purge,if,reference,null,needs,resize,allow,resize,lock,try,int,count,after,restructure,this,count,set,reference,k,v,to,purge,collections,empty,set,if,reference,null,to,purge,new,hash,set,while,reference,null,to,purge,add,reference,reference,this,reference,manager,poll,for,purge,count,after,restructure,to,purge,size,needs,resize,count,after,restructure,0,count,after,restructure,this,resize,threshold,boolean,resizing,false,int,restructure,size,this,references,length,if,allow,resize,needs,resize,restructure,size,restructure,size,1,resizing,true,reference,k,v,restructured,resizing,create,reference,array,restructure,size,this,references,for,int,i,0,i,this,references,length,i,reference,this,references,i,if,resizing,restructured,i,null,while,reference,null,if,to,purge,contains,reference,entry,k,v,entry,reference,get,if,entry,null,int,index,get,index,reference,get,hash,restructured,restructured,index,this,reference,manager,create,reference,entry,reference,get,hash,restructured,index,reference,reference,get,next,if,resizing,this,references,restructured,this,resize,threshold,int,this,references,length,get,load,factor,this,count,math,max,count,after,restructure,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> protected final void restructureIfNecessary(boolean allowResize);1530190293;Restructure the underlying data structure when it becomes necessary. This_method can increase the size of the references table as well as purge any_references that have been garbage collected._@param allowResize if resizing is permitted;protected final void restructureIfNecessary(boolean allowResize) {_			boolean needsResize = ((this.count > 0) && (this.count >= this.resizeThreshold))__			Reference<K, V> reference = this.referenceManager.pollForPurge()__			if ((reference != null) || (needsResize && allowResize)) {_				lock()__				try {_					int countAfterRestructure = this.count___					Set<Reference<K, V>> toPurge = Collections.emptySet()__					if (reference != null) {_						toPurge = new HashSet<>()__						while (reference != null) {_							toPurge.add(reference)__							reference = this.referenceManager.pollForPurge()__						}_					}_					countAfterRestructure -= toPurge.size()___					_					_					needsResize = (countAfterRestructure > 0 && countAfterRestructure >= this.resizeThreshold)__					boolean resizing = false__					int restructureSize = this.references.length__					if (allowResize && needsResize && restructureSize < MAXIMUM_SEGMENT_SIZE) {_						restructureSize <<= 1__						resizing = true__					}__					_					Reference<K, V>[] restructured = (resizing ? createReferenceArray(restructureSize) : this.references)___					_					for (int i = 0_ i < this.references.length_ i++) {_						reference = this.references[i]__						if (!resizing) {_							restructured[i] = null__						}_						while (reference != null) {_							if (!toPurge.contains(reference)) {_								Entry<K, V> entry = reference.get()__								if (entry != null) {_									int index = getIndex(reference.getHash(), restructured)__									restructured[index] = this.referenceManager.createReference(_											entry, reference.getHash(), restructured[index])__								}_							}_							reference = reference.getNext()__						}_					}__					_					if (resizing) {_						this.references = restructured__						this.resizeThreshold = (int) (this.references.length * getLoadFactor())__					}_					this.count = Math.max(countAfterRestructure, 0)__				}_				finally {_					unlock()__				}_			}_		};restructure,the,underlying,data,structure,when,it,becomes,necessary,this,method,can,increase,the,size,of,the,references,table,as,well,as,purge,any,references,that,have,been,garbage,collected,param,allow,resize,if,resizing,is,permitted;protected,final,void,restructure,if,necessary,boolean,allow,resize,boolean,needs,resize,this,count,0,this,count,this,resize,threshold,reference,k,v,reference,this,reference,manager,poll,for,purge,if,reference,null,needs,resize,allow,resize,lock,try,int,count,after,restructure,this,count,set,reference,k,v,to,purge,collections,empty,set,if,reference,null,to,purge,new,hash,set,while,reference,null,to,purge,add,reference,reference,this,reference,manager,poll,for,purge,count,after,restructure,to,purge,size,needs,resize,count,after,restructure,0,count,after,restructure,this,resize,threshold,boolean,resizing,false,int,restructure,size,this,references,length,if,allow,resize,needs,resize,restructure,size,restructure,size,1,resizing,true,reference,k,v,restructured,resizing,create,reference,array,restructure,size,this,references,for,int,i,0,i,this,references,length,i,reference,this,references,i,if,resizing,restructured,i,null,while,reference,null,if,to,purge,contains,reference,entry,k,v,entry,reference,get,if,entry,null,int,index,get,index,reference,get,hash,restructured,restructured,index,this,reference,manager,create,reference,entry,reference,get,hash,restructured,index,reference,reference,get,next,if,resizing,this,references,restructured,this,resize,threshold,int,this,references,length,get,load,factor,this,count,math,max,count,after,restructure,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> protected final void restructureIfNecessary(boolean allowResize);1530563577;Restructure the underlying data structure when it becomes necessary. This_method can increase the size of the references table as well as purge any_references that have been garbage collected._@param allowResize if resizing is permitted;protected final void restructureIfNecessary(boolean allowResize) {_			boolean needsResize = (this.count > 0 && this.count >= this.resizeThreshold)__			Reference<K, V> ref = this.referenceManager.pollForPurge()__			if (ref != null || (needsResize && allowResize)) {_				lock()__				try {_					int countAfterRestructure = this.count__					Set<Reference<K, V>> toPurge = Collections.emptySet()__					if (ref != null) {_						toPurge = new HashSet<>()__						while (ref != null) {_							toPurge.add(ref)__							ref = this.referenceManager.pollForPurge()__						}_					}_					countAfterRestructure -= toPurge.size()___					_					_					needsResize = (countAfterRestructure > 0 && countAfterRestructure >= this.resizeThreshold)__					boolean resizing = false__					int restructureSize = this.references.length__					if (allowResize && needsResize && restructureSize < MAXIMUM_SEGMENT_SIZE) {_						restructureSize <<= 1__						resizing = true__					}__					_					Reference<K, V>[] restructured =_							(resizing ? createReferenceArray(restructureSize) : this.references)___					_					for (int i = 0_ i < this.references.length_ i++) {_						ref = this.references[i]__						if (!resizing) {_							restructured[i] = null__						}_						while (ref != null) {_							if (!toPurge.contains(ref)) {_								Entry<K, V> entry = ref.get()__								if (entry != null) {_									int index = getIndex(ref.getHash(), restructured)__									restructured[index] = this.referenceManager.createReference(_											entry, ref.getHash(), restructured[index])__								}_							}_							ref = ref.getNext()__						}_					}__					_					if (resizing) {_						this.references = restructured__						this.resizeThreshold = (int) (this.references.length * getLoadFactor())__					}_					this.count = Math.max(countAfterRestructure, 0)__				}_				finally {_					unlock()__				}_			}_		};restructure,the,underlying,data,structure,when,it,becomes,necessary,this,method,can,increase,the,size,of,the,references,table,as,well,as,purge,any,references,that,have,been,garbage,collected,param,allow,resize,if,resizing,is,permitted;protected,final,void,restructure,if,necessary,boolean,allow,resize,boolean,needs,resize,this,count,0,this,count,this,resize,threshold,reference,k,v,ref,this,reference,manager,poll,for,purge,if,ref,null,needs,resize,allow,resize,lock,try,int,count,after,restructure,this,count,set,reference,k,v,to,purge,collections,empty,set,if,ref,null,to,purge,new,hash,set,while,ref,null,to,purge,add,ref,ref,this,reference,manager,poll,for,purge,count,after,restructure,to,purge,size,needs,resize,count,after,restructure,0,count,after,restructure,this,resize,threshold,boolean,resizing,false,int,restructure,size,this,references,length,if,allow,resize,needs,resize,restructure,size,restructure,size,1,resizing,true,reference,k,v,restructured,resizing,create,reference,array,restructure,size,this,references,for,int,i,0,i,this,references,length,i,ref,this,references,i,if,resizing,restructured,i,null,while,ref,null,if,to,purge,contains,ref,entry,k,v,entry,ref,get,if,entry,null,int,index,get,index,ref,get,hash,restructured,restructured,index,this,reference,manager,create,reference,entry,ref,get,hash,restructured,index,ref,ref,get,next,if,resizing,this,references,restructured,this,resize,threshold,int,this,references,length,get,load,factor,this,count,math,max,count,after,restructure,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> protected final void restructureIfNecessary(boolean allowResize);1531136363;Restructure the underlying data structure when it becomes necessary. This_method can increase the size of the references table as well as purge any_references that have been garbage collected._@param allowResize if resizing is permitted;protected final void restructureIfNecessary(boolean allowResize) {_			boolean needsResize = (this.count > 0 && this.count >= this.resizeThreshold)__			Reference<K, V> ref = this.referenceManager.pollForPurge()__			if (ref != null || (needsResize && allowResize)) {_				lock()__				try {_					int countAfterRestructure = this.count__					Set<Reference<K, V>> toPurge = Collections.emptySet()__					if (ref != null) {_						toPurge = new HashSet<>()__						while (ref != null) {_							toPurge.add(ref)__							ref = this.referenceManager.pollForPurge()__						}_					}_					countAfterRestructure -= toPurge.size()___					_					_					needsResize = (countAfterRestructure > 0 && countAfterRestructure >= this.resizeThreshold)__					boolean resizing = false__					int restructureSize = this.references.length__					if (allowResize && needsResize && restructureSize < MAXIMUM_SEGMENT_SIZE) {_						restructureSize <<= 1__						resizing = true__					}__					_					Reference<K, V>[] restructured =_							(resizing ? createReferenceArray(restructureSize) : this.references)___					_					for (int i = 0_ i < this.references.length_ i++) {_						ref = this.references[i]__						if (!resizing) {_							restructured[i] = null__						}_						while (ref != null) {_							if (!toPurge.contains(ref)) {_								Entry<K, V> entry = ref.get()__								if (entry != null) {_									int index = getIndex(ref.getHash(), restructured)__									restructured[index] = this.referenceManager.createReference(_											entry, ref.getHash(), restructured[index])__								}_							}_							ref = ref.getNext()__						}_					}__					_					if (resizing) {_						this.references = restructured__						this.resizeThreshold = (int) (this.references.length * getLoadFactor())__					}_					this.count = Math.max(countAfterRestructure, 0)__				}_				finally {_					unlock()__				}_			}_		};restructure,the,underlying,data,structure,when,it,becomes,necessary,this,method,can,increase,the,size,of,the,references,table,as,well,as,purge,any,references,that,have,been,garbage,collected,param,allow,resize,if,resizing,is,permitted;protected,final,void,restructure,if,necessary,boolean,allow,resize,boolean,needs,resize,this,count,0,this,count,this,resize,threshold,reference,k,v,ref,this,reference,manager,poll,for,purge,if,ref,null,needs,resize,allow,resize,lock,try,int,count,after,restructure,this,count,set,reference,k,v,to,purge,collections,empty,set,if,ref,null,to,purge,new,hash,set,while,ref,null,to,purge,add,ref,ref,this,reference,manager,poll,for,purge,count,after,restructure,to,purge,size,needs,resize,count,after,restructure,0,count,after,restructure,this,resize,threshold,boolean,resizing,false,int,restructure,size,this,references,length,if,allow,resize,needs,resize,restructure,size,restructure,size,1,resizing,true,reference,k,v,restructured,resizing,create,reference,array,restructure,size,this,references,for,int,i,0,i,this,references,length,i,ref,this,references,i,if,resizing,restructured,i,null,while,ref,null,if,to,purge,contains,ref,entry,k,v,entry,ref,get,if,entry,null,int,index,get,index,ref,get,hash,restructured,restructured,index,this,reference,manager,create,reference,entry,ref,get,hash,restructured,index,ref,ref,get,next,if,resizing,this,references,restructured,this,resize,threshold,int,this,references,length,get,load,factor,this,count,math,max,count,after,restructure,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> protected final void restructureIfNecessary(boolean allowResize);1531139295;Restructure the underlying data structure when it becomes necessary. This_method can increase the size of the references table as well as purge any_references that have been garbage collected._@param allowResize if resizing is permitted;protected final void restructureIfNecessary(boolean allowResize) {_			boolean needsResize = (this.count > 0 && this.count >= this.resizeThreshold)__			Reference<K, V> ref = this.referenceManager.pollForPurge()__			if (ref != null || (needsResize && allowResize)) {_				lock()__				try {_					int countAfterRestructure = this.count__					Set<Reference<K, V>> toPurge = Collections.emptySet()__					if (ref != null) {_						toPurge = new HashSet<>()__						while (ref != null) {_							toPurge.add(ref)__							ref = this.referenceManager.pollForPurge()__						}_					}_					countAfterRestructure -= toPurge.size()___					_					_					needsResize = (countAfterRestructure > 0 && countAfterRestructure >= this.resizeThreshold)__					boolean resizing = false__					int restructureSize = this.references.length__					if (allowResize && needsResize && restructureSize < MAXIMUM_SEGMENT_SIZE) {_						restructureSize <<= 1__						resizing = true__					}__					_					Reference<K, V>[] restructured =_							(resizing ? createReferenceArray(restructureSize) : this.references)___					_					for (int i = 0_ i < this.references.length_ i++) {_						ref = this.references[i]__						if (!resizing) {_							restructured[i] = null__						}_						while (ref != null) {_							if (!toPurge.contains(ref)) {_								Entry<K, V> entry = ref.get()__								if (entry != null) {_									int index = getIndex(ref.getHash(), restructured)__									restructured[index] = this.referenceManager.createReference(_											entry, ref.getHash(), restructured[index])__								}_							}_							ref = ref.getNext()__						}_					}__					_					if (resizing) {_						this.references = restructured__						this.resizeThreshold = (int) (this.references.length * getLoadFactor())__					}_					this.count = Math.max(countAfterRestructure, 0)__				}_				finally {_					unlock()__				}_			}_		};restructure,the,underlying,data,structure,when,it,becomes,necessary,this,method,can,increase,the,size,of,the,references,table,as,well,as,purge,any,references,that,have,been,garbage,collected,param,allow,resize,if,resizing,is,permitted;protected,final,void,restructure,if,necessary,boolean,allow,resize,boolean,needs,resize,this,count,0,this,count,this,resize,threshold,reference,k,v,ref,this,reference,manager,poll,for,purge,if,ref,null,needs,resize,allow,resize,lock,try,int,count,after,restructure,this,count,set,reference,k,v,to,purge,collections,empty,set,if,ref,null,to,purge,new,hash,set,while,ref,null,to,purge,add,ref,ref,this,reference,manager,poll,for,purge,count,after,restructure,to,purge,size,needs,resize,count,after,restructure,0,count,after,restructure,this,resize,threshold,boolean,resizing,false,int,restructure,size,this,references,length,if,allow,resize,needs,resize,restructure,size,restructure,size,1,resizing,true,reference,k,v,restructured,resizing,create,reference,array,restructure,size,this,references,for,int,i,0,i,this,references,length,i,ref,this,references,i,if,resizing,restructured,i,null,while,ref,null,if,to,purge,contains,ref,entry,k,v,entry,ref,get,if,entry,null,int,index,get,index,ref,get,hash,restructured,restructured,index,this,reference,manager,create,reference,entry,ref,get,hash,restructured,index,ref,ref,get,next,if,resizing,this,references,restructured,this,resize,threshold,int,this,references,length,get,load,factor,this,count,math,max,count,after,restructure,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> protected final void restructureIfNecessary(boolean allowResize);1544716668;Restructure the underlying data structure when it becomes necessary. This_method can increase the size of the references table as well as purge any_references that have been garbage collected._@param allowResize if resizing is permitted;protected final void restructureIfNecessary(boolean allowResize) {_			boolean needsResize = (this.count > 0 && this.count >= this.resizeThreshold)__			Reference<K, V> ref = this.referenceManager.pollForPurge()__			if (ref != null || (needsResize && allowResize)) {_				lock()__				try {_					int countAfterRestructure = this.count__					Set<Reference<K, V>> toPurge = Collections.emptySet()__					if (ref != null) {_						toPurge = new HashSet<>()__						while (ref != null) {_							toPurge.add(ref)__							ref = this.referenceManager.pollForPurge()__						}_					}_					countAfterRestructure -= toPurge.size()___					_					_					needsResize = (countAfterRestructure > 0 && countAfterRestructure >= this.resizeThreshold)__					boolean resizing = false__					int restructureSize = this.references.length__					if (allowResize && needsResize && restructureSize < MAXIMUM_SEGMENT_SIZE) {_						restructureSize <<= 1__						resizing = true__					}__					_					Reference<K, V>[] restructured =_							(resizing ? createReferenceArray(restructureSize) : this.references)___					_					for (int i = 0_ i < this.references.length_ i++) {_						ref = this.references[i]__						if (!resizing) {_							restructured[i] = null__						}_						while (ref != null) {_							if (!toPurge.contains(ref)) {_								Entry<K, V> entry = ref.get()__								if (entry != null) {_									int index = getIndex(ref.getHash(), restructured)__									restructured[index] = this.referenceManager.createReference(_											entry, ref.getHash(), restructured[index])__								}_							}_							ref = ref.getNext()__						}_					}__					_					if (resizing) {_						this.references = restructured__						this.resizeThreshold = (int) (this.references.length * getLoadFactor())__					}_					this.count = Math.max(countAfterRestructure, 0)__				}_				finally {_					unlock()__				}_			}_		};restructure,the,underlying,data,structure,when,it,becomes,necessary,this,method,can,increase,the,size,of,the,references,table,as,well,as,purge,any,references,that,have,been,garbage,collected,param,allow,resize,if,resizing,is,permitted;protected,final,void,restructure,if,necessary,boolean,allow,resize,boolean,needs,resize,this,count,0,this,count,this,resize,threshold,reference,k,v,ref,this,reference,manager,poll,for,purge,if,ref,null,needs,resize,allow,resize,lock,try,int,count,after,restructure,this,count,set,reference,k,v,to,purge,collections,empty,set,if,ref,null,to,purge,new,hash,set,while,ref,null,to,purge,add,ref,ref,this,reference,manager,poll,for,purge,count,after,restructure,to,purge,size,needs,resize,count,after,restructure,0,count,after,restructure,this,resize,threshold,boolean,resizing,false,int,restructure,size,this,references,length,if,allow,resize,needs,resize,restructure,size,restructure,size,1,resizing,true,reference,k,v,restructured,resizing,create,reference,array,restructure,size,this,references,for,int,i,0,i,this,references,length,i,ref,this,references,i,if,resizing,restructured,i,null,while,ref,null,if,to,purge,contains,ref,entry,k,v,entry,ref,get,if,entry,null,int,index,get,index,ref,get,hash,restructured,restructured,index,this,reference,manager,create,reference,entry,ref,get,hash,restructured,index,ref,ref,get,next,if,resizing,this,references,restructured,this,resize,threshold,int,this,references,length,get,load,factor,this,count,math,max,count,after,restructure,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> protected final void restructureIfNecessary(boolean allowResize);1549318940;Restructure the underlying data structure when it becomes necessary. This_method can increase the size of the references table as well as purge any_references that have been garbage collected._@param allowResize if resizing is permitted;protected final void restructureIfNecessary(boolean allowResize) {_			boolean needsResize = (this.count.get() > 0 && this.count.get() >= this.resizeThreshold)__			Reference<K, V> ref = this.referenceManager.pollForPurge()__			if (ref != null || (needsResize && allowResize)) {_				lock()__				try {_					int countAfterRestructure = this.count.get()__					Set<Reference<K, V>> toPurge = Collections.emptySet()__					if (ref != null) {_						toPurge = new HashSet<>()__						while (ref != null) {_							toPurge.add(ref)__							ref = this.referenceManager.pollForPurge()__						}_					}_					countAfterRestructure -= toPurge.size()___					_					_					needsResize = (countAfterRestructure > 0 && countAfterRestructure >= this.resizeThreshold)__					boolean resizing = false__					int restructureSize = this.references.length__					if (allowResize && needsResize && restructureSize < MAXIMUM_SEGMENT_SIZE) {_						restructureSize <<= 1__						resizing = true__					}__					_					Reference<K, V>[] restructured =_							(resizing ? createReferenceArray(restructureSize) : this.references)___					_					for (int i = 0_ i < this.references.length_ i++) {_						ref = this.references[i]__						if (!resizing) {_							restructured[i] = null__						}_						while (ref != null) {_							if (!toPurge.contains(ref)) {_								Entry<K, V> entry = ref.get()__								if (entry != null) {_									int index = getIndex(ref.getHash(), restructured)__									restructured[index] = this.referenceManager.createReference(_											entry, ref.getHash(), restructured[index])__								}_							}_							ref = ref.getNext()__						}_					}__					_					if (resizing) {_						this.references = restructured__						this.resizeThreshold = (int) (this.references.length * getLoadFactor())__					}_					this.count.set(Math.max(countAfterRestructure, 0))__				}_				finally {_					unlock()__				}_			}_		};restructure,the,underlying,data,structure,when,it,becomes,necessary,this,method,can,increase,the,size,of,the,references,table,as,well,as,purge,any,references,that,have,been,garbage,collected,param,allow,resize,if,resizing,is,permitted;protected,final,void,restructure,if,necessary,boolean,allow,resize,boolean,needs,resize,this,count,get,0,this,count,get,this,resize,threshold,reference,k,v,ref,this,reference,manager,poll,for,purge,if,ref,null,needs,resize,allow,resize,lock,try,int,count,after,restructure,this,count,get,set,reference,k,v,to,purge,collections,empty,set,if,ref,null,to,purge,new,hash,set,while,ref,null,to,purge,add,ref,ref,this,reference,manager,poll,for,purge,count,after,restructure,to,purge,size,needs,resize,count,after,restructure,0,count,after,restructure,this,resize,threshold,boolean,resizing,false,int,restructure,size,this,references,length,if,allow,resize,needs,resize,restructure,size,restructure,size,1,resizing,true,reference,k,v,restructured,resizing,create,reference,array,restructure,size,this,references,for,int,i,0,i,this,references,length,i,ref,this,references,i,if,resizing,restructured,i,null,while,ref,null,if,to,purge,contains,ref,entry,k,v,entry,ref,get,if,entry,null,int,index,get,index,ref,get,hash,restructured,restructured,index,this,reference,manager,create,reference,entry,ref,get,hash,restructured,index,ref,ref,get,next,if,resizing,this,references,restructured,this,resize,threshold,int,this,references,length,get,load,factor,this,count,set,math,max,count,after,restructure,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> protected final void restructureIfNecessary(boolean allowResize);1549321822;Restructure the underlying data structure when it becomes necessary. This_method can increase the size of the references table as well as purge any_references that have been garbage collected._@param allowResize if resizing is permitted;protected final void restructureIfNecessary(boolean allowResize) {_			int currCount = this.count.get()__			boolean needsResize = (currCount > 0 && currCount >= this.resizeThreshold)__			Reference<K, V> ref = this.referenceManager.pollForPurge()__			if (ref != null || (needsResize && allowResize)) {_				lock()__				try {_					int countAfterRestructure = this.count.get()__					Set<Reference<K, V>> toPurge = Collections.emptySet()__					if (ref != null) {_						toPurge = new HashSet<>()__						while (ref != null) {_							toPurge.add(ref)__							ref = this.referenceManager.pollForPurge()__						}_					}_					countAfterRestructure -= toPurge.size()___					_					_					needsResize = (countAfterRestructure > 0 && countAfterRestructure >= this.resizeThreshold)__					boolean resizing = false__					int restructureSize = this.references.length__					if (allowResize && needsResize && restructureSize < MAXIMUM_SEGMENT_SIZE) {_						restructureSize <<= 1__						resizing = true__					}__					_					Reference<K, V>[] restructured =_							(resizing ? createReferenceArray(restructureSize) : this.references)___					_					for (int i = 0_ i < this.references.length_ i++) {_						ref = this.references[i]__						if (!resizing) {_							restructured[i] = null__						}_						while (ref != null) {_							if (!toPurge.contains(ref)) {_								Entry<K, V> entry = ref.get()__								if (entry != null) {_									int index = getIndex(ref.getHash(), restructured)__									restructured[index] = this.referenceManager.createReference(_											entry, ref.getHash(), restructured[index])__								}_							}_							ref = ref.getNext()__						}_					}__					_					if (resizing) {_						this.references = restructured__						this.resizeThreshold = (int) (this.references.length * getLoadFactor())__					}_					this.count.set(Math.max(countAfterRestructure, 0))__				}_				finally {_					unlock()__				}_			}_		};restructure,the,underlying,data,structure,when,it,becomes,necessary,this,method,can,increase,the,size,of,the,references,table,as,well,as,purge,any,references,that,have,been,garbage,collected,param,allow,resize,if,resizing,is,permitted;protected,final,void,restructure,if,necessary,boolean,allow,resize,int,curr,count,this,count,get,boolean,needs,resize,curr,count,0,curr,count,this,resize,threshold,reference,k,v,ref,this,reference,manager,poll,for,purge,if,ref,null,needs,resize,allow,resize,lock,try,int,count,after,restructure,this,count,get,set,reference,k,v,to,purge,collections,empty,set,if,ref,null,to,purge,new,hash,set,while,ref,null,to,purge,add,ref,ref,this,reference,manager,poll,for,purge,count,after,restructure,to,purge,size,needs,resize,count,after,restructure,0,count,after,restructure,this,resize,threshold,boolean,resizing,false,int,restructure,size,this,references,length,if,allow,resize,needs,resize,restructure,size,restructure,size,1,resizing,true,reference,k,v,restructured,resizing,create,reference,array,restructure,size,this,references,for,int,i,0,i,this,references,length,i,ref,this,references,i,if,resizing,restructured,i,null,while,ref,null,if,to,purge,contains,ref,entry,k,v,entry,ref,get,if,entry,null,int,index,get,index,ref,get,hash,restructured,restructured,index,this,reference,manager,create,reference,entry,ref,get,hash,restructured,index,ref,ref,get,next,if,resizing,this,references,restructured,this,resize,threshold,int,this,references,length,get,load,factor,this,count,set,math,max,count,after,restructure,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> protected final void restructureIfNecessary(boolean allowResize);1550237263;Restructure the underlying data structure when it becomes necessary. This_method can increase the size of the references table as well as purge any_references that have been garbage collected._@param allowResize if resizing is permitted;protected final void restructureIfNecessary(boolean allowResize) {_			int currCount = this.count.get()__			boolean needsResize = (currCount > 0 && currCount >= this.resizeThreshold)__			Reference<K, V> ref = this.referenceManager.pollForPurge()__			if (ref != null || (needsResize && allowResize)) {_				lock()__				try {_					int countAfterRestructure = this.count.get()__					Set<Reference<K, V>> toPurge = Collections.emptySet()__					if (ref != null) {_						toPurge = new HashSet<>()__						while (ref != null) {_							toPurge.add(ref)__							ref = this.referenceManager.pollForPurge()__						}_					}_					countAfterRestructure -= toPurge.size()___					_					_					needsResize = (countAfterRestructure > 0 && countAfterRestructure >= this.resizeThreshold)__					boolean resizing = false__					int restructureSize = this.references.length__					if (allowResize && needsResize && restructureSize < MAXIMUM_SEGMENT_SIZE) {_						restructureSize <<= 1__						resizing = true__					}__					_					Reference<K, V>[] restructured =_							(resizing ? createReferenceArray(restructureSize) : this.references)___					_					for (int i = 0_ i < this.references.length_ i++) {_						ref = this.references[i]__						if (!resizing) {_							restructured[i] = null__						}_						while (ref != null) {_							if (!toPurge.contains(ref)) {_								Entry<K, V> entry = ref.get()__								if (entry != null) {_									int index = getIndex(ref.getHash(), restructured)__									restructured[index] = this.referenceManager.createReference(_											entry, ref.getHash(), restructured[index])__								}_							}_							ref = ref.getNext()__						}_					}__					_					if (resizing) {_						this.references = restructured__						this.resizeThreshold = (int) (this.references.length * getLoadFactor())__					}_					this.count.set(Math.max(countAfterRestructure, 0))__				}_				finally {_					unlock()__				}_			}_		};restructure,the,underlying,data,structure,when,it,becomes,necessary,this,method,can,increase,the,size,of,the,references,table,as,well,as,purge,any,references,that,have,been,garbage,collected,param,allow,resize,if,resizing,is,permitted;protected,final,void,restructure,if,necessary,boolean,allow,resize,int,curr,count,this,count,get,boolean,needs,resize,curr,count,0,curr,count,this,resize,threshold,reference,k,v,ref,this,reference,manager,poll,for,purge,if,ref,null,needs,resize,allow,resize,lock,try,int,count,after,restructure,this,count,get,set,reference,k,v,to,purge,collections,empty,set,if,ref,null,to,purge,new,hash,set,while,ref,null,to,purge,add,ref,ref,this,reference,manager,poll,for,purge,count,after,restructure,to,purge,size,needs,resize,count,after,restructure,0,count,after,restructure,this,resize,threshold,boolean,resizing,false,int,restructure,size,this,references,length,if,allow,resize,needs,resize,restructure,size,restructure,size,1,resizing,true,reference,k,v,restructured,resizing,create,reference,array,restructure,size,this,references,for,int,i,0,i,this,references,length,i,ref,this,references,i,if,resizing,restructured,i,null,while,ref,null,if,to,purge,contains,ref,entry,k,v,entry,ref,get,if,entry,null,int,index,get,index,ref,get,hash,restructured,restructured,index,this,reference,manager,create,reference,entry,ref,get,hash,restructured,index,ref,ref,get,next,if,resizing,this,references,restructured,this,resize,threshold,int,this,references,length,get,load,factor,this,count,set,math,max,count,after,restructure,0,finally,unlock
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, 			int concurrencyLevel, ReferenceType referenceType);1351982790;Create a new {@link ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted_@param concurrencyLevel the expected number of threads that will concurrently write_to the map_@param referenceType the reference type used for entries;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor,_			int concurrencyLevel, ReferenceType referenceType) {_		Assert.isTrue(concurrencyLevel > 0, "ConcurrencyLevel must be positive")__		Assert.isTrue(initialCapacity >= 0, "InitialCapactity must not be negative")__		Assert.isTrue(loadFactor > 0f, "LoadFactor must be positive")__		Assert.notNull(referenceType, "Reference type must not be null")__		this.loadFactor = loadFactor__		this.shift = calculateShift(concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL)__		int size = 1 << this.shift__		this.referenceType = referenceType__		int roundedUpSegmentCapactity = (int) ((initialCapacity + size - 1L) / size)__		this.segments = createSegmentsArray(size)__		for (int i = 0_ i < this.segments.length_ i++) {_			this.segments[i] = new Segment(roundedUpSegmentCapactity)__		}_	};create,a,new,link,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map,param,reference,type,the,reference,type,used,for,entries;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,reference,type,reference,type,assert,is,true,concurrency,level,0,concurrency,level,must,be,positive,assert,is,true,initial,capacity,0,initial,capactity,must,not,be,negative,assert,is,true,load,factor,0f,load,factor,must,be,positive,assert,not,null,reference,type,reference,type,must,not,be,null,this,load,factor,load,factor,this,shift,calculate,shift,concurrency,level,int,size,1,this,shift,this,reference,type,reference,type,int,rounded,up,segment,capactity,int,initial,capacity,size,1l,size,this,segments,create,segments,array,size,for,int,i,0,i,this,segments,length,i,this,segments,i,new,segment,rounded,up,segment,capactity
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, 			int concurrencyLevel, ReferenceType referenceType);1352039846;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted_@param concurrencyLevel the expected number of threads that will concurrently write_to the map_@param referenceType the reference type used for entries;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor,_			int concurrencyLevel, ReferenceType referenceType) {_		Assert.isTrue(concurrencyLevel > 0, "ConcurrencyLevel must be positive")__		Assert.isTrue(initialCapacity >= 0, "InitialCapacity must not be negative")__		Assert.isTrue(loadFactor > 0f, "LoadFactor must be positive")__		Assert.notNull(referenceType, "Reference type must not be null")__		this.loadFactor = loadFactor__		this.shift = calculateShift(concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL)__		int size = 1 << this.shift__		this.referenceType = referenceType__		int roundedUpSegmentCapactity = (int) ((initialCapacity + size - 1L) / size)__		this.segments = createSegmentsArray(size)__		for (int i = 0_ i < this.segments.length_ i++) {_			this.segments[i] = new Segment(roundedUpSegmentCapactity)__		}_	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map,param,reference,type,the,reference,type,used,for,entries;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,reference,type,reference,type,assert,is,true,concurrency,level,0,concurrency,level,must,be,positive,assert,is,true,initial,capacity,0,initial,capacity,must,not,be,negative,assert,is,true,load,factor,0f,load,factor,must,be,positive,assert,not,null,reference,type,reference,type,must,not,be,null,this,load,factor,load,factor,this,shift,calculate,shift,concurrency,level,int,size,1,this,shift,this,reference,type,reference,type,int,rounded,up,segment,capactity,int,initial,capacity,size,1l,size,this,segments,create,segments,array,size,for,int,i,0,i,this,segments,length,i,this,segments,i,new,segment,rounded,up,segment,capactity
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, 			int concurrencyLevel, ReferenceType referenceType);1355313310;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted_@param concurrencyLevel the expected number of threads that will concurrently write_to the map_@param referenceType the reference type used for entries;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor,_			int concurrencyLevel, ReferenceType referenceType) {_		Assert.isTrue(concurrencyLevel > 0, "ConcurrencyLevel must be positive")__		Assert.isTrue(initialCapacity >= 0, "InitialCapacity must not be negative")__		Assert.isTrue(loadFactor > 0f, "LoadFactor must be positive")__		Assert.notNull(referenceType, "Reference type must not be null")__		this.loadFactor = loadFactor__		this.shift = calculateShift(concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL)__		int size = 1 << this.shift__		this.referenceType = referenceType__		int roundedUpSegmentCapactity = (int) ((initialCapacity + size - 1L) / size)__		this.segments = createSegmentsArray(size)__		for (int i = 0_ i < this.segments.length_ i++) {_			this.segments[i] = new Segment(roundedUpSegmentCapactity)__		}_	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map,param,reference,type,the,reference,type,used,for,entries;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,reference,type,reference,type,assert,is,true,concurrency,level,0,concurrency,level,must,be,positive,assert,is,true,initial,capacity,0,initial,capacity,must,not,be,negative,assert,is,true,load,factor,0f,load,factor,must,be,positive,assert,not,null,reference,type,reference,type,must,not,be,null,this,load,factor,load,factor,this,shift,calculate,shift,concurrency,level,int,size,1,this,shift,this,reference,type,reference,type,int,rounded,up,segment,capactity,int,initial,capacity,size,1l,size,this,segments,create,segments,array,size,for,int,i,0,i,this,segments,length,i,this,segments,i,new,segment,rounded,up,segment,capactity
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, 			int concurrencyLevel, ReferenceType referenceType);1356735495;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted_@param concurrencyLevel the expected number of threads that will concurrently write_to the map_@param referenceType the reference type used for entries;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor,_			int concurrencyLevel, ReferenceType referenceType) {_		Assert.isTrue(concurrencyLevel > 0, "ConcurrencyLevel must be positive")__		Assert.isTrue(initialCapacity >= 0, "InitialCapacity must not be negative")__		Assert.isTrue(loadFactor > 0f, "LoadFactor must be positive")__		Assert.notNull(referenceType, "Reference type must not be null")__		this.loadFactor = loadFactor__		this.shift = calculateShift(concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL)__		int size = 1 << this.shift__		this.referenceType = referenceType__		int roundedUpSegmentCapactity = (int) ((initialCapacity + size - 1L) / size)__		this.segments = createSegmentsArray(size)__		for (int i = 0_ i < this.segments.length_ i++) {_			this.segments[i] = new Segment(roundedUpSegmentCapactity)__		}_	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map,param,reference,type,the,reference,type,used,for,entries;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,reference,type,reference,type,assert,is,true,concurrency,level,0,concurrency,level,must,be,positive,assert,is,true,initial,capacity,0,initial,capacity,must,not,be,negative,assert,is,true,load,factor,0f,load,factor,must,be,positive,assert,not,null,reference,type,reference,type,must,not,be,null,this,load,factor,load,factor,this,shift,calculate,shift,concurrency,level,int,size,1,this,shift,this,reference,type,reference,type,int,rounded,up,segment,capactity,int,initial,capacity,size,1l,size,this,segments,create,segments,array,size,for,int,i,0,i,this,segments,length,i,this,segments,i,new,segment,rounded,up,segment,capactity
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, 			int concurrencyLevel, ReferenceType referenceType);1357119239;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted_@param concurrencyLevel the expected number of threads that will concurrently write_to the map_@param referenceType the reference type used for entries;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor,_			int concurrencyLevel, ReferenceType referenceType) {_		Assert.isTrue(concurrencyLevel > 0, "ConcurrencyLevel must be positive")__		Assert.isTrue(initialCapacity >= 0, "InitialCapacity must not be negative")__		Assert.isTrue(loadFactor > 0f, "LoadFactor must be positive")__		Assert.notNull(referenceType, "Reference type must not be null")__		this.loadFactor = loadFactor__		this.shift = calculateShift(concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL)__		int size = 1 << this.shift__		this.referenceType = referenceType__		int roundedUpSegmentCapactity = (int) ((initialCapacity + size - 1L) / size)__		this.segments = createSegmentsArray(size)__		for (int i = 0_ i < this.segments.length_ i++) {_			this.segments[i] = new Segment(roundedUpSegmentCapactity)__		}_	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map,param,reference,type,the,reference,type,used,for,entries;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,reference,type,reference,type,assert,is,true,concurrency,level,0,concurrency,level,must,be,positive,assert,is,true,initial,capacity,0,initial,capacity,must,not,be,negative,assert,is,true,load,factor,0f,load,factor,must,be,positive,assert,not,null,reference,type,reference,type,must,not,be,null,this,load,factor,load,factor,this,shift,calculate,shift,concurrency,level,int,size,1,this,shift,this,reference,type,reference,type,int,rounded,up,segment,capactity,int,initial,capacity,size,1l,size,this,segments,create,segments,array,size,for,int,i,0,i,this,segments,length,i,this,segments,i,new,segment,rounded,up,segment,capactity
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, 			int concurrencyLevel, ReferenceType referenceType);1368482696;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted_@param concurrencyLevel the expected number of threads that will concurrently write_to the map_@param referenceType the reference type used for entries;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor,_			int concurrencyLevel, ReferenceType referenceType) {_		Assert.isTrue(concurrencyLevel > 0, "ConcurrencyLevel must be positive")__		Assert.isTrue(initialCapacity >= 0, "InitialCapacity must not be negative")__		Assert.isTrue(loadFactor > 0f, "LoadFactor must be positive")__		Assert.notNull(referenceType, "Reference type must not be null")__		this.loadFactor = loadFactor__		this.shift = calculateShift(concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL)__		int size = 1 << this.shift__		this.referenceType = referenceType__		int roundedUpSegmentCapactity = (int) ((initialCapacity + size - 1L) / size)__		this.segments = createSegmentsArray(size)__		for (int i = 0_ i < this.segments.length_ i++) {_			this.segments[i] = new Segment(roundedUpSegmentCapactity)__		}_	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map,param,reference,type,the,reference,type,used,for,entries;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,reference,type,reference,type,assert,is,true,concurrency,level,0,concurrency,level,must,be,positive,assert,is,true,initial,capacity,0,initial,capacity,must,not,be,negative,assert,is,true,load,factor,0f,load,factor,must,be,positive,assert,not,null,reference,type,reference,type,must,not,be,null,this,load,factor,load,factor,this,shift,calculate,shift,concurrency,level,int,size,1,this,shift,this,reference,type,reference,type,int,rounded,up,segment,capactity,int,initial,capacity,size,1l,size,this,segments,create,segments,array,size,for,int,i,0,i,this,segments,length,i,this,segments,i,new,segment,rounded,up,segment,capactity
ConcurrentReferenceHashMap -> Segment -> private void setReferences(Reference<K, V>[] references);1351982790;Replace the references with a new value, recalculating the resizeThreshold._@param references the new references;private void setReferences(Reference<K, V>[] references) {_			this.references = references__			this.resizeThreshold = (int) (references.length * getLoadFactor())__		};replace,the,references,with,a,new,value,recalculating,the,resize,threshold,param,references,the,new,references;private,void,set,references,reference,k,v,references,this,references,references,this,resize,threshold,int,references,length,get,load,factor
ConcurrentReferenceHashMap -> Segment -> private void setReferences(Reference<K, V>[] references);1352039846;Replace the references with a new value, recalculating the resizeThreshold._@param references the new references;private void setReferences(Reference<K, V>[] references) {_			this.references = references__			this.resizeThreshold = (int) (references.length * getLoadFactor())__		};replace,the,references,with,a,new,value,recalculating,the,resize,threshold,param,references,the,new,references;private,void,set,references,reference,k,v,references,this,references,references,this,resize,threshold,int,references,length,get,load,factor
ConcurrentReferenceHashMap -> Segment -> private void setReferences(Reference<K, V>[] references);1355313310;Replace the references with a new value, recalculating the resizeThreshold._@param references the new references;private void setReferences(Reference<K, V>[] references) {_			this.references = references__			this.resizeThreshold = (int) (references.length * getLoadFactor())__		};replace,the,references,with,a,new,value,recalculating,the,resize,threshold,param,references,the,new,references;private,void,set,references,reference,k,v,references,this,references,references,this,resize,threshold,int,references,length,get,load,factor
ConcurrentReferenceHashMap -> Segment -> private void setReferences(Reference<K, V>[] references);1356735495;Replace the references with a new value, recalculating the resizeThreshold._@param references the new references;private void setReferences(Reference<K, V>[] references) {_			this.references = references__			this.resizeThreshold = (int) (references.length * getLoadFactor())__		};replace,the,references,with,a,new,value,recalculating,the,resize,threshold,param,references,the,new,references;private,void,set,references,reference,k,v,references,this,references,references,this,resize,threshold,int,references,length,get,load,factor
ConcurrentReferenceHashMap -> Segment -> private void setReferences(Reference<K, V>[] references);1357119239;Replace the references with a new value, recalculating the resizeThreshold._@param references the new references;private void setReferences(Reference<K, V>[] references) {_			this.references = references__			this.resizeThreshold = (int) (references.length * getLoadFactor())__		};replace,the,references,with,a,new,value,recalculating,the,resize,threshold,param,references,the,new,references;private,void,set,references,reference,k,v,references,this,references,references,this,resize,threshold,int,references,length,get,load,factor
ConcurrentReferenceHashMap -> Segment -> private void setReferences(Reference<K, V>[] references);1368482696;Replace the references with a new value, recalculating the resizeThreshold._@param references the new references;private void setReferences(Reference<K, V>[] references) {_			this.references = references__			this.resizeThreshold = (int) (references.length * getLoadFactor())__		};replace,the,references,with,a,new,value,recalculating,the,resize,threshold,param,references,the,new,references;private,void,set,references,reference,k,v,references,this,references,references,this,resize,threshold,int,references,length,get,load,factor
ConcurrentReferenceHashMap -> Segment -> private void setReferences(Reference<K, V>[] references);1383090835;Replace the references with a new value, recalculating the resizeThreshold._@param references the new references;private void setReferences(Reference<K, V>[] references) {_			this.references = references__			this.resizeThreshold = (int) (references.length * getLoadFactor())__		};replace,the,references,with,a,new,value,recalculating,the,resize,threshold,param,references,the,new,references;private,void,set,references,reference,k,v,references,this,references,references,this,resize,threshold,int,references,length,get,load,factor
ConcurrentReferenceHashMap -> Segment -> private void setReferences(Reference<K, V>[] references);1383178438;Replace the references with a new value, recalculating the resizeThreshold._@param references the new references;private void setReferences(Reference<K, V>[] references) {_			this.references = references__			this.resizeThreshold = (int) (references.length * getLoadFactor())__		};replace,the,references,with,a,new,value,recalculating,the,resize,threshold,param,references,the,new,references;private,void,set,references,reference,k,v,references,this,references,references,this,resize,threshold,int,references,length,get,load,factor
ConcurrentReferenceHashMap -> Segment -> private void setReferences(Reference<K, V>[] references);1390260938;Replace the references with a new value, recalculating the resizeThreshold._@param references the new references;private void setReferences(Reference<K, V>[] references) {_			this.references = references__			this.resizeThreshold = (int) (references.length * getLoadFactor())__		};replace,the,references,with,a,new,value,recalculating,the,resize,threshold,param,references,the,new,references;private,void,set,references,reference,k,v,references,this,references,references,this,resize,threshold,int,references,length,get,load,factor
ConcurrentReferenceHashMap -> Segment -> private void setReferences(Reference<K, V>[] references);1391715359;Replace the references with a new value, recalculating the resizeThreshold._@param references the new references;private void setReferences(Reference<K, V>[] references) {_			this.references = references__			this.resizeThreshold = (int) (references.length * getLoadFactor())__		};replace,the,references,with,a,new,value,recalculating,the,resize,threshold,param,references,the,new,references;private,void,set,references,reference,k,v,references,this,references,references,this,resize,threshold,int,references,length,get,load,factor
ConcurrentReferenceHashMap -> Segment -> private void setReferences(Reference<K, V>[] references);1392765030;Replace the references with a new value, recalculating the resizeThreshold._@param references the new references;private void setReferences(Reference<K, V>[] references) {_			this.references = references__			this.resizeThreshold = (int) (references.length * getLoadFactor())__		};replace,the,references,with,a,new,value,recalculating,the,resize,threshold,param,references,the,new,references;private,void,set,references,reference,k,v,references,this,references,references,this,resize,threshold,int,references,length,get,load,factor
ConcurrentReferenceHashMap -> Segment -> private void setReferences(Reference<K, V>[] references);1398175099;Replace the references with a new value, recalculating the resizeThreshold._@param references the new references;private void setReferences(Reference<K, V>[] references) {_			this.references = references__			this.resizeThreshold = (int) (references.length * getLoadFactor())__		};replace,the,references,with,a,new,value,recalculating,the,resize,threshold,param,references,the,new,references;private,void,set,references,reference,k,v,references,this,references,references,this,resize,threshold,int,references,length,get,load,factor
ConcurrentReferenceHashMap -> Segment -> private void setReferences(Reference<K, V>[] references);1404132943;Replace the references with a new value, recalculating the resizeThreshold._@param references the new references;private void setReferences(Reference<K, V>[] references) {_			this.references = references__			this.resizeThreshold = (int) (references.length * getLoadFactor())__		};replace,the,references,with,a,new,value,recalculating,the,resize,threshold,param,references,the,new,references;private,void,set,references,reference,k,v,references,this,references,references,this,resize,threshold,int,references,length,get,load,factor
ConcurrentReferenceHashMap -> Segment -> private void setReferences(Reference<K, V>[] references);1427240641;Replace the references with a new value, recalculating the resizeThreshold._@param references the new references;private void setReferences(Reference<K, V>[] references) {_			this.references = references__			this.resizeThreshold = (int) (references.length * getLoadFactor())__		};replace,the,references,with,a,new,value,recalculating,the,resize,threshold,param,references,the,new,references;private,void,set,references,reference,k,v,references,this,references,references,this,resize,threshold,int,references,length,get,load,factor
ConcurrentReferenceHashMap -> Segment -> private void setReferences(Reference<K, V>[] references);1459795890;Replace the references with a new value, recalculating the resizeThreshold._@param references the new references;private void setReferences(Reference<K, V>[] references) {_			this.references = references__			this.resizeThreshold = (int) (references.length * getLoadFactor())__		};replace,the,references,with,a,new,value,recalculating,the,resize,threshold,param,references,the,new,references;private,void,set,references,reference,k,v,references,this,references,references,this,resize,threshold,int,references,length,get,load,factor
ConcurrentReferenceHashMap -> Segment -> private void setReferences(Reference<K, V>[] references);1467730834;Replace the references with a new value, recalculating the resizeThreshold._@param references the new references;private void setReferences(Reference<K, V>[] references) {_			this.references = references__			this.resizeThreshold = (int) (references.length * getLoadFactor())__		};replace,the,references,with,a,new,value,recalculating,the,resize,threshold,param,references,the,new,references;private,void,set,references,reference,k,v,references,this,references,references,this,resize,threshold,int,references,length,get,load,factor
ConcurrentReferenceHashMap -> Segment -> private void setReferences(Reference<K, V>[] references);1485810955;Replace the references with a new value, recalculating the resizeThreshold._@param references the new references;private void setReferences(Reference<K, V>[] references) {_			this.references = references__			this.resizeThreshold = (int) (references.length * getLoadFactor())__		};replace,the,references,with,a,new,value,recalculating,the,resize,threshold,param,references,the,new,references;private,void,set,references,reference,k,v,references,this,references,references,this,resize,threshold,int,references,length,get,load,factor
ConcurrentReferenceHashMap -> Segment -> private void setReferences(Reference<K, V>[] references);1495868221;Replace the references with a new value, recalculating the resizeThreshold._@param references the new references;private void setReferences(Reference<K, V>[] references) {_			this.references = references__			this.resizeThreshold = (int) (references.length * getLoadFactor())__		};replace,the,references,with,a,new,value,recalculating,the,resize,threshold,param,references,the,new,references;private,void,set,references,reference,k,v,references,this,references,references,this,resize,threshold,int,references,length,get,load,factor
ConcurrentReferenceHashMap -> Segment -> private void setReferences(Reference<K, V>[] references);1496242568;Replace the references with a new value, recalculating the resizeThreshold._@param references the new references;private void setReferences(Reference<K, V>[] references) {_			this.references = references__			this.resizeThreshold = (int) (references.length * getLoadFactor())__		};replace,the,references,with,a,new,value,recalculating,the,resize,threshold,param,references,the,new,references;private,void,set,references,reference,k,v,references,this,references,references,this,resize,threshold,int,references,length,get,load,factor
ConcurrentReferenceHashMap -> Segment -> private void setReferences(Reference<K, V>[] references);1496837955;Replace the references with a new value, recalculating the resizeThreshold._@param references the new references;private void setReferences(Reference<K, V>[] references) {_			this.references = references__			this.resizeThreshold = (int) (references.length * getLoadFactor())__		};replace,the,references,with,a,new,value,recalculating,the,resize,threshold,param,references,the,new,references;private,void,set,references,reference,k,v,references,this,references,references,this,resize,threshold,int,references,length,get,load,factor
ConcurrentReferenceHashMap -> ReferenceManager -> @SuppressWarnings("unchecked") 		public Reference<K, V> pollForPurge();1351982790;Return any reference that has been garbage collected and can be purged from the_underlying structure or {@code null} if no references need purging. This_method must be thread safe and ideally should not block when returning_{@code null}. References should be returned once and only once._@return a reference to purge or {@code null};@SuppressWarnings("unchecked")_		public Reference<K, V> pollForPurge() {_			return (Reference<K, V>) this.queue.poll()__		};return,any,reference,that,has,been,garbage,collected,and,can,be,purged,from,the,underlying,structure,or,code,null,if,no,references,need,purging,this,method,must,be,thread,safe,and,ideally,should,not,block,when,returning,code,null,references,should,be,returned,once,and,only,once,return,a,reference,to,purge,or,code,null;suppress,warnings,unchecked,public,reference,k,v,poll,for,purge,return,reference,k,v,this,queue,poll
ConcurrentReferenceHashMap -> ReferenceManager -> @SuppressWarnings("unchecked") 		public Reference<K, V> pollForPurge();1352039846;Return any reference that has been garbage collected and can be purged from the_underlying structure or {@code null} if no references need purging. This_method must be thread safe and ideally should not block when returning_{@code null}. References should be returned once and only once._@return a reference to purge or {@code null};@SuppressWarnings("unchecked")_		public Reference<K, V> pollForPurge() {_			return (Reference<K, V>) this.queue.poll()__		};return,any,reference,that,has,been,garbage,collected,and,can,be,purged,from,the,underlying,structure,or,code,null,if,no,references,need,purging,this,method,must,be,thread,safe,and,ideally,should,not,block,when,returning,code,null,references,should,be,returned,once,and,only,once,return,a,reference,to,purge,or,code,null;suppress,warnings,unchecked,public,reference,k,v,poll,for,purge,return,reference,k,v,this,queue,poll
ConcurrentReferenceHashMap -> ReferenceManager -> @SuppressWarnings("unchecked") 		public Reference<K, V> pollForPurge();1355313310;Return any reference that has been garbage collected and can be purged from the_underlying structure or {@code null} if no references need purging. This_method must be thread safe and ideally should not block when returning_{@code null}. References should be returned once and only once._@return a reference to purge or {@code null};@SuppressWarnings("unchecked")_		public Reference<K, V> pollForPurge() {_			return (Reference<K, V>) this.queue.poll()__		};return,any,reference,that,has,been,garbage,collected,and,can,be,purged,from,the,underlying,structure,or,code,null,if,no,references,need,purging,this,method,must,be,thread,safe,and,ideally,should,not,block,when,returning,code,null,references,should,be,returned,once,and,only,once,return,a,reference,to,purge,or,code,null;suppress,warnings,unchecked,public,reference,k,v,poll,for,purge,return,reference,k,v,this,queue,poll
ConcurrentReferenceHashMap -> ReferenceManager -> @SuppressWarnings("unchecked") 		public Reference<K, V> pollForPurge();1356735495;Return any reference that has been garbage collected and can be purged from the_underlying structure or {@code null} if no references need purging. This_method must be thread safe and ideally should not block when returning_{@code null}. References should be returned once and only once._@return a reference to purge or {@code null};@SuppressWarnings("unchecked")_		public Reference<K, V> pollForPurge() {_			return (Reference<K, V>) this.queue.poll()__		};return,any,reference,that,has,been,garbage,collected,and,can,be,purged,from,the,underlying,structure,or,code,null,if,no,references,need,purging,this,method,must,be,thread,safe,and,ideally,should,not,block,when,returning,code,null,references,should,be,returned,once,and,only,once,return,a,reference,to,purge,or,code,null;suppress,warnings,unchecked,public,reference,k,v,poll,for,purge,return,reference,k,v,this,queue,poll
ConcurrentReferenceHashMap -> ReferenceManager -> @SuppressWarnings("unchecked") 		public Reference<K, V> pollForPurge();1357119239;Return any reference that has been garbage collected and can be purged from the_underlying structure or {@code null} if no references need purging. This_method must be thread safe and ideally should not block when returning_{@code null}. References should be returned once and only once._@return a reference to purge or {@code null};@SuppressWarnings("unchecked")_		public Reference<K, V> pollForPurge() {_			return (Reference<K, V>) this.queue.poll()__		};return,any,reference,that,has,been,garbage,collected,and,can,be,purged,from,the,underlying,structure,or,code,null,if,no,references,need,purging,this,method,must,be,thread,safe,and,ideally,should,not,block,when,returning,code,null,references,should,be,returned,once,and,only,once,return,a,reference,to,purge,or,code,null;suppress,warnings,unchecked,public,reference,k,v,poll,for,purge,return,reference,k,v,this,queue,poll
ConcurrentReferenceHashMap -> ReferenceManager -> @SuppressWarnings("unchecked") 		public Reference<K, V> pollForPurge();1368482696;Return any reference that has been garbage collected and can be purged from the_underlying structure or {@code null} if no references need purging. This_method must be thread safe and ideally should not block when returning_{@code null}. References should be returned once and only once._@return a reference to purge or {@code null};@SuppressWarnings("unchecked")_		public Reference<K, V> pollForPurge() {_			return (Reference<K, V>) this.queue.poll()__		};return,any,reference,that,has,been,garbage,collected,and,can,be,purged,from,the,underlying,structure,or,code,null,if,no,references,need,purging,this,method,must,be,thread,safe,and,ideally,should,not,block,when,returning,code,null,references,should,be,returned,once,and,only,once,return,a,reference,to,purge,or,code,null;suppress,warnings,unchecked,public,reference,k,v,poll,for,purge,return,reference,k,v,this,queue,poll
ConcurrentReferenceHashMap -> ReferenceManager -> @SuppressWarnings("unchecked") 		public Reference<K, V> pollForPurge();1383090835;Return any reference that has been garbage collected and can be purged from the_underlying structure or {@code null} if no references need purging. This_method must be thread safe and ideally should not block when returning_{@code null}. References should be returned once and only once._@return a reference to purge or {@code null};@SuppressWarnings("unchecked")_		public Reference<K, V> pollForPurge() {_			return (Reference<K, V>) this.queue.poll()__		};return,any,reference,that,has,been,garbage,collected,and,can,be,purged,from,the,underlying,structure,or,code,null,if,no,references,need,purging,this,method,must,be,thread,safe,and,ideally,should,not,block,when,returning,code,null,references,should,be,returned,once,and,only,once,return,a,reference,to,purge,or,code,null;suppress,warnings,unchecked,public,reference,k,v,poll,for,purge,return,reference,k,v,this,queue,poll
ConcurrentReferenceHashMap -> ReferenceManager -> @SuppressWarnings("unchecked") 		public Reference<K, V> pollForPurge();1383178438;Return any reference that has been garbage collected and can be purged from the_underlying structure or {@code null} if no references need purging. This_method must be thread safe and ideally should not block when returning_{@code null}. References should be returned once and only once._@return a reference to purge or {@code null};@SuppressWarnings("unchecked")_		public Reference<K, V> pollForPurge() {_			return (Reference<K, V>) this.queue.poll()__		};return,any,reference,that,has,been,garbage,collected,and,can,be,purged,from,the,underlying,structure,or,code,null,if,no,references,need,purging,this,method,must,be,thread,safe,and,ideally,should,not,block,when,returning,code,null,references,should,be,returned,once,and,only,once,return,a,reference,to,purge,or,code,null;suppress,warnings,unchecked,public,reference,k,v,poll,for,purge,return,reference,k,v,this,queue,poll
ConcurrentReferenceHashMap -> ReferenceManager -> @SuppressWarnings("unchecked") 		public Reference<K, V> pollForPurge();1390260938;Return any reference that has been garbage collected and can be purged from the_underlying structure or {@code null} if no references need purging. This_method must be thread safe and ideally should not block when returning_{@code null}. References should be returned once and only once._@return a reference to purge or {@code null};@SuppressWarnings("unchecked")_		public Reference<K, V> pollForPurge() {_			return (Reference<K, V>) this.queue.poll()__		};return,any,reference,that,has,been,garbage,collected,and,can,be,purged,from,the,underlying,structure,or,code,null,if,no,references,need,purging,this,method,must,be,thread,safe,and,ideally,should,not,block,when,returning,code,null,references,should,be,returned,once,and,only,once,return,a,reference,to,purge,or,code,null;suppress,warnings,unchecked,public,reference,k,v,poll,for,purge,return,reference,k,v,this,queue,poll
ConcurrentReferenceHashMap -> ReferenceManager -> @SuppressWarnings("unchecked") 		public Reference<K, V> pollForPurge();1391715359;Return any reference that has been garbage collected and can be purged from the_underlying structure or {@code null} if no references need purging. This_method must be thread safe and ideally should not block when returning_{@code null}. References should be returned once and only once._@return a reference to purge or {@code null};@SuppressWarnings("unchecked")_		public Reference<K, V> pollForPurge() {_			return (Reference<K, V>) this.queue.poll()__		};return,any,reference,that,has,been,garbage,collected,and,can,be,purged,from,the,underlying,structure,or,code,null,if,no,references,need,purging,this,method,must,be,thread,safe,and,ideally,should,not,block,when,returning,code,null,references,should,be,returned,once,and,only,once,return,a,reference,to,purge,or,code,null;suppress,warnings,unchecked,public,reference,k,v,poll,for,purge,return,reference,k,v,this,queue,poll
ConcurrentReferenceHashMap -> ReferenceManager -> @SuppressWarnings("unchecked") 		public Reference<K, V> pollForPurge();1392765030;Return any reference that has been garbage collected and can be purged from the_underlying structure or {@code null} if no references need purging. This_method must be thread safe and ideally should not block when returning_{@code null}. References should be returned once and only once._@return a reference to purge or {@code null};@SuppressWarnings("unchecked")_		public Reference<K, V> pollForPurge() {_			return (Reference<K, V>) this.queue.poll()__		};return,any,reference,that,has,been,garbage,collected,and,can,be,purged,from,the,underlying,structure,or,code,null,if,no,references,need,purging,this,method,must,be,thread,safe,and,ideally,should,not,block,when,returning,code,null,references,should,be,returned,once,and,only,once,return,a,reference,to,purge,or,code,null;suppress,warnings,unchecked,public,reference,k,v,poll,for,purge,return,reference,k,v,this,queue,poll
ConcurrentReferenceHashMap -> ReferenceManager -> @SuppressWarnings("unchecked") 		public Reference<K, V> pollForPurge();1398175099;Return any reference that has been garbage collected and can be purged from the_underlying structure or {@code null} if no references need purging. This_method must be thread safe and ideally should not block when returning_{@code null}. References should be returned once and only once._@return a reference to purge or {@code null};@SuppressWarnings("unchecked")_		public Reference<K, V> pollForPurge() {_			return (Reference<K, V>) this.queue.poll()__		};return,any,reference,that,has,been,garbage,collected,and,can,be,purged,from,the,underlying,structure,or,code,null,if,no,references,need,purging,this,method,must,be,thread,safe,and,ideally,should,not,block,when,returning,code,null,references,should,be,returned,once,and,only,once,return,a,reference,to,purge,or,code,null;suppress,warnings,unchecked,public,reference,k,v,poll,for,purge,return,reference,k,v,this,queue,poll
ConcurrentReferenceHashMap -> ReferenceManager -> @SuppressWarnings("unchecked") 		public Reference<K, V> pollForPurge();1404132943;Return any reference that has been garbage collected and can be purged from the_underlying structure or {@code null} if no references need purging. This_method must be thread safe and ideally should not block when returning_{@code null}. References should be returned once and only once._@return a reference to purge or {@code null};@SuppressWarnings("unchecked")_		public Reference<K, V> pollForPurge() {_			return (Reference<K, V>) this.queue.poll()__		};return,any,reference,that,has,been,garbage,collected,and,can,be,purged,from,the,underlying,structure,or,code,null,if,no,references,need,purging,this,method,must,be,thread,safe,and,ideally,should,not,block,when,returning,code,null,references,should,be,returned,once,and,only,once,return,a,reference,to,purge,or,code,null;suppress,warnings,unchecked,public,reference,k,v,poll,for,purge,return,reference,k,v,this,queue,poll
ConcurrentReferenceHashMap -> ReferenceManager -> @SuppressWarnings("unchecked") 		public Reference<K, V> pollForPurge();1427240641;Return any reference that has been garbage collected and can be purged from the_underlying structure or {@code null} if no references need purging. This_method must be thread safe and ideally should not block when returning_{@code null}. References should be returned once and only once._@return a reference to purge or {@code null};@SuppressWarnings("unchecked")_		public Reference<K, V> pollForPurge() {_			return (Reference<K, V>) this.queue.poll()__		};return,any,reference,that,has,been,garbage,collected,and,can,be,purged,from,the,underlying,structure,or,code,null,if,no,references,need,purging,this,method,must,be,thread,safe,and,ideally,should,not,block,when,returning,code,null,references,should,be,returned,once,and,only,once,return,a,reference,to,purge,or,code,null;suppress,warnings,unchecked,public,reference,k,v,poll,for,purge,return,reference,k,v,this,queue,poll
ConcurrentReferenceHashMap -> ReferenceManager -> @SuppressWarnings("unchecked") 		public Reference<K, V> pollForPurge();1459795890;Return any reference that has been garbage collected and can be purged from the_underlying structure or {@code null} if no references need purging. This_method must be thread safe and ideally should not block when returning_{@code null}. References should be returned once and only once._@return a reference to purge or {@code null};@SuppressWarnings("unchecked")_		public Reference<K, V> pollForPurge() {_			return (Reference<K, V>) this.queue.poll()__		};return,any,reference,that,has,been,garbage,collected,and,can,be,purged,from,the,underlying,structure,or,code,null,if,no,references,need,purging,this,method,must,be,thread,safe,and,ideally,should,not,block,when,returning,code,null,references,should,be,returned,once,and,only,once,return,a,reference,to,purge,or,code,null;suppress,warnings,unchecked,public,reference,k,v,poll,for,purge,return,reference,k,v,this,queue,poll
ConcurrentReferenceHashMap -> ReferenceManager -> @SuppressWarnings("unchecked") 		public Reference<K, V> pollForPurge();1467730834;Return any reference that has been garbage collected and can be purged from the_underlying structure or {@code null} if no references need purging. This_method must be thread safe and ideally should not block when returning_{@code null}. References should be returned once and only once._@return a reference to purge or {@code null};@SuppressWarnings("unchecked")_		public Reference<K, V> pollForPurge() {_			return (Reference<K, V>) this.queue.poll()__		};return,any,reference,that,has,been,garbage,collected,and,can,be,purged,from,the,underlying,structure,or,code,null,if,no,references,need,purging,this,method,must,be,thread,safe,and,ideally,should,not,block,when,returning,code,null,references,should,be,returned,once,and,only,once,return,a,reference,to,purge,or,code,null;suppress,warnings,unchecked,public,reference,k,v,poll,for,purge,return,reference,k,v,this,queue,poll
ConcurrentReferenceHashMap -> ReferenceManager -> @SuppressWarnings("unchecked") 		public Reference<K, V> pollForPurge();1485810955;Return any reference that has been garbage collected and can be purged from the_underlying structure or {@code null} if no references need purging. This_method must be thread safe and ideally should not block when returning_{@code null}. References should be returned once and only once._@return a reference to purge or {@code null};@SuppressWarnings("unchecked")_		public Reference<K, V> pollForPurge() {_			return (Reference<K, V>) this.queue.poll()__		};return,any,reference,that,has,been,garbage,collected,and,can,be,purged,from,the,underlying,structure,or,code,null,if,no,references,need,purging,this,method,must,be,thread,safe,and,ideally,should,not,block,when,returning,code,null,references,should,be,returned,once,and,only,once,return,a,reference,to,purge,or,code,null;suppress,warnings,unchecked,public,reference,k,v,poll,for,purge,return,reference,k,v,this,queue,poll
ConcurrentReferenceHashMap -> @SuppressWarnings("unchecked") 	public ConcurrentReferenceHashMap( 			int initialCapacity, float loadFactor, int concurrencyLevel, ReferenceType referenceType);1530563577;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map_@param referenceType the reference type used for entries (soft or weak);@SuppressWarnings("unchecked")_	public ConcurrentReferenceHashMap(_			int initialCapacity, float loadFactor, int concurrencyLevel, ReferenceType referenceType) {__		Assert.isTrue(initialCapacity >= 0, "Initial capacity must not be negative")__		Assert.isTrue(loadFactor > 0f, "Load factor must be positive")__		Assert.isTrue(concurrencyLevel > 0, "Concurrency level must be positive")__		Assert.notNull(referenceType, "Reference type must not be null")__		this.loadFactor = loadFactor__		this.shift = calculateShift(concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL)__		int size = 1 << this.shift__		this.referenceType = referenceType__		int roundedUpSegmentCapacity = (int) ((initialCapacity + size - 1L) / size)__		this.segments = (Segment[]) Array.newInstance(Segment.class, size)__		for (int i = 0_ i < this.segments.length_ i++) {_			this.segments[i] = new Segment(roundedUpSegmentCapacity)__		}_	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;suppress,warnings,unchecked,public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,reference,type,reference,type,assert,is,true,initial,capacity,0,initial,capacity,must,not,be,negative,assert,is,true,load,factor,0f,load,factor,must,be,positive,assert,is,true,concurrency,level,0,concurrency,level,must,be,positive,assert,not,null,reference,type,reference,type,must,not,be,null,this,load,factor,load,factor,this,shift,calculate,shift,concurrency,level,int,size,1,this,shift,this,reference,type,reference,type,int,rounded,up,segment,capacity,int,initial,capacity,size,1l,size,this,segments,segment,array,new,instance,segment,class,size,for,int,i,0,i,this,segments,length,i,this,segments,i,new,segment,rounded,up,segment,capacity
ConcurrentReferenceHashMap -> @SuppressWarnings("unchecked") 	public ConcurrentReferenceHashMap( 			int initialCapacity, float loadFactor, int concurrencyLevel, ReferenceType referenceType);1531136363;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map_@param referenceType the reference type used for entries (soft or weak);@SuppressWarnings("unchecked")_	public ConcurrentReferenceHashMap(_			int initialCapacity, float loadFactor, int concurrencyLevel, ReferenceType referenceType) {__		Assert.isTrue(initialCapacity >= 0, "Initial capacity must not be negative")__		Assert.isTrue(loadFactor > 0f, "Load factor must be positive")__		Assert.isTrue(concurrencyLevel > 0, "Concurrency level must be positive")__		Assert.notNull(referenceType, "Reference type must not be null")__		this.loadFactor = loadFactor__		this.shift = calculateShift(concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL)__		int size = 1 << this.shift__		this.referenceType = referenceType__		int roundedUpSegmentCapacity = (int) ((initialCapacity + size - 1L) / size)__		this.segments = (Segment[]) Array.newInstance(Segment.class, size)__		for (int i = 0_ i < this.segments.length_ i++) {_			this.segments[i] = new Segment(roundedUpSegmentCapacity)__		}_	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;suppress,warnings,unchecked,public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,reference,type,reference,type,assert,is,true,initial,capacity,0,initial,capacity,must,not,be,negative,assert,is,true,load,factor,0f,load,factor,must,be,positive,assert,is,true,concurrency,level,0,concurrency,level,must,be,positive,assert,not,null,reference,type,reference,type,must,not,be,null,this,load,factor,load,factor,this,shift,calculate,shift,concurrency,level,int,size,1,this,shift,this,reference,type,reference,type,int,rounded,up,segment,capacity,int,initial,capacity,size,1l,size,this,segments,segment,array,new,instance,segment,class,size,for,int,i,0,i,this,segments,length,i,this,segments,i,new,segment,rounded,up,segment,capacity
ConcurrentReferenceHashMap -> @SuppressWarnings("unchecked") 	public ConcurrentReferenceHashMap( 			int initialCapacity, float loadFactor, int concurrencyLevel, ReferenceType referenceType);1531139295;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map_@param referenceType the reference type used for entries (soft or weak);@SuppressWarnings("unchecked")_	public ConcurrentReferenceHashMap(_			int initialCapacity, float loadFactor, int concurrencyLevel, ReferenceType referenceType) {__		Assert.isTrue(initialCapacity >= 0, "Initial capacity must not be negative")__		Assert.isTrue(loadFactor > 0f, "Load factor must be positive")__		Assert.isTrue(concurrencyLevel > 0, "Concurrency level must be positive")__		Assert.notNull(referenceType, "Reference type must not be null")__		this.loadFactor = loadFactor__		this.shift = calculateShift(concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL)__		int size = 1 << this.shift__		this.referenceType = referenceType__		int roundedUpSegmentCapacity = (int) ((initialCapacity + size - 1L) / size)__		this.segments = (Segment[]) Array.newInstance(Segment.class, size)__		for (int i = 0_ i < this.segments.length_ i++) {_			this.segments[i] = new Segment(roundedUpSegmentCapacity)__		}_	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;suppress,warnings,unchecked,public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,reference,type,reference,type,assert,is,true,initial,capacity,0,initial,capacity,must,not,be,negative,assert,is,true,load,factor,0f,load,factor,must,be,positive,assert,is,true,concurrency,level,0,concurrency,level,must,be,positive,assert,not,null,reference,type,reference,type,must,not,be,null,this,load,factor,load,factor,this,shift,calculate,shift,concurrency,level,int,size,1,this,shift,this,reference,type,reference,type,int,rounded,up,segment,capacity,int,initial,capacity,size,1l,size,this,segments,segment,array,new,instance,segment,class,size,for,int,i,0,i,this,segments,length,i,this,segments,i,new,segment,rounded,up,segment,capacity
ConcurrentReferenceHashMap -> @SuppressWarnings("unchecked") 	public ConcurrentReferenceHashMap( 			int initialCapacity, float loadFactor, int concurrencyLevel, ReferenceType referenceType);1544716668;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map_@param referenceType the reference type used for entries (soft or weak);@SuppressWarnings("unchecked")_	public ConcurrentReferenceHashMap(_			int initialCapacity, float loadFactor, int concurrencyLevel, ReferenceType referenceType) {__		Assert.isTrue(initialCapacity >= 0, "Initial capacity must not be negative")__		Assert.isTrue(loadFactor > 0f, "Load factor must be positive")__		Assert.isTrue(concurrencyLevel > 0, "Concurrency level must be positive")__		Assert.notNull(referenceType, "Reference type must not be null")__		this.loadFactor = loadFactor__		this.shift = calculateShift(concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL)__		int size = 1 << this.shift__		this.referenceType = referenceType__		int roundedUpSegmentCapacity = (int) ((initialCapacity + size - 1L) / size)__		int initialSize = 1 << calculateShift(roundedUpSegmentCapacity, MAXIMUM_SEGMENT_SIZE)__		Segment[] segments = (Segment[]) Array.newInstance(Segment.class, size)__		int resizeThreshold = (int) (initialSize * getLoadFactor())__		for (int i = 0_ i < segments.length_ i++) {_			segments[i] = new Segment(initialSize, resizeThreshold)__		}_		this.segments = segments__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;suppress,warnings,unchecked,public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,reference,type,reference,type,assert,is,true,initial,capacity,0,initial,capacity,must,not,be,negative,assert,is,true,load,factor,0f,load,factor,must,be,positive,assert,is,true,concurrency,level,0,concurrency,level,must,be,positive,assert,not,null,reference,type,reference,type,must,not,be,null,this,load,factor,load,factor,this,shift,calculate,shift,concurrency,level,int,size,1,this,shift,this,reference,type,reference,type,int,rounded,up,segment,capacity,int,initial,capacity,size,1l,size,int,initial,size,1,calculate,shift,rounded,up,segment,capacity,segment,segments,segment,array,new,instance,segment,class,size,int,resize,threshold,int,initial,size,get,load,factor,for,int,i,0,i,segments,length,i,segments,i,new,segment,initial,size,resize,threshold,this,segments,segments
ConcurrentReferenceHashMap -> @SuppressWarnings("unchecked") 	public ConcurrentReferenceHashMap( 			int initialCapacity, float loadFactor, int concurrencyLevel, ReferenceType referenceType);1549318940;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map_@param referenceType the reference type used for entries (soft or weak);@SuppressWarnings("unchecked")_	public ConcurrentReferenceHashMap(_			int initialCapacity, float loadFactor, int concurrencyLevel, ReferenceType referenceType) {__		Assert.isTrue(initialCapacity >= 0, "Initial capacity must not be negative")__		Assert.isTrue(loadFactor > 0f, "Load factor must be positive")__		Assert.isTrue(concurrencyLevel > 0, "Concurrency level must be positive")__		Assert.notNull(referenceType, "Reference type must not be null")__		this.loadFactor = loadFactor__		this.shift = calculateShift(concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL)__		int size = 1 << this.shift__		this.referenceType = referenceType__		int roundedUpSegmentCapacity = (int) ((initialCapacity + size - 1L) / size)__		int initialSize = 1 << calculateShift(roundedUpSegmentCapacity, MAXIMUM_SEGMENT_SIZE)__		Segment[] segments = (Segment[]) Array.newInstance(Segment.class, size)__		int resizeThreshold = (int) (initialSize * getLoadFactor())__		for (int i = 0_ i < segments.length_ i++) {_			segments[i] = new Segment(initialSize, resizeThreshold)__		}_		this.segments = segments__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;suppress,warnings,unchecked,public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,reference,type,reference,type,assert,is,true,initial,capacity,0,initial,capacity,must,not,be,negative,assert,is,true,load,factor,0f,load,factor,must,be,positive,assert,is,true,concurrency,level,0,concurrency,level,must,be,positive,assert,not,null,reference,type,reference,type,must,not,be,null,this,load,factor,load,factor,this,shift,calculate,shift,concurrency,level,int,size,1,this,shift,this,reference,type,reference,type,int,rounded,up,segment,capacity,int,initial,capacity,size,1l,size,int,initial,size,1,calculate,shift,rounded,up,segment,capacity,segment,segments,segment,array,new,instance,segment,class,size,int,resize,threshold,int,initial,size,get,load,factor,for,int,i,0,i,segments,length,i,segments,i,new,segment,initial,size,resize,threshold,this,segments,segments
ConcurrentReferenceHashMap -> @SuppressWarnings("unchecked") 	public ConcurrentReferenceHashMap( 			int initialCapacity, float loadFactor, int concurrencyLevel, ReferenceType referenceType);1549321822;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map_@param referenceType the reference type used for entries (soft or weak);@SuppressWarnings("unchecked")_	public ConcurrentReferenceHashMap(_			int initialCapacity, float loadFactor, int concurrencyLevel, ReferenceType referenceType) {__		Assert.isTrue(initialCapacity >= 0, "Initial capacity must not be negative")__		Assert.isTrue(loadFactor > 0f, "Load factor must be positive")__		Assert.isTrue(concurrencyLevel > 0, "Concurrency level must be positive")__		Assert.notNull(referenceType, "Reference type must not be null")__		this.loadFactor = loadFactor__		this.shift = calculateShift(concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL)__		int size = 1 << this.shift__		this.referenceType = referenceType__		int roundedUpSegmentCapacity = (int) ((initialCapacity + size - 1L) / size)__		int initialSize = 1 << calculateShift(roundedUpSegmentCapacity, MAXIMUM_SEGMENT_SIZE)__		Segment[] segments = (Segment[]) Array.newInstance(Segment.class, size)__		int resizeThreshold = (int) (initialSize * getLoadFactor())__		for (int i = 0_ i < segments.length_ i++) {_			segments[i] = new Segment(initialSize, resizeThreshold)__		}_		this.segments = segments__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;suppress,warnings,unchecked,public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,reference,type,reference,type,assert,is,true,initial,capacity,0,initial,capacity,must,not,be,negative,assert,is,true,load,factor,0f,load,factor,must,be,positive,assert,is,true,concurrency,level,0,concurrency,level,must,be,positive,assert,not,null,reference,type,reference,type,must,not,be,null,this,load,factor,load,factor,this,shift,calculate,shift,concurrency,level,int,size,1,this,shift,this,reference,type,reference,type,int,rounded,up,segment,capacity,int,initial,capacity,size,1l,size,int,initial,size,1,calculate,shift,rounded,up,segment,capacity,segment,segments,segment,array,new,instance,segment,class,size,int,resize,threshold,int,initial,size,get,load,factor,for,int,i,0,i,segments,length,i,segments,i,new,segment,initial,size,resize,threshold,this,segments,segments
ConcurrentReferenceHashMap -> @SuppressWarnings("unchecked") 	public ConcurrentReferenceHashMap( 			int initialCapacity, float loadFactor, int concurrencyLevel, ReferenceType referenceType);1550237263;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map_@param referenceType the reference type used for entries (soft or weak);@SuppressWarnings("unchecked")_	public ConcurrentReferenceHashMap(_			int initialCapacity, float loadFactor, int concurrencyLevel, ReferenceType referenceType) {__		Assert.isTrue(initialCapacity >= 0, "Initial capacity must not be negative")__		Assert.isTrue(loadFactor > 0f, "Load factor must be positive")__		Assert.isTrue(concurrencyLevel > 0, "Concurrency level must be positive")__		Assert.notNull(referenceType, "Reference type must not be null")__		this.loadFactor = loadFactor__		this.shift = calculateShift(concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL)__		int size = 1 << this.shift__		this.referenceType = referenceType__		int roundedUpSegmentCapacity = (int) ((initialCapacity + size - 1L) / size)__		int initialSize = 1 << calculateShift(roundedUpSegmentCapacity, MAXIMUM_SEGMENT_SIZE)__		Segment[] segments = (Segment[]) Array.newInstance(Segment.class, size)__		int resizeThreshold = (int) (initialSize * getLoadFactor())__		for (int i = 0_ i < segments.length_ i++) {_			segments[i] = new Segment(initialSize, resizeThreshold)__		}_		this.segments = segments__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;suppress,warnings,unchecked,public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,reference,type,reference,type,assert,is,true,initial,capacity,0,initial,capacity,must,not,be,negative,assert,is,true,load,factor,0f,load,factor,must,be,positive,assert,is,true,concurrency,level,0,concurrency,level,must,be,positive,assert,not,null,reference,type,reference,type,must,not,be,null,this,load,factor,load,factor,this,shift,calculate,shift,concurrency,level,int,size,1,this,shift,this,reference,type,reference,type,int,rounded,up,segment,capacity,int,initial,capacity,size,1l,size,int,initial,size,1,calculate,shift,rounded,up,segment,capacity,segment,segments,segment,array,new,instance,segment,class,size,int,resize,threshold,int,initial,size,get,load,factor,for,int,i,0,i,segments,length,i,segments,i,new,segment,initial,size,resize,threshold,this,segments,segments
ConcurrentReferenceHashMap -> Task -> @Nullable 		protected T execute(@Nullable Reference<K, V> reference, @Nullable Entry<K, V> entry);1495868221;Convenience method that can be used for tasks that do not need access to {@link Entries}._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@return the result of the task_@see #execute(Reference, Entry, Entries);@Nullable_		protected T execute(@Nullable Reference<K, V> reference, @Nullable Entry<K, V> entry) {_			return null__		};convenience,method,that,can,be,used,for,tasks,that,do,not,need,access,to,link,entries,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,return,the,result,of,the,task,see,execute,reference,entry,entries;nullable,protected,t,execute,nullable,reference,k,v,reference,nullable,entry,k,v,entry,return,null
ConcurrentReferenceHashMap -> Task -> @Nullable 		protected T execute(@Nullable Reference<K, V> reference, @Nullable Entry<K, V> entry);1496242568;Convenience method that can be used for tasks that do not need access to {@link Entries}._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@return the result of the task_@see #execute(Reference, Entry, Entries);@Nullable_		protected T execute(@Nullable Reference<K, V> reference, @Nullable Entry<K, V> entry) {_			return null__		};convenience,method,that,can,be,used,for,tasks,that,do,not,need,access,to,link,entries,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,return,the,result,of,the,task,see,execute,reference,entry,entries;nullable,protected,t,execute,nullable,reference,k,v,reference,nullable,entry,k,v,entry,return,null
ConcurrentReferenceHashMap -> Task -> @Nullable 		protected T execute(@Nullable Reference<K, V> reference, @Nullable Entry<K, V> entry);1496837955;Convenience method that can be used for tasks that do not need access to {@link Entries}._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@return the result of the task_@see #execute(Reference, Entry, Entries);@Nullable_		protected T execute(@Nullable Reference<K, V> reference, @Nullable Entry<K, V> entry) {_			return null__		};convenience,method,that,can,be,used,for,tasks,that,do,not,need,access,to,link,entries,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,return,the,result,of,the,task,see,execute,reference,entry,entries;nullable,protected,t,execute,nullable,reference,k,v,reference,nullable,entry,k,v,entry,return,null
ConcurrentReferenceHashMap -> Task -> @Nullable 		protected T execute(@Nullable Reference<K, V> reference, @Nullable Entry<K, V> entry);1498780456;Convenience method that can be used for tasks that do not need access to {@link Entries}._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@return the result of the task_@see #execute(Reference, Entry, Entries);@Nullable_		protected T execute(@Nullable Reference<K, V> reference, @Nullable Entry<K, V> entry) {_			return null__		};convenience,method,that,can,be,used,for,tasks,that,do,not,need,access,to,link,entries,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,return,the,result,of,the,task,see,execute,reference,entry,entries;nullable,protected,t,execute,nullable,reference,k,v,reference,nullable,entry,k,v,entry,return,null
ConcurrentReferenceHashMap -> Task -> @Nullable 		protected T execute(@Nullable Reference<K, V> reference, @Nullable Entry<K, V> entry);1502974979;Convenience method that can be used for tasks that do not need access to {@link Entries}._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@return the result of the task_@see #execute(Reference, Entry, Entries);@Nullable_		protected T execute(@Nullable Reference<K, V> reference, @Nullable Entry<K, V> entry) {_			return null__		};convenience,method,that,can,be,used,for,tasks,that,do,not,need,access,to,link,entries,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,return,the,result,of,the,task,see,execute,reference,entry,entries;nullable,protected,t,execute,nullable,reference,k,v,reference,nullable,entry,k,v,entry,return,null
ConcurrentReferenceHashMap -> Task -> @Nullable 		protected T execute(@Nullable Reference<K, V> reference, @Nullable Entry<K, V> entry);1506097334;Convenience method that can be used for tasks that do not need access to {@link Entries}._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@return the result of the task_@see #execute(Reference, Entry, Entries);@Nullable_		protected T execute(@Nullable Reference<K, V> reference, @Nullable Entry<K, V> entry) {_			return null__		};convenience,method,that,can,be,used,for,tasks,that,do,not,need,access,to,link,entries,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,return,the,result,of,the,task,see,execute,reference,entry,entries;nullable,protected,t,execute,nullable,reference,k,v,reference,nullable,entry,k,v,entry,return,null
ConcurrentReferenceHashMap -> Task -> @Nullable 		protected T execute(@Nullable Reference<K, V> reference, @Nullable Entry<K, V> entry);1521044224;Convenience method that can be used for tasks that do not need access to {@link Entries}._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@return the result of the task_@see #execute(Reference, Entry, Entries);@Nullable_		protected T execute(@Nullable Reference<K, V> reference, @Nullable Entry<K, V> entry) {_			return null__		};convenience,method,that,can,be,used,for,tasks,that,do,not,need,access,to,link,entries,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,return,the,result,of,the,task,see,execute,reference,entry,entries;nullable,protected,t,execute,nullable,reference,k,v,reference,nullable,entry,k,v,entry,return,null
ConcurrentReferenceHashMap -> Task -> @Nullable 		protected T execute(@Nullable Reference<K, V> reference, @Nullable Entry<K, V> entry);1530174524;Convenience method that can be used for tasks that do not need access to {@link Entries}._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@return the result of the task_@see #execute(Reference, Entry, Entries);@Nullable_		protected T execute(@Nullable Reference<K, V> reference, @Nullable Entry<K, V> entry) {_			return null__		};convenience,method,that,can,be,used,for,tasks,that,do,not,need,access,to,link,entries,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,return,the,result,of,the,task,see,execute,reference,entry,entries;nullable,protected,t,execute,nullable,reference,k,v,reference,nullable,entry,k,v,entry,return,null
ConcurrentReferenceHashMap -> Task -> @Nullable 		protected T execute(@Nullable Reference<K, V> reference, @Nullable Entry<K, V> entry);1530190293;Convenience method that can be used for tasks that do not need access to {@link Entries}._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@return the result of the task_@see #execute(Reference, Entry, Entries);@Nullable_		protected T execute(@Nullable Reference<K, V> reference, @Nullable Entry<K, V> entry) {_			return null__		};convenience,method,that,can,be,used,for,tasks,that,do,not,need,access,to,link,entries,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,return,the,result,of,the,task,see,execute,reference,entry,entries;nullable,protected,t,execute,nullable,reference,k,v,reference,nullable,entry,k,v,entry,return,null
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel);1351982790;Create a new {@link ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param concurrencyLevel the expected number of threads that will concurrently write_to the map;public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, concurrencyLevel,_				DEFAULT_REFERENCE_TYPE)__	};create,a,new,link,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,int,concurrency,level,this,initial,capacity,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel);1352039846;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param concurrencyLevel the expected number of threads that will concurrently write_to the map;public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, concurrencyLevel,_				DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,int,concurrency,level,this,initial,capacity,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel);1355313310;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param concurrencyLevel the expected number of threads that will concurrently write_to the map;public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, concurrencyLevel,_				DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,int,concurrency,level,this,initial,capacity,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel);1356735495;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param concurrencyLevel the expected number of threads that will concurrently write_to the map;public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, concurrencyLevel,_				DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,int,concurrency,level,this,initial,capacity,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel);1357119239;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param concurrencyLevel the expected number of threads that will concurrently write_to the map;public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, concurrencyLevel,_				DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,int,concurrency,level,this,initial,capacity,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel);1368482696;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param concurrencyLevel the expected number of threads that will concurrently write_to the map;public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, concurrencyLevel,_				DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,int,concurrency,level,this,initial,capacity,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel);1383090835;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,int,concurrency,level,this,initial,capacity,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel);1383178438;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,int,concurrency,level,this,initial,capacity,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel);1390260938;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,int,concurrency,level,this,initial,capacity,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel);1391715359;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,int,concurrency,level,this,initial,capacity,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel);1392765030;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,int,concurrency,level,this,initial,capacity,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel);1398175099;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,int,concurrency,level,this,initial,capacity,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel);1404132943;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,int,concurrency,level,this,initial,capacity,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel);1427240641;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,int,concurrency,level,this,initial,capacity,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel);1459795890;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,int,concurrency,level,this,initial,capacity,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel);1467730834;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,int,concurrency,level,this,initial,capacity,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel);1485810955;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,int,concurrency,level,this,initial,capacity,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel);1495868221;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,int,concurrency,level,this,initial,capacity,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel);1496242568;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,int,concurrency,level,this,initial,capacity,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel);1496837955;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,int,concurrency,level,this,initial,capacity,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel);1498780456;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,int,concurrency,level,this,initial,capacity,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel);1502974979;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,int,concurrency,level,this,initial,capacity,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel);1506097334;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,int,concurrency,level,this,initial,capacity,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel);1521044224;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,int,concurrency,level,this,initial,capacity,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel);1530174524;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,int,concurrency,level,this,initial,capacity,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel);1530190293;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,int,concurrency,level,this,initial,capacity,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel);1530563577;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,int,concurrency,level,this,initial,capacity,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel);1531136363;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,int,concurrency,level,this,initial,capacity,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel);1531139295;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,int,concurrency,level,this,initial,capacity,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel);1544716668;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,int,concurrency,level,this,initial,capacity,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel);1549318940;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,int,concurrency,level,this,initial,capacity,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel);1549321822;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,int,concurrency,level,this,initial,capacity,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel);1550237263;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,int,concurrency,level,this,initial,capacity,concurrency,level
ConcurrentReferenceHashMap -> Task -> protected T execute(Reference<K, V> reference, Entry<K, V> entry, Entries entries);1351982790;Execute the task._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@param entries access to the underlying entries_@return the result of the task_@see #execute(Reference, Entry);protected T execute(Reference<K, V> reference, Entry<K, V> entry, Entries entries) {_			return execute(reference, entry)__		};execute,the,task,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,param,entries,access,to,the,underlying,entries,return,the,result,of,the,task,see,execute,reference,entry;protected,t,execute,reference,k,v,reference,entry,k,v,entry,entries,entries,return,execute,reference,entry
ConcurrentReferenceHashMap -> Task -> protected T execute(Reference<K, V> reference, Entry<K, V> entry, Entries entries);1352039846;Execute the task._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@param entries access to the underlying entries_@return the result of the task_@see #execute(Reference, Entry);protected T execute(Reference<K, V> reference, Entry<K, V> entry, Entries entries) {_			return execute(reference, entry)__		};execute,the,task,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,param,entries,access,to,the,underlying,entries,return,the,result,of,the,task,see,execute,reference,entry;protected,t,execute,reference,k,v,reference,entry,k,v,entry,entries,entries,return,execute,reference,entry
ConcurrentReferenceHashMap -> Task -> protected T execute(Reference<K, V> reference, Entry<K, V> entry, Entries entries);1355313310;Execute the task._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@param entries access to the underlying entries_@return the result of the task_@see #execute(Reference, Entry);protected T execute(Reference<K, V> reference, Entry<K, V> entry, Entries entries) {_			return execute(reference, entry)__		};execute,the,task,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,param,entries,access,to,the,underlying,entries,return,the,result,of,the,task,see,execute,reference,entry;protected,t,execute,reference,k,v,reference,entry,k,v,entry,entries,entries,return,execute,reference,entry
ConcurrentReferenceHashMap -> Task -> protected T execute(Reference<K, V> reference, Entry<K, V> entry, Entries entries);1356735495;Execute the task._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@param entries access to the underlying entries_@return the result of the task_@see #execute(Reference, Entry);protected T execute(Reference<K, V> reference, Entry<K, V> entry, Entries entries) {_			return execute(reference, entry)__		};execute,the,task,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,param,entries,access,to,the,underlying,entries,return,the,result,of,the,task,see,execute,reference,entry;protected,t,execute,reference,k,v,reference,entry,k,v,entry,entries,entries,return,execute,reference,entry
ConcurrentReferenceHashMap -> Task -> protected T execute(Reference<K, V> reference, Entry<K, V> entry, Entries entries);1357119239;Execute the task._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@param entries access to the underlying entries_@return the result of the task_@see #execute(Reference, Entry);protected T execute(Reference<K, V> reference, Entry<K, V> entry, Entries entries) {_			return execute(reference, entry)__		};execute,the,task,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,param,entries,access,to,the,underlying,entries,return,the,result,of,the,task,see,execute,reference,entry;protected,t,execute,reference,k,v,reference,entry,k,v,entry,entries,entries,return,execute,reference,entry
ConcurrentReferenceHashMap -> Task -> protected T execute(Reference<K, V> reference, Entry<K, V> entry, Entries entries);1368482696;Execute the task._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@param entries access to the underlying entries_@return the result of the task_@see #execute(Reference, Entry);protected T execute(Reference<K, V> reference, Entry<K, V> entry, Entries entries) {_			return execute(reference, entry)__		};execute,the,task,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,param,entries,access,to,the,underlying,entries,return,the,result,of,the,task,see,execute,reference,entry;protected,t,execute,reference,k,v,reference,entry,k,v,entry,entries,entries,return,execute,reference,entry
ConcurrentReferenceHashMap -> Task -> protected T execute(Reference<K, V> reference, Entry<K, V> entry, Entries entries);1383090835;Execute the task._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@param entries access to the underlying entries_@return the result of the task_@see #execute(Reference, Entry);protected T execute(Reference<K, V> reference, Entry<K, V> entry, Entries entries) {_			return execute(reference, entry)__		};execute,the,task,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,param,entries,access,to,the,underlying,entries,return,the,result,of,the,task,see,execute,reference,entry;protected,t,execute,reference,k,v,reference,entry,k,v,entry,entries,entries,return,execute,reference,entry
ConcurrentReferenceHashMap -> Task -> protected T execute(Reference<K, V> reference, Entry<K, V> entry, Entries entries);1383178438;Execute the task._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@param entries access to the underlying entries_@return the result of the task_@see #execute(Reference, Entry);protected T execute(Reference<K, V> reference, Entry<K, V> entry, Entries entries) {_			return execute(reference, entry)__		};execute,the,task,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,param,entries,access,to,the,underlying,entries,return,the,result,of,the,task,see,execute,reference,entry;protected,t,execute,reference,k,v,reference,entry,k,v,entry,entries,entries,return,execute,reference,entry
ConcurrentReferenceHashMap -> Task -> protected T execute(Reference<K, V> reference, Entry<K, V> entry, Entries entries);1390260938;Execute the task._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@param entries access to the underlying entries_@return the result of the task_@see #execute(Reference, Entry);protected T execute(Reference<K, V> reference, Entry<K, V> entry, Entries entries) {_			return execute(reference, entry)__		};execute,the,task,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,param,entries,access,to,the,underlying,entries,return,the,result,of,the,task,see,execute,reference,entry;protected,t,execute,reference,k,v,reference,entry,k,v,entry,entries,entries,return,execute,reference,entry
ConcurrentReferenceHashMap -> Task -> protected T execute(Reference<K, V> reference, Entry<K, V> entry, Entries entries);1391715359;Execute the task._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@param entries access to the underlying entries_@return the result of the task_@see #execute(Reference, Entry);protected T execute(Reference<K, V> reference, Entry<K, V> entry, Entries entries) {_			return execute(reference, entry)__		};execute,the,task,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,param,entries,access,to,the,underlying,entries,return,the,result,of,the,task,see,execute,reference,entry;protected,t,execute,reference,k,v,reference,entry,k,v,entry,entries,entries,return,execute,reference,entry
ConcurrentReferenceHashMap -> Task -> protected T execute(Reference<K, V> reference, Entry<K, V> entry, Entries entries);1392765030;Execute the task._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@param entries access to the underlying entries_@return the result of the task_@see #execute(Reference, Entry);protected T execute(Reference<K, V> reference, Entry<K, V> entry, Entries entries) {_			return execute(reference, entry)__		};execute,the,task,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,param,entries,access,to,the,underlying,entries,return,the,result,of,the,task,see,execute,reference,entry;protected,t,execute,reference,k,v,reference,entry,k,v,entry,entries,entries,return,execute,reference,entry
ConcurrentReferenceHashMap -> Task -> protected T execute(Reference<K, V> reference, Entry<K, V> entry, Entries entries);1398175099;Execute the task._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@param entries access to the underlying entries_@return the result of the task_@see #execute(Reference, Entry);protected T execute(Reference<K, V> reference, Entry<K, V> entry, Entries entries) {_			return execute(reference, entry)__		};execute,the,task,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,param,entries,access,to,the,underlying,entries,return,the,result,of,the,task,see,execute,reference,entry;protected,t,execute,reference,k,v,reference,entry,k,v,entry,entries,entries,return,execute,reference,entry
ConcurrentReferenceHashMap -> Task -> protected T execute(Reference<K, V> reference, Entry<K, V> entry, Entries entries);1404132943;Execute the task._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@param entries access to the underlying entries_@return the result of the task_@see #execute(Reference, Entry);protected T execute(Reference<K, V> reference, Entry<K, V> entry, Entries entries) {_			return execute(reference, entry)__		};execute,the,task,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,param,entries,access,to,the,underlying,entries,return,the,result,of,the,task,see,execute,reference,entry;protected,t,execute,reference,k,v,reference,entry,k,v,entry,entries,entries,return,execute,reference,entry
ConcurrentReferenceHashMap -> Task -> protected T execute(Reference<K, V> reference, Entry<K, V> entry, Entries entries);1427240641;Execute the task._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@param entries access to the underlying entries_@return the result of the task_@see #execute(Reference, Entry);protected T execute(Reference<K, V> reference, Entry<K, V> entry, Entries entries) {_			return execute(reference, entry)__		};execute,the,task,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,param,entries,access,to,the,underlying,entries,return,the,result,of,the,task,see,execute,reference,entry;protected,t,execute,reference,k,v,reference,entry,k,v,entry,entries,entries,return,execute,reference,entry
ConcurrentReferenceHashMap -> Task -> protected T execute(Reference<K, V> reference, Entry<K, V> entry, Entries entries);1459795890;Execute the task._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@param entries access to the underlying entries_@return the result of the task_@see #execute(Reference, Entry);protected T execute(Reference<K, V> reference, Entry<K, V> entry, Entries entries) {_			return execute(reference, entry)__		};execute,the,task,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,param,entries,access,to,the,underlying,entries,return,the,result,of,the,task,see,execute,reference,entry;protected,t,execute,reference,k,v,reference,entry,k,v,entry,entries,entries,return,execute,reference,entry
ConcurrentReferenceHashMap -> Task -> protected T execute(Reference<K, V> reference, Entry<K, V> entry, Entries entries);1467730834;Execute the task._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@param entries access to the underlying entries_@return the result of the task_@see #execute(Reference, Entry);protected T execute(Reference<K, V> reference, Entry<K, V> entry, Entries entries) {_			return execute(reference, entry)__		};execute,the,task,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,param,entries,access,to,the,underlying,entries,return,the,result,of,the,task,see,execute,reference,entry;protected,t,execute,reference,k,v,reference,entry,k,v,entry,entries,entries,return,execute,reference,entry
ConcurrentReferenceHashMap -> Task -> protected T execute(Reference<K, V> reference, Entry<K, V> entry, Entries entries);1485810955;Execute the task._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@param entries access to the underlying entries_@return the result of the task_@see #execute(Reference, Entry);protected T execute(Reference<K, V> reference, Entry<K, V> entry, Entries entries) {_			return execute(reference, entry)__		};execute,the,task,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,param,entries,access,to,the,underlying,entries,return,the,result,of,the,task,see,execute,reference,entry;protected,t,execute,reference,k,v,reference,entry,k,v,entry,entries,entries,return,execute,reference,entry
ConcurrentReferenceHashMap -> public void purgeUnreferencedEntries();1392765030;Remove any entries that have been garbage collected and are no longer referenced._Under normal circumstances garbage collected entries are automatically purged as_items are added or removed from the Map. This method can be used to force a purge,_and is useful when the Map is read frequently but updated less often.;public void purgeUnreferencedEntries() {_		for (Segment segment : this.segments) {_			segment.restructureIfNecessary(false)__		}_	};remove,any,entries,that,have,been,garbage,collected,and,are,no,longer,referenced,under,normal,circumstances,garbage,collected,entries,are,automatically,purged,as,items,are,added,or,removed,from,the,map,this,method,can,be,used,to,force,a,purge,and,is,useful,when,the,map,is,read,frequently,but,updated,less,often;public,void,purge,unreferenced,entries,for,segment,segment,this,segments,segment,restructure,if,necessary,false
ConcurrentReferenceHashMap -> public void purgeUnreferencedEntries();1398175099;Remove any entries that have been garbage collected and are no longer referenced._Under normal circumstances garbage collected entries are automatically purged as_items are added or removed from the Map. This method can be used to force a purge,_and is useful when the Map is read frequently but updated less often.;public void purgeUnreferencedEntries() {_		for (Segment segment : this.segments) {_			segment.restructureIfNecessary(false)__		}_	};remove,any,entries,that,have,been,garbage,collected,and,are,no,longer,referenced,under,normal,circumstances,garbage,collected,entries,are,automatically,purged,as,items,are,added,or,removed,from,the,map,this,method,can,be,used,to,force,a,purge,and,is,useful,when,the,map,is,read,frequently,but,updated,less,often;public,void,purge,unreferenced,entries,for,segment,segment,this,segments,segment,restructure,if,necessary,false
ConcurrentReferenceHashMap -> public void purgeUnreferencedEntries();1404132943;Remove any entries that have been garbage collected and are no longer referenced._Under normal circumstances garbage collected entries are automatically purged as_items are added or removed from the Map. This method can be used to force a purge,_and is useful when the Map is read frequently but updated less often.;public void purgeUnreferencedEntries() {_		for (Segment segment : this.segments) {_			segment.restructureIfNecessary(false)__		}_	};remove,any,entries,that,have,been,garbage,collected,and,are,no,longer,referenced,under,normal,circumstances,garbage,collected,entries,are,automatically,purged,as,items,are,added,or,removed,from,the,map,this,method,can,be,used,to,force,a,purge,and,is,useful,when,the,map,is,read,frequently,but,updated,less,often;public,void,purge,unreferenced,entries,for,segment,segment,this,segments,segment,restructure,if,necessary,false
ConcurrentReferenceHashMap -> public void purgeUnreferencedEntries();1427240641;Remove any entries that have been garbage collected and are no longer referenced._Under normal circumstances garbage collected entries are automatically purged as_items are added or removed from the Map. This method can be used to force a purge,_and is useful when the Map is read frequently but updated less often.;public void purgeUnreferencedEntries() {_		for (Segment segment : this.segments) {_			segment.restructureIfNecessary(false)__		}_	};remove,any,entries,that,have,been,garbage,collected,and,are,no,longer,referenced,under,normal,circumstances,garbage,collected,entries,are,automatically,purged,as,items,are,added,or,removed,from,the,map,this,method,can,be,used,to,force,a,purge,and,is,useful,when,the,map,is,read,frequently,but,updated,less,often;public,void,purge,unreferenced,entries,for,segment,segment,this,segments,segment,restructure,if,necessary,false
ConcurrentReferenceHashMap -> public void purgeUnreferencedEntries();1459795890;Remove any entries that have been garbage collected and are no longer referenced._Under normal circumstances garbage collected entries are automatically purged as_items are added or removed from the Map. This method can be used to force a purge,_and is useful when the Map is read frequently but updated less often.;public void purgeUnreferencedEntries() {_		for (Segment segment : this.segments) {_			segment.restructureIfNecessary(false)__		}_	};remove,any,entries,that,have,been,garbage,collected,and,are,no,longer,referenced,under,normal,circumstances,garbage,collected,entries,are,automatically,purged,as,items,are,added,or,removed,from,the,map,this,method,can,be,used,to,force,a,purge,and,is,useful,when,the,map,is,read,frequently,but,updated,less,often;public,void,purge,unreferenced,entries,for,segment,segment,this,segments,segment,restructure,if,necessary,false
ConcurrentReferenceHashMap -> public void purgeUnreferencedEntries();1467730834;Remove any entries that have been garbage collected and are no longer referenced._Under normal circumstances garbage collected entries are automatically purged as_items are added or removed from the Map. This method can be used to force a purge,_and is useful when the Map is read frequently but updated less often.;public void purgeUnreferencedEntries() {_		for (Segment segment : this.segments) {_			segment.restructureIfNecessary(false)__		}_	};remove,any,entries,that,have,been,garbage,collected,and,are,no,longer,referenced,under,normal,circumstances,garbage,collected,entries,are,automatically,purged,as,items,are,added,or,removed,from,the,map,this,method,can,be,used,to,force,a,purge,and,is,useful,when,the,map,is,read,frequently,but,updated,less,often;public,void,purge,unreferenced,entries,for,segment,segment,this,segments,segment,restructure,if,necessary,false
ConcurrentReferenceHashMap -> public void purgeUnreferencedEntries();1485810955;Remove any entries that have been garbage collected and are no longer referenced._Under normal circumstances garbage collected entries are automatically purged as_items are added or removed from the Map. This method can be used to force a purge,_and is useful when the Map is read frequently but updated less often.;public void purgeUnreferencedEntries() {_		for (Segment segment : this.segments) {_			segment.restructureIfNecessary(false)__		}_	};remove,any,entries,that,have,been,garbage,collected,and,are,no,longer,referenced,under,normal,circumstances,garbage,collected,entries,are,automatically,purged,as,items,are,added,or,removed,from,the,map,this,method,can,be,used,to,force,a,purge,and,is,useful,when,the,map,is,read,frequently,but,updated,less,often;public,void,purge,unreferenced,entries,for,segment,segment,this,segments,segment,restructure,if,necessary,false
ConcurrentReferenceHashMap -> public void purgeUnreferencedEntries();1495868221;Remove any entries that have been garbage collected and are no longer referenced._Under normal circumstances garbage collected entries are automatically purged as_items are added or removed from the Map. This method can be used to force a purge,_and is useful when the Map is read frequently but updated less often.;public void purgeUnreferencedEntries() {_		for (Segment segment : this.segments) {_			segment.restructureIfNecessary(false)__		}_	};remove,any,entries,that,have,been,garbage,collected,and,are,no,longer,referenced,under,normal,circumstances,garbage,collected,entries,are,automatically,purged,as,items,are,added,or,removed,from,the,map,this,method,can,be,used,to,force,a,purge,and,is,useful,when,the,map,is,read,frequently,but,updated,less,often;public,void,purge,unreferenced,entries,for,segment,segment,this,segments,segment,restructure,if,necessary,false
ConcurrentReferenceHashMap -> public void purgeUnreferencedEntries();1496242568;Remove any entries that have been garbage collected and are no longer referenced._Under normal circumstances garbage collected entries are automatically purged as_items are added or removed from the Map. This method can be used to force a purge,_and is useful when the Map is read frequently but updated less often.;public void purgeUnreferencedEntries() {_		for (Segment segment : this.segments) {_			segment.restructureIfNecessary(false)__		}_	};remove,any,entries,that,have,been,garbage,collected,and,are,no,longer,referenced,under,normal,circumstances,garbage,collected,entries,are,automatically,purged,as,items,are,added,or,removed,from,the,map,this,method,can,be,used,to,force,a,purge,and,is,useful,when,the,map,is,read,frequently,but,updated,less,often;public,void,purge,unreferenced,entries,for,segment,segment,this,segments,segment,restructure,if,necessary,false
ConcurrentReferenceHashMap -> public void purgeUnreferencedEntries();1496837955;Remove any entries that have been garbage collected and are no longer referenced._Under normal circumstances garbage collected entries are automatically purged as_items are added or removed from the Map. This method can be used to force a purge,_and is useful when the Map is read frequently but updated less often.;public void purgeUnreferencedEntries() {_		for (Segment segment : this.segments) {_			segment.restructureIfNecessary(false)__		}_	};remove,any,entries,that,have,been,garbage,collected,and,are,no,longer,referenced,under,normal,circumstances,garbage,collected,entries,are,automatically,purged,as,items,are,added,or,removed,from,the,map,this,method,can,be,used,to,force,a,purge,and,is,useful,when,the,map,is,read,frequently,but,updated,less,often;public,void,purge,unreferenced,entries,for,segment,segment,this,segments,segment,restructure,if,necessary,false
ConcurrentReferenceHashMap -> public void purgeUnreferencedEntries();1498780456;Remove any entries that have been garbage collected and are no longer referenced._Under normal circumstances garbage collected entries are automatically purged as_items are added or removed from the Map. This method can be used to force a purge,_and is useful when the Map is read frequently but updated less often.;public void purgeUnreferencedEntries() {_		for (Segment segment : this.segments) {_			segment.restructureIfNecessary(false)__		}_	};remove,any,entries,that,have,been,garbage,collected,and,are,no,longer,referenced,under,normal,circumstances,garbage,collected,entries,are,automatically,purged,as,items,are,added,or,removed,from,the,map,this,method,can,be,used,to,force,a,purge,and,is,useful,when,the,map,is,read,frequently,but,updated,less,often;public,void,purge,unreferenced,entries,for,segment,segment,this,segments,segment,restructure,if,necessary,false
ConcurrentReferenceHashMap -> public void purgeUnreferencedEntries();1502974979;Remove any entries that have been garbage collected and are no longer referenced._Under normal circumstances garbage collected entries are automatically purged as_items are added or removed from the Map. This method can be used to force a purge,_and is useful when the Map is read frequently but updated less often.;public void purgeUnreferencedEntries() {_		for (Segment segment : this.segments) {_			segment.restructureIfNecessary(false)__		}_	};remove,any,entries,that,have,been,garbage,collected,and,are,no,longer,referenced,under,normal,circumstances,garbage,collected,entries,are,automatically,purged,as,items,are,added,or,removed,from,the,map,this,method,can,be,used,to,force,a,purge,and,is,useful,when,the,map,is,read,frequently,but,updated,less,often;public,void,purge,unreferenced,entries,for,segment,segment,this,segments,segment,restructure,if,necessary,false
ConcurrentReferenceHashMap -> public void purgeUnreferencedEntries();1506097334;Remove any entries that have been garbage collected and are no longer referenced._Under normal circumstances garbage collected entries are automatically purged as_items are added or removed from the Map. This method can be used to force a purge,_and is useful when the Map is read frequently but updated less often.;public void purgeUnreferencedEntries() {_		for (Segment segment : this.segments) {_			segment.restructureIfNecessary(false)__		}_	};remove,any,entries,that,have,been,garbage,collected,and,are,no,longer,referenced,under,normal,circumstances,garbage,collected,entries,are,automatically,purged,as,items,are,added,or,removed,from,the,map,this,method,can,be,used,to,force,a,purge,and,is,useful,when,the,map,is,read,frequently,but,updated,less,often;public,void,purge,unreferenced,entries,for,segment,segment,this,segments,segment,restructure,if,necessary,false
ConcurrentReferenceHashMap -> public void purgeUnreferencedEntries();1521044224;Remove any entries that have been garbage collected and are no longer referenced._Under normal circumstances garbage collected entries are automatically purged as_items are added or removed from the Map. This method can be used to force a purge,_and is useful when the Map is read frequently but updated less often.;public void purgeUnreferencedEntries() {_		for (Segment segment : this.segments) {_			segment.restructureIfNecessary(false)__		}_	};remove,any,entries,that,have,been,garbage,collected,and,are,no,longer,referenced,under,normal,circumstances,garbage,collected,entries,are,automatically,purged,as,items,are,added,or,removed,from,the,map,this,method,can,be,used,to,force,a,purge,and,is,useful,when,the,map,is,read,frequently,but,updated,less,often;public,void,purge,unreferenced,entries,for,segment,segment,this,segments,segment,restructure,if,necessary,false
ConcurrentReferenceHashMap -> public void purgeUnreferencedEntries();1530174524;Remove any entries that have been garbage collected and are no longer referenced._Under normal circumstances garbage collected entries are automatically purged as_items are added or removed from the Map. This method can be used to force a purge,_and is useful when the Map is read frequently but updated less often.;public void purgeUnreferencedEntries() {_		for (Segment segment : this.segments) {_			segment.restructureIfNecessary(false)__		}_	};remove,any,entries,that,have,been,garbage,collected,and,are,no,longer,referenced,under,normal,circumstances,garbage,collected,entries,are,automatically,purged,as,items,are,added,or,removed,from,the,map,this,method,can,be,used,to,force,a,purge,and,is,useful,when,the,map,is,read,frequently,but,updated,less,often;public,void,purge,unreferenced,entries,for,segment,segment,this,segments,segment,restructure,if,necessary,false
ConcurrentReferenceHashMap -> public void purgeUnreferencedEntries();1530190293;Remove any entries that have been garbage collected and are no longer referenced._Under normal circumstances garbage collected entries are automatically purged as_items are added or removed from the Map. This method can be used to force a purge,_and is useful when the Map is read frequently but updated less often.;public void purgeUnreferencedEntries() {_		for (Segment segment : this.segments) {_			segment.restructureIfNecessary(false)__		}_	};remove,any,entries,that,have,been,garbage,collected,and,are,no,longer,referenced,under,normal,circumstances,garbage,collected,entries,are,automatically,purged,as,items,are,added,or,removed,from,the,map,this,method,can,be,used,to,force,a,purge,and,is,useful,when,the,map,is,read,frequently,but,updated,less,often;public,void,purge,unreferenced,entries,for,segment,segment,this,segments,segment,restructure,if,necessary,false
ConcurrentReferenceHashMap -> public void purgeUnreferencedEntries();1530563577;Remove any entries that have been garbage collected and are no longer referenced._Under normal circumstances garbage collected entries are automatically purged as_items are added or removed from the Map. This method can be used to force a purge,_and is useful when the Map is read frequently but updated less often.;public void purgeUnreferencedEntries() {_		for (Segment segment : this.segments) {_			segment.restructureIfNecessary(false)__		}_	};remove,any,entries,that,have,been,garbage,collected,and,are,no,longer,referenced,under,normal,circumstances,garbage,collected,entries,are,automatically,purged,as,items,are,added,or,removed,from,the,map,this,method,can,be,used,to,force,a,purge,and,is,useful,when,the,map,is,read,frequently,but,updated,less,often;public,void,purge,unreferenced,entries,for,segment,segment,this,segments,segment,restructure,if,necessary,false
ConcurrentReferenceHashMap -> public void purgeUnreferencedEntries();1531136363;Remove any entries that have been garbage collected and are no longer referenced._Under normal circumstances garbage collected entries are automatically purged as_items are added or removed from the Map. This method can be used to force a purge,_and is useful when the Map is read frequently but updated less often.;public void purgeUnreferencedEntries() {_		for (Segment segment : this.segments) {_			segment.restructureIfNecessary(false)__		}_	};remove,any,entries,that,have,been,garbage,collected,and,are,no,longer,referenced,under,normal,circumstances,garbage,collected,entries,are,automatically,purged,as,items,are,added,or,removed,from,the,map,this,method,can,be,used,to,force,a,purge,and,is,useful,when,the,map,is,read,frequently,but,updated,less,often;public,void,purge,unreferenced,entries,for,segment,segment,this,segments,segment,restructure,if,necessary,false
ConcurrentReferenceHashMap -> public void purgeUnreferencedEntries();1531139295;Remove any entries that have been garbage collected and are no longer referenced._Under normal circumstances garbage collected entries are automatically purged as_items are added or removed from the Map. This method can be used to force a purge,_and is useful when the Map is read frequently but updated less often.;public void purgeUnreferencedEntries() {_		for (Segment segment : this.segments) {_			segment.restructureIfNecessary(false)__		}_	};remove,any,entries,that,have,been,garbage,collected,and,are,no,longer,referenced,under,normal,circumstances,garbage,collected,entries,are,automatically,purged,as,items,are,added,or,removed,from,the,map,this,method,can,be,used,to,force,a,purge,and,is,useful,when,the,map,is,read,frequently,but,updated,less,often;public,void,purge,unreferenced,entries,for,segment,segment,this,segments,segment,restructure,if,necessary,false
ConcurrentReferenceHashMap -> public void purgeUnreferencedEntries();1544716668;Remove any entries that have been garbage collected and are no longer referenced._Under normal circumstances garbage collected entries are automatically purged as_items are added or removed from the Map. This method can be used to force a purge,_and is useful when the Map is read frequently but updated less often.;public void purgeUnreferencedEntries() {_		for (Segment segment : this.segments) {_			segment.restructureIfNecessary(false)__		}_	};remove,any,entries,that,have,been,garbage,collected,and,are,no,longer,referenced,under,normal,circumstances,garbage,collected,entries,are,automatically,purged,as,items,are,added,or,removed,from,the,map,this,method,can,be,used,to,force,a,purge,and,is,useful,when,the,map,is,read,frequently,but,updated,less,often;public,void,purge,unreferenced,entries,for,segment,segment,this,segments,segment,restructure,if,necessary,false
ConcurrentReferenceHashMap -> public void purgeUnreferencedEntries();1549318940;Remove any entries that have been garbage collected and are no longer referenced._Under normal circumstances garbage collected entries are automatically purged as_items are added or removed from the Map. This method can be used to force a purge,_and is useful when the Map is read frequently but updated less often.;public void purgeUnreferencedEntries() {_		for (Segment segment : this.segments) {_			segment.restructureIfNecessary(false)__		}_	};remove,any,entries,that,have,been,garbage,collected,and,are,no,longer,referenced,under,normal,circumstances,garbage,collected,entries,are,automatically,purged,as,items,are,added,or,removed,from,the,map,this,method,can,be,used,to,force,a,purge,and,is,useful,when,the,map,is,read,frequently,but,updated,less,often;public,void,purge,unreferenced,entries,for,segment,segment,this,segments,segment,restructure,if,necessary,false
ConcurrentReferenceHashMap -> public void purgeUnreferencedEntries();1549321822;Remove any entries that have been garbage collected and are no longer referenced._Under normal circumstances garbage collected entries are automatically purged as_items are added or removed from the Map. This method can be used to force a purge,_and is useful when the Map is read frequently but updated less often.;public void purgeUnreferencedEntries() {_		for (Segment segment : this.segments) {_			segment.restructureIfNecessary(false)__		}_	};remove,any,entries,that,have,been,garbage,collected,and,are,no,longer,referenced,under,normal,circumstances,garbage,collected,entries,are,automatically,purged,as,items,are,added,or,removed,from,the,map,this,method,can,be,used,to,force,a,purge,and,is,useful,when,the,map,is,read,frequently,but,updated,less,often;public,void,purge,unreferenced,entries,for,segment,segment,this,segments,segment,restructure,if,necessary,false
ConcurrentReferenceHashMap -> public void purgeUnreferencedEntries();1550237263;Remove any entries that have been garbage collected and are no longer referenced._Under normal circumstances garbage collected entries are automatically purged as_items are added or removed from the Map. This method can be used to force a purge,_and is useful when the Map is read frequently but updated less often.;public void purgeUnreferencedEntries() {_		for (Segment segment : this.segments) {_			segment.restructureIfNecessary(false)__		}_	};remove,any,entries,that,have,been,garbage,collected,and,are,no,longer,referenced,under,normal,circumstances,garbage,collected,entries,are,automatically,purged,as,items,are,added,or,removed,from,the,map,this,method,can,be,used,to,force,a,purge,and,is,useful,when,the,map,is,read,frequently,but,updated,less,often;public,void,purge,unreferenced,entries,for,segment,segment,this,segments,segment,restructure,if,necessary,false
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType);1391715359;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param referenceType the reference type used for entries (soft or weak);public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, referenceType)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;public,concurrent,reference,hash,map,int,initial,capacity,reference,type,reference,type,this,initial,capacity,reference,type
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType);1392765030;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param referenceType the reference type used for entries (soft or weak);public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, referenceType)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;public,concurrent,reference,hash,map,int,initial,capacity,reference,type,reference,type,this,initial,capacity,reference,type
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType);1398175099;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param referenceType the reference type used for entries (soft or weak);public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, referenceType)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;public,concurrent,reference,hash,map,int,initial,capacity,reference,type,reference,type,this,initial,capacity,reference,type
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType);1404132943;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param referenceType the reference type used for entries (soft or weak);public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, referenceType)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;public,concurrent,reference,hash,map,int,initial,capacity,reference,type,reference,type,this,initial,capacity,reference,type
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType);1427240641;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param referenceType the reference type used for entries (soft or weak);public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, referenceType)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;public,concurrent,reference,hash,map,int,initial,capacity,reference,type,reference,type,this,initial,capacity,reference,type
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType);1459795890;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param referenceType the reference type used for entries (soft or weak);public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, referenceType)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;public,concurrent,reference,hash,map,int,initial,capacity,reference,type,reference,type,this,initial,capacity,reference,type
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType);1467730834;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param referenceType the reference type used for entries (soft or weak);public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, referenceType)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;public,concurrent,reference,hash,map,int,initial,capacity,reference,type,reference,type,this,initial,capacity,reference,type
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType);1485810955;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param referenceType the reference type used for entries (soft or weak);public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, referenceType)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;public,concurrent,reference,hash,map,int,initial,capacity,reference,type,reference,type,this,initial,capacity,reference,type
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType);1495868221;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param referenceType the reference type used for entries (soft or weak);public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, referenceType)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;public,concurrent,reference,hash,map,int,initial,capacity,reference,type,reference,type,this,initial,capacity,reference,type
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType);1496242568;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param referenceType the reference type used for entries (soft or weak);public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, referenceType)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;public,concurrent,reference,hash,map,int,initial,capacity,reference,type,reference,type,this,initial,capacity,reference,type
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType);1496837955;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param referenceType the reference type used for entries (soft or weak);public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, referenceType)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;public,concurrent,reference,hash,map,int,initial,capacity,reference,type,reference,type,this,initial,capacity,reference,type
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType);1498780456;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param referenceType the reference type used for entries (soft or weak);public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, referenceType)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;public,concurrent,reference,hash,map,int,initial,capacity,reference,type,reference,type,this,initial,capacity,reference,type
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType);1502974979;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param referenceType the reference type used for entries (soft or weak);public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, referenceType)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;public,concurrent,reference,hash,map,int,initial,capacity,reference,type,reference,type,this,initial,capacity,reference,type
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType);1506097334;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param referenceType the reference type used for entries (soft or weak);public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, referenceType)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;public,concurrent,reference,hash,map,int,initial,capacity,reference,type,reference,type,this,initial,capacity,reference,type
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType);1521044224;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param referenceType the reference type used for entries (soft or weak);public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, referenceType)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;public,concurrent,reference,hash,map,int,initial,capacity,reference,type,reference,type,this,initial,capacity,reference,type
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType);1530174524;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param referenceType the reference type used for entries (soft or weak);public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, referenceType)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;public,concurrent,reference,hash,map,int,initial,capacity,reference,type,reference,type,this,initial,capacity,reference,type
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType);1530190293;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param referenceType the reference type used for entries (soft or weak);public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, referenceType)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;public,concurrent,reference,hash,map,int,initial,capacity,reference,type,reference,type,this,initial,capacity,reference,type
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType);1530563577;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param referenceType the reference type used for entries (soft or weak);public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, referenceType)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;public,concurrent,reference,hash,map,int,initial,capacity,reference,type,reference,type,this,initial,capacity,reference,type
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType);1531136363;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param referenceType the reference type used for entries (soft or weak);public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, referenceType)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;public,concurrent,reference,hash,map,int,initial,capacity,reference,type,reference,type,this,initial,capacity,reference,type
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType);1531139295;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param referenceType the reference type used for entries (soft or weak);public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, referenceType)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;public,concurrent,reference,hash,map,int,initial,capacity,reference,type,reference,type,this,initial,capacity,reference,type
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType);1544716668;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param referenceType the reference type used for entries (soft or weak);public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, referenceType)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;public,concurrent,reference,hash,map,int,initial,capacity,reference,type,reference,type,this,initial,capacity,reference,type
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType);1549318940;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param referenceType the reference type used for entries (soft or weak);public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, referenceType)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;public,concurrent,reference,hash,map,int,initial,capacity,reference,type,reference,type,this,initial,capacity,reference,type
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType);1549321822;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param referenceType the reference type used for entries (soft or weak);public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, referenceType)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;public,concurrent,reference,hash,map,int,initial,capacity,reference,type,reference,type,this,initial,capacity,reference,type
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType);1550237263;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param referenceType the reference type used for entries (soft or weak);public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, referenceType)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,reference,type,the,reference,type,used,for,entries,soft,or,weak;public,concurrent,reference,hash,map,int,initial,capacity,reference,type,reference,type,this,initial,capacity,reference,type
ConcurrentReferenceHashMap -> Entries -> public abstract void add(@Nullable V value)_;1521044224;Add a new entry with the specified value._@param value the value to add;public abstract void add(@Nullable V value)_;add,a,new,entry,with,the,specified,value,param,value,the,value,to,add;public,abstract,void,add,nullable,v,value
ConcurrentReferenceHashMap -> Entries -> public abstract void add(@Nullable V value)_;1530174524;Add a new entry with the specified value._@param value the value to add;public abstract void add(@Nullable V value)_;add,a,new,entry,with,the,specified,value,param,value,the,value,to,add;public,abstract,void,add,nullable,v,value
ConcurrentReferenceHashMap -> Entries -> public abstract void add(@Nullable V value)_;1530190293;Add a new entry with the specified value._@param value the value to add;public abstract void add(@Nullable V value)_;add,a,new,entry,with,the,specified,value,param,value,the,value,to,add;public,abstract,void,add,nullable,v,value
ConcurrentReferenceHashMap -> Entries -> public abstract void add(@Nullable V value)_;1530563577;Add a new entry with the specified value._@param value the value to add;public abstract void add(@Nullable V value)_;add,a,new,entry,with,the,specified,value,param,value,the,value,to,add;public,abstract,void,add,nullable,v,value
ConcurrentReferenceHashMap -> Entries -> public abstract void add(@Nullable V value)_;1531136363;Add a new entry with the specified value._@param value the value to add;public abstract void add(@Nullable V value)_;add,a,new,entry,with,the,specified,value,param,value,the,value,to,add;public,abstract,void,add,nullable,v,value
ConcurrentReferenceHashMap -> Entries -> public abstract void add(@Nullable V value)_;1531139295;Add a new entry with the specified value._@param value the value to add;public abstract void add(@Nullable V value)_;add,a,new,entry,with,the,specified,value,param,value,the,value,to,add;public,abstract,void,add,nullable,v,value
ConcurrentReferenceHashMap -> Entries -> public abstract void add(@Nullable V value)_;1544716668;Add a new entry with the specified value._@param value the value to add;public abstract void add(@Nullable V value)_;add,a,new,entry,with,the,specified,value,param,value,the,value,to,add;public,abstract,void,add,nullable,v,value
ConcurrentReferenceHashMap -> Entries -> public abstract void add(@Nullable V value)_;1549318940;Add a new entry with the specified value._@param value the value to add;public abstract void add(@Nullable V value)_;add,a,new,entry,with,the,specified,value,param,value,the,value,to,add;public,abstract,void,add,nullable,v,value
ConcurrentReferenceHashMap -> Entries -> public abstract void add(@Nullable V value)_;1549321822;Add a new entry with the specified value._@param value the value to add;public abstract void add(@Nullable V value)_;add,a,new,entry,with,the,specified,value,param,value,the,value,to,add;public,abstract,void,add,nullable,v,value
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap();1351982790;Create a new {@link ConcurrentReferenceHashMap} instance.;public ConcurrentReferenceHashMap() {_		this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL,_				DEFAULT_REFERENCE_TYPE)__	};create,a,new,link,concurrent,reference,hash,map,instance;public,concurrent,reference,hash,map,this
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap();1352039846;Create a new {@code ConcurrentReferenceHashMap} instance.;public ConcurrentReferenceHashMap() {_		this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL,_				DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance;public,concurrent,reference,hash,map,this
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap();1355313310;Create a new {@code ConcurrentReferenceHashMap} instance.;public ConcurrentReferenceHashMap() {_		this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL,_				DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance;public,concurrent,reference,hash,map,this
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap();1356735495;Create a new {@code ConcurrentReferenceHashMap} instance.;public ConcurrentReferenceHashMap() {_		this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL,_				DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance;public,concurrent,reference,hash,map,this
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap();1357119239;Create a new {@code ConcurrentReferenceHashMap} instance.;public ConcurrentReferenceHashMap() {_		this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL,_				DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance;public,concurrent,reference,hash,map,this
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap();1368482696;Create a new {@code ConcurrentReferenceHashMap} instance.;public ConcurrentReferenceHashMap() {_		this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL,_				DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance;public,concurrent,reference,hash,map,this
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap();1383090835;Create a new {@code ConcurrentReferenceHashMap} instance.;public ConcurrentReferenceHashMap() {_		this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance;public,concurrent,reference,hash,map,this
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap();1383178438;Create a new {@code ConcurrentReferenceHashMap} instance.;public ConcurrentReferenceHashMap() {_		this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance;public,concurrent,reference,hash,map,this
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap();1390260938;Create a new {@code ConcurrentReferenceHashMap} instance.;public ConcurrentReferenceHashMap() {_		this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance;public,concurrent,reference,hash,map,this
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap();1391715359;Create a new {@code ConcurrentReferenceHashMap} instance.;public ConcurrentReferenceHashMap() {_		this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance;public,concurrent,reference,hash,map,this
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap();1392765030;Create a new {@code ConcurrentReferenceHashMap} instance.;public ConcurrentReferenceHashMap() {_		this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance;public,concurrent,reference,hash,map,this
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap();1398175099;Create a new {@code ConcurrentReferenceHashMap} instance.;public ConcurrentReferenceHashMap() {_		this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance;public,concurrent,reference,hash,map,this
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap();1404132943;Create a new {@code ConcurrentReferenceHashMap} instance.;public ConcurrentReferenceHashMap() {_		this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance;public,concurrent,reference,hash,map,this
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap();1427240641;Create a new {@code ConcurrentReferenceHashMap} instance.;public ConcurrentReferenceHashMap() {_		this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance;public,concurrent,reference,hash,map,this
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap();1459795890;Create a new {@code ConcurrentReferenceHashMap} instance.;public ConcurrentReferenceHashMap() {_		this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance;public,concurrent,reference,hash,map,this
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap();1467730834;Create a new {@code ConcurrentReferenceHashMap} instance.;public ConcurrentReferenceHashMap() {_		this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance;public,concurrent,reference,hash,map,this
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap();1485810955;Create a new {@code ConcurrentReferenceHashMap} instance.;public ConcurrentReferenceHashMap() {_		this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance;public,concurrent,reference,hash,map,this
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap();1495868221;Create a new {@code ConcurrentReferenceHashMap} instance.;public ConcurrentReferenceHashMap() {_		this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance;public,concurrent,reference,hash,map,this
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap();1496242568;Create a new {@code ConcurrentReferenceHashMap} instance.;public ConcurrentReferenceHashMap() {_		this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance;public,concurrent,reference,hash,map,this
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap();1496837955;Create a new {@code ConcurrentReferenceHashMap} instance.;public ConcurrentReferenceHashMap() {_		this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance;public,concurrent,reference,hash,map,this
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap();1498780456;Create a new {@code ConcurrentReferenceHashMap} instance.;public ConcurrentReferenceHashMap() {_		this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance;public,concurrent,reference,hash,map,this
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap();1502974979;Create a new {@code ConcurrentReferenceHashMap} instance.;public ConcurrentReferenceHashMap() {_		this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance;public,concurrent,reference,hash,map,this
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap();1506097334;Create a new {@code ConcurrentReferenceHashMap} instance.;public ConcurrentReferenceHashMap() {_		this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance;public,concurrent,reference,hash,map,this
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap();1521044224;Create a new {@code ConcurrentReferenceHashMap} instance.;public ConcurrentReferenceHashMap() {_		this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance;public,concurrent,reference,hash,map,this
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap();1530174524;Create a new {@code ConcurrentReferenceHashMap} instance.;public ConcurrentReferenceHashMap() {_		this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance;public,concurrent,reference,hash,map,this
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap();1530190293;Create a new {@code ConcurrentReferenceHashMap} instance.;public ConcurrentReferenceHashMap() {_		this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance;public,concurrent,reference,hash,map,this
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap();1530563577;Create a new {@code ConcurrentReferenceHashMap} instance.;public ConcurrentReferenceHashMap() {_		this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance;public,concurrent,reference,hash,map,this
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap();1531136363;Create a new {@code ConcurrentReferenceHashMap} instance.;public ConcurrentReferenceHashMap() {_		this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance;public,concurrent,reference,hash,map,this
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap();1531139295;Create a new {@code ConcurrentReferenceHashMap} instance.;public ConcurrentReferenceHashMap() {_		this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance;public,concurrent,reference,hash,map,this
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap();1544716668;Create a new {@code ConcurrentReferenceHashMap} instance.;public ConcurrentReferenceHashMap() {_		this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance;public,concurrent,reference,hash,map,this
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap();1549318940;Create a new {@code ConcurrentReferenceHashMap} instance.;public ConcurrentReferenceHashMap() {_		this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance;public,concurrent,reference,hash,map,this
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap();1549321822;Create a new {@code ConcurrentReferenceHashMap} instance.;public ConcurrentReferenceHashMap() {_		this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance;public,concurrent,reference,hash,map,this
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap();1550237263;Create a new {@code ConcurrentReferenceHashMap} instance.;public ConcurrentReferenceHashMap() {_		this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance;public,concurrent,reference,hash,map,this
ConcurrentReferenceHashMap -> Reference -> int getHash()_;1351982790;Returns the hash for the reference._@return the hash;int getHash()_;returns,the,hash,for,the,reference,return,the,hash;int,get,hash
ConcurrentReferenceHashMap -> Reference -> int getHash()_;1352039846;Returns the hash for the reference._@return the hash;int getHash()_;returns,the,hash,for,the,reference,return,the,hash;int,get,hash
ConcurrentReferenceHashMap -> Reference -> int getHash()_;1355313310;Returns the hash for the reference._@return the hash;int getHash()_;returns,the,hash,for,the,reference,return,the,hash;int,get,hash
ConcurrentReferenceHashMap -> Reference -> int getHash()_;1356735495;Returns the hash for the reference._@return the hash;int getHash()_;returns,the,hash,for,the,reference,return,the,hash;int,get,hash
ConcurrentReferenceHashMap -> Reference -> int getHash()_;1357119239;Returns the hash for the reference._@return the hash;int getHash()_;returns,the,hash,for,the,reference,return,the,hash;int,get,hash
ConcurrentReferenceHashMap -> Reference -> int getHash()_;1368482696;Returns the hash for the reference._@return the hash;int getHash()_;returns,the,hash,for,the,reference,return,the,hash;int,get,hash
ConcurrentReferenceHashMap -> Reference -> int getHash()_;1383090835;Returns the hash for the reference._@return the hash;int getHash()_;returns,the,hash,for,the,reference,return,the,hash;int,get,hash
ConcurrentReferenceHashMap -> Reference -> int getHash()_;1383178438;Returns the hash for the reference._@return the hash;int getHash()_;returns,the,hash,for,the,reference,return,the,hash;int,get,hash
ConcurrentReferenceHashMap -> Reference -> int getHash()_;1390260938;Returns the hash for the reference._@return the hash;int getHash()_;returns,the,hash,for,the,reference,return,the,hash;int,get,hash
ConcurrentReferenceHashMap -> Reference -> int getHash()_;1391715359;Returns the hash for the reference._@return the hash;int getHash()_;returns,the,hash,for,the,reference,return,the,hash;int,get,hash
ConcurrentReferenceHashMap -> Reference -> int getHash()_;1392765030;Returns the hash for the reference._@return the hash;int getHash()_;returns,the,hash,for,the,reference,return,the,hash;int,get,hash
ConcurrentReferenceHashMap -> Reference -> int getHash()_;1398175099;Returns the hash for the reference._@return the hash;int getHash()_;returns,the,hash,for,the,reference,return,the,hash;int,get,hash
ConcurrentReferenceHashMap -> Reference -> int getHash()_;1404132943;Returns the hash for the reference._@return the hash;int getHash()_;returns,the,hash,for,the,reference,return,the,hash;int,get,hash
ConcurrentReferenceHashMap -> Reference -> int getHash()_;1427240641;Returns the hash for the reference._@return the hash;int getHash()_;returns,the,hash,for,the,reference,return,the,hash;int,get,hash
ConcurrentReferenceHashMap -> Reference -> int getHash()_;1459795890;Returns the hash for the reference._@return the hash;int getHash()_;returns,the,hash,for,the,reference,return,the,hash;int,get,hash
ConcurrentReferenceHashMap -> Reference -> int getHash()_;1467730834;Returns the hash for the reference._@return the hash;int getHash()_;returns,the,hash,for,the,reference,return,the,hash;int,get,hash
ConcurrentReferenceHashMap -> Reference -> int getHash()_;1485810955;Returns the hash for the reference._@return the hash;int getHash()_;returns,the,hash,for,the,reference,return,the,hash;int,get,hash
ConcurrentReferenceHashMap -> Reference -> int getHash()_;1495868221;Returns the hash for the reference._@return the hash;int getHash()_;returns,the,hash,for,the,reference,return,the,hash;int,get,hash
ConcurrentReferenceHashMap -> Reference -> int getHash()_;1496242568;Returns the hash for the reference._@return the hash;int getHash()_;returns,the,hash,for,the,reference,return,the,hash;int,get,hash
ConcurrentReferenceHashMap -> Reference -> int getHash()_;1496837955;Return the hash for the reference.;int getHash()_;return,the,hash,for,the,reference;int,get,hash
ConcurrentReferenceHashMap -> Reference -> int getHash()_;1498780456;Return the hash for the reference.;int getHash()_;return,the,hash,for,the,reference;int,get,hash
ConcurrentReferenceHashMap -> Reference -> int getHash()_;1502974979;Return the hash for the reference.;int getHash()_;return,the,hash,for,the,reference;int,get,hash
ConcurrentReferenceHashMap -> Reference -> int getHash()_;1506097334;Return the hash for the reference.;int getHash()_;return,the,hash,for,the,reference;int,get,hash
ConcurrentReferenceHashMap -> Reference -> int getHash()_;1521044224;Return the hash for the reference.;int getHash()_;return,the,hash,for,the,reference;int,get,hash
ConcurrentReferenceHashMap -> Reference -> int getHash()_;1530174524;Return the hash for the reference.;int getHash()_;return,the,hash,for,the,reference;int,get,hash
ConcurrentReferenceHashMap -> Reference -> int getHash()_;1530190293;Return the hash for the reference.;int getHash()_;return,the,hash,for,the,reference;int,get,hash
ConcurrentReferenceHashMap -> Reference -> int getHash()_;1530563577;Return the hash for the reference.;int getHash()_;return,the,hash,for,the,reference;int,get,hash
ConcurrentReferenceHashMap -> Reference -> int getHash()_;1531136363;Return the hash for the reference.;int getHash()_;return,the,hash,for,the,reference;int,get,hash
ConcurrentReferenceHashMap -> Reference -> int getHash()_;1531139295;Return the hash for the reference.;int getHash()_;return,the,hash,for,the,reference;int,get,hash
ConcurrentReferenceHashMap -> Reference -> int getHash()_;1544716668;Return the hash for the reference.;int getHash()_;return,the,hash,for,the,reference;int,get,hash
ConcurrentReferenceHashMap -> Reference -> int getHash()_;1549318940;Return the hash for the reference.;int getHash()_;return,the,hash,for,the,reference;int,get,hash
ConcurrentReferenceHashMap -> Reference -> int getHash()_;1549321822;Return the hash for the reference.;int getHash()_;return,the,hash,for,the,reference;int,get,hash
ConcurrentReferenceHashMap -> Reference -> int getHash()_;1550237263;Return the hash for the reference.;int getHash()_;return,the,hash,for,the,reference;int,get,hash
ConcurrentReferenceHashMap -> @Nullable 	protected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure);1495868221;Return a {@link Reference} to the {@link Entry} for the specified {@code key},_or {@code null} if not found._@param key the key (can be {@code null})_@param restructure types of restructure allowed during this call_@return the reference, or {@code null} if not found;@Nullable_	protected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure) {_		int hash = getHash(key)__		return getSegmentForHash(hash).getReference(key, hash, restructure)__	};return,a,link,reference,to,the,link,entry,for,the,specified,code,key,or,code,null,if,not,found,param,key,the,key,can,be,code,null,param,restructure,types,of,restructure,allowed,during,this,call,return,the,reference,or,code,null,if,not,found;nullable,protected,final,reference,k,v,get,reference,nullable,object,key,restructure,restructure,int,hash,get,hash,key,return,get,segment,for,hash,hash,get,reference,key,hash,restructure
ConcurrentReferenceHashMap -> @Nullable 	protected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure);1496242568;Return a {@link Reference} to the {@link Entry} for the specified {@code key},_or {@code null} if not found._@param key the key (can be {@code null})_@param restructure types of restructure allowed during this call_@return the reference, or {@code null} if not found;@Nullable_	protected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure) {_		int hash = getHash(key)__		return getSegmentForHash(hash).getReference(key, hash, restructure)__	};return,a,link,reference,to,the,link,entry,for,the,specified,code,key,or,code,null,if,not,found,param,key,the,key,can,be,code,null,param,restructure,types,of,restructure,allowed,during,this,call,return,the,reference,or,code,null,if,not,found;nullable,protected,final,reference,k,v,get,reference,nullable,object,key,restructure,restructure,int,hash,get,hash,key,return,get,segment,for,hash,hash,get,reference,key,hash,restructure
ConcurrentReferenceHashMap -> @Nullable 	protected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure);1496837955;Return a {@link Reference} to the {@link Entry} for the specified {@code key},_or {@code null} if not found._@param key the key (can be {@code null})_@param restructure types of restructure allowed during this call_@return the reference, or {@code null} if not found;@Nullable_	protected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure) {_		int hash = getHash(key)__		return getSegmentForHash(hash).getReference(key, hash, restructure)__	};return,a,link,reference,to,the,link,entry,for,the,specified,code,key,or,code,null,if,not,found,param,key,the,key,can,be,code,null,param,restructure,types,of,restructure,allowed,during,this,call,return,the,reference,or,code,null,if,not,found;nullable,protected,final,reference,k,v,get,reference,nullable,object,key,restructure,restructure,int,hash,get,hash,key,return,get,segment,for,hash,hash,get,reference,key,hash,restructure
ConcurrentReferenceHashMap -> @Nullable 	protected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure);1498780456;Return a {@link Reference} to the {@link Entry} for the specified {@code key},_or {@code null} if not found._@param key the key (can be {@code null})_@param restructure types of restructure allowed during this call_@return the reference, or {@code null} if not found;@Nullable_	protected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure) {_		int hash = getHash(key)__		return getSegmentForHash(hash).getReference(key, hash, restructure)__	};return,a,link,reference,to,the,link,entry,for,the,specified,code,key,or,code,null,if,not,found,param,key,the,key,can,be,code,null,param,restructure,types,of,restructure,allowed,during,this,call,return,the,reference,or,code,null,if,not,found;nullable,protected,final,reference,k,v,get,reference,nullable,object,key,restructure,restructure,int,hash,get,hash,key,return,get,segment,for,hash,hash,get,reference,key,hash,restructure
ConcurrentReferenceHashMap -> @Nullable 	protected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure);1502974979;Return a {@link Reference} to the {@link Entry} for the specified {@code key},_or {@code null} if not found._@param key the key (can be {@code null})_@param restructure types of restructure allowed during this call_@return the reference, or {@code null} if not found;@Nullable_	protected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure) {_		int hash = getHash(key)__		return getSegmentForHash(hash).getReference(key, hash, restructure)__	};return,a,link,reference,to,the,link,entry,for,the,specified,code,key,or,code,null,if,not,found,param,key,the,key,can,be,code,null,param,restructure,types,of,restructure,allowed,during,this,call,return,the,reference,or,code,null,if,not,found;nullable,protected,final,reference,k,v,get,reference,nullable,object,key,restructure,restructure,int,hash,get,hash,key,return,get,segment,for,hash,hash,get,reference,key,hash,restructure
ConcurrentReferenceHashMap -> @Nullable 	protected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure);1506097334;Return a {@link Reference} to the {@link Entry} for the specified {@code key},_or {@code null} if not found._@param key the key (can be {@code null})_@param restructure types of restructure allowed during this call_@return the reference, or {@code null} if not found;@Nullable_	protected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure) {_		int hash = getHash(key)__		return getSegmentForHash(hash).getReference(key, hash, restructure)__	};return,a,link,reference,to,the,link,entry,for,the,specified,code,key,or,code,null,if,not,found,param,key,the,key,can,be,code,null,param,restructure,types,of,restructure,allowed,during,this,call,return,the,reference,or,code,null,if,not,found;nullable,protected,final,reference,k,v,get,reference,nullable,object,key,restructure,restructure,int,hash,get,hash,key,return,get,segment,for,hash,hash,get,reference,key,hash,restructure
ConcurrentReferenceHashMap -> @Nullable 	protected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure);1521044224;Return a {@link Reference} to the {@link Entry} for the specified {@code key},_or {@code null} if not found._@param key the key (can be {@code null})_@param restructure types of restructure allowed during this call_@return the reference, or {@code null} if not found;@Nullable_	protected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure) {_		int hash = getHash(key)__		return getSegmentForHash(hash).getReference(key, hash, restructure)__	};return,a,link,reference,to,the,link,entry,for,the,specified,code,key,or,code,null,if,not,found,param,key,the,key,can,be,code,null,param,restructure,types,of,restructure,allowed,during,this,call,return,the,reference,or,code,null,if,not,found;nullable,protected,final,reference,k,v,get,reference,nullable,object,key,restructure,restructure,int,hash,get,hash,key,return,get,segment,for,hash,hash,get,reference,key,hash,restructure
ConcurrentReferenceHashMap -> @Nullable 	protected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure);1530174524;Return a {@link Reference} to the {@link Entry} for the specified {@code key},_or {@code null} if not found._@param key the key (can be {@code null})_@param restructure types of restructure allowed during this call_@return the reference, or {@code null} if not found;@Nullable_	protected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure) {_		int hash = getHash(key)__		return getSegmentForHash(hash).getReference(key, hash, restructure)__	};return,a,link,reference,to,the,link,entry,for,the,specified,code,key,or,code,null,if,not,found,param,key,the,key,can,be,code,null,param,restructure,types,of,restructure,allowed,during,this,call,return,the,reference,or,code,null,if,not,found;nullable,protected,final,reference,k,v,get,reference,nullable,object,key,restructure,restructure,int,hash,get,hash,key,return,get,segment,for,hash,hash,get,reference,key,hash,restructure
ConcurrentReferenceHashMap -> @Nullable 	protected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure);1530190293;Return a {@link Reference} to the {@link Entry} for the specified {@code key},_or {@code null} if not found._@param key the key (can be {@code null})_@param restructure types of restructure allowed during this call_@return the reference, or {@code null} if not found;@Nullable_	protected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure) {_		int hash = getHash(key)__		return getSegmentForHash(hash).getReference(key, hash, restructure)__	};return,a,link,reference,to,the,link,entry,for,the,specified,code,key,or,code,null,if,not,found,param,key,the,key,can,be,code,null,param,restructure,types,of,restructure,allowed,during,this,call,return,the,reference,or,code,null,if,not,found;nullable,protected,final,reference,k,v,get,reference,nullable,object,key,restructure,restructure,int,hash,get,hash,key,return,get,segment,for,hash,hash,get,reference,key,hash,restructure
ConcurrentReferenceHashMap -> @Nullable 	protected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure);1530563577;Return a {@link Reference} to the {@link Entry} for the specified {@code key},_or {@code null} if not found._@param key the key (can be {@code null})_@param restructure types of restructure allowed during this call_@return the reference, or {@code null} if not found;@Nullable_	protected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure) {_		int hash = getHash(key)__		return getSegmentForHash(hash).getReference(key, hash, restructure)__	};return,a,link,reference,to,the,link,entry,for,the,specified,code,key,or,code,null,if,not,found,param,key,the,key,can,be,code,null,param,restructure,types,of,restructure,allowed,during,this,call,return,the,reference,or,code,null,if,not,found;nullable,protected,final,reference,k,v,get,reference,nullable,object,key,restructure,restructure,int,hash,get,hash,key,return,get,segment,for,hash,hash,get,reference,key,hash,restructure
ConcurrentReferenceHashMap -> @Nullable 	protected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure);1531136363;Return a {@link Reference} to the {@link Entry} for the specified {@code key},_or {@code null} if not found._@param key the key (can be {@code null})_@param restructure types of restructure allowed during this call_@return the reference, or {@code null} if not found;@Nullable_	protected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure) {_		int hash = getHash(key)__		return getSegmentForHash(hash).getReference(key, hash, restructure)__	};return,a,link,reference,to,the,link,entry,for,the,specified,code,key,or,code,null,if,not,found,param,key,the,key,can,be,code,null,param,restructure,types,of,restructure,allowed,during,this,call,return,the,reference,or,code,null,if,not,found;nullable,protected,final,reference,k,v,get,reference,nullable,object,key,restructure,restructure,int,hash,get,hash,key,return,get,segment,for,hash,hash,get,reference,key,hash,restructure
ConcurrentReferenceHashMap -> @Nullable 	protected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure);1531139295;Return a {@link Reference} to the {@link Entry} for the specified {@code key},_or {@code null} if not found._@param key the key (can be {@code null})_@param restructure types of restructure allowed during this call_@return the reference, or {@code null} if not found;@Nullable_	protected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure) {_		int hash = getHash(key)__		return getSegmentForHash(hash).getReference(key, hash, restructure)__	};return,a,link,reference,to,the,link,entry,for,the,specified,code,key,or,code,null,if,not,found,param,key,the,key,can,be,code,null,param,restructure,types,of,restructure,allowed,during,this,call,return,the,reference,or,code,null,if,not,found;nullable,protected,final,reference,k,v,get,reference,nullable,object,key,restructure,restructure,int,hash,get,hash,key,return,get,segment,for,hash,hash,get,reference,key,hash,restructure
ConcurrentReferenceHashMap -> @Nullable 	protected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure);1544716668;Return a {@link Reference} to the {@link Entry} for the specified {@code key},_or {@code null} if not found._@param key the key (can be {@code null})_@param restructure types of restructure allowed during this call_@return the reference, or {@code null} if not found;@Nullable_	protected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure) {_		int hash = getHash(key)__		return getSegmentForHash(hash).getReference(key, hash, restructure)__	};return,a,link,reference,to,the,link,entry,for,the,specified,code,key,or,code,null,if,not,found,param,key,the,key,can,be,code,null,param,restructure,types,of,restructure,allowed,during,this,call,return,the,reference,or,code,null,if,not,found;nullable,protected,final,reference,k,v,get,reference,nullable,object,key,restructure,restructure,int,hash,get,hash,key,return,get,segment,for,hash,hash,get,reference,key,hash,restructure
ConcurrentReferenceHashMap -> @Nullable 	protected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure);1549318940;Return a {@link Reference} to the {@link Entry} for the specified {@code key},_or {@code null} if not found._@param key the key (can be {@code null})_@param restructure types of restructure allowed during this call_@return the reference, or {@code null} if not found;@Nullable_	protected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure) {_		int hash = getHash(key)__		return getSegmentForHash(hash).getReference(key, hash, restructure)__	};return,a,link,reference,to,the,link,entry,for,the,specified,code,key,or,code,null,if,not,found,param,key,the,key,can,be,code,null,param,restructure,types,of,restructure,allowed,during,this,call,return,the,reference,or,code,null,if,not,found;nullable,protected,final,reference,k,v,get,reference,nullable,object,key,restructure,restructure,int,hash,get,hash,key,return,get,segment,for,hash,hash,get,reference,key,hash,restructure
ConcurrentReferenceHashMap -> @Nullable 	protected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure);1549321822;Return a {@link Reference} to the {@link Entry} for the specified {@code key},_or {@code null} if not found._@param key the key (can be {@code null})_@param restructure types of restructure allowed during this call_@return the reference, or {@code null} if not found;@Nullable_	protected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure) {_		int hash = getHash(key)__		return getSegmentForHash(hash).getReference(key, hash, restructure)__	};return,a,link,reference,to,the,link,entry,for,the,specified,code,key,or,code,null,if,not,found,param,key,the,key,can,be,code,null,param,restructure,types,of,restructure,allowed,during,this,call,return,the,reference,or,code,null,if,not,found;nullable,protected,final,reference,k,v,get,reference,nullable,object,key,restructure,restructure,int,hash,get,hash,key,return,get,segment,for,hash,hash,get,reference,key,hash,restructure
ConcurrentReferenceHashMap -> @Nullable 	protected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure);1550237263;Return a {@link Reference} to the {@link Entry} for the specified {@code key},_or {@code null} if not found._@param key the key (can be {@code null})_@param restructure types of restructure allowed during this call_@return the reference, or {@code null} if not found;@Nullable_	protected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure) {_		int hash = getHash(key)__		return getSegmentForHash(hash).getReference(key, hash, restructure)__	};return,a,link,reference,to,the,link,entry,for,the,specified,code,key,or,code,null,if,not,found,param,key,the,key,can,be,code,null,param,restructure,types,of,restructure,allowed,during,this,call,return,the,reference,or,code,null,if,not,found;nullable,protected,final,reference,k,v,get,reference,nullable,object,key,restructure,restructure,int,hash,get,hash,key,return,get,segment,for,hash,hash,get,reference,key,hash,restructure
ConcurrentReferenceHashMap -> Segment -> @Nullable 		public <T> T doTask(final int hash, final Object key, final Task<T> task);1496837955;Apply an update operation to this segment._The segment will be locked during the update._@param hash the hash of the key_@param key the key_@param task the update operation_@return the result of the operation;@Nullable_		public <T> T doTask(final int hash, final Object key, final Task<T> task) {_			boolean resize = task.hasOption(TaskOption.RESIZE)__			if (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {_				restructureIfNecessary(resize)__			}_			if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && this.count == 0) {_				return task.execute(null, null, null)__			}_			lock()__			try {_				final int index = getIndex(hash, this.references)__				final Reference<K, V> head = this.references[index]__				Reference<K, V> reference = findInChain(head, key, hash)__				Entry<K, V> entry = (reference != null ? reference.get() : null)__				Entries entries = new Entries() {_					@Override_					public void add(V value) {_						@SuppressWarnings("unchecked")_						Entry<K, V> newEntry = new Entry<>((K) key, value)__						Reference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head)__						Segment.this.references[index] = newReference__						Segment.this.count++__					}_				}__				return task.execute(reference, entry, entries)__			}_			finally {_				unlock()__				if (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {_					restructureIfNecessary(resize)__				}_			}_		};apply,an,update,operation,to,this,segment,the,segment,will,be,locked,during,the,update,param,hash,the,hash,of,the,key,param,key,the,key,param,task,the,update,operation,return,the,result,of,the,operation;nullable,public,t,t,do,task,final,int,hash,final,object,key,final,task,t,task,boolean,resize,task,has,option,task,option,resize,if,task,has,option,task,option,restructure,if,necessary,resize,if,task,has,option,task,option,this,count,0,return,task,execute,null,null,null,lock,try,final,int,index,get,index,hash,this,references,final,reference,k,v,head,this,references,index,reference,k,v,reference,find,in,chain,head,key,hash,entry,k,v,entry,reference,null,reference,get,null,entries,entries,new,entries,override,public,void,add,v,value,suppress,warnings,unchecked,entry,k,v,new,entry,new,entry,k,key,value,reference,k,v,new,reference,segment,this,reference,manager,create,reference,new,entry,hash,head,segment,this,references,index,new,reference,segment,this,count,return,task,execute,reference,entry,entries,finally,unlock,if,task,has,option,task,option,restructure,if,necessary,resize
ConcurrentReferenceHashMap -> Segment -> @Nullable 		public <T> T doTask(final int hash, final Object key, final Task<T> task);1498780456;Apply an update operation to this segment._The segment will be locked during the update._@param hash the hash of the key_@param key the key_@param task the update operation_@return the result of the operation;@Nullable_		public <T> T doTask(final int hash, final Object key, final Task<T> task) {_			boolean resize = task.hasOption(TaskOption.RESIZE)__			if (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {_				restructureIfNecessary(resize)__			}_			if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && this.count == 0) {_				return task.execute(null, null, null)__			}_			lock()__			try {_				final int index = getIndex(hash, this.references)__				final Reference<K, V> head = this.references[index]__				Reference<K, V> reference = findInChain(head, key, hash)__				Entry<K, V> entry = (reference != null ? reference.get() : null)__				Entries entries = new Entries() {_					@Override_					public void add(V value) {_						@SuppressWarnings("unchecked")_						Entry<K, V> newEntry = new Entry<>((K) key, value)__						Reference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head)__						Segment.this.references[index] = newReference__						Segment.this.count++__					}_				}__				return task.execute(reference, entry, entries)__			}_			finally {_				unlock()__				if (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {_					restructureIfNecessary(resize)__				}_			}_		};apply,an,update,operation,to,this,segment,the,segment,will,be,locked,during,the,update,param,hash,the,hash,of,the,key,param,key,the,key,param,task,the,update,operation,return,the,result,of,the,operation;nullable,public,t,t,do,task,final,int,hash,final,object,key,final,task,t,task,boolean,resize,task,has,option,task,option,resize,if,task,has,option,task,option,restructure,if,necessary,resize,if,task,has,option,task,option,this,count,0,return,task,execute,null,null,null,lock,try,final,int,index,get,index,hash,this,references,final,reference,k,v,head,this,references,index,reference,k,v,reference,find,in,chain,head,key,hash,entry,k,v,entry,reference,null,reference,get,null,entries,entries,new,entries,override,public,void,add,v,value,suppress,warnings,unchecked,entry,k,v,new,entry,new,entry,k,key,value,reference,k,v,new,reference,segment,this,reference,manager,create,reference,new,entry,hash,head,segment,this,references,index,new,reference,segment,this,count,return,task,execute,reference,entry,entries,finally,unlock,if,task,has,option,task,option,restructure,if,necessary,resize
ConcurrentReferenceHashMap -> Segment -> @Nullable 		public <T> T doTask(final int hash, final Object key, final Task<T> task);1502974979;Apply an update operation to this segment._The segment will be locked during the update._@param hash the hash of the key_@param key the key_@param task the update operation_@return the result of the operation;@Nullable_		public <T> T doTask(final int hash, final Object key, final Task<T> task) {_			boolean resize = task.hasOption(TaskOption.RESIZE)__			if (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {_				restructureIfNecessary(resize)__			}_			if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && this.count == 0) {_				return task.execute(null, null, null)__			}_			lock()__			try {_				final int index = getIndex(hash, this.references)__				final Reference<K, V> head = this.references[index]__				Reference<K, V> reference = findInChain(head, key, hash)__				Entry<K, V> entry = (reference != null ? reference.get() : null)__				Entries entries = new Entries() {_					@Override_					public void add(V value) {_						@SuppressWarnings("unchecked")_						Entry<K, V> newEntry = new Entry<>((K) key, value)__						Reference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head)__						Segment.this.references[index] = newReference__						Segment.this.count++__					}_				}__				return task.execute(reference, entry, entries)__			}_			finally {_				unlock()__				if (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {_					restructureIfNecessary(resize)__				}_			}_		};apply,an,update,operation,to,this,segment,the,segment,will,be,locked,during,the,update,param,hash,the,hash,of,the,key,param,key,the,key,param,task,the,update,operation,return,the,result,of,the,operation;nullable,public,t,t,do,task,final,int,hash,final,object,key,final,task,t,task,boolean,resize,task,has,option,task,option,resize,if,task,has,option,task,option,restructure,if,necessary,resize,if,task,has,option,task,option,this,count,0,return,task,execute,null,null,null,lock,try,final,int,index,get,index,hash,this,references,final,reference,k,v,head,this,references,index,reference,k,v,reference,find,in,chain,head,key,hash,entry,k,v,entry,reference,null,reference,get,null,entries,entries,new,entries,override,public,void,add,v,value,suppress,warnings,unchecked,entry,k,v,new,entry,new,entry,k,key,value,reference,k,v,new,reference,segment,this,reference,manager,create,reference,new,entry,hash,head,segment,this,references,index,new,reference,segment,this,count,return,task,execute,reference,entry,entries,finally,unlock,if,task,has,option,task,option,restructure,if,necessary,resize
ConcurrentReferenceHashMap -> Segment -> @Nullable 		public <T> T doTask(final int hash, final Object key, final Task<T> task);1506097334;Apply an update operation to this segment._The segment will be locked during the update._@param hash the hash of the key_@param key the key_@param task the update operation_@return the result of the operation;@Nullable_		public <T> T doTask(final int hash, final Object key, final Task<T> task) {_			boolean resize = task.hasOption(TaskOption.RESIZE)__			if (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {_				restructureIfNecessary(resize)__			}_			if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && this.count == 0) {_				return task.execute(null, null, null)__			}_			lock()__			try {_				final int index = getIndex(hash, this.references)__				final Reference<K, V> head = this.references[index]__				Reference<K, V> reference = findInChain(head, key, hash)__				Entry<K, V> entry = (reference != null ? reference.get() : null)__				Entries entries = new Entries() {_					@Override_					public void add(V value) {_						@SuppressWarnings("unchecked")_						Entry<K, V> newEntry = new Entry<>((K) key, value)__						Reference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head)__						Segment.this.references[index] = newReference__						Segment.this.count++__					}_				}__				return task.execute(reference, entry, entries)__			}_			finally {_				unlock()__				if (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {_					restructureIfNecessary(resize)__				}_			}_		};apply,an,update,operation,to,this,segment,the,segment,will,be,locked,during,the,update,param,hash,the,hash,of,the,key,param,key,the,key,param,task,the,update,operation,return,the,result,of,the,operation;nullable,public,t,t,do,task,final,int,hash,final,object,key,final,task,t,task,boolean,resize,task,has,option,task,option,resize,if,task,has,option,task,option,restructure,if,necessary,resize,if,task,has,option,task,option,this,count,0,return,task,execute,null,null,null,lock,try,final,int,index,get,index,hash,this,references,final,reference,k,v,head,this,references,index,reference,k,v,reference,find,in,chain,head,key,hash,entry,k,v,entry,reference,null,reference,get,null,entries,entries,new,entries,override,public,void,add,v,value,suppress,warnings,unchecked,entry,k,v,new,entry,new,entry,k,key,value,reference,k,v,new,reference,segment,this,reference,manager,create,reference,new,entry,hash,head,segment,this,references,index,new,reference,segment,this,count,return,task,execute,reference,entry,entries,finally,unlock,if,task,has,option,task,option,restructure,if,necessary,resize
ConcurrentReferenceHashMap -> Task -> @Nullable 		protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry, @Nullable Entries entries);1530563577;Execute the task._@param ref the found reference (or {@code null})_@param entry the found entry (or {@code null})_@param entries access to the underlying entries_@return the result of the task_@see #execute(Reference, Entry);@Nullable_		protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry, @Nullable Entries entries) {_			return execute(ref, entry)__		};execute,the,task,param,ref,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,param,entries,access,to,the,underlying,entries,return,the,result,of,the,task,see,execute,reference,entry;nullable,protected,t,execute,nullable,reference,k,v,ref,nullable,entry,k,v,entry,nullable,entries,entries,return,execute,ref,entry
ConcurrentReferenceHashMap -> Task -> @Nullable 		protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry, @Nullable Entries entries);1531136363;Execute the task._@param ref the found reference (or {@code null})_@param entry the found entry (or {@code null})_@param entries access to the underlying entries_@return the result of the task_@see #execute(Reference, Entry);@Nullable_		protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry, @Nullable Entries entries) {_			return execute(ref, entry)__		};execute,the,task,param,ref,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,param,entries,access,to,the,underlying,entries,return,the,result,of,the,task,see,execute,reference,entry;nullable,protected,t,execute,nullable,reference,k,v,ref,nullable,entry,k,v,entry,nullable,entries,entries,return,execute,ref,entry
ConcurrentReferenceHashMap -> Task -> @Nullable 		protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry, @Nullable Entries entries);1531139295;Execute the task._@param ref the found reference (or {@code null})_@param entry the found entry (or {@code null})_@param entries access to the underlying entries_@return the result of the task_@see #execute(Reference, Entry);@Nullable_		protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry, @Nullable Entries entries) {_			return execute(ref, entry)__		};execute,the,task,param,ref,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,param,entries,access,to,the,underlying,entries,return,the,result,of,the,task,see,execute,reference,entry;nullable,protected,t,execute,nullable,reference,k,v,ref,nullable,entry,k,v,entry,nullable,entries,entries,return,execute,ref,entry
ConcurrentReferenceHashMap -> Task -> @Nullable 		protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry, @Nullable Entries entries);1544716668;Execute the task._@param ref the found reference (or {@code null})_@param entry the found entry (or {@code null})_@param entries access to the underlying entries_@return the result of the task_@see #execute(Reference, Entry);@Nullable_		protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry, @Nullable Entries entries) {_			return execute(ref, entry)__		};execute,the,task,param,ref,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,param,entries,access,to,the,underlying,entries,return,the,result,of,the,task,see,execute,reference,entry;nullable,protected,t,execute,nullable,reference,k,v,ref,nullable,entry,k,v,entry,nullable,entries,entries,return,execute,ref,entry
ConcurrentReferenceHashMap -> Task -> @Nullable 		protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry, @Nullable Entries entries);1549318940;Execute the task._@param ref the found reference (or {@code null})_@param entry the found entry (or {@code null})_@param entries access to the underlying entries_@return the result of the task_@see #execute(Reference, Entry);@Nullable_		protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry, @Nullable Entries entries) {_			return execute(ref, entry)__		};execute,the,task,param,ref,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,param,entries,access,to,the,underlying,entries,return,the,result,of,the,task,see,execute,reference,entry;nullable,protected,t,execute,nullable,reference,k,v,ref,nullable,entry,k,v,entry,nullable,entries,entries,return,execute,ref,entry
ConcurrentReferenceHashMap -> Task -> @Nullable 		protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry, @Nullable Entries entries);1549321822;Execute the task._@param ref the found reference (or {@code null})_@param entry the found entry (or {@code null})_@param entries access to the underlying entries_@return the result of the task_@see #execute(Reference, Entry);@Nullable_		protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry, @Nullable Entries entries) {_			return execute(ref, entry)__		};execute,the,task,param,ref,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,param,entries,access,to,the,underlying,entries,return,the,result,of,the,task,see,execute,reference,entry;nullable,protected,t,execute,nullable,reference,k,v,ref,nullable,entry,k,v,entry,nullable,entries,entries,return,execute,ref,entry
ConcurrentReferenceHashMap -> Reference -> Entry<K, V> get()_;1351982790;Returns the referenced entry or {@code null} if the entry is no longer_available._@return the entry or {@code null};Entry<K, V> get()_;returns,the,referenced,entry,or,code,null,if,the,entry,is,no,longer,available,return,the,entry,or,code,null;entry,k,v,get
ConcurrentReferenceHashMap -> Reference -> Entry<K, V> get()_;1352039846;Returns the referenced entry or {@code null} if the entry is no longer_available._@return the entry or {@code null};Entry<K, V> get()_;returns,the,referenced,entry,or,code,null,if,the,entry,is,no,longer,available,return,the,entry,or,code,null;entry,k,v,get
ConcurrentReferenceHashMap -> Reference -> Entry<K, V> get()_;1355313310;Returns the referenced entry or {@code null} if the entry is no longer_available._@return the entry or {@code null};Entry<K, V> get()_;returns,the,referenced,entry,or,code,null,if,the,entry,is,no,longer,available,return,the,entry,or,code,null;entry,k,v,get
ConcurrentReferenceHashMap -> Reference -> Entry<K, V> get()_;1356735495;Returns the referenced entry or {@code null} if the entry is no longer_available._@return the entry or {@code null};Entry<K, V> get()_;returns,the,referenced,entry,or,code,null,if,the,entry,is,no,longer,available,return,the,entry,or,code,null;entry,k,v,get
ConcurrentReferenceHashMap -> Reference -> Entry<K, V> get()_;1357119239;Returns the referenced entry or {@code null} if the entry is no longer_available._@return the entry or {@code null};Entry<K, V> get()_;returns,the,referenced,entry,or,code,null,if,the,entry,is,no,longer,available,return,the,entry,or,code,null;entry,k,v,get
ConcurrentReferenceHashMap -> Reference -> Entry<K, V> get()_;1368482696;Returns the referenced entry or {@code null} if the entry is no longer_available._@return the entry or {@code null};Entry<K, V> get()_;returns,the,referenced,entry,or,code,null,if,the,entry,is,no,longer,available,return,the,entry,or,code,null;entry,k,v,get
ConcurrentReferenceHashMap -> Reference -> Entry<K, V> get()_;1383090835;Returns the referenced entry or {@code null} if the entry is no longer_available._@return the entry or {@code null};Entry<K, V> get()_;returns,the,referenced,entry,or,code,null,if,the,entry,is,no,longer,available,return,the,entry,or,code,null;entry,k,v,get
ConcurrentReferenceHashMap -> Reference -> Entry<K, V> get()_;1383178438;Returns the referenced entry or {@code null} if the entry is no longer_available._@return the entry or {@code null};Entry<K, V> get()_;returns,the,referenced,entry,or,code,null,if,the,entry,is,no,longer,available,return,the,entry,or,code,null;entry,k,v,get
ConcurrentReferenceHashMap -> Reference -> Entry<K, V> get()_;1390260938;Returns the referenced entry or {@code null} if the entry is no longer_available._@return the entry or {@code null};Entry<K, V> get()_;returns,the,referenced,entry,or,code,null,if,the,entry,is,no,longer,available,return,the,entry,or,code,null;entry,k,v,get
ConcurrentReferenceHashMap -> Reference -> Entry<K, V> get()_;1391715359;Returns the referenced entry or {@code null} if the entry is no longer_available._@return the entry or {@code null};Entry<K, V> get()_;returns,the,referenced,entry,or,code,null,if,the,entry,is,no,longer,available,return,the,entry,or,code,null;entry,k,v,get
ConcurrentReferenceHashMap -> Reference -> Entry<K, V> get()_;1392765030;Returns the referenced entry or {@code null} if the entry is no longer_available._@return the entry or {@code null};Entry<K, V> get()_;returns,the,referenced,entry,or,code,null,if,the,entry,is,no,longer,available,return,the,entry,or,code,null;entry,k,v,get
ConcurrentReferenceHashMap -> Reference -> Entry<K, V> get()_;1398175099;Returns the referenced entry or {@code null} if the entry is no longer_available._@return the entry or {@code null};Entry<K, V> get()_;returns,the,referenced,entry,or,code,null,if,the,entry,is,no,longer,available,return,the,entry,or,code,null;entry,k,v,get
ConcurrentReferenceHashMap -> Reference -> Entry<K, V> get()_;1404132943;Returns the referenced entry or {@code null} if the entry is no longer_available._@return the entry or {@code null};Entry<K, V> get()_;returns,the,referenced,entry,or,code,null,if,the,entry,is,no,longer,available,return,the,entry,or,code,null;entry,k,v,get
ConcurrentReferenceHashMap -> Reference -> Entry<K, V> get()_;1427240641;Returns the referenced entry or {@code null} if the entry is no longer_available._@return the entry or {@code null};Entry<K, V> get()_;returns,the,referenced,entry,or,code,null,if,the,entry,is,no,longer,available,return,the,entry,or,code,null;entry,k,v,get
ConcurrentReferenceHashMap -> Reference -> Entry<K, V> get()_;1459795890;Returns the referenced entry or {@code null} if the entry is no longer_available._@return the entry or {@code null};Entry<K, V> get()_;returns,the,referenced,entry,or,code,null,if,the,entry,is,no,longer,available,return,the,entry,or,code,null;entry,k,v,get
ConcurrentReferenceHashMap -> Reference -> Entry<K, V> get()_;1467730834;Returns the referenced entry or {@code null} if the entry is no longer_available._@return the entry or {@code null};Entry<K, V> get()_;returns,the,referenced,entry,or,code,null,if,the,entry,is,no,longer,available,return,the,entry,or,code,null;entry,k,v,get
ConcurrentReferenceHashMap -> Reference -> Entry<K, V> get()_;1485810955;Returns the referenced entry or {@code null} if the entry is no longer_available._@return the entry or {@code null};Entry<K, V> get()_;returns,the,referenced,entry,or,code,null,if,the,entry,is,no,longer,available,return,the,entry,or,code,null;entry,k,v,get
ConcurrentReferenceHashMap -> ReferenceManager -> public Reference<K, V> createReference(Entry<K, V> entry, int hash, 				Reference<K, V> next);1351982790;Factory method used to create a new {@link Reference}._@param entry the entry contained in the reference_@param hash the hash_@param next the next reference in the chain or {@code null}_@return a new {@link Reference};public Reference<K, V> createReference(Entry<K, V> entry, int hash,_				Reference<K, V> next) {_			if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {_				return new WeakEntryReference<K, V>(entry, hash, next, this.queue)__			}_			return new SoftEntryReference<K, V>(entry, hash, next, this.queue)__		};factory,method,used,to,create,a,new,link,reference,param,entry,the,entry,contained,in,the,reference,param,hash,the,hash,param,next,the,next,reference,in,the,chain,or,code,null,return,a,new,link,reference;public,reference,k,v,create,reference,entry,k,v,entry,int,hash,reference,k,v,next,if,concurrent,reference,hash,map,this,reference,type,reference,type,weak,return,new,weak,entry,reference,k,v,entry,hash,next,this,queue,return,new,soft,entry,reference,k,v,entry,hash,next,this,queue
ConcurrentReferenceHashMap -> ReferenceManager -> public Reference<K, V> createReference(Entry<K, V> entry, int hash, 				Reference<K, V> next);1352039846;Factory method used to create a new {@link Reference}._@param entry the entry contained in the reference_@param hash the hash_@param next the next reference in the chain or {@code null}_@return a new {@link Reference};public Reference<K, V> createReference(Entry<K, V> entry, int hash,_				Reference<K, V> next) {_			if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {_				return new WeakEntryReference<K, V>(entry, hash, next, this.queue)__			}_			return new SoftEntryReference<K, V>(entry, hash, next, this.queue)__		};factory,method,used,to,create,a,new,link,reference,param,entry,the,entry,contained,in,the,reference,param,hash,the,hash,param,next,the,next,reference,in,the,chain,or,code,null,return,a,new,link,reference;public,reference,k,v,create,reference,entry,k,v,entry,int,hash,reference,k,v,next,if,concurrent,reference,hash,map,this,reference,type,reference,type,weak,return,new,weak,entry,reference,k,v,entry,hash,next,this,queue,return,new,soft,entry,reference,k,v,entry,hash,next,this,queue
ConcurrentReferenceHashMap -> ReferenceManager -> public Reference<K, V> createReference(Entry<K, V> entry, int hash, 				Reference<K, V> next);1355313310;Factory method used to create a new {@link Reference}._@param entry the entry contained in the reference_@param hash the hash_@param next the next reference in the chain or {@code null}_@return a new {@link Reference};public Reference<K, V> createReference(Entry<K, V> entry, int hash,_				Reference<K, V> next) {_			if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {_				return new WeakEntryReference<K, V>(entry, hash, next, this.queue)__			}_			return new SoftEntryReference<K, V>(entry, hash, next, this.queue)__		};factory,method,used,to,create,a,new,link,reference,param,entry,the,entry,contained,in,the,reference,param,hash,the,hash,param,next,the,next,reference,in,the,chain,or,code,null,return,a,new,link,reference;public,reference,k,v,create,reference,entry,k,v,entry,int,hash,reference,k,v,next,if,concurrent,reference,hash,map,this,reference,type,reference,type,weak,return,new,weak,entry,reference,k,v,entry,hash,next,this,queue,return,new,soft,entry,reference,k,v,entry,hash,next,this,queue
ConcurrentReferenceHashMap -> ReferenceManager -> public Reference<K, V> createReference(Entry<K, V> entry, int hash, 				Reference<K, V> next);1356735495;Factory method used to create a new {@link Reference}._@param entry the entry contained in the reference_@param hash the hash_@param next the next reference in the chain or {@code null}_@return a new {@link Reference};public Reference<K, V> createReference(Entry<K, V> entry, int hash,_				Reference<K, V> next) {_			if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {_				return new WeakEntryReference<K, V>(entry, hash, next, this.queue)__			}_			return new SoftEntryReference<K, V>(entry, hash, next, this.queue)__		};factory,method,used,to,create,a,new,link,reference,param,entry,the,entry,contained,in,the,reference,param,hash,the,hash,param,next,the,next,reference,in,the,chain,or,code,null,return,a,new,link,reference;public,reference,k,v,create,reference,entry,k,v,entry,int,hash,reference,k,v,next,if,concurrent,reference,hash,map,this,reference,type,reference,type,weak,return,new,weak,entry,reference,k,v,entry,hash,next,this,queue,return,new,soft,entry,reference,k,v,entry,hash,next,this,queue
ConcurrentReferenceHashMap -> ReferenceManager -> public Reference<K, V> createReference(Entry<K, V> entry, int hash, 				Reference<K, V> next);1357119239;Factory method used to create a new {@link Reference}._@param entry the entry contained in the reference_@param hash the hash_@param next the next reference in the chain or {@code null}_@return a new {@link Reference};public Reference<K, V> createReference(Entry<K, V> entry, int hash,_				Reference<K, V> next) {_			if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {_				return new WeakEntryReference<K, V>(entry, hash, next, this.queue)__			}_			return new SoftEntryReference<K, V>(entry, hash, next, this.queue)__		};factory,method,used,to,create,a,new,link,reference,param,entry,the,entry,contained,in,the,reference,param,hash,the,hash,param,next,the,next,reference,in,the,chain,or,code,null,return,a,new,link,reference;public,reference,k,v,create,reference,entry,k,v,entry,int,hash,reference,k,v,next,if,concurrent,reference,hash,map,this,reference,type,reference,type,weak,return,new,weak,entry,reference,k,v,entry,hash,next,this,queue,return,new,soft,entry,reference,k,v,entry,hash,next,this,queue
ConcurrentReferenceHashMap -> ReferenceManager -> public Reference<K, V> createReference(Entry<K, V> entry, int hash, 				Reference<K, V> next);1368482696;Factory method used to create a new {@link Reference}._@param entry the entry contained in the reference_@param hash the hash_@param next the next reference in the chain or {@code null}_@return a new {@link Reference};public Reference<K, V> createReference(Entry<K, V> entry, int hash,_				Reference<K, V> next) {_			if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {_				return new WeakEntryReference<K, V>(entry, hash, next, this.queue)__			}_			return new SoftEntryReference<K, V>(entry, hash, next, this.queue)__		};factory,method,used,to,create,a,new,link,reference,param,entry,the,entry,contained,in,the,reference,param,hash,the,hash,param,next,the,next,reference,in,the,chain,or,code,null,return,a,new,link,reference;public,reference,k,v,create,reference,entry,k,v,entry,int,hash,reference,k,v,next,if,concurrent,reference,hash,map,this,reference,type,reference,type,weak,return,new,weak,entry,reference,k,v,entry,hash,next,this,queue,return,new,soft,entry,reference,k,v,entry,hash,next,this,queue
ConcurrentReferenceHashMap -> Entries -> public abstract void add(V value)_;1351982790;Add a new entry with the specified value._@param value the value to add;public abstract void add(V value)_;add,a,new,entry,with,the,specified,value,param,value,the,value,to,add;public,abstract,void,add,v,value
ConcurrentReferenceHashMap -> Entries -> public abstract void add(V value)_;1352039846;Add a new entry with the specified value._@param value the value to add;public abstract void add(V value)_;add,a,new,entry,with,the,specified,value,param,value,the,value,to,add;public,abstract,void,add,v,value
ConcurrentReferenceHashMap -> Entries -> public abstract void add(V value)_;1355313310;Add a new entry with the specified value._@param value the value to add;public abstract void add(V value)_;add,a,new,entry,with,the,specified,value,param,value,the,value,to,add;public,abstract,void,add,v,value
ConcurrentReferenceHashMap -> Entries -> public abstract void add(V value)_;1356735495;Add a new entry with the specified value._@param value the value to add;public abstract void add(V value)_;add,a,new,entry,with,the,specified,value,param,value,the,value,to,add;public,abstract,void,add,v,value
ConcurrentReferenceHashMap -> Entries -> public abstract void add(V value)_;1357119239;Add a new entry with the specified value._@param value the value to add;public abstract void add(V value)_;add,a,new,entry,with,the,specified,value,param,value,the,value,to,add;public,abstract,void,add,v,value
ConcurrentReferenceHashMap -> Entries -> public abstract void add(V value)_;1368482696;Add a new entry with the specified value._@param value the value to add;public abstract void add(V value)_;add,a,new,entry,with,the,specified,value,param,value,the,value,to,add;public,abstract,void,add,v,value
ConcurrentReferenceHashMap -> Entries -> public abstract void add(V value)_;1383090835;Add a new entry with the specified value._@param value the value to add;public abstract void add(V value)_;add,a,new,entry,with,the,specified,value,param,value,the,value,to,add;public,abstract,void,add,v,value
ConcurrentReferenceHashMap -> Entries -> public abstract void add(V value)_;1383178438;Add a new entry with the specified value._@param value the value to add;public abstract void add(V value)_;add,a,new,entry,with,the,specified,value,param,value,the,value,to,add;public,abstract,void,add,v,value
ConcurrentReferenceHashMap -> Entries -> public abstract void add(V value)_;1390260938;Add a new entry with the specified value._@param value the value to add;public abstract void add(V value)_;add,a,new,entry,with,the,specified,value,param,value,the,value,to,add;public,abstract,void,add,v,value
ConcurrentReferenceHashMap -> Entries -> public abstract void add(V value)_;1391715359;Add a new entry with the specified value._@param value the value to add;public abstract void add(V value)_;add,a,new,entry,with,the,specified,value,param,value,the,value,to,add;public,abstract,void,add,v,value
ConcurrentReferenceHashMap -> Entries -> public abstract void add(V value)_;1392765030;Add a new entry with the specified value._@param value the value to add;public abstract void add(V value)_;add,a,new,entry,with,the,specified,value,param,value,the,value,to,add;public,abstract,void,add,v,value
ConcurrentReferenceHashMap -> Entries -> public abstract void add(V value)_;1398175099;Add a new entry with the specified value._@param value the value to add;public abstract void add(V value)_;add,a,new,entry,with,the,specified,value,param,value,the,value,to,add;public,abstract,void,add,v,value
ConcurrentReferenceHashMap -> Entries -> public abstract void add(V value)_;1404132943;Add a new entry with the specified value._@param value the value to add;public abstract void add(V value)_;add,a,new,entry,with,the,specified,value,param,value,the,value,to,add;public,abstract,void,add,v,value
ConcurrentReferenceHashMap -> Entries -> public abstract void add(V value)_;1427240641;Add a new entry with the specified value._@param value the value to add;public abstract void add(V value)_;add,a,new,entry,with,the,specified,value,param,value,the,value,to,add;public,abstract,void,add,v,value
ConcurrentReferenceHashMap -> Entries -> public abstract void add(V value)_;1459795890;Add a new entry with the specified value._@param value the value to add;public abstract void add(V value)_;add,a,new,entry,with,the,specified,value,param,value,the,value,to,add;public,abstract,void,add,v,value
ConcurrentReferenceHashMap -> Entries -> public abstract void add(V value)_;1467730834;Add a new entry with the specified value._@param value the value to add;public abstract void add(V value)_;add,a,new,entry,with,the,specified,value,param,value,the,value,to,add;public,abstract,void,add,v,value
ConcurrentReferenceHashMap -> Entries -> public abstract void add(V value)_;1485810955;Add a new entry with the specified value._@param value the value to add;public abstract void add(V value)_;add,a,new,entry,with,the,specified,value,param,value,the,value,to,add;public,abstract,void,add,v,value
ConcurrentReferenceHashMap -> Entries -> public abstract void add(V value)_;1495868221;Add a new entry with the specified value._@param value the value to add;public abstract void add(V value)_;add,a,new,entry,with,the,specified,value,param,value,the,value,to,add;public,abstract,void,add,v,value
ConcurrentReferenceHashMap -> Entries -> public abstract void add(V value)_;1496242568;Add a new entry with the specified value._@param value the value to add;public abstract void add(V value)_;add,a,new,entry,with,the,specified,value,param,value,the,value,to,add;public,abstract,void,add,v,value
ConcurrentReferenceHashMap -> Entries -> public abstract void add(V value)_;1496837955;Add a new entry with the specified value._@param value the value to add;public abstract void add(V value)_;add,a,new,entry,with,the,specified,value,param,value,the,value,to,add;public,abstract,void,add,v,value
ConcurrentReferenceHashMap -> Entries -> public abstract void add(V value)_;1498780456;Add a new entry with the specified value._@param value the value to add;public abstract void add(V value)_;add,a,new,entry,with,the,specified,value,param,value,the,value,to,add;public,abstract,void,add,v,value
ConcurrentReferenceHashMap -> Entries -> public abstract void add(V value)_;1502974979;Add a new entry with the specified value._@param value the value to add;public abstract void add(V value)_;add,a,new,entry,with,the,specified,value,param,value,the,value,to,add;public,abstract,void,add,v,value
ConcurrentReferenceHashMap -> Entries -> public abstract void add(V value)_;1506097334;Add a new entry with the specified value._@param value the value to add;public abstract void add(V value)_;add,a,new,entry,with,the,specified,value,param,value,the,value,to,add;public,abstract,void,add,v,value
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor);1351982790;Create a new {@link ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor) {_		this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL,_				DEFAULT_REFERENCE_TYPE)__	};create,a,new,link,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,this,initial,capacity,load,factor
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor);1352039846;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor) {_		this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL,_				DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,this,initial,capacity,load,factor
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor);1355313310;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor) {_		this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL,_				DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,this,initial,capacity,load,factor
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor);1356735495;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor) {_		this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL,_				DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,this,initial,capacity,load,factor
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor);1357119239;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor) {_		this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL,_				DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,this,initial,capacity,load,factor
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor);1368482696;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor) {_		this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL,_				DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,this,initial,capacity,load,factor
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor);1383090835;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor) {_		this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,this,initial,capacity,load,factor
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor);1383178438;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor) {_		this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,this,initial,capacity,load,factor
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor);1390260938;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor) {_		this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,this,initial,capacity,load,factor
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor);1391715359;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor) {_		this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,this,initial,capacity,load,factor
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor);1392765030;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor) {_		this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,this,initial,capacity,load,factor
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor);1398175099;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor) {_		this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,this,initial,capacity,load,factor
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor);1404132943;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor) {_		this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,this,initial,capacity,load,factor
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor);1427240641;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor) {_		this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,this,initial,capacity,load,factor
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor);1459795890;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor) {_		this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,this,initial,capacity,load,factor
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor);1467730834;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor) {_		this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,this,initial,capacity,load,factor
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor);1485810955;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor) {_		this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,this,initial,capacity,load,factor
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor);1495868221;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor) {_		this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,this,initial,capacity,load,factor
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor);1496242568;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor) {_		this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,this,initial,capacity,load,factor
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor);1496837955;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor) {_		this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,this,initial,capacity,load,factor
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor);1498780456;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor) {_		this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,this,initial,capacity,load,factor
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor);1502974979;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor) {_		this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,this,initial,capacity,load,factor
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor);1506097334;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor) {_		this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,this,initial,capacity,load,factor
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor);1521044224;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor) {_		this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,this,initial,capacity,load,factor
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor);1530174524;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor) {_		this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,this,initial,capacity,load,factor
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor);1530190293;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor) {_		this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,this,initial,capacity,load,factor
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor);1530563577;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor) {_		this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,this,initial,capacity,load,factor
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor);1531136363;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor) {_		this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,this,initial,capacity,load,factor
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor);1531139295;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor) {_		this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,this,initial,capacity,load,factor
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor);1544716668;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor) {_		this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,this,initial,capacity,load,factor
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor);1549318940;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor) {_		this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,this,initial,capacity,load,factor
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor);1549321822;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor) {_		this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,this,initial,capacity,load,factor
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor);1550237263;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor) {_		this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,this,initial,capacity,load,factor
ConcurrentReferenceHashMap -> Reference -> Reference<K, V> getNext()_;1351982790;Returns the next reference in the chain or {@code null}_@return the next reference of {@code null};Reference<K, V> getNext()_;returns,the,next,reference,in,the,chain,or,code,null,return,the,next,reference,of,code,null;reference,k,v,get,next
ConcurrentReferenceHashMap -> Reference -> Reference<K, V> getNext()_;1352039846;Returns the next reference in the chain or {@code null}_@return the next reference of {@code null};Reference<K, V> getNext()_;returns,the,next,reference,in,the,chain,or,code,null,return,the,next,reference,of,code,null;reference,k,v,get,next
ConcurrentReferenceHashMap -> Reference -> Reference<K, V> getNext()_;1355313310;Returns the next reference in the chain or {@code null}_@return the next reference of {@code null};Reference<K, V> getNext()_;returns,the,next,reference,in,the,chain,or,code,null,return,the,next,reference,of,code,null;reference,k,v,get,next
ConcurrentReferenceHashMap -> Reference -> Reference<K, V> getNext()_;1356735495;Returns the next reference in the chain or {@code null}_@return the next reference of {@code null};Reference<K, V> getNext()_;returns,the,next,reference,in,the,chain,or,code,null,return,the,next,reference,of,code,null;reference,k,v,get,next
ConcurrentReferenceHashMap -> Reference -> Reference<K, V> getNext()_;1357119239;Returns the next reference in the chain or {@code null}_@return the next reference of {@code null};Reference<K, V> getNext()_;returns,the,next,reference,in,the,chain,or,code,null,return,the,next,reference,of,code,null;reference,k,v,get,next
ConcurrentReferenceHashMap -> Reference -> Reference<K, V> getNext()_;1368482696;Returns the next reference in the chain or {@code null}_@return the next reference of {@code null};Reference<K, V> getNext()_;returns,the,next,reference,in,the,chain,or,code,null,return,the,next,reference,of,code,null;reference,k,v,get,next
ConcurrentReferenceHashMap -> Reference -> Reference<K, V> getNext()_;1383090835;Returns the next reference in the chain or {@code null}_@return the next reference of {@code null};Reference<K, V> getNext()_;returns,the,next,reference,in,the,chain,or,code,null,return,the,next,reference,of,code,null;reference,k,v,get,next
ConcurrentReferenceHashMap -> Reference -> Reference<K, V> getNext()_;1383178438;Returns the next reference in the chain or {@code null}_@return the next reference of {@code null};Reference<K, V> getNext()_;returns,the,next,reference,in,the,chain,or,code,null,return,the,next,reference,of,code,null;reference,k,v,get,next
ConcurrentReferenceHashMap -> Reference -> Reference<K, V> getNext()_;1390260938;Returns the next reference in the chain or {@code null}_@return the next reference of {@code null};Reference<K, V> getNext()_;returns,the,next,reference,in,the,chain,or,code,null,return,the,next,reference,of,code,null;reference,k,v,get,next
ConcurrentReferenceHashMap -> Reference -> Reference<K, V> getNext()_;1391715359;Returns the next reference in the chain or {@code null}_@return the next reference of {@code null};Reference<K, V> getNext()_;returns,the,next,reference,in,the,chain,or,code,null,return,the,next,reference,of,code,null;reference,k,v,get,next
ConcurrentReferenceHashMap -> Reference -> Reference<K, V> getNext()_;1392765030;Returns the next reference in the chain or {@code null}_@return the next reference of {@code null};Reference<K, V> getNext()_;returns,the,next,reference,in,the,chain,or,code,null,return,the,next,reference,of,code,null;reference,k,v,get,next
ConcurrentReferenceHashMap -> Reference -> Reference<K, V> getNext()_;1398175099;Returns the next reference in the chain or {@code null}_@return the next reference of {@code null};Reference<K, V> getNext()_;returns,the,next,reference,in,the,chain,or,code,null,return,the,next,reference,of,code,null;reference,k,v,get,next
ConcurrentReferenceHashMap -> Reference -> Reference<K, V> getNext()_;1404132943;Returns the next reference in the chain or {@code null}_@return the next reference of {@code null};Reference<K, V> getNext()_;returns,the,next,reference,in,the,chain,or,code,null,return,the,next,reference,of,code,null;reference,k,v,get,next
ConcurrentReferenceHashMap -> Reference -> Reference<K, V> getNext()_;1427240641;Returns the next reference in the chain or {@code null}_@return the next reference of {@code null};Reference<K, V> getNext()_;returns,the,next,reference,in,the,chain,or,code,null,return,the,next,reference,of,code,null;reference,k,v,get,next
ConcurrentReferenceHashMap -> Reference -> Reference<K, V> getNext()_;1459795890;Returns the next reference in the chain or {@code null}_@return the next reference of {@code null};Reference<K, V> getNext()_;returns,the,next,reference,in,the,chain,or,code,null,return,the,next,reference,of,code,null;reference,k,v,get,next
ConcurrentReferenceHashMap -> Reference -> Reference<K, V> getNext()_;1467730834;Returns the next reference in the chain or {@code null}_@return the next reference of {@code null};Reference<K, V> getNext()_;returns,the,next,reference,in,the,chain,or,code,null,return,the,next,reference,of,code,null;reference,k,v,get,next
ConcurrentReferenceHashMap -> Reference -> Reference<K, V> getNext()_;1485810955;Returns the next reference in the chain or {@code null}_@return the next reference of {@code null};Reference<K, V> getNext()_;returns,the,next,reference,in,the,chain,or,code,null,return,the,next,reference,of,code,null;reference,k,v,get,next
ConcurrentReferenceHashMap -> Segment -> public <T> T doTask(final int hash, final Object key, final Task<T> task);1351982790;Apply an update operation to this segment.  The segment will be locked_during update._@param hash the hash of the key_@param key the key_@param task the update operation_@return the result of the operation;public <T> T doTask(final int hash, final Object key, final Task<T> task) {__			boolean resize = task.hasOption(TaskOption.RESIZE)___			if (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {_				restructureIfNecessary(resize)__			}__			if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && (this.count == 0)) {_				return task.execute(null, null, null)__			}__			lock()__			try {_				final int index = getIndex(hash, this.references)__				final Reference<K, V> head = this.references[index]__				Reference<K, V> reference = findInChain(head, key, hash)__				Entry<K, V> entry = (reference == null ? null : reference.get())__				Entries entries = new Entries() {_					@Override_					public void add(V value) {_						@SuppressWarnings("unchecked")_						Entry<K, V> newEntry = new Entry<K, V>((K)key, value)__						Reference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head)__						Segment.this.references[index] = newReference__						Segment.this.count++__					}_				}__				return task.execute(reference, entry, entries)__			} finally {_				unlock()__				if (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {_					restructureIfNecessary(resize)__				}_			}_		};apply,an,update,operation,to,this,segment,the,segment,will,be,locked,during,update,param,hash,the,hash,of,the,key,param,key,the,key,param,task,the,update,operation,return,the,result,of,the,operation;public,t,t,do,task,final,int,hash,final,object,key,final,task,t,task,boolean,resize,task,has,option,task,option,resize,if,task,has,option,task,option,restructure,if,necessary,resize,if,task,has,option,task,option,this,count,0,return,task,execute,null,null,null,lock,try,final,int,index,get,index,hash,this,references,final,reference,k,v,head,this,references,index,reference,k,v,reference,find,in,chain,head,key,hash,entry,k,v,entry,reference,null,null,reference,get,entries,entries,new,entries,override,public,void,add,v,value,suppress,warnings,unchecked,entry,k,v,new,entry,new,entry,k,v,k,key,value,reference,k,v,new,reference,segment,this,reference,manager,create,reference,new,entry,hash,head,segment,this,references,index,new,reference,segment,this,count,return,task,execute,reference,entry,entries,finally,unlock,if,task,has,option,task,option,restructure,if,necessary,resize
ConcurrentReferenceHashMap -> Segment -> public <T> T doTask(final int hash, final Object key, final Task<T> task);1352039846;Apply an update operation to this segment.  The segment will be locked_during update._@param hash the hash of the key_@param key the key_@param task the update operation_@return the result of the operation;public <T> T doTask(final int hash, final Object key, final Task<T> task) {__			boolean resize = task.hasOption(TaskOption.RESIZE)___			if (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {_				restructureIfNecessary(resize)__			}__			if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && (this.count == 0)) {_				return task.execute(null, null, null)__			}__			lock()__			try {_				final int index = getIndex(hash, this.references)__				final Reference<K, V> head = this.references[index]__				Reference<K, V> reference = findInChain(head, key, hash)__				Entry<K, V> entry = (reference == null ? null : reference.get())__				Entries entries = new Entries() {_					@Override_					public void add(V value) {_						@SuppressWarnings("unchecked")_						Entry<K, V> newEntry = new Entry<K, V>((K)key, value)__						Reference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head)__						Segment.this.references[index] = newReference__						Segment.this.count++__					}_				}__				return task.execute(reference, entry, entries)__			} finally {_				unlock()__				if (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {_					restructureIfNecessary(resize)__				}_			}_		};apply,an,update,operation,to,this,segment,the,segment,will,be,locked,during,update,param,hash,the,hash,of,the,key,param,key,the,key,param,task,the,update,operation,return,the,result,of,the,operation;public,t,t,do,task,final,int,hash,final,object,key,final,task,t,task,boolean,resize,task,has,option,task,option,resize,if,task,has,option,task,option,restructure,if,necessary,resize,if,task,has,option,task,option,this,count,0,return,task,execute,null,null,null,lock,try,final,int,index,get,index,hash,this,references,final,reference,k,v,head,this,references,index,reference,k,v,reference,find,in,chain,head,key,hash,entry,k,v,entry,reference,null,null,reference,get,entries,entries,new,entries,override,public,void,add,v,value,suppress,warnings,unchecked,entry,k,v,new,entry,new,entry,k,v,k,key,value,reference,k,v,new,reference,segment,this,reference,manager,create,reference,new,entry,hash,head,segment,this,references,index,new,reference,segment,this,count,return,task,execute,reference,entry,entries,finally,unlock,if,task,has,option,task,option,restructure,if,necessary,resize
ConcurrentReferenceHashMap -> Segment -> public <T> T doTask(final int hash, final Object key, final Task<T> task);1355313310;Apply an update operation to this segment.  The segment will be locked_during update._@param hash the hash of the key_@param key the key_@param task the update operation_@return the result of the operation;public <T> T doTask(final int hash, final Object key, final Task<T> task) {__			boolean resize = task.hasOption(TaskOption.RESIZE)___			if (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {_				restructureIfNecessary(resize)__			}__			if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && (this.count == 0)) {_				return task.execute(null, null, null)__			}__			lock()__			try {_				final int index = getIndex(hash, this.references)__				final Reference<K, V> head = this.references[index]__				Reference<K, V> reference = findInChain(head, key, hash)__				Entry<K, V> entry = (reference == null ? null : reference.get())__				Entries entries = new Entries() {_					@Override_					public void add(V value) {_						@SuppressWarnings("unchecked")_						Entry<K, V> newEntry = new Entry<K, V>((K)key, value)__						Reference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head)__						Segment.this.references[index] = newReference__						Segment.this.count++__					}_				}__				return task.execute(reference, entry, entries)__			} finally {_				unlock()__				if (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {_					restructureIfNecessary(resize)__				}_			}_		};apply,an,update,operation,to,this,segment,the,segment,will,be,locked,during,update,param,hash,the,hash,of,the,key,param,key,the,key,param,task,the,update,operation,return,the,result,of,the,operation;public,t,t,do,task,final,int,hash,final,object,key,final,task,t,task,boolean,resize,task,has,option,task,option,resize,if,task,has,option,task,option,restructure,if,necessary,resize,if,task,has,option,task,option,this,count,0,return,task,execute,null,null,null,lock,try,final,int,index,get,index,hash,this,references,final,reference,k,v,head,this,references,index,reference,k,v,reference,find,in,chain,head,key,hash,entry,k,v,entry,reference,null,null,reference,get,entries,entries,new,entries,override,public,void,add,v,value,suppress,warnings,unchecked,entry,k,v,new,entry,new,entry,k,v,k,key,value,reference,k,v,new,reference,segment,this,reference,manager,create,reference,new,entry,hash,head,segment,this,references,index,new,reference,segment,this,count,return,task,execute,reference,entry,entries,finally,unlock,if,task,has,option,task,option,restructure,if,necessary,resize
ConcurrentReferenceHashMap -> Segment -> public <T> T doTask(final int hash, final Object key, final Task<T> task);1356735495;Apply an update operation to this segment.  The segment will be locked_during update._@param hash the hash of the key_@param key the key_@param task the update operation_@return the result of the operation;public <T> T doTask(final int hash, final Object key, final Task<T> task) {__			boolean resize = task.hasOption(TaskOption.RESIZE)___			if (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {_				restructureIfNecessary(resize)__			}__			if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && (this.count == 0)) {_				return task.execute(null, null, null)__			}__			lock()__			try {_				final int index = getIndex(hash, this.references)__				final Reference<K, V> head = this.references[index]__				Reference<K, V> reference = findInChain(head, key, hash)__				Entry<K, V> entry = (reference == null ? null : reference.get())__				Entries entries = new Entries() {_					@Override_					public void add(V value) {_						@SuppressWarnings("unchecked")_						Entry<K, V> newEntry = new Entry<K, V>((K)key, value)__						Reference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head)__						Segment.this.references[index] = newReference__						Segment.this.count++__					}_				}__				return task.execute(reference, entry, entries)__			} finally {_				unlock()__				if (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {_					restructureIfNecessary(resize)__				}_			}_		};apply,an,update,operation,to,this,segment,the,segment,will,be,locked,during,update,param,hash,the,hash,of,the,key,param,key,the,key,param,task,the,update,operation,return,the,result,of,the,operation;public,t,t,do,task,final,int,hash,final,object,key,final,task,t,task,boolean,resize,task,has,option,task,option,resize,if,task,has,option,task,option,restructure,if,necessary,resize,if,task,has,option,task,option,this,count,0,return,task,execute,null,null,null,lock,try,final,int,index,get,index,hash,this,references,final,reference,k,v,head,this,references,index,reference,k,v,reference,find,in,chain,head,key,hash,entry,k,v,entry,reference,null,null,reference,get,entries,entries,new,entries,override,public,void,add,v,value,suppress,warnings,unchecked,entry,k,v,new,entry,new,entry,k,v,k,key,value,reference,k,v,new,reference,segment,this,reference,manager,create,reference,new,entry,hash,head,segment,this,references,index,new,reference,segment,this,count,return,task,execute,reference,entry,entries,finally,unlock,if,task,has,option,task,option,restructure,if,necessary,resize
ConcurrentReferenceHashMap -> Segment -> public <T> T doTask(final int hash, final Object key, final Task<T> task);1357119239;Apply an update operation to this segment.  The segment will be locked_during update._@param hash the hash of the key_@param key the key_@param task the update operation_@return the result of the operation;public <T> T doTask(final int hash, final Object key, final Task<T> task) {__			boolean resize = task.hasOption(TaskOption.RESIZE)___			if (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {_				restructureIfNecessary(resize)__			}__			if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && (this.count == 0)) {_				return task.execute(null, null, null)__			}__			lock()__			try {_				final int index = getIndex(hash, this.references)__				final Reference<K, V> head = this.references[index]__				Reference<K, V> reference = findInChain(head, key, hash)__				Entry<K, V> entry = (reference == null ? null : reference.get())__				Entries entries = new Entries() {_					@Override_					public void add(V value) {_						@SuppressWarnings("unchecked")_						Entry<K, V> newEntry = new Entry<K, V>((K)key, value)__						Reference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head)__						Segment.this.references[index] = newReference__						Segment.this.count++__					}_				}__				return task.execute(reference, entry, entries)__			} finally {_				unlock()__				if (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {_					restructureIfNecessary(resize)__				}_			}_		};apply,an,update,operation,to,this,segment,the,segment,will,be,locked,during,update,param,hash,the,hash,of,the,key,param,key,the,key,param,task,the,update,operation,return,the,result,of,the,operation;public,t,t,do,task,final,int,hash,final,object,key,final,task,t,task,boolean,resize,task,has,option,task,option,resize,if,task,has,option,task,option,restructure,if,necessary,resize,if,task,has,option,task,option,this,count,0,return,task,execute,null,null,null,lock,try,final,int,index,get,index,hash,this,references,final,reference,k,v,head,this,references,index,reference,k,v,reference,find,in,chain,head,key,hash,entry,k,v,entry,reference,null,null,reference,get,entries,entries,new,entries,override,public,void,add,v,value,suppress,warnings,unchecked,entry,k,v,new,entry,new,entry,k,v,k,key,value,reference,k,v,new,reference,segment,this,reference,manager,create,reference,new,entry,hash,head,segment,this,references,index,new,reference,segment,this,count,return,task,execute,reference,entry,entries,finally,unlock,if,task,has,option,task,option,restructure,if,necessary,resize
ConcurrentReferenceHashMap -> Segment -> public <T> T doTask(final int hash, final Object key, final Task<T> task);1368482696;Apply an update operation to this segment.  The segment will be locked_during update._@param hash the hash of the key_@param key the key_@param task the update operation_@return the result of the operation;public <T> T doTask(final int hash, final Object key, final Task<T> task) {__			boolean resize = task.hasOption(TaskOption.RESIZE)___			if (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {_				restructureIfNecessary(resize)__			}__			if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && (this.count == 0)) {_				return task.execute(null, null, null)__			}__			lock()__			try {_				final int index = getIndex(hash, this.references)__				final Reference<K, V> head = this.references[index]__				Reference<K, V> reference = findInChain(head, key, hash)__				Entry<K, V> entry = (reference == null ? null : reference.get())__				Entries entries = new Entries() {_					@Override_					public void add(V value) {_						@SuppressWarnings("unchecked")_						Entry<K, V> newEntry = new Entry<K, V>((K)key, value)__						Reference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head)__						Segment.this.references[index] = newReference__						Segment.this.count++__					}_				}__				return task.execute(reference, entry, entries)__			} finally {_				unlock()__				if (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {_					restructureIfNecessary(resize)__				}_			}_		};apply,an,update,operation,to,this,segment,the,segment,will,be,locked,during,update,param,hash,the,hash,of,the,key,param,key,the,key,param,task,the,update,operation,return,the,result,of,the,operation;public,t,t,do,task,final,int,hash,final,object,key,final,task,t,task,boolean,resize,task,has,option,task,option,resize,if,task,has,option,task,option,restructure,if,necessary,resize,if,task,has,option,task,option,this,count,0,return,task,execute,null,null,null,lock,try,final,int,index,get,index,hash,this,references,final,reference,k,v,head,this,references,index,reference,k,v,reference,find,in,chain,head,key,hash,entry,k,v,entry,reference,null,null,reference,get,entries,entries,new,entries,override,public,void,add,v,value,suppress,warnings,unchecked,entry,k,v,new,entry,new,entry,k,v,k,key,value,reference,k,v,new,reference,segment,this,reference,manager,create,reference,new,entry,hash,head,segment,this,references,index,new,reference,segment,this,count,return,task,execute,reference,entry,entries,finally,unlock,if,task,has,option,task,option,restructure,if,necessary,resize
ConcurrentReferenceHashMap -> Segment -> public <T> T doTask(final int hash, final Object key, final Task<T> task);1383090835;Apply an update operation to this segment.  The segment will be locked_during update._@param hash the hash of the key_@param key the key_@param task the update operation_@return the result of the operation;public <T> T doTask(final int hash, final Object key, final Task<T> task) {_			boolean resize = task.hasOption(TaskOption.RESIZE)__			if (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {_				restructureIfNecessary(resize)__			}_			if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && (this.count == 0)) {_				return task.execute(null, null, null)__			}_			lock()__			try {_				final int index = getIndex(hash, this.references)__				final Reference<K, V> head = this.references[index]__				Reference<K, V> reference = findInChain(head, key, hash)__				Entry<K, V> entry = (reference == null ? null : reference.get())__				Entries entries = new Entries() {_					@Override_					public void add(V value) {_						@SuppressWarnings("unchecked")_						Entry<K, V> newEntry = new Entry<K, V>((K)key, value)__						Reference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head)__						Segment.this.references[index] = newReference__						Segment.this.count++__					}_				}__				return task.execute(reference, entry, entries)__			}_			finally {_				unlock()__				if (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {_					restructureIfNecessary(resize)__				}_			}_		};apply,an,update,operation,to,this,segment,the,segment,will,be,locked,during,update,param,hash,the,hash,of,the,key,param,key,the,key,param,task,the,update,operation,return,the,result,of,the,operation;public,t,t,do,task,final,int,hash,final,object,key,final,task,t,task,boolean,resize,task,has,option,task,option,resize,if,task,has,option,task,option,restructure,if,necessary,resize,if,task,has,option,task,option,this,count,0,return,task,execute,null,null,null,lock,try,final,int,index,get,index,hash,this,references,final,reference,k,v,head,this,references,index,reference,k,v,reference,find,in,chain,head,key,hash,entry,k,v,entry,reference,null,null,reference,get,entries,entries,new,entries,override,public,void,add,v,value,suppress,warnings,unchecked,entry,k,v,new,entry,new,entry,k,v,k,key,value,reference,k,v,new,reference,segment,this,reference,manager,create,reference,new,entry,hash,head,segment,this,references,index,new,reference,segment,this,count,return,task,execute,reference,entry,entries,finally,unlock,if,task,has,option,task,option,restructure,if,necessary,resize
ConcurrentReferenceHashMap -> Segment -> public <T> T doTask(final int hash, final Object key, final Task<T> task);1383178438;Apply an update operation to this segment.  The segment will be locked_during update._@param hash the hash of the key_@param key the key_@param task the update operation_@return the result of the operation;public <T> T doTask(final int hash, final Object key, final Task<T> task) {_			boolean resize = task.hasOption(TaskOption.RESIZE)__			if (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {_				restructureIfNecessary(resize)__			}_			if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && (this.count == 0)) {_				return task.execute(null, null, null)__			}_			lock()__			try {_				final int index = getIndex(hash, this.references)__				final Reference<K, V> head = this.references[index]__				Reference<K, V> reference = findInChain(head, key, hash)__				Entry<K, V> entry = (reference == null ? null : reference.get())__				Entries entries = new Entries() {_					@Override_					public void add(V value) {_						@SuppressWarnings("unchecked")_						Entry<K, V> newEntry = new Entry<K, V>((K)key, value)__						Reference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head)__						Segment.this.references[index] = newReference__						Segment.this.count++__					}_				}__				return task.execute(reference, entry, entries)__			}_			finally {_				unlock()__				if (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {_					restructureIfNecessary(resize)__				}_			}_		};apply,an,update,operation,to,this,segment,the,segment,will,be,locked,during,update,param,hash,the,hash,of,the,key,param,key,the,key,param,task,the,update,operation,return,the,result,of,the,operation;public,t,t,do,task,final,int,hash,final,object,key,final,task,t,task,boolean,resize,task,has,option,task,option,resize,if,task,has,option,task,option,restructure,if,necessary,resize,if,task,has,option,task,option,this,count,0,return,task,execute,null,null,null,lock,try,final,int,index,get,index,hash,this,references,final,reference,k,v,head,this,references,index,reference,k,v,reference,find,in,chain,head,key,hash,entry,k,v,entry,reference,null,null,reference,get,entries,entries,new,entries,override,public,void,add,v,value,suppress,warnings,unchecked,entry,k,v,new,entry,new,entry,k,v,k,key,value,reference,k,v,new,reference,segment,this,reference,manager,create,reference,new,entry,hash,head,segment,this,references,index,new,reference,segment,this,count,return,task,execute,reference,entry,entries,finally,unlock,if,task,has,option,task,option,restructure,if,necessary,resize
ConcurrentReferenceHashMap -> Segment -> public <T> T doTask(final int hash, final Object key, final Task<T> task);1390260938;Apply an update operation to this segment.  The segment will be locked_during update._@param hash the hash of the key_@param key the key_@param task the update operation_@return the result of the operation;public <T> T doTask(final int hash, final Object key, final Task<T> task) {_			boolean resize = task.hasOption(TaskOption.RESIZE)__			if (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {_				restructureIfNecessary(resize)__			}_			if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && (this.count == 0)) {_				return task.execute(null, null, null)__			}_			lock()__			try {_				final int index = getIndex(hash, this.references)__				final Reference<K, V> head = this.references[index]__				Reference<K, V> reference = findInChain(head, key, hash)__				Entry<K, V> entry = (reference == null ? null : reference.get())__				Entries entries = new Entries() {_					@Override_					public void add(V value) {_						@SuppressWarnings("unchecked")_						Entry<K, V> newEntry = new Entry<K, V>((K)key, value)__						Reference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head)__						Segment.this.references[index] = newReference__						Segment.this.count++__					}_				}__				return task.execute(reference, entry, entries)__			}_			finally {_				unlock()__				if (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {_					restructureIfNecessary(resize)__				}_			}_		};apply,an,update,operation,to,this,segment,the,segment,will,be,locked,during,update,param,hash,the,hash,of,the,key,param,key,the,key,param,task,the,update,operation,return,the,result,of,the,operation;public,t,t,do,task,final,int,hash,final,object,key,final,task,t,task,boolean,resize,task,has,option,task,option,resize,if,task,has,option,task,option,restructure,if,necessary,resize,if,task,has,option,task,option,this,count,0,return,task,execute,null,null,null,lock,try,final,int,index,get,index,hash,this,references,final,reference,k,v,head,this,references,index,reference,k,v,reference,find,in,chain,head,key,hash,entry,k,v,entry,reference,null,null,reference,get,entries,entries,new,entries,override,public,void,add,v,value,suppress,warnings,unchecked,entry,k,v,new,entry,new,entry,k,v,k,key,value,reference,k,v,new,reference,segment,this,reference,manager,create,reference,new,entry,hash,head,segment,this,references,index,new,reference,segment,this,count,return,task,execute,reference,entry,entries,finally,unlock,if,task,has,option,task,option,restructure,if,necessary,resize
ConcurrentReferenceHashMap -> Segment -> public <T> T doTask(final int hash, final Object key, final Task<T> task);1391715359;Apply an update operation to this segment.  The segment will be locked_during update._@param hash the hash of the key_@param key the key_@param task the update operation_@return the result of the operation;public <T> T doTask(final int hash, final Object key, final Task<T> task) {_			boolean resize = task.hasOption(TaskOption.RESIZE)__			if (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {_				restructureIfNecessary(resize)__			}_			if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && (this.count == 0)) {_				return task.execute(null, null, null)__			}_			lock()__			try {_				final int index = getIndex(hash, this.references)__				final Reference<K, V> head = this.references[index]__				Reference<K, V> reference = findInChain(head, key, hash)__				Entry<K, V> entry = (reference == null ? null : reference.get())__				Entries entries = new Entries() {_					@Override_					public void add(V value) {_						@SuppressWarnings("unchecked")_						Entry<K, V> newEntry = new Entry<K, V>((K)key, value)__						Reference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head)__						Segment.this.references[index] = newReference__						Segment.this.count++__					}_				}__				return task.execute(reference, entry, entries)__			}_			finally {_				unlock()__				if (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {_					restructureIfNecessary(resize)__				}_			}_		};apply,an,update,operation,to,this,segment,the,segment,will,be,locked,during,update,param,hash,the,hash,of,the,key,param,key,the,key,param,task,the,update,operation,return,the,result,of,the,operation;public,t,t,do,task,final,int,hash,final,object,key,final,task,t,task,boolean,resize,task,has,option,task,option,resize,if,task,has,option,task,option,restructure,if,necessary,resize,if,task,has,option,task,option,this,count,0,return,task,execute,null,null,null,lock,try,final,int,index,get,index,hash,this,references,final,reference,k,v,head,this,references,index,reference,k,v,reference,find,in,chain,head,key,hash,entry,k,v,entry,reference,null,null,reference,get,entries,entries,new,entries,override,public,void,add,v,value,suppress,warnings,unchecked,entry,k,v,new,entry,new,entry,k,v,k,key,value,reference,k,v,new,reference,segment,this,reference,manager,create,reference,new,entry,hash,head,segment,this,references,index,new,reference,segment,this,count,return,task,execute,reference,entry,entries,finally,unlock,if,task,has,option,task,option,restructure,if,necessary,resize
ConcurrentReferenceHashMap -> Segment -> public <T> T doTask(final int hash, final Object key, final Task<T> task);1392765030;Apply an update operation to this segment.  The segment will be locked_during update._@param hash the hash of the key_@param key the key_@param task the update operation_@return the result of the operation;public <T> T doTask(final int hash, final Object key, final Task<T> task) {_			boolean resize = task.hasOption(TaskOption.RESIZE)__			if (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {_				restructureIfNecessary(resize)__			}_			if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && (this.count == 0)) {_				return task.execute(null, null, null)__			}_			lock()__			try {_				final int index = getIndex(hash, this.references)__				final Reference<K, V> head = this.references[index]__				Reference<K, V> reference = findInChain(head, key, hash)__				Entry<K, V> entry = (reference == null ? null : reference.get())__				Entries entries = new Entries() {_					@Override_					public void add(V value) {_						@SuppressWarnings("unchecked")_						Entry<K, V> newEntry = new Entry<K, V>((K)key, value)__						Reference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head)__						Segment.this.references[index] = newReference__						Segment.this.count++__					}_				}__				return task.execute(reference, entry, entries)__			}_			finally {_				unlock()__				if (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {_					restructureIfNecessary(resize)__				}_			}_		};apply,an,update,operation,to,this,segment,the,segment,will,be,locked,during,update,param,hash,the,hash,of,the,key,param,key,the,key,param,task,the,update,operation,return,the,result,of,the,operation;public,t,t,do,task,final,int,hash,final,object,key,final,task,t,task,boolean,resize,task,has,option,task,option,resize,if,task,has,option,task,option,restructure,if,necessary,resize,if,task,has,option,task,option,this,count,0,return,task,execute,null,null,null,lock,try,final,int,index,get,index,hash,this,references,final,reference,k,v,head,this,references,index,reference,k,v,reference,find,in,chain,head,key,hash,entry,k,v,entry,reference,null,null,reference,get,entries,entries,new,entries,override,public,void,add,v,value,suppress,warnings,unchecked,entry,k,v,new,entry,new,entry,k,v,k,key,value,reference,k,v,new,reference,segment,this,reference,manager,create,reference,new,entry,hash,head,segment,this,references,index,new,reference,segment,this,count,return,task,execute,reference,entry,entries,finally,unlock,if,task,has,option,task,option,restructure,if,necessary,resize
ConcurrentReferenceHashMap -> Segment -> public <T> T doTask(final int hash, final Object key, final Task<T> task);1398175099;Apply an update operation to this segment.  The segment will be locked_during update._@param hash the hash of the key_@param key the key_@param task the update operation_@return the result of the operation;public <T> T doTask(final int hash, final Object key, final Task<T> task) {_			boolean resize = task.hasOption(TaskOption.RESIZE)__			if (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {_				restructureIfNecessary(resize)__			}_			if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && (this.count == 0)) {_				return task.execute(null, null, null)__			}_			lock()__			try {_				final int index = getIndex(hash, this.references)__				final Reference<K, V> head = this.references[index]__				Reference<K, V> reference = findInChain(head, key, hash)__				Entry<K, V> entry = (reference == null ? null : reference.get())__				Entries entries = new Entries() {_					@Override_					public void add(V value) {_						@SuppressWarnings("unchecked")_						Entry<K, V> newEntry = new Entry<K, V>((K)key, value)__						Reference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head)__						Segment.this.references[index] = newReference__						Segment.this.count++__					}_				}__				return task.execute(reference, entry, entries)__			}_			finally {_				unlock()__				if (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {_					restructureIfNecessary(resize)__				}_			}_		};apply,an,update,operation,to,this,segment,the,segment,will,be,locked,during,update,param,hash,the,hash,of,the,key,param,key,the,key,param,task,the,update,operation,return,the,result,of,the,operation;public,t,t,do,task,final,int,hash,final,object,key,final,task,t,task,boolean,resize,task,has,option,task,option,resize,if,task,has,option,task,option,restructure,if,necessary,resize,if,task,has,option,task,option,this,count,0,return,task,execute,null,null,null,lock,try,final,int,index,get,index,hash,this,references,final,reference,k,v,head,this,references,index,reference,k,v,reference,find,in,chain,head,key,hash,entry,k,v,entry,reference,null,null,reference,get,entries,entries,new,entries,override,public,void,add,v,value,suppress,warnings,unchecked,entry,k,v,new,entry,new,entry,k,v,k,key,value,reference,k,v,new,reference,segment,this,reference,manager,create,reference,new,entry,hash,head,segment,this,references,index,new,reference,segment,this,count,return,task,execute,reference,entry,entries,finally,unlock,if,task,has,option,task,option,restructure,if,necessary,resize
ConcurrentReferenceHashMap -> Segment -> public <T> T doTask(final int hash, final Object key, final Task<T> task);1404132943;Apply an update operation to this segment._The segment will be locked during the update._@param hash the hash of the key_@param key the key_@param task the update operation_@return the result of the operation;public <T> T doTask(final int hash, final Object key, final Task<T> task) {_			boolean resize = task.hasOption(TaskOption.RESIZE)__			if (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {_				restructureIfNecessary(resize)__			}_			if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && this.count == 0) {_				return task.execute(null, null, null)__			}_			lock()__			try {_				final int index = getIndex(hash, this.references)__				final Reference<K, V> head = this.references[index]__				Reference<K, V> reference = findInChain(head, key, hash)__				Entry<K, V> entry = (reference != null ? reference.get() : null)__				Entries entries = new Entries() {_					@Override_					public void add(V value) {_						@SuppressWarnings("unchecked")_						Entry<K, V> newEntry = new Entry<K, V>((K) key, value)__						Reference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head)__						Segment.this.references[index] = newReference__						Segment.this.count++__					}_				}__				return task.execute(reference, entry, entries)__			}_			finally {_				unlock()__				if (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {_					restructureIfNecessary(resize)__				}_			}_		};apply,an,update,operation,to,this,segment,the,segment,will,be,locked,during,the,update,param,hash,the,hash,of,the,key,param,key,the,key,param,task,the,update,operation,return,the,result,of,the,operation;public,t,t,do,task,final,int,hash,final,object,key,final,task,t,task,boolean,resize,task,has,option,task,option,resize,if,task,has,option,task,option,restructure,if,necessary,resize,if,task,has,option,task,option,this,count,0,return,task,execute,null,null,null,lock,try,final,int,index,get,index,hash,this,references,final,reference,k,v,head,this,references,index,reference,k,v,reference,find,in,chain,head,key,hash,entry,k,v,entry,reference,null,reference,get,null,entries,entries,new,entries,override,public,void,add,v,value,suppress,warnings,unchecked,entry,k,v,new,entry,new,entry,k,v,k,key,value,reference,k,v,new,reference,segment,this,reference,manager,create,reference,new,entry,hash,head,segment,this,references,index,new,reference,segment,this,count,return,task,execute,reference,entry,entries,finally,unlock,if,task,has,option,task,option,restructure,if,necessary,resize
ConcurrentReferenceHashMap -> Segment -> public <T> T doTask(final int hash, final Object key, final Task<T> task);1427240641;Apply an update operation to this segment._The segment will be locked during the update._@param hash the hash of the key_@param key the key_@param task the update operation_@return the result of the operation;public <T> T doTask(final int hash, final Object key, final Task<T> task) {_			boolean resize = task.hasOption(TaskOption.RESIZE)__			if (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {_				restructureIfNecessary(resize)__			}_			if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && this.count == 0) {_				return task.execute(null, null, null)__			}_			lock()__			try {_				final int index = getIndex(hash, this.references)__				final Reference<K, V> head = this.references[index]__				Reference<K, V> reference = findInChain(head, key, hash)__				Entry<K, V> entry = (reference != null ? reference.get() : null)__				Entries entries = new Entries() {_					@Override_					public void add(V value) {_						@SuppressWarnings("unchecked")_						Entry<K, V> newEntry = new Entry<K, V>((K) key, value)__						Reference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head)__						Segment.this.references[index] = newReference__						Segment.this.count++__					}_				}__				return task.execute(reference, entry, entries)__			}_			finally {_				unlock()__				if (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {_					restructureIfNecessary(resize)__				}_			}_		};apply,an,update,operation,to,this,segment,the,segment,will,be,locked,during,the,update,param,hash,the,hash,of,the,key,param,key,the,key,param,task,the,update,operation,return,the,result,of,the,operation;public,t,t,do,task,final,int,hash,final,object,key,final,task,t,task,boolean,resize,task,has,option,task,option,resize,if,task,has,option,task,option,restructure,if,necessary,resize,if,task,has,option,task,option,this,count,0,return,task,execute,null,null,null,lock,try,final,int,index,get,index,hash,this,references,final,reference,k,v,head,this,references,index,reference,k,v,reference,find,in,chain,head,key,hash,entry,k,v,entry,reference,null,reference,get,null,entries,entries,new,entries,override,public,void,add,v,value,suppress,warnings,unchecked,entry,k,v,new,entry,new,entry,k,v,k,key,value,reference,k,v,new,reference,segment,this,reference,manager,create,reference,new,entry,hash,head,segment,this,references,index,new,reference,segment,this,count,return,task,execute,reference,entry,entries,finally,unlock,if,task,has,option,task,option,restructure,if,necessary,resize
ConcurrentReferenceHashMap -> Segment -> public <T> T doTask(final int hash, final Object key, final Task<T> task);1459795890;Apply an update operation to this segment._The segment will be locked during the update._@param hash the hash of the key_@param key the key_@param task the update operation_@return the result of the operation;public <T> T doTask(final int hash, final Object key, final Task<T> task) {_			boolean resize = task.hasOption(TaskOption.RESIZE)__			if (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {_				restructureIfNecessary(resize)__			}_			if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && this.count == 0) {_				return task.execute(null, null, null)__			}_			lock()__			try {_				final int index = getIndex(hash, this.references)__				final Reference<K, V> head = this.references[index]__				Reference<K, V> reference = findInChain(head, key, hash)__				Entry<K, V> entry = (reference != null ? reference.get() : null)__				Entries entries = new Entries() {_					@Override_					public void add(V value) {_						@SuppressWarnings("unchecked")_						Entry<K, V> newEntry = new Entry<K, V>((K) key, value)__						Reference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head)__						Segment.this.references[index] = newReference__						Segment.this.count++__					}_				}__				return task.execute(reference, entry, entries)__			}_			finally {_				unlock()__				if (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {_					restructureIfNecessary(resize)__				}_			}_		};apply,an,update,operation,to,this,segment,the,segment,will,be,locked,during,the,update,param,hash,the,hash,of,the,key,param,key,the,key,param,task,the,update,operation,return,the,result,of,the,operation;public,t,t,do,task,final,int,hash,final,object,key,final,task,t,task,boolean,resize,task,has,option,task,option,resize,if,task,has,option,task,option,restructure,if,necessary,resize,if,task,has,option,task,option,this,count,0,return,task,execute,null,null,null,lock,try,final,int,index,get,index,hash,this,references,final,reference,k,v,head,this,references,index,reference,k,v,reference,find,in,chain,head,key,hash,entry,k,v,entry,reference,null,reference,get,null,entries,entries,new,entries,override,public,void,add,v,value,suppress,warnings,unchecked,entry,k,v,new,entry,new,entry,k,v,k,key,value,reference,k,v,new,reference,segment,this,reference,manager,create,reference,new,entry,hash,head,segment,this,references,index,new,reference,segment,this,count,return,task,execute,reference,entry,entries,finally,unlock,if,task,has,option,task,option,restructure,if,necessary,resize
ConcurrentReferenceHashMap -> Segment -> public <T> T doTask(final int hash, final Object key, final Task<T> task);1467730834;Apply an update operation to this segment._The segment will be locked during the update._@param hash the hash of the key_@param key the key_@param task the update operation_@return the result of the operation;public <T> T doTask(final int hash, final Object key, final Task<T> task) {_			boolean resize = task.hasOption(TaskOption.RESIZE)__			if (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {_				restructureIfNecessary(resize)__			}_			if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && this.count == 0) {_				return task.execute(null, null, null)__			}_			lock()__			try {_				final int index = getIndex(hash, this.references)__				final Reference<K, V> head = this.references[index]__				Reference<K, V> reference = findInChain(head, key, hash)__				Entry<K, V> entry = (reference != null ? reference.get() : null)__				Entries entries = new Entries() {_					@Override_					public void add(V value) {_						@SuppressWarnings("unchecked")_						Entry<K, V> newEntry = new Entry<>((K) key, value)__						Reference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head)__						Segment.this.references[index] = newReference__						Segment.this.count++__					}_				}__				return task.execute(reference, entry, entries)__			}_			finally {_				unlock()__				if (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {_					restructureIfNecessary(resize)__				}_			}_		};apply,an,update,operation,to,this,segment,the,segment,will,be,locked,during,the,update,param,hash,the,hash,of,the,key,param,key,the,key,param,task,the,update,operation,return,the,result,of,the,operation;public,t,t,do,task,final,int,hash,final,object,key,final,task,t,task,boolean,resize,task,has,option,task,option,resize,if,task,has,option,task,option,restructure,if,necessary,resize,if,task,has,option,task,option,this,count,0,return,task,execute,null,null,null,lock,try,final,int,index,get,index,hash,this,references,final,reference,k,v,head,this,references,index,reference,k,v,reference,find,in,chain,head,key,hash,entry,k,v,entry,reference,null,reference,get,null,entries,entries,new,entries,override,public,void,add,v,value,suppress,warnings,unchecked,entry,k,v,new,entry,new,entry,k,key,value,reference,k,v,new,reference,segment,this,reference,manager,create,reference,new,entry,hash,head,segment,this,references,index,new,reference,segment,this,count,return,task,execute,reference,entry,entries,finally,unlock,if,task,has,option,task,option,restructure,if,necessary,resize
ConcurrentReferenceHashMap -> Segment -> public <T> T doTask(final int hash, final Object key, final Task<T> task);1485810955;Apply an update operation to this segment._The segment will be locked during the update._@param hash the hash of the key_@param key the key_@param task the update operation_@return the result of the operation;public <T> T doTask(final int hash, final Object key, final Task<T> task) {_			boolean resize = task.hasOption(TaskOption.RESIZE)__			if (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {_				restructureIfNecessary(resize)__			}_			if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && this.count == 0) {_				return task.execute(null, null, null)__			}_			lock()__			try {_				final int index = getIndex(hash, this.references)__				final Reference<K, V> head = this.references[index]__				Reference<K, V> reference = findInChain(head, key, hash)__				Entry<K, V> entry = (reference != null ? reference.get() : null)__				Entries entries = new Entries() {_					@Override_					public void add(V value) {_						@SuppressWarnings("unchecked")_						Entry<K, V> newEntry = new Entry<>((K) key, value)__						Reference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head)__						Segment.this.references[index] = newReference__						Segment.this.count++__					}_				}__				return task.execute(reference, entry, entries)__			}_			finally {_				unlock()__				if (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {_					restructureIfNecessary(resize)__				}_			}_		};apply,an,update,operation,to,this,segment,the,segment,will,be,locked,during,the,update,param,hash,the,hash,of,the,key,param,key,the,key,param,task,the,update,operation,return,the,result,of,the,operation;public,t,t,do,task,final,int,hash,final,object,key,final,task,t,task,boolean,resize,task,has,option,task,option,resize,if,task,has,option,task,option,restructure,if,necessary,resize,if,task,has,option,task,option,this,count,0,return,task,execute,null,null,null,lock,try,final,int,index,get,index,hash,this,references,final,reference,k,v,head,this,references,index,reference,k,v,reference,find,in,chain,head,key,hash,entry,k,v,entry,reference,null,reference,get,null,entries,entries,new,entries,override,public,void,add,v,value,suppress,warnings,unchecked,entry,k,v,new,entry,new,entry,k,key,value,reference,k,v,new,reference,segment,this,reference,manager,create,reference,new,entry,hash,head,segment,this,references,index,new,reference,segment,this,count,return,task,execute,reference,entry,entries,finally,unlock,if,task,has,option,task,option,restructure,if,necessary,resize
ConcurrentReferenceHashMap -> Segment -> public <T> T doTask(final int hash, final Object key, final Task<T> task);1495868221;Apply an update operation to this segment._The segment will be locked during the update._@param hash the hash of the key_@param key the key_@param task the update operation_@return the result of the operation;public <T> T doTask(final int hash, final Object key, final Task<T> task) {_			boolean resize = task.hasOption(TaskOption.RESIZE)__			if (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {_				restructureIfNecessary(resize)__			}_			if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && this.count == 0) {_				return task.execute(null, null, null)__			}_			lock()__			try {_				final int index = getIndex(hash, this.references)__				final Reference<K, V> head = this.references[index]__				Reference<K, V> reference = findInChain(head, key, hash)__				Entry<K, V> entry = (reference != null ? reference.get() : null)__				Entries entries = new Entries() {_					@Override_					public void add(V value) {_						@SuppressWarnings("unchecked")_						Entry<K, V> newEntry = new Entry<>((K) key, value)__						Reference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head)__						Segment.this.references[index] = newReference__						Segment.this.count++__					}_				}__				return task.execute(reference, entry, entries)__			}_			finally {_				unlock()__				if (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {_					restructureIfNecessary(resize)__				}_			}_		};apply,an,update,operation,to,this,segment,the,segment,will,be,locked,during,the,update,param,hash,the,hash,of,the,key,param,key,the,key,param,task,the,update,operation,return,the,result,of,the,operation;public,t,t,do,task,final,int,hash,final,object,key,final,task,t,task,boolean,resize,task,has,option,task,option,resize,if,task,has,option,task,option,restructure,if,necessary,resize,if,task,has,option,task,option,this,count,0,return,task,execute,null,null,null,lock,try,final,int,index,get,index,hash,this,references,final,reference,k,v,head,this,references,index,reference,k,v,reference,find,in,chain,head,key,hash,entry,k,v,entry,reference,null,reference,get,null,entries,entries,new,entries,override,public,void,add,v,value,suppress,warnings,unchecked,entry,k,v,new,entry,new,entry,k,key,value,reference,k,v,new,reference,segment,this,reference,manager,create,reference,new,entry,hash,head,segment,this,references,index,new,reference,segment,this,count,return,task,execute,reference,entry,entries,finally,unlock,if,task,has,option,task,option,restructure,if,necessary,resize
ConcurrentReferenceHashMap -> Segment -> public <T> T doTask(final int hash, final Object key, final Task<T> task);1496242568;Apply an update operation to this segment._The segment will be locked during the update._@param hash the hash of the key_@param key the key_@param task the update operation_@return the result of the operation;public <T> T doTask(final int hash, final Object key, final Task<T> task) {_			boolean resize = task.hasOption(TaskOption.RESIZE)__			if (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {_				restructureIfNecessary(resize)__			}_			if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && this.count == 0) {_				return task.execute(null, null, null)__			}_			lock()__			try {_				final int index = getIndex(hash, this.references)__				final Reference<K, V> head = this.references[index]__				Reference<K, V> reference = findInChain(head, key, hash)__				Entry<K, V> entry = (reference != null ? reference.get() : null)__				Entries entries = new Entries() {_					@Override_					public void add(V value) {_						@SuppressWarnings("unchecked")_						Entry<K, V> newEntry = new Entry<>((K) key, value)__						Reference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head)__						Segment.this.references[index] = newReference__						Segment.this.count++__					}_				}__				return task.execute(reference, entry, entries)__			}_			finally {_				unlock()__				if (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {_					restructureIfNecessary(resize)__				}_			}_		};apply,an,update,operation,to,this,segment,the,segment,will,be,locked,during,the,update,param,hash,the,hash,of,the,key,param,key,the,key,param,task,the,update,operation,return,the,result,of,the,operation;public,t,t,do,task,final,int,hash,final,object,key,final,task,t,task,boolean,resize,task,has,option,task,option,resize,if,task,has,option,task,option,restructure,if,necessary,resize,if,task,has,option,task,option,this,count,0,return,task,execute,null,null,null,lock,try,final,int,index,get,index,hash,this,references,final,reference,k,v,head,this,references,index,reference,k,v,reference,find,in,chain,head,key,hash,entry,k,v,entry,reference,null,reference,get,null,entries,entries,new,entries,override,public,void,add,v,value,suppress,warnings,unchecked,entry,k,v,new,entry,new,entry,k,key,value,reference,k,v,new,reference,segment,this,reference,manager,create,reference,new,entry,hash,head,segment,this,references,index,new,reference,segment,this,count,return,task,execute,reference,entry,entries,finally,unlock,if,task,has,option,task,option,restructure,if,necessary,resize
ConcurrentReferenceHashMap -> protected int getHash(@Nullable Object o);1495868221;Get the hash for a given object, apply an additional hash function to reduce_collisions. This implementation uses the same Wang/Jenkins algorithm as_{@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing._@param o the object to hash (may be null)_@return the resulting hash code;protected int getHash(@Nullable Object o) {_		int hash = o == null ? 0 : o.hashCode()__		hash += (hash << 15) ^ 0xffffcd7d__		hash ^= (hash >>> 10)__		hash += (hash << 3)__		hash ^= (hash >>> 6)__		hash += (hash << 2) + (hash << 14)__		hash ^= (hash >>> 16)__		return hash__	};get,the,hash,for,a,given,object,apply,an,additional,hash,function,to,reduce,collisions,this,implementation,uses,the,same,wang,jenkins,algorithm,as,link,concurrent,hash,map,subclasses,can,override,to,provide,alternative,hashing,param,o,the,object,to,hash,may,be,null,return,the,resulting,hash,code;protected,int,get,hash,nullable,object,o,int,hash,o,null,0,o,hash,code,hash,hash,15,0xffffcd7d,hash,hash,10,hash,hash,3,hash,hash,6,hash,hash,2,hash,14,hash,hash,16,return,hash
ConcurrentReferenceHashMap -> protected int getHash(@Nullable Object o);1496242568;Get the hash for a given object, apply an additional hash function to reduce_collisions. This implementation uses the same Wang/Jenkins algorithm as_{@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing._@param o the object to hash (may be null)_@return the resulting hash code;protected int getHash(@Nullable Object o) {_		int hash = o == null ? 0 : o.hashCode()__		hash += (hash << 15) ^ 0xffffcd7d__		hash ^= (hash >>> 10)__		hash += (hash << 3)__		hash ^= (hash >>> 6)__		hash += (hash << 2) + (hash << 14)__		hash ^= (hash >>> 16)__		return hash__	};get,the,hash,for,a,given,object,apply,an,additional,hash,function,to,reduce,collisions,this,implementation,uses,the,same,wang,jenkins,algorithm,as,link,concurrent,hash,map,subclasses,can,override,to,provide,alternative,hashing,param,o,the,object,to,hash,may,be,null,return,the,resulting,hash,code;protected,int,get,hash,nullable,object,o,int,hash,o,null,0,o,hash,code,hash,hash,15,0xffffcd7d,hash,hash,10,hash,hash,3,hash,hash,6,hash,hash,2,hash,14,hash,hash,16,return,hash
ConcurrentReferenceHashMap -> protected int getHash(@Nullable Object o);1496837955;Get the hash for a given object, apply an additional hash function to reduce_collisions. This implementation uses the same Wang/Jenkins algorithm as_{@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing._@param o the object to hash (may be null)_@return the resulting hash code;protected int getHash(@Nullable Object o) {_		int hash = o == null ? 0 : o.hashCode()__		hash += (hash << 15) ^ 0xffffcd7d__		hash ^= (hash >>> 10)__		hash += (hash << 3)__		hash ^= (hash >>> 6)__		hash += (hash << 2) + (hash << 14)__		hash ^= (hash >>> 16)__		return hash__	};get,the,hash,for,a,given,object,apply,an,additional,hash,function,to,reduce,collisions,this,implementation,uses,the,same,wang,jenkins,algorithm,as,link,concurrent,hash,map,subclasses,can,override,to,provide,alternative,hashing,param,o,the,object,to,hash,may,be,null,return,the,resulting,hash,code;protected,int,get,hash,nullable,object,o,int,hash,o,null,0,o,hash,code,hash,hash,15,0xffffcd7d,hash,hash,10,hash,hash,3,hash,hash,6,hash,hash,2,hash,14,hash,hash,16,return,hash
ConcurrentReferenceHashMap -> protected int getHash(@Nullable Object o);1498780456;Get the hash for a given object, apply an additional hash function to reduce_collisions. This implementation uses the same Wang/Jenkins algorithm as_{@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing._@param o the object to hash (may be null)_@return the resulting hash code;protected int getHash(@Nullable Object o) {_		int hash = o == null ? 0 : o.hashCode()__		hash += (hash << 15) ^ 0xffffcd7d__		hash ^= (hash >>> 10)__		hash += (hash << 3)__		hash ^= (hash >>> 6)__		hash += (hash << 2) + (hash << 14)__		hash ^= (hash >>> 16)__		return hash__	};get,the,hash,for,a,given,object,apply,an,additional,hash,function,to,reduce,collisions,this,implementation,uses,the,same,wang,jenkins,algorithm,as,link,concurrent,hash,map,subclasses,can,override,to,provide,alternative,hashing,param,o,the,object,to,hash,may,be,null,return,the,resulting,hash,code;protected,int,get,hash,nullable,object,o,int,hash,o,null,0,o,hash,code,hash,hash,15,0xffffcd7d,hash,hash,10,hash,hash,3,hash,hash,6,hash,hash,2,hash,14,hash,hash,16,return,hash
ConcurrentReferenceHashMap -> protected int getHash(@Nullable Object o);1502974979;Get the hash for a given object, apply an additional hash function to reduce_collisions. This implementation uses the same Wang/Jenkins algorithm as_{@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing._@param o the object to hash (may be null)_@return the resulting hash code;protected int getHash(@Nullable Object o) {_		int hash = o == null ? 0 : o.hashCode()__		hash += (hash << 15) ^ 0xffffcd7d__		hash ^= (hash >>> 10)__		hash += (hash << 3)__		hash ^= (hash >>> 6)__		hash += (hash << 2) + (hash << 14)__		hash ^= (hash >>> 16)__		return hash__	};get,the,hash,for,a,given,object,apply,an,additional,hash,function,to,reduce,collisions,this,implementation,uses,the,same,wang,jenkins,algorithm,as,link,concurrent,hash,map,subclasses,can,override,to,provide,alternative,hashing,param,o,the,object,to,hash,may,be,null,return,the,resulting,hash,code;protected,int,get,hash,nullable,object,o,int,hash,o,null,0,o,hash,code,hash,hash,15,0xffffcd7d,hash,hash,10,hash,hash,3,hash,hash,6,hash,hash,2,hash,14,hash,hash,16,return,hash
ConcurrentReferenceHashMap -> protected int getHash(@Nullable Object o);1506097334;Get the hash for a given object, apply an additional hash function to reduce_collisions. This implementation uses the same Wang/Jenkins algorithm as_{@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing._@param o the object to hash (may be null)_@return the resulting hash code;protected int getHash(@Nullable Object o) {_		int hash = o == null ? 0 : o.hashCode()__		hash += (hash << 15) ^ 0xffffcd7d__		hash ^= (hash >>> 10)__		hash += (hash << 3)__		hash ^= (hash >>> 6)__		hash += (hash << 2) + (hash << 14)__		hash ^= (hash >>> 16)__		return hash__	};get,the,hash,for,a,given,object,apply,an,additional,hash,function,to,reduce,collisions,this,implementation,uses,the,same,wang,jenkins,algorithm,as,link,concurrent,hash,map,subclasses,can,override,to,provide,alternative,hashing,param,o,the,object,to,hash,may,be,null,return,the,resulting,hash,code;protected,int,get,hash,nullable,object,o,int,hash,o,null,0,o,hash,code,hash,hash,15,0xffffcd7d,hash,hash,10,hash,hash,3,hash,hash,6,hash,hash,2,hash,14,hash,hash,16,return,hash
ConcurrentReferenceHashMap -> protected int getHash(@Nullable Object o);1521044224;Get the hash for a given object, apply an additional hash function to reduce_collisions. This implementation uses the same Wang/Jenkins algorithm as_{@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing._@param o the object to hash (may be null)_@return the resulting hash code;protected int getHash(@Nullable Object o) {_		int hash = o == null ? 0 : o.hashCode()__		hash += (hash << 15) ^ 0xffffcd7d__		hash ^= (hash >>> 10)__		hash += (hash << 3)__		hash ^= (hash >>> 6)__		hash += (hash << 2) + (hash << 14)__		hash ^= (hash >>> 16)__		return hash__	};get,the,hash,for,a,given,object,apply,an,additional,hash,function,to,reduce,collisions,this,implementation,uses,the,same,wang,jenkins,algorithm,as,link,concurrent,hash,map,subclasses,can,override,to,provide,alternative,hashing,param,o,the,object,to,hash,may,be,null,return,the,resulting,hash,code;protected,int,get,hash,nullable,object,o,int,hash,o,null,0,o,hash,code,hash,hash,15,0xffffcd7d,hash,hash,10,hash,hash,3,hash,hash,6,hash,hash,2,hash,14,hash,hash,16,return,hash
ConcurrentReferenceHashMap -> protected int getHash(@Nullable Object o);1530174524;Get the hash for a given object, apply an additional hash function to reduce_collisions. This implementation uses the same Wang/Jenkins algorithm as_{@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing._@param o the object to hash (may be null)_@return the resulting hash code;protected int getHash(@Nullable Object o) {_		int hash = o == null ? 0 : o.hashCode()__		hash += (hash << 15) ^ 0xffffcd7d__		hash ^= (hash >>> 10)__		hash += (hash << 3)__		hash ^= (hash >>> 6)__		hash += (hash << 2) + (hash << 14)__		hash ^= (hash >>> 16)__		return hash__	};get,the,hash,for,a,given,object,apply,an,additional,hash,function,to,reduce,collisions,this,implementation,uses,the,same,wang,jenkins,algorithm,as,link,concurrent,hash,map,subclasses,can,override,to,provide,alternative,hashing,param,o,the,object,to,hash,may,be,null,return,the,resulting,hash,code;protected,int,get,hash,nullable,object,o,int,hash,o,null,0,o,hash,code,hash,hash,15,0xffffcd7d,hash,hash,10,hash,hash,3,hash,hash,6,hash,hash,2,hash,14,hash,hash,16,return,hash
ConcurrentReferenceHashMap -> protected int getHash(@Nullable Object o);1530190293;Get the hash for a given object, apply an additional hash function to reduce_collisions. This implementation uses the same Wang/Jenkins algorithm as_{@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing._@param o the object to hash (may be null)_@return the resulting hash code;protected int getHash(@Nullable Object o) {_		int hash = o == null ? 0 : o.hashCode()__		hash += (hash << 15) ^ 0xffffcd7d__		hash ^= (hash >>> 10)__		hash += (hash << 3)__		hash ^= (hash >>> 6)__		hash += (hash << 2) + (hash << 14)__		hash ^= (hash >>> 16)__		return hash__	};get,the,hash,for,a,given,object,apply,an,additional,hash,function,to,reduce,collisions,this,implementation,uses,the,same,wang,jenkins,algorithm,as,link,concurrent,hash,map,subclasses,can,override,to,provide,alternative,hashing,param,o,the,object,to,hash,may,be,null,return,the,resulting,hash,code;protected,int,get,hash,nullable,object,o,int,hash,o,null,0,o,hash,code,hash,hash,15,0xffffcd7d,hash,hash,10,hash,hash,3,hash,hash,6,hash,hash,2,hash,14,hash,hash,16,return,hash
ConcurrentReferenceHashMap -> protected int getHash(@Nullable Object o);1530563577;Get the hash for a given object, apply an additional hash function to reduce_collisions. This implementation uses the same Wang/Jenkins algorithm as_{@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing._@param o the object to hash (may be null)_@return the resulting hash code;protected int getHash(@Nullable Object o) {_		int hash = (o != null ? o.hashCode() : 0)__		hash += (hash << 15) ^ 0xffffcd7d__		hash ^= (hash >>> 10)__		hash += (hash << 3)__		hash ^= (hash >>> 6)__		hash += (hash << 2) + (hash << 14)__		hash ^= (hash >>> 16)__		return hash__	};get,the,hash,for,a,given,object,apply,an,additional,hash,function,to,reduce,collisions,this,implementation,uses,the,same,wang,jenkins,algorithm,as,link,concurrent,hash,map,subclasses,can,override,to,provide,alternative,hashing,param,o,the,object,to,hash,may,be,null,return,the,resulting,hash,code;protected,int,get,hash,nullable,object,o,int,hash,o,null,o,hash,code,0,hash,hash,15,0xffffcd7d,hash,hash,10,hash,hash,3,hash,hash,6,hash,hash,2,hash,14,hash,hash,16,return,hash
ConcurrentReferenceHashMap -> protected int getHash(@Nullable Object o);1531136363;Get the hash for a given object, apply an additional hash function to reduce_collisions. This implementation uses the same Wang/Jenkins algorithm as_{@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing._@param o the object to hash (may be null)_@return the resulting hash code;protected int getHash(@Nullable Object o) {_		int hash = (o != null ? o.hashCode() : 0)__		hash += (hash << 15) ^ 0xffffcd7d__		hash ^= (hash >>> 10)__		hash += (hash << 3)__		hash ^= (hash >>> 6)__		hash += (hash << 2) + (hash << 14)__		hash ^= (hash >>> 16)__		return hash__	};get,the,hash,for,a,given,object,apply,an,additional,hash,function,to,reduce,collisions,this,implementation,uses,the,same,wang,jenkins,algorithm,as,link,concurrent,hash,map,subclasses,can,override,to,provide,alternative,hashing,param,o,the,object,to,hash,may,be,null,return,the,resulting,hash,code;protected,int,get,hash,nullable,object,o,int,hash,o,null,o,hash,code,0,hash,hash,15,0xffffcd7d,hash,hash,10,hash,hash,3,hash,hash,6,hash,hash,2,hash,14,hash,hash,16,return,hash
ConcurrentReferenceHashMap -> protected int getHash(@Nullable Object o);1531139295;Get the hash for a given object, apply an additional hash function to reduce_collisions. This implementation uses the same Wang/Jenkins algorithm as_{@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing._@param o the object to hash (may be null)_@return the resulting hash code;protected int getHash(@Nullable Object o) {_		int hash = (o != null ? o.hashCode() : 0)__		hash += (hash << 15) ^ 0xffffcd7d__		hash ^= (hash >>> 10)__		hash += (hash << 3)__		hash ^= (hash >>> 6)__		hash += (hash << 2) + (hash << 14)__		hash ^= (hash >>> 16)__		return hash__	};get,the,hash,for,a,given,object,apply,an,additional,hash,function,to,reduce,collisions,this,implementation,uses,the,same,wang,jenkins,algorithm,as,link,concurrent,hash,map,subclasses,can,override,to,provide,alternative,hashing,param,o,the,object,to,hash,may,be,null,return,the,resulting,hash,code;protected,int,get,hash,nullable,object,o,int,hash,o,null,o,hash,code,0,hash,hash,15,0xffffcd7d,hash,hash,10,hash,hash,3,hash,hash,6,hash,hash,2,hash,14,hash,hash,16,return,hash
ConcurrentReferenceHashMap -> protected int getHash(@Nullable Object o);1544716668;Get the hash for a given object, apply an additional hash function to reduce_collisions. This implementation uses the same Wang/Jenkins algorithm as_{@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing._@param o the object to hash (may be null)_@return the resulting hash code;protected int getHash(@Nullable Object o) {_		int hash = (o != null ? o.hashCode() : 0)__		hash += (hash << 15) ^ 0xffffcd7d__		hash ^= (hash >>> 10)__		hash += (hash << 3)__		hash ^= (hash >>> 6)__		hash += (hash << 2) + (hash << 14)__		hash ^= (hash >>> 16)__		return hash__	};get,the,hash,for,a,given,object,apply,an,additional,hash,function,to,reduce,collisions,this,implementation,uses,the,same,wang,jenkins,algorithm,as,link,concurrent,hash,map,subclasses,can,override,to,provide,alternative,hashing,param,o,the,object,to,hash,may,be,null,return,the,resulting,hash,code;protected,int,get,hash,nullable,object,o,int,hash,o,null,o,hash,code,0,hash,hash,15,0xffffcd7d,hash,hash,10,hash,hash,3,hash,hash,6,hash,hash,2,hash,14,hash,hash,16,return,hash
ConcurrentReferenceHashMap -> protected int getHash(@Nullable Object o);1549318940;Get the hash for a given object, apply an additional hash function to reduce_collisions. This implementation uses the same Wang/Jenkins algorithm as_{@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing._@param o the object to hash (may be null)_@return the resulting hash code;protected int getHash(@Nullable Object o) {_		int hash = (o != null ? o.hashCode() : 0)__		hash += (hash << 15) ^ 0xffffcd7d__		hash ^= (hash >>> 10)__		hash += (hash << 3)__		hash ^= (hash >>> 6)__		hash += (hash << 2) + (hash << 14)__		hash ^= (hash >>> 16)__		return hash__	};get,the,hash,for,a,given,object,apply,an,additional,hash,function,to,reduce,collisions,this,implementation,uses,the,same,wang,jenkins,algorithm,as,link,concurrent,hash,map,subclasses,can,override,to,provide,alternative,hashing,param,o,the,object,to,hash,may,be,null,return,the,resulting,hash,code;protected,int,get,hash,nullable,object,o,int,hash,o,null,o,hash,code,0,hash,hash,15,0xffffcd7d,hash,hash,10,hash,hash,3,hash,hash,6,hash,hash,2,hash,14,hash,hash,16,return,hash
ConcurrentReferenceHashMap -> protected int getHash(@Nullable Object o);1549321822;Get the hash for a given object, apply an additional hash function to reduce_collisions. This implementation uses the same Wang/Jenkins algorithm as_{@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing._@param o the object to hash (may be null)_@return the resulting hash code;protected int getHash(@Nullable Object o) {_		int hash = (o != null ? o.hashCode() : 0)__		hash += (hash << 15) ^ 0xffffcd7d__		hash ^= (hash >>> 10)__		hash += (hash << 3)__		hash ^= (hash >>> 6)__		hash += (hash << 2) + (hash << 14)__		hash ^= (hash >>> 16)__		return hash__	};get,the,hash,for,a,given,object,apply,an,additional,hash,function,to,reduce,collisions,this,implementation,uses,the,same,wang,jenkins,algorithm,as,link,concurrent,hash,map,subclasses,can,override,to,provide,alternative,hashing,param,o,the,object,to,hash,may,be,null,return,the,resulting,hash,code;protected,int,get,hash,nullable,object,o,int,hash,o,null,o,hash,code,0,hash,hash,15,0xffffcd7d,hash,hash,10,hash,hash,3,hash,hash,6,hash,hash,2,hash,14,hash,hash,16,return,hash
ConcurrentReferenceHashMap -> protected int getHash(@Nullable Object o);1550237263;Get the hash for a given object, apply an additional hash function to reduce_collisions. This implementation uses the same Wang/Jenkins algorithm as_{@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing._@param o the object to hash (may be null)_@return the resulting hash code;protected int getHash(@Nullable Object o) {_		int hash = (o != null ? o.hashCode() : 0)__		hash += (hash << 15) ^ 0xffffcd7d__		hash ^= (hash >>> 10)__		hash += (hash << 3)__		hash ^= (hash >>> 6)__		hash += (hash << 2) + (hash << 14)__		hash ^= (hash >>> 16)__		return hash__	};get,the,hash,for,a,given,object,apply,an,additional,hash,function,to,reduce,collisions,this,implementation,uses,the,same,wang,jenkins,algorithm,as,link,concurrent,hash,map,subclasses,can,override,to,provide,alternative,hashing,param,o,the,object,to,hash,may,be,null,return,the,resulting,hash,code;protected,int,get,hash,nullable,object,o,int,hash,o,null,o,hash,code,0,hash,hash,15,0xffffcd7d,hash,hash,10,hash,hash,3,hash,hash,6,hash,hash,2,hash,14,hash,hash,16,return,hash
ConcurrentReferenceHashMap -> ReferenceManager -> @SuppressWarnings("unchecked") 		@Nullable 		public Reference<K, V> pollForPurge();1495868221;Return any reference that has been garbage collected and can be purged from the_underlying structure or {@code null} if no references need purging. This_method must be thread safe and ideally should not block when returning_{@code null}. References should be returned once and only once._@return a reference to purge or {@code null};@SuppressWarnings("unchecked")_		@Nullable_		public Reference<K, V> pollForPurge() {_			return (Reference<K, V>) this.queue.poll()__		};return,any,reference,that,has,been,garbage,collected,and,can,be,purged,from,the,underlying,structure,or,code,null,if,no,references,need,purging,this,method,must,be,thread,safe,and,ideally,should,not,block,when,returning,code,null,references,should,be,returned,once,and,only,once,return,a,reference,to,purge,or,code,null;suppress,warnings,unchecked,nullable,public,reference,k,v,poll,for,purge,return,reference,k,v,this,queue,poll
ConcurrentReferenceHashMap -> ReferenceManager -> @SuppressWarnings("unchecked") 		@Nullable 		public Reference<K, V> pollForPurge();1496242568;Return any reference that has been garbage collected and can be purged from the_underlying structure or {@code null} if no references need purging. This_method must be thread safe and ideally should not block when returning_{@code null}. References should be returned once and only once._@return a reference to purge or {@code null};@SuppressWarnings("unchecked")_		@Nullable_		public Reference<K, V> pollForPurge() {_			return (Reference<K, V>) this.queue.poll()__		};return,any,reference,that,has,been,garbage,collected,and,can,be,purged,from,the,underlying,structure,or,code,null,if,no,references,need,purging,this,method,must,be,thread,safe,and,ideally,should,not,block,when,returning,code,null,references,should,be,returned,once,and,only,once,return,a,reference,to,purge,or,code,null;suppress,warnings,unchecked,nullable,public,reference,k,v,poll,for,purge,return,reference,k,v,this,queue,poll
ConcurrentReferenceHashMap -> ReferenceManager -> @SuppressWarnings("unchecked") 		@Nullable 		public Reference<K, V> pollForPurge();1496837955;Return any reference that has been garbage collected and can be purged from the_underlying structure or {@code null} if no references need purging. This_method must be thread safe and ideally should not block when returning_{@code null}. References should be returned once and only once._@return a reference to purge or {@code null};@SuppressWarnings("unchecked")_		@Nullable_		public Reference<K, V> pollForPurge() {_			return (Reference<K, V>) this.queue.poll()__		};return,any,reference,that,has,been,garbage,collected,and,can,be,purged,from,the,underlying,structure,or,code,null,if,no,references,need,purging,this,method,must,be,thread,safe,and,ideally,should,not,block,when,returning,code,null,references,should,be,returned,once,and,only,once,return,a,reference,to,purge,or,code,null;suppress,warnings,unchecked,nullable,public,reference,k,v,poll,for,purge,return,reference,k,v,this,queue,poll
ConcurrentReferenceHashMap -> ReferenceManager -> @SuppressWarnings("unchecked") 		@Nullable 		public Reference<K, V> pollForPurge();1498780456;Return any reference that has been garbage collected and can be purged from the_underlying structure or {@code null} if no references need purging. This_method must be thread safe and ideally should not block when returning_{@code null}. References should be returned once and only once._@return a reference to purge or {@code null};@SuppressWarnings("unchecked")_		@Nullable_		public Reference<K, V> pollForPurge() {_			return (Reference<K, V>) this.queue.poll()__		};return,any,reference,that,has,been,garbage,collected,and,can,be,purged,from,the,underlying,structure,or,code,null,if,no,references,need,purging,this,method,must,be,thread,safe,and,ideally,should,not,block,when,returning,code,null,references,should,be,returned,once,and,only,once,return,a,reference,to,purge,or,code,null;suppress,warnings,unchecked,nullable,public,reference,k,v,poll,for,purge,return,reference,k,v,this,queue,poll
ConcurrentReferenceHashMap -> ReferenceManager -> @SuppressWarnings("unchecked") 		@Nullable 		public Reference<K, V> pollForPurge();1502974979;Return any reference that has been garbage collected and can be purged from the_underlying structure or {@code null} if no references need purging. This_method must be thread safe and ideally should not block when returning_{@code null}. References should be returned once and only once._@return a reference to purge or {@code null};@SuppressWarnings("unchecked")_		@Nullable_		public Reference<K, V> pollForPurge() {_			return (Reference<K, V>) this.queue.poll()__		};return,any,reference,that,has,been,garbage,collected,and,can,be,purged,from,the,underlying,structure,or,code,null,if,no,references,need,purging,this,method,must,be,thread,safe,and,ideally,should,not,block,when,returning,code,null,references,should,be,returned,once,and,only,once,return,a,reference,to,purge,or,code,null;suppress,warnings,unchecked,nullable,public,reference,k,v,poll,for,purge,return,reference,k,v,this,queue,poll
ConcurrentReferenceHashMap -> ReferenceManager -> @SuppressWarnings("unchecked") 		@Nullable 		public Reference<K, V> pollForPurge();1506097334;Return any reference that has been garbage collected and can be purged from the_underlying structure or {@code null} if no references need purging. This_method must be thread safe and ideally should not block when returning_{@code null}. References should be returned once and only once._@return a reference to purge or {@code null};@SuppressWarnings("unchecked")_		@Nullable_		public Reference<K, V> pollForPurge() {_			return (Reference<K, V>) this.queue.poll()__		};return,any,reference,that,has,been,garbage,collected,and,can,be,purged,from,the,underlying,structure,or,code,null,if,no,references,need,purging,this,method,must,be,thread,safe,and,ideally,should,not,block,when,returning,code,null,references,should,be,returned,once,and,only,once,return,a,reference,to,purge,or,code,null;suppress,warnings,unchecked,nullable,public,reference,k,v,poll,for,purge,return,reference,k,v,this,queue,poll
ConcurrentReferenceHashMap -> ReferenceManager -> @SuppressWarnings("unchecked") 		@Nullable 		public Reference<K, V> pollForPurge();1521044224;Return any reference that has been garbage collected and can be purged from the_underlying structure or {@code null} if no references need purging. This_method must be thread safe and ideally should not block when returning_{@code null}. References should be returned once and only once._@return a reference to purge or {@code null};@SuppressWarnings("unchecked")_		@Nullable_		public Reference<K, V> pollForPurge() {_			return (Reference<K, V>) this.queue.poll()__		};return,any,reference,that,has,been,garbage,collected,and,can,be,purged,from,the,underlying,structure,or,code,null,if,no,references,need,purging,this,method,must,be,thread,safe,and,ideally,should,not,block,when,returning,code,null,references,should,be,returned,once,and,only,once,return,a,reference,to,purge,or,code,null;suppress,warnings,unchecked,nullable,public,reference,k,v,poll,for,purge,return,reference,k,v,this,queue,poll
ConcurrentReferenceHashMap -> ReferenceManager -> @SuppressWarnings("unchecked") 		@Nullable 		public Reference<K, V> pollForPurge();1530174524;Return any reference that has been garbage collected and can be purged from the_underlying structure or {@code null} if no references need purging. This_method must be thread safe and ideally should not block when returning_{@code null}. References should be returned once and only once._@return a reference to purge or {@code null};@SuppressWarnings("unchecked")_		@Nullable_		public Reference<K, V> pollForPurge() {_			return (Reference<K, V>) this.queue.poll()__		};return,any,reference,that,has,been,garbage,collected,and,can,be,purged,from,the,underlying,structure,or,code,null,if,no,references,need,purging,this,method,must,be,thread,safe,and,ideally,should,not,block,when,returning,code,null,references,should,be,returned,once,and,only,once,return,a,reference,to,purge,or,code,null;suppress,warnings,unchecked,nullable,public,reference,k,v,poll,for,purge,return,reference,k,v,this,queue,poll
ConcurrentReferenceHashMap -> ReferenceManager -> @SuppressWarnings("unchecked") 		@Nullable 		public Reference<K, V> pollForPurge();1530190293;Return any reference that has been garbage collected and can be purged from the_underlying structure or {@code null} if no references need purging. This_method must be thread safe and ideally should not block when returning_{@code null}. References should be returned once and only once._@return a reference to purge or {@code null};@SuppressWarnings("unchecked")_		@Nullable_		public Reference<K, V> pollForPurge() {_			return (Reference<K, V>) this.queue.poll()__		};return,any,reference,that,has,been,garbage,collected,and,can,be,purged,from,the,underlying,structure,or,code,null,if,no,references,need,purging,this,method,must,be,thread,safe,and,ideally,should,not,block,when,returning,code,null,references,should,be,returned,once,and,only,once,return,a,reference,to,purge,or,code,null;suppress,warnings,unchecked,nullable,public,reference,k,v,poll,for,purge,return,reference,k,v,this,queue,poll
ConcurrentReferenceHashMap -> ReferenceManager -> @SuppressWarnings("unchecked") 		@Nullable 		public Reference<K, V> pollForPurge();1530563577;Return any reference that has been garbage collected and can be purged from the_underlying structure or {@code null} if no references need purging. This_method must be thread safe and ideally should not block when returning_{@code null}. References should be returned once and only once._@return a reference to purge or {@code null};@SuppressWarnings("unchecked")_		@Nullable_		public Reference<K, V> pollForPurge() {_			return (Reference<K, V>) this.queue.poll()__		};return,any,reference,that,has,been,garbage,collected,and,can,be,purged,from,the,underlying,structure,or,code,null,if,no,references,need,purging,this,method,must,be,thread,safe,and,ideally,should,not,block,when,returning,code,null,references,should,be,returned,once,and,only,once,return,a,reference,to,purge,or,code,null;suppress,warnings,unchecked,nullable,public,reference,k,v,poll,for,purge,return,reference,k,v,this,queue,poll
ConcurrentReferenceHashMap -> ReferenceManager -> @SuppressWarnings("unchecked") 		@Nullable 		public Reference<K, V> pollForPurge();1531136363;Return any reference that has been garbage collected and can be purged from the_underlying structure or {@code null} if no references need purging. This_method must be thread safe and ideally should not block when returning_{@code null}. References should be returned once and only once._@return a reference to purge or {@code null};@SuppressWarnings("unchecked")_		@Nullable_		public Reference<K, V> pollForPurge() {_			return (Reference<K, V>) this.queue.poll()__		};return,any,reference,that,has,been,garbage,collected,and,can,be,purged,from,the,underlying,structure,or,code,null,if,no,references,need,purging,this,method,must,be,thread,safe,and,ideally,should,not,block,when,returning,code,null,references,should,be,returned,once,and,only,once,return,a,reference,to,purge,or,code,null;suppress,warnings,unchecked,nullable,public,reference,k,v,poll,for,purge,return,reference,k,v,this,queue,poll
ConcurrentReferenceHashMap -> ReferenceManager -> @SuppressWarnings("unchecked") 		@Nullable 		public Reference<K, V> pollForPurge();1531139295;Return any reference that has been garbage collected and can be purged from the_underlying structure or {@code null} if no references need purging. This_method must be thread safe and ideally should not block when returning_{@code null}. References should be returned once and only once._@return a reference to purge or {@code null};@SuppressWarnings("unchecked")_		@Nullable_		public Reference<K, V> pollForPurge() {_			return (Reference<K, V>) this.queue.poll()__		};return,any,reference,that,has,been,garbage,collected,and,can,be,purged,from,the,underlying,structure,or,code,null,if,no,references,need,purging,this,method,must,be,thread,safe,and,ideally,should,not,block,when,returning,code,null,references,should,be,returned,once,and,only,once,return,a,reference,to,purge,or,code,null;suppress,warnings,unchecked,nullable,public,reference,k,v,poll,for,purge,return,reference,k,v,this,queue,poll
ConcurrentReferenceHashMap -> ReferenceManager -> @SuppressWarnings("unchecked") 		@Nullable 		public Reference<K, V> pollForPurge();1544716668;Return any reference that has been garbage collected and can be purged from the_underlying structure or {@code null} if no references need purging. This_method must be thread safe and ideally should not block when returning_{@code null}. References should be returned once and only once._@return a reference to purge or {@code null};@SuppressWarnings("unchecked")_		@Nullable_		public Reference<K, V> pollForPurge() {_			return (Reference<K, V>) this.queue.poll()__		};return,any,reference,that,has,been,garbage,collected,and,can,be,purged,from,the,underlying,structure,or,code,null,if,no,references,need,purging,this,method,must,be,thread,safe,and,ideally,should,not,block,when,returning,code,null,references,should,be,returned,once,and,only,once,return,a,reference,to,purge,or,code,null;suppress,warnings,unchecked,nullable,public,reference,k,v,poll,for,purge,return,reference,k,v,this,queue,poll
ConcurrentReferenceHashMap -> ReferenceManager -> @SuppressWarnings("unchecked") 		@Nullable 		public Reference<K, V> pollForPurge();1549318940;Return any reference that has been garbage collected and can be purged from the_underlying structure or {@code null} if no references need purging. This_method must be thread safe and ideally should not block when returning_{@code null}. References should be returned once and only once._@return a reference to purge or {@code null};@SuppressWarnings("unchecked")_		@Nullable_		public Reference<K, V> pollForPurge() {_			return (Reference<K, V>) this.queue.poll()__		};return,any,reference,that,has,been,garbage,collected,and,can,be,purged,from,the,underlying,structure,or,code,null,if,no,references,need,purging,this,method,must,be,thread,safe,and,ideally,should,not,block,when,returning,code,null,references,should,be,returned,once,and,only,once,return,a,reference,to,purge,or,code,null;suppress,warnings,unchecked,nullable,public,reference,k,v,poll,for,purge,return,reference,k,v,this,queue,poll
ConcurrentReferenceHashMap -> ReferenceManager -> @SuppressWarnings("unchecked") 		@Nullable 		public Reference<K, V> pollForPurge();1549321822;Return any reference that has been garbage collected and can be purged from the_underlying structure or {@code null} if no references need purging. This_method must be thread safe and ideally should not block when returning_{@code null}. References should be returned once and only once._@return a reference to purge or {@code null};@SuppressWarnings("unchecked")_		@Nullable_		public Reference<K, V> pollForPurge() {_			return (Reference<K, V>) this.queue.poll()__		};return,any,reference,that,has,been,garbage,collected,and,can,be,purged,from,the,underlying,structure,or,code,null,if,no,references,need,purging,this,method,must,be,thread,safe,and,ideally,should,not,block,when,returning,code,null,references,should,be,returned,once,and,only,once,return,a,reference,to,purge,or,code,null;suppress,warnings,unchecked,nullable,public,reference,k,v,poll,for,purge,return,reference,k,v,this,queue,poll
ConcurrentReferenceHashMap -> ReferenceManager -> @SuppressWarnings("unchecked") 		@Nullable 		public Reference<K, V> pollForPurge();1550237263;Return any reference that has been garbage collected and can be purged from the_underlying structure or {@code null} if no references need purging. This_method must be thread safe and ideally should not block when returning_{@code null}. References should be returned once and only once._@return a reference to purge or {@code null};@SuppressWarnings("unchecked")_		@Nullable_		public Reference<K, V> pollForPurge() {_			return (Reference<K, V>) this.queue.poll()__		};return,any,reference,that,has,been,garbage,collected,and,can,be,purged,from,the,underlying,structure,or,code,null,if,no,references,need,purging,this,method,must,be,thread,safe,and,ideally,should,not,block,when,returning,code,null,references,should,be,returned,once,and,only,once,return,a,reference,to,purge,or,code,null;suppress,warnings,unchecked,nullable,public,reference,k,v,poll,for,purge,return,reference,k,v,this,queue,poll
ConcurrentReferenceHashMap -> Task -> @Nullable 		protected T execute(@Nullable Reference<K, V> reference, @Nullable Entry<K, V> entry, @Nullable Entries entries);1496837955;Execute the task._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@param entries access to the underlying entries_@return the result of the task_@see #execute(Reference, Entry);@Nullable_		protected T execute(@Nullable Reference<K, V> reference, @Nullable Entry<K, V> entry, @Nullable Entries entries) {_			return execute(reference, entry)__		};execute,the,task,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,param,entries,access,to,the,underlying,entries,return,the,result,of,the,task,see,execute,reference,entry;nullable,protected,t,execute,nullable,reference,k,v,reference,nullable,entry,k,v,entry,nullable,entries,entries,return,execute,reference,entry
ConcurrentReferenceHashMap -> Task -> @Nullable 		protected T execute(@Nullable Reference<K, V> reference, @Nullable Entry<K, V> entry, @Nullable Entries entries);1498780456;Execute the task._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@param entries access to the underlying entries_@return the result of the task_@see #execute(Reference, Entry);@Nullable_		protected T execute(@Nullable Reference<K, V> reference, @Nullable Entry<K, V> entry, @Nullable Entries entries) {_			return execute(reference, entry)__		};execute,the,task,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,param,entries,access,to,the,underlying,entries,return,the,result,of,the,task,see,execute,reference,entry;nullable,protected,t,execute,nullable,reference,k,v,reference,nullable,entry,k,v,entry,nullable,entries,entries,return,execute,reference,entry
ConcurrentReferenceHashMap -> Task -> @Nullable 		protected T execute(@Nullable Reference<K, V> reference, @Nullable Entry<K, V> entry, @Nullable Entries entries);1502974979;Execute the task._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@param entries access to the underlying entries_@return the result of the task_@see #execute(Reference, Entry);@Nullable_		protected T execute(@Nullable Reference<K, V> reference, @Nullable Entry<K, V> entry, @Nullable Entries entries) {_			return execute(reference, entry)__		};execute,the,task,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,param,entries,access,to,the,underlying,entries,return,the,result,of,the,task,see,execute,reference,entry;nullable,protected,t,execute,nullable,reference,k,v,reference,nullable,entry,k,v,entry,nullable,entries,entries,return,execute,reference,entry
ConcurrentReferenceHashMap -> Task -> @Nullable 		protected T execute(@Nullable Reference<K, V> reference, @Nullable Entry<K, V> entry, @Nullable Entries entries);1506097334;Execute the task._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@param entries access to the underlying entries_@return the result of the task_@see #execute(Reference, Entry);@Nullable_		protected T execute(@Nullable Reference<K, V> reference, @Nullable Entry<K, V> entry, @Nullable Entries entries) {_			return execute(reference, entry)__		};execute,the,task,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,param,entries,access,to,the,underlying,entries,return,the,result,of,the,task,see,execute,reference,entry;nullable,protected,t,execute,nullable,reference,k,v,reference,nullable,entry,k,v,entry,nullable,entries,entries,return,execute,reference,entry
ConcurrentReferenceHashMap -> Task -> @Nullable 		protected T execute(@Nullable Reference<K, V> reference, @Nullable Entry<K, V> entry, @Nullable Entries entries);1521044224;Execute the task._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@param entries access to the underlying entries_@return the result of the task_@see #execute(Reference, Entry);@Nullable_		protected T execute(@Nullable Reference<K, V> reference, @Nullable Entry<K, V> entry, @Nullable Entries entries) {_			return execute(reference, entry)__		};execute,the,task,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,param,entries,access,to,the,underlying,entries,return,the,result,of,the,task,see,execute,reference,entry;nullable,protected,t,execute,nullable,reference,k,v,reference,nullable,entry,k,v,entry,nullable,entries,entries,return,execute,reference,entry
ConcurrentReferenceHashMap -> Task -> @Nullable 		protected T execute(@Nullable Reference<K, V> reference, @Nullable Entry<K, V> entry, @Nullable Entries entries);1530174524;Execute the task._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@param entries access to the underlying entries_@return the result of the task_@see #execute(Reference, Entry);@Nullable_		protected T execute(@Nullable Reference<K, V> reference, @Nullable Entry<K, V> entry, @Nullable Entries entries) {_			return execute(reference, entry)__		};execute,the,task,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,param,entries,access,to,the,underlying,entries,return,the,result,of,the,task,see,execute,reference,entry;nullable,protected,t,execute,nullable,reference,k,v,reference,nullable,entry,k,v,entry,nullable,entries,entries,return,execute,reference,entry
ConcurrentReferenceHashMap -> Task -> @Nullable 		protected T execute(@Nullable Reference<K, V> reference, @Nullable Entry<K, V> entry, @Nullable Entries entries);1530190293;Execute the task._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@param entries access to the underlying entries_@return the result of the task_@see #execute(Reference, Entry);@Nullable_		protected T execute(@Nullable Reference<K, V> reference, @Nullable Entry<K, V> entry, @Nullable Entries entries) {_			return execute(reference, entry)__		};execute,the,task,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,param,entries,access,to,the,underlying,entries,return,the,result,of,the,task,see,execute,reference,entry;nullable,protected,t,execute,nullable,reference,k,v,reference,nullable,entry,k,v,entry,nullable,entries,entries,return,execute,reference,entry
ConcurrentReferenceHashMap -> Segment -> public void clear();1351982790;Clear all items from this segment.;public void clear() {_			if (this.count == 0) {_				return__			}_			lock()__			try {_				setReferences(createReferenceArray(this.initialSize))__				this.count = 0__			} finally {_				unlock()__			}_		};clear,all,items,from,this,segment;public,void,clear,if,this,count,0,return,lock,try,set,references,create,reference,array,this,initial,size,this,count,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> public void clear();1352039846;Clear all items from this segment.;public void clear() {_			if (this.count == 0) {_				return__			}_			lock()__			try {_				setReferences(createReferenceArray(this.initialSize))__				this.count = 0__			} finally {_				unlock()__			}_		};clear,all,items,from,this,segment;public,void,clear,if,this,count,0,return,lock,try,set,references,create,reference,array,this,initial,size,this,count,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> public void clear();1355313310;Clear all items from this segment.;public void clear() {_			if (this.count == 0) {_				return__			}_			lock()__			try {_				setReferences(createReferenceArray(this.initialSize))__				this.count = 0__			} finally {_				unlock()__			}_		};clear,all,items,from,this,segment;public,void,clear,if,this,count,0,return,lock,try,set,references,create,reference,array,this,initial,size,this,count,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> public void clear();1356735495;Clear all items from this segment.;public void clear() {_			if (this.count == 0) {_				return__			}_			lock()__			try {_				setReferences(createReferenceArray(this.initialSize))__				this.count = 0__			} finally {_				unlock()__			}_		};clear,all,items,from,this,segment;public,void,clear,if,this,count,0,return,lock,try,set,references,create,reference,array,this,initial,size,this,count,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> public void clear();1357119239;Clear all items from this segment.;public void clear() {_			if (this.count == 0) {_				return__			}_			lock()__			try {_				setReferences(createReferenceArray(this.initialSize))__				this.count = 0__			} finally {_				unlock()__			}_		};clear,all,items,from,this,segment;public,void,clear,if,this,count,0,return,lock,try,set,references,create,reference,array,this,initial,size,this,count,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> public void clear();1368482696;Clear all items from this segment.;public void clear() {_			if (this.count == 0) {_				return__			}_			lock()__			try {_				setReferences(createReferenceArray(this.initialSize))__				this.count = 0__			} finally {_				unlock()__			}_		};clear,all,items,from,this,segment;public,void,clear,if,this,count,0,return,lock,try,set,references,create,reference,array,this,initial,size,this,count,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> public void clear();1383090835;Clear all items from this segment.;public void clear() {_			if (this.count == 0) {_				return__			}_			lock()__			try {_				setReferences(createReferenceArray(this.initialSize))__				this.count = 0__			} finally {_				unlock()__			}_		};clear,all,items,from,this,segment;public,void,clear,if,this,count,0,return,lock,try,set,references,create,reference,array,this,initial,size,this,count,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> public void clear();1383178438;Clear all items from this segment.;public void clear() {_			if (this.count == 0) {_				return__			}_			lock()__			try {_				setReferences(createReferenceArray(this.initialSize))__				this.count = 0__			} finally {_				unlock()__			}_		};clear,all,items,from,this,segment;public,void,clear,if,this,count,0,return,lock,try,set,references,create,reference,array,this,initial,size,this,count,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> public void clear();1390260938;Clear all items from this segment.;public void clear() {_			if (this.count == 0) {_				return__			}_			lock()__			try {_				setReferences(createReferenceArray(this.initialSize))__				this.count = 0__			} finally {_				unlock()__			}_		};clear,all,items,from,this,segment;public,void,clear,if,this,count,0,return,lock,try,set,references,create,reference,array,this,initial,size,this,count,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> public void clear();1391715359;Clear all items from this segment.;public void clear() {_			if (this.count == 0) {_				return__			}_			lock()__			try {_				setReferences(createReferenceArray(this.initialSize))__				this.count = 0__			} finally {_				unlock()__			}_		};clear,all,items,from,this,segment;public,void,clear,if,this,count,0,return,lock,try,set,references,create,reference,array,this,initial,size,this,count,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> public void clear();1392765030;Clear all items from this segment.;public void clear() {_			if (this.count == 0) {_				return__			}_			lock()__			try {_				setReferences(createReferenceArray(this.initialSize))__				this.count = 0__			} finally {_				unlock()__			}_		};clear,all,items,from,this,segment;public,void,clear,if,this,count,0,return,lock,try,set,references,create,reference,array,this,initial,size,this,count,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> public void clear();1398175099;Clear all items from this segment.;public void clear() {_			if (this.count == 0) {_				return__			}_			lock()__			try {_				setReferences(createReferenceArray(this.initialSize))__				this.count = 0__			} finally {_				unlock()__			}_		};clear,all,items,from,this,segment;public,void,clear,if,this,count,0,return,lock,try,set,references,create,reference,array,this,initial,size,this,count,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> public void clear();1404132943;Clear all items from this segment.;public void clear() {_			if (this.count == 0) {_				return__			}_			lock()__			try {_				setReferences(createReferenceArray(this.initialSize))__				this.count = 0__			}_			finally {_				unlock()__			}_		};clear,all,items,from,this,segment;public,void,clear,if,this,count,0,return,lock,try,set,references,create,reference,array,this,initial,size,this,count,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> public void clear();1427240641;Clear all items from this segment.;public void clear() {_			if (this.count == 0) {_				return__			}_			lock()__			try {_				setReferences(createReferenceArray(this.initialSize))__				this.count = 0__			}_			finally {_				unlock()__			}_		};clear,all,items,from,this,segment;public,void,clear,if,this,count,0,return,lock,try,set,references,create,reference,array,this,initial,size,this,count,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> public void clear();1459795890;Clear all items from this segment.;public void clear() {_			if (this.count == 0) {_				return__			}_			lock()__			try {_				setReferences(createReferenceArray(this.initialSize))__				this.count = 0__			}_			finally {_				unlock()__			}_		};clear,all,items,from,this,segment;public,void,clear,if,this,count,0,return,lock,try,set,references,create,reference,array,this,initial,size,this,count,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> public void clear();1467730834;Clear all items from this segment.;public void clear() {_			if (this.count == 0) {_				return__			}_			lock()__			try {_				setReferences(createReferenceArray(this.initialSize))__				this.count = 0__			}_			finally {_				unlock()__			}_		};clear,all,items,from,this,segment;public,void,clear,if,this,count,0,return,lock,try,set,references,create,reference,array,this,initial,size,this,count,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> public void clear();1485810955;Clear all items from this segment.;public void clear() {_			if (this.count == 0) {_				return__			}_			lock()__			try {_				setReferences(createReferenceArray(this.initialSize))__				this.count = 0__			}_			finally {_				unlock()__			}_		};clear,all,items,from,this,segment;public,void,clear,if,this,count,0,return,lock,try,set,references,create,reference,array,this,initial,size,this,count,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> public void clear();1495868221;Clear all items from this segment.;public void clear() {_			if (this.count == 0) {_				return__			}_			lock()__			try {_				setReferences(createReferenceArray(this.initialSize))__				this.count = 0__			}_			finally {_				unlock()__			}_		};clear,all,items,from,this,segment;public,void,clear,if,this,count,0,return,lock,try,set,references,create,reference,array,this,initial,size,this,count,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> public void clear();1496242568;Clear all items from this segment.;public void clear() {_			if (this.count == 0) {_				return__			}_			lock()__			try {_				setReferences(createReferenceArray(this.initialSize))__				this.count = 0__			}_			finally {_				unlock()__			}_		};clear,all,items,from,this,segment;public,void,clear,if,this,count,0,return,lock,try,set,references,create,reference,array,this,initial,size,this,count,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> public void clear();1496837955;Clear all items from this segment.;public void clear() {_			if (this.count == 0) {_				return__			}_			lock()__			try {_				setReferences(createReferenceArray(this.initialSize))__				this.count = 0__			}_			finally {_				unlock()__			}_		};clear,all,items,from,this,segment;public,void,clear,if,this,count,0,return,lock,try,set,references,create,reference,array,this,initial,size,this,count,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> public void clear();1498780456;Clear all items from this segment.;public void clear() {_			if (this.count == 0) {_				return__			}_			lock()__			try {_				this.references = createReferenceArray(this.initialSize)__				this.resizeThreshold = (int) (this.references.length * getLoadFactor())__				this.count = 0__			}_			finally {_				unlock()__			}_		};clear,all,items,from,this,segment;public,void,clear,if,this,count,0,return,lock,try,this,references,create,reference,array,this,initial,size,this,resize,threshold,int,this,references,length,get,load,factor,this,count,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> public void clear();1502974979;Clear all items from this segment.;public void clear() {_			if (this.count == 0) {_				return__			}_			lock()__			try {_				this.references = createReferenceArray(this.initialSize)__				this.resizeThreshold = (int) (this.references.length * getLoadFactor())__				this.count = 0__			}_			finally {_				unlock()__			}_		};clear,all,items,from,this,segment;public,void,clear,if,this,count,0,return,lock,try,this,references,create,reference,array,this,initial,size,this,resize,threshold,int,this,references,length,get,load,factor,this,count,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> public void clear();1506097334;Clear all items from this segment.;public void clear() {_			if (this.count == 0) {_				return__			}_			lock()__			try {_				this.references = createReferenceArray(this.initialSize)__				this.resizeThreshold = (int) (this.references.length * getLoadFactor())__				this.count = 0__			}_			finally {_				unlock()__			}_		};clear,all,items,from,this,segment;public,void,clear,if,this,count,0,return,lock,try,this,references,create,reference,array,this,initial,size,this,resize,threshold,int,this,references,length,get,load,factor,this,count,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> public void clear();1521044224;Clear all items from this segment.;public void clear() {_			if (this.count == 0) {_				return__			}_			lock()__			try {_				this.references = createReferenceArray(this.initialSize)__				this.resizeThreshold = (int) (this.references.length * getLoadFactor())__				this.count = 0__			}_			finally {_				unlock()__			}_		};clear,all,items,from,this,segment;public,void,clear,if,this,count,0,return,lock,try,this,references,create,reference,array,this,initial,size,this,resize,threshold,int,this,references,length,get,load,factor,this,count,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> public void clear();1530174524;Clear all items from this segment.;public void clear() {_			if (this.count == 0) {_				return__			}_			lock()__			try {_				this.references = createReferenceArray(this.initialSize)__				this.resizeThreshold = (int) (this.references.length * getLoadFactor())__				this.count = 0__			}_			finally {_				unlock()__			}_		};clear,all,items,from,this,segment;public,void,clear,if,this,count,0,return,lock,try,this,references,create,reference,array,this,initial,size,this,resize,threshold,int,this,references,length,get,load,factor,this,count,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> public void clear();1530190293;Clear all items from this segment.;public void clear() {_			if (this.count == 0) {_				return__			}_			lock()__			try {_				this.references = createReferenceArray(this.initialSize)__				this.resizeThreshold = (int) (this.references.length * getLoadFactor())__				this.count = 0__			}_			finally {_				unlock()__			}_		};clear,all,items,from,this,segment;public,void,clear,if,this,count,0,return,lock,try,this,references,create,reference,array,this,initial,size,this,resize,threshold,int,this,references,length,get,load,factor,this,count,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> public void clear();1530563577;Clear all items from this segment.;public void clear() {_			if (this.count == 0) {_				return__			}_			lock()__			try {_				this.references = createReferenceArray(this.initialSize)__				this.resizeThreshold = (int) (this.references.length * getLoadFactor())__				this.count = 0__			}_			finally {_				unlock()__			}_		};clear,all,items,from,this,segment;public,void,clear,if,this,count,0,return,lock,try,this,references,create,reference,array,this,initial,size,this,resize,threshold,int,this,references,length,get,load,factor,this,count,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> public void clear();1531136363;Clear all items from this segment.;public void clear() {_			if (this.count == 0) {_				return__			}_			lock()__			try {_				this.references = createReferenceArray(this.initialSize)__				this.resizeThreshold = (int) (this.references.length * getLoadFactor())__				this.count = 0__			}_			finally {_				unlock()__			}_		};clear,all,items,from,this,segment;public,void,clear,if,this,count,0,return,lock,try,this,references,create,reference,array,this,initial,size,this,resize,threshold,int,this,references,length,get,load,factor,this,count,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> public void clear();1531139295;Clear all items from this segment.;public void clear() {_			if (this.count == 0) {_				return__			}_			lock()__			try {_				this.references = createReferenceArray(this.initialSize)__				this.resizeThreshold = (int) (this.references.length * getLoadFactor())__				this.count = 0__			}_			finally {_				unlock()__			}_		};clear,all,items,from,this,segment;public,void,clear,if,this,count,0,return,lock,try,this,references,create,reference,array,this,initial,size,this,resize,threshold,int,this,references,length,get,load,factor,this,count,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> public void clear();1544716668;Clear all items from this segment.;public void clear() {_			if (this.count == 0) {_				return__			}_			lock()__			try {_				this.references = createReferenceArray(this.initialSize)__				this.resizeThreshold = (int) (this.references.length * getLoadFactor())__				this.count = 0__			}_			finally {_				unlock()__			}_		};clear,all,items,from,this,segment;public,void,clear,if,this,count,0,return,lock,try,this,references,create,reference,array,this,initial,size,this,resize,threshold,int,this,references,length,get,load,factor,this,count,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> public void clear();1549318940;Clear all items from this segment.;public void clear() {_			if (this.count.get() == 0) {_				return__			}_			lock()__			try {_				this.references = createReferenceArray(this.initialSize)__				this.resizeThreshold = (int) (this.references.length * getLoadFactor())__				this.count.set(0)__			}_			finally {_				unlock()__			}_		};clear,all,items,from,this,segment;public,void,clear,if,this,count,get,0,return,lock,try,this,references,create,reference,array,this,initial,size,this,resize,threshold,int,this,references,length,get,load,factor,this,count,set,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> public void clear();1549321822;Clear all items from this segment.;public void clear() {_			if (this.count.get() == 0) {_				return__			}_			lock()__			try {_				this.references = createReferenceArray(this.initialSize)__				this.resizeThreshold = (int) (this.references.length * getLoadFactor())__				this.count.set(0)__			}_			finally {_				unlock()__			}_		};clear,all,items,from,this,segment;public,void,clear,if,this,count,get,0,return,lock,try,this,references,create,reference,array,this,initial,size,this,resize,threshold,int,this,references,length,get,load,factor,this,count,set,0,finally,unlock
ConcurrentReferenceHashMap -> Segment -> public void clear();1550237263;Clear all items from this segment.;public void clear() {_			if (this.count.get() == 0) {_				return__			}_			lock()__			try {_				this.references = createReferenceArray(this.initialSize)__				this.resizeThreshold = (int) (this.references.length * getLoadFactor())__				this.count.set(0)__			}_			finally {_				unlock()__			}_		};clear,all,items,from,this,segment;public,void,clear,if,this,count,get,0,return,lock,try,this,references,create,reference,array,this,initial,size,this,resize,threshold,int,this,references,length,get,load,factor,this,count,set,0,finally,unlock
ConcurrentReferenceHashMap -> Task -> protected T execute(Reference<K, V> reference, Entry<K, V> entry);1351982790;Convenience method that can be used for tasks that do not need access to {@link Entries}._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@return the result of the task_@see #execute(Reference, Entry, Entries);protected T execute(Reference<K, V> reference, Entry<K, V> entry) {_			return null__		};convenience,method,that,can,be,used,for,tasks,that,do,not,need,access,to,link,entries,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,return,the,result,of,the,task,see,execute,reference,entry,entries;protected,t,execute,reference,k,v,reference,entry,k,v,entry,return,null
ConcurrentReferenceHashMap -> Task -> protected T execute(Reference<K, V> reference, Entry<K, V> entry);1352039846;Convenience method that can be used for tasks that do not need access to {@link Entries}._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@return the result of the task_@see #execute(Reference, Entry, Entries);protected T execute(Reference<K, V> reference, Entry<K, V> entry) {_			return null__		};convenience,method,that,can,be,used,for,tasks,that,do,not,need,access,to,link,entries,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,return,the,result,of,the,task,see,execute,reference,entry,entries;protected,t,execute,reference,k,v,reference,entry,k,v,entry,return,null
ConcurrentReferenceHashMap -> Task -> protected T execute(Reference<K, V> reference, Entry<K, V> entry);1355313310;Convenience method that can be used for tasks that do not need access to {@link Entries}._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@return the result of the task_@see #execute(Reference, Entry, Entries);protected T execute(Reference<K, V> reference, Entry<K, V> entry) {_			return null__		};convenience,method,that,can,be,used,for,tasks,that,do,not,need,access,to,link,entries,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,return,the,result,of,the,task,see,execute,reference,entry,entries;protected,t,execute,reference,k,v,reference,entry,k,v,entry,return,null
ConcurrentReferenceHashMap -> Task -> protected T execute(Reference<K, V> reference, Entry<K, V> entry);1356735495;Convenience method that can be used for tasks that do not need access to {@link Entries}._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@return the result of the task_@see #execute(Reference, Entry, Entries);protected T execute(Reference<K, V> reference, Entry<K, V> entry) {_			return null__		};convenience,method,that,can,be,used,for,tasks,that,do,not,need,access,to,link,entries,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,return,the,result,of,the,task,see,execute,reference,entry,entries;protected,t,execute,reference,k,v,reference,entry,k,v,entry,return,null
ConcurrentReferenceHashMap -> Task -> protected T execute(Reference<K, V> reference, Entry<K, V> entry);1357119239;Convenience method that can be used for tasks that do not need access to {@link Entries}._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@return the result of the task_@see #execute(Reference, Entry, Entries);protected T execute(Reference<K, V> reference, Entry<K, V> entry) {_			return null__		};convenience,method,that,can,be,used,for,tasks,that,do,not,need,access,to,link,entries,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,return,the,result,of,the,task,see,execute,reference,entry,entries;protected,t,execute,reference,k,v,reference,entry,k,v,entry,return,null
ConcurrentReferenceHashMap -> Task -> protected T execute(Reference<K, V> reference, Entry<K, V> entry);1368482696;Convenience method that can be used for tasks that do not need access to {@link Entries}._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@return the result of the task_@see #execute(Reference, Entry, Entries);protected T execute(Reference<K, V> reference, Entry<K, V> entry) {_			return null__		};convenience,method,that,can,be,used,for,tasks,that,do,not,need,access,to,link,entries,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,return,the,result,of,the,task,see,execute,reference,entry,entries;protected,t,execute,reference,k,v,reference,entry,k,v,entry,return,null
ConcurrentReferenceHashMap -> Task -> protected T execute(Reference<K, V> reference, Entry<K, V> entry);1383090835;Convenience method that can be used for tasks that do not need access to {@link Entries}._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@return the result of the task_@see #execute(Reference, Entry, Entries);protected T execute(Reference<K, V> reference, Entry<K, V> entry) {_			return null__		};convenience,method,that,can,be,used,for,tasks,that,do,not,need,access,to,link,entries,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,return,the,result,of,the,task,see,execute,reference,entry,entries;protected,t,execute,reference,k,v,reference,entry,k,v,entry,return,null
ConcurrentReferenceHashMap -> Task -> protected T execute(Reference<K, V> reference, Entry<K, V> entry);1383178438;Convenience method that can be used for tasks that do not need access to {@link Entries}._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@return the result of the task_@see #execute(Reference, Entry, Entries);protected T execute(Reference<K, V> reference, Entry<K, V> entry) {_			return null__		};convenience,method,that,can,be,used,for,tasks,that,do,not,need,access,to,link,entries,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,return,the,result,of,the,task,see,execute,reference,entry,entries;protected,t,execute,reference,k,v,reference,entry,k,v,entry,return,null
ConcurrentReferenceHashMap -> Task -> protected T execute(Reference<K, V> reference, Entry<K, V> entry);1390260938;Convenience method that can be used for tasks that do not need access to {@link Entries}._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@return the result of the task_@see #execute(Reference, Entry, Entries);protected T execute(Reference<K, V> reference, Entry<K, V> entry) {_			return null__		};convenience,method,that,can,be,used,for,tasks,that,do,not,need,access,to,link,entries,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,return,the,result,of,the,task,see,execute,reference,entry,entries;protected,t,execute,reference,k,v,reference,entry,k,v,entry,return,null
ConcurrentReferenceHashMap -> Task -> protected T execute(Reference<K, V> reference, Entry<K, V> entry);1391715359;Convenience method that can be used for tasks that do not need access to {@link Entries}._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@return the result of the task_@see #execute(Reference, Entry, Entries);protected T execute(Reference<K, V> reference, Entry<K, V> entry) {_			return null__		};convenience,method,that,can,be,used,for,tasks,that,do,not,need,access,to,link,entries,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,return,the,result,of,the,task,see,execute,reference,entry,entries;protected,t,execute,reference,k,v,reference,entry,k,v,entry,return,null
ConcurrentReferenceHashMap -> Task -> protected T execute(Reference<K, V> reference, Entry<K, V> entry);1392765030;Convenience method that can be used for tasks that do not need access to {@link Entries}._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@return the result of the task_@see #execute(Reference, Entry, Entries);protected T execute(Reference<K, V> reference, Entry<K, V> entry) {_			return null__		};convenience,method,that,can,be,used,for,tasks,that,do,not,need,access,to,link,entries,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,return,the,result,of,the,task,see,execute,reference,entry,entries;protected,t,execute,reference,k,v,reference,entry,k,v,entry,return,null
ConcurrentReferenceHashMap -> Task -> protected T execute(Reference<K, V> reference, Entry<K, V> entry);1398175099;Convenience method that can be used for tasks that do not need access to {@link Entries}._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@return the result of the task_@see #execute(Reference, Entry, Entries);protected T execute(Reference<K, V> reference, Entry<K, V> entry) {_			return null__		};convenience,method,that,can,be,used,for,tasks,that,do,not,need,access,to,link,entries,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,return,the,result,of,the,task,see,execute,reference,entry,entries;protected,t,execute,reference,k,v,reference,entry,k,v,entry,return,null
ConcurrentReferenceHashMap -> Task -> protected T execute(Reference<K, V> reference, Entry<K, V> entry);1404132943;Convenience method that can be used for tasks that do not need access to {@link Entries}._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@return the result of the task_@see #execute(Reference, Entry, Entries);protected T execute(Reference<K, V> reference, Entry<K, V> entry) {_			return null__		};convenience,method,that,can,be,used,for,tasks,that,do,not,need,access,to,link,entries,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,return,the,result,of,the,task,see,execute,reference,entry,entries;protected,t,execute,reference,k,v,reference,entry,k,v,entry,return,null
ConcurrentReferenceHashMap -> Task -> protected T execute(Reference<K, V> reference, Entry<K, V> entry);1427240641;Convenience method that can be used for tasks that do not need access to {@link Entries}._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@return the result of the task_@see #execute(Reference, Entry, Entries);protected T execute(Reference<K, V> reference, Entry<K, V> entry) {_			return null__		};convenience,method,that,can,be,used,for,tasks,that,do,not,need,access,to,link,entries,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,return,the,result,of,the,task,see,execute,reference,entry,entries;protected,t,execute,reference,k,v,reference,entry,k,v,entry,return,null
ConcurrentReferenceHashMap -> Task -> protected T execute(Reference<K, V> reference, Entry<K, V> entry);1459795890;Convenience method that can be used for tasks that do not need access to {@link Entries}._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@return the result of the task_@see #execute(Reference, Entry, Entries);protected T execute(Reference<K, V> reference, Entry<K, V> entry) {_			return null__		};convenience,method,that,can,be,used,for,tasks,that,do,not,need,access,to,link,entries,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,return,the,result,of,the,task,see,execute,reference,entry,entries;protected,t,execute,reference,k,v,reference,entry,k,v,entry,return,null
ConcurrentReferenceHashMap -> Task -> protected T execute(Reference<K, V> reference, Entry<K, V> entry);1467730834;Convenience method that can be used for tasks that do not need access to {@link Entries}._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@return the result of the task_@see #execute(Reference, Entry, Entries);protected T execute(Reference<K, V> reference, Entry<K, V> entry) {_			return null__		};convenience,method,that,can,be,used,for,tasks,that,do,not,need,access,to,link,entries,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,return,the,result,of,the,task,see,execute,reference,entry,entries;protected,t,execute,reference,k,v,reference,entry,k,v,entry,return,null
ConcurrentReferenceHashMap -> Task -> protected T execute(Reference<K, V> reference, Entry<K, V> entry);1485810955;Convenience method that can be used for tasks that do not need access to {@link Entries}._@param reference the found reference or {@code null}_@param entry the found entry or {@code null}_@return the result of the task_@see #execute(Reference, Entry, Entries);protected T execute(Reference<K, V> reference, Entry<K, V> entry) {_			return null__		};convenience,method,that,can,be,used,for,tasks,that,do,not,need,access,to,link,entries,param,reference,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,return,the,result,of,the,task,see,execute,reference,entry,entries;protected,t,execute,reference,k,v,reference,entry,k,v,entry,return,null
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel);1383090835;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {_		this(initialCapacity, loadFactor, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,this,initial,capacity,load,factor,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel);1383178438;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {_		this(initialCapacity, loadFactor, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,this,initial,capacity,load,factor,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel);1390260938;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {_		this(initialCapacity, loadFactor, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,this,initial,capacity,load,factor,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel);1391715359;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {_		this(initialCapacity, loadFactor, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,this,initial,capacity,load,factor,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel);1392765030;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {_		this(initialCapacity, loadFactor, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,this,initial,capacity,load,factor,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel);1398175099;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {_		this(initialCapacity, loadFactor, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,this,initial,capacity,load,factor,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel);1404132943;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {_		this(initialCapacity, loadFactor, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,this,initial,capacity,load,factor,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel);1427240641;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {_		this(initialCapacity, loadFactor, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,this,initial,capacity,load,factor,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel);1459795890;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {_		this(initialCapacity, loadFactor, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,this,initial,capacity,load,factor,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel);1467730834;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {_		this(initialCapacity, loadFactor, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,this,initial,capacity,load,factor,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel);1485810955;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {_		this(initialCapacity, loadFactor, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,this,initial,capacity,load,factor,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel);1495868221;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {_		this(initialCapacity, loadFactor, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,this,initial,capacity,load,factor,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel);1496242568;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {_		this(initialCapacity, loadFactor, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,this,initial,capacity,load,factor,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel);1496837955;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {_		this(initialCapacity, loadFactor, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,this,initial,capacity,load,factor,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel);1498780456;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {_		this(initialCapacity, loadFactor, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,this,initial,capacity,load,factor,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel);1502974979;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {_		this(initialCapacity, loadFactor, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,this,initial,capacity,load,factor,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel);1506097334;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {_		this(initialCapacity, loadFactor, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,this,initial,capacity,load,factor,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel);1521044224;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {_		this(initialCapacity, loadFactor, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,this,initial,capacity,load,factor,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel);1530174524;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {_		this(initialCapacity, loadFactor, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,this,initial,capacity,load,factor,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel);1530190293;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {_		this(initialCapacity, loadFactor, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,this,initial,capacity,load,factor,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel);1530563577;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {_		this(initialCapacity, loadFactor, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,this,initial,capacity,load,factor,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel);1531136363;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {_		this(initialCapacity, loadFactor, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,this,initial,capacity,load,factor,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel);1531139295;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {_		this(initialCapacity, loadFactor, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,this,initial,capacity,load,factor,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel);1544716668;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {_		this(initialCapacity, loadFactor, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,this,initial,capacity,load,factor,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel);1549318940;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {_		this(initialCapacity, loadFactor, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,this,initial,capacity,load,factor,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel);1549321822;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {_		this(initialCapacity, loadFactor, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,this,initial,capacity,load,factor,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel);1550237263;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per_table exceeds this value, resize will be attempted._@param concurrencyLevel the expected number of threads that will concurrently_write to the map;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {_		this(initialCapacity, loadFactor, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,this,initial,capacity,load,factor,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity);1351982790;Create a new {@link ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map;public ConcurrentReferenceHashMap(int initialCapacity) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL,_				DEFAULT_REFERENCE_TYPE)__	};create,a,new,link,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map;public,concurrent,reference,hash,map,int,initial,capacity,this,initial,capacity
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity);1352039846;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map;public ConcurrentReferenceHashMap(int initialCapacity) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL,_				DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map;public,concurrent,reference,hash,map,int,initial,capacity,this,initial,capacity
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity);1355313310;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map;public ConcurrentReferenceHashMap(int initialCapacity) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL,_				DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map;public,concurrent,reference,hash,map,int,initial,capacity,this,initial,capacity
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity);1356735495;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map;public ConcurrentReferenceHashMap(int initialCapacity) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL,_				DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map;public,concurrent,reference,hash,map,int,initial,capacity,this,initial,capacity
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity);1357119239;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map;public ConcurrentReferenceHashMap(int initialCapacity) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL,_				DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map;public,concurrent,reference,hash,map,int,initial,capacity,this,initial,capacity
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity);1368482696;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map;public ConcurrentReferenceHashMap(int initialCapacity) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL,_				DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map;public,concurrent,reference,hash,map,int,initial,capacity,this,initial,capacity
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity);1383090835;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map;public ConcurrentReferenceHashMap(int initialCapacity) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map;public,concurrent,reference,hash,map,int,initial,capacity,this,initial,capacity
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity);1383178438;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map;public ConcurrentReferenceHashMap(int initialCapacity) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map;public,concurrent,reference,hash,map,int,initial,capacity,this,initial,capacity
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity);1390260938;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map;public ConcurrentReferenceHashMap(int initialCapacity) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map;public,concurrent,reference,hash,map,int,initial,capacity,this,initial,capacity
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity);1391715359;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map;public ConcurrentReferenceHashMap(int initialCapacity) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map;public,concurrent,reference,hash,map,int,initial,capacity,this,initial,capacity
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity);1392765030;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map;public ConcurrentReferenceHashMap(int initialCapacity) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map;public,concurrent,reference,hash,map,int,initial,capacity,this,initial,capacity
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity);1398175099;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map;public ConcurrentReferenceHashMap(int initialCapacity) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map;public,concurrent,reference,hash,map,int,initial,capacity,this,initial,capacity
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity);1404132943;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map;public ConcurrentReferenceHashMap(int initialCapacity) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map;public,concurrent,reference,hash,map,int,initial,capacity,this,initial,capacity
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity);1427240641;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map;public ConcurrentReferenceHashMap(int initialCapacity) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map;public,concurrent,reference,hash,map,int,initial,capacity,this,initial,capacity
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity);1459795890;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map;public ConcurrentReferenceHashMap(int initialCapacity) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map;public,concurrent,reference,hash,map,int,initial,capacity,this,initial,capacity
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity);1467730834;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map;public ConcurrentReferenceHashMap(int initialCapacity) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map;public,concurrent,reference,hash,map,int,initial,capacity,this,initial,capacity
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity);1485810955;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map;public ConcurrentReferenceHashMap(int initialCapacity) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map;public,concurrent,reference,hash,map,int,initial,capacity,this,initial,capacity
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity);1495868221;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map;public ConcurrentReferenceHashMap(int initialCapacity) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map;public,concurrent,reference,hash,map,int,initial,capacity,this,initial,capacity
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity);1496242568;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map;public ConcurrentReferenceHashMap(int initialCapacity) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map;public,concurrent,reference,hash,map,int,initial,capacity,this,initial,capacity
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity);1496837955;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map;public ConcurrentReferenceHashMap(int initialCapacity) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map;public,concurrent,reference,hash,map,int,initial,capacity,this,initial,capacity
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity);1498780456;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map;public ConcurrentReferenceHashMap(int initialCapacity) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map;public,concurrent,reference,hash,map,int,initial,capacity,this,initial,capacity
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity);1502974979;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map;public ConcurrentReferenceHashMap(int initialCapacity) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map;public,concurrent,reference,hash,map,int,initial,capacity,this,initial,capacity
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity);1506097334;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map;public ConcurrentReferenceHashMap(int initialCapacity) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map;public,concurrent,reference,hash,map,int,initial,capacity,this,initial,capacity
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity);1521044224;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map;public ConcurrentReferenceHashMap(int initialCapacity) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map;public,concurrent,reference,hash,map,int,initial,capacity,this,initial,capacity
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity);1530174524;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map;public ConcurrentReferenceHashMap(int initialCapacity) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map;public,concurrent,reference,hash,map,int,initial,capacity,this,initial,capacity
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity);1530190293;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map;public ConcurrentReferenceHashMap(int initialCapacity) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map;public,concurrent,reference,hash,map,int,initial,capacity,this,initial,capacity
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity);1530563577;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map;public ConcurrentReferenceHashMap(int initialCapacity) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map;public,concurrent,reference,hash,map,int,initial,capacity,this,initial,capacity
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity);1531136363;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map;public ConcurrentReferenceHashMap(int initialCapacity) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map;public,concurrent,reference,hash,map,int,initial,capacity,this,initial,capacity
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity);1531139295;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map;public ConcurrentReferenceHashMap(int initialCapacity) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map;public,concurrent,reference,hash,map,int,initial,capacity,this,initial,capacity
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity);1544716668;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map;public ConcurrentReferenceHashMap(int initialCapacity) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map;public,concurrent,reference,hash,map,int,initial,capacity,this,initial,capacity
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity);1549318940;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map;public ConcurrentReferenceHashMap(int initialCapacity) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map;public,concurrent,reference,hash,map,int,initial,capacity,this,initial,capacity
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity);1549321822;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map;public ConcurrentReferenceHashMap(int initialCapacity) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map;public,concurrent,reference,hash,map,int,initial,capacity,this,initial,capacity
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity);1550237263;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map;public ConcurrentReferenceHashMap(int initialCapacity) {_		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map;public,concurrent,reference,hash,map,int,initial,capacity,this,initial,capacity
ConcurrentReferenceHashMap -> protected final Reference<K, V> getReference(Object key, Restructure restructure);1351982790;Returns a {@link Reference} to the {@link Entry} for the specified {@code key} or_{@code null} if not found._@param key the key (can be {@code null})_@param restructure types of restructure allowed during this call_@return the reference or {@code null};protected final Reference<K, V> getReference(Object key, Restructure restructure) {_		int hash = getHash(key)__		return getSegmentForHash(hash).getReference(key, hash, restructure)__	};returns,a,link,reference,to,the,link,entry,for,the,specified,code,key,or,code,null,if,not,found,param,key,the,key,can,be,code,null,param,restructure,types,of,restructure,allowed,during,this,call,return,the,reference,or,code,null;protected,final,reference,k,v,get,reference,object,key,restructure,restructure,int,hash,get,hash,key,return,get,segment,for,hash,hash,get,reference,key,hash,restructure
ConcurrentReferenceHashMap -> protected final Reference<K, V> getReference(Object key, Restructure restructure);1352039846;Returns a {@link Reference} to the {@link Entry} for the specified {@code key} or_{@code null} if not found._@param key the key (can be {@code null})_@param restructure types of restructure allowed during this call_@return the reference or {@code null};protected final Reference<K, V> getReference(Object key, Restructure restructure) {_		int hash = getHash(key)__		return getSegmentForHash(hash).getReference(key, hash, restructure)__	};returns,a,link,reference,to,the,link,entry,for,the,specified,code,key,or,code,null,if,not,found,param,key,the,key,can,be,code,null,param,restructure,types,of,restructure,allowed,during,this,call,return,the,reference,or,code,null;protected,final,reference,k,v,get,reference,object,key,restructure,restructure,int,hash,get,hash,key,return,get,segment,for,hash,hash,get,reference,key,hash,restructure
ConcurrentReferenceHashMap -> protected final Reference<K, V> getReference(Object key, Restructure restructure);1355313310;Returns a {@link Reference} to the {@link Entry} for the specified {@code key} or_{@code null} if not found._@param key the key (can be {@code null})_@param restructure types of restructure allowed during this call_@return the reference or {@code null};protected final Reference<K, V> getReference(Object key, Restructure restructure) {_		int hash = getHash(key)__		return getSegmentForHash(hash).getReference(key, hash, restructure)__	};returns,a,link,reference,to,the,link,entry,for,the,specified,code,key,or,code,null,if,not,found,param,key,the,key,can,be,code,null,param,restructure,types,of,restructure,allowed,during,this,call,return,the,reference,or,code,null;protected,final,reference,k,v,get,reference,object,key,restructure,restructure,int,hash,get,hash,key,return,get,segment,for,hash,hash,get,reference,key,hash,restructure
ConcurrentReferenceHashMap -> protected final Reference<K, V> getReference(Object key, Restructure restructure);1356735495;Returns a {@link Reference} to the {@link Entry} for the specified {@code key} or_{@code null} if not found._@param key the key (can be {@code null})_@param restructure types of restructure allowed during this call_@return the reference or {@code null};protected final Reference<K, V> getReference(Object key, Restructure restructure) {_		int hash = getHash(key)__		return getSegmentForHash(hash).getReference(key, hash, restructure)__	};returns,a,link,reference,to,the,link,entry,for,the,specified,code,key,or,code,null,if,not,found,param,key,the,key,can,be,code,null,param,restructure,types,of,restructure,allowed,during,this,call,return,the,reference,or,code,null;protected,final,reference,k,v,get,reference,object,key,restructure,restructure,int,hash,get,hash,key,return,get,segment,for,hash,hash,get,reference,key,hash,restructure
ConcurrentReferenceHashMap -> protected final Reference<K, V> getReference(Object key, Restructure restructure);1357119239;Returns a {@link Reference} to the {@link Entry} for the specified {@code key} or_{@code null} if not found._@param key the key (can be {@code null})_@param restructure types of restructure allowed during this call_@return the reference or {@code null};protected final Reference<K, V> getReference(Object key, Restructure restructure) {_		int hash = getHash(key)__		return getSegmentForHash(hash).getReference(key, hash, restructure)__	};returns,a,link,reference,to,the,link,entry,for,the,specified,code,key,or,code,null,if,not,found,param,key,the,key,can,be,code,null,param,restructure,types,of,restructure,allowed,during,this,call,return,the,reference,or,code,null;protected,final,reference,k,v,get,reference,object,key,restructure,restructure,int,hash,get,hash,key,return,get,segment,for,hash,hash,get,reference,key,hash,restructure
ConcurrentReferenceHashMap -> protected final Reference<K, V> getReference(Object key, Restructure restructure);1368482696;Returns a {@link Reference} to the {@link Entry} for the specified {@code key} or_{@code null} if not found._@param key the key (can be {@code null})_@param restructure types of restructure allowed during this call_@return the reference or {@code null};protected final Reference<K, V> getReference(Object key, Restructure restructure) {_		int hash = getHash(key)__		return getSegmentForHash(hash).getReference(key, hash, restructure)__	};returns,a,link,reference,to,the,link,entry,for,the,specified,code,key,or,code,null,if,not,found,param,key,the,key,can,be,code,null,param,restructure,types,of,restructure,allowed,during,this,call,return,the,reference,or,code,null;protected,final,reference,k,v,get,reference,object,key,restructure,restructure,int,hash,get,hash,key,return,get,segment,for,hash,hash,get,reference,key,hash,restructure
ConcurrentReferenceHashMap -> protected final Reference<K, V> getReference(Object key, Restructure restructure);1383090835;Returns a {@link Reference} to the {@link Entry} for the specified {@code key} or_{@code null} if not found._@param key the key (can be {@code null})_@param restructure types of restructure allowed during this call_@return the reference or {@code null};protected final Reference<K, V> getReference(Object key, Restructure restructure) {_		int hash = getHash(key)__		return getSegmentForHash(hash).getReference(key, hash, restructure)__	};returns,a,link,reference,to,the,link,entry,for,the,specified,code,key,or,code,null,if,not,found,param,key,the,key,can,be,code,null,param,restructure,types,of,restructure,allowed,during,this,call,return,the,reference,or,code,null;protected,final,reference,k,v,get,reference,object,key,restructure,restructure,int,hash,get,hash,key,return,get,segment,for,hash,hash,get,reference,key,hash,restructure
ConcurrentReferenceHashMap -> protected final Reference<K, V> getReference(Object key, Restructure restructure);1383178438;Returns a {@link Reference} to the {@link Entry} for the specified {@code key} or_{@code null} if not found._@param key the key (can be {@code null})_@param restructure types of restructure allowed during this call_@return the reference or {@code null};protected final Reference<K, V> getReference(Object key, Restructure restructure) {_		int hash = getHash(key)__		return getSegmentForHash(hash).getReference(key, hash, restructure)__	};returns,a,link,reference,to,the,link,entry,for,the,specified,code,key,or,code,null,if,not,found,param,key,the,key,can,be,code,null,param,restructure,types,of,restructure,allowed,during,this,call,return,the,reference,or,code,null;protected,final,reference,k,v,get,reference,object,key,restructure,restructure,int,hash,get,hash,key,return,get,segment,for,hash,hash,get,reference,key,hash,restructure
ConcurrentReferenceHashMap -> protected final Reference<K, V> getReference(Object key, Restructure restructure);1390260938;Returns a {@link Reference} to the {@link Entry} for the specified {@code key} or_{@code null} if not found._@param key the key (can be {@code null})_@param restructure types of restructure allowed during this call_@return the reference or {@code null};protected final Reference<K, V> getReference(Object key, Restructure restructure) {_		int hash = getHash(key)__		return getSegmentForHash(hash).getReference(key, hash, restructure)__	};returns,a,link,reference,to,the,link,entry,for,the,specified,code,key,or,code,null,if,not,found,param,key,the,key,can,be,code,null,param,restructure,types,of,restructure,allowed,during,this,call,return,the,reference,or,code,null;protected,final,reference,k,v,get,reference,object,key,restructure,restructure,int,hash,get,hash,key,return,get,segment,for,hash,hash,get,reference,key,hash,restructure
ConcurrentReferenceHashMap -> protected final Reference<K, V> getReference(Object key, Restructure restructure);1391715359;Returns a {@link Reference} to the {@link Entry} for the specified {@code key} or_{@code null} if not found._@param key the key (can be {@code null})_@param restructure types of restructure allowed during this call_@return the reference or {@code null};protected final Reference<K, V> getReference(Object key, Restructure restructure) {_		int hash = getHash(key)__		return getSegmentForHash(hash).getReference(key, hash, restructure)__	};returns,a,link,reference,to,the,link,entry,for,the,specified,code,key,or,code,null,if,not,found,param,key,the,key,can,be,code,null,param,restructure,types,of,restructure,allowed,during,this,call,return,the,reference,or,code,null;protected,final,reference,k,v,get,reference,object,key,restructure,restructure,int,hash,get,hash,key,return,get,segment,for,hash,hash,get,reference,key,hash,restructure
ConcurrentReferenceHashMap -> protected final Reference<K, V> getReference(Object key, Restructure restructure);1392765030;Returns a {@link Reference} to the {@link Entry} for the specified {@code key} or_{@code null} if not found._@param key the key (can be {@code null})_@param restructure types of restructure allowed during this call_@return the reference or {@code null};protected final Reference<K, V> getReference(Object key, Restructure restructure) {_		int hash = getHash(key)__		return getSegmentForHash(hash).getReference(key, hash, restructure)__	};returns,a,link,reference,to,the,link,entry,for,the,specified,code,key,or,code,null,if,not,found,param,key,the,key,can,be,code,null,param,restructure,types,of,restructure,allowed,during,this,call,return,the,reference,or,code,null;protected,final,reference,k,v,get,reference,object,key,restructure,restructure,int,hash,get,hash,key,return,get,segment,for,hash,hash,get,reference,key,hash,restructure
ConcurrentReferenceHashMap -> protected final Reference<K, V> getReference(Object key, Restructure restructure);1398175099;Returns a {@link Reference} to the {@link Entry} for the specified {@code key} or_{@code null} if not found._@param key the key (can be {@code null})_@param restructure types of restructure allowed during this call_@return the reference or {@code null};protected final Reference<K, V> getReference(Object key, Restructure restructure) {_		int hash = getHash(key)__		return getSegmentForHash(hash).getReference(key, hash, restructure)__	};returns,a,link,reference,to,the,link,entry,for,the,specified,code,key,or,code,null,if,not,found,param,key,the,key,can,be,code,null,param,restructure,types,of,restructure,allowed,during,this,call,return,the,reference,or,code,null;protected,final,reference,k,v,get,reference,object,key,restructure,restructure,int,hash,get,hash,key,return,get,segment,for,hash,hash,get,reference,key,hash,restructure
ConcurrentReferenceHashMap -> protected final Reference<K, V> getReference(Object key, Restructure restructure);1404132943;Return a {@link Reference} to the {@link Entry} for the specified {@code key},_or {@code null} if not found._@param key the key (can be {@code null})_@param restructure types of restructure allowed during this call_@return the reference, or {@code null} if not found;protected final Reference<K, V> getReference(Object key, Restructure restructure) {_		int hash = getHash(key)__		return getSegmentForHash(hash).getReference(key, hash, restructure)__	};return,a,link,reference,to,the,link,entry,for,the,specified,code,key,or,code,null,if,not,found,param,key,the,key,can,be,code,null,param,restructure,types,of,restructure,allowed,during,this,call,return,the,reference,or,code,null,if,not,found;protected,final,reference,k,v,get,reference,object,key,restructure,restructure,int,hash,get,hash,key,return,get,segment,for,hash,hash,get,reference,key,hash,restructure
ConcurrentReferenceHashMap -> protected final Reference<K, V> getReference(Object key, Restructure restructure);1427240641;Return a {@link Reference} to the {@link Entry} for the specified {@code key},_or {@code null} if not found._@param key the key (can be {@code null})_@param restructure types of restructure allowed during this call_@return the reference, or {@code null} if not found;protected final Reference<K, V> getReference(Object key, Restructure restructure) {_		int hash = getHash(key)__		return getSegmentForHash(hash).getReference(key, hash, restructure)__	};return,a,link,reference,to,the,link,entry,for,the,specified,code,key,or,code,null,if,not,found,param,key,the,key,can,be,code,null,param,restructure,types,of,restructure,allowed,during,this,call,return,the,reference,or,code,null,if,not,found;protected,final,reference,k,v,get,reference,object,key,restructure,restructure,int,hash,get,hash,key,return,get,segment,for,hash,hash,get,reference,key,hash,restructure
ConcurrentReferenceHashMap -> protected final Reference<K, V> getReference(Object key, Restructure restructure);1459795890;Return a {@link Reference} to the {@link Entry} for the specified {@code key},_or {@code null} if not found._@param key the key (can be {@code null})_@param restructure types of restructure allowed during this call_@return the reference, or {@code null} if not found;protected final Reference<K, V> getReference(Object key, Restructure restructure) {_		int hash = getHash(key)__		return getSegmentForHash(hash).getReference(key, hash, restructure)__	};return,a,link,reference,to,the,link,entry,for,the,specified,code,key,or,code,null,if,not,found,param,key,the,key,can,be,code,null,param,restructure,types,of,restructure,allowed,during,this,call,return,the,reference,or,code,null,if,not,found;protected,final,reference,k,v,get,reference,object,key,restructure,restructure,int,hash,get,hash,key,return,get,segment,for,hash,hash,get,reference,key,hash,restructure
ConcurrentReferenceHashMap -> protected final Reference<K, V> getReference(Object key, Restructure restructure);1467730834;Return a {@link Reference} to the {@link Entry} for the specified {@code key},_or {@code null} if not found._@param key the key (can be {@code null})_@param restructure types of restructure allowed during this call_@return the reference, or {@code null} if not found;protected final Reference<K, V> getReference(Object key, Restructure restructure) {_		int hash = getHash(key)__		return getSegmentForHash(hash).getReference(key, hash, restructure)__	};return,a,link,reference,to,the,link,entry,for,the,specified,code,key,or,code,null,if,not,found,param,key,the,key,can,be,code,null,param,restructure,types,of,restructure,allowed,during,this,call,return,the,reference,or,code,null,if,not,found;protected,final,reference,k,v,get,reference,object,key,restructure,restructure,int,hash,get,hash,key,return,get,segment,for,hash,hash,get,reference,key,hash,restructure
ConcurrentReferenceHashMap -> protected final Reference<K, V> getReference(Object key, Restructure restructure);1485810955;Return a {@link Reference} to the {@link Entry} for the specified {@code key},_or {@code null} if not found._@param key the key (can be {@code null})_@param restructure types of restructure allowed during this call_@return the reference, or {@code null} if not found;protected final Reference<K, V> getReference(Object key, Restructure restructure) {_		int hash = getHash(key)__		return getSegmentForHash(hash).getReference(key, hash, restructure)__	};return,a,link,reference,to,the,link,entry,for,the,specified,code,key,or,code,null,if,not,found,param,key,the,key,can,be,code,null,param,restructure,types,of,restructure,allowed,during,this,call,return,the,reference,or,code,null,if,not,found;protected,final,reference,k,v,get,reference,object,key,restructure,restructure,int,hash,get,hash,key,return,get,segment,for,hash,hash,get,reference,key,hash,restructure
ConcurrentReferenceHashMap -> protected int getHash(Object o);1351982790;Get the hash for a given object, apply an additional hash function to reduce_collisions. This implementation uses the same Wang/Jenkins algorithm as_{@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing._@param o the object to hash (may be null)_@return the resulting hash code;protected int getHash(Object o) {_		int hash = o == null ? 0 : o.hashCode()__		hash += (hash << 15) ^ 0xffffcd7d__		hash ^= (hash >>> 10)__		hash += (hash << 3)__		hash ^= (hash >>> 6)__		hash += (hash << 2) + (hash << 14)__		hash ^= (hash >>> 16)__		return hash__	};get,the,hash,for,a,given,object,apply,an,additional,hash,function,to,reduce,collisions,this,implementation,uses,the,same,wang,jenkins,algorithm,as,link,concurrent,hash,map,subclasses,can,override,to,provide,alternative,hashing,param,o,the,object,to,hash,may,be,null,return,the,resulting,hash,code;protected,int,get,hash,object,o,int,hash,o,null,0,o,hash,code,hash,hash,15,0xffffcd7d,hash,hash,10,hash,hash,3,hash,hash,6,hash,hash,2,hash,14,hash,hash,16,return,hash
ConcurrentReferenceHashMap -> protected int getHash(Object o);1352039846;Get the hash for a given object, apply an additional hash function to reduce_collisions. This implementation uses the same Wang/Jenkins algorithm as_{@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing._@param o the object to hash (may be null)_@return the resulting hash code;protected int getHash(Object o) {_		int hash = o == null ? 0 : o.hashCode()__		hash += (hash << 15) ^ 0xffffcd7d__		hash ^= (hash >>> 10)__		hash += (hash << 3)__		hash ^= (hash >>> 6)__		hash += (hash << 2) + (hash << 14)__		hash ^= (hash >>> 16)__		return hash__	};get,the,hash,for,a,given,object,apply,an,additional,hash,function,to,reduce,collisions,this,implementation,uses,the,same,wang,jenkins,algorithm,as,link,concurrent,hash,map,subclasses,can,override,to,provide,alternative,hashing,param,o,the,object,to,hash,may,be,null,return,the,resulting,hash,code;protected,int,get,hash,object,o,int,hash,o,null,0,o,hash,code,hash,hash,15,0xffffcd7d,hash,hash,10,hash,hash,3,hash,hash,6,hash,hash,2,hash,14,hash,hash,16,return,hash
ConcurrentReferenceHashMap -> protected int getHash(Object o);1355313310;Get the hash for a given object, apply an additional hash function to reduce_collisions. This implementation uses the same Wang/Jenkins algorithm as_{@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing._@param o the object to hash (may be null)_@return the resulting hash code;protected int getHash(Object o) {_		int hash = o == null ? 0 : o.hashCode()__		hash += (hash << 15) ^ 0xffffcd7d__		hash ^= (hash >>> 10)__		hash += (hash << 3)__		hash ^= (hash >>> 6)__		hash += (hash << 2) + (hash << 14)__		hash ^= (hash >>> 16)__		return hash__	};get,the,hash,for,a,given,object,apply,an,additional,hash,function,to,reduce,collisions,this,implementation,uses,the,same,wang,jenkins,algorithm,as,link,concurrent,hash,map,subclasses,can,override,to,provide,alternative,hashing,param,o,the,object,to,hash,may,be,null,return,the,resulting,hash,code;protected,int,get,hash,object,o,int,hash,o,null,0,o,hash,code,hash,hash,15,0xffffcd7d,hash,hash,10,hash,hash,3,hash,hash,6,hash,hash,2,hash,14,hash,hash,16,return,hash
ConcurrentReferenceHashMap -> protected int getHash(Object o);1356735495;Get the hash for a given object, apply an additional hash function to reduce_collisions. This implementation uses the same Wang/Jenkins algorithm as_{@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing._@param o the object to hash (may be null)_@return the resulting hash code;protected int getHash(Object o) {_		int hash = o == null ? 0 : o.hashCode()__		hash += (hash << 15) ^ 0xffffcd7d__		hash ^= (hash >>> 10)__		hash += (hash << 3)__		hash ^= (hash >>> 6)__		hash += (hash << 2) + (hash << 14)__		hash ^= (hash >>> 16)__		return hash__	};get,the,hash,for,a,given,object,apply,an,additional,hash,function,to,reduce,collisions,this,implementation,uses,the,same,wang,jenkins,algorithm,as,link,concurrent,hash,map,subclasses,can,override,to,provide,alternative,hashing,param,o,the,object,to,hash,may,be,null,return,the,resulting,hash,code;protected,int,get,hash,object,o,int,hash,o,null,0,o,hash,code,hash,hash,15,0xffffcd7d,hash,hash,10,hash,hash,3,hash,hash,6,hash,hash,2,hash,14,hash,hash,16,return,hash
ConcurrentReferenceHashMap -> protected int getHash(Object o);1357119239;Get the hash for a given object, apply an additional hash function to reduce_collisions. This implementation uses the same Wang/Jenkins algorithm as_{@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing._@param o the object to hash (may be null)_@return the resulting hash code;protected int getHash(Object o) {_		int hash = o == null ? 0 : o.hashCode()__		hash += (hash << 15) ^ 0xffffcd7d__		hash ^= (hash >>> 10)__		hash += (hash << 3)__		hash ^= (hash >>> 6)__		hash += (hash << 2) + (hash << 14)__		hash ^= (hash >>> 16)__		return hash__	};get,the,hash,for,a,given,object,apply,an,additional,hash,function,to,reduce,collisions,this,implementation,uses,the,same,wang,jenkins,algorithm,as,link,concurrent,hash,map,subclasses,can,override,to,provide,alternative,hashing,param,o,the,object,to,hash,may,be,null,return,the,resulting,hash,code;protected,int,get,hash,object,o,int,hash,o,null,0,o,hash,code,hash,hash,15,0xffffcd7d,hash,hash,10,hash,hash,3,hash,hash,6,hash,hash,2,hash,14,hash,hash,16,return,hash
ConcurrentReferenceHashMap -> protected int getHash(Object o);1368482696;Get the hash for a given object, apply an additional hash function to reduce_collisions. This implementation uses the same Wang/Jenkins algorithm as_{@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing._@param o the object to hash (may be null)_@return the resulting hash code;protected int getHash(Object o) {_		int hash = o == null ? 0 : o.hashCode()__		hash += (hash << 15) ^ 0xffffcd7d__		hash ^= (hash >>> 10)__		hash += (hash << 3)__		hash ^= (hash >>> 6)__		hash += (hash << 2) + (hash << 14)__		hash ^= (hash >>> 16)__		return hash__	};get,the,hash,for,a,given,object,apply,an,additional,hash,function,to,reduce,collisions,this,implementation,uses,the,same,wang,jenkins,algorithm,as,link,concurrent,hash,map,subclasses,can,override,to,provide,alternative,hashing,param,o,the,object,to,hash,may,be,null,return,the,resulting,hash,code;protected,int,get,hash,object,o,int,hash,o,null,0,o,hash,code,hash,hash,15,0xffffcd7d,hash,hash,10,hash,hash,3,hash,hash,6,hash,hash,2,hash,14,hash,hash,16,return,hash
ConcurrentReferenceHashMap -> protected int getHash(Object o);1383090835;Get the hash for a given object, apply an additional hash function to reduce_collisions. This implementation uses the same Wang/Jenkins algorithm as_{@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing._@param o the object to hash (may be null)_@return the resulting hash code;protected int getHash(Object o) {_		int hash = o == null ? 0 : o.hashCode()__		hash += (hash << 15) ^ 0xffffcd7d__		hash ^= (hash >>> 10)__		hash += (hash << 3)__		hash ^= (hash >>> 6)__		hash += (hash << 2) + (hash << 14)__		hash ^= (hash >>> 16)__		return hash__	};get,the,hash,for,a,given,object,apply,an,additional,hash,function,to,reduce,collisions,this,implementation,uses,the,same,wang,jenkins,algorithm,as,link,concurrent,hash,map,subclasses,can,override,to,provide,alternative,hashing,param,o,the,object,to,hash,may,be,null,return,the,resulting,hash,code;protected,int,get,hash,object,o,int,hash,o,null,0,o,hash,code,hash,hash,15,0xffffcd7d,hash,hash,10,hash,hash,3,hash,hash,6,hash,hash,2,hash,14,hash,hash,16,return,hash
ConcurrentReferenceHashMap -> protected int getHash(Object o);1383178438;Get the hash for a given object, apply an additional hash function to reduce_collisions. This implementation uses the same Wang/Jenkins algorithm as_{@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing._@param o the object to hash (may be null)_@return the resulting hash code;protected int getHash(Object o) {_		int hash = o == null ? 0 : o.hashCode()__		hash += (hash << 15) ^ 0xffffcd7d__		hash ^= (hash >>> 10)__		hash += (hash << 3)__		hash ^= (hash >>> 6)__		hash += (hash << 2) + (hash << 14)__		hash ^= (hash >>> 16)__		return hash__	};get,the,hash,for,a,given,object,apply,an,additional,hash,function,to,reduce,collisions,this,implementation,uses,the,same,wang,jenkins,algorithm,as,link,concurrent,hash,map,subclasses,can,override,to,provide,alternative,hashing,param,o,the,object,to,hash,may,be,null,return,the,resulting,hash,code;protected,int,get,hash,object,o,int,hash,o,null,0,o,hash,code,hash,hash,15,0xffffcd7d,hash,hash,10,hash,hash,3,hash,hash,6,hash,hash,2,hash,14,hash,hash,16,return,hash
ConcurrentReferenceHashMap -> protected int getHash(Object o);1390260938;Get the hash for a given object, apply an additional hash function to reduce_collisions. This implementation uses the same Wang/Jenkins algorithm as_{@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing._@param o the object to hash (may be null)_@return the resulting hash code;protected int getHash(Object o) {_		int hash = o == null ? 0 : o.hashCode()__		hash += (hash << 15) ^ 0xffffcd7d__		hash ^= (hash >>> 10)__		hash += (hash << 3)__		hash ^= (hash >>> 6)__		hash += (hash << 2) + (hash << 14)__		hash ^= (hash >>> 16)__		return hash__	};get,the,hash,for,a,given,object,apply,an,additional,hash,function,to,reduce,collisions,this,implementation,uses,the,same,wang,jenkins,algorithm,as,link,concurrent,hash,map,subclasses,can,override,to,provide,alternative,hashing,param,o,the,object,to,hash,may,be,null,return,the,resulting,hash,code;protected,int,get,hash,object,o,int,hash,o,null,0,o,hash,code,hash,hash,15,0xffffcd7d,hash,hash,10,hash,hash,3,hash,hash,6,hash,hash,2,hash,14,hash,hash,16,return,hash
ConcurrentReferenceHashMap -> protected int getHash(Object o);1391715359;Get the hash for a given object, apply an additional hash function to reduce_collisions. This implementation uses the same Wang/Jenkins algorithm as_{@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing._@param o the object to hash (may be null)_@return the resulting hash code;protected int getHash(Object o) {_		int hash = o == null ? 0 : o.hashCode()__		hash += (hash << 15) ^ 0xffffcd7d__		hash ^= (hash >>> 10)__		hash += (hash << 3)__		hash ^= (hash >>> 6)__		hash += (hash << 2) + (hash << 14)__		hash ^= (hash >>> 16)__		return hash__	};get,the,hash,for,a,given,object,apply,an,additional,hash,function,to,reduce,collisions,this,implementation,uses,the,same,wang,jenkins,algorithm,as,link,concurrent,hash,map,subclasses,can,override,to,provide,alternative,hashing,param,o,the,object,to,hash,may,be,null,return,the,resulting,hash,code;protected,int,get,hash,object,o,int,hash,o,null,0,o,hash,code,hash,hash,15,0xffffcd7d,hash,hash,10,hash,hash,3,hash,hash,6,hash,hash,2,hash,14,hash,hash,16,return,hash
ConcurrentReferenceHashMap -> protected int getHash(Object o);1392765030;Get the hash for a given object, apply an additional hash function to reduce_collisions. This implementation uses the same Wang/Jenkins algorithm as_{@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing._@param o the object to hash (may be null)_@return the resulting hash code;protected int getHash(Object o) {_		int hash = o == null ? 0 : o.hashCode()__		hash += (hash << 15) ^ 0xffffcd7d__		hash ^= (hash >>> 10)__		hash += (hash << 3)__		hash ^= (hash >>> 6)__		hash += (hash << 2) + (hash << 14)__		hash ^= (hash >>> 16)__		return hash__	};get,the,hash,for,a,given,object,apply,an,additional,hash,function,to,reduce,collisions,this,implementation,uses,the,same,wang,jenkins,algorithm,as,link,concurrent,hash,map,subclasses,can,override,to,provide,alternative,hashing,param,o,the,object,to,hash,may,be,null,return,the,resulting,hash,code;protected,int,get,hash,object,o,int,hash,o,null,0,o,hash,code,hash,hash,15,0xffffcd7d,hash,hash,10,hash,hash,3,hash,hash,6,hash,hash,2,hash,14,hash,hash,16,return,hash
ConcurrentReferenceHashMap -> protected int getHash(Object o);1398175099;Get the hash for a given object, apply an additional hash function to reduce_collisions. This implementation uses the same Wang/Jenkins algorithm as_{@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing._@param o the object to hash (may be null)_@return the resulting hash code;protected int getHash(Object o) {_		int hash = o == null ? 0 : o.hashCode()__		hash += (hash << 15) ^ 0xffffcd7d__		hash ^= (hash >>> 10)__		hash += (hash << 3)__		hash ^= (hash >>> 6)__		hash += (hash << 2) + (hash << 14)__		hash ^= (hash >>> 16)__		return hash__	};get,the,hash,for,a,given,object,apply,an,additional,hash,function,to,reduce,collisions,this,implementation,uses,the,same,wang,jenkins,algorithm,as,link,concurrent,hash,map,subclasses,can,override,to,provide,alternative,hashing,param,o,the,object,to,hash,may,be,null,return,the,resulting,hash,code;protected,int,get,hash,object,o,int,hash,o,null,0,o,hash,code,hash,hash,15,0xffffcd7d,hash,hash,10,hash,hash,3,hash,hash,6,hash,hash,2,hash,14,hash,hash,16,return,hash
ConcurrentReferenceHashMap -> protected int getHash(Object o);1404132943;Get the hash for a given object, apply an additional hash function to reduce_collisions. This implementation uses the same Wang/Jenkins algorithm as_{@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing._@param o the object to hash (may be null)_@return the resulting hash code;protected int getHash(Object o) {_		int hash = o == null ? 0 : o.hashCode()__		hash += (hash << 15) ^ 0xffffcd7d__		hash ^= (hash >>> 10)__		hash += (hash << 3)__		hash ^= (hash >>> 6)__		hash += (hash << 2) + (hash << 14)__		hash ^= (hash >>> 16)__		return hash__	};get,the,hash,for,a,given,object,apply,an,additional,hash,function,to,reduce,collisions,this,implementation,uses,the,same,wang,jenkins,algorithm,as,link,concurrent,hash,map,subclasses,can,override,to,provide,alternative,hashing,param,o,the,object,to,hash,may,be,null,return,the,resulting,hash,code;protected,int,get,hash,object,o,int,hash,o,null,0,o,hash,code,hash,hash,15,0xffffcd7d,hash,hash,10,hash,hash,3,hash,hash,6,hash,hash,2,hash,14,hash,hash,16,return,hash
ConcurrentReferenceHashMap -> protected int getHash(Object o);1427240641;Get the hash for a given object, apply an additional hash function to reduce_collisions. This implementation uses the same Wang/Jenkins algorithm as_{@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing._@param o the object to hash (may be null)_@return the resulting hash code;protected int getHash(Object o) {_		int hash = o == null ? 0 : o.hashCode()__		hash += (hash << 15) ^ 0xffffcd7d__		hash ^= (hash >>> 10)__		hash += (hash << 3)__		hash ^= (hash >>> 6)__		hash += (hash << 2) + (hash << 14)__		hash ^= (hash >>> 16)__		return hash__	};get,the,hash,for,a,given,object,apply,an,additional,hash,function,to,reduce,collisions,this,implementation,uses,the,same,wang,jenkins,algorithm,as,link,concurrent,hash,map,subclasses,can,override,to,provide,alternative,hashing,param,o,the,object,to,hash,may,be,null,return,the,resulting,hash,code;protected,int,get,hash,object,o,int,hash,o,null,0,o,hash,code,hash,hash,15,0xffffcd7d,hash,hash,10,hash,hash,3,hash,hash,6,hash,hash,2,hash,14,hash,hash,16,return,hash
ConcurrentReferenceHashMap -> protected int getHash(Object o);1459795890;Get the hash for a given object, apply an additional hash function to reduce_collisions. This implementation uses the same Wang/Jenkins algorithm as_{@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing._@param o the object to hash (may be null)_@return the resulting hash code;protected int getHash(Object o) {_		int hash = o == null ? 0 : o.hashCode()__		hash += (hash << 15) ^ 0xffffcd7d__		hash ^= (hash >>> 10)__		hash += (hash << 3)__		hash ^= (hash >>> 6)__		hash += (hash << 2) + (hash << 14)__		hash ^= (hash >>> 16)__		return hash__	};get,the,hash,for,a,given,object,apply,an,additional,hash,function,to,reduce,collisions,this,implementation,uses,the,same,wang,jenkins,algorithm,as,link,concurrent,hash,map,subclasses,can,override,to,provide,alternative,hashing,param,o,the,object,to,hash,may,be,null,return,the,resulting,hash,code;protected,int,get,hash,object,o,int,hash,o,null,0,o,hash,code,hash,hash,15,0xffffcd7d,hash,hash,10,hash,hash,3,hash,hash,6,hash,hash,2,hash,14,hash,hash,16,return,hash
ConcurrentReferenceHashMap -> protected int getHash(Object o);1467730834;Get the hash for a given object, apply an additional hash function to reduce_collisions. This implementation uses the same Wang/Jenkins algorithm as_{@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing._@param o the object to hash (may be null)_@return the resulting hash code;protected int getHash(Object o) {_		int hash = o == null ? 0 : o.hashCode()__		hash += (hash << 15) ^ 0xffffcd7d__		hash ^= (hash >>> 10)__		hash += (hash << 3)__		hash ^= (hash >>> 6)__		hash += (hash << 2) + (hash << 14)__		hash ^= (hash >>> 16)__		return hash__	};get,the,hash,for,a,given,object,apply,an,additional,hash,function,to,reduce,collisions,this,implementation,uses,the,same,wang,jenkins,algorithm,as,link,concurrent,hash,map,subclasses,can,override,to,provide,alternative,hashing,param,o,the,object,to,hash,may,be,null,return,the,resulting,hash,code;protected,int,get,hash,object,o,int,hash,o,null,0,o,hash,code,hash,hash,15,0xffffcd7d,hash,hash,10,hash,hash,3,hash,hash,6,hash,hash,2,hash,14,hash,hash,16,return,hash
ConcurrentReferenceHashMap -> protected int getHash(Object o);1485810955;Get the hash for a given object, apply an additional hash function to reduce_collisions. This implementation uses the same Wang/Jenkins algorithm as_{@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing._@param o the object to hash (may be null)_@return the resulting hash code;protected int getHash(Object o) {_		int hash = o == null ? 0 : o.hashCode()__		hash += (hash << 15) ^ 0xffffcd7d__		hash ^= (hash >>> 10)__		hash += (hash << 3)__		hash ^= (hash >>> 6)__		hash += (hash << 2) + (hash << 14)__		hash ^= (hash >>> 16)__		return hash__	};get,the,hash,for,a,given,object,apply,an,additional,hash,function,to,reduce,collisions,this,implementation,uses,the,same,wang,jenkins,algorithm,as,link,concurrent,hash,map,subclasses,can,override,to,provide,alternative,hashing,param,o,the,object,to,hash,may,be,null,return,the,resulting,hash,code;protected,int,get,hash,object,o,int,hash,o,null,0,o,hash,code,hash,hash,15,0xffffcd7d,hash,hash,10,hash,hash,3,hash,hash,6,hash,hash,2,hash,14,hash,hash,16,return,hash
ConcurrentReferenceHashMap -> Task -> @Nullable 		protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry);1530563577;Convenience method that can be used for tasks that do not need access to {@link Entries}._@param ref the found reference (or {@code null})_@param entry the found entry (or {@code null})_@return the result of the task_@see #execute(Reference, Entry, Entries);@Nullable_		protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {_			return null__		};convenience,method,that,can,be,used,for,tasks,that,do,not,need,access,to,link,entries,param,ref,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,return,the,result,of,the,task,see,execute,reference,entry,entries;nullable,protected,t,execute,nullable,reference,k,v,ref,nullable,entry,k,v,entry,return,null
ConcurrentReferenceHashMap -> Task -> @Nullable 		protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry);1531136363;Convenience method that can be used for tasks that do not need access to {@link Entries}._@param ref the found reference (or {@code null})_@param entry the found entry (or {@code null})_@return the result of the task_@see #execute(Reference, Entry, Entries);@Nullable_		protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {_			return null__		};convenience,method,that,can,be,used,for,tasks,that,do,not,need,access,to,link,entries,param,ref,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,return,the,result,of,the,task,see,execute,reference,entry,entries;nullable,protected,t,execute,nullable,reference,k,v,ref,nullable,entry,k,v,entry,return,null
ConcurrentReferenceHashMap -> Task -> @Nullable 		protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry);1531139295;Convenience method that can be used for tasks that do not need access to {@link Entries}._@param ref the found reference (or {@code null})_@param entry the found entry (or {@code null})_@return the result of the task_@see #execute(Reference, Entry, Entries);@Nullable_		protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {_			return null__		};convenience,method,that,can,be,used,for,tasks,that,do,not,need,access,to,link,entries,param,ref,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,return,the,result,of,the,task,see,execute,reference,entry,entries;nullable,protected,t,execute,nullable,reference,k,v,ref,nullable,entry,k,v,entry,return,null
ConcurrentReferenceHashMap -> Task -> @Nullable 		protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry);1544716668;Convenience method that can be used for tasks that do not need access to {@link Entries}._@param ref the found reference (or {@code null})_@param entry the found entry (or {@code null})_@return the result of the task_@see #execute(Reference, Entry, Entries);@Nullable_		protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {_			return null__		};convenience,method,that,can,be,used,for,tasks,that,do,not,need,access,to,link,entries,param,ref,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,return,the,result,of,the,task,see,execute,reference,entry,entries;nullable,protected,t,execute,nullable,reference,k,v,ref,nullable,entry,k,v,entry,return,null
ConcurrentReferenceHashMap -> Task -> @Nullable 		protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry);1549318940;Convenience method that can be used for tasks that do not need access to {@link Entries}._@param ref the found reference (or {@code null})_@param entry the found entry (or {@code null})_@return the result of the task_@see #execute(Reference, Entry, Entries);@Nullable_		protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {_			return null__		};convenience,method,that,can,be,used,for,tasks,that,do,not,need,access,to,link,entries,param,ref,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,return,the,result,of,the,task,see,execute,reference,entry,entries;nullable,protected,t,execute,nullable,reference,k,v,ref,nullable,entry,k,v,entry,return,null
ConcurrentReferenceHashMap -> Task -> @Nullable 		protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry);1549321822;Convenience method that can be used for tasks that do not need access to {@link Entries}._@param ref the found reference (or {@code null})_@param entry the found entry (or {@code null})_@return the result of the task_@see #execute(Reference, Entry, Entries);@Nullable_		protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {_			return null__		};convenience,method,that,can,be,used,for,tasks,that,do,not,need,access,to,link,entries,param,ref,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,return,the,result,of,the,task,see,execute,reference,entry,entries;nullable,protected,t,execute,nullable,reference,k,v,ref,nullable,entry,k,v,entry,return,null
ConcurrentReferenceHashMap -> Task -> @Nullable 		protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry);1550237263;Convenience method that can be used for tasks that do not need access to {@link Entries}._@param ref the found reference (or {@code null})_@param entry the found entry (or {@code null})_@return the result of the task_@see #execute(Reference, Entry, Entries);@Nullable_		protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {_			return null__		};convenience,method,that,can,be,used,for,tasks,that,do,not,need,access,to,link,entries,param,ref,the,found,reference,or,code,null,param,entry,the,found,entry,or,code,null,return,the,result,of,the,task,see,execute,reference,entry,entries;nullable,protected,t,execute,nullable,reference,k,v,ref,nullable,entry,k,v,entry,return,null
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, 			int concurrencyLevel);1351982790;Create a new {@link ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted_@param concurrencyLevel the expected number of threads that will concurrently write_to the map;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor,_			int concurrencyLevel) {_		this(initialCapacity, loadFactor, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,link,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,this,initial,capacity,load,factor,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, 			int concurrencyLevel);1352039846;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted_@param concurrencyLevel the expected number of threads that will concurrently write_to the map;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor,_			int concurrencyLevel) {_		this(initialCapacity, loadFactor, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,this,initial,capacity,load,factor,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, 			int concurrencyLevel);1355313310;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted_@param concurrencyLevel the expected number of threads that will concurrently write_to the map;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor,_			int concurrencyLevel) {_		this(initialCapacity, loadFactor, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,this,initial,capacity,load,factor,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, 			int concurrencyLevel);1356735495;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted_@param concurrencyLevel the expected number of threads that will concurrently write_to the map;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor,_			int concurrencyLevel) {_		this(initialCapacity, loadFactor, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,this,initial,capacity,load,factor,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, 			int concurrencyLevel);1357119239;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted_@param concurrencyLevel the expected number of threads that will concurrently write_to the map;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor,_			int concurrencyLevel) {_		this(initialCapacity, loadFactor, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,this,initial,capacity,load,factor,concurrency,level
ConcurrentReferenceHashMap -> public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, 			int concurrencyLevel);1368482696;Create a new {@code ConcurrentReferenceHashMap} instance._@param initialCapacity the initial capacity of the map_@param loadFactor the load factor. When the average number of references per table_exceeds this value resize will be attempted_@param concurrencyLevel the expected number of threads that will concurrently write_to the map;public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor,_			int concurrencyLevel) {_		this(initialCapacity, loadFactor, concurrencyLevel, DEFAULT_REFERENCE_TYPE)__	};create,a,new,code,concurrent,reference,hash,map,instance,param,initial,capacity,the,initial,capacity,of,the,map,param,load,factor,the,load,factor,when,the,average,number,of,references,per,table,exceeds,this,value,resize,will,be,attempted,param,concurrency,level,the,expected,number,of,threads,that,will,concurrently,write,to,the,map;public,concurrent,reference,hash,map,int,initial,capacity,float,load,factor,int,concurrency,level,this,initial,capacity,load,factor,concurrency,level
ConcurrentReferenceHashMap -> Segment -> @Nullable 		public <T> T doTask(final int hash, @Nullable final Object key, final Task<T> task);1521044224;Apply an update operation to this segment._The segment will be locked during the update._@param hash the hash of the key_@param key the key_@param task the update operation_@return the result of the operation;@Nullable_		public <T> T doTask(final int hash, @Nullable final Object key, final Task<T> task) {_			boolean resize = task.hasOption(TaskOption.RESIZE)__			if (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {_				restructureIfNecessary(resize)__			}_			if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && this.count == 0) {_				return task.execute(null, null, null)__			}_			lock()__			try {_				final int index = getIndex(hash, this.references)__				final Reference<K, V> head = this.references[index]__				Reference<K, V> reference = findInChain(head, key, hash)__				Entry<K, V> entry = (reference != null ? reference.get() : null)__				Entries entries = new Entries() {_					@Override_					public void add(@Nullable V value) {_						@SuppressWarnings("unchecked")_						Entry<K, V> newEntry = new Entry<>((K) key, value)__						Reference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head)__						Segment.this.references[index] = newReference__						Segment.this.count++__					}_				}__				return task.execute(reference, entry, entries)__			}_			finally {_				unlock()__				if (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {_					restructureIfNecessary(resize)__				}_			}_		};apply,an,update,operation,to,this,segment,the,segment,will,be,locked,during,the,update,param,hash,the,hash,of,the,key,param,key,the,key,param,task,the,update,operation,return,the,result,of,the,operation;nullable,public,t,t,do,task,final,int,hash,nullable,final,object,key,final,task,t,task,boolean,resize,task,has,option,task,option,resize,if,task,has,option,task,option,restructure,if,necessary,resize,if,task,has,option,task,option,this,count,0,return,task,execute,null,null,null,lock,try,final,int,index,get,index,hash,this,references,final,reference,k,v,head,this,references,index,reference,k,v,reference,find,in,chain,head,key,hash,entry,k,v,entry,reference,null,reference,get,null,entries,entries,new,entries,override,public,void,add,nullable,v,value,suppress,warnings,unchecked,entry,k,v,new,entry,new,entry,k,key,value,reference,k,v,new,reference,segment,this,reference,manager,create,reference,new,entry,hash,head,segment,this,references,index,new,reference,segment,this,count,return,task,execute,reference,entry,entries,finally,unlock,if,task,has,option,task,option,restructure,if,necessary,resize
ConcurrentReferenceHashMap -> Segment -> @Nullable 		public <T> T doTask(final int hash, @Nullable final Object key, final Task<T> task);1530174524;Apply an update operation to this segment._The segment will be locked during the update._@param hash the hash of the key_@param key the key_@param task the update operation_@return the result of the operation;@Nullable_		public <T> T doTask(final int hash, @Nullable final Object key, final Task<T> task) {_			boolean resize = task.hasOption(TaskOption.RESIZE)__			if (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {_				restructureIfNecessary(resize)__			}_			if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && this.count == 0) {_				return task.execute(null, null, null)__			}_			lock()__			try {_				final int index = getIndex(hash, this.references)__				final Reference<K, V> head = this.references[index]__				Reference<K, V> reference = findInChain(head, key, hash)__				Entry<K, V> entry = (reference != null ? reference.get() : null)__				Entries entries = new Entries() {_					@Override_					public void add(@Nullable V value) {_						@SuppressWarnings("unchecked")_						Entry<K, V> newEntry = new Entry<>((K) key, value)__						Reference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head)__						Segment.this.references[index] = newReference__						Segment.this.count++__					}_				}__				return task.execute(reference, entry, entries)__			}_			finally {_				unlock()__				if (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {_					restructureIfNecessary(resize)__				}_			}_		};apply,an,update,operation,to,this,segment,the,segment,will,be,locked,during,the,update,param,hash,the,hash,of,the,key,param,key,the,key,param,task,the,update,operation,return,the,result,of,the,operation;nullable,public,t,t,do,task,final,int,hash,nullable,final,object,key,final,task,t,task,boolean,resize,task,has,option,task,option,resize,if,task,has,option,task,option,restructure,if,necessary,resize,if,task,has,option,task,option,this,count,0,return,task,execute,null,null,null,lock,try,final,int,index,get,index,hash,this,references,final,reference,k,v,head,this,references,index,reference,k,v,reference,find,in,chain,head,key,hash,entry,k,v,entry,reference,null,reference,get,null,entries,entries,new,entries,override,public,void,add,nullable,v,value,suppress,warnings,unchecked,entry,k,v,new,entry,new,entry,k,key,value,reference,k,v,new,reference,segment,this,reference,manager,create,reference,new,entry,hash,head,segment,this,references,index,new,reference,segment,this,count,return,task,execute,reference,entry,entries,finally,unlock,if,task,has,option,task,option,restructure,if,necessary,resize
ConcurrentReferenceHashMap -> Segment -> @Nullable 		public <T> T doTask(final int hash, @Nullable final Object key, final Task<T> task);1530190293;Apply an update operation to this segment._The segment will be locked during the update._@param hash the hash of the key_@param key the key_@param task the update operation_@return the result of the operation;@Nullable_		public <T> T doTask(final int hash, @Nullable final Object key, final Task<T> task) {_			boolean resize = task.hasOption(TaskOption.RESIZE)__			if (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {_				restructureIfNecessary(resize)__			}_			if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && this.count == 0) {_				return task.execute(null, null, null)__			}_			lock()__			try {_				final int index = getIndex(hash, this.references)__				final Reference<K, V> head = this.references[index]__				Reference<K, V> reference = findInChain(head, key, hash)__				Entry<K, V> entry = (reference != null ? reference.get() : null)__				Entries entries = new Entries() {_					@Override_					public void add(@Nullable V value) {_						@SuppressWarnings("unchecked")_						Entry<K, V> newEntry = new Entry<>((K) key, value)__						Reference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head)__						Segment.this.references[index] = newReference__						Segment.this.count++__					}_				}__				return task.execute(reference, entry, entries)__			}_			finally {_				unlock()__				if (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {_					restructureIfNecessary(resize)__				}_			}_		};apply,an,update,operation,to,this,segment,the,segment,will,be,locked,during,the,update,param,hash,the,hash,of,the,key,param,key,the,key,param,task,the,update,operation,return,the,result,of,the,operation;nullable,public,t,t,do,task,final,int,hash,nullable,final,object,key,final,task,t,task,boolean,resize,task,has,option,task,option,resize,if,task,has,option,task,option,restructure,if,necessary,resize,if,task,has,option,task,option,this,count,0,return,task,execute,null,null,null,lock,try,final,int,index,get,index,hash,this,references,final,reference,k,v,head,this,references,index,reference,k,v,reference,find,in,chain,head,key,hash,entry,k,v,entry,reference,null,reference,get,null,entries,entries,new,entries,override,public,void,add,nullable,v,value,suppress,warnings,unchecked,entry,k,v,new,entry,new,entry,k,key,value,reference,k,v,new,reference,segment,this,reference,manager,create,reference,new,entry,hash,head,segment,this,references,index,new,reference,segment,this,count,return,task,execute,reference,entry,entries,finally,unlock,if,task,has,option,task,option,restructure,if,necessary,resize
ConcurrentReferenceHashMap -> Segment -> @Nullable 		public <T> T doTask(final int hash, @Nullable final Object key, final Task<T> task);1530563577;Apply an update operation to this segment._The segment will be locked during the update._@param hash the hash of the key_@param key the key_@param task the update operation_@return the result of the operation;@Nullable_		public <T> T doTask(final int hash, @Nullable final Object key, final Task<T> task) {_			boolean resize = task.hasOption(TaskOption.RESIZE)__			if (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {_				restructureIfNecessary(resize)__			}_			if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && this.count == 0) {_				return task.execute(null, null, null)__			}_			lock()__			try {_				final int index = getIndex(hash, this.references)__				final Reference<K, V> head = this.references[index]__				Reference<K, V> ref = findInChain(head, key, hash)__				Entry<K, V> entry = (ref != null ? ref.get() : null)__				Entries entries = new Entries() {_					@Override_					public void add(@Nullable V value) {_						@SuppressWarnings("unchecked")_						Entry<K, V> newEntry = new Entry<>((K) key, value)__						Reference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head)__						Segment.this.references[index] = newReference__						Segment.this.count++__					}_				}__				return task.execute(ref, entry, entries)__			}_			finally {_				unlock()__				if (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {_					restructureIfNecessary(resize)__				}_			}_		};apply,an,update,operation,to,this,segment,the,segment,will,be,locked,during,the,update,param,hash,the,hash,of,the,key,param,key,the,key,param,task,the,update,operation,return,the,result,of,the,operation;nullable,public,t,t,do,task,final,int,hash,nullable,final,object,key,final,task,t,task,boolean,resize,task,has,option,task,option,resize,if,task,has,option,task,option,restructure,if,necessary,resize,if,task,has,option,task,option,this,count,0,return,task,execute,null,null,null,lock,try,final,int,index,get,index,hash,this,references,final,reference,k,v,head,this,references,index,reference,k,v,ref,find,in,chain,head,key,hash,entry,k,v,entry,ref,null,ref,get,null,entries,entries,new,entries,override,public,void,add,nullable,v,value,suppress,warnings,unchecked,entry,k,v,new,entry,new,entry,k,key,value,reference,k,v,new,reference,segment,this,reference,manager,create,reference,new,entry,hash,head,segment,this,references,index,new,reference,segment,this,count,return,task,execute,ref,entry,entries,finally,unlock,if,task,has,option,task,option,restructure,if,necessary,resize
ConcurrentReferenceHashMap -> Segment -> @Nullable 		public <T> T doTask(final int hash, @Nullable final Object key, final Task<T> task);1531136363;Apply an update operation to this segment._The segment will be locked during the update._@param hash the hash of the key_@param key the key_@param task the update operation_@return the result of the operation;@Nullable_		public <T> T doTask(final int hash, @Nullable final Object key, final Task<T> task) {_			boolean resize = task.hasOption(TaskOption.RESIZE)__			if (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {_				restructureIfNecessary(resize)__			}_			if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && this.count == 0) {_				return task.execute(null, null, null)__			}_			lock()__			try {_				final int index = getIndex(hash, this.references)__				final Reference<K, V> head = this.references[index]__				Reference<K, V> ref = findInChain(head, key, hash)__				Entry<K, V> entry = (ref != null ? ref.get() : null)__				Entries entries = new Entries() {_					@Override_					public void add(@Nullable V value) {_						@SuppressWarnings("unchecked")_						Entry<K, V> newEntry = new Entry<>((K) key, value)__						Reference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head)__						Segment.this.references[index] = newReference__						Segment.this.count++__					}_				}__				return task.execute(ref, entry, entries)__			}_			finally {_				unlock()__				if (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {_					restructureIfNecessary(resize)__				}_			}_		};apply,an,update,operation,to,this,segment,the,segment,will,be,locked,during,the,update,param,hash,the,hash,of,the,key,param,key,the,key,param,task,the,update,operation,return,the,result,of,the,operation;nullable,public,t,t,do,task,final,int,hash,nullable,final,object,key,final,task,t,task,boolean,resize,task,has,option,task,option,resize,if,task,has,option,task,option,restructure,if,necessary,resize,if,task,has,option,task,option,this,count,0,return,task,execute,null,null,null,lock,try,final,int,index,get,index,hash,this,references,final,reference,k,v,head,this,references,index,reference,k,v,ref,find,in,chain,head,key,hash,entry,k,v,entry,ref,null,ref,get,null,entries,entries,new,entries,override,public,void,add,nullable,v,value,suppress,warnings,unchecked,entry,k,v,new,entry,new,entry,k,key,value,reference,k,v,new,reference,segment,this,reference,manager,create,reference,new,entry,hash,head,segment,this,references,index,new,reference,segment,this,count,return,task,execute,ref,entry,entries,finally,unlock,if,task,has,option,task,option,restructure,if,necessary,resize
ConcurrentReferenceHashMap -> Segment -> @Nullable 		public <T> T doTask(final int hash, @Nullable final Object key, final Task<T> task);1531139295;Apply an update operation to this segment._The segment will be locked during the update._@param hash the hash of the key_@param key the key_@param task the update operation_@return the result of the operation;@Nullable_		public <T> T doTask(final int hash, @Nullable final Object key, final Task<T> task) {_			boolean resize = task.hasOption(TaskOption.RESIZE)__			if (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {_				restructureIfNecessary(resize)__			}_			if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && this.count == 0) {_				return task.execute(null, null, null)__			}_			lock()__			try {_				final int index = getIndex(hash, this.references)__				final Reference<K, V> head = this.references[index]__				Reference<K, V> ref = findInChain(head, key, hash)__				Entry<K, V> entry = (ref != null ? ref.get() : null)__				Entries entries = new Entries() {_					@Override_					public void add(@Nullable V value) {_						@SuppressWarnings("unchecked")_						Entry<K, V> newEntry = new Entry<>((K) key, value)__						Reference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head)__						Segment.this.references[index] = newReference__						Segment.this.count++__					}_				}__				return task.execute(ref, entry, entries)__			}_			finally {_				unlock()__				if (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {_					restructureIfNecessary(resize)__				}_			}_		};apply,an,update,operation,to,this,segment,the,segment,will,be,locked,during,the,update,param,hash,the,hash,of,the,key,param,key,the,key,param,task,the,update,operation,return,the,result,of,the,operation;nullable,public,t,t,do,task,final,int,hash,nullable,final,object,key,final,task,t,task,boolean,resize,task,has,option,task,option,resize,if,task,has,option,task,option,restructure,if,necessary,resize,if,task,has,option,task,option,this,count,0,return,task,execute,null,null,null,lock,try,final,int,index,get,index,hash,this,references,final,reference,k,v,head,this,references,index,reference,k,v,ref,find,in,chain,head,key,hash,entry,k,v,entry,ref,null,ref,get,null,entries,entries,new,entries,override,public,void,add,nullable,v,value,suppress,warnings,unchecked,entry,k,v,new,entry,new,entry,k,key,value,reference,k,v,new,reference,segment,this,reference,manager,create,reference,new,entry,hash,head,segment,this,references,index,new,reference,segment,this,count,return,task,execute,ref,entry,entries,finally,unlock,if,task,has,option,task,option,restructure,if,necessary,resize
ConcurrentReferenceHashMap -> Segment -> @Nullable 		public <T> T doTask(final int hash, @Nullable final Object key, final Task<T> task);1544716668;Apply an update operation to this segment._The segment will be locked during the update._@param hash the hash of the key_@param key the key_@param task the update operation_@return the result of the operation;@Nullable_		public <T> T doTask(final int hash, @Nullable final Object key, final Task<T> task) {_			boolean resize = task.hasOption(TaskOption.RESIZE)__			if (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {_				restructureIfNecessary(resize)__			}_			if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && this.count == 0) {_				return task.execute(null, null, null)__			}_			lock()__			try {_				final int index = getIndex(hash, this.references)__				final Reference<K, V> head = this.references[index]__				Reference<K, V> ref = findInChain(head, key, hash)__				Entry<K, V> entry = (ref != null ? ref.get() : null)__				Entries entries = new Entries() {_					@Override_					public void add(@Nullable V value) {_						@SuppressWarnings("unchecked")_						Entry<K, V> newEntry = new Entry<>((K) key, value)__						Reference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head)__						Segment.this.references[index] = newReference__						Segment.this.count++__					}_				}__				return task.execute(ref, entry, entries)__			}_			finally {_				unlock()__				if (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {_					restructureIfNecessary(resize)__				}_			}_		};apply,an,update,operation,to,this,segment,the,segment,will,be,locked,during,the,update,param,hash,the,hash,of,the,key,param,key,the,key,param,task,the,update,operation,return,the,result,of,the,operation;nullable,public,t,t,do,task,final,int,hash,nullable,final,object,key,final,task,t,task,boolean,resize,task,has,option,task,option,resize,if,task,has,option,task,option,restructure,if,necessary,resize,if,task,has,option,task,option,this,count,0,return,task,execute,null,null,null,lock,try,final,int,index,get,index,hash,this,references,final,reference,k,v,head,this,references,index,reference,k,v,ref,find,in,chain,head,key,hash,entry,k,v,entry,ref,null,ref,get,null,entries,entries,new,entries,override,public,void,add,nullable,v,value,suppress,warnings,unchecked,entry,k,v,new,entry,new,entry,k,key,value,reference,k,v,new,reference,segment,this,reference,manager,create,reference,new,entry,hash,head,segment,this,references,index,new,reference,segment,this,count,return,task,execute,ref,entry,entries,finally,unlock,if,task,has,option,task,option,restructure,if,necessary,resize
ConcurrentReferenceHashMap -> Segment -> @Nullable 		public <T> T doTask(final int hash, @Nullable final Object key, final Task<T> task);1549318940;Apply an update operation to this segment._The segment will be locked during the update._@param hash the hash of the key_@param key the key_@param task the update operation_@return the result of the operation;@Nullable_		public <T> T doTask(final int hash, @Nullable final Object key, final Task<T> task) {_			boolean resize = task.hasOption(TaskOption.RESIZE)__			if (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {_				restructureIfNecessary(resize)__			}_			if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && this.count.get() == 0) {_				return task.execute(null, null, null)__			}_			lock()__			try {_				final int index = getIndex(hash, this.references)__				final Reference<K, V> head = this.references[index]__				Reference<K, V> ref = findInChain(head, key, hash)__				Entry<K, V> entry = (ref != null ? ref.get() : null)__				Entries entries = new Entries() {_					@Override_					public void add(@Nullable V value) {_						@SuppressWarnings("unchecked")_						Entry<K, V> newEntry = new Entry<>((K) key, value)__						Reference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head)__						Segment.this.references[index] = newReference__						Segment.this.count.incrementAndGet()__					}_				}__				return task.execute(ref, entry, entries)__			}_			finally {_				unlock()__				if (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {_					restructureIfNecessary(resize)__				}_			}_		};apply,an,update,operation,to,this,segment,the,segment,will,be,locked,during,the,update,param,hash,the,hash,of,the,key,param,key,the,key,param,task,the,update,operation,return,the,result,of,the,operation;nullable,public,t,t,do,task,final,int,hash,nullable,final,object,key,final,task,t,task,boolean,resize,task,has,option,task,option,resize,if,task,has,option,task,option,restructure,if,necessary,resize,if,task,has,option,task,option,this,count,get,0,return,task,execute,null,null,null,lock,try,final,int,index,get,index,hash,this,references,final,reference,k,v,head,this,references,index,reference,k,v,ref,find,in,chain,head,key,hash,entry,k,v,entry,ref,null,ref,get,null,entries,entries,new,entries,override,public,void,add,nullable,v,value,suppress,warnings,unchecked,entry,k,v,new,entry,new,entry,k,key,value,reference,k,v,new,reference,segment,this,reference,manager,create,reference,new,entry,hash,head,segment,this,references,index,new,reference,segment,this,count,increment,and,get,return,task,execute,ref,entry,entries,finally,unlock,if,task,has,option,task,option,restructure,if,necessary,resize
ConcurrentReferenceHashMap -> Segment -> @Nullable 		public <T> T doTask(final int hash, @Nullable final Object key, final Task<T> task);1549321822;Apply an update operation to this segment._The segment will be locked during the update._@param hash the hash of the key_@param key the key_@param task the update operation_@return the result of the operation;@Nullable_		public <T> T doTask(final int hash, @Nullable final Object key, final Task<T> task) {_			boolean resize = task.hasOption(TaskOption.RESIZE)__			if (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {_				restructureIfNecessary(resize)__			}_			if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && this.count.get() == 0) {_				return task.execute(null, null, null)__			}_			lock()__			try {_				final int index = getIndex(hash, this.references)__				final Reference<K, V> head = this.references[index]__				Reference<K, V> ref = findInChain(head, key, hash)__				Entry<K, V> entry = (ref != null ? ref.get() : null)__				Entries entries = new Entries() {_					@Override_					public void add(@Nullable V value) {_						@SuppressWarnings("unchecked")_						Entry<K, V> newEntry = new Entry<>((K) key, value)__						Reference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head)__						Segment.this.references[index] = newReference__						Segment.this.count.incrementAndGet()__					}_				}__				return task.execute(ref, entry, entries)__			}_			finally {_				unlock()__				if (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {_					restructureIfNecessary(resize)__				}_			}_		};apply,an,update,operation,to,this,segment,the,segment,will,be,locked,during,the,update,param,hash,the,hash,of,the,key,param,key,the,key,param,task,the,update,operation,return,the,result,of,the,operation;nullable,public,t,t,do,task,final,int,hash,nullable,final,object,key,final,task,t,task,boolean,resize,task,has,option,task,option,resize,if,task,has,option,task,option,restructure,if,necessary,resize,if,task,has,option,task,option,this,count,get,0,return,task,execute,null,null,null,lock,try,final,int,index,get,index,hash,this,references,final,reference,k,v,head,this,references,index,reference,k,v,ref,find,in,chain,head,key,hash,entry,k,v,entry,ref,null,ref,get,null,entries,entries,new,entries,override,public,void,add,nullable,v,value,suppress,warnings,unchecked,entry,k,v,new,entry,new,entry,k,key,value,reference,k,v,new,reference,segment,this,reference,manager,create,reference,new,entry,hash,head,segment,this,references,index,new,reference,segment,this,count,increment,and,get,return,task,execute,ref,entry,entries,finally,unlock,if,task,has,option,task,option,restructure,if,necessary,resize
ConcurrentReferenceHashMap -> Segment -> @Nullable 		public <T> T doTask(final int hash, @Nullable final Object key, final Task<T> task);1550237263;Apply an update operation to this segment._The segment will be locked during the update._@param hash the hash of the key_@param key the key_@param task the update operation_@return the result of the operation;@Nullable_		public <T> T doTask(final int hash, @Nullable final Object key, final Task<T> task) {_			boolean resize = task.hasOption(TaskOption.RESIZE)__			if (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {_				restructureIfNecessary(resize)__			}_			if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && this.count.get() == 0) {_				return task.execute(null, null, null)__			}_			lock()__			try {_				final int index = getIndex(hash, this.references)__				final Reference<K, V> head = this.references[index]__				Reference<K, V> ref = findInChain(head, key, hash)__				Entry<K, V> entry = (ref != null ? ref.get() : null)__				Entries<V> entries = value -> {_					@SuppressWarnings("unchecked")_					Entry<K, V> newEntry = new Entry<>((K) key, value)__					Reference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head)__					Segment.this.references[index] = newReference__					Segment.this.count.incrementAndGet()__				}__				return task.execute(ref, entry, entries)__			}_			finally {_				unlock()__				if (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {_					restructureIfNecessary(resize)__				}_			}_		};apply,an,update,operation,to,this,segment,the,segment,will,be,locked,during,the,update,param,hash,the,hash,of,the,key,param,key,the,key,param,task,the,update,operation,return,the,result,of,the,operation;nullable,public,t,t,do,task,final,int,hash,nullable,final,object,key,final,task,t,task,boolean,resize,task,has,option,task,option,resize,if,task,has,option,task,option,restructure,if,necessary,resize,if,task,has,option,task,option,this,count,get,0,return,task,execute,null,null,null,lock,try,final,int,index,get,index,hash,this,references,final,reference,k,v,head,this,references,index,reference,k,v,ref,find,in,chain,head,key,hash,entry,k,v,entry,ref,null,ref,get,null,entries,v,entries,value,suppress,warnings,unchecked,entry,k,v,new,entry,new,entry,k,key,value,reference,k,v,new,reference,segment,this,reference,manager,create,reference,new,entry,hash,head,segment,this,references,index,new,reference,segment,this,count,increment,and,get,return,task,execute,ref,entry,entries,finally,unlock,if,task,has,option,task,option,restructure,if,necessary,resize
ConcurrentReferenceHashMap -> protected static int calculateShift(int minimumValue, int maximumValue);1352039846;Calculate a shift value that can be used to create a power-of-two value between_the specified maximum and minimum values._@param minimumValue the minimum value_@param maximumValue the maximum value_@return the calculated shift (use {@code 1 << shift} to obtain a value);protected static int calculateShift(int minimumValue, int maximumValue) {_		int shift = 0__		int value = 1__		while (value < minimumValue && value < minimumValue) {_			value <<= 1__			shift++__		}_		return shift__	};calculate,a,shift,value,that,can,be,used,to,create,a,power,of,two,value,between,the,specified,maximum,and,minimum,values,param,minimum,value,the,minimum,value,param,maximum,value,the,maximum,value,return,the,calculated,shift,use,code,1,shift,to,obtain,a,value;protected,static,int,calculate,shift,int,minimum,value,int,maximum,value,int,shift,0,int,value,1,while,value,minimum,value,value,minimum,value,value,1,shift,return,shift
ConcurrentReferenceHashMap -> protected static int calculateShift(int minimumValue, int maximumValue);1355313310;Calculate a shift value that can be used to create a power-of-two value between_the specified maximum and minimum values._@param minimumValue the minimum value_@param maximumValue the maximum value_@return the calculated shift (use {@code 1 << shift} to obtain a value);protected static int calculateShift(int minimumValue, int maximumValue) {_		int shift = 0__		int value = 1__		while (value < minimumValue && value < minimumValue) {_			value <<= 1__			shift++__		}_		return shift__	};calculate,a,shift,value,that,can,be,used,to,create,a,power,of,two,value,between,the,specified,maximum,and,minimum,values,param,minimum,value,the,minimum,value,param,maximum,value,the,maximum,value,return,the,calculated,shift,use,code,1,shift,to,obtain,a,value;protected,static,int,calculate,shift,int,minimum,value,int,maximum,value,int,shift,0,int,value,1,while,value,minimum,value,value,minimum,value,value,1,shift,return,shift
ConcurrentReferenceHashMap -> protected static int calculateShift(int minimumValue, int maximumValue);1356735495;Calculate a shift value that can be used to create a power-of-two value between_the specified maximum and minimum values._@param minimumValue the minimum value_@param maximumValue the maximum value_@return the calculated shift (use {@code 1 << shift} to obtain a value);protected static int calculateShift(int minimumValue, int maximumValue) {_		int shift = 0__		int value = 1__		while (value < minimumValue && value < minimumValue) {_			value <<= 1__			shift++__		}_		return shift__	};calculate,a,shift,value,that,can,be,used,to,create,a,power,of,two,value,between,the,specified,maximum,and,minimum,values,param,minimum,value,the,minimum,value,param,maximum,value,the,maximum,value,return,the,calculated,shift,use,code,1,shift,to,obtain,a,value;protected,static,int,calculate,shift,int,minimum,value,int,maximum,value,int,shift,0,int,value,1,while,value,minimum,value,value,minimum,value,value,1,shift,return,shift
ConcurrentReferenceHashMap -> protected static int calculateShift(int minimumValue, int maximumValue);1357119239;Calculate a shift value that can be used to create a power-of-two value between_the specified maximum and minimum values._@param minimumValue the minimum value_@param maximumValue the maximum value_@return the calculated shift (use {@code 1 << shift} to obtain a value);protected static int calculateShift(int minimumValue, int maximumValue) {_		int shift = 0__		int value = 1__		while (value < minimumValue && value < minimumValue) {_			value <<= 1__			shift++__		}_		return shift__	};calculate,a,shift,value,that,can,be,used,to,create,a,power,of,two,value,between,the,specified,maximum,and,minimum,values,param,minimum,value,the,minimum,value,param,maximum,value,the,maximum,value,return,the,calculated,shift,use,code,1,shift,to,obtain,a,value;protected,static,int,calculate,shift,int,minimum,value,int,maximum,value,int,shift,0,int,value,1,while,value,minimum,value,value,minimum,value,value,1,shift,return,shift
ConcurrentReferenceHashMap -> protected static int calculateShift(int minimumValue, int maximumValue);1368482696;Calculate a shift value that can be used to create a power-of-two value between_the specified maximum and minimum values._@param minimumValue the minimum value_@param maximumValue the maximum value_@return the calculated shift (use {@code 1 << shift} to obtain a value);protected static int calculateShift(int minimumValue, int maximumValue) {_		int shift = 0__		int value = 1__		while (value < minimumValue && value < minimumValue) {_			value <<= 1__			shift++__		}_		return shift__	};calculate,a,shift,value,that,can,be,used,to,create,a,power,of,two,value,between,the,specified,maximum,and,minimum,values,param,minimum,value,the,minimum,value,param,maximum,value,the,maximum,value,return,the,calculated,shift,use,code,1,shift,to,obtain,a,value;protected,static,int,calculate,shift,int,minimum,value,int,maximum,value,int,shift,0,int,value,1,while,value,minimum,value,value,minimum,value,value,1,shift,return,shift
ConcurrentReferenceHashMap -> protected static int calculateShift(int minimumValue, int maximumValue);1383090835;Calculate a shift value that can be used to create a power-of-two value between_the specified maximum and minimum values._@param minimumValue the minimum value_@param maximumValue the maximum value_@return the calculated shift (use {@code 1 << shift} to obtain a value);protected static int calculateShift(int minimumValue, int maximumValue) {_		int shift = 0__		int value = 1__		while (value < minimumValue && value < minimumValue) {_			value <<= 1__			shift++__		}_		return shift__	};calculate,a,shift,value,that,can,be,used,to,create,a,power,of,two,value,between,the,specified,maximum,and,minimum,values,param,minimum,value,the,minimum,value,param,maximum,value,the,maximum,value,return,the,calculated,shift,use,code,1,shift,to,obtain,a,value;protected,static,int,calculate,shift,int,minimum,value,int,maximum,value,int,shift,0,int,value,1,while,value,minimum,value,value,minimum,value,value,1,shift,return,shift
ConcurrentReferenceHashMap -> protected static int calculateShift(int minimumValue, int maximumValue);1383178438;Calculate a shift value that can be used to create a power-of-two value between_the specified maximum and minimum values._@param minimumValue the minimum value_@param maximumValue the maximum value_@return the calculated shift (use {@code 1 << shift} to obtain a value);protected static int calculateShift(int minimumValue, int maximumValue) {_		int shift = 0__		int value = 1__		while (value < minimumValue && value < minimumValue) {_			value <<= 1__			shift++__		}_		return shift__	};calculate,a,shift,value,that,can,be,used,to,create,a,power,of,two,value,between,the,specified,maximum,and,minimum,values,param,minimum,value,the,minimum,value,param,maximum,value,the,maximum,value,return,the,calculated,shift,use,code,1,shift,to,obtain,a,value;protected,static,int,calculate,shift,int,minimum,value,int,maximum,value,int,shift,0,int,value,1,while,value,minimum,value,value,minimum,value,value,1,shift,return,shift
ConcurrentReferenceHashMap -> protected static int calculateShift(int minimumValue, int maximumValue);1390260938;Calculate a shift value that can be used to create a power-of-two value between_the specified maximum and minimum values._@param minimumValue the minimum value_@param maximumValue the maximum value_@return the calculated shift (use {@code 1 << shift} to obtain a value);protected static int calculateShift(int minimumValue, int maximumValue) {_		int shift = 0__		int value = 1__		while (value < minimumValue && value < minimumValue) {_			value <<= 1__			shift++__		}_		return shift__	};calculate,a,shift,value,that,can,be,used,to,create,a,power,of,two,value,between,the,specified,maximum,and,minimum,values,param,minimum,value,the,minimum,value,param,maximum,value,the,maximum,value,return,the,calculated,shift,use,code,1,shift,to,obtain,a,value;protected,static,int,calculate,shift,int,minimum,value,int,maximum,value,int,shift,0,int,value,1,while,value,minimum,value,value,minimum,value,value,1,shift,return,shift
ConcurrentReferenceHashMap -> protected static int calculateShift(int minimumValue, int maximumValue);1391715359;Calculate a shift value that can be used to create a power-of-two value between_the specified maximum and minimum values._@param minimumValue the minimum value_@param maximumValue the maximum value_@return the calculated shift (use {@code 1 << shift} to obtain a value);protected static int calculateShift(int minimumValue, int maximumValue) {_		int shift = 0__		int value = 1__		while (value < minimumValue && value < minimumValue) {_			value <<= 1__			shift++__		}_		return shift__	};calculate,a,shift,value,that,can,be,used,to,create,a,power,of,two,value,between,the,specified,maximum,and,minimum,values,param,minimum,value,the,minimum,value,param,maximum,value,the,maximum,value,return,the,calculated,shift,use,code,1,shift,to,obtain,a,value;protected,static,int,calculate,shift,int,minimum,value,int,maximum,value,int,shift,0,int,value,1,while,value,minimum,value,value,minimum,value,value,1,shift,return,shift
ConcurrentReferenceHashMap -> protected static int calculateShift(int minimumValue, int maximumValue);1392765030;Calculate a shift value that can be used to create a power-of-two value between_the specified maximum and minimum values._@param minimumValue the minimum value_@param maximumValue the maximum value_@return the calculated shift (use {@code 1 << shift} to obtain a value);protected static int calculateShift(int minimumValue, int maximumValue) {_		int shift = 0__		int value = 1__		while (value < minimumValue && value < minimumValue) {_			value <<= 1__			shift++__		}_		return shift__	};calculate,a,shift,value,that,can,be,used,to,create,a,power,of,two,value,between,the,specified,maximum,and,minimum,values,param,minimum,value,the,minimum,value,param,maximum,value,the,maximum,value,return,the,calculated,shift,use,code,1,shift,to,obtain,a,value;protected,static,int,calculate,shift,int,minimum,value,int,maximum,value,int,shift,0,int,value,1,while,value,minimum,value,value,minimum,value,value,1,shift,return,shift
ConcurrentReferenceHashMap -> protected static int calculateShift(int minimumValue, int maximumValue);1398175099;Calculate a shift value that can be used to create a power-of-two value between_the specified maximum and minimum values._@param minimumValue the minimum value_@param maximumValue the maximum value_@return the calculated shift (use {@code 1 << shift} to obtain a value);protected static int calculateShift(int minimumValue, int maximumValue) {_		int shift = 0__		int value = 1__		while (value < minimumValue && value < maximumValue) {_			value <<= 1__			shift++__		}_		return shift__	};calculate,a,shift,value,that,can,be,used,to,create,a,power,of,two,value,between,the,specified,maximum,and,minimum,values,param,minimum,value,the,minimum,value,param,maximum,value,the,maximum,value,return,the,calculated,shift,use,code,1,shift,to,obtain,a,value;protected,static,int,calculate,shift,int,minimum,value,int,maximum,value,int,shift,0,int,value,1,while,value,minimum,value,value,maximum,value,value,1,shift,return,shift
ConcurrentReferenceHashMap -> protected static int calculateShift(int minimumValue, int maximumValue);1404132943;Calculate a shift value that can be used to create a power-of-two value between_the specified maximum and minimum values._@param minimumValue the minimum value_@param maximumValue the maximum value_@return the calculated shift (use {@code 1 << shift} to obtain a value);protected static int calculateShift(int minimumValue, int maximumValue) {_		int shift = 0__		int value = 1__		while (value < minimumValue && value < maximumValue) {_			value <<= 1__			shift++__		}_		return shift__	};calculate,a,shift,value,that,can,be,used,to,create,a,power,of,two,value,between,the,specified,maximum,and,minimum,values,param,minimum,value,the,minimum,value,param,maximum,value,the,maximum,value,return,the,calculated,shift,use,code,1,shift,to,obtain,a,value;protected,static,int,calculate,shift,int,minimum,value,int,maximum,value,int,shift,0,int,value,1,while,value,minimum,value,value,maximum,value,value,1,shift,return,shift
ConcurrentReferenceHashMap -> protected static int calculateShift(int minimumValue, int maximumValue);1427240641;Calculate a shift value that can be used to create a power-of-two value between_the specified maximum and minimum values._@param minimumValue the minimum value_@param maximumValue the maximum value_@return the calculated shift (use {@code 1 << shift} to obtain a value);protected static int calculateShift(int minimumValue, int maximumValue) {_		int shift = 0__		int value = 1__		while (value < minimumValue && value < maximumValue) {_			value <<= 1__			shift++__		}_		return shift__	};calculate,a,shift,value,that,can,be,used,to,create,a,power,of,two,value,between,the,specified,maximum,and,minimum,values,param,minimum,value,the,minimum,value,param,maximum,value,the,maximum,value,return,the,calculated,shift,use,code,1,shift,to,obtain,a,value;protected,static,int,calculate,shift,int,minimum,value,int,maximum,value,int,shift,0,int,value,1,while,value,minimum,value,value,maximum,value,value,1,shift,return,shift
ConcurrentReferenceHashMap -> protected static int calculateShift(int minimumValue, int maximumValue);1459795890;Calculate a shift value that can be used to create a power-of-two value between_the specified maximum and minimum values._@param minimumValue the minimum value_@param maximumValue the maximum value_@return the calculated shift (use {@code 1 << shift} to obtain a value);protected static int calculateShift(int minimumValue, int maximumValue) {_		int shift = 0__		int value = 1__		while (value < minimumValue && value < maximumValue) {_			value <<= 1__			shift++__		}_		return shift__	};calculate,a,shift,value,that,can,be,used,to,create,a,power,of,two,value,between,the,specified,maximum,and,minimum,values,param,minimum,value,the,minimum,value,param,maximum,value,the,maximum,value,return,the,calculated,shift,use,code,1,shift,to,obtain,a,value;protected,static,int,calculate,shift,int,minimum,value,int,maximum,value,int,shift,0,int,value,1,while,value,minimum,value,value,maximum,value,value,1,shift,return,shift
ConcurrentReferenceHashMap -> protected static int calculateShift(int minimumValue, int maximumValue);1467730834;Calculate a shift value that can be used to create a power-of-two value between_the specified maximum and minimum values._@param minimumValue the minimum value_@param maximumValue the maximum value_@return the calculated shift (use {@code 1 << shift} to obtain a value);protected static int calculateShift(int minimumValue, int maximumValue) {_		int shift = 0__		int value = 1__		while (value < minimumValue && value < maximumValue) {_			value <<= 1__			shift++__		}_		return shift__	};calculate,a,shift,value,that,can,be,used,to,create,a,power,of,two,value,between,the,specified,maximum,and,minimum,values,param,minimum,value,the,minimum,value,param,maximum,value,the,maximum,value,return,the,calculated,shift,use,code,1,shift,to,obtain,a,value;protected,static,int,calculate,shift,int,minimum,value,int,maximum,value,int,shift,0,int,value,1,while,value,minimum,value,value,maximum,value,value,1,shift,return,shift
ConcurrentReferenceHashMap -> protected static int calculateShift(int minimumValue, int maximumValue);1485810955;Calculate a shift value that can be used to create a power-of-two value between_the specified maximum and minimum values._@param minimumValue the minimum value_@param maximumValue the maximum value_@return the calculated shift (use {@code 1 << shift} to obtain a value);protected static int calculateShift(int minimumValue, int maximumValue) {_		int shift = 0__		int value = 1__		while (value < minimumValue && value < maximumValue) {_			value <<= 1__			shift++__		}_		return shift__	};calculate,a,shift,value,that,can,be,used,to,create,a,power,of,two,value,between,the,specified,maximum,and,minimum,values,param,minimum,value,the,minimum,value,param,maximum,value,the,maximum,value,return,the,calculated,shift,use,code,1,shift,to,obtain,a,value;protected,static,int,calculate,shift,int,minimum,value,int,maximum,value,int,shift,0,int,value,1,while,value,minimum,value,value,maximum,value,value,1,shift,return,shift
ConcurrentReferenceHashMap -> protected static int calculateShift(int minimumValue, int maximumValue);1495868221;Calculate a shift value that can be used to create a power-of-two value between_the specified maximum and minimum values._@param minimumValue the minimum value_@param maximumValue the maximum value_@return the calculated shift (use {@code 1 << shift} to obtain a value);protected static int calculateShift(int minimumValue, int maximumValue) {_		int shift = 0__		int value = 1__		while (value < minimumValue && value < maximumValue) {_			value <<= 1__			shift++__		}_		return shift__	};calculate,a,shift,value,that,can,be,used,to,create,a,power,of,two,value,between,the,specified,maximum,and,minimum,values,param,minimum,value,the,minimum,value,param,maximum,value,the,maximum,value,return,the,calculated,shift,use,code,1,shift,to,obtain,a,value;protected,static,int,calculate,shift,int,minimum,value,int,maximum,value,int,shift,0,int,value,1,while,value,minimum,value,value,maximum,value,value,1,shift,return,shift
ConcurrentReferenceHashMap -> protected static int calculateShift(int minimumValue, int maximumValue);1496242568;Calculate a shift value that can be used to create a power-of-two value between_the specified maximum and minimum values._@param minimumValue the minimum value_@param maximumValue the maximum value_@return the calculated shift (use {@code 1 << shift} to obtain a value);protected static int calculateShift(int minimumValue, int maximumValue) {_		int shift = 0__		int value = 1__		while (value < minimumValue && value < maximumValue) {_			value <<= 1__			shift++__		}_		return shift__	};calculate,a,shift,value,that,can,be,used,to,create,a,power,of,two,value,between,the,specified,maximum,and,minimum,values,param,minimum,value,the,minimum,value,param,maximum,value,the,maximum,value,return,the,calculated,shift,use,code,1,shift,to,obtain,a,value;protected,static,int,calculate,shift,int,minimum,value,int,maximum,value,int,shift,0,int,value,1,while,value,minimum,value,value,maximum,value,value,1,shift,return,shift
ConcurrentReferenceHashMap -> protected static int calculateShift(int minimumValue, int maximumValue);1496837955;Calculate a shift value that can be used to create a power-of-two value between_the specified maximum and minimum values._@param minimumValue the minimum value_@param maximumValue the maximum value_@return the calculated shift (use {@code 1 << shift} to obtain a value);protected static int calculateShift(int minimumValue, int maximumValue) {_		int shift = 0__		int value = 1__		while (value < minimumValue && value < maximumValue) {_			value <<= 1__			shift++__		}_		return shift__	};calculate,a,shift,value,that,can,be,used,to,create,a,power,of,two,value,between,the,specified,maximum,and,minimum,values,param,minimum,value,the,minimum,value,param,maximum,value,the,maximum,value,return,the,calculated,shift,use,code,1,shift,to,obtain,a,value;protected,static,int,calculate,shift,int,minimum,value,int,maximum,value,int,shift,0,int,value,1,while,value,minimum,value,value,maximum,value,value,1,shift,return,shift
ConcurrentReferenceHashMap -> protected static int calculateShift(int minimumValue, int maximumValue);1498780456;Calculate a shift value that can be used to create a power-of-two value between_the specified maximum and minimum values._@param minimumValue the minimum value_@param maximumValue the maximum value_@return the calculated shift (use {@code 1 << shift} to obtain a value);protected static int calculateShift(int minimumValue, int maximumValue) {_		int shift = 0__		int value = 1__		while (value < minimumValue && value < maximumValue) {_			value <<= 1__			shift++__		}_		return shift__	};calculate,a,shift,value,that,can,be,used,to,create,a,power,of,two,value,between,the,specified,maximum,and,minimum,values,param,minimum,value,the,minimum,value,param,maximum,value,the,maximum,value,return,the,calculated,shift,use,code,1,shift,to,obtain,a,value;protected,static,int,calculate,shift,int,minimum,value,int,maximum,value,int,shift,0,int,value,1,while,value,minimum,value,value,maximum,value,value,1,shift,return,shift
ConcurrentReferenceHashMap -> protected static int calculateShift(int minimumValue, int maximumValue);1502974979;Calculate a shift value that can be used to create a power-of-two value between_the specified maximum and minimum values._@param minimumValue the minimum value_@param maximumValue the maximum value_@return the calculated shift (use {@code 1 << shift} to obtain a value);protected static int calculateShift(int minimumValue, int maximumValue) {_		int shift = 0__		int value = 1__		while (value < minimumValue && value < maximumValue) {_			value <<= 1__			shift++__		}_		return shift__	};calculate,a,shift,value,that,can,be,used,to,create,a,power,of,two,value,between,the,specified,maximum,and,minimum,values,param,minimum,value,the,minimum,value,param,maximum,value,the,maximum,value,return,the,calculated,shift,use,code,1,shift,to,obtain,a,value;protected,static,int,calculate,shift,int,minimum,value,int,maximum,value,int,shift,0,int,value,1,while,value,minimum,value,value,maximum,value,value,1,shift,return,shift
ConcurrentReferenceHashMap -> protected static int calculateShift(int minimumValue, int maximumValue);1506097334;Calculate a shift value that can be used to create a power-of-two value between_the specified maximum and minimum values._@param minimumValue the minimum value_@param maximumValue the maximum value_@return the calculated shift (use {@code 1 << shift} to obtain a value);protected static int calculateShift(int minimumValue, int maximumValue) {_		int shift = 0__		int value = 1__		while (value < minimumValue && value < maximumValue) {_			value <<= 1__			shift++__		}_		return shift__	};calculate,a,shift,value,that,can,be,used,to,create,a,power,of,two,value,between,the,specified,maximum,and,minimum,values,param,minimum,value,the,minimum,value,param,maximum,value,the,maximum,value,return,the,calculated,shift,use,code,1,shift,to,obtain,a,value;protected,static,int,calculate,shift,int,minimum,value,int,maximum,value,int,shift,0,int,value,1,while,value,minimum,value,value,maximum,value,value,1,shift,return,shift
ConcurrentReferenceHashMap -> protected static int calculateShift(int minimumValue, int maximumValue);1521044224;Calculate a shift value that can be used to create a power-of-two value between_the specified maximum and minimum values._@param minimumValue the minimum value_@param maximumValue the maximum value_@return the calculated shift (use {@code 1 << shift} to obtain a value);protected static int calculateShift(int minimumValue, int maximumValue) {_		int shift = 0__		int value = 1__		while (value < minimumValue && value < maximumValue) {_			value <<= 1__			shift++__		}_		return shift__	};calculate,a,shift,value,that,can,be,used,to,create,a,power,of,two,value,between,the,specified,maximum,and,minimum,values,param,minimum,value,the,minimum,value,param,maximum,value,the,maximum,value,return,the,calculated,shift,use,code,1,shift,to,obtain,a,value;protected,static,int,calculate,shift,int,minimum,value,int,maximum,value,int,shift,0,int,value,1,while,value,minimum,value,value,maximum,value,value,1,shift,return,shift
ConcurrentReferenceHashMap -> protected static int calculateShift(int minimumValue, int maximumValue);1530174524;Calculate a shift value that can be used to create a power-of-two value between_the specified maximum and minimum values._@param minimumValue the minimum value_@param maximumValue the maximum value_@return the calculated shift (use {@code 1 << shift} to obtain a value);protected static int calculateShift(int minimumValue, int maximumValue) {_		int shift = 0__		int value = 1__		while (value < minimumValue && value < maximumValue) {_			value <<= 1__			shift++__		}_		return shift__	};calculate,a,shift,value,that,can,be,used,to,create,a,power,of,two,value,between,the,specified,maximum,and,minimum,values,param,minimum,value,the,minimum,value,param,maximum,value,the,maximum,value,return,the,calculated,shift,use,code,1,shift,to,obtain,a,value;protected,static,int,calculate,shift,int,minimum,value,int,maximum,value,int,shift,0,int,value,1,while,value,minimum,value,value,maximum,value,value,1,shift,return,shift
ConcurrentReferenceHashMap -> protected static int calculateShift(int minimumValue, int maximumValue);1530190293;Calculate a shift value that can be used to create a power-of-two value between_the specified maximum and minimum values._@param minimumValue the minimum value_@param maximumValue the maximum value_@return the calculated shift (use {@code 1 << shift} to obtain a value);protected static int calculateShift(int minimumValue, int maximumValue) {_		int shift = 0__		int value = 1__		while (value < minimumValue && value < maximumValue) {_			value <<= 1__			shift++__		}_		return shift__	};calculate,a,shift,value,that,can,be,used,to,create,a,power,of,two,value,between,the,specified,maximum,and,minimum,values,param,minimum,value,the,minimum,value,param,maximum,value,the,maximum,value,return,the,calculated,shift,use,code,1,shift,to,obtain,a,value;protected,static,int,calculate,shift,int,minimum,value,int,maximum,value,int,shift,0,int,value,1,while,value,minimum,value,value,maximum,value,value,1,shift,return,shift
ConcurrentReferenceHashMap -> protected static int calculateShift(int minimumValue, int maximumValue);1530563577;Calculate a shift value that can be used to create a power-of-two value between_the specified maximum and minimum values._@param minimumValue the minimum value_@param maximumValue the maximum value_@return the calculated shift (use {@code 1 << shift} to obtain a value);protected static int calculateShift(int minimumValue, int maximumValue) {_		int shift = 0__		int value = 1__		while (value < minimumValue && value < maximumValue) {_			value <<= 1__			shift++__		}_		return shift__	};calculate,a,shift,value,that,can,be,used,to,create,a,power,of,two,value,between,the,specified,maximum,and,minimum,values,param,minimum,value,the,minimum,value,param,maximum,value,the,maximum,value,return,the,calculated,shift,use,code,1,shift,to,obtain,a,value;protected,static,int,calculate,shift,int,minimum,value,int,maximum,value,int,shift,0,int,value,1,while,value,minimum,value,value,maximum,value,value,1,shift,return,shift
ConcurrentReferenceHashMap -> protected static int calculateShift(int minimumValue, int maximumValue);1531136363;Calculate a shift value that can be used to create a power-of-two value between_the specified maximum and minimum values._@param minimumValue the minimum value_@param maximumValue the maximum value_@return the calculated shift (use {@code 1 << shift} to obtain a value);protected static int calculateShift(int minimumValue, int maximumValue) {_		int shift = 0__		int value = 1__		while (value < minimumValue && value < maximumValue) {_			value <<= 1__			shift++__		}_		return shift__	};calculate,a,shift,value,that,can,be,used,to,create,a,power,of,two,value,between,the,specified,maximum,and,minimum,values,param,minimum,value,the,minimum,value,param,maximum,value,the,maximum,value,return,the,calculated,shift,use,code,1,shift,to,obtain,a,value;protected,static,int,calculate,shift,int,minimum,value,int,maximum,value,int,shift,0,int,value,1,while,value,minimum,value,value,maximum,value,value,1,shift,return,shift
ConcurrentReferenceHashMap -> protected static int calculateShift(int minimumValue, int maximumValue);1531139295;Calculate a shift value that can be used to create a power-of-two value between_the specified maximum and minimum values._@param minimumValue the minimum value_@param maximumValue the maximum value_@return the calculated shift (use {@code 1 << shift} to obtain a value);protected static int calculateShift(int minimumValue, int maximumValue) {_		int shift = 0__		int value = 1__		while (value < minimumValue && value < maximumValue) {_			value <<= 1__			shift++__		}_		return shift__	};calculate,a,shift,value,that,can,be,used,to,create,a,power,of,two,value,between,the,specified,maximum,and,minimum,values,param,minimum,value,the,minimum,value,param,maximum,value,the,maximum,value,return,the,calculated,shift,use,code,1,shift,to,obtain,a,value;protected,static,int,calculate,shift,int,minimum,value,int,maximum,value,int,shift,0,int,value,1,while,value,minimum,value,value,maximum,value,value,1,shift,return,shift
ConcurrentReferenceHashMap -> protected static int calculateShift(int minimumValue, int maximumValue);1544716668;Calculate a shift value that can be used to create a power-of-two value between_the specified maximum and minimum values._@param minimumValue the minimum value_@param maximumValue the maximum value_@return the calculated shift (use {@code 1 << shift} to obtain a value);protected static int calculateShift(int minimumValue, int maximumValue) {_		int shift = 0__		int value = 1__		while (value < minimumValue && value < maximumValue) {_			value <<= 1__			shift++__		}_		return shift__	};calculate,a,shift,value,that,can,be,used,to,create,a,power,of,two,value,between,the,specified,maximum,and,minimum,values,param,minimum,value,the,minimum,value,param,maximum,value,the,maximum,value,return,the,calculated,shift,use,code,1,shift,to,obtain,a,value;protected,static,int,calculate,shift,int,minimum,value,int,maximum,value,int,shift,0,int,value,1,while,value,minimum,value,value,maximum,value,value,1,shift,return,shift
ConcurrentReferenceHashMap -> protected static int calculateShift(int minimumValue, int maximumValue);1549318940;Calculate a shift value that can be used to create a power-of-two value between_the specified maximum and minimum values._@param minimumValue the minimum value_@param maximumValue the maximum value_@return the calculated shift (use {@code 1 << shift} to obtain a value);protected static int calculateShift(int minimumValue, int maximumValue) {_		int shift = 0__		int value = 1__		while (value < minimumValue && value < maximumValue) {_			value <<= 1__			shift++__		}_		return shift__	};calculate,a,shift,value,that,can,be,used,to,create,a,power,of,two,value,between,the,specified,maximum,and,minimum,values,param,minimum,value,the,minimum,value,param,maximum,value,the,maximum,value,return,the,calculated,shift,use,code,1,shift,to,obtain,a,value;protected,static,int,calculate,shift,int,minimum,value,int,maximum,value,int,shift,0,int,value,1,while,value,minimum,value,value,maximum,value,value,1,shift,return,shift
ConcurrentReferenceHashMap -> protected static int calculateShift(int minimumValue, int maximumValue);1549321822;Calculate a shift value that can be used to create a power-of-two value between_the specified maximum and minimum values._@param minimumValue the minimum value_@param maximumValue the maximum value_@return the calculated shift (use {@code 1 << shift} to obtain a value);protected static int calculateShift(int minimumValue, int maximumValue) {_		int shift = 0__		int value = 1__		while (value < minimumValue && value < maximumValue) {_			value <<= 1__			shift++__		}_		return shift__	};calculate,a,shift,value,that,can,be,used,to,create,a,power,of,two,value,between,the,specified,maximum,and,minimum,values,param,minimum,value,the,minimum,value,param,maximum,value,the,maximum,value,return,the,calculated,shift,use,code,1,shift,to,obtain,a,value;protected,static,int,calculate,shift,int,minimum,value,int,maximum,value,int,shift,0,int,value,1,while,value,minimum,value,value,maximum,value,value,1,shift,return,shift
ConcurrentReferenceHashMap -> protected static int calculateShift(int minimumValue, int maximumValue);1550237263;Calculate a shift value that can be used to create a power-of-two value between_the specified maximum and minimum values._@param minimumValue the minimum value_@param maximumValue the maximum value_@return the calculated shift (use {@code 1 << shift} to obtain a value);protected static int calculateShift(int minimumValue, int maximumValue) {_		int shift = 0__		int value = 1__		while (value < minimumValue && value < maximumValue) {_			value <<= 1__			shift++__		}_		return shift__	};calculate,a,shift,value,that,can,be,used,to,create,a,power,of,two,value,between,the,specified,maximum,and,minimum,values,param,minimum,value,the,minimum,value,param,maximum,value,the,maximum,value,return,the,calculated,shift,use,code,1,shift,to,obtain,a,value;protected,static,int,calculate,shift,int,minimum,value,int,maximum,value,int,shift,0,int,value,1,while,value,minimum,value,value,maximum,value,value,1,shift,return,shift
