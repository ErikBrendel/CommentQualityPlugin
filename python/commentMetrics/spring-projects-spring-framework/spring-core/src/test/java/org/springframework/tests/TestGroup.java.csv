commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;16;/**  * Parse the specified comma separated string of groups.  * @param value the comma separated string of groups  * @return a set of groups  * @throws IllegalArgumentException if any specified group name is not a  * valid {@link TestGroup}  */ ;/**  * Parse the specified comma separated string of groups.  * @param value the comma separated string of groups  * @return a set of groups  * @throws IllegalArgumentException if any specified group name is not a  * valid {@link TestGroup}  */ public static Set<TestGroup> parse(String value) throws IllegalArgumentException {     if (!StringUtils.hasText(value)) {         return Collections.emptySet().     }     String originalValue = value.     value = value.trim().     if ("ALL".equalsIgnoreCase(value)) {         return EnumSet.allOf(TestGroup.class).     }     if (value.toUpperCase().startsWith("ALL-")) {         Set<TestGroup> groups = EnumSet.allOf(TestGroup.class).         groups.removeAll(parseGroups(originalValue, value.substring(4))).         return groups.     }     return parseGroups(originalValue, value). }
false;private,static;2;15;;private static Set<TestGroup> parseGroups(String originalValue, String value) throws IllegalArgumentException {     Set<TestGroup> groups = new HashSet<>().     for (String group : value.split(",")) {         try {             groups.add(valueOf(group.trim().toUpperCase())).         } catch (IllegalArgumentException ex) {             throw new IllegalArgumentException(format("Unable to find test group '%s' when parsing testGroups value: '%s'. " + "Available groups include: [%s]", group.trim(), originalValue, StringUtils.arrayToCommaDelimitedString(TestGroup.values()))).         }     }     return groups. }
