commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Test public void simpleInterfaceType() {     assertEquals(String.class, resolveTypeArgument(MySimpleInterfaceType.class, MyInterfaceType.class)). }
false;public;0;4;;@Test public void simpleCollectionInterfaceType() {     assertEquals(Collection.class, resolveTypeArgument(MyCollectionInterfaceType.class, MyInterfaceType.class)). }
false;public;0;4;;@Test public void simpleSuperclassType() {     assertEquals(String.class, resolveTypeArgument(MySimpleSuperclassType.class, MySuperclassType.class)). }
false;public;0;4;;@Test public void simpleCollectionSuperclassType() {     assertEquals(Collection.class, resolveTypeArgument(MyCollectionSuperclassType.class, MySuperclassType.class)). }
false;public;0;5;;@Test public void nullIfNotResolvable() {     GenericClass<String> obj = new GenericClass<>().     assertNull(resolveTypeArgument(obj.getClass(), GenericClass.class)). }
false;public;0;10;;@Test public void methodReturnTypes() {     assertEquals(Integer.class, resolveReturnTypeArgument(findMethod(MyTypeWithMethods.class, "integer"), MyInterfaceType.class)).     assertEquals(String.class, resolveReturnTypeArgument(findMethod(MyTypeWithMethods.class, "string"), MyInterfaceType.class)).     assertEquals(null, resolveReturnTypeArgument(findMethod(MyTypeWithMethods.class, "raw"), MyInterfaceType.class)).     assertEquals(null, resolveReturnTypeArgument(findMethod(MyTypeWithMethods.class, "object"), MyInterfaceType.class)). }
false;public;0;19;;@Test public void testResolveType() {     Method intMessageMethod = findMethod(MyTypeWithMethods.class, "readIntegerInputMessage", MyInterfaceType.class).     MethodParameter intMessageMethodParam = new MethodParameter(intMessageMethod, 0).     assertEquals(MyInterfaceType.class, resolveType(intMessageMethodParam.getGenericParameterType(), new HashMap<>())).     Method intArrMessageMethod = findMethod(MyTypeWithMethods.class, "readIntegerArrayInputMessage", MyInterfaceType[].class).     MethodParameter intArrMessageMethodParam = new MethodParameter(intArrMessageMethod, 0).     assertEquals(MyInterfaceType[].class, resolveType(intArrMessageMethodParam.getGenericParameterType(), new HashMap<>())).     Method genericArrMessageMethod = findMethod(MySimpleTypeWithMethods.class, "readGenericArrayInputMessage", Object[].class).     MethodParameter genericArrMessageMethodParam = new MethodParameter(genericArrMessageMethod, 0).     Map<TypeVariable, Type> varMap = getTypeVariableMap(MySimpleTypeWithMethods.class).     assertEquals(Integer[].class, resolveType(genericArrMessageMethodParam.getGenericParameterType(), varMap)). }
false;public;0;4;;@Test public void testBoundParameterizedType() {     assertEquals(B.class, resolveTypeArgument(TestImpl.class, TestIfc.class)). }
false;public;0;37;;@Test public void testGetTypeVariableMap() throws Exception {     Map<TypeVariable, Type> map.     map = GenericTypeResolver.getTypeVariableMap(MySimpleInterfaceType.class).     assertThat(map.toString(), equalTo("{T=class java.lang.String}")).     map = GenericTypeResolver.getTypeVariableMap(MyCollectionInterfaceType.class).     assertThat(map.toString(), equalTo("{T=java.util.Collection<java.lang.String>}")).     map = GenericTypeResolver.getTypeVariableMap(MyCollectionSuperclassType.class).     assertThat(map.toString(), equalTo("{T=java.util.Collection<java.lang.String>}")).     map = GenericTypeResolver.getTypeVariableMap(MySimpleTypeWithMethods.class).     assertThat(map.toString(), equalTo("{T=class java.lang.Integer}")).     map = GenericTypeResolver.getTypeVariableMap(TopLevelClass.class).     assertThat(map.toString(), equalTo("{}")).     map = GenericTypeResolver.getTypeVariableMap(TypedTopLevelClass.class).     assertThat(map.toString(), equalTo("{T=class java.lang.Integer}")).     map = GenericTypeResolver.getTypeVariableMap(TypedTopLevelClass.TypedNested.class).     assertThat(map.size(), equalTo(2)).     Type t = null.     Type x = null.     for (Map.Entry<TypeVariable, Type> entry : map.entrySet()) {         if (entry.getKey().toString().equals("T")) {             t = entry.getValue().         } else {             x = entry.getValue().         }     }     assertThat(t, equalTo((Type) Integer.class)).     assertThat(x, equalTo((Type) Long.class)). }
false;public;0;5;;// SPR-11030 @Test public void getGenericsCannotBeResolved() throws Exception {     Class<?>[] resolved = GenericTypeResolver.resolveTypeArguments(List.class, Iterable.class).     assertNull(resolved). }
false;public;0;5;;// SPR-11052 @Test public void getRawMapTypeCannotBeResolved() throws Exception {     Class<?>[] resolved = GenericTypeResolver.resolveTypeArguments(Map.class, Map.class).     assertNull(resolved). }
false;public;0;7;;// SPR-11044 @Test public void getGenericsOnArrayFromParamCannotBeResolved() throws Exception {     MethodParameter methodParameter = MethodParameter.forExecutable(WithArrayBase.class.getDeclaredMethod("array", Object[].class), 0).     Class<?> resolved = GenericTypeResolver.resolveParameterType(methodParameter, WithArray.class).     assertThat(resolved, equalTo((Class<?>) Object[].class)). }
false;public;0;6;;// SPR-11044 @Test public void getGenericsOnArrayFromReturnCannotBeResolved() throws Exception {     Class<?> resolved = GenericTypeResolver.resolveReturnType(WithArrayBase.class.getDeclaredMethod("array", Object[].class), WithArray.class).     assertThat(resolved, equalTo((Class<?>) Object[].class)). }
false;public;0;8;;// SPR-11763 @Test public void resolveIncompleteTypeVariables() {     Class<?>[] resolved = GenericTypeResolver.resolveTypeArguments(IdFixingRepository.class, Repository.class).     assertNotNull(resolved).     assertEquals(2, resolved.length).     assertEquals(Object.class, resolved[0]).     assertEquals(Long.class, resolved[1]). }
false;public;0;3;;public MyInterfaceType<Integer> integer() {     return null. }
false;public;0;3;;public MySimpleInterfaceType string() {     return null. }
false;public;0;3;;public Object object() {     return null. }
false;public;0;3;;public MyInterfaceType raw() {     return null. }
false;public;0;3;;public String notParameterized() {     return null. }
false;public;2;3;;public String notParameterizedWithArguments(Integer x, Boolean b) {     return null. }
true;public,static;1;3;/**  * Simulates a factory method that wraps the supplied object in a proxy of the  * same type.  */ ;/**  * Simulates a factory method that wraps the supplied object in a proxy of the  * same type.  */ public static <T> T createProxy(T object) {     return null. }
true;public,static;2;3;/**  * Similar to {@link #createProxy(Object)} but adds an additional argument before  * the argument of type {@code T}. Note that they may potentially be of the same  * time when invoked!  */ ;/**  * Similar to {@link #createProxy(Object)} but adds an additional argument before  * the argument of type {@code T}. Note that they may potentially be of the same  * time when invoked!  */ public static <T> T createNamedProxy(String name, T object) {     return null. }
true;public,static;1;3;/**  * Simulates factory methods found in libraries such as Mockito and EasyMock.  */ ;/**  * Simulates factory methods found in libraries such as Mockito and EasyMock.  */ public static <MOCK> MOCK createMock(Class<MOCK> toMock) {     return null. }
true;public,static;2;3;/**  * Similar to {@link #createMock(Class)} but adds an additional method argument  * before the parameterized argument.  */ ;/**  * Similar to {@link #createMock(Class)} but adds an additional method argument  * before the parameterized argument.  */ public static <T> T createNamedMock(String name, Class<T> toMock) {     return null. }
true;public,static;2;3;/**  * Similar to {@link #createNamedMock(String, Class)} but adds an additional  * parameterized type.  */ ;/**  * Similar to {@link #createNamedMock(String, Class)} but adds an additional  * parameterized type.  */ public static <V extends Object, T> T createVMock(V name, Class<T> toMock) {     return null. }
true;public,static;1;3;/**  * Extract some value of the type supported by the interface (i.e., by a concrete,  * non-generic implementation of the interface).  */ ;/**  * Extract some value of the type supported by the interface (i.e., by a concrete,  * non-generic implementation of the interface).  */ public static <T> T extractValueFrom(MyInterfaceType<T> myInterfaceType) {     return null. }
true;public,static;1;3;/**  * Extract some magic value from the supplied map.  */ ;/**  * Extract some magic value from the supplied map.  */ public static <K, V> V extractMagicValue(Map<K, V> map) {     return null. }
false;public;1;2;;public void readIntegerInputMessage(MyInterfaceType<Integer> message) { }
false;public;1;2;;public void readIntegerArrayInputMessage(MyInterfaceType<Integer>[] message) { }
false;public;1;2;;public void readGenericArrayInputMessage(T[] message) { }
false;public,abstract;1;1;;public abstract T[] array(T... args).
