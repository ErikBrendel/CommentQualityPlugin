commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Before public void clearCacheBeforeTests() {     AnnotationUtils.clearCache(). }
false;public;0;7;;@Test public void findMethodAnnotationOnLeaf() throws Exception {     Method m = Leaf.class.getMethod("annotatedOnLeaf").     assertNotNull(m.getAnnotation(Order.class)).     assertNotNull(getAnnotation(m, Order.class)).     assertNotNull(findAnnotation(m, Order.class)). }
true;public;0;10;// @since 4.2 ;// @since 4.2 @Test public void findMethodAnnotationWithAnnotationOnMethodInInterface() throws Exception {     Method m = Leaf.class.getMethod("fromInterfaceImplementedByRoot").     // @Order is not @Inherited     assertNull(m.getAnnotation(Order.class)).     // getAnnotation() does not search on interfaces     assertNull(getAnnotation(m, Order.class)).     // findAnnotation() does search on interfaces     assertNotNull(findAnnotation(m, Order.class)). }
true;public;0;7;// @since 4.2 ;// @since 4.2 @Test public void findMethodAnnotationWithMetaAnnotationOnLeaf() throws Exception {     Method m = Leaf.class.getMethod("metaAnnotatedOnLeaf").     assertNull(m.getAnnotation(Order.class)).     assertNotNull(getAnnotation(m, Order.class)).     assertNotNull(findAnnotation(m, Order.class)). }
true;public;0;7;// @since 4.2 ;// @since 4.2 @Test public void findMethodAnnotationWithMetaMetaAnnotationOnLeaf() throws Exception {     Method m = Leaf.class.getMethod("metaMetaAnnotatedOnLeaf").     assertNull(m.getAnnotation(Component.class)).     assertNull(getAnnotation(m, Component.class)).     assertNotNull(findAnnotation(m, Component.class)). }
false;public;0;7;;@Test public void findMethodAnnotationOnRoot() throws Exception {     Method m = Leaf.class.getMethod("annotatedOnRoot").     assertNotNull(m.getAnnotation(Order.class)).     assertNotNull(getAnnotation(m, Order.class)).     assertNotNull(findAnnotation(m, Order.class)). }
true;public;0;7;// @since 4.2 ;// @since 4.2 @Test public void findMethodAnnotationWithMetaAnnotationOnRoot() throws Exception {     Method m = Leaf.class.getMethod("metaAnnotatedOnRoot").     assertNull(m.getAnnotation(Order.class)).     assertNotNull(getAnnotation(m, Order.class)).     assertNotNull(findAnnotation(m, Order.class)). }
false;public;0;7;;@Test public void findMethodAnnotationOnRootButOverridden() throws Exception {     Method m = Leaf.class.getMethod("overrideWithoutNewAnnotation").     assertNull(m.getAnnotation(Order.class)).     assertNull(getAnnotation(m, Order.class)).     assertNotNull(findAnnotation(m, Order.class)). }
false;public;0;5;;@Test public void findMethodAnnotationNotAnnotated() throws Exception {     Method m = Leaf.class.getMethod("notAnnotated").     assertNull(findAnnotation(m, Order.class)). }
false;public;0;26;;@Test public void findMethodAnnotationOnBridgeMethod() throws Exception {     Method bridgeMethod = SimpleFoo.class.getMethod("something", Object.class).     assertTrue(bridgeMethod.isBridge()).     assertNull(bridgeMethod.getAnnotation(Order.class)).     assertNull(getAnnotation(bridgeMethod, Order.class)).     assertNotNull(findAnnotation(bridgeMethod, Order.class)).     boolean runningInEclipse = Arrays.stream(new Exception().getStackTrace()).anyMatch(element -> element.getClassName().startsWith("org.eclipse.jdt")).     //      if (!runningInEclipse) {         assertNotNull(bridgeMethod.getAnnotation(Transactional.class)).     }     assertNotNull(getAnnotation(bridgeMethod, Transactional.class)).     assertNotNull(findAnnotation(bridgeMethod, Transactional.class)). }
false;public;0;13;;@Test public void findMethodAnnotationOnBridgedMethod() throws Exception {     Method bridgedMethod = SimpleFoo.class.getMethod("something", String.class).     assertFalse(bridgedMethod.isBridge()).     assertNull(bridgedMethod.getAnnotation(Order.class)).     assertNull(getAnnotation(bridgedMethod, Order.class)).     assertNotNull(findAnnotation(bridgedMethod, Order.class)).     assertNotNull(bridgedMethod.getAnnotation(Transactional.class)).     assertNotNull(getAnnotation(bridgedMethod, Transactional.class)).     assertNotNull(findAnnotation(bridgedMethod, Transactional.class)). }
false;public;0;6;;@Test public void findMethodAnnotationFromInterface() throws Exception {     Method method = ImplementsInterfaceWithAnnotatedMethod.class.getMethod("foo").     Order order = findAnnotation(method, Order.class).     assertNotNull(order). }
false;public;0;6;;// SPR-16060 @Test public void findMethodAnnotationFromGenericInterface() throws Exception {     Method method = ImplementsInterfaceWithGenericAnnotatedMethod.class.getMethod("foo", String.class).     Order order = findAnnotation(method, Order.class).     assertNotNull(order). }
false;public;0;6;;// SPR-17146 @Test public void findMethodAnnotationFromGenericSuperclass() throws Exception {     Method method = ExtendsBaseClassWithGenericAnnotatedMethod.class.getMethod("foo", String.class).     Order order = findAnnotation(method, Order.class).     assertNotNull(order). }
false;public;0;6;;@Test public void findMethodAnnotationFromInterfaceOnSuper() throws Exception {     Method method = SubOfImplementsInterfaceWithAnnotatedMethod.class.getMethod("foo").     Order order = findAnnotation(method, Order.class).     assertNotNull(order). }
false;public;0;6;;@Test public void findMethodAnnotationFromInterfaceWhenSuperDoesNotImplementMethod() throws Exception {     Method method = SubOfAbstractImplementsInterfaceWithAnnotatedMethod.class.getMethod("foo").     Order order = findAnnotation(method, Order.class).     assertNotNull(order). }
true;public;0;6;// @since 4.1.2 ;// @since 4.1.2 @Test public void findClassAnnotationFavorsMoreLocallyDeclaredComposedAnnotationsOverAnnotationsOnInterfaces() {     Component component = findAnnotation(ClassWithLocalMetaAnnotationAndMetaAnnotatedInterface.class, Component.class).     assertNotNull(component).     assertEquals("meta2", component.value()). }
true;public;0;6;// @since 4.0.3 ;// @since 4.0.3 @Test public void findClassAnnotationFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedAnnotations() {     Transactional transactional = findAnnotation(SubSubClassWithInheritedAnnotation.class, Transactional.class).     assertNotNull(transactional).     assertTrue("readOnly flag for SubSubClassWithInheritedAnnotation", transactional.readOnly()). }
true;public;0;6;// @since 4.0.3 ;// @since 4.0.3 @Test public void findClassAnnotationFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedComposedAnnotations() {     Component component = findAnnotation(SubSubClassWithInheritedMetaAnnotation.class, Component.class).     assertNotNull(component).     assertEquals("meta2", component.value()). }
false;public;0;6;;@Test public void findClassAnnotationOnMetaMetaAnnotatedClass() {     Component component = findAnnotation(MetaMetaAnnotatedClass.class, Component.class).     assertNotNull("Should find meta-annotation on composed annotation on class", component).     assertEquals("meta2", component.value()). }
false;public;0;6;;@Test public void findClassAnnotationOnMetaMetaMetaAnnotatedClass() {     Component component = findAnnotation(MetaMetaMetaAnnotatedClass.class, Component.class).     assertNotNull("Should find meta-annotation on meta-annotation on composed annotation on class", component).     assertEquals("meta2", component.value()). }
false;public;0;6;;@Test public void findClassAnnotationOnAnnotatedClassWithMissingTargetMetaAnnotation() {     // TransactionalClass is NOT annotated or meta-annotated with @Component     Component component = findAnnotation(TransactionalClass.class, Component.class).     assertNull("Should not find @Component on TransactionalClass", component). }
false;public;0;5;;@Test public void findClassAnnotationOnMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation() {     Component component = findAnnotation(MetaCycleAnnotatedClass.class, Component.class).     assertNull("Should not find @Component on MetaCycleAnnotatedClass", component). }
true;public;0;5;// @since 4.2 ;// @since 4.2 @Test public void findClassAnnotationOnInheritedAnnotationInterface() {     Transactional tx = findAnnotation(InheritedAnnotationInterface.class, Transactional.class).     assertNotNull("Should find @Transactional on InheritedAnnotationInterface", tx). }
true;public;0;5;// @since 4.2 ;// @since 4.2 @Test public void findClassAnnotationOnSubInheritedAnnotationInterface() {     Transactional tx = findAnnotation(SubInheritedAnnotationInterface.class, Transactional.class).     assertNotNull("Should find @Transactional on SubInheritedAnnotationInterface", tx). }
true;public;0;5;// @since 4.2 ;// @since 4.2 @Test public void findClassAnnotationOnSubSubInheritedAnnotationInterface() {     Transactional tx = findAnnotation(SubSubInheritedAnnotationInterface.class, Transactional.class).     assertNotNull("Should find @Transactional on SubSubInheritedAnnotationInterface", tx). }
true;public;0;5;// @since 4.2 ;// @since 4.2 @Test public void findClassAnnotationOnNonInheritedAnnotationInterface() {     Order order = findAnnotation(NonInheritedAnnotationInterface.class, Order.class).     assertNotNull("Should find @Order on NonInheritedAnnotationInterface", order). }
true;public;0;5;// @since 4.2 ;// @since 4.2 @Test public void findClassAnnotationOnSubNonInheritedAnnotationInterface() {     Order order = findAnnotation(SubNonInheritedAnnotationInterface.class, Order.class).     assertNotNull("Should find @Order on SubNonInheritedAnnotationInterface", order). }
true;public;0;5;// @since 4.2 ;// @since 4.2 @Test public void findClassAnnotationOnSubSubNonInheritedAnnotationInterface() {     Order order = findAnnotation(SubSubNonInheritedAnnotationInterface.class, Order.class).     assertNotNull("Should find @Order on SubSubNonInheritedAnnotationInterface", order). }
false;public;0;25;;@Test public void findAnnotationDeclaringClassForAllScenarios() {     // no class-level annotation     assertNull(findAnnotationDeclaringClass(Transactional.class, NonAnnotatedInterface.class)).     assertNull(findAnnotationDeclaringClass(Transactional.class, NonAnnotatedClass.class)).     // inherited class-level annotation. note: @Transactional is inherited     assertEquals(InheritedAnnotationInterface.class, findAnnotationDeclaringClass(Transactional.class, InheritedAnnotationInterface.class)).     assertNull(findAnnotationDeclaringClass(Transactional.class, SubInheritedAnnotationInterface.class)).     assertEquals(InheritedAnnotationClass.class, findAnnotationDeclaringClass(Transactional.class, InheritedAnnotationClass.class)).     assertEquals(InheritedAnnotationClass.class, findAnnotationDeclaringClass(Transactional.class, SubInheritedAnnotationClass.class)).     // non-inherited class-level annotation. note: @Order is not inherited,     // but findAnnotationDeclaringClass() should still find it on classes.     assertEquals(NonInheritedAnnotationInterface.class, findAnnotationDeclaringClass(Order.class, NonInheritedAnnotationInterface.class)).     assertNull(findAnnotationDeclaringClass(Order.class, SubNonInheritedAnnotationInterface.class)).     assertEquals(NonInheritedAnnotationClass.class, findAnnotationDeclaringClass(Order.class, NonInheritedAnnotationClass.class)).     assertEquals(NonInheritedAnnotationClass.class, findAnnotationDeclaringClass(Order.class, SubNonInheritedAnnotationClass.class)). }
false;public;0;27;;@Test public void findAnnotationDeclaringClassForTypesWithSingleCandidateType() {     // no class-level annotation     List<Class<? extends Annotation>> transactionalCandidateList = Collections.singletonList(Transactional.class).     assertNull(findAnnotationDeclaringClassForTypes(transactionalCandidateList, NonAnnotatedInterface.class)).     assertNull(findAnnotationDeclaringClassForTypes(transactionalCandidateList, NonAnnotatedClass.class)).     // inherited class-level annotation. note: @Transactional is inherited     assertEquals(InheritedAnnotationInterface.class, findAnnotationDeclaringClassForTypes(transactionalCandidateList, InheritedAnnotationInterface.class)).     assertNull(findAnnotationDeclaringClassForTypes(transactionalCandidateList, SubInheritedAnnotationInterface.class)).     assertEquals(InheritedAnnotationClass.class, findAnnotationDeclaringClassForTypes(transactionalCandidateList, InheritedAnnotationClass.class)).     assertEquals(InheritedAnnotationClass.class, findAnnotationDeclaringClassForTypes(transactionalCandidateList, SubInheritedAnnotationClass.class)).     // non-inherited class-level annotation. note: @Order is not inherited,     // but findAnnotationDeclaringClassForTypes() should still find it on classes.     List<Class<? extends Annotation>> orderCandidateList = Collections.singletonList(Order.class).     assertEquals(NonInheritedAnnotationInterface.class, findAnnotationDeclaringClassForTypes(orderCandidateList, NonInheritedAnnotationInterface.class)).     assertNull(findAnnotationDeclaringClassForTypes(orderCandidateList, SubNonInheritedAnnotationInterface.class)).     assertEquals(NonInheritedAnnotationClass.class, findAnnotationDeclaringClassForTypes(orderCandidateList, NonInheritedAnnotationClass.class)).     assertEquals(NonInheritedAnnotationClass.class, findAnnotationDeclaringClassForTypes(orderCandidateList, SubNonInheritedAnnotationClass.class)). }
false;public;0;35;;@Test public void findAnnotationDeclaringClassForTypesWithMultipleCandidateTypes() {     List<Class<? extends Annotation>> candidates = asList(Transactional.class, Order.class).     // no class-level annotation     assertNull(findAnnotationDeclaringClassForTypes(candidates, NonAnnotatedInterface.class)).     assertNull(findAnnotationDeclaringClassForTypes(candidates, NonAnnotatedClass.class)).     // inherited class-level annotation. note: @Transactional is inherited     assertEquals(InheritedAnnotationInterface.class, findAnnotationDeclaringClassForTypes(candidates, InheritedAnnotationInterface.class)).     assertNull(findAnnotationDeclaringClassForTypes(candidates, SubInheritedAnnotationInterface.class)).     assertEquals(InheritedAnnotationClass.class, findAnnotationDeclaringClassForTypes(candidates, InheritedAnnotationClass.class)).     assertEquals(InheritedAnnotationClass.class, findAnnotationDeclaringClassForTypes(candidates, SubInheritedAnnotationClass.class)).     // non-inherited class-level annotation. note: @Order is not inherited,     // but findAnnotationDeclaringClassForTypes() should still find it on classes.     assertEquals(NonInheritedAnnotationInterface.class, findAnnotationDeclaringClassForTypes(candidates, NonInheritedAnnotationInterface.class)).     assertNull(findAnnotationDeclaringClassForTypes(candidates, SubNonInheritedAnnotationInterface.class)).     assertEquals(NonInheritedAnnotationClass.class, findAnnotationDeclaringClassForTypes(candidates, NonInheritedAnnotationClass.class)).     assertEquals(NonInheritedAnnotationClass.class, findAnnotationDeclaringClassForTypes(candidates, SubNonInheritedAnnotationClass.class)).     // class hierarchy mixed with @Transactional and @Order declarations     assertEquals(TransactionalClass.class, findAnnotationDeclaringClassForTypes(candidates, TransactionalClass.class)).     assertEquals(TransactionalAndOrderedClass.class, findAnnotationDeclaringClassForTypes(candidates, TransactionalAndOrderedClass.class)).     assertEquals(TransactionalAndOrderedClass.class, findAnnotationDeclaringClassForTypes(candidates, SubTransactionalAndOrderedClass.class)). }
false;public;0;18;;@Test public void isAnnotationDeclaredLocallyForAllScenarios() throws Exception {     // no class-level annotation     assertFalse(isAnnotationDeclaredLocally(Transactional.class, NonAnnotatedInterface.class)).     assertFalse(isAnnotationDeclaredLocally(Transactional.class, NonAnnotatedClass.class)).     // inherited class-level annotation. note: @Transactional is inherited     assertTrue(isAnnotationDeclaredLocally(Transactional.class, InheritedAnnotationInterface.class)).     assertFalse(isAnnotationDeclaredLocally(Transactional.class, SubInheritedAnnotationInterface.class)).     assertTrue(isAnnotationDeclaredLocally(Transactional.class, InheritedAnnotationClass.class)).     assertFalse(isAnnotationDeclaredLocally(Transactional.class, SubInheritedAnnotationClass.class)).     // non-inherited class-level annotation. note: @Order is not inherited     assertTrue(isAnnotationDeclaredLocally(Order.class, NonInheritedAnnotationInterface.class)).     assertFalse(isAnnotationDeclaredLocally(Order.class, SubNonInheritedAnnotationInterface.class)).     assertTrue(isAnnotationDeclaredLocally(Order.class, NonInheritedAnnotationClass.class)).     assertFalse(isAnnotationDeclaredLocally(Order.class, SubNonInheritedAnnotationClass.class)). }
false;public;0;20;;@Test public void isAnnotationInheritedForAllScenarios() {     // no class-level annotation     assertFalse(isAnnotationInherited(Transactional.class, NonAnnotatedInterface.class)).     assertFalse(isAnnotationInherited(Transactional.class, NonAnnotatedClass.class)).     // inherited class-level annotation. note: @Transactional is inherited     assertFalse(isAnnotationInherited(Transactional.class, InheritedAnnotationInterface.class)).     // isAnnotationInherited() does not currently traverse interface hierarchies.     // Thus the following, though perhaps counter intuitive, must be false:     assertFalse(isAnnotationInherited(Transactional.class, SubInheritedAnnotationInterface.class)).     assertFalse(isAnnotationInherited(Transactional.class, InheritedAnnotationClass.class)).     assertTrue(isAnnotationInherited(Transactional.class, SubInheritedAnnotationClass.class)).     // non-inherited class-level annotation. note: @Order is not inherited     assertFalse(isAnnotationInherited(Order.class, NonInheritedAnnotationInterface.class)).     assertFalse(isAnnotationInherited(Order.class, SubNonInheritedAnnotationInterface.class)).     assertFalse(isAnnotationInherited(Order.class, NonInheritedAnnotationClass.class)).     assertFalse(isAnnotationInherited(Order.class, SubNonInheritedAnnotationClass.class)). }
false;public;0;10;;@Test public void getAnnotationAttributesWithoutAttributeAliases() {     Component component = WebController.class.getAnnotation(Component.class).     assertNotNull(component).     AnnotationAttributes attributes = (AnnotationAttributes) getAnnotationAttributes(component).     assertNotNull(attributes).     assertEquals("value attribute: ", "webController", attributes.getString(VALUE)).     assertEquals(Component.class, attributes.annotationType()). }
false;public;0;15;;@Test public void getAnnotationAttributesWithNestedAnnotations() {     ComponentScan componentScan = ComponentScanClass.class.getAnnotation(ComponentScan.class).     assertNotNull(componentScan).     AnnotationAttributes attributes = getAnnotationAttributes(ComponentScanClass.class, componentScan).     assertNotNull(attributes).     assertEquals(ComponentScan.class, attributes.annotationType()).     Filter[] filters = attributes.getAnnotationArray("excludeFilters", Filter.class).     assertNotNull(filters).     List<String> patterns = stream(filters).map(Filter::pattern).collect(toList()).     assertEquals(asList("*Foo", "*Bar"), patterns). }
false;public;0;20;;@Test public void getAnnotationAttributesWithAttributeAliases() throws Exception {     Method method = WebController.class.getMethod("handleMappedWithValueAttribute").     WebMapping webMapping = method.getAnnotation(WebMapping.class).     AnnotationAttributes attributes = (AnnotationAttributes) getAnnotationAttributes(webMapping).     assertNotNull(attributes).     assertEquals(WebMapping.class, attributes.annotationType()).     assertEquals("name attribute: ", "foo", attributes.getString("name")).     assertArrayEquals("value attribute: ", asArray("/test"), attributes.getStringArray(VALUE)).     assertArrayEquals("path attribute: ", asArray("/test"), attributes.getStringArray("path")).     method = WebController.class.getMethod("handleMappedWithPathAttribute").     webMapping = method.getAnnotation(WebMapping.class).     attributes = (AnnotationAttributes) getAnnotationAttributes(webMapping).     assertNotNull(attributes).     assertEquals(WebMapping.class, attributes.annotationType()).     assertEquals("name attribute: ", "bar", attributes.getString("name")).     assertArrayEquals("value attribute: ", asArray("/test"), attributes.getStringArray(VALUE)).     assertArrayEquals("path attribute: ", asArray("/test"), attributes.getStringArray("path")). }
false;public;0;10;;@Test public void getAnnotationAttributesWithAttributeAliasesWithDifferentValues() throws Exception {     exception.expect(AnnotationConfigurationException.class).     exception.expectMessage(containsString("attribute 'value' and its alias 'path'")).     exception.expectMessage(containsString("values of [{/enigma}] and [{/test}]")).     Method method = WebController.class.getMethod("handleMappedWithDifferentPathAndValueAttributes").     WebMapping webMapping = method.getAnnotation(WebMapping.class).     getAnnotationAttributes(webMapping). }
false;public;0;8;;@Test public void getValueFromAnnotation() throws Exception {     Method method = SimpleFoo.class.getMethod("something", Object.class).     Order order = findAnnotation(method, Order.class).     assertEquals(1, getValue(order, VALUE)).     assertEquals(1, getValue(order)). }
false;public;0;10;;@Test public void getValueFromNonPublicAnnotation() throws Exception {     Annotation[] declaredAnnotations = NonPublicAnnotatedClass.class.getDeclaredAnnotations().     assertEquals(1, declaredAnnotations.length).     Annotation annotation = declaredAnnotations[0].     assertNotNull(annotation).     assertEquals("NonPublicAnnotation", annotation.annotationType().getSimpleName()).     assertEquals(42, getValue(annotation, VALUE)).     assertEquals(42, getValue(annotation)). }
false;public;0;8;;@Test public void getDefaultValueFromAnnotation() throws Exception {     Method method = SimpleFoo.class.getMethod("something", Object.class).     Order order = findAnnotation(method, Order.class).     assertEquals(Ordered.LOWEST_PRECEDENCE, getDefaultValue(order, VALUE)).     assertEquals(Ordered.LOWEST_PRECEDENCE, getDefaultValue(order)). }
false;public;0;10;;@Test public void getDefaultValueFromNonPublicAnnotation() {     Annotation[] declaredAnnotations = NonPublicAnnotatedClass.class.getDeclaredAnnotations().     assertEquals(1, declaredAnnotations.length).     Annotation annotation = declaredAnnotations[0].     assertNotNull(annotation).     assertEquals("NonPublicAnnotation", annotation.annotationType().getSimpleName()).     assertEquals(-1, getDefaultValue(annotation, VALUE)).     assertEquals(-1, getDefaultValue(annotation)). }
false;public;0;5;;@Test public void getDefaultValueFromAnnotationType() {     assertEquals(Ordered.LOWEST_PRECEDENCE, getDefaultValue(Order.class, VALUE)).     assertEquals(Ordered.LOWEST_PRECEDENCE, getDefaultValue(Order.class)). }
false;public;0;6;;@Test public void findRepeatableAnnotationOnComposedAnnotation() {     Repeatable repeatable = findAnnotation(MyRepeatableMeta1.class, Repeatable.class).     assertNotNull(repeatable).     assertEquals(MyRepeatableContainer.class, repeatable.value()). }
false;public;0;8;;@Test public void getRepeatableAnnotationsDeclaredOnMethod() throws Exception {     Method method = InterfaceWithRepeated.class.getMethod("foo").     Set<MyRepeatable> annotations = getRepeatableAnnotations(method, MyRepeatable.class, MyRepeatableContainer.class).     assertNotNull(annotations).     List<String> values = annotations.stream().map(MyRepeatable::value).collect(toList()).     assertThat(values, is(asList("A", "B", "C", "meta1"))). }
false;public;0;9;;@Test public void getRepeatableAnnotationsDeclaredOnClassWithMissingAttributeAliasDeclaration() throws Exception {     exception.expect(AnnotationConfigurationException.class).     exception.expectMessage(startsWith("Attribute 'value' in")).     exception.expectMessage(containsString(BrokenContextConfig.class.getName())).     exception.expectMessage(containsString("@AliasFor [location]")).     getRepeatableAnnotations(BrokenConfigHierarchyTestCase.class, BrokenContextConfig.class, BrokenHierarchy.class). }
false;public;0;17;;@Test public void getRepeatableAnnotationsDeclaredOnClassWithAttributeAliases() {     final List<String> expectedLocations = asList("A", "B").     Set<ContextConfig> annotations = getRepeatableAnnotations(ConfigHierarchyTestCase.class, ContextConfig.class, null).     assertNotNull(annotations).     assertEquals("size if container type is omitted: ", 0, annotations.size()).     annotations = getRepeatableAnnotations(ConfigHierarchyTestCase.class, ContextConfig.class, Hierarchy.class).     assertNotNull(annotations).     List<String> locations = annotations.stream().map(ContextConfig::location).collect(toList()).     assertThat(locations, is(expectedLocations)).     List<String> values = annotations.stream().map(ContextConfig::value).collect(toList()).     assertThat(values, is(expectedLocations)). }
false;public;0;23;;@Test public void getRepeatableAnnotationsDeclaredOnClass() {     final List<String> expectedValuesJava = asList("A", "B", "C").     final List<String> expectedValuesSpring = asList("A", "B", "C", "meta1").     // Java 8     MyRepeatable[] array = MyRepeatableClass.class.getAnnotationsByType(MyRepeatable.class).     assertNotNull(array).     List<String> values = stream(array).map(MyRepeatable::value).collect(toList()).     assertThat(values, is(expectedValuesJava)).     // Spring     Set<MyRepeatable> set = getRepeatableAnnotations(MyRepeatableClass.class, MyRepeatable.class, MyRepeatableContainer.class).     assertNotNull(set).     values = set.stream().map(MyRepeatable::value).collect(toList()).     assertThat(values, is(expectedValuesSpring)).     // When container type is omitted and therefore inferred from @Repeatable     set = getRepeatableAnnotations(MyRepeatableClass.class, MyRepeatable.class).     assertNotNull(set).     values = set.stream().map(MyRepeatable::value).collect(toList()).     assertThat(values, is(expectedValuesSpring)). }
false;public;0;24;;@Test public void getRepeatableAnnotationsDeclaredOnSuperclass() {     final Class<?> clazz = SubMyRepeatableClass.class.     final List<String> expectedValuesJava = asList("A", "B", "C").     final List<String> expectedValuesSpring = asList("A", "B", "C", "meta1").     // Java 8     MyRepeatable[] array = clazz.getAnnotationsByType(MyRepeatable.class).     assertNotNull(array).     List<String> values = stream(array).map(MyRepeatable::value).collect(toList()).     assertThat(values, is(expectedValuesJava)).     // Spring     Set<MyRepeatable> set = getRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class).     assertNotNull(set).     values = set.stream().map(MyRepeatable::value).collect(toList()).     assertThat(values, is(expectedValuesSpring)).     // When container type is omitted and therefore inferred from @Repeatable     set = getRepeatableAnnotations(clazz, MyRepeatable.class).     assertNotNull(set).     values = set.stream().map(MyRepeatable::value).collect(toList()).     assertThat(values, is(expectedValuesSpring)). }
false;public;0;24;;@Test public void getRepeatableAnnotationsDeclaredOnClassAndSuperclass() {     final Class<?> clazz = SubMyRepeatableWithAdditionalLocalDeclarationsClass.class.     final List<String> expectedValuesJava = asList("X", "Y", "Z").     final List<String> expectedValuesSpring = asList("X", "Y", "Z", "meta2").     // Java 8     MyRepeatable[] array = clazz.getAnnotationsByType(MyRepeatable.class).     assertNotNull(array).     List<String> values = stream(array).map(MyRepeatable::value).collect(toList()).     assertThat(values, is(expectedValuesJava)).     // Spring     Set<MyRepeatable> set = getRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class).     assertNotNull(set).     values = set.stream().map(MyRepeatable::value).collect(toList()).     assertThat(values, is(expectedValuesSpring)).     // When container type is omitted and therefore inferred from @Repeatable     set = getRepeatableAnnotations(clazz, MyRepeatable.class).     assertNotNull(set).     values = set.stream().map(MyRepeatable::value).collect(toList()).     assertThat(values, is(expectedValuesSpring)). }
false;public;0;24;;@Test public void getRepeatableAnnotationsDeclaredOnMultipleSuperclasses() {     final Class<?> clazz = SubSubMyRepeatableWithAdditionalLocalDeclarationsClass.class.     final List<String> expectedValuesJava = asList("X", "Y", "Z").     final List<String> expectedValuesSpring = asList("X", "Y", "Z", "meta2").     // Java 8     MyRepeatable[] array = clazz.getAnnotationsByType(MyRepeatable.class).     assertNotNull(array).     List<String> values = stream(array).map(MyRepeatable::value).collect(toList()).     assertThat(values, is(expectedValuesJava)).     // Spring     Set<MyRepeatable> set = getRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class).     assertNotNull(set).     values = set.stream().map(MyRepeatable::value).collect(toList()).     assertThat(values, is(expectedValuesSpring)).     // When container type is omitted and therefore inferred from @Repeatable     set = getRepeatableAnnotations(clazz, MyRepeatable.class).     assertNotNull(set).     values = set.stream().map(MyRepeatable::value).collect(toList()).     assertThat(values, is(expectedValuesSpring)). }
false;public;0;23;;@Test public void getDeclaredRepeatableAnnotationsDeclaredOnClass() {     final List<String> expectedValuesJava = asList("A", "B", "C").     final List<String> expectedValuesSpring = asList("A", "B", "C", "meta1").     // Java 8     MyRepeatable[] array = MyRepeatableClass.class.getDeclaredAnnotationsByType(MyRepeatable.class).     assertNotNull(array).     List<String> values = stream(array).map(MyRepeatable::value).collect(toList()).     assertThat(values, is(expectedValuesJava)).     // Spring     Set<MyRepeatable> set = getDeclaredRepeatableAnnotations(MyRepeatableClass.class, MyRepeatable.class, MyRepeatableContainer.class).     assertNotNull(set).     values = set.stream().map(MyRepeatable::value).collect(toList()).     assertThat(values, is(expectedValuesSpring)).     // When container type is omitted and therefore inferred from @Repeatable     set = getDeclaredRepeatableAnnotations(MyRepeatableClass.class, MyRepeatable.class).     assertNotNull(set).     values = set.stream().map(MyRepeatable::value).collect(toList()).     assertThat(values, is(expectedValuesSpring)). }
false;public;0;19;;@Test public void getDeclaredRepeatableAnnotationsDeclaredOnSuperclass() {     final Class<?> clazz = SubMyRepeatableClass.class.     // Java 8     MyRepeatable[] array = clazz.getDeclaredAnnotationsByType(MyRepeatable.class).     assertNotNull(array).     assertThat(array.length, is(0)).     // Spring     Set<MyRepeatable> set = getDeclaredRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class).     assertNotNull(set).     assertThat(set.size(), is(0)).     // When container type is omitted and therefore inferred from @Repeatable     set = getDeclaredRepeatableAnnotations(clazz, MyRepeatable.class).     assertNotNull(set).     assertThat(set.size(), is(0)). }
false;public;0;6;;@Test public void getAttributeOverrideNameFromWrongTargetAnnotation() throws Exception {     Method attribute = AliasedComposedContextConfig.class.getDeclaredMethod("xmlConfigFile").     assertThat("xmlConfigFile is not an alias for @Component.", getAttributeOverrideName(attribute, Component.class), is(nullValue())). }
false;public;0;5;;@Test public void getAttributeOverrideNameForNonAliasedAttribute() throws Exception {     Method nonAliasedAttribute = ImplicitAliasesContextConfig.class.getDeclaredMethod("nonAliasedAttribute").     assertThat(getAttributeOverrideName(nonAliasedAttribute, ContextConfig.class), is(nullValue())). }
false;public;0;5;;@Test public void getAttributeOverrideNameFromAliasedComposedAnnotation() throws Exception {     Method attribute = AliasedComposedContextConfig.class.getDeclaredMethod("xmlConfigFile").     assertEquals("location", getAttributeOverrideName(attribute, ContextConfig.class)). }
false;public;0;22;;@Test public void getAttributeAliasNamesFromComposedAnnotationWithImplicitAliases() throws Exception {     Method xmlFile = ImplicitAliasesContextConfig.class.getDeclaredMethod("xmlFile").     Method groovyScript = ImplicitAliasesContextConfig.class.getDeclaredMethod("groovyScript").     Method value = ImplicitAliasesContextConfig.class.getDeclaredMethod("value").     Method location1 = ImplicitAliasesContextConfig.class.getDeclaredMethod("location1").     Method location2 = ImplicitAliasesContextConfig.class.getDeclaredMethod("location2").     Method location3 = ImplicitAliasesContextConfig.class.getDeclaredMethod("location3").     // Meta-annotation attribute overrides     assertEquals("location", getAttributeOverrideName(xmlFile, ContextConfig.class)).     assertEquals("location", getAttributeOverrideName(groovyScript, ContextConfig.class)).     assertEquals("location", getAttributeOverrideName(value, ContextConfig.class)).     // Implicit aliases     assertThat(getAttributeAliasNames(xmlFile), containsInAnyOrder("value", "groovyScript", "location1", "location2", "location3")).     assertThat(getAttributeAliasNames(groovyScript), containsInAnyOrder("value", "xmlFile", "location1", "location2", "location3")).     assertThat(getAttributeAliasNames(value), containsInAnyOrder("xmlFile", "groovyScript", "location1", "location2", "location3")).     assertThat(getAttributeAliasNames(location1), containsInAnyOrder("xmlFile", "groovyScript", "value", "location2", "location3")).     assertThat(getAttributeAliasNames(location2), containsInAnyOrder("xmlFile", "groovyScript", "value", "location1", "location3")).     assertThat(getAttributeAliasNames(location3), containsInAnyOrder("xmlFile", "groovyScript", "value", "location1", "location2")). }
false;public;0;13;;@Test public void getAttributeAliasNamesFromComposedAnnotationWithImplicitAliasesForAliasPair() throws Exception {     Method xmlFile = ImplicitAliasesForAliasPairContextConfig.class.getDeclaredMethod("xmlFile").     Method groovyScript = ImplicitAliasesForAliasPairContextConfig.class.getDeclaredMethod("groovyScript").     // Meta-annotation attribute overrides     assertEquals("location", getAttributeOverrideName(xmlFile, ContextConfig.class)).     assertEquals("value", getAttributeOverrideName(groovyScript, ContextConfig.class)).     // Implicit aliases     assertThat(getAttributeAliasNames(xmlFile), containsInAnyOrder("groovyScript")).     assertThat(getAttributeAliasNames(groovyScript), containsInAnyOrder("xmlFile")). }
false;public;0;18;;@Test public void getAttributeAliasNamesFromComposedAnnotationWithImplicitAliasesWithImpliedAliasNamesOmitted() throws Exception {     Method value = ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig.class.getDeclaredMethod("value").     Method location = ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig.class.getDeclaredMethod("location").     Method xmlFile = ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig.class.getDeclaredMethod("xmlFile").     // Meta-annotation attribute overrides     assertEquals("value", getAttributeOverrideName(value, ContextConfig.class)).     assertEquals("location", getAttributeOverrideName(location, ContextConfig.class)).     assertEquals("location", getAttributeOverrideName(xmlFile, ContextConfig.class)).     // Implicit aliases     assertThat(getAttributeAliasNames(value), containsInAnyOrder("location", "xmlFile")).     assertThat(getAttributeAliasNames(location), containsInAnyOrder("value", "xmlFile")).     assertThat(getAttributeAliasNames(xmlFile), containsInAnyOrder("value", "location")). }
false;public;0;17;;@Test public void getAttributeAliasNamesFromComposedAnnotationWithTransitiveImplicitAliases() throws Exception {     Method xml = TransitiveImplicitAliasesContextConfig.class.getDeclaredMethod("xml").     Method groovy = TransitiveImplicitAliasesContextConfig.class.getDeclaredMethod("groovy").     // Explicit meta-annotation attribute overrides     assertEquals("xmlFile", getAttributeOverrideName(xml, ImplicitAliasesContextConfig.class)).     assertEquals("groovyScript", getAttributeOverrideName(groovy, ImplicitAliasesContextConfig.class)).     // Transitive meta-annotation attribute overrides     assertEquals("location", getAttributeOverrideName(xml, ContextConfig.class)).     assertEquals("location", getAttributeOverrideName(groovy, ContextConfig.class)).     // Transitive implicit aliases     assertThat(getAttributeAliasNames(xml), containsInAnyOrder("groovy")).     assertThat(getAttributeAliasNames(groovy), containsInAnyOrder("xml")). }
false;public;0;13;;@Test public void getAttributeAliasNamesFromComposedAnnotationWithTransitiveImplicitAliasesForAliasPair() throws Exception {     Method xml = TransitiveImplicitAliasesForAliasPairContextConfig.class.getDeclaredMethod("xml").     Method groovy = TransitiveImplicitAliasesForAliasPairContextConfig.class.getDeclaredMethod("groovy").     // Explicit meta-annotation attribute overrides     assertEquals("xmlFile", getAttributeOverrideName(xml, ImplicitAliasesForAliasPairContextConfig.class)).     assertEquals("groovyScript", getAttributeOverrideName(groovy, ImplicitAliasesForAliasPairContextConfig.class)).     // Transitive implicit aliases     assertThat(getAttributeAliasNames(xml), containsInAnyOrder("groovy")).     assertThat(getAttributeAliasNames(groovy), containsInAnyOrder("xml")). }
false;public;0;19;;@Test public void getAttributeAliasNamesFromComposedAnnotationWithTransitiveImplicitAliasesWithImpliedAliasNamesOmitted() throws Exception {     Method xml = TransitiveImplicitAliasesWithImpliedAliasNamesOmittedContextConfig.class.getDeclaredMethod("xml").     Method groovy = TransitiveImplicitAliasesWithImpliedAliasNamesOmittedContextConfig.class.getDeclaredMethod("groovy").     // Meta-annotation attribute overrides     assertEquals("location", getAttributeOverrideName(xml, ContextConfig.class)).     assertEquals("location", getAttributeOverrideName(groovy, ContextConfig.class)).     // Explicit meta-annotation attribute overrides     assertEquals("xmlFile", getAttributeOverrideName(xml, ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig.class)).     assertEquals("location", getAttributeOverrideName(groovy, ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig.class)).     // Transitive implicit aliases     assertThat(getAttributeAliasNames(groovy), containsInAnyOrder("xml")).     assertThat(getAttributeAliasNames(xml), containsInAnyOrder("groovy")). }
false;public;0;9;;@Test public void synthesizeAnnotationWithoutAttributeAliases() throws Exception {     Component component = WebController.class.getAnnotation(Component.class).     assertNotNull(component).     Component synthesizedComponent = synthesizeAnnotation(component).     assertNotNull(synthesizedComponent).     assertSame(component, synthesizedComponent).     assertEquals("value attribute: ", "webController", synthesizedComponent.value()). }
false;public;0;15;;@Test public void synthesizeAlreadySynthesizedAnnotation() throws Exception {     Method method = WebController.class.getMethod("handleMappedWithValueAttribute").     WebMapping webMapping = method.getAnnotation(WebMapping.class).     assertNotNull(webMapping).     WebMapping synthesizedWebMapping = synthesizeAnnotation(webMapping).     assertNotSame(webMapping, synthesizedWebMapping).     WebMapping synthesizedAgainWebMapping = synthesizeAnnotation(synthesizedWebMapping).     assertThat(synthesizedAgainWebMapping, instanceOf(SynthesizedAnnotation.class)).     assertSame(synthesizedWebMapping, synthesizedAgainWebMapping).     assertEquals("name attribute: ", "foo", synthesizedAgainWebMapping.name()).     assertArrayEquals("aliased path attribute: ", asArray("/test"), synthesizedAgainWebMapping.path()).     assertArrayEquals("actual value attribute: ", asArray("/test"), synthesizedAgainWebMapping.value()). }
false;public;0;9;;@Test public void synthesizeAnnotationWhereAliasForIsMissingAttributeDeclaration() throws Exception {     AliasForWithMissingAttributeDeclaration annotation = AliasForWithMissingAttributeDeclarationClass.class.getAnnotation(AliasForWithMissingAttributeDeclaration.class).     exception.expect(AnnotationConfigurationException.class).     exception.expectMessage(startsWith("@AliasFor declaration on attribute 'foo' in annotation")).     exception.expectMessage(containsString(AliasForWithMissingAttributeDeclaration.class.getName())).     exception.expectMessage(containsString("points to itself")).     synthesizeAnnotation(annotation). }
false;public;0;9;;@Test public void synthesizeAnnotationWhereAliasForHasDuplicateAttributeDeclaration() throws Exception {     AliasForWithDuplicateAttributeDeclaration annotation = AliasForWithDuplicateAttributeDeclarationClass.class.getAnnotation(AliasForWithDuplicateAttributeDeclaration.class).     exception.expect(AnnotationConfigurationException.class).     exception.expectMessage(startsWith("In @AliasFor declared on attribute 'foo' in annotation")).     exception.expectMessage(containsString(AliasForWithDuplicateAttributeDeclaration.class.getName())).     exception.expectMessage(containsString("attribute 'attribute' and its alias 'value' are present with values of [baz] and [bar]")).     synthesizeAnnotation(annotation). }
false;public;0;9;;@Test public void synthesizeAnnotationWithAttributeAliasForNonexistentAttribute() throws Exception {     AliasForNonexistentAttribute annotation = AliasForNonexistentAttributeClass.class.getAnnotation(AliasForNonexistentAttribute.class).     exception.expect(AnnotationConfigurationException.class).     exception.expectMessage(startsWith("Attribute 'foo' in")).     exception.expectMessage(containsString(AliasForNonexistentAttribute.class.getName())).     exception.expectMessage(containsString("is declared as an @AliasFor nonexistent attribute 'bar'")).     synthesizeAnnotation(annotation). }
false;public;0;10;;@Test public void synthesizeAnnotationWithAttributeAliasWithoutMirroredAliasFor() throws Exception {     AliasForWithoutMirroredAliasFor annotation = AliasForWithoutMirroredAliasForClass.class.getAnnotation(AliasForWithoutMirroredAliasFor.class).     exception.expect(AnnotationConfigurationException.class).     exception.expectMessage(startsWith("Attribute 'bar' in")).     exception.expectMessage(containsString(AliasForWithoutMirroredAliasFor.class.getName())).     exception.expectMessage(containsString("@AliasFor [foo]")).     synthesizeAnnotation(annotation). }
false;public;0;11;;@Test public void synthesizeAnnotationWithAttributeAliasWithMirroredAliasForWrongAttribute() throws Exception {     AliasForWithMirroredAliasForWrongAttribute annotation = AliasForWithMirroredAliasForWrongAttributeClass.class.getAnnotation(AliasForWithMirroredAliasForWrongAttribute.class).     exception.expect(AnnotationConfigurationException.class).     exception.expectMessage(startsWith("Attribute 'bar' in")).     exception.expectMessage(containsString(AliasForWithMirroredAliasForWrongAttribute.class.getName())).     exception.expectMessage(either(containsString("must be declared as an @AliasFor [foo], not [quux]")).or(containsString("is declared as an @AliasFor nonexistent attribute 'quux'"))).     synthesizeAnnotation(annotation). }
false;public;0;12;;@Test public void synthesizeAnnotationWithAttributeAliasForAttributeOfDifferentType() throws Exception {     AliasForAttributeOfDifferentType annotation = AliasForAttributeOfDifferentTypeClass.class.getAnnotation(AliasForAttributeOfDifferentType.class).     exception.expect(AnnotationConfigurationException.class).     exception.expectMessage(startsWith("Misconfigured aliases")).     exception.expectMessage(containsString(AliasForAttributeOfDifferentType.class.getName())).     exception.expectMessage(containsString("attribute 'foo'")).     exception.expectMessage(containsString("attribute 'bar'")).     exception.expectMessage(containsString("same return type")).     synthesizeAnnotation(annotation). }
false;public;0;12;;@Test public void synthesizeAnnotationWithAttributeAliasForWithMissingDefaultValues() throws Exception {     AliasForWithMissingDefaultValues annotation = AliasForWithMissingDefaultValuesClass.class.getAnnotation(AliasForWithMissingDefaultValues.class).     exception.expect(AnnotationConfigurationException.class).     exception.expectMessage(startsWith("Misconfigured aliases")).     exception.expectMessage(containsString(AliasForWithMissingDefaultValues.class.getName())).     exception.expectMessage(containsString("attribute 'foo' in annotation")).     exception.expectMessage(containsString("attribute 'bar' in annotation")).     exception.expectMessage(containsString("default values")).     synthesizeAnnotation(annotation). }
false;public;0;12;;@Test public void synthesizeAnnotationWithAttributeAliasForAttributeWithDifferentDefaultValue() throws Exception {     AliasForAttributeWithDifferentDefaultValue annotation = AliasForAttributeWithDifferentDefaultValueClass.class.getAnnotation(AliasForAttributeWithDifferentDefaultValue.class).     exception.expect(AnnotationConfigurationException.class).     exception.expectMessage(startsWith("Misconfigured aliases")).     exception.expectMessage(containsString(AliasForAttributeWithDifferentDefaultValue.class.getName())).     exception.expectMessage(containsString("attribute 'foo' in annotation")).     exception.expectMessage(containsString("attribute 'bar' in annotation")).     exception.expectMessage(containsString("same default value")).     synthesizeAnnotation(annotation). }
false;public;0;12;;@Test public void synthesizeAnnotationWithAttributeAliasForMetaAnnotationThatIsNotMetaPresent() throws Exception {     AliasedComposedContextConfigNotMetaPresent annotation = AliasedComposedContextConfigNotMetaPresentClass.class.getAnnotation(AliasedComposedContextConfigNotMetaPresent.class).     exception.expect(AnnotationConfigurationException.class).     exception.expectMessage(startsWith("@AliasFor declaration on attribute 'xmlConfigFile' in annotation")).     exception.expectMessage(containsString(AliasedComposedContextConfigNotMetaPresent.class.getName())).     exception.expectMessage(containsString("declares an alias for attribute 'location' in meta-annotation")).     exception.expectMessage(containsString(ContextConfig.class.getName())).     exception.expectMessage(containsString("not meta-present")).     synthesizeAnnotation(annotation). }
false;public;0;22;;@Test public void synthesizeAnnotationWithAttributeAliases() throws Exception {     Method method = WebController.class.getMethod("handleMappedWithValueAttribute").     WebMapping webMapping = method.getAnnotation(WebMapping.class).     assertNotNull(webMapping).     WebMapping synthesizedWebMapping1 = synthesizeAnnotation(webMapping).     assertThat(synthesizedWebMapping1, instanceOf(SynthesizedAnnotation.class)).     assertNotSame(webMapping, synthesizedWebMapping1).     assertEquals("name attribute: ", "foo", synthesizedWebMapping1.name()).     assertArrayEquals("aliased path attribute: ", asArray("/test"), synthesizedWebMapping1.path()).     assertArrayEquals("actual value attribute: ", asArray("/test"), synthesizedWebMapping1.value()).     WebMapping synthesizedWebMapping2 = synthesizeAnnotation(webMapping).     assertThat(synthesizedWebMapping2, instanceOf(SynthesizedAnnotation.class)).     assertNotSame(webMapping, synthesizedWebMapping2).     assertEquals("name attribute: ", "foo", synthesizedWebMapping2.name()).     assertArrayEquals("aliased path attribute: ", asArray("/test"), synthesizedWebMapping2.path()).     assertArrayEquals("actual value attribute: ", asArray("/test"), synthesizedWebMapping2.value()). }
false;public;0;7;;@Test public void synthesizeAnnotationWithImplicitAliases() throws Exception {     assertAnnotationSynthesisWithImplicitAliases(ValueImplicitAliasesContextConfigClass.class, "value").     assertAnnotationSynthesisWithImplicitAliases(Location1ImplicitAliasesContextConfigClass.class, "location1").     assertAnnotationSynthesisWithImplicitAliases(XmlImplicitAliasesContextConfigClass.class, "xmlFile").     assertAnnotationSynthesisWithImplicitAliases(GroovyImplicitAliasesContextConfigClass.class, "groovyScript"). }
false;private;2;12;;private void assertAnnotationSynthesisWithImplicitAliases(Class<?> clazz, String expected) throws Exception {     ImplicitAliasesContextConfig config = clazz.getAnnotation(ImplicitAliasesContextConfig.class).     assertNotNull(config).     ImplicitAliasesContextConfig synthesizedConfig = synthesizeAnnotation(config).     assertThat(synthesizedConfig, instanceOf(SynthesizedAnnotation.class)).     assertEquals("value: ", expected, synthesizedConfig.value()).     assertEquals("location1: ", expected, synthesizedConfig.location1()).     assertEquals("xmlFile: ", expected, synthesizedConfig.xmlFile()).     assertEquals("groovyScript: ", expected, synthesizedConfig.groovyScript()). }
false;public;0;9;;@Test public void synthesizeAnnotationWithImplicitAliasesWithImpliedAliasNamesOmitted() throws Exception {     assertAnnotationSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(ValueImplicitAliasesWithImpliedAliasNamesOmittedContextConfigClass.class, "value").     assertAnnotationSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(LocationsImplicitAliasesWithImpliedAliasNamesOmittedContextConfigClass.class, "location").     assertAnnotationSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(XmlFilesImplicitAliasesWithImpliedAliasNamesOmittedContextConfigClass.class, "xmlFile"). }
false;private;2;14;;private void assertAnnotationSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(Class<?> clazz, String expected) {     ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig config = clazz.getAnnotation(ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig.class).     assertNotNull(config).     ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig synthesizedConfig = synthesizeAnnotation(config).     assertThat(synthesizedConfig, instanceOf(SynthesizedAnnotation.class)).     assertEquals("value: ", expected, synthesizedConfig.value()).     assertEquals("locations: ", expected, synthesizedConfig.location()).     assertEquals("xmlFiles: ", expected, synthesizedConfig.xmlFile()). }
false;public;0;12;;@Test public void synthesizeAnnotationWithImplicitAliasesForAliasPair() throws Exception {     Class<?> clazz = ImplicitAliasesForAliasPairContextConfigClass.class.     ImplicitAliasesForAliasPairContextConfig config = clazz.getAnnotation(ImplicitAliasesForAliasPairContextConfig.class).     assertNotNull(config).     ImplicitAliasesForAliasPairContextConfig synthesizedConfig = synthesizeAnnotation(config).     assertThat(synthesizedConfig, instanceOf(SynthesizedAnnotation.class)).     assertEquals("xmlFile: ", "test.xml", synthesizedConfig.xmlFile()).     assertEquals("groovyScript: ", "test.xml", synthesizedConfig.groovyScript()). }
false;public;0;12;;@Test public void synthesizeAnnotationWithTransitiveImplicitAliases() throws Exception {     Class<?> clazz = TransitiveImplicitAliasesContextConfigClass.class.     TransitiveImplicitAliasesContextConfig config = clazz.getAnnotation(TransitiveImplicitAliasesContextConfig.class).     assertNotNull(config).     TransitiveImplicitAliasesContextConfig synthesizedConfig = synthesizeAnnotation(config).     assertThat(synthesizedConfig, instanceOf(SynthesizedAnnotation.class)).     assertEquals("xml: ", "test.xml", synthesizedConfig.xml()).     assertEquals("groovy: ", "test.xml", synthesizedConfig.groovy()). }
false;public;0;12;;@Test public void synthesizeAnnotationWithTransitiveImplicitAliasesForAliasPair() throws Exception {     Class<?> clazz = TransitiveImplicitAliasesForAliasPairContextConfigClass.class.     TransitiveImplicitAliasesForAliasPairContextConfig config = clazz.getAnnotation(TransitiveImplicitAliasesForAliasPairContextConfig.class).     assertNotNull(config).     TransitiveImplicitAliasesForAliasPairContextConfig synthesizedConfig = synthesizeAnnotation(config).     assertThat(synthesizedConfig, instanceOf(SynthesizedAnnotation.class)).     assertEquals("xml: ", "test.xml", synthesizedConfig.xml()).     assertEquals("groovy: ", "test.xml", synthesizedConfig.groovy()). }
false;public;0;15;;@Test public void synthesizeAnnotationWithImplicitAliasesWithMissingDefaultValues() throws Exception {     Class<?> clazz = ImplicitAliasesWithMissingDefaultValuesContextConfigClass.class.     Class<ImplicitAliasesWithMissingDefaultValuesContextConfig> annotationType = ImplicitAliasesWithMissingDefaultValuesContextConfig.class.     ImplicitAliasesWithMissingDefaultValuesContextConfig config = clazz.getAnnotation(annotationType).     assertNotNull(config).     exception.expect(AnnotationConfigurationException.class).     exception.expectMessage(startsWith("Misconfigured aliases:")).     exception.expectMessage(containsString("attribute 'location1' in annotation [" + annotationType.getName() + "]")).     exception.expectMessage(containsString("attribute 'location2' in annotation [" + annotationType.getName() + "]")).     exception.expectMessage(containsString("default values")).     synthesizeAnnotation(config, clazz). }
false;public;0;15;;@Test public void synthesizeAnnotationWithImplicitAliasesWithDifferentDefaultValues() throws Exception {     Class<?> clazz = ImplicitAliasesWithDifferentDefaultValuesContextConfigClass.class.     Class<ImplicitAliasesWithDifferentDefaultValuesContextConfig> annotationType = ImplicitAliasesWithDifferentDefaultValuesContextConfig.class.     ImplicitAliasesWithDifferentDefaultValuesContextConfig config = clazz.getAnnotation(annotationType).     assertNotNull(config).     exception.expect(AnnotationConfigurationException.class).     exception.expectMessage(startsWith("Misconfigured aliases:")).     exception.expectMessage(containsString("attribute 'location1' in annotation [" + annotationType.getName() + "]")).     exception.expectMessage(containsString("attribute 'location2' in annotation [" + annotationType.getName() + "]")).     exception.expectMessage(containsString("same default value")).     synthesizeAnnotation(config, clazz). }
false;public;0;23;;@Test public void synthesizeAnnotationWithImplicitAliasesWithDuplicateValues() throws Exception {     Class<?> clazz = ImplicitAliasesWithDuplicateValuesContextConfigClass.class.     Class<ImplicitAliasesWithDuplicateValuesContextConfig> annotationType = ImplicitAliasesWithDuplicateValuesContextConfig.class.     ImplicitAliasesWithDuplicateValuesContextConfig config = clazz.getAnnotation(annotationType).     assertNotNull(config).     ImplicitAliasesWithDuplicateValuesContextConfig synthesizedConfig = synthesizeAnnotation(config, clazz).     assertNotNull(synthesizedConfig).     exception.expect(AnnotationConfigurationException.class).     exception.expectMessage(startsWith("In annotation")).     exception.expectMessage(containsString(annotationType.getName())).     exception.expectMessage(containsString("declared on class")).     exception.expectMessage(containsString(clazz.getName())).     exception.expectMessage(containsString("and synthesized from")).     exception.expectMessage(either(containsString("attribute 'location1' and its alias 'location2'")).or(containsString("attribute 'location2' and its alias 'location1'"))).     exception.expectMessage(either(containsString("are present with values of [1] and [2]")).or(containsString("are present with values of [2] and [1]"))).     synthesizedConfig.location1(). }
false;public;0;13;;@Test public void synthesizeAnnotationFromMapWithoutAttributeAliases() throws Exception {     Component component = WebController.class.getAnnotation(Component.class).     assertNotNull(component).     Map<String, Object> map = Collections.singletonMap(VALUE, "webController").     Component synthesizedComponent = synthesizeAnnotation(map, Component.class, WebController.class).     assertNotNull(synthesizedComponent).     assertNotSame(component, synthesizedComponent).     assertEquals("value from component: ", "webController", component.value()).     assertEquals("value from synthesized component: ", "webController", synthesizedComponent.value()). }
false;public;0;27;;@Test @SuppressWarnings("unchecked") public void synthesizeAnnotationFromMapWithNestedMap() throws Exception {     ComponentScanSingleFilter componentScan = ComponentScanSingleFilterClass.class.getAnnotation(ComponentScanSingleFilter.class).     assertNotNull(componentScan).     assertEquals("value from ComponentScan: ", "*Foo", componentScan.value().pattern()).     AnnotationAttributes attributes = getAnnotationAttributes(ComponentScanSingleFilterClass.class, componentScan, false, true).     assertNotNull(attributes).     assertEquals(ComponentScanSingleFilter.class, attributes.annotationType()).     Map<String, Object> filterMap = (Map<String, Object>) attributes.get("value").     assertNotNull(filterMap).     assertEquals("*Foo", filterMap.get("pattern")).     // Modify nested map     filterMap.put("pattern", "newFoo").     filterMap.put("enigma", 42).     ComponentScanSingleFilter synthesizedComponentScan = synthesizeAnnotation(attributes, ComponentScanSingleFilter.class, ComponentScanSingleFilterClass.class).     assertNotNull(synthesizedComponentScan).     assertNotSame(componentScan, synthesizedComponentScan).     assertEquals("value from synthesized ComponentScan: ", "newFoo", synthesizedComponentScan.value().pattern()). }
false;public;0;29;;@Test @SuppressWarnings("unchecked") public void synthesizeAnnotationFromMapWithNestedArrayOfMaps() throws Exception {     ComponentScan componentScan = ComponentScanClass.class.getAnnotation(ComponentScan.class).     assertNotNull(componentScan).     AnnotationAttributes attributes = getAnnotationAttributes(ComponentScanClass.class, componentScan, false, true).     assertNotNull(attributes).     assertEquals(ComponentScan.class, attributes.annotationType()).     Map<String, Object>[] filters = (Map[]) attributes.get("excludeFilters").     assertNotNull(filters).     List<String> patterns = stream(filters).map(m -> (String) m.get("pattern")).collect(toList()).     assertEquals(asList("*Foo", "*Bar"), patterns).     // Modify nested maps     filters[0].put("pattern", "newFoo").     filters[0].put("enigma", 42).     filters[1].put("pattern", "newBar").     filters[1].put("enigma", 42).     ComponentScan synthesizedComponentScan = synthesizeAnnotation(attributes, ComponentScan.class, ComponentScanClass.class).     assertNotNull(synthesizedComponentScan).     assertNotSame(componentScan, synthesizedComponentScan).     patterns = stream(synthesizedComponentScan.excludeFilters()).map(Filter::pattern).collect(toList()).     assertEquals(asList("newFoo", "newBar"), patterns). }
false;public;0;8;;@Test public void synthesizeAnnotationFromDefaultsWithoutAttributeAliases() throws Exception {     AnnotationWithDefaults annotationWithDefaults = synthesizeAnnotation(AnnotationWithDefaults.class).     assertNotNull(annotationWithDefaults).     assertEquals("text: ", "enigma", annotationWithDefaults.text()).     assertTrue("predicate: ", annotationWithDefaults.predicate()).     assertArrayEquals("characters: ", new char[] { 'a', 'b', 'c' }, annotationWithDefaults.characters()). }
false;public;0;7;;@Test public void synthesizeAnnotationFromDefaultsWithAttributeAliases() throws Exception {     ContextConfig contextConfig = synthesizeAnnotation(ContextConfig.class).     assertNotNull(contextConfig).     assertEquals("value: ", "", contextConfig.value()).     assertEquals("location: ", "", contextConfig.location()). }
false;public;0;6;;@Test public void synthesizeAnnotationWithAttributeAliasesWithDifferentValues() throws Exception {     ContextConfig contextConfig = synthesizeAnnotation(ContextConfigMismatch.class.getAnnotation(ContextConfig.class)).     exception.expect(AnnotationConfigurationException.class).     getValue(contextConfig). }
false;public;0;8;;@Test public void synthesizeAnnotationFromMapWithMinimalAttributesWithAttributeAliases() throws Exception {     Map<String, Object> map = Collections.singletonMap("location", "test.xml").     ContextConfig contextConfig = synthesizeAnnotation(map, ContextConfig.class, null).     assertNotNull(contextConfig).     assertEquals("value: ", "test.xml", contextConfig.value()).     assertEquals("location: ", "test.xml", contextConfig.location()). }
false;public;0;14;;@Test public void synthesizeAnnotationFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements() throws Exception {     Map<String, Object> map = Collections.singletonMap("value", "/foo").     Get get = synthesizeAnnotation(map, Get.class, null).     assertNotNull(get).     assertEquals("value: ", "/foo", get.value()).     assertEquals("path: ", "/foo", get.path()).     map = Collections.singletonMap("path", "/foo").     get = synthesizeAnnotation(map, Get.class, null).     assertNotNull(get).     assertEquals("value: ", "/foo", get.value()).     assertEquals("path: ", "/foo", get.path()). }
false;public;0;9;;@Test public void synthesizeAnnotationFromMapWithImplicitAttributeAliases() throws Exception {     assertAnnotationSynthesisFromMapWithImplicitAliases("value").     assertAnnotationSynthesisFromMapWithImplicitAliases("location1").     assertAnnotationSynthesisFromMapWithImplicitAliases("location2").     assertAnnotationSynthesisFromMapWithImplicitAliases("location3").     assertAnnotationSynthesisFromMapWithImplicitAliases("xmlFile").     assertAnnotationSynthesisFromMapWithImplicitAliases("groovyScript"). }
false;private;1;11;;private void assertAnnotationSynthesisFromMapWithImplicitAliases(String attributeNameAndValue) throws Exception {     Map<String, Object> map = Collections.singletonMap(attributeNameAndValue, attributeNameAndValue).     ImplicitAliasesContextConfig config = synthesizeAnnotation(map, ImplicitAliasesContextConfig.class, null).     assertNotNull(config).     assertEquals("value: ", attributeNameAndValue, config.value()).     assertEquals("location1: ", attributeNameAndValue, config.location1()).     assertEquals("location2: ", attributeNameAndValue, config.location2()).     assertEquals("location3: ", attributeNameAndValue, config.location3()).     assertEquals("xmlFile: ", attributeNameAndValue, config.xmlFile()).     assertEquals("groovyScript: ", attributeNameAndValue, config.groovyScript()). }
false;public;0;4;;@Test public void synthesizeAnnotationFromMapWithMissingAttributeValue() throws Exception {     assertMissingTextAttribute(Collections.emptyMap()). }
false;public;0;6;;@Test public void synthesizeAnnotationFromMapWithNullAttributeValue() throws Exception {     Map<String, Object> map = Collections.singletonMap("text", null).     assertTrue(map.containsKey("text")).     assertMissingTextAttribute(map). }
false;private;1;7;;private void assertMissingTextAttribute(Map<String, Object> attributes) {     exception.expect(IllegalArgumentException.class).     exception.expectMessage(startsWith("Attributes map")).     exception.expectMessage(containsString("returned null for required attribute 'text'")).     exception.expectMessage(containsString("defined by annotation type [" + AnnotationWithoutDefaults.class.getName() + "]")).     synthesizeAnnotation(attributes, AnnotationWithoutDefaults.class, null). }
false;public;0;13;;@Test public void synthesizeAnnotationFromMapWithAttributeOfIncorrectType() throws Exception {     Map<String, Object> map = Collections.singletonMap(VALUE, 42L).     exception.expect(IllegalArgumentException.class).     exception.expectMessage(startsWith("Attributes map")).     exception.expectMessage(containsString("returned a value of type [java.lang.Long]")).     exception.expectMessage(containsString("for attribute 'value'")).     exception.expectMessage(containsString("but a value of type [java.lang.String] is required")).     exception.expectMessage(containsString("as defined by annotation type [" + Component.class.getName() + "]")).     synthesizeAnnotation(map, Component.class, null). }
false;public;0;20;;@Test public void synthesizeAnnotationFromAnnotationAttributesWithoutAttributeAliases() throws Exception {     // 1) Get an annotation     Component component = WebController.class.getAnnotation(Component.class).     assertNotNull(component).     // 2) Convert the annotation into AnnotationAttributes     AnnotationAttributes attributes = getAnnotationAttributes(WebController.class, component).     assertNotNull(attributes).     // 3) Synthesize the AnnotationAttributes back into an annotation     Component synthesizedComponent = synthesizeAnnotation(attributes, Component.class, WebController.class).     assertNotNull(synthesizedComponent).     // 4) Verify that the original and synthesized annotations are equivalent     assertNotSame(component, synthesizedComponent).     assertEquals(component, synthesizedComponent).     assertEquals("value from component: ", "webController", component.value()).     assertEquals("value from synthesized component: ", "webController", synthesizedComponent.value()). }
false;public;0;19;;@Test public void toStringForSynthesizedAnnotations() throws Exception {     Method methodWithPath = WebController.class.getMethod("handleMappedWithPathAttribute").     WebMapping webMappingWithAliases = methodWithPath.getAnnotation(WebMapping.class).     assertNotNull(webMappingWithAliases).     Method methodWithPathAndValue = WebController.class.getMethod("handleMappedWithSamePathAndValueAttributes").     WebMapping webMappingWithPathAndValue = methodWithPathAndValue.getAnnotation(WebMapping.class).     assertNotNull(webMappingWithPathAndValue).     WebMapping synthesizedWebMapping1 = synthesizeAnnotation(webMappingWithAliases).     assertNotNull(synthesizedWebMapping1).     WebMapping synthesizedWebMapping2 = synthesizeAnnotation(webMappingWithAliases).     assertNotNull(synthesizedWebMapping2).     assertThat(webMappingWithAliases.toString(), is(not(synthesizedWebMapping1.toString()))).     assertToStringForWebMappingWithPathAndValue(synthesizedWebMapping1).     assertToStringForWebMappingWithPathAndValue(synthesizedWebMapping2). }
false;private;1;10;;private void assertToStringForWebMappingWithPathAndValue(WebMapping webMapping) {     String string = webMapping.toString().     assertThat(string, startsWith("@" + WebMapping.class.getName() + "(")).     assertThat(string, containsString("value=[/test]")).     assertThat(string, containsString("path=[/test]")).     assertThat(string, containsString("name=bar")).     assertThat(string, containsString("method=")).     assertThat(string, containsString("[GET, POST]")).     assertThat(string, endsWith(")")). }
false;public;0;37;;@Test public void equalsForSynthesizedAnnotations() throws Exception {     Method methodWithPath = WebController.class.getMethod("handleMappedWithPathAttribute").     WebMapping webMappingWithAliases = methodWithPath.getAnnotation(WebMapping.class).     assertNotNull(webMappingWithAliases).     Method methodWithPathAndValue = WebController.class.getMethod("handleMappedWithSamePathAndValueAttributes").     WebMapping webMappingWithPathAndValue = methodWithPathAndValue.getAnnotation(WebMapping.class).     assertNotNull(webMappingWithPathAndValue).     WebMapping synthesizedWebMapping1 = synthesizeAnnotation(webMappingWithAliases).     assertNotNull(synthesizedWebMapping1).     WebMapping synthesizedWebMapping2 = synthesizeAnnotation(webMappingWithAliases).     assertNotNull(synthesizedWebMapping2).     // Equality amongst standard annotations     assertThat(webMappingWithAliases, is(webMappingWithAliases)).     assertThat(webMappingWithPathAndValue, is(webMappingWithPathAndValue)).     // Inequality amongst standard annotations     assertThat(webMappingWithAliases, is(not(webMappingWithPathAndValue))).     assertThat(webMappingWithPathAndValue, is(not(webMappingWithAliases))).     // Equality amongst synthesized annotations     assertThat(synthesizedWebMapping1, is(synthesizedWebMapping1)).     assertThat(synthesizedWebMapping2, is(synthesizedWebMapping2)).     assertThat(synthesizedWebMapping1, is(synthesizedWebMapping2)).     assertThat(synthesizedWebMapping2, is(synthesizedWebMapping1)).     // Equality between standard and synthesized annotations     assertThat(synthesizedWebMapping1, is(webMappingWithPathAndValue)).     assertThat(webMappingWithPathAndValue, is(synthesizedWebMapping1)).     // Inequality between standard and synthesized annotations     assertThat(synthesizedWebMapping1, is(not(webMappingWithAliases))).     assertThat(webMappingWithAliases, is(not(synthesizedWebMapping1))). }
false;public;0;37;;@Test public void hashCodeForSynthesizedAnnotations() throws Exception {     Method methodWithPath = WebController.class.getMethod("handleMappedWithPathAttribute").     WebMapping webMappingWithAliases = methodWithPath.getAnnotation(WebMapping.class).     assertNotNull(webMappingWithAliases).     Method methodWithPathAndValue = WebController.class.getMethod("handleMappedWithSamePathAndValueAttributes").     WebMapping webMappingWithPathAndValue = methodWithPathAndValue.getAnnotation(WebMapping.class).     assertNotNull(webMappingWithPathAndValue).     WebMapping synthesizedWebMapping1 = synthesizeAnnotation(webMappingWithAliases).     assertNotNull(synthesizedWebMapping1).     WebMapping synthesizedWebMapping2 = synthesizeAnnotation(webMappingWithAliases).     assertNotNull(synthesizedWebMapping2).     // Equality amongst standard annotations     assertThat(webMappingWithAliases.hashCode(), is(webMappingWithAliases.hashCode())).     assertThat(webMappingWithPathAndValue.hashCode(), is(webMappingWithPathAndValue.hashCode())).     // Inequality amongst standard annotations     assertThat(webMappingWithAliases.hashCode(), is(not(webMappingWithPathAndValue.hashCode()))).     assertThat(webMappingWithPathAndValue.hashCode(), is(not(webMappingWithAliases.hashCode()))).     // Equality amongst synthesized annotations     assertThat(synthesizedWebMapping1.hashCode(), is(synthesizedWebMapping1.hashCode())).     assertThat(synthesizedWebMapping2.hashCode(), is(synthesizedWebMapping2.hashCode())).     assertThat(synthesizedWebMapping1.hashCode(), is(synthesizedWebMapping2.hashCode())).     assertThat(synthesizedWebMapping2.hashCode(), is(synthesizedWebMapping1.hashCode())).     // Equality between standard and synthesized annotations     assertThat(synthesizedWebMapping1.hashCode(), is(webMappingWithPathAndValue.hashCode())).     assertThat(webMappingWithPathAndValue.hashCode(), is(synthesizedWebMapping1.hashCode())).     // Inequality between standard and synthesized annotations     assertThat(synthesizedWebMapping1.hashCode(), is(not(webMappingWithAliases.hashCode()))).     assertThat(webMappingWithAliases.hashCode(), is(not(synthesizedWebMapping1.hashCode()))). }
true;public;0;18;/**  * Fully reflection-based test that verifies support for  * {@linkplain AnnotationUtils#synthesizeAnnotation synthesizing annotations}  * across packages with non-public visibility of user types (e.g., a non-public  * annotation that uses {@code @AliasFor}).  */ ;/**  * Fully reflection-based test that verifies support for  * {@linkplain AnnotationUtils#synthesizeAnnotation synthesizing annotations}  * across packages with non-public visibility of user types (e.g., a non-public  * annotation that uses {@code @AliasFor}).  */ @Test @SuppressWarnings("unchecked") public void synthesizeNonPublicAnnotationWithAttributeAliasesFromDifferentPackage() throws Exception {     Class<?> clazz = ClassUtils.forName("org.springframework.core.annotation.subpackage.NonPublicAliasedAnnotatedClass", null).     Class<? extends Annotation> annotationType = (Class<? extends Annotation>) ClassUtils.forName("org.springframework.core.annotation.subpackage.NonPublicAliasedAnnotation", null).     Annotation annotation = clazz.getAnnotation(annotationType).     assertNotNull(annotation).     Annotation synthesizedAnnotation = synthesizeAnnotation(annotation).     assertNotSame(annotation, synthesizedAnnotation).     assertNotNull(synthesizedAnnotation).     assertEquals("name attribute: ", "test", getValue(synthesizedAnnotation, "name")).     assertEquals("aliased path attribute: ", "/test", getValue(synthesizedAnnotation, "path")).     assertEquals("aliased path attribute: ", "/test", getValue(synthesizedAnnotation, "value")). }
false;public;0;21;;@Test public void synthesizeAnnotationWithAttributeAliasesInNestedAnnotations() throws Exception {     List<String> expectedLocations = asList("A", "B").     Hierarchy hierarchy = ConfigHierarchyTestCase.class.getAnnotation(Hierarchy.class).     assertNotNull(hierarchy).     Hierarchy synthesizedHierarchy = synthesizeAnnotation(hierarchy).     assertNotSame(hierarchy, synthesizedHierarchy).     assertThat(synthesizedHierarchy, instanceOf(SynthesizedAnnotation.class)).     ContextConfig[] configs = synthesizedHierarchy.value().     assertNotNull(configs).     assertTrue("nested annotations must be synthesized", stream(configs).allMatch(c -> c instanceof SynthesizedAnnotation)).     List<String> locations = stream(configs).map(ContextConfig::location).collect(toList()).     assertThat(locations, is(expectedLocations)).     List<String> values = stream(configs).map(ContextConfig::value).collect(toList()).     assertThat(values, is(expectedLocations)). }
false;public;0;24;;@Test public void synthesizeAnnotationWithArrayOfAnnotations() throws Exception {     List<String> expectedLocations = asList("A", "B").     Hierarchy hierarchy = ConfigHierarchyTestCase.class.getAnnotation(Hierarchy.class).     assertNotNull(hierarchy).     Hierarchy synthesizedHierarchy = synthesizeAnnotation(hierarchy).     assertThat(synthesizedHierarchy, instanceOf(SynthesizedAnnotation.class)).     ContextConfig contextConfig = SimpleConfigTestCase.class.getAnnotation(ContextConfig.class).     assertNotNull(contextConfig).     ContextConfig[] configs = synthesizedHierarchy.value().     List<String> locations = stream(configs).map(ContextConfig::location).collect(toList()).     assertThat(locations, is(expectedLocations)).     // Alter array returned from synthesized annotation     configs[0] = contextConfig.     // Re-retrieve the array from the synthesized annotation     configs = synthesizedHierarchy.value().     List<String> values = stream(configs).map(ContextConfig::value).collect(toList()).     assertThat(values, is(expectedLocations)). }
false;public;0;17;;@Test public void synthesizeAnnotationWithArrayOfChars() throws Exception {     CharsContainer charsContainer = GroupOfCharsClass.class.getAnnotation(CharsContainer.class).     assertNotNull(charsContainer).     CharsContainer synthesizedCharsContainer = synthesizeAnnotation(charsContainer).     assertThat(synthesizedCharsContainer, instanceOf(SynthesizedAnnotation.class)).     char[] chars = synthesizedCharsContainer.chars().     assertArrayEquals(new char[] { 'x', 'y', 'z' }, chars).     // Alter array returned from synthesized annotation     chars[0] = '?'.     // Re-retrieve the array from the synthesized annotation     chars = synthesizedCharsContainer.chars().     assertArrayEquals(new char[] { 'x', 'y', 'z' }, chars). }
false;public;0;6;;@Test public void interfaceWithAnnotatedMethods() {     assertTrue(AnnotationUtils.getAnnotatedMethodsInBaseType(NonAnnotatedInterface.class).isEmpty()).     assertFalse(AnnotationUtils.getAnnotatedMethodsInBaseType(AnnotatedInterface.class).isEmpty()).     assertTrue(AnnotationUtils.getAnnotatedMethodsInBaseType(NullableAnnotatedInterface.class).isEmpty()). }
false;static;1;4;;@SafeVarargs static <T> T[] asArray(T... arr) {     return arr. }
false;;0;2;;@Order(0) void fromInterfaceImplementedByRoot().
false;;0;2;;@Nullable void fromInterfaceImplementedByRoot().
false;public;0;3;;@Order(27) public void annotatedOnRoot() { }
false;public;0;3;;@Meta1 public void metaAnnotatedOnRoot() { }
false;public;0;2;;public void overrideToAnnotate() { }
false;public;0;3;;@Order(27) public void overrideWithoutNewAnnotation() { }
false;public;0;2;;public void notAnnotated() { }
false;public;0;3;;@Override public void fromInterfaceImplementedByRoot() { }
false;public;0;3;;@Order(25) public void annotatedOnLeaf() { }
false;public;0;3;;@Meta1 public void metaAnnotatedOnLeaf() { }
false;public;0;3;;@MetaMeta public void metaMetaAnnotatedOnLeaf() { }
false;public;0;4;;@Override @Order(1) public void overrideToAnnotate() { }
false;public;0;3;;@Override public void overrideWithoutNewAnnotation() { }
false;public,abstract;1;2;;@Order(1) public abstract void something(T arg).
false;public;1;4;;@Override @Transactional public void something(final String arg) { }
false;;0;2;;@Order void foo().
false;public;0;3;;@Override public void foo() { }
false;public;0;3;;@Override public void foo() { }
false;public;0;3;;@Override public void foo() { }
false;;1;2;;@Order void foo(T t).
false;public;1;2;;public void foo(String t) { }
false;abstract;1;2;;@Order abstract void foo(T t).
false;public;1;2;;public void foo(String t) { }
false;;0;4;;@MyRepeatable("A") @MyRepeatableContainer({ @MyRepeatable("B"), @MyRepeatable("C") }) @MyRepeatableMeta1 void foo().
false;public;0;3;;@WebMapping(value = "/test", name = "foo") public void handleMappedWithValueAttribute() { }
false;public;0;3;;@WebMapping(path = "/test", name = "bar", method = { RequestMethod.GET, RequestMethod.POST }) public void handleMappedWithPathAttribute() { }
false;public;0;3;;@Get("/test") public void getMappedWithValueAttribute() { }
false;public;0;3;;@Get(path = "/test") public void getMappedWithPathAttribute() { }
false;public;0;3;;@Post(path = "/test") public void postMappedWithPathAttribute() { }
true;public;0;3;/**  * mapping is logically "equal" to handleMappedWithPathAttribute().  */ ;/**  * mapping is logically "equal" to handleMappedWithPathAttribute().  */ @WebMapping(value = "/test", path = "/test", name = "bar", method = { RequestMethod.GET, RequestMethod.POST }) public void handleMappedWithSamePathAndValueAttributes() { }
false;public;0;3;;@WebMapping(value = "/enigma", path = "/test", name = "baz") public void handleMappedWithDifferentPathAndValueAttributes() { }
