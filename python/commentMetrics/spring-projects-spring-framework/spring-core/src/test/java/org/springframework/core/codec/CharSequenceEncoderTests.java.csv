commented;modifiers;parameterAmount;loc;comment;code
false;public;0;16;;@Override public void canEncode() throws Exception {     assertTrue(this.encoder.canEncode(ResolvableType.forClass(String.class), MimeTypeUtils.TEXT_PLAIN)).     assertTrue(this.encoder.canEncode(ResolvableType.forClass(StringBuilder.class), MimeTypeUtils.TEXT_PLAIN)).     assertTrue(this.encoder.canEncode(ResolvableType.forClass(StringBuffer.class), MimeTypeUtils.TEXT_PLAIN)).     assertFalse(this.encoder.canEncode(ResolvableType.forClass(Integer.class), MimeTypeUtils.TEXT_PLAIN)).     assertFalse(this.encoder.canEncode(ResolvableType.forClass(String.class), MimeTypeUtils.APPLICATION_JSON)).     // SPR-15464     assertFalse(this.encoder.canEncode(ResolvableType.NONE, null)). }
false;public;0;9;;@Override public void encode() {     Flux<CharSequence> input = Flux.just(this.foo, this.bar).     testEncodeAll(input, CharSequence.class, step -> step.consumeNextWith(expectString(this.foo)).consumeNextWith(expectString(this.bar)).verifyComplete()). }
false;public;0;12;;@Test public void calculateCapacity() {     String sequence = "Hello World!".     Stream.of(UTF_8, UTF_16, ISO_8859_1, US_ASCII, Charset.forName("BIG5")).forEach(charset -> {         int capacity = this.encoder.calculateCapacity(sequence, charset).         int length = sequence.length().         assertTrue(String.format("%s has capacity %d. length %d", charset, capacity, length), capacity >= length).     }). }
