commented;modifiers;parameterAmount;loc;comment;code
true;public;0;17;/**  * The test demonstrates that the generics-based API for  * {@link CollectionFactory#createApproximateCollection(Object, int)}  * is not type-safe.  * <p>Specifically, the parameterized type {@code E} is not bound to  * the type of elements contained in the {@code collection} argument  * passed to {@code createApproximateCollection()}. Thus casting the  * value returned by {@link EnumSet#copyOf(EnumSet)} to  * {@code (Collection<E>)} cannot guarantee that the returned collection  * actually contains elements of type {@code E}.  */ ;/**  * The test demonstrates that the generics-based API for  * {@link CollectionFactory#createApproximateCollection(Object, int)}  * is not type-safe.  * <p>Specifically, the parameterized type {@code E} is not bound to  * the type of elements contained in the {@code collection} argument  * passed to {@code createApproximateCollection()}. Thus casting the  * value returned by {@link EnumSet#copyOf(EnumSet)} to  * {@code (Collection<E>)} cannot guarantee that the returned collection  * actually contains elements of type {@code E}.  */ @Test public void createApproximateCollectionIsNotTypeSafeForEnumSet() {     Collection<Integer> ints = createApproximateCollection(EnumSet.of(Color.BLUE), 3).     // next line and not as a result of the previous line.     try {         // Note that ints is of type Collection<Integer>, but the collection returned         // by createApproximateCollection() is of type Collection<Color>. Thus, 42         // cannot be cast to a Color.         ints.add(42).         fail("Should have thrown a ClassCastException").     } catch (ClassCastException e) {     /* expected */     } }
false;public;0;17;;@Test public void createCollectionIsNotTypeSafeForEnumSet() {     Collection<Integer> ints = createCollection(EnumSet.class, Color.class, 3).     // next line and not as a result of the previous line.     try {         // Note that ints is of type Collection<Integer>, but the collection returned         // by createCollection() is of type Collection<Color>. Thus, 42 cannot be cast         // to a Color.         ints.add(42).         fail("Should have thrown a ClassCastException").     } catch (ClassCastException e) {     /* expected */     } }
true;public;0;20;/**  * The test demonstrates that the generics-based API for  * {@link CollectionFactory#createApproximateMap(Object, int)}  * is not type-safe.  * <p>The reasoning is similar that described in  * {@link #createApproximateCollectionIsNotTypeSafeForEnumSet}.  */ ;/**  * The test demonstrates that the generics-based API for  * {@link CollectionFactory#createApproximateMap(Object, int)}  * is not type-safe.  * <p>The reasoning is similar that described in  * {@link #createApproximateCollectionIsNotTypeSafeForEnumSet}.  */ @Test public void createApproximateMapIsNotTypeSafeForEnumMap() {     EnumMap<Color, Integer> enumMap = new EnumMap<>(Color.class).     enumMap.put(Color.RED, 1).     enumMap.put(Color.BLUE, 2).     Map<String, Integer> map = createApproximateMap(enumMap, 3).     // next line and not as a result of the previous line.     try {         // Note that the 'map' key must be of type String, but the keys in the map         // returned by createApproximateMap() are of type Color. Thus "foo" cannot be         // cast to a Color.         map.put("foo", 1).         fail("Should have thrown a ClassCastException").     } catch (ClassCastException e) {     /* expected */     } }
false;public;0;17;;@Test public void createMapIsNotTypeSafeForEnumMap() {     Map<String, Integer> map = createMap(EnumMap.class, Color.class, 3).     // next line and not as a result of the previous line.     try {         // Note that the 'map' key must be of type String, but the keys in the map         // returned by createMap() are of type Color. Thus "foo" cannot be cast to a         // Color.         map.put("foo", 1).         fail("Should have thrown a ClassCastException").     } catch (ClassCastException e) {     /* expected */     } }
false;public;0;17;;@Test public void createMapIsNotTypeSafeForLinkedMultiValueMap() {     Map<String, Integer> map = createMap(MultiValueMap.class, null, 3).     // next line and not as a result of the previous line.     try {         // Note: 'map' values must be of type Integer, but the values in the map         // returned by createMap() are of type java.util.List. Thus 1 cannot be         // cast to a List.         map.put("foo", 1).         fail("Should have thrown a ClassCastException").     } catch (ClassCastException e) {     /* expected */     } }
false;public;0;5;;@Test public void createApproximateCollectionFromEmptyHashSet() {     Collection<String> set = createApproximateCollection(new HashSet<String>(), 2).     assertThat(set, is(empty())). }
false;public;0;7;;@Test public void createApproximateCollectionFromNonEmptyHashSet() {     HashSet<String> hashSet = new HashSet<>().     hashSet.add("foo").     Collection<String> set = createApproximateCollection(hashSet, 2).     assertThat(set, is(empty())). }
false;public;0;5;;@Test public void createApproximateCollectionFromEmptyEnumSet() {     Collection<Color> colors = createApproximateCollection(EnumSet.noneOf(Color.class), 2).     assertThat(colors, is(empty())). }
false;public;0;5;;@Test public void createApproximateCollectionFromNonEmptyEnumSet() {     Collection<Color> colors = createApproximateCollection(EnumSet.of(Color.BLUE), 2).     assertThat(colors, is(empty())). }
false;public;0;5;;@Test public void createApproximateMapFromEmptyHashMap() {     Map<String, String> map = createApproximateMap(new HashMap<String, String>(), 2).     assertThat(map.size(), is(0)). }
false;public;0;7;;@Test public void createApproximateMapFromNonEmptyHashMap() {     Map<String, String> hashMap = new HashMap<>().     hashMap.put("foo", "bar").     Map<String, String> map = createApproximateMap(hashMap, 2).     assertThat(map.size(), is(0)). }
false;public;0;5;;@Test public void createApproximateMapFromEmptyEnumMap() {     Map<Color, String> colors = createApproximateMap(new EnumMap<Color, String>(Color.class), 2).     assertThat(colors.size(), is(0)). }
false;public;0;7;;@Test public void createApproximateMapFromNonEmptyEnumMap() {     EnumMap<Color, String> enumMap = new EnumMap<>(Color.class).     enumMap.put(Color.BLUE, "blue").     Map<Color, String> colors = createApproximateMap(enumMap, 2).     assertThat(colors.size(), is(0)). }
false;public;0;19;;@Test public void createsCollectionsCorrectly() {     // interfaces     assertThat(createCollection(List.class, 0), is(instanceOf(ArrayList.class))).     assertThat(createCollection(Set.class, 0), is(instanceOf(LinkedHashSet.class))).     assertThat(createCollection(Collection.class, 0), is(instanceOf(LinkedHashSet.class))).     assertThat(createCollection(SortedSet.class, 0), is(instanceOf(TreeSet.class))).     assertThat(createCollection(NavigableSet.class, 0), is(instanceOf(TreeSet.class))).     assertThat(createCollection(List.class, String.class, 0), is(instanceOf(ArrayList.class))).     assertThat(createCollection(Set.class, String.class, 0), is(instanceOf(LinkedHashSet.class))).     assertThat(createCollection(Collection.class, String.class, 0), is(instanceOf(LinkedHashSet.class))).     assertThat(createCollection(SortedSet.class, String.class, 0), is(instanceOf(TreeSet.class))).     assertThat(createCollection(NavigableSet.class, String.class, 0), is(instanceOf(TreeSet.class))).     // concrete types     assertThat(createCollection(HashSet.class, 0), is(instanceOf(HashSet.class))).     assertThat(createCollection(HashSet.class, String.class, 0), is(instanceOf(HashSet.class))). }
false;public;0;4;;@Test public void createsEnumSet() {     assertThat(createCollection(EnumSet.class, Color.class, 0), is(instanceOf(EnumSet.class))). }
false;public;0;5;;// SPR-17619 @Test public void createsEnumSetSubclass() {     EnumSet<Color> enumSet = EnumSet.noneOf(Color.class).     assertThat(createCollection(enumSet.getClass(), Color.class, 0), is(instanceOf(enumSet.getClass()))). }
false;public;0;4;;@Test(expected = IllegalArgumentException.class) public void rejectsInvalidElementTypeForEnumSet() {     createCollection(EnumSet.class, Object.class, 0). }
false;public;0;4;;@Test(expected = IllegalArgumentException.class) public void rejectsNullElementTypeForEnumSet() {     createCollection(EnumSet.class, null, 0). }
false;public;0;4;;@Test(expected = IllegalArgumentException.class) public void rejectsNullCollectionType() {     createCollection(null, Object.class, 0). }
false;public;0;18;;@Test public void createsMapsCorrectly() {     // interfaces     assertThat(createMap(Map.class, 0), is(instanceOf(LinkedHashMap.class))).     assertThat(createMap(SortedMap.class, 0), is(instanceOf(TreeMap.class))).     assertThat(createMap(NavigableMap.class, 0), is(instanceOf(TreeMap.class))).     assertThat(createMap(MultiValueMap.class, 0), is(instanceOf(LinkedMultiValueMap.class))).     assertThat(createMap(Map.class, String.class, 0), is(instanceOf(LinkedHashMap.class))).     assertThat(createMap(SortedMap.class, String.class, 0), is(instanceOf(TreeMap.class))).     assertThat(createMap(NavigableMap.class, String.class, 0), is(instanceOf(TreeMap.class))).     assertThat(createMap(MultiValueMap.class, String.class, 0), is(instanceOf(LinkedMultiValueMap.class))).     // concrete types     assertThat(createMap(HashMap.class, 0), is(instanceOf(HashMap.class))).     assertThat(createMap(HashMap.class, String.class, 0), is(instanceOf(HashMap.class))). }
false;public;0;4;;@Test public void createsEnumMap() {     assertThat(createMap(EnumMap.class, Color.class, 0), is(instanceOf(EnumMap.class))). }
false;public;0;4;;@Test(expected = IllegalArgumentException.class) public void rejectsInvalidKeyTypeForEnumMap() {     createMap(EnumMap.class, Object.class, 0). }
false;public;0;4;;@Test(expected = IllegalArgumentException.class) public void rejectsNullKeyTypeForEnumMap() {     createMap(EnumMap.class, null, 0). }
false;public;0;4;;@Test(expected = IllegalArgumentException.class) public void rejectsNullMapType() {     createMap(null, Object.class, 0). }
