# id;timestamp;commentText;codeText;commentWords;codeWords
AbstractEncoderTestCase -> protected AbstractEncoderTestCase(E encoder, Class<?> elementClass);1542112537;Construct a new {@code AbstractEncoderTestCase} for the given encoder and element class._@param encoder the encoder_@param elementClass the element class;protected AbstractEncoderTestCase(E encoder, Class<?> elementClass) {_		this(encoder, ResolvableType.forClass(elementClass), null, null)__	};construct,a,new,code,abstract,encoder,test,case,for,the,given,encoder,and,element,class,param,encoder,the,encoder,param,element,class,the,element,class;protected,abstract,encoder,test,case,e,encoder,class,element,class,this,encoder,resolvable,type,for,class,element,class,null,null
AbstractEncoderTestCase -> protected AbstractEncoderTestCase(E encoder, Class<?> elementClass);1542375206;Construct a new {@code AbstractEncoderTestCase} for the given encoder and element class._@param encoder the encoder_@param elementClass the element class;protected AbstractEncoderTestCase(E encoder, Class<?> elementClass) {_		this(encoder, ResolvableType.forClass(elementClass), null, null)__	};construct,a,new,code,abstract,encoder,test,case,for,the,given,encoder,and,element,class,param,encoder,the,encoder,param,element,class,the,element,class;protected,abstract,encoder,test,case,e,encoder,class,element,class,this,encoder,resolvable,type,for,class,element,class,null,null
AbstractEncoderTestCase -> protected abstract Flux<T> input()_;1542112537;Abstract template method that provides input for the encoder._Used for {@link #encode()}, {@link #encodeError()}, and {@link #encodeCancel()}.;protected abstract Flux<T> input()_;abstract,template,method,that,provides,input,for,the,encoder,used,for,link,encode,link,encode,error,and,link,encode,cancel;protected,abstract,flux,t,input
AbstractEncoderTestCase -> protected abstract Flux<T> input()_;1542375206;Abstract template method that provides input for the encoder._Used for {@link #encode()}, {@link #encodeError()}, and {@link #encodeCancel()}.;protected abstract Flux<T> input()_;abstract,template,method,that,provides,input,for,the,encoder,used,for,link,encode,link,encode,error,and,link,encode,cancel;protected,abstract,flux,t,input
AbstractEncoderTestCase -> protected abstract Stream<Consumer<DataBuffer>> outputConsumers()_;1542112537;Abstract template method that verifies the output of the encoder._The returned stream should contain a buffer consumer for each expected output, given_the {@linkplain #input()}.;protected abstract Stream<Consumer<DataBuffer>> outputConsumers()_;abstract,template,method,that,verifies,the,output,of,the,encoder,the,returned,stream,should,contain,a,buffer,consumer,for,each,expected,output,given,the,linkplain,input;protected,abstract,stream,consumer,data,buffer,output,consumers
AbstractEncoderTestCase -> protected abstract Stream<Consumer<DataBuffer>> outputConsumers()_;1542375206;Abstract template method that verifies the output of the encoder._The returned stream should contain a buffer consumer for each expected output, given_the {@linkplain #input()}.;protected abstract Stream<Consumer<DataBuffer>> outputConsumers()_;abstract,template,method,that,verifies,the,output,of,the,encoder,the,returned,stream,should,contain,a,buffer,consumer,for,each,expected,output,given,the,linkplain,input;protected,abstract,stream,consumer,data,buffer,output,consumers
AbstractEncoderTestCase -> protected final Consumer<DataBuffer> resultConsumer(byte[] expected);1542112537;Create a result consumer that expects the given bytes._@param expected the expected string_@return a consumer that expects the given data buffer to be equal to {@code expected};protected final Consumer<DataBuffer> resultConsumer(byte[] expected) {_		return dataBuffer -> {_			byte[] resultBytes = new byte[dataBuffer.readableByteCount()]__			dataBuffer.read(resultBytes)__			assertArrayEquals(expected, resultBytes)__		}__	};create,a,result,consumer,that,expects,the,given,bytes,param,expected,the,expected,string,return,a,consumer,that,expects,the,given,data,buffer,to,be,equal,to,code,expected;protected,final,consumer,data,buffer,result,consumer,byte,expected,return,data,buffer,byte,result,bytes,new,byte,data,buffer,readable,byte,count,data,buffer,read,result,bytes,assert,array,equals,expected,result,bytes
AbstractEncoderTestCase -> protected final Consumer<DataBuffer> resultConsumer(byte[] expected);1542375206;Create a result consumer that expects the given bytes._@param expected the expected string_@return a consumer that expects the given data buffer to be equal to {@code expected};protected final Consumer<DataBuffer> resultConsumer(byte[] expected) {_		return dataBuffer -> {_			byte[] resultBytes = new byte[dataBuffer.readableByteCount()]__			dataBuffer.read(resultBytes)__			assertArrayEquals(expected, resultBytes)__		}__	};create,a,result,consumer,that,expects,the,given,bytes,param,expected,the,expected,string,return,a,consumer,that,expects,the,given,data,buffer,to,be,equal,to,code,expected;protected,final,consumer,data,buffer,result,consumer,byte,expected,return,data,buffer,byte,result,bytes,new,byte,data,buffer,readable,byte,count,data,buffer,read,result,bytes,assert,array,equals,expected,result,bytes
AbstractEncoderTestCase -> protected final Consumer<DataBuffer> resultConsumer(String expected);1542112537;Create a result consumer that expects the given String in UTF-8 encoding._@param expected the expected string_@return a consumer that expects the given data buffer to be equal to {@code expected};protected final Consumer<DataBuffer> resultConsumer(String expected) {_		return dataBuffer -> {_			byte[] resultBytes = new byte[dataBuffer.readableByteCount()]__			dataBuffer.read(resultBytes)__			String actual = new String(resultBytes, UTF_8)__			assertEquals(expected, actual)__		}___	};create,a,result,consumer,that,expects,the,given,string,in,utf,8,encoding,param,expected,the,expected,string,return,a,consumer,that,expects,the,given,data,buffer,to,be,equal,to,code,expected;protected,final,consumer,data,buffer,result,consumer,string,expected,return,data,buffer,byte,result,bytes,new,byte,data,buffer,readable,byte,count,data,buffer,read,result,bytes,string,actual,new,string,result,bytes,assert,equals,expected,actual
AbstractEncoderTestCase -> protected final Consumer<DataBuffer> resultConsumer(String expected);1542375206;Create a result consumer that expects the given String in UTF-8 encoding._@param expected the expected string_@return a consumer that expects the given data buffer to be equal to {@code expected};protected final Consumer<DataBuffer> resultConsumer(String expected) {_		return dataBuffer -> {_			byte[] resultBytes = new byte[dataBuffer.readableByteCount()]__			dataBuffer.read(resultBytes)__			String actual = new String(resultBytes, UTF_8)__			assertEquals(expected, actual)__		}___	};create,a,result,consumer,that,expects,the,given,string,in,utf,8,encoding,param,expected,the,expected,string,return,a,consumer,that,expects,the,given,data,buffer,to,be,equal,to,code,expected;protected,final,consumer,data,buffer,result,consumer,string,expected,return,data,buffer,byte,result,bytes,new,byte,data,buffer,readable,byte,count,data,buffer,read,result,bytes,string,actual,new,string,result,bytes,assert,equals,expected,actual
AbstractEncoderTestCase -> @Test 	public final void encode();1542112537;Tests whether passing {@link #input()} to the encoder can be consumed with_{@link #outputConsumers()}.;@Test_	public final void encode() {_		Flux<T> input = input()___		Flux<DataBuffer> output = this.encoder.encode(input, this.bufferFactory,_				this.elementType, this.mimeType, this.hints)___		StepVerifier.Step<DataBuffer> step = StepVerifier.create(output)___		outputAndReleaseConsumers().forEach(step::consumeNextWith)___		step.expectComplete()_				.verify()__	};tests,whether,passing,link,input,to,the,encoder,can,be,consumed,with,link,output,consumers;test,public,final,void,encode,flux,t,input,input,flux,data,buffer,output,this,encoder,encode,input,this,buffer,factory,this,element,type,this,mime,type,this,hints,step,verifier,step,data,buffer,step,step,verifier,create,output,output,and,release,consumers,for,each,step,consume,next,with,step,expect,complete,verify
AbstractEncoderTestCase -> @Test 	public final void encode();1542375206;Tests whether passing {@link #input()} to the encoder can be consumed with_{@link #outputConsumers()}.;@Test_	public final void encode() {_		Flux<T> input = input()___		Flux<DataBuffer> output = this.encoder.encode(input, this.bufferFactory,_				this.elementType, this.mimeType, this.hints)___		StepVerifier.Step<DataBuffer> step = StepVerifier.create(output)___		outputAndReleaseConsumers().forEach(step::consumeNextWith)___		step.expectComplete()_				.verify()__	};tests,whether,passing,link,input,to,the,encoder,can,be,consumed,with,link,output,consumers;test,public,final,void,encode,flux,t,input,input,flux,data,buffer,output,this,encoder,encode,input,this,buffer,factory,this,element,type,this,mime,type,this,hints,step,verifier,step,data,buffer,step,step,verifier,create,output,output,and,release,consumers,for,each,step,consume,next,with,step,expect,complete,verify
AbstractEncoderTestCase -> @Test 	public final void encodeError();1542112537;Tests whether passing an error to the encoder can be consumed with_{@link #outputConsumers()}.;@Test_	public final void encodeError() {__		boolean singleValue = this.encoder instanceof AbstractSingleValueEncoder___		Flux<T> input__		if (singleValue) {_			input = Flux.error(new RuntimeException())__		}_		else {_			input = Flux.concat(_					input().take(1),_					Flux.error(new RuntimeException()))__		}__		Flux<DataBuffer> output = this.encoder.encode(input, this.bufferFactory,_				this.elementType, this.mimeType, this.hints)___		if (singleValue) {_			StepVerifier.create(output)_					.expectError(RuntimeException.class)_					.verify()__		}_		else {_			Consumer<DataBuffer> firstResultConsumer = outputAndReleaseConsumers().findFirst()_					.orElseThrow(IllegalArgumentException::new)__			StepVerifier.create(output)_					.consumeNextWith(firstResultConsumer)_					.expectError(RuntimeException.class)_					.verify()__		}_	};tests,whether,passing,an,error,to,the,encoder,can,be,consumed,with,link,output,consumers;test,public,final,void,encode,error,boolean,single,value,this,encoder,instanceof,abstract,single,value,encoder,flux,t,input,if,single,value,input,flux,error,new,runtime,exception,else,input,flux,concat,input,take,1,flux,error,new,runtime,exception,flux,data,buffer,output,this,encoder,encode,input,this,buffer,factory,this,element,type,this,mime,type,this,hints,if,single,value,step,verifier,create,output,expect,error,runtime,exception,class,verify,else,consumer,data,buffer,first,result,consumer,output,and,release,consumers,find,first,or,else,throw,illegal,argument,exception,new,step,verifier,create,output,consume,next,with,first,result,consumer,expect,error,runtime,exception,class,verify
AbstractEncoderTestCase -> @Test 	public final void encodeError();1542375206;Tests whether passing an error to the encoder can be consumed with_{@link #outputConsumers()}.;@Test_	public final void encodeError() {__		boolean singleValue = this.encoder instanceof AbstractSingleValueEncoder___		Flux<T> input__		if (singleValue) {_			input = Flux.error(new RuntimeException())__		}_		else {_			input = Flux.concat(_					input().take(1),_					Flux.error(new RuntimeException()))__		}__		Flux<DataBuffer> output = this.encoder.encode(input, this.bufferFactory,_				this.elementType, this.mimeType, this.hints)___		if (singleValue) {_			StepVerifier.create(output)_					.expectError(RuntimeException.class)_					.verify()__		}_		else {_			Consumer<DataBuffer> firstResultConsumer = outputAndReleaseConsumers().findFirst()_					.orElseThrow(IllegalArgumentException::new)__			StepVerifier.create(output)_					.consumeNextWith(firstResultConsumer)_					.expectError(RuntimeException.class)_					.verify()__		}_	};tests,whether,passing,an,error,to,the,encoder,can,be,consumed,with,link,output,consumers;test,public,final,void,encode,error,boolean,single,value,this,encoder,instanceof,abstract,single,value,encoder,flux,t,input,if,single,value,input,flux,error,new,runtime,exception,else,input,flux,concat,input,take,1,flux,error,new,runtime,exception,flux,data,buffer,output,this,encoder,encode,input,this,buffer,factory,this,element,type,this,mime,type,this,hints,if,single,value,step,verifier,create,output,expect,error,runtime,exception,class,verify,else,consumer,data,buffer,first,result,consumer,output,and,release,consumers,find,first,or,else,throw,illegal,argument,exception,new,step,verifier,create,output,consume,next,with,first,result,consumer,expect,error,runtime,exception,class,verify
AbstractEncoderTestCase -> @Test 	public final void encodeCancel();1542112537;Tests whether canceling the output of the encoder can be consumed with_{@link #outputConsumers()}.;@Test_	public final void encodeCancel() {_		Flux<T> input = input()___		Flux<DataBuffer> output = this.encoder.encode(input, this.bufferFactory,_				this.elementType, this.mimeType, this.hints)___		Consumer<DataBuffer> firstResultConsumer = outputAndReleaseConsumers().findFirst()_				.orElseThrow(IllegalArgumentException::new)__		StepVerifier.create(output)_				.consumeNextWith(firstResultConsumer)_				.thenCancel()_				.verify()__	};tests,whether,canceling,the,output,of,the,encoder,can,be,consumed,with,link,output,consumers;test,public,final,void,encode,cancel,flux,t,input,input,flux,data,buffer,output,this,encoder,encode,input,this,buffer,factory,this,element,type,this,mime,type,this,hints,consumer,data,buffer,first,result,consumer,output,and,release,consumers,find,first,or,else,throw,illegal,argument,exception,new,step,verifier,create,output,consume,next,with,first,result,consumer,then,cancel,verify
AbstractEncoderTestCase -> @Test 	public final void encodeCancel();1542375206;Tests whether canceling the output of the encoder can be consumed with_{@link #outputConsumers()}.;@Test_	public final void encodeCancel() {_		Flux<T> input = input()___		Flux<DataBuffer> output = this.encoder.encode(input, this.bufferFactory,_				this.elementType, this.mimeType, this.hints)___		Consumer<DataBuffer> firstResultConsumer = outputAndReleaseConsumers().findFirst()_				.orElseThrow(IllegalArgumentException::new)__		StepVerifier.create(output)_				.consumeNextWith(firstResultConsumer)_				.thenCancel()_				.verify()__	};tests,whether,canceling,the,output,of,the,encoder,can,be,consumed,with,link,output,consumers;test,public,final,void,encode,cancel,flux,t,input,input,flux,data,buffer,output,this,encoder,encode,input,this,buffer,factory,this,element,type,this,mime,type,this,hints,consumer,data,buffer,first,result,consumer,output,and,release,consumers,find,first,or,else,throw,illegal,argument,exception,new,step,verifier,create,output,consume,next,with,first,result,consumer,then,cancel,verify
AbstractEncoderTestCase -> protected AbstractEncoderTestCase(E encoder, ResolvableType elementType, 			@Nullable MimeType mimeType, @Nullable Map<String, Object> hints);1542112537;Construct a new {@code AbstractEncoderTestCase} for the given parameters._@param encoder the encoder_@param elementType the element type_@param mimeType the mime type. May be {@code null}._@param hints the hints. May be {@code null}.;protected AbstractEncoderTestCase(E encoder, ResolvableType elementType,_			@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {__		Assert.notNull(encoder, "Encoder must not be null")__		Assert.notNull(elementType, "ElementType must not be null")___		this.encoder = encoder__		this.elementType = elementType__		this.mimeType = mimeType__		this.hints = hints__	};construct,a,new,code,abstract,encoder,test,case,for,the,given,parameters,param,encoder,the,encoder,param,element,type,the,element,type,param,mime,type,the,mime,type,may,be,code,null,param,hints,the,hints,may,be,code,null;protected,abstract,encoder,test,case,e,encoder,resolvable,type,element,type,nullable,mime,type,mime,type,nullable,map,string,object,hints,assert,not,null,encoder,encoder,must,not,be,null,assert,not,null,element,type,element,type,must,not,be,null,this,encoder,encoder,this,element,type,element,type,this,mime,type,mime,type,this,hints,hints
AbstractEncoderTestCase -> protected AbstractEncoderTestCase(E encoder, ResolvableType elementType, 			@Nullable MimeType mimeType, @Nullable Map<String, Object> hints);1542375206;Construct a new {@code AbstractEncoderTestCase} for the given parameters._@param encoder the encoder_@param elementType the element type_@param mimeType the mime type. May be {@code null}._@param hints the hints. May be {@code null}.;protected AbstractEncoderTestCase(E encoder, ResolvableType elementType,_			@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {__		Assert.notNull(encoder, "Encoder must not be null")__		Assert.notNull(elementType, "ElementType must not be null")___		this.encoder = encoder__		this.elementType = elementType__		this.mimeType = mimeType__		this.hints = hints__	};construct,a,new,code,abstract,encoder,test,case,for,the,given,parameters,param,encoder,the,encoder,param,element,type,the,element,type,param,mime,type,the,mime,type,may,be,code,null,param,hints,the,hints,may,be,code,null;protected,abstract,encoder,test,case,e,encoder,resolvable,type,element,type,nullable,mime,type,mime,type,nullable,map,string,object,hints,assert,not,null,encoder,encoder,must,not,be,null,assert,not,null,element,type,element,type,must,not,be,null,this,encoder,encoder,this,element,type,element,type,this,mime,type,mime,type,this,hints,hints
