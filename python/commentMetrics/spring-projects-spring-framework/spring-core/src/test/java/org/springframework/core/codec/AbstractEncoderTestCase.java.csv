commented;modifiers;parameterAmount;loc;comment;code
true;public,abstract;0;2;/**  * Subclasses should implement this method to test {@link Encoder#canEncode}.  */ ;/**  * Subclasses should implement this method to test {@link Encoder#canEncode}.  */ @Test public abstract void canEncode() throws Exception.
true;public,abstract;0;2;/**  * Subclasses should implement this method to test {@link Encoder#encode}, possibly using  * {@link #testEncodeAll} or other helper methods.  */ ;/**  * Subclasses should implement this method to test {@link Encoder#encode}, possibly using  * {@link #testEncodeAll} or other helper methods.  */ @Test public abstract void encode() throws Exception.
true;protected;3;4;/**  * Helper methods that tests for a variety of encoding scenarios. This methods  * invokes:  * <ul>  *     <li>{@link #testEncode(Publisher, ResolvableType, Consumer, MimeType, Map)}</li>  *     <li>{@link #testEncodeError(Publisher, ResolvableType, MimeType, Map)}</li>  *     <li>{@link #testEncodeCancel(Publisher, ResolvableType, MimeType, Map)}</li>  *     <li>{@link #testEncodeEmpty(ResolvableType, MimeType, Map)}</li>  * </ul>  *  * @param input the input to be provided to the encoder  * @param inputClass the input class  * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output  * @param <T> the output type  */ ;/**  * Helper methods that tests for a variety of encoding scenarios. This methods  * invokes:  * <ul>  *     <li>{@link #testEncode(Publisher, ResolvableType, Consumer, MimeType, Map)}</li>  *     <li>{@link #testEncodeError(Publisher, ResolvableType, MimeType, Map)}</li>  *     <li>{@link #testEncodeCancel(Publisher, ResolvableType, MimeType, Map)}</li>  *     <li>{@link #testEncodeEmpty(ResolvableType, MimeType, Map)}</li>  * </ul>  *  * @param input the input to be provided to the encoder  * @param inputClass the input class  * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output  * @param <T> the output type  */ protected <T> void testEncodeAll(Publisher<? extends T> input, Class<? extends T> inputClass, Consumer<StepVerifier.FirstStep<DataBuffer>> stepConsumer) {     testEncodeAll(input, ResolvableType.forClass(inputClass), stepConsumer, null, null). }
true;protected;5;8;/**  * Helper methods that tests for a variety of decoding scenarios. This methods  * invokes:  * <ul>  *     <li>{@link #testEncode(Publisher, ResolvableType, Consumer, MimeType, Map)}</li>  *     <li>{@link #testEncodeError(Publisher, ResolvableType, MimeType, Map)}</li>  *     <li>{@link #testEncodeCancel(Publisher, ResolvableType, MimeType, Map)}</li>  *     <li>{@link #testEncodeEmpty(ResolvableType, MimeType, Map)}</li>  * </ul>  *  * @param input the input to be provided to the encoder  * @param inputType the input type  * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output  * @param mimeType the mime type to use for decoding. May be {@code null}.  * @param hints the hints used for decoding. May be {@code null}.  * @param <T> the output type  */ ;/**  * Helper methods that tests for a variety of decoding scenarios. This methods  * invokes:  * <ul>  *     <li>{@link #testEncode(Publisher, ResolvableType, Consumer, MimeType, Map)}</li>  *     <li>{@link #testEncodeError(Publisher, ResolvableType, MimeType, Map)}</li>  *     <li>{@link #testEncodeCancel(Publisher, ResolvableType, MimeType, Map)}</li>  *     <li>{@link #testEncodeEmpty(ResolvableType, MimeType, Map)}</li>  * </ul>  *  * @param input the input to be provided to the encoder  * @param inputType the input type  * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output  * @param mimeType the mime type to use for decoding. May be {@code null}.  * @param hints the hints used for decoding. May be {@code null}.  * @param <T> the output type  */ protected <T> void testEncodeAll(Publisher<? extends T> input, ResolvableType inputType, Consumer<StepVerifier.FirstStep<DataBuffer>> stepConsumer, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {     testEncode(input, inputType, stepConsumer, mimeType, hints).     testEncodeError(input, inputType, mimeType, hints).     testEncodeCancel(input, inputType, mimeType, hints).     testEncodeEmpty(inputType, mimeType, hints). }
true;protected;3;4;/**  * Test a standard {@link Encoder#encode encode} scenario.  *  * @param input the input to be provided to the encoder  * @param inputClass the input class  * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output  * @param <T> the output type  */ ;/**  * Test a standard {@link Encoder#encode encode} scenario.  *  * @param input the input to be provided to the encoder  * @param inputClass the input class  * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output  * @param <T> the output type  */ protected <T> void testEncode(Publisher<? extends T> input, Class<? extends T> inputClass, Consumer<StepVerifier.FirstStep<DataBuffer>> stepConsumer) {     testEncode(input, ResolvableType.forClass(inputClass), stepConsumer, null, null). }
true;protected;5;10;/**  * Test a standard {@link Encoder#encode encode} scenario.  *  * @param input the input to be provided to the encoder  * @param inputType the input type  * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output  * @param mimeType the mime type to use for decoding. May be {@code null}.  * @param hints the hints used for decoding. May be {@code null}.  * @param <T> the output type  */ ;/**  * Test a standard {@link Encoder#encode encode} scenario.  *  * @param input the input to be provided to the encoder  * @param inputType the input type  * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output  * @param mimeType the mime type to use for decoding. May be {@code null}.  * @param hints the hints used for decoding. May be {@code null}.  * @param <T> the output type  */ @SuppressWarnings("unchecked") protected <T> void testEncode(Publisher<? extends T> input, ResolvableType inputType, Consumer<StepVerifier.FirstStep<DataBuffer>> stepConsumer, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {     Flux<DataBuffer> result = encoder().encode(input, this.bufferFactory, inputType, mimeType, hints).     StepVerifier.FirstStep<DataBuffer> step = StepVerifier.create(result).     stepConsumer.accept(step). }
true;protected;4;15;/**  * Test a {@link Encoder#encode encode} scenario where the input stream contains an error.  * This test method will feed the first element of the {@code input} stream to the encoder,  * followed by an {@link InputException}.  * The result is expected to contain one "normal" element, followed by the error.  *  * @param input the input to be provided to the encoder  * @param inputType the input type  * @param mimeType the mime type to use for decoding. May be {@code null}.  * @param hints the hints used for decoding. May be {@code null}.  * @see InputException  */ ;/**  * Test a {@link Encoder#encode encode} scenario where the input stream contains an error.  * This test method will feed the first element of the {@code input} stream to the encoder,  * followed by an {@link InputException}.  * The result is expected to contain one "normal" element, followed by the error.  *  * @param input the input to be provided to the encoder  * @param inputType the input type  * @param mimeType the mime type to use for decoding. May be {@code null}.  * @param hints the hints used for decoding. May be {@code null}.  * @see InputException  */ protected void testEncodeError(Publisher<?> input, ResolvableType inputType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {     input = Flux.concat(Flux.from(input).take(1), Flux.error(new InputException())).     Flux<DataBuffer> result = encoder().encode(input, this.bufferFactory, inputType, mimeType, hints).     StepVerifier.create(result).consumeNextWith(DataBufferUtils::release).expectError(InputException.class).verify(). }
true;protected;4;11;/**  * Test a {@link Encoder#encode encode} scenario where the input stream is canceled.  * This test method will feed the first element of the {@code input} stream to the decoder,  * followed by a cancel signal.  * The result is expected to contain one "normal" element.  *  * @param input the input to be provided to the encoder  * @param inputType the input type  * @param mimeType the mime type to use for decoding. May be {@code null}.  * @param hints the hints used for decoding. May be {@code null}.  */ ;/**  * Test a {@link Encoder#encode encode} scenario where the input stream is canceled.  * This test method will feed the first element of the {@code input} stream to the decoder,  * followed by a cancel signal.  * The result is expected to contain one "normal" element.  *  * @param input the input to be provided to the encoder  * @param inputType the input type  * @param mimeType the mime type to use for decoding. May be {@code null}.  * @param hints the hints used for decoding. May be {@code null}.  */ protected void testEncodeCancel(Publisher<?> input, ResolvableType inputType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {     Flux<DataBuffer> result = encoder().encode(input, this.bufferFactory, inputType, mimeType, hints).     StepVerifier.create(result).consumeNextWith(DataBufferUtils::release).thenCancel().verify(). }
true;protected;3;10;/**  * Test a {@link Encoder#encode encode} scenario where the input stream is empty.  * The output is expected to be empty as well.  *  * @param inputType the input type  * @param mimeType the mime type to use for decoding. May be {@code null}.  * @param hints the hints used for decoding. May be {@code null}.  */ ;/**  * Test a {@link Encoder#encode encode} scenario where the input stream is empty.  * The output is expected to be empty as well.  *  * @param inputType the input type  * @param mimeType the mime type to use for decoding. May be {@code null}.  * @param hints the hints used for decoding. May be {@code null}.  */ protected void testEncodeEmpty(ResolvableType inputType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {     Flux<?> input = Flux.empty().     Flux<DataBuffer> result = encoder().encode(input, this.bufferFactory, inputType, mimeType, hints).     StepVerifier.create(result).verifyComplete(). }
true;protected,final;1;8;/**  * Create a result consumer that expects the given bytes.  * @param expected the expected bytes  * @return a consumer that expects the given data buffer to be equal to {@code expected}  */ ;/**  * Create a result consumer that expects the given bytes.  * @param expected the expected bytes  * @return a consumer that expects the given data buffer to be equal to {@code expected}  */ protected final Consumer<DataBuffer> expectBytes(byte[] expected) {     return dataBuffer -> {         byte[] resultBytes = new byte[dataBuffer.readableByteCount()].         dataBuffer.read(resultBytes).         release(dataBuffer).         assertArrayEquals(expected, resultBytes).     }. }
true;protected;1;10;/**  * Create a result consumer that expects the given string, using the UTF-8 encoding.  * @param expected the expected string  * @return a consumer that expects the given data buffer to be equal to {@code expected}  */ ;/**  * Create a result consumer that expects the given string, using the UTF-8 encoding.  * @param expected the expected string  * @return a consumer that expects the given data buffer to be equal to {@code expected}  */ protected Consumer<DataBuffer> expectString(String expected) {     return dataBuffer -> {         byte[] resultBytes = new byte[dataBuffer.readableByteCount()].         dataBuffer.read(resultBytes).         release(dataBuffer).         String actual = new String(resultBytes, UTF_8).         assertEquals(expected, actual).     }. }
false;private;0;5;;@SuppressWarnings("unchecked") private <T> Encoder<T> encoder() {     return (Encoder<T>) this.encoder. }
