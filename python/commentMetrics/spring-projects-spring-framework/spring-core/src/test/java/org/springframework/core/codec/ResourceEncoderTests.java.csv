commented;modifiers;parameterAmount;loc;comment;code
false;public;0;15;;@Override @Test public void canEncode() {     assertTrue(this.encoder.canEncode(ResolvableType.forClass(InputStreamResource.class), MimeTypeUtils.TEXT_PLAIN)).     assertTrue(this.encoder.canEncode(ResolvableType.forClass(ByteArrayResource.class), MimeTypeUtils.TEXT_PLAIN)).     assertTrue(this.encoder.canEncode(ResolvableType.forClass(Resource.class), MimeTypeUtils.TEXT_PLAIN)).     assertTrue(this.encoder.canEncode(ResolvableType.forClass(InputStreamResource.class), MimeTypeUtils.APPLICATION_JSON)).     // SPR-15464     assertFalse(this.encoder.canEncode(ResolvableType.NONE, null)). }
false;public;0;8;;@Override public void encode() {     Flux<Resource> input = Flux.just(new ByteArrayResource(this.bytes)).     testEncodeAll(input, Resource.class, step -> step.consumeNextWith(expectBytes(this.bytes)).verifyComplete()). }
false;protected;4;14;;@Override protected void testEncodeError(Publisher<?> input, ResolvableType outputType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {     Flux<Resource> i = Flux.error(new InputException()).     Flux<DataBuffer> result = ((Encoder<Resource>) this.encoder).encode(i, this.bufferFactory, outputType, mimeType, hints).     StepVerifier.create(result).expectError(InputException.class).verify(). }
