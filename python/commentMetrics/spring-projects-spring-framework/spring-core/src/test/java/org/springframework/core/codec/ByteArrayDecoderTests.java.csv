commented;modifiers;parameterAmount;loc;comment;code
false;public;0;10;;@Override @Test public void canDecode() {     assertTrue(this.decoder.canDecode(ResolvableType.forClass(byte[].class), MimeTypeUtils.TEXT_PLAIN)).     assertFalse(this.decoder.canDecode(ResolvableType.forClass(Integer.class), MimeTypeUtils.TEXT_PLAIN)).     assertTrue(this.decoder.canDecode(ResolvableType.forClass(byte[].class), MimeTypeUtils.APPLICATION_JSON)). }
false;public;0;13;;@Override @Test public void decode() {     Flux<DataBuffer> input = Flux.concat(dataBuffer(this.fooBytes), dataBuffer(this.barBytes)).     testDecodeAll(input, byte[].class, step -> step.consumeNextWith(expectBytes(this.fooBytes)).consumeNextWith(expectBytes(this.barBytes)).verifyComplete()). }
false;public;0;15;;@Override @Test public void decodeToMono() {     Flux<DataBuffer> input = Flux.concat(dataBuffer(this.fooBytes), dataBuffer(this.barBytes)).     byte[] expected = new byte[this.fooBytes.length + this.barBytes.length].     System.arraycopy(this.fooBytes, 0, expected, 0, this.fooBytes.length).     System.arraycopy(this.barBytes, 0, expected, this.fooBytes.length, this.barBytes.length).     testDecodeToMonoAll(input, byte[].class, step -> step.consumeNextWith(expectBytes(expected)).verifyComplete()). }
false;private;1;3;;private Consumer<byte[]> expectBytes(byte[] expected) {     return bytes -> assertArrayEquals(expected, bytes). }
