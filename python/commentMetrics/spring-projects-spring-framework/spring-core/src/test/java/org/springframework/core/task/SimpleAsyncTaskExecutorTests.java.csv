commented;modifiers;parameterAmount;loc;comment;code
false;public;0;8;;@Test public void cannotExecuteWhenConcurrencyIsSwitchedOff() throws Exception {     SimpleAsyncTaskExecutor executor = new SimpleAsyncTaskExecutor().     executor.setConcurrencyLimit(ConcurrencyThrottleSupport.NO_CONCURRENCY).     assertTrue(executor.isThrottleActive()).     exception.expect(IllegalStateException.class).     executor.execute(new NoOpRunnable()). }
false;public;0;5;;@Test public void throttleIsNotActiveByDefault() throws Exception {     SimpleAsyncTaskExecutor executor = new SimpleAsyncTaskExecutor().     assertFalse("Concurrency throttle must not default to being active (on)", executor.isThrottleActive()). }
false;public;0;9;;@Test public void threadNameGetsSetCorrectly() throws Exception {     final String customPrefix = "chankPop#".     final Object monitor = new Object().     SimpleAsyncTaskExecutor executor = new SimpleAsyncTaskExecutor(customPrefix).     ThreadNameHarvester task = new ThreadNameHarvester(monitor).     executeAndWait(executor, task, monitor).     assertThat(task.getThreadName(), startsWith(customPrefix)). }
false;public;1;4;;@Override public Thread newThread(Runnable r) {     return new Thread(r, "test"). }
false;public;0;13;;@Test public void threadFactoryOverridesDefaults() throws Exception {     final Object monitor = new Object().     SimpleAsyncTaskExecutor executor = new SimpleAsyncTaskExecutor(new ThreadFactory() {          @Override         public Thread newThread(Runnable r) {             return new Thread(r, "test").         }     }).     ThreadNameHarvester task = new ThreadNameHarvester(monitor).     executeAndWait(executor, task, monitor).     assertEquals("test", task.getThreadName()). }
false;public;0;5;;@Test public void throwsExceptionWhenSuppliedWithNullRunnable() throws Exception {     exception.expect(IllegalArgumentException.class).     new SimpleAsyncTaskExecutor().execute(null). }
false;private;3;10;;private void executeAndWait(SimpleAsyncTaskExecutor executor, Runnable task, Object monitor) {     synchronized (monitor) {         executor.execute(task).         try {             monitor.wait().         } catch (InterruptedException ignored) {         }     } }
false;public;0;4;;@Override public void run() { // no-op }
false;public,final;0;11;;@Override public final void run() {     synchronized (this.monitor) {         try {             doRun().         } finally {             this.monitor.notifyAll().         }     } }
false;protected,abstract;0;1;;protected abstract void doRun().
false;public;0;3;;public String getThreadName() {     return this.threadName. }
false;protected;0;4;;@Override protected void doRun() {     this.threadName = Thread.currentThread().getName(). }
