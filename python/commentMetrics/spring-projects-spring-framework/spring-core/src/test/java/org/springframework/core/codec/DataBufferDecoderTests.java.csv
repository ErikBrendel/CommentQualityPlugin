commented;modifiers;parameterAmount;loc;comment;code
false;public;0;10;;@Override @Test public void canDecode() {     assertTrue(this.decoder.canDecode(ResolvableType.forClass(DataBuffer.class), MimeTypeUtils.TEXT_PLAIN)).     assertFalse(this.decoder.canDecode(ResolvableType.forClass(Integer.class), MimeTypeUtils.TEXT_PLAIN)).     assertTrue(this.decoder.canDecode(ResolvableType.forClass(DataBuffer.class), MimeTypeUtils.APPLICATION_JSON)). }
false;public;0;11;;@Override public void decode() {     Flux<DataBuffer> input = Flux.just(this.bufferFactory.wrap(this.fooBytes), this.bufferFactory.wrap(this.barBytes)).     testDecodeAll(input, DataBuffer.class, step -> step.consumeNextWith(expectDataBuffer(this.fooBytes)).consumeNextWith(expectDataBuffer(this.barBytes)).verifyComplete()). }
false;public;0;14;;@Override public void decodeToMono() throws Exception {     Flux<DataBuffer> input = Flux.concat(dataBuffer(this.fooBytes), dataBuffer(this.barBytes)).     byte[] expected = new byte[this.fooBytes.length + this.barBytes.length].     System.arraycopy(this.fooBytes, 0, expected, 0, this.fooBytes.length).     System.arraycopy(this.barBytes, 0, expected, this.fooBytes.length, this.barBytes.length).     testDecodeToMonoAll(input, DataBuffer.class, step -> step.consumeNextWith(expectDataBuffer(expected)).verifyComplete()). }
false;private;1;9;;private Consumer<DataBuffer> expectDataBuffer(byte[] expected) {     return actual -> {         byte[] actualBytes = new byte[actual.readableByteCount()].         actual.read(actualBytes).         assertArrayEquals(expected, actualBytes).         DataBufferUtils.release(actual).     }. }
