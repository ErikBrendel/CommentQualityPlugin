# id;timestamp;commentText;codeText;commentWords;codeWords
ConcurrentReferenceHashMapTests -> private <V> StopWatch timeMultiThreaded(String id, final Map<Integer, V> map, 			ValueFactory<V> factory) throws InterruptedException;1351982790;Time a multi-threaded access to a cache.__@param cache the cache to test_@return the timing stopwatch_@throws InterruptedException;private <V> StopWatch timeMultiThreaded(String id, final Map<Integer, V> map,_			ValueFactory<V> factory) throws InterruptedException {_		StopWatch stopWatch = new StopWatch(id)__		for (int i = 0_ i < 500_ i++) {_			map.put(i, factory.newValue(i))__		}_		Thread[] threads = new Thread[30]__		stopWatch.start("Running threads")__		for (int threadIndex = 0_ threadIndex < threads.length_ threadIndex++) {_			threads[threadIndex] = new Thread("Cache access thread " + threadIndex) {__				@Override_				public void run() {_					for (int j = 0_ j < 1000_ j++) {_						for (int i = 0_ i < 1000_ i++) {_							map.get(i)__						}_					}_				}__			}__		}_		for (int i = 0_ i < threads.length_ i++) {_			threads[i].start()__		}__		for (int i = 0_ i < threads.length_ i++) {_			if (threads[i].isAlive()) {_				threads[i].join(2000)__			}_		}_		stopWatch.stop()__		return stopWatch__	};time,a,multi,threaded,access,to,a,cache,param,cache,the,cache,to,test,return,the,timing,stopwatch,throws,interrupted,exception;private,v,stop,watch,time,multi,threaded,string,id,final,map,integer,v,map,value,factory,v,factory,throws,interrupted,exception,stop,watch,stop,watch,new,stop,watch,id,for,int,i,0,i,500,i,map,put,i,factory,new,value,i,thread,threads,new,thread,30,stop,watch,start,running,threads,for,int,thread,index,0,thread,index,threads,length,thread,index,threads,thread,index,new,thread,cache,access,thread,thread,index,override,public,void,run,for,int,j,0,j,1000,j,for,int,i,0,i,1000,i,map,get,i,for,int,i,0,i,threads,length,i,threads,i,start,for,int,i,0,i,threads,length,i,if,threads,i,is,alive,threads,i,join,2000,stop,watch,stop,return,stop,watch
ConcurrentReferenceHashMapTests -> private <V> StopWatch timeMultiThreaded(String id, final Map<Integer, V> map, 			ValueFactory<V> factory) throws InterruptedException;1352039846;Time a multi-threaded access to a cache.__@param cache the cache to test_@return the timing stopwatch_@throws InterruptedException;private <V> StopWatch timeMultiThreaded(String id, final Map<Integer, V> map,_			ValueFactory<V> factory) throws InterruptedException {_		StopWatch stopWatch = new StopWatch(id)__		for (int i = 0_ i < 500_ i++) {_			map.put(i, factory.newValue(i))__		}_		Thread[] threads = new Thread[30]__		stopWatch.start("Running threads")__		for (int threadIndex = 0_ threadIndex < threads.length_ threadIndex++) {_			threads[threadIndex] = new Thread("Cache access thread " + threadIndex) {__				@Override_				public void run() {_					for (int j = 0_ j < 1000_ j++) {_						for (int i = 0_ i < 1000_ i++) {_							map.get(i)__						}_					}_				}__			}__		}_		for (int i = 0_ i < threads.length_ i++) {_			threads[i].start()__		}__		for (int i = 0_ i < threads.length_ i++) {_			if (threads[i].isAlive()) {_				threads[i].join(2000)__			}_		}_		stopWatch.stop()__		return stopWatch__	};time,a,multi,threaded,access,to,a,cache,param,cache,the,cache,to,test,return,the,timing,stopwatch,throws,interrupted,exception;private,v,stop,watch,time,multi,threaded,string,id,final,map,integer,v,map,value,factory,v,factory,throws,interrupted,exception,stop,watch,stop,watch,new,stop,watch,id,for,int,i,0,i,500,i,map,put,i,factory,new,value,i,thread,threads,new,thread,30,stop,watch,start,running,threads,for,int,thread,index,0,thread,index,threads,length,thread,index,threads,thread,index,new,thread,cache,access,thread,thread,index,override,public,void,run,for,int,j,0,j,1000,j,for,int,i,0,i,1000,i,map,get,i,for,int,i,0,i,threads,length,i,threads,i,start,for,int,i,0,i,threads,length,i,if,threads,i,is,alive,threads,i,join,2000,stop,watch,stop,return,stop,watch
ConcurrentReferenceHashMapTests -> private <V> StopWatch timeMultiThreaded(String id, final Map<Integer, V> map, 			ValueFactory<V> factory) throws InterruptedException;1356735495;Time a multi-threaded access to a cache.__@param cache the cache to test_@return the timing stopwatch_@throws InterruptedException;private <V> StopWatch timeMultiThreaded(String id, final Map<Integer, V> map,_			ValueFactory<V> factory) throws InterruptedException {_		StopWatch stopWatch = new StopWatch(id)__		for (int i = 0_ i < 500_ i++) {_			map.put(i, factory.newValue(i))__		}_		Thread[] threads = new Thread[30]__		stopWatch.start("Running threads")__		for (int threadIndex = 0_ threadIndex < threads.length_ threadIndex++) {_			threads[threadIndex] = new Thread("Cache access thread " + threadIndex) {__				@Override_				public void run() {_					for (int j = 0_ j < 1000_ j++) {_						for (int i = 0_ i < 1000_ i++) {_							map.get(i)__						}_					}_				}__			}__		}_		for (int i = 0_ i < threads.length_ i++) {_			threads[i].start()__		}__		for (int i = 0_ i < threads.length_ i++) {_			if (threads[i].isAlive()) {_				threads[i].join(2000)__			}_		}_		stopWatch.stop()__		return stopWatch__	};time,a,multi,threaded,access,to,a,cache,param,cache,the,cache,to,test,return,the,timing,stopwatch,throws,interrupted,exception;private,v,stop,watch,time,multi,threaded,string,id,final,map,integer,v,map,value,factory,v,factory,throws,interrupted,exception,stop,watch,stop,watch,new,stop,watch,id,for,int,i,0,i,500,i,map,put,i,factory,new,value,i,thread,threads,new,thread,30,stop,watch,start,running,threads,for,int,thread,index,0,thread,index,threads,length,thread,index,threads,thread,index,new,thread,cache,access,thread,thread,index,override,public,void,run,for,int,j,0,j,1000,j,for,int,i,0,i,1000,i,map,get,i,for,int,i,0,i,threads,length,i,threads,i,start,for,int,i,0,i,threads,length,i,if,threads,i,is,alive,threads,i,join,2000,stop,watch,stop,return,stop,watch
ConcurrentReferenceHashMapTests -> private <V> StopWatch timeMultiThreaded(String id, final Map<Integer, V> map, 			ValueFactory<V> factory) throws InterruptedException;1390260938;Time a multi-threaded access to a cache._@return the timing stopwatch;private <V> StopWatch timeMultiThreaded(String id, final Map<Integer, V> map,_			ValueFactory<V> factory) throws InterruptedException {__		StopWatch stopWatch = new StopWatch(id)__		for (int i = 0_ i < 500_ i++) {_			map.put(i, factory.newValue(i))__		}_		Thread[] threads = new Thread[30]__		stopWatch.start("Running threads")__		for (int threadIndex = 0_ threadIndex < threads.length_ threadIndex++) {_			threads[threadIndex] = new Thread("Cache access thread " + threadIndex) {_				@Override_				public void run() {_					for (int j = 0_ j < 1000_ j++) {_						for (int i = 0_ i < 1000_ i++) {_							map.get(i)__						}_					}_				}_			}__		}_		for (Thread thread : threads) {_			thread.start()__		}__		for (Thread thread : threads) {_			if (thread.isAlive()) {_				thread.join(2000)__			}_		}_		stopWatch.stop()__		return stopWatch__	};time,a,multi,threaded,access,to,a,cache,return,the,timing,stopwatch;private,v,stop,watch,time,multi,threaded,string,id,final,map,integer,v,map,value,factory,v,factory,throws,interrupted,exception,stop,watch,stop,watch,new,stop,watch,id,for,int,i,0,i,500,i,map,put,i,factory,new,value,i,thread,threads,new,thread,30,stop,watch,start,running,threads,for,int,thread,index,0,thread,index,threads,length,thread,index,threads,thread,index,new,thread,cache,access,thread,thread,index,override,public,void,run,for,int,j,0,j,1000,j,for,int,i,0,i,1000,i,map,get,i,for,thread,thread,threads,thread,start,for,thread,thread,threads,if,thread,is,alive,thread,join,2000,stop,watch,stop,return,stop,watch
ConcurrentReferenceHashMapTests -> private <V> StopWatch timeMultiThreaded(String id, final Map<Integer, V> map, 			ValueFactory<V> factory) throws InterruptedException;1467730834;Time a multi-threaded access to a cache._@return the timing stopwatch;private <V> StopWatch timeMultiThreaded(String id, final Map<Integer, V> map,_			ValueFactory<V> factory) throws InterruptedException {__		StopWatch stopWatch = new StopWatch(id)__		for (int i = 0_ i < 500_ i++) {_			map.put(i, factory.newValue(i))__		}_		Thread[] threads = new Thread[30]__		stopWatch.start("Running threads")__		for (int threadIndex = 0_ threadIndex < threads.length_ threadIndex++) {_			threads[threadIndex] = new Thread("Cache access thread " + threadIndex) {_				@Override_				public void run() {_					for (int j = 0_ j < 1000_ j++) {_						for (int i = 0_ i < 1000_ i++) {_							map.get(i)__						}_					}_				}_			}__		}_		for (Thread thread : threads) {_			thread.start()__		}__		for (Thread thread : threads) {_			if (thread.isAlive()) {_				thread.join(2000)__			}_		}_		stopWatch.stop()__		return stopWatch__	};time,a,multi,threaded,access,to,a,cache,return,the,timing,stopwatch;private,v,stop,watch,time,multi,threaded,string,id,final,map,integer,v,map,value,factory,v,factory,throws,interrupted,exception,stop,watch,stop,watch,new,stop,watch,id,for,int,i,0,i,500,i,map,put,i,factory,new,value,i,thread,threads,new,thread,30,stop,watch,start,running,threads,for,int,thread,index,0,thread,index,threads,length,thread,index,threads,thread,index,new,thread,cache,access,thread,thread,index,override,public,void,run,for,int,j,0,j,1000,j,for,int,i,0,i,1000,i,map,get,i,for,thread,thread,threads,thread,start,for,thread,thread,threads,if,thread,is,alive,thread,join,2000,stop,watch,stop,return,stop,watch
ConcurrentReferenceHashMapTests -> private <V> StopWatch timeMultiThreaded(String id, final Map<Integer, V> map, 			ValueFactory<V> factory) throws InterruptedException;1496242568;Time a multi-threaded access to a cache._@return the timing stopwatch;private <V> StopWatch timeMultiThreaded(String id, final Map<Integer, V> map,_			ValueFactory<V> factory) throws InterruptedException {__		StopWatch stopWatch = new StopWatch(id)__		for (int i = 0_ i < 500_ i++) {_			map.put(i, factory.newValue(i))__		}_		Thread[] threads = new Thread[30]__		stopWatch.start("Running threads")__		for (int threadIndex = 0_ threadIndex < threads.length_ threadIndex++) {_			threads[threadIndex] = new Thread("Cache access thread " + threadIndex) {_				@Override_				public void run() {_					for (int j = 0_ j < 1000_ j++) {_						for (int i = 0_ i < 1000_ i++) {_							map.get(i)__						}_					}_				}_			}__		}_		for (Thread thread : threads) {_			thread.start()__		}__		for (Thread thread : threads) {_			if (thread.isAlive()) {_				thread.join(2000)__			}_		}_		stopWatch.stop()__		return stopWatch__	};time,a,multi,threaded,access,to,a,cache,return,the,timing,stopwatch;private,v,stop,watch,time,multi,threaded,string,id,final,map,integer,v,map,value,factory,v,factory,throws,interrupted,exception,stop,watch,stop,watch,new,stop,watch,id,for,int,i,0,i,500,i,map,put,i,factory,new,value,i,thread,threads,new,thread,30,stop,watch,start,running,threads,for,int,thread,index,0,thread,index,threads,length,thread,index,threads,thread,index,new,thread,cache,access,thread,thread,index,override,public,void,run,for,int,j,0,j,1000,j,for,int,i,0,i,1000,i,map,get,i,for,thread,thread,threads,thread,start,for,thread,thread,threads,if,thread,is,alive,thread,join,2000,stop,watch,stop,return,stop,watch
ConcurrentReferenceHashMapTests -> private <V> StopWatch timeMultiThreaded(String id, final Map<Integer, V> map, 			ValueFactory<V> factory) throws InterruptedException;1521044224;Time a multi-threaded access to a cache._@return the timing stopwatch;private <V> StopWatch timeMultiThreaded(String id, final Map<Integer, V> map,_			ValueFactory<V> factory) throws InterruptedException {__		StopWatch stopWatch = new StopWatch(id)__		for (int i = 0_ i < 500_ i++) {_			map.put(i, factory.newValue(i))__		}_		Thread[] threads = new Thread[30]__		stopWatch.start("Running threads")__		for (int threadIndex = 0_ threadIndex < threads.length_ threadIndex++) {_			threads[threadIndex] = new Thread("Cache access thread " + threadIndex) {_				@Override_				public void run() {_					for (int j = 0_ j < 1000_ j++) {_						for (int i = 0_ i < 1000_ i++) {_							map.get(i)__						}_					}_				}_			}__		}_		for (Thread thread : threads) {_			thread.start()__		}__		for (Thread thread : threads) {_			if (thread.isAlive()) {_				thread.join(2000)__			}_		}_		stopWatch.stop()__		return stopWatch__	};time,a,multi,threaded,access,to,a,cache,return,the,timing,stopwatch;private,v,stop,watch,time,multi,threaded,string,id,final,map,integer,v,map,value,factory,v,factory,throws,interrupted,exception,stop,watch,stop,watch,new,stop,watch,id,for,int,i,0,i,500,i,map,put,i,factory,new,value,i,thread,threads,new,thread,30,stop,watch,start,running,threads,for,int,thread,index,0,thread,index,threads,length,thread,index,threads,thread,index,new,thread,cache,access,thread,thread,index,override,public,void,run,for,int,j,0,j,1000,j,for,int,i,0,i,1000,i,map,get,i,for,thread,thread,threads,thread,start,for,thread,thread,threads,if,thread,is,alive,thread,join,2000,stop,watch,stop,return,stop,watch
ConcurrentReferenceHashMapTests -> private <V> StopWatch timeMultiThreaded(String id, final Map<Integer, V> map, 			ValueFactory<V> factory) throws InterruptedException;1522231598;Time a multi-threaded access to a cache._@return the timing stopwatch;private <V> StopWatch timeMultiThreaded(String id, final Map<Integer, V> map,_			ValueFactory<V> factory) throws InterruptedException {__		StopWatch stopWatch = new StopWatch(id)__		for (int i = 0_ i < 500_ i++) {_			map.put(i, factory.newValue(i))__		}_		Thread[] threads = new Thread[30]__		stopWatch.start("Running threads")__		for (int threadIndex = 0_ threadIndex < threads.length_ threadIndex++) {_			threads[threadIndex] = new Thread("Cache access thread " + threadIndex) {_				@Override_				public void run() {_					for (int j = 0_ j < 1000_ j++) {_						for (int i = 0_ i < 1000_ i++) {_							map.get(i)__						}_					}_				}_			}__		}_		for (Thread thread : threads) {_			thread.start()__		}__		for (Thread thread : threads) {_			if (thread.isAlive()) {_				thread.join(2000)__			}_		}_		stopWatch.stop()__		return stopWatch__	};time,a,multi,threaded,access,to,a,cache,return,the,timing,stopwatch;private,v,stop,watch,time,multi,threaded,string,id,final,map,integer,v,map,value,factory,v,factory,throws,interrupted,exception,stop,watch,stop,watch,new,stop,watch,id,for,int,i,0,i,500,i,map,put,i,factory,new,value,i,thread,threads,new,thread,30,stop,watch,start,running,threads,for,int,thread,index,0,thread,index,threads,length,thread,index,threads,thread,index,new,thread,cache,access,thread,thread,index,override,public,void,run,for,int,j,0,j,1000,j,for,int,i,0,i,1000,i,map,get,i,for,thread,thread,threads,thread,start,for,thread,thread,threads,if,thread,is,alive,thread,join,2000,stop,watch,stop,return,stop,watch
ConcurrentReferenceHashMapTests -> private <V> StopWatch timeMultiThreaded(String id, final Map<Integer, V> map, 			ValueFactory<V> factory) throws InterruptedException;1542613849;Time a multi-threaded access to a cache._@return the timing stopwatch;private <V> StopWatch timeMultiThreaded(String id, final Map<Integer, V> map,_			ValueFactory<V> factory) throws InterruptedException {__		StopWatch stopWatch = new StopWatch(id)__		for (int i = 0_ i < 500_ i++) {_			map.put(i, factory.newValue(i))__		}_		Thread[] threads = new Thread[30]__		stopWatch.start("Running threads")__		for (int threadIndex = 0_ threadIndex < threads.length_ threadIndex++) {_			threads[threadIndex] = new Thread("Cache access thread " + threadIndex) {_				@Override_				public void run() {_					for (int j = 0_ j < 1000_ j++) {_						for (int i = 0_ i < 1000_ i++) {_							map.get(i)__						}_					}_				}_			}__		}_		for (Thread thread : threads) {_			thread.start()__		}__		for (Thread thread : threads) {_			if (thread.isAlive()) {_				thread.join(2000)__			}_		}_		stopWatch.stop()__		return stopWatch__	};time,a,multi,threaded,access,to,a,cache,return,the,timing,stopwatch;private,v,stop,watch,time,multi,threaded,string,id,final,map,integer,v,map,value,factory,v,factory,throws,interrupted,exception,stop,watch,stop,watch,new,stop,watch,id,for,int,i,0,i,500,i,map,put,i,factory,new,value,i,thread,threads,new,thread,30,stop,watch,start,running,threads,for,int,thread,index,0,thread,index,threads,length,thread,index,threads,thread,index,new,thread,cache,access,thread,thread,index,override,public,void,run,for,int,j,0,j,1000,j,for,int,i,0,i,1000,i,map,get,i,for,thread,thread,threads,thread,start,for,thread,thread,threads,if,thread,is,alive,thread,join,2000,stop,watch,stop,return,stop,watch
